diff --git a/.cvsignore b/.cvsignore
deleted file mode 100644
index 081a43c..0000000
--- a/.cvsignore
+++ /dev/null
@@ -1,16 +0,0 @@
-*.asm
-*.d
-*.sym
-_*
-kernel
-user1
-userfs
-usertests
-xv6.img
-vectors.S
-bochsout.txt
-bootblock
-bootother
-bootother.out
-parport.out
-fmt
diff --git a/.dir-locals.el b/.dir-locals.el
deleted file mode 100644
index da72247..0000000
--- a/.dir-locals.el
+++ /dev/null
@@ -1,4 +0,0 @@
-((c-mode
-  (indent-tabs-mode . nil)
-  (c-file-style . "bsd")
-  (c-basic-offset . 2)))
diff --git a/.gdbinit.tmpl b/.gdbinit.tmpl
index f71681a..ac7a259 100644
--- a/.gdbinit.tmpl
+++ b/.gdbinit.tmpl
@@ -24,4 +24,4 @@ echo + target remote localhost:1234\n
 target remote localhost:1234
 
 echo + symbol-file kernel\n
-symbol-file kernel
+symbol-file kernel
\ No newline at end of file
diff --git a/.gitignore b/.gitignore
deleted file mode 100644
index 3e2c9de..0000000
--- a/.gitignore
+++ /dev/null
@@ -1,16 +0,0 @@
-*~
-_*
-*.o
-*.d
-*.asm
-*.sym
-*.img
-vectors.S
-bootblock
-entryother
-initcode
-initcode.out
-kernel
-kernelmemfs
-mkfs
-.gdbinit
diff --git a/.idea/xv6.iml b/.idea/xv6.iml
index 5aac3dd..771e54c 100644
--- a/.idea/xv6.iml
+++ b/.idea/xv6.iml
@@ -1,2 +1,2 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<module classpath="External" external.linked.project.id="xv6" external.linked.project.path="C:\Users\Kotori\Desktop\Code Projects\School\xv6\xv6" external.root.project.path="$MODULE_DIR$" external.system.id="Makefile" type="CPP_MODULE" version="4" />
\ No newline at end of file
+<module classpath="External" type="CPP_MODULE" version="4" />
\ No newline at end of file
diff --git a/LICENSE b/LICENSE
index 422c0cc..4ec362c 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,6 +1,6 @@
 The xv6 software is:
 
-Copyright (c) 2006-2018 Frans Kaashoek, Robert Morris, Russ Cox,
+Copyright (c) 2006-2017 Frans Kaashoek, Robert Morris, Russ Cox,
                         Massachusetts Institute of Technology
 
 Permission is hereby granted, free of charge, to any person obtaining
diff --git a/Makefile b/Makefile
index 04d74d5..be7fd50 100644
--- a/Makefile
+++ b/Makefile
@@ -27,6 +27,7 @@ OBJS = \
 	uart.o\
 	vectors.o\
 	vm.o\
+	shm.o\
 
 # Cross-compiling (e.g., on Mac OS X)
 # TOOLPREFIX = i386-jos-elf
@@ -77,20 +78,13 @@ LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
 CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+#CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
 LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
 
-# Disable PIE when possible (for Ubuntu 16.10 toolchain)
-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
-CFLAGS += -fno-pie -no-pie
-endif
-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
-CFLAGS += -fno-pie -nopie
-endif
-
-xv6.img: bootblock kernel
+xv6.img: bootblock kernel fs.img
 	dd if=/dev/zero of=xv6.img count=10000
 	dd if=bootblock of=xv6.img conv=notrunc
 	dd if=kernel of=xv6.img seek=1 conv=notrunc
@@ -141,19 +135,19 @@ tags: $(OBJS) entryother.S _init
 	etags *.S *.c
 
 vectors.S: vectors.pl
-	./vectors.pl > vectors.S
+	perl vectors.pl > vectors.S
 
-ULIB = ulib.o usys.o printf.o umalloc.o
+ULIB = ulib.o usys.o printf.o umalloc.o uspinlock.o
 
 _%: %.o $(ULIB)
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0x1000 -o $@ $^
 	$(OBJDUMP) -S $@ > $*.asm
 	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
 
 _forktest: forktest.o $(ULIB)
 	# forktest has less library code linked in - needs to be small
 	# in order to be able to max out the proc table.
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0x1000 -o _forktest forktest.o ulib.o usys.o
 	$(OBJDUMP) -S _forktest > forktest.asm
 
 mkfs: mkfs.c fs.h
@@ -181,7 +175,10 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
-	_lab1\
+	_shm_cnt\
+	_null\
+	_lab3\
+	_lab3p2\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -191,8 +188,8 @@ fs.img: mkfs README $(UPROGS)
 clean: 
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
 	*.o *.d *.asm *.sym vectors.S bootblock entryother \
-	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
-	xv6memfs.img mkfs .gdbinit \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs mkfs \
+	.gdbinit \
 	$(UPROGS)
 
 # make a printout
@@ -218,7 +215,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
@@ -251,7 +248,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
-	printf.c umalloc.c\
+	printf.c umalloc.c uspinlock.c shm_cnt.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
diff --git a/README b/README
index 923e0a4..b82e8d2 100644
--- a/README
+++ b/README
@@ -1,7 +1,3 @@
-NOTE: we have stopped maintaining the x86 version of xv6, and switched
-our efforts to the RISC-V version
-(https://github.com/mit-pdos/xv6-riscv.git)
-
 xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
 Version 6 (v6).  xv6 loosely follows the structure and style of v6,
 but is implemented for a modern x86-based multiprocessor using ANSI C.
@@ -10,7 +6,7 @@ ACKNOWLEDGMENTS
 
 xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
 to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
-2000)). See also https://pdos.csail.mit.edu/6.828/, which
+2000)). See also http://pdos.csail.mit.edu/6.828/2016/xv6.html, which
 provides pointers to on-line resources for v6.
 
 xv6 borrows code from the following sources:
@@ -24,28 +20,30 @@ locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
 Clements.
 
 We are also grateful for the bug reports and patches contributed by Silas
-Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,
-Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter
-Froehlich, Yakir Goaron,Shivam Handa, Bryan Henry, Jim Huang, Alexander
-Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller, Eddie Kohler, Austin
-Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi
-Merimovich, Mark Morrissey, mtasm, Joel Nider, Greg Price, Ayan Shafqat,
-Eldar Sehayek, Yongming Shen, Cam Tenny, tyfkda, Rafael Ubal, Warren
-Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
-Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang Wei.
+Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, Nelson Elhage,
+Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter Froehlich, Yakir Goaron,
+Shivam Handa, Bryan Henry, Jim Huang, Alexander Kapshuk, Anders Kaseorg,
+kehao95, Wolfgang Keller, Eddie Kohler, Austin Liew, Imbar Marinescu, Yandong
+Mao, Hitoshi Mitake, Carmi Merimovich, Joel Nider, Greg Price, Ayan Shafqat,
+Eldar Sehayek, Yongming Shen, Cam Tenny, Rafael Ubal, Warren Toomey, Stephen Tu,
+Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas Wolovick, Grant Wu, Jindong
+Zhang, Icenowy Zheng, and Zou Chang Wei.
 
 The code in the files that constitute xv6 is
-Copyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.
+Copyright 2006-2016 Frans Kaashoek, Robert Morris, and Russ Cox.
 
 ERROR REPORTS
 
-We don't process error reports (see note on top of this file).
+Please send errors and suggestions to Frans Kaashoek and Robert Morris
+(kaashoek,rtm@mit.edu). The main purpose of xv6 is as a teaching
+operating system for MIT's 6.828, so we are more interested in
+simplifications and clarifications than new features.
 
 BUILDING AND RUNNING XV6
 
 To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
 "make". On non-x86 or non-ELF machines (like OS X, even on x86), you
 will need to install a cross-compiler gcc suite capable of producing
-x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
+x86 ELF binaries. See http://pdos.csail.mit.edu/6.828/2016/tools.html.
 Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
-simulator and run "make qemu".
\ No newline at end of file
+simulator and run "make qemu".
diff --git a/_cat b/_cat
new file mode 100644
index 0000000..cfaa8f4
Binary files /dev/null and b/_cat differ
diff --git a/_echo b/_echo
new file mode 100644
index 0000000..4442637
Binary files /dev/null and b/_echo differ
diff --git a/_forktest b/_forktest
new file mode 100644
index 0000000..8542b3c
Binary files /dev/null and b/_forktest differ
diff --git a/_grep b/_grep
new file mode 100644
index 0000000..facda7a
Binary files /dev/null and b/_grep differ
diff --git a/_init b/_init
new file mode 100644
index 0000000..395d671
Binary files /dev/null and b/_init differ
diff --git a/_kill b/_kill
new file mode 100644
index 0000000..edfedd8
Binary files /dev/null and b/_kill differ
diff --git a/_ln b/_ln
new file mode 100644
index 0000000..e9f132b
Binary files /dev/null and b/_ln differ
diff --git a/_ls b/_ls
new file mode 100644
index 0000000..9c5bda8
Binary files /dev/null and b/_ls differ
diff --git a/_mkdir b/_mkdir
new file mode 100644
index 0000000..c420bc8
Binary files /dev/null and b/_mkdir differ
diff --git a/_null b/_null
new file mode 100644
index 0000000..02f3d6d
Binary files /dev/null and b/_null differ
diff --git a/_rm b/_rm
new file mode 100644
index 0000000..208c5ca
Binary files /dev/null and b/_rm differ
diff --git a/_sh b/_sh
new file mode 100644
index 0000000..17e639e
Binary files /dev/null and b/_sh differ
diff --git a/_shm_cnt b/_shm_cnt
new file mode 100644
index 0000000..a0ac31e
Binary files /dev/null and b/_shm_cnt differ
diff --git a/_stressfs b/_stressfs
new file mode 100644
index 0000000..26a491c
Binary files /dev/null and b/_stressfs differ
diff --git a/_usertests b/_usertests
new file mode 100644
index 0000000..d6ed5f9
Binary files /dev/null and b/_usertests differ
diff --git a/_wc b/_wc
new file mode 100644
index 0000000..6d1738a
Binary files /dev/null and b/_wc differ
diff --git a/_zombie b/_zombie
new file mode 100644
index 0000000..8f081ce
Binary files /dev/null and b/_zombie differ
diff --git a/asm.h b/asm.h
index b8a7353..68210d7 100644
--- a/asm.h
+++ b/asm.h
@@ -14,5 +14,8 @@
                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
 
 #define STA_X     0x8       // Executable segment
+#define STA_E     0x4       // Expand down (non-executable segments)
+#define STA_C     0x4       // Conforming code segment (executable only)
 #define STA_W     0x2       // Writeable (non-executable segments)
 #define STA_R     0x2       // Readable (executable segments)
+#define STA_A     0x1       // Accessed
diff --git a/bio.d b/bio.d
new file mode 100644
index 0000000..b4bbd30
--- /dev/null
+++ b/bio.d
@@ -0,0 +1,2 @@
+bio.o: bio.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h \
+ sleeplock.h fs.h buf.h
diff --git a/bio.o b/bio.o
new file mode 100644
index 0000000..ffb2b32
Binary files /dev/null and b/bio.o differ
diff --git a/bootasm.d b/bootasm.d
new file mode 100644
index 0000000..3b3dc19
--- /dev/null
+++ b/bootasm.d
@@ -0,0 +1 @@
+bootasm.o: bootasm.S asm.h memlayout.h mmu.h
diff --git a/bootasm.o b/bootasm.o
new file mode 100644
index 0000000..f960dd1
Binary files /dev/null and b/bootasm.o differ
diff --git a/bootblock b/bootblock
new file mode 100644
index 0000000..ff63c64
Binary files /dev/null and b/bootblock differ
diff --git a/bootblock.asm b/bootblock.asm
new file mode 100644
index 0000000..bf77419
--- /dev/null
+++ b/bootblock.asm
@@ -0,0 +1,353 @@
+
+bootblock.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00007c00 <start>:
+# with %cs=0 %ip=7c00.
+
+.code16                       # Assemble for 16-bit mode
+.globl start
+start:
+  cli                         # BIOS enabled interrupts; disable
+    7c00:	fa                   	cli    
+
+  # Zero data segment registers DS, ES, and SS.
+  xorw    %ax,%ax             # Set %ax to zero
+    7c01:	31 c0                	xor    %eax,%eax
+  movw    %ax,%ds             # -> Data Segment
+    7c03:	8e d8                	mov    %eax,%ds
+  movw    %ax,%es             # -> Extra Segment
+    7c05:	8e c0                	mov    %eax,%es
+  movw    %ax,%ss             # -> Stack Segment
+    7c07:	8e d0                	mov    %eax,%ss
+
+00007c09 <seta20.1>:
+
+  # Physical address line A20 is tied to zero so that the first PCs 
+  # with 2 MB would run software that assumed 1 MB.  Undo that.
+seta20.1:
+  inb     $0x64,%al               # Wait for not busy
+    7c09:	e4 64                	in     $0x64,%al
+  testb   $0x2,%al
+    7c0b:	a8 02                	test   $0x2,%al
+  jnz     seta20.1
+    7c0d:	75 fa                	jne    7c09 <seta20.1>
+
+  movb    $0xd1,%al               # 0xd1 -> port 0x64
+    7c0f:	b0 d1                	mov    $0xd1,%al
+  outb    %al,$0x64
+    7c11:	e6 64                	out    %al,$0x64
+
+00007c13 <seta20.2>:
+
+seta20.2:
+  inb     $0x64,%al               # Wait for not busy
+    7c13:	e4 64                	in     $0x64,%al
+  testb   $0x2,%al
+    7c15:	a8 02                	test   $0x2,%al
+  jnz     seta20.2
+    7c17:	75 fa                	jne    7c13 <seta20.2>
+
+  movb    $0xdf,%al               # 0xdf -> port 0x60
+    7c19:	b0 df                	mov    $0xdf,%al
+  outb    %al,$0x60
+    7c1b:	e6 60                	out    %al,$0x60
+
+  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+  # virtual addresses map directly to physical addresses so that the
+  # effective memory map doesn't change during the transition.
+  lgdt    gdtdesc
+    7c1d:	0f 01 16             	lgdtl  (%esi)
+    7c20:	78 7c                	js     7c9e <readsect+0xe>
+  movl    %cr0, %eax
+    7c22:	0f 20 c0             	mov    %cr0,%eax
+  orl     $CR0_PE, %eax
+    7c25:	66 83 c8 01          	or     $0x1,%ax
+  movl    %eax, %cr0
+    7c29:	0f 22 c0             	mov    %eax,%cr0
+
+//PAGEBREAK!
+  # Complete the transition to 32-bit protected mode by using a long jmp
+  # to reload %cs and %eip.  The segment descriptors are set up with no
+  # translation, so that the mapping is still the identity mapping.
+  ljmp    $(SEG_KCODE<<3), $start32
+    7c2c:	ea                   	.byte 0xea
+    7c2d:	31 7c 08 00          	xor    %edi,0x0(%eax,%ecx,1)
+
+00007c31 <start32>:
+
+.code32  # Tell assembler to generate 32-bit code now.
+start32:
+  # Set up the protected-mode data segment registers
+  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+    7c31:	66 b8 10 00          	mov    $0x10,%ax
+  movw    %ax, %ds                # -> DS: Data Segment
+    7c35:	8e d8                	mov    %eax,%ds
+  movw    %ax, %es                # -> ES: Extra Segment
+    7c37:	8e c0                	mov    %eax,%es
+  movw    %ax, %ss                # -> SS: Stack Segment
+    7c39:	8e d0                	mov    %eax,%ss
+  movw    $0, %ax                 # Zero segments not ready for use
+    7c3b:	66 b8 00 00          	mov    $0x0,%ax
+  movw    %ax, %fs                # -> FS
+    7c3f:	8e e0                	mov    %eax,%fs
+  movw    %ax, %gs                # -> GS
+    7c41:	8e e8                	mov    %eax,%gs
+
+  # Set up the stack pointer and call into C.
+  movl    $start, %esp
+    7c43:	bc 00 7c 00 00       	mov    $0x7c00,%esp
+  call    bootmain
+    7c48:	e8 e2 00 00 00       	call   7d2f <bootmain>
+
+  # If bootmain returns (it shouldn't), trigger a Bochs
+  # breakpoint if running under Bochs, then loop.
+  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
+    7c4d:	66 b8 00 8a          	mov    $0x8a00,%ax
+  movw    %ax, %dx
+    7c51:	66 89 c2             	mov    %ax,%dx
+  outw    %ax, %dx
+    7c54:	66 ef                	out    %ax,(%dx)
+  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
+    7c56:	66 b8 e0 8a          	mov    $0x8ae0,%ax
+  outw    %ax, %dx
+    7c5a:	66 ef                	out    %ax,(%dx)
+
+00007c5c <spin>:
+spin:
+  jmp     spin
+    7c5c:	eb fe                	jmp    7c5c <spin>
+    7c5e:	66 90                	xchg   %ax,%ax
+
+00007c60 <gdt>:
+	...
+    7c68:	ff                   	(bad)  
+    7c69:	ff 00                	incl   (%eax)
+    7c6b:	00 00                	add    %al,(%eax)
+    7c6d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
+    7c74:	00                   	.byte 0x0
+    7c75:	92                   	xchg   %eax,%edx
+    7c76:	cf                   	iret   
+	...
+
+00007c78 <gdtdesc>:
+    7c78:	17                   	pop    %ss
+    7c79:	00 60 7c             	add    %ah,0x7c(%eax)
+	...
+
+00007c7e <waitdisk>:
+  entry();
+}
+
+void
+waitdisk(void)
+{
+    7c7e:	55                   	push   %ebp
+    7c7f:	89 e5                	mov    %esp,%ebp
+static inline uchar
+inb(ushort port)
+{
+  uchar data;
+
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+    7c81:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7c86:	ec                   	in     (%dx),%al
+  // Wait for disk ready.
+  while((inb(0x1F7) & 0xC0) != 0x40)
+    7c87:	83 e0 c0             	and    $0xffffffc0,%eax
+    7c8a:	3c 40                	cmp    $0x40,%al
+    7c8c:	75 f8                	jne    7c86 <waitdisk+0x8>
+    ;
+}
+    7c8e:	5d                   	pop    %ebp
+    7c8f:	c3                   	ret    
+
+00007c90 <readsect>:
+
+// Read a single sector at offset into dst.
+void
+readsect(void *dst, uint offset)
+{
+    7c90:	55                   	push   %ebp
+    7c91:	89 e5                	mov    %esp,%ebp
+    7c93:	57                   	push   %edi
+    7c94:	53                   	push   %ebx
+    7c95:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  // Issue command.
+  waitdisk();
+    7c98:	e8 e1 ff ff ff       	call   7c7e <waitdisk>
+}
+
+static inline void
+outb(ushort port, uchar data)
+{
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+    7c9d:	ba f2 01 00 00       	mov    $0x1f2,%edx
+    7ca2:	b8 01 00 00 00       	mov    $0x1,%eax
+    7ca7:	ee                   	out    %al,(%dx)
+    7ca8:	b2 f3                	mov    $0xf3,%dl
+    7caa:	89 d8                	mov    %ebx,%eax
+    7cac:	ee                   	out    %al,(%dx)
+    7cad:	0f b6 c7             	movzbl %bh,%eax
+    7cb0:	b2 f4                	mov    $0xf4,%dl
+    7cb2:	ee                   	out    %al,(%dx)
+  outb(0x1F2, 1);   // count = 1
+  outb(0x1F3, offset);
+  outb(0x1F4, offset >> 8);
+  outb(0x1F5, offset >> 16);
+    7cb3:	89 d8                	mov    %ebx,%eax
+    7cb5:	c1 e8 10             	shr    $0x10,%eax
+    7cb8:	b2 f5                	mov    $0xf5,%dl
+    7cba:	ee                   	out    %al,(%dx)
+  outb(0x1F6, (offset >> 24) | 0xE0);
+    7cbb:	c1 eb 18             	shr    $0x18,%ebx
+    7cbe:	89 d8                	mov    %ebx,%eax
+    7cc0:	83 c8 e0             	or     $0xffffffe0,%eax
+    7cc3:	b2 f6                	mov    $0xf6,%dl
+    7cc5:	ee                   	out    %al,(%dx)
+    7cc6:	b2 f7                	mov    $0xf7,%dl
+    7cc8:	b8 20 00 00 00       	mov    $0x20,%eax
+    7ccd:	ee                   	out    %al,(%dx)
+  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
+
+  // Read data.
+  waitdisk();
+    7cce:	e8 ab ff ff ff       	call   7c7e <waitdisk>
+  asm volatile("cld; rep insl" :
+    7cd3:	8b 7d 08             	mov    0x8(%ebp),%edi
+    7cd6:	b9 80 00 00 00       	mov    $0x80,%ecx
+    7cdb:	ba f0 01 00 00       	mov    $0x1f0,%edx
+    7ce0:	fc                   	cld    
+    7ce1:	f3 6d                	rep insl (%dx),%es:(%edi)
+  insl(0x1F0, dst, SECTSIZE/4);
+}
+    7ce3:	5b                   	pop    %ebx
+    7ce4:	5f                   	pop    %edi
+    7ce5:	5d                   	pop    %ebp
+    7ce6:	c3                   	ret    
+
+00007ce7 <readseg>:
+
+// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
+// Might copy more than asked.
+void
+readseg(uchar* pa, uint count, uint offset)
+{
+    7ce7:	55                   	push   %ebp
+    7ce8:	89 e5                	mov    %esp,%ebp
+    7cea:	57                   	push   %edi
+    7ceb:	56                   	push   %esi
+    7cec:	53                   	push   %ebx
+    7ced:	83 ec 08             	sub    $0x8,%esp
+    7cf0:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    7cf3:	8b 75 10             	mov    0x10(%ebp),%esi
+  uchar* epa;
+
+  epa = pa + count;
+    7cf6:	89 df                	mov    %ebx,%edi
+    7cf8:	03 7d 0c             	add    0xc(%ebp),%edi
+
+  // Round down to sector boundary.
+  pa -= offset % SECTSIZE;
+    7cfb:	89 f0                	mov    %esi,%eax
+    7cfd:	25 ff 01 00 00       	and    $0x1ff,%eax
+    7d02:	29 c3                	sub    %eax,%ebx
+
+  // Translate from bytes to sectors; kernel starts at sector 1.
+  offset = (offset / SECTSIZE) + 1;
+    7d04:	c1 ee 09             	shr    $0x9,%esi
+    7d07:	83 c6 01             	add    $0x1,%esi
+
+  // If this is too slow, we could read lots of sectors at a time.
+  // We'd write more to memory than asked, but it doesn't matter --
+  // we load in increasing order.
+  for(; pa < epa; pa += SECTSIZE, offset++)
+    7d0a:	39 df                	cmp    %ebx,%edi
+    7d0c:	76 19                	jbe    7d27 <readseg+0x40>
+    readsect(pa, offset);
+    7d0e:	89 74 24 04          	mov    %esi,0x4(%esp)
+    7d12:	89 1c 24             	mov    %ebx,(%esp)
+    7d15:	e8 76 ff ff ff       	call   7c90 <readsect>
+  for(; pa < epa; pa += SECTSIZE, offset++)
+    7d1a:	81 c3 00 02 00 00    	add    $0x200,%ebx
+    7d20:	83 c6 01             	add    $0x1,%esi
+    7d23:	39 df                	cmp    %ebx,%edi
+    7d25:	77 e7                	ja     7d0e <readseg+0x27>
+}
+    7d27:	83 c4 08             	add    $0x8,%esp
+    7d2a:	5b                   	pop    %ebx
+    7d2b:	5e                   	pop    %esi
+    7d2c:	5f                   	pop    %edi
+    7d2d:	5d                   	pop    %ebp
+    7d2e:	c3                   	ret    
+
+00007d2f <bootmain>:
+{
+    7d2f:	55                   	push   %ebp
+    7d30:	89 e5                	mov    %esp,%ebp
+    7d32:	57                   	push   %edi
+    7d33:	56                   	push   %esi
+    7d34:	53                   	push   %ebx
+    7d35:	83 ec 1c             	sub    $0x1c,%esp
+  readseg((uchar*)elf, 4096, 0);
+    7d38:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+    7d3f:	00 
+    7d40:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+    7d47:	00 
+    7d48:	c7 04 24 00 00 01 00 	movl   $0x10000,(%esp)
+    7d4f:	e8 93 ff ff ff       	call   7ce7 <readseg>
+  if(elf->magic != ELF_MAGIC)
+    7d54:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
+    7d5b:	45 4c 46 
+    7d5e:	75 57                	jne    7db7 <bootmain+0x88>
+  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
+    7d60:	a1 1c 00 01 00       	mov    0x1001c,%eax
+    7d65:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx
+  eph = ph + elf->phnum;
+    7d6b:	0f b7 35 2c 00 01 00 	movzwl 0x1002c,%esi
+    7d72:	c1 e6 05             	shl    $0x5,%esi
+    7d75:	01 de                	add    %ebx,%esi
+  for(; ph < eph; ph++){
+    7d77:	39 f3                	cmp    %esi,%ebx
+    7d79:	73 36                	jae    7db1 <bootmain+0x82>
+    pa = (uchar*)ph->paddr;
+    7d7b:	8b 7b 0c             	mov    0xc(%ebx),%edi
+    readseg(pa, ph->filesz, ph->off);
+    7d7e:	8b 43 04             	mov    0x4(%ebx),%eax
+    7d81:	89 44 24 08          	mov    %eax,0x8(%esp)
+    7d85:	8b 43 10             	mov    0x10(%ebx),%eax
+    7d88:	89 44 24 04          	mov    %eax,0x4(%esp)
+    7d8c:	89 3c 24             	mov    %edi,(%esp)
+    7d8f:	e8 53 ff ff ff       	call   7ce7 <readseg>
+    if(ph->memsz > ph->filesz)
+    7d94:	8b 4b 14             	mov    0x14(%ebx),%ecx
+    7d97:	8b 43 10             	mov    0x10(%ebx),%eax
+    7d9a:	39 c1                	cmp    %eax,%ecx
+    7d9c:	76 0c                	jbe    7daa <bootmain+0x7b>
+      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
+    7d9e:	01 c7                	add    %eax,%edi
+    7da0:	29 c1                	sub    %eax,%ecx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    7da2:	b8 00 00 00 00       	mov    $0x0,%eax
+    7da7:	fc                   	cld    
+    7da8:	f3 aa                	rep stos %al,%es:(%edi)
+  for(; ph < eph; ph++){
+    7daa:	83 c3 20             	add    $0x20,%ebx
+    7dad:	39 de                	cmp    %ebx,%esi
+    7daf:	77 ca                	ja     7d7b <bootmain+0x4c>
+  entry();
+    7db1:	ff 15 18 00 01 00    	call   *0x10018
+}
+    7db7:	83 c4 1c             	add    $0x1c,%esp
+    7dba:	5b                   	pop    %ebx
+    7dbb:	5e                   	pop    %esi
+    7dbc:	5f                   	pop    %edi
+    7dbd:	5d                   	pop    %ebp
+    7dbe:	c3                   	ret    
diff --git a/bootblock.o b/bootblock.o
new file mode 100644
index 0000000..13736fc
Binary files /dev/null and b/bootblock.o differ
diff --git a/bootblockother.o b/bootblockother.o
new file mode 100644
index 0000000..1eab171
Binary files /dev/null and b/bootblockother.o differ
diff --git a/bootmain.d b/bootmain.d
new file mode 100644
index 0000000..b32eaf5
--- /dev/null
+++ b/bootmain.d
@@ -0,0 +1 @@
+bootmain.o: bootmain.c types.h elf.h x86.h memlayout.h
diff --git a/bootmain.o b/bootmain.o
new file mode 100644
index 0000000..0bded56
Binary files /dev/null and b/bootmain.o differ
diff --git a/cat.asm b/cat.asm
new file mode 100644
index 0000000..1a0c1f9
--- /dev/null
+++ b/cat.asm
@@ -0,0 +1,1301 @@
+
+_cat:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+  }
+}
+
+int
+main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	57                   	push   %edi
+    1004:	56                   	push   %esi
+  int fd, i;
+
+  if(argc <= 1){
+    1005:	be 01 00 00 00       	mov    $0x1,%esi
+{
+    100a:	53                   	push   %ebx
+    100b:	83 e4 f0             	and    $0xfffffff0,%esp
+    100e:	83 ec 10             	sub    $0x10,%esp
+    1011:	8b 45 0c             	mov    0xc(%ebp),%eax
+  if(argc <= 1){
+    1014:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+    1018:	8d 58 04             	lea    0x4(%eax),%ebx
+    101b:	7e 5a                	jle    1077 <main+0x77>
+    101d:	8d 76 00             	lea    0x0(%esi),%esi
+    cat(0);
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+    if((fd = open(argv[i], 0)) < 0){
+    1020:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1027:	00 
+    1028:	8b 03                	mov    (%ebx),%eax
+    102a:	89 04 24             	mov    %eax,(%esp)
+    102d:	e8 50 03 00 00       	call   1382 <open>
+    1032:	85 c0                	test   %eax,%eax
+    1034:	89 c7                	mov    %eax,%edi
+    1036:	78 20                	js     1058 <main+0x58>
+      printf(1, "cat: cannot open %s\n", argv[i]);
+      exit();
+    }
+    cat(fd);
+    1038:	89 04 24             	mov    %eax,(%esp)
+  for(i = 1; i < argc; i++){
+    103b:	83 c6 01             	add    $0x1,%esi
+    103e:	83 c3 04             	add    $0x4,%ebx
+    cat(fd);
+    1041:	e8 4a 00 00 00       	call   1090 <cat>
+    close(fd);
+    1046:	89 3c 24             	mov    %edi,(%esp)
+    1049:	e8 1c 03 00 00       	call   136a <close>
+  for(i = 1; i < argc; i++){
+    104e:	3b 75 08             	cmp    0x8(%ebp),%esi
+    1051:	75 cd                	jne    1020 <main+0x20>
+  }
+  exit();
+    1053:	e8 ea 02 00 00       	call   1342 <exit>
+      printf(1, "cat: cannot open %s\n", argv[i]);
+    1058:	8b 03                	mov    (%ebx),%eax
+    105a:	c7 44 24 04 64 18 00 	movl   $0x1864,0x4(%esp)
+    1061:	00 
+    1062:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1069:	89 44 24 08          	mov    %eax,0x8(%esp)
+    106d:	e8 2e 04 00 00       	call   14a0 <printf>
+      exit();
+    1072:	e8 cb 02 00 00       	call   1342 <exit>
+    cat(0);
+    1077:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    107e:	e8 0d 00 00 00       	call   1090 <cat>
+    exit();
+    1083:	e8 ba 02 00 00       	call   1342 <exit>
+    1088:	66 90                	xchg   %ax,%ax
+    108a:	66 90                	xchg   %ax,%ax
+    108c:	66 90                	xchg   %ax,%ax
+    108e:	66 90                	xchg   %ax,%ax
+
+00001090 <cat>:
+{
+    1090:	55                   	push   %ebp
+    1091:	89 e5                	mov    %esp,%ebp
+    1093:	56                   	push   %esi
+    1094:	53                   	push   %ebx
+    1095:	83 ec 10             	sub    $0x10,%esp
+    1098:	8b 75 08             	mov    0x8(%ebp),%esi
+  while((n = read(fd, buf, sizeof(buf))) > 0) {
+    109b:	eb 1f                	jmp    10bc <cat+0x2c>
+    109d:	8d 76 00             	lea    0x0(%esi),%esi
+    if (write(1, buf, n) != n) {
+    10a0:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    10a4:	c7 44 24 04 a0 1b 00 	movl   $0x1ba0,0x4(%esp)
+    10ab:	00 
+    10ac:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10b3:	e8 aa 02 00 00       	call   1362 <write>
+    10b8:	39 d8                	cmp    %ebx,%eax
+    10ba:	75 28                	jne    10e4 <cat+0x54>
+  while((n = read(fd, buf, sizeof(buf))) > 0) {
+    10bc:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+    10c3:	00 
+    10c4:	c7 44 24 04 a0 1b 00 	movl   $0x1ba0,0x4(%esp)
+    10cb:	00 
+    10cc:	89 34 24             	mov    %esi,(%esp)
+    10cf:	e8 86 02 00 00       	call   135a <read>
+    10d4:	83 f8 00             	cmp    $0x0,%eax
+    10d7:	89 c3                	mov    %eax,%ebx
+    10d9:	7f c5                	jg     10a0 <cat+0x10>
+  if(n < 0){
+    10db:	75 20                	jne    10fd <cat+0x6d>
+}
+    10dd:	83 c4 10             	add    $0x10,%esp
+    10e0:	5b                   	pop    %ebx
+    10e1:	5e                   	pop    %esi
+    10e2:	5d                   	pop    %ebp
+    10e3:	c3                   	ret    
+      printf(1, "cat: write error\n");
+    10e4:	c7 44 24 04 41 18 00 	movl   $0x1841,0x4(%esp)
+    10eb:	00 
+    10ec:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10f3:	e8 a8 03 00 00       	call   14a0 <printf>
+      exit();
+    10f8:	e8 45 02 00 00       	call   1342 <exit>
+    printf(1, "cat: read error\n");
+    10fd:	c7 44 24 04 53 18 00 	movl   $0x1853,0x4(%esp)
+    1104:	00 
+    1105:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    110c:	e8 8f 03 00 00       	call   14a0 <printf>
+    exit();
+    1111:	e8 2c 02 00 00       	call   1342 <exit>
+    1116:	66 90                	xchg   %ax,%ax
+    1118:	66 90                	xchg   %ax,%ax
+    111a:	66 90                	xchg   %ax,%ax
+    111c:	66 90                	xchg   %ax,%ax
+    111e:	66 90                	xchg   %ax,%ax
+
+00001120 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1120:	55                   	push   %ebp
+    1121:	89 e5                	mov    %esp,%ebp
+    1123:	8b 45 08             	mov    0x8(%ebp),%eax
+    1126:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1129:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    112a:	89 c2                	mov    %eax,%edx
+    112c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1130:	83 c1 01             	add    $0x1,%ecx
+    1133:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1137:	83 c2 01             	add    $0x1,%edx
+    113a:	84 db                	test   %bl,%bl
+    113c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    113f:	75 ef                	jne    1130 <strcpy+0x10>
+    ;
+  return os;
+}
+    1141:	5b                   	pop    %ebx
+    1142:	5d                   	pop    %ebp
+    1143:	c3                   	ret    
+    1144:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    114a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001150 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1150:	55                   	push   %ebp
+    1151:	89 e5                	mov    %esp,%ebp
+    1153:	8b 55 08             	mov    0x8(%ebp),%edx
+    1156:	53                   	push   %ebx
+    1157:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    115a:	0f b6 02             	movzbl (%edx),%eax
+    115d:	84 c0                	test   %al,%al
+    115f:	74 2d                	je     118e <strcmp+0x3e>
+    1161:	0f b6 19             	movzbl (%ecx),%ebx
+    1164:	38 d8                	cmp    %bl,%al
+    1166:	74 0e                	je     1176 <strcmp+0x26>
+    1168:	eb 2b                	jmp    1195 <strcmp+0x45>
+    116a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1170:	38 c8                	cmp    %cl,%al
+    1172:	75 15                	jne    1189 <strcmp+0x39>
+    p++, q++;
+    1174:	89 d9                	mov    %ebx,%ecx
+    1176:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    1179:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    117c:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    117f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    1183:	84 c0                	test   %al,%al
+    1185:	75 e9                	jne    1170 <strcmp+0x20>
+    1187:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    1189:	29 c8                	sub    %ecx,%eax
+}
+    118b:	5b                   	pop    %ebx
+    118c:	5d                   	pop    %ebp
+    118d:	c3                   	ret    
+    118e:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    1191:	31 c0                	xor    %eax,%eax
+    1193:	eb f4                	jmp    1189 <strcmp+0x39>
+    1195:	0f b6 cb             	movzbl %bl,%ecx
+    1198:	eb ef                	jmp    1189 <strcmp+0x39>
+    119a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000011a0 <strlen>:
+
+uint
+strlen(char *s)
+{
+    11a0:	55                   	push   %ebp
+    11a1:	89 e5                	mov    %esp,%ebp
+    11a3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    11a6:	80 39 00             	cmpb   $0x0,(%ecx)
+    11a9:	74 12                	je     11bd <strlen+0x1d>
+    11ab:	31 d2                	xor    %edx,%edx
+    11ad:	8d 76 00             	lea    0x0(%esi),%esi
+    11b0:	83 c2 01             	add    $0x1,%edx
+    11b3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    11b7:	89 d0                	mov    %edx,%eax
+    11b9:	75 f5                	jne    11b0 <strlen+0x10>
+    ;
+  return n;
+}
+    11bb:	5d                   	pop    %ebp
+    11bc:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    11bd:	31 c0                	xor    %eax,%eax
+}
+    11bf:	5d                   	pop    %ebp
+    11c0:	c3                   	ret    
+    11c1:	eb 0d                	jmp    11d0 <memset>
+    11c3:	90                   	nop
+    11c4:	90                   	nop
+    11c5:	90                   	nop
+    11c6:	90                   	nop
+    11c7:	90                   	nop
+    11c8:	90                   	nop
+    11c9:	90                   	nop
+    11ca:	90                   	nop
+    11cb:	90                   	nop
+    11cc:	90                   	nop
+    11cd:	90                   	nop
+    11ce:	90                   	nop
+    11cf:	90                   	nop
+
+000011d0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    11d0:	55                   	push   %ebp
+    11d1:	89 e5                	mov    %esp,%ebp
+    11d3:	8b 55 08             	mov    0x8(%ebp),%edx
+    11d6:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    11d7:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    11da:	8b 45 0c             	mov    0xc(%ebp),%eax
+    11dd:	89 d7                	mov    %edx,%edi
+    11df:	fc                   	cld    
+    11e0:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    11e2:	89 d0                	mov    %edx,%eax
+    11e4:	5f                   	pop    %edi
+    11e5:	5d                   	pop    %ebp
+    11e6:	c3                   	ret    
+    11e7:	89 f6                	mov    %esi,%esi
+    11e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+000011f0 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    11f0:	55                   	push   %ebp
+    11f1:	89 e5                	mov    %esp,%ebp
+    11f3:	8b 45 08             	mov    0x8(%ebp),%eax
+    11f6:	53                   	push   %ebx
+    11f7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    11fa:	0f b6 18             	movzbl (%eax),%ebx
+    11fd:	84 db                	test   %bl,%bl
+    11ff:	74 1d                	je     121e <strchr+0x2e>
+    if(*s == c)
+    1201:	38 d3                	cmp    %dl,%bl
+    1203:	89 d1                	mov    %edx,%ecx
+    1205:	75 0d                	jne    1214 <strchr+0x24>
+    1207:	eb 17                	jmp    1220 <strchr+0x30>
+    1209:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1210:	38 ca                	cmp    %cl,%dl
+    1212:	74 0c                	je     1220 <strchr+0x30>
+  for(; *s; s++)
+    1214:	83 c0 01             	add    $0x1,%eax
+    1217:	0f b6 10             	movzbl (%eax),%edx
+    121a:	84 d2                	test   %dl,%dl
+    121c:	75 f2                	jne    1210 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    121e:	31 c0                	xor    %eax,%eax
+}
+    1220:	5b                   	pop    %ebx
+    1221:	5d                   	pop    %ebp
+    1222:	c3                   	ret    
+    1223:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1229:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001230 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1230:	55                   	push   %ebp
+    1231:	89 e5                	mov    %esp,%ebp
+    1233:	57                   	push   %edi
+    1234:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1235:	31 f6                	xor    %esi,%esi
+{
+    1237:	53                   	push   %ebx
+    1238:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    123b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    123e:	eb 31                	jmp    1271 <gets+0x41>
+    cc = read(0, &c, 1);
+    1240:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1247:	00 
+    1248:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    124c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1253:	e8 02 01 00 00       	call   135a <read>
+    if(cc < 1)
+    1258:	85 c0                	test   %eax,%eax
+    125a:	7e 1d                	jle    1279 <gets+0x49>
+      break;
+    buf[i++] = c;
+    125c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    1260:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    1262:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    1265:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    1267:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    126b:	74 0c                	je     1279 <gets+0x49>
+    126d:	3c 0a                	cmp    $0xa,%al
+    126f:	74 08                	je     1279 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    1271:	8d 5e 01             	lea    0x1(%esi),%ebx
+    1274:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    1277:	7c c7                	jl     1240 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    1279:	8b 45 08             	mov    0x8(%ebp),%eax
+    127c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    1280:	83 c4 2c             	add    $0x2c,%esp
+    1283:	5b                   	pop    %ebx
+    1284:	5e                   	pop    %esi
+    1285:	5f                   	pop    %edi
+    1286:	5d                   	pop    %ebp
+    1287:	c3                   	ret    
+    1288:	90                   	nop
+    1289:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001290 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    1290:	55                   	push   %ebp
+    1291:	89 e5                	mov    %esp,%ebp
+    1293:	56                   	push   %esi
+    1294:	53                   	push   %ebx
+    1295:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    1298:	8b 45 08             	mov    0x8(%ebp),%eax
+    129b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    12a2:	00 
+    12a3:	89 04 24             	mov    %eax,(%esp)
+    12a6:	e8 d7 00 00 00       	call   1382 <open>
+  if(fd < 0)
+    12ab:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    12ad:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    12af:	78 27                	js     12d8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    12b1:	8b 45 0c             	mov    0xc(%ebp),%eax
+    12b4:	89 1c 24             	mov    %ebx,(%esp)
+    12b7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    12bb:	e8 da 00 00 00       	call   139a <fstat>
+  close(fd);
+    12c0:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    12c3:	89 c6                	mov    %eax,%esi
+  close(fd);
+    12c5:	e8 a0 00 00 00       	call   136a <close>
+  return r;
+    12ca:	89 f0                	mov    %esi,%eax
+}
+    12cc:	83 c4 10             	add    $0x10,%esp
+    12cf:	5b                   	pop    %ebx
+    12d0:	5e                   	pop    %esi
+    12d1:	5d                   	pop    %ebp
+    12d2:	c3                   	ret    
+    12d3:	90                   	nop
+    12d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    12d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    12dd:	eb ed                	jmp    12cc <stat+0x3c>
+    12df:	90                   	nop
+
+000012e0 <atoi>:
+
+int
+atoi(const char *s)
+{
+    12e0:	55                   	push   %ebp
+    12e1:	89 e5                	mov    %esp,%ebp
+    12e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    12e6:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    12e7:	0f be 11             	movsbl (%ecx),%edx
+    12ea:	8d 42 d0             	lea    -0x30(%edx),%eax
+    12ed:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    12ef:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    12f4:	77 17                	ja     130d <atoi+0x2d>
+    12f6:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    12f8:	83 c1 01             	add    $0x1,%ecx
+    12fb:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    12fe:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1302:	0f be 11             	movsbl (%ecx),%edx
+    1305:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1308:	80 fb 09             	cmp    $0x9,%bl
+    130b:	76 eb                	jbe    12f8 <atoi+0x18>
+  return n;
+}
+    130d:	5b                   	pop    %ebx
+    130e:	5d                   	pop    %ebp
+    130f:	c3                   	ret    
+
+00001310 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1310:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1311:	31 d2                	xor    %edx,%edx
+{
+    1313:	89 e5                	mov    %esp,%ebp
+    1315:	56                   	push   %esi
+    1316:	8b 45 08             	mov    0x8(%ebp),%eax
+    1319:	53                   	push   %ebx
+    131a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    131d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1320:	85 db                	test   %ebx,%ebx
+    1322:	7e 12                	jle    1336 <memmove+0x26>
+    1324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1328:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    132c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    132f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1332:	39 da                	cmp    %ebx,%edx
+    1334:	75 f2                	jne    1328 <memmove+0x18>
+  return vdst;
+}
+    1336:	5b                   	pop    %ebx
+    1337:	5e                   	pop    %esi
+    1338:	5d                   	pop    %ebp
+    1339:	c3                   	ret    
+
+0000133a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    133a:	b8 01 00 00 00       	mov    $0x1,%eax
+    133f:	cd 40                	int    $0x40
+    1341:	c3                   	ret    
+
+00001342 <exit>:
+SYSCALL(exit)
+    1342:	b8 02 00 00 00       	mov    $0x2,%eax
+    1347:	cd 40                	int    $0x40
+    1349:	c3                   	ret    
+
+0000134a <wait>:
+SYSCALL(wait)
+    134a:	b8 03 00 00 00       	mov    $0x3,%eax
+    134f:	cd 40                	int    $0x40
+    1351:	c3                   	ret    
+
+00001352 <pipe>:
+SYSCALL(pipe)
+    1352:	b8 04 00 00 00       	mov    $0x4,%eax
+    1357:	cd 40                	int    $0x40
+    1359:	c3                   	ret    
+
+0000135a <read>:
+SYSCALL(read)
+    135a:	b8 05 00 00 00       	mov    $0x5,%eax
+    135f:	cd 40                	int    $0x40
+    1361:	c3                   	ret    
+
+00001362 <write>:
+SYSCALL(write)
+    1362:	b8 10 00 00 00       	mov    $0x10,%eax
+    1367:	cd 40                	int    $0x40
+    1369:	c3                   	ret    
+
+0000136a <close>:
+SYSCALL(close)
+    136a:	b8 15 00 00 00       	mov    $0x15,%eax
+    136f:	cd 40                	int    $0x40
+    1371:	c3                   	ret    
+
+00001372 <kill>:
+SYSCALL(kill)
+    1372:	b8 06 00 00 00       	mov    $0x6,%eax
+    1377:	cd 40                	int    $0x40
+    1379:	c3                   	ret    
+
+0000137a <exec>:
+SYSCALL(exec)
+    137a:	b8 07 00 00 00       	mov    $0x7,%eax
+    137f:	cd 40                	int    $0x40
+    1381:	c3                   	ret    
+
+00001382 <open>:
+SYSCALL(open)
+    1382:	b8 0f 00 00 00       	mov    $0xf,%eax
+    1387:	cd 40                	int    $0x40
+    1389:	c3                   	ret    
+
+0000138a <mknod>:
+SYSCALL(mknod)
+    138a:	b8 11 00 00 00       	mov    $0x11,%eax
+    138f:	cd 40                	int    $0x40
+    1391:	c3                   	ret    
+
+00001392 <unlink>:
+SYSCALL(unlink)
+    1392:	b8 12 00 00 00       	mov    $0x12,%eax
+    1397:	cd 40                	int    $0x40
+    1399:	c3                   	ret    
+
+0000139a <fstat>:
+SYSCALL(fstat)
+    139a:	b8 08 00 00 00       	mov    $0x8,%eax
+    139f:	cd 40                	int    $0x40
+    13a1:	c3                   	ret    
+
+000013a2 <link>:
+SYSCALL(link)
+    13a2:	b8 13 00 00 00       	mov    $0x13,%eax
+    13a7:	cd 40                	int    $0x40
+    13a9:	c3                   	ret    
+
+000013aa <mkdir>:
+SYSCALL(mkdir)
+    13aa:	b8 14 00 00 00       	mov    $0x14,%eax
+    13af:	cd 40                	int    $0x40
+    13b1:	c3                   	ret    
+
+000013b2 <chdir>:
+SYSCALL(chdir)
+    13b2:	b8 09 00 00 00       	mov    $0x9,%eax
+    13b7:	cd 40                	int    $0x40
+    13b9:	c3                   	ret    
+
+000013ba <dup>:
+SYSCALL(dup)
+    13ba:	b8 0a 00 00 00       	mov    $0xa,%eax
+    13bf:	cd 40                	int    $0x40
+    13c1:	c3                   	ret    
+
+000013c2 <getpid>:
+SYSCALL(getpid)
+    13c2:	b8 0b 00 00 00       	mov    $0xb,%eax
+    13c7:	cd 40                	int    $0x40
+    13c9:	c3                   	ret    
+
+000013ca <sbrk>:
+SYSCALL(sbrk)
+    13ca:	b8 0c 00 00 00       	mov    $0xc,%eax
+    13cf:	cd 40                	int    $0x40
+    13d1:	c3                   	ret    
+
+000013d2 <sleep>:
+SYSCALL(sleep)
+    13d2:	b8 0d 00 00 00       	mov    $0xd,%eax
+    13d7:	cd 40                	int    $0x40
+    13d9:	c3                   	ret    
+
+000013da <uptime>:
+SYSCALL(uptime)
+    13da:	b8 0e 00 00 00       	mov    $0xe,%eax
+    13df:	cd 40                	int    $0x40
+    13e1:	c3                   	ret    
+
+000013e2 <shm_open>:
+SYSCALL(shm_open)
+    13e2:	b8 16 00 00 00       	mov    $0x16,%eax
+    13e7:	cd 40                	int    $0x40
+    13e9:	c3                   	ret    
+
+000013ea <shm_close>:
+SYSCALL(shm_close)	
+    13ea:	b8 17 00 00 00       	mov    $0x17,%eax
+    13ef:	cd 40                	int    $0x40
+    13f1:	c3                   	ret    
+    13f2:	66 90                	xchg   %ax,%ax
+    13f4:	66 90                	xchg   %ax,%ax
+    13f6:	66 90                	xchg   %ax,%ax
+    13f8:	66 90                	xchg   %ax,%ax
+    13fa:	66 90                	xchg   %ax,%ax
+    13fc:	66 90                	xchg   %ax,%ax
+    13fe:	66 90                	xchg   %ax,%ax
+
+00001400 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1400:	55                   	push   %ebp
+    1401:	89 e5                	mov    %esp,%ebp
+    1403:	57                   	push   %edi
+    1404:	56                   	push   %esi
+    1405:	89 c6                	mov    %eax,%esi
+    1407:	53                   	push   %ebx
+    1408:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    140b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    140e:	85 db                	test   %ebx,%ebx
+    1410:	74 09                	je     141b <printint+0x1b>
+    1412:	89 d0                	mov    %edx,%eax
+    1414:	c1 e8 1f             	shr    $0x1f,%eax
+    1417:	84 c0                	test   %al,%al
+    1419:	75 75                	jne    1490 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    141b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    141d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1424:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1427:	31 ff                	xor    %edi,%edi
+    1429:	89 ce                	mov    %ecx,%esi
+    142b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    142e:	eb 02                	jmp    1432 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1430:	89 cf                	mov    %ecx,%edi
+    1432:	31 d2                	xor    %edx,%edx
+    1434:	f7 f6                	div    %esi
+    1436:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1439:	0f b6 92 80 18 00 00 	movzbl 0x1880(%edx),%edx
+  }while((x /= base) != 0);
+    1440:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1442:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1445:	75 e9                	jne    1430 <printint+0x30>
+  if(neg)
+    1447:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    144a:	89 c8                	mov    %ecx,%eax
+    144c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    144f:	85 d2                	test   %edx,%edx
+    1451:	74 08                	je     145b <printint+0x5b>
+    buf[i++] = '-';
+    1453:	8d 4f 02             	lea    0x2(%edi),%ecx
+    1456:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    145b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    145e:	66 90                	xchg   %ax,%ax
+    1460:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    1465:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    1468:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    146f:	00 
+    1470:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1474:	89 34 24             	mov    %esi,(%esp)
+    1477:	88 45 d7             	mov    %al,-0x29(%ebp)
+    147a:	e8 e3 fe ff ff       	call   1362 <write>
+  while(--i >= 0)
+    147f:	83 ff ff             	cmp    $0xffffffff,%edi
+    1482:	75 dc                	jne    1460 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    1484:	83 c4 4c             	add    $0x4c,%esp
+    1487:	5b                   	pop    %ebx
+    1488:	5e                   	pop    %esi
+    1489:	5f                   	pop    %edi
+    148a:	5d                   	pop    %ebp
+    148b:	c3                   	ret    
+    148c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    1490:	89 d0                	mov    %edx,%eax
+    1492:	f7 d8                	neg    %eax
+    neg = 1;
+    1494:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    149b:	eb 87                	jmp    1424 <printint+0x24>
+    149d:	8d 76 00             	lea    0x0(%esi),%esi
+
+000014a0 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    14a0:	55                   	push   %ebp
+    14a1:	89 e5                	mov    %esp,%ebp
+    14a3:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    14a4:	31 ff                	xor    %edi,%edi
+{
+    14a6:	56                   	push   %esi
+    14a7:	53                   	push   %ebx
+    14a8:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    14ab:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    14ae:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    14b1:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    14b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    14b7:	0f b6 13             	movzbl (%ebx),%edx
+    14ba:	83 c3 01             	add    $0x1,%ebx
+    14bd:	84 d2                	test   %dl,%dl
+    14bf:	75 39                	jne    14fa <printf+0x5a>
+    14c1:	e9 c2 00 00 00       	jmp    1588 <printf+0xe8>
+    14c6:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    14c8:	83 fa 25             	cmp    $0x25,%edx
+    14cb:	0f 84 bf 00 00 00    	je     1590 <printf+0xf0>
+  write(fd, &c, 1);
+    14d1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    14d4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14db:	00 
+    14dc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14e0:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    14e3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    14e6:	e8 77 fe ff ff       	call   1362 <write>
+    14eb:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    14ee:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    14f2:	84 d2                	test   %dl,%dl
+    14f4:	0f 84 8e 00 00 00    	je     1588 <printf+0xe8>
+    if(state == 0){
+    14fa:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    14fc:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    14ff:	74 c7                	je     14c8 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1501:	83 ff 25             	cmp    $0x25,%edi
+    1504:	75 e5                	jne    14eb <printf+0x4b>
+      if(c == 'd'){
+    1506:	83 fa 64             	cmp    $0x64,%edx
+    1509:	0f 84 31 01 00 00    	je     1640 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    150f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1514:	83 f8 70             	cmp    $0x70,%eax
+    1517:	0f 84 83 00 00 00    	je     15a0 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    151d:	83 fa 73             	cmp    $0x73,%edx
+    1520:	0f 84 a2 00 00 00    	je     15c8 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1526:	83 fa 63             	cmp    $0x63,%edx
+    1529:	0f 84 35 01 00 00    	je     1664 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    152f:	83 fa 25             	cmp    $0x25,%edx
+    1532:	0f 84 e0 00 00 00    	je     1618 <printf+0x178>
+  write(fd, &c, 1);
+    1538:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    153b:	83 c3 01             	add    $0x1,%ebx
+    153e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1545:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    1546:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    1548:	89 44 24 04          	mov    %eax,0x4(%esp)
+    154c:	89 34 24             	mov    %esi,(%esp)
+    154f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    1552:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    1556:	e8 07 fe ff ff       	call   1362 <write>
+        putc(fd, c);
+    155b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    155e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    1561:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1568:	00 
+    1569:	89 44 24 04          	mov    %eax,0x4(%esp)
+    156d:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    1570:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    1573:	e8 ea fd ff ff       	call   1362 <write>
+  for(i = 0; fmt[i]; i++){
+    1578:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    157c:	84 d2                	test   %dl,%dl
+    157e:	0f 85 76 ff ff ff    	jne    14fa <printf+0x5a>
+    1584:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    1588:	83 c4 3c             	add    $0x3c,%esp
+    158b:	5b                   	pop    %ebx
+    158c:	5e                   	pop    %esi
+    158d:	5f                   	pop    %edi
+    158e:	5d                   	pop    %ebp
+    158f:	c3                   	ret    
+        state = '%';
+    1590:	bf 25 00 00 00       	mov    $0x25,%edi
+    1595:	e9 51 ff ff ff       	jmp    14eb <printf+0x4b>
+    159a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    15a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    15a3:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    15a8:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    15aa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    15b1:	8b 10                	mov    (%eax),%edx
+    15b3:	89 f0                	mov    %esi,%eax
+    15b5:	e8 46 fe ff ff       	call   1400 <printint>
+        ap++;
+    15ba:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15be:	e9 28 ff ff ff       	jmp    14eb <printf+0x4b>
+    15c3:	90                   	nop
+    15c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    15c8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    15cb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    15cf:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    15d1:	b8 79 18 00 00       	mov    $0x1879,%eax
+    15d6:	85 ff                	test   %edi,%edi
+    15d8:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    15db:	0f b6 07             	movzbl (%edi),%eax
+    15de:	84 c0                	test   %al,%al
+    15e0:	74 2a                	je     160c <printf+0x16c>
+    15e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    15e8:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    15eb:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    15ee:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    15f1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    15f8:	00 
+    15f9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15fd:	89 34 24             	mov    %esi,(%esp)
+    1600:	e8 5d fd ff ff       	call   1362 <write>
+        while(*s != 0){
+    1605:	0f b6 07             	movzbl (%edi),%eax
+    1608:	84 c0                	test   %al,%al
+    160a:	75 dc                	jne    15e8 <printf+0x148>
+      state = 0;
+    160c:	31 ff                	xor    %edi,%edi
+    160e:	e9 d8 fe ff ff       	jmp    14eb <printf+0x4b>
+    1613:	90                   	nop
+    1614:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1618:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    161b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    161d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1624:	00 
+    1625:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1629:	89 34 24             	mov    %esi,(%esp)
+    162c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1630:	e8 2d fd ff ff       	call   1362 <write>
+    1635:	e9 b1 fe ff ff       	jmp    14eb <printf+0x4b>
+    163a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    1640:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1643:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    1648:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    164b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1652:	8b 10                	mov    (%eax),%edx
+    1654:	89 f0                	mov    %esi,%eax
+    1656:	e8 a5 fd ff ff       	call   1400 <printint>
+        ap++;
+    165b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    165f:	e9 87 fe ff ff       	jmp    14eb <printf+0x4b>
+        putc(fd, *ap);
+    1664:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    1667:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    1669:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    166b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1672:	00 
+    1673:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    1676:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    1679:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    167c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1680:	e8 dd fc ff ff       	call   1362 <write>
+        ap++;
+    1685:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    1689:	e9 5d fe ff ff       	jmp    14eb <printf+0x4b>
+    168e:	66 90                	xchg   %ax,%ax
+
+00001690 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    1690:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1691:	a1 80 1b 00 00       	mov    0x1b80,%eax
+{
+    1696:	89 e5                	mov    %esp,%ebp
+    1698:	57                   	push   %edi
+    1699:	56                   	push   %esi
+    169a:	53                   	push   %ebx
+    169b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    169e:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    16a0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16a3:	39 d0                	cmp    %edx,%eax
+    16a5:	72 11                	jb     16b8 <free+0x28>
+    16a7:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16a8:	39 c8                	cmp    %ecx,%eax
+    16aa:	72 04                	jb     16b0 <free+0x20>
+    16ac:	39 ca                	cmp    %ecx,%edx
+    16ae:	72 10                	jb     16c0 <free+0x30>
+    16b0:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16b2:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16b4:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16b6:	73 f0                	jae    16a8 <free+0x18>
+    16b8:	39 ca                	cmp    %ecx,%edx
+    16ba:	72 04                	jb     16c0 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16bc:	39 c8                	cmp    %ecx,%eax
+    16be:	72 f0                	jb     16b0 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    16c0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    16c3:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    16c6:	39 cf                	cmp    %ecx,%edi
+    16c8:	74 1e                	je     16e8 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    16ca:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    16cd:	8b 48 04             	mov    0x4(%eax),%ecx
+    16d0:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    16d3:	39 f2                	cmp    %esi,%edx
+    16d5:	74 28                	je     16ff <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    16d7:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    16d9:	a3 80 1b 00 00       	mov    %eax,0x1b80
+}
+    16de:	5b                   	pop    %ebx
+    16df:	5e                   	pop    %esi
+    16e0:	5f                   	pop    %edi
+    16e1:	5d                   	pop    %ebp
+    16e2:	c3                   	ret    
+    16e3:	90                   	nop
+    16e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    16e8:	03 71 04             	add    0x4(%ecx),%esi
+    16eb:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    16ee:	8b 08                	mov    (%eax),%ecx
+    16f0:	8b 09                	mov    (%ecx),%ecx
+    16f2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    16f5:	8b 48 04             	mov    0x4(%eax),%ecx
+    16f8:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    16fb:	39 f2                	cmp    %esi,%edx
+    16fd:	75 d8                	jne    16d7 <free+0x47>
+    p->s.size += bp->s.size;
+    16ff:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    1702:	a3 80 1b 00 00       	mov    %eax,0x1b80
+    p->s.size += bp->s.size;
+    1707:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    170a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    170d:	89 10                	mov    %edx,(%eax)
+}
+    170f:	5b                   	pop    %ebx
+    1710:	5e                   	pop    %esi
+    1711:	5f                   	pop    %edi
+    1712:	5d                   	pop    %ebp
+    1713:	c3                   	ret    
+    1714:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    171a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001720 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1720:	55                   	push   %ebp
+    1721:	89 e5                	mov    %esp,%ebp
+    1723:	57                   	push   %edi
+    1724:	56                   	push   %esi
+    1725:	53                   	push   %ebx
+    1726:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1729:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    172c:	8b 1d 80 1b 00 00    	mov    0x1b80,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1732:	8d 48 07             	lea    0x7(%eax),%ecx
+    1735:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1738:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    173a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    173d:	0f 84 9b 00 00 00    	je     17de <malloc+0xbe>
+    1743:	8b 13                	mov    (%ebx),%edx
+    1745:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    1748:	39 fe                	cmp    %edi,%esi
+    174a:	76 64                	jbe    17b0 <malloc+0x90>
+    174c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    1753:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    1758:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    175b:	eb 0e                	jmp    176b <malloc+0x4b>
+    175d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1760:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    1762:	8b 78 04             	mov    0x4(%eax),%edi
+    1765:	39 fe                	cmp    %edi,%esi
+    1767:	76 4f                	jbe    17b8 <malloc+0x98>
+    1769:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    176b:	3b 15 80 1b 00 00    	cmp    0x1b80,%edx
+    1771:	75 ed                	jne    1760 <malloc+0x40>
+  if(nu < 4096)
+    1773:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1776:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    177c:	bf 00 10 00 00       	mov    $0x1000,%edi
+    1781:	0f 43 fe             	cmovae %esi,%edi
+    1784:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    1787:	89 04 24             	mov    %eax,(%esp)
+    178a:	e8 3b fc ff ff       	call   13ca <sbrk>
+  if(p == (char*)-1)
+    178f:	83 f8 ff             	cmp    $0xffffffff,%eax
+    1792:	74 18                	je     17ac <malloc+0x8c>
+  hp->s.size = nu;
+    1794:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    1797:	83 c0 08             	add    $0x8,%eax
+    179a:	89 04 24             	mov    %eax,(%esp)
+    179d:	e8 ee fe ff ff       	call   1690 <free>
+  return freep;
+    17a2:	8b 15 80 1b 00 00    	mov    0x1b80,%edx
+      if((p = morecore(nunits)) == 0)
+    17a8:	85 d2                	test   %edx,%edx
+    17aa:	75 b4                	jne    1760 <malloc+0x40>
+        return 0;
+    17ac:	31 c0                	xor    %eax,%eax
+    17ae:	eb 20                	jmp    17d0 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    17b0:	89 d0                	mov    %edx,%eax
+    17b2:	89 da                	mov    %ebx,%edx
+    17b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    17b8:	39 fe                	cmp    %edi,%esi
+    17ba:	74 1c                	je     17d8 <malloc+0xb8>
+        p->s.size -= nunits;
+    17bc:	29 f7                	sub    %esi,%edi
+    17be:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    17c1:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    17c4:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    17c7:	89 15 80 1b 00 00    	mov    %edx,0x1b80
+      return (void*)(p + 1);
+    17cd:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    17d0:	83 c4 1c             	add    $0x1c,%esp
+    17d3:	5b                   	pop    %ebx
+    17d4:	5e                   	pop    %esi
+    17d5:	5f                   	pop    %edi
+    17d6:	5d                   	pop    %ebp
+    17d7:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    17d8:	8b 08                	mov    (%eax),%ecx
+    17da:	89 0a                	mov    %ecx,(%edx)
+    17dc:	eb e9                	jmp    17c7 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    17de:	c7 05 80 1b 00 00 84 	movl   $0x1b84,0x1b80
+    17e5:	1b 00 00 
+    base.s.size = 0;
+    17e8:	ba 84 1b 00 00       	mov    $0x1b84,%edx
+    base.s.ptr = freep = prevp = &base;
+    17ed:	c7 05 84 1b 00 00 84 	movl   $0x1b84,0x1b84
+    17f4:	1b 00 00 
+    base.s.size = 0;
+    17f7:	c7 05 88 1b 00 00 00 	movl   $0x0,0x1b88
+    17fe:	00 00 00 
+    1801:	e9 46 ff ff ff       	jmp    174c <malloc+0x2c>
+    1806:	66 90                	xchg   %ax,%ax
+    1808:	66 90                	xchg   %ax,%ax
+    180a:	66 90                	xchg   %ax,%ax
+    180c:	66 90                	xchg   %ax,%ax
+    180e:	66 90                	xchg   %ax,%ax
+
+00001810 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1810:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1811:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1816:	89 e5                	mov    %esp,%ebp
+    1818:	8b 55 08             	mov    0x8(%ebp),%edx
+    181b:	90                   	nop
+    181c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1820:	89 c8                	mov    %ecx,%eax
+    1822:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1825:	85 c0                	test   %eax,%eax
+    1827:	75 f7                	jne    1820 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1829:	0f ae f0             	mfence 
+}
+    182c:	5d                   	pop    %ebp
+    182d:	c3                   	ret    
+    182e:	66 90                	xchg   %ax,%ax
+
+00001830 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1830:	55                   	push   %ebp
+    1831:	89 e5                	mov    %esp,%ebp
+    1833:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1836:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1839:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    183f:	5d                   	pop    %ebp
+    1840:	c3                   	ret    
diff --git a/cat.c b/cat.c
index 68b1b8d..5ddc820 100644
--- a/cat.c
+++ b/cat.c
@@ -12,12 +12,12 @@ cat(int fd)
   while((n = read(fd, buf, sizeof(buf))) > 0) {
     if (write(1, buf, n) != n) {
       printf(1, "cat: write error\n");
-      exit(3);
+      exit();
     }
   }
   if(n < 0){
     printf(1, "cat: read error\n");
-    exit(4);
+    exit();
   }
 }
 
@@ -28,16 +28,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     cat(0);
-    exit(1);
+    exit();
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "cat: cannot open %s\n", argv[i]);
-      exit(2);
+      exit();
     }
     cat(fd);
     close(fd);
   }
-  exit(0);
+  exit();
 }
diff --git a/cat.d b/cat.d
new file mode 100644
index 0000000..8f55acc
--- /dev/null
+++ b/cat.d
@@ -0,0 +1 @@
+cat.o: cat.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/cat.o b/cat.o
new file mode 100644
index 0000000..5e359cb
Binary files /dev/null and b/cat.o differ
diff --git a/cat.sym b/cat.sym
new file mode 100644
index 0000000..8004974
--- /dev/null
+++ b/cat.sym
@@ -0,0 +1,64 @@
+00001000 .text
+00001841 .rodata
+00001894 .eh_frame
+00001b80 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 cat.c
+00000000 ulib.c
+00000000 printf.c
+00001400 printint
+00001880 digits.1359
+00000000 umalloc.c
+00001b80 freep
+00001b84 base
+00000000 uspinlock.c
+00001120 strcpy
+000014a0 printf
+00001310 memmove
+0000138a mknod
+000013e2 shm_open
+00001230 gets
+000013c2 getpid
+00001090 cat
+00001720 malloc
+000013d2 sleep
+00001352 pipe
+00001362 write
+0000139a fstat
+00001372 kill
+000013b2 chdir
+0000137a exec
+0000134a wait
+0000135a read
+00001392 unlink
+00001810 uacquire
+0000133a fork
+000013ca sbrk
+000013ea shm_close
+000013da uptime
+00001b6c __bss_start
+000011d0 memset
+00001000 main
+00001150 strcmp
+000013ba dup
+00001ba0 buf
+00001290 stat
+00001b6c _edata
+00001da0 _end
+000013a2 link
+00001342 exit
+000012e0 atoi
+000011a0 strlen
+00001382 open
+000011f0 strchr
+000013aa mkdir
+0000136a close
+00001830 urelease
+00001690 free
diff --git a/code.diff b/code.diff
index c889659..74fcd4b 100644
--- a/code.diff
+++ b/code.diff
@@ -1,2919 +1,16128 @@
+diff --git a/.cvsignore b/.cvsignore
+deleted file mode 100644
+index 081a43c..0000000
+--- a/.cvsignore
++++ /dev/null
+@@ -1,16 +0,0 @@
+-*.asm
+-*.d
+-*.sym
+-_*
+-kernel
+-user1
+-userfs
+-usertests
+-xv6.img
+-vectors.S
+-bochsout.txt
+-bootblock
+-bootother
+-bootother.out
+-parport.out
+-fmt
+diff --git a/.dir-locals.el b/.dir-locals.el
+deleted file mode 100644
+index da72247..0000000
+--- a/.dir-locals.el
++++ /dev/null
+@@ -1,4 +0,0 @@
+-((c-mode
+-  (indent-tabs-mode . nil)
+-  (c-file-style . "bsd")
+-  (c-basic-offset . 2)))
+diff --git a/.gdbinit.tmpl b/.gdbinit.tmpl
+index f71681a..ac7a259 100644
+--- a/.gdbinit.tmpl
++++ b/.gdbinit.tmpl
+@@ -24,4 +24,4 @@ echo + target remote localhost:1234\n
+ target remote localhost:1234
+ 
+ echo + symbol-file kernel\n
+-symbol-file kernel
++symbol-file kernel
+\ No newline at end of file
+diff --git a/.gitignore b/.gitignore
+deleted file mode 100644
+index 3e2c9de..0000000
+--- a/.gitignore
++++ /dev/null
+@@ -1,16 +0,0 @@
+-*~
+-_*
+-*.o
+-*.d
+-*.asm
+-*.sym
+-*.img
+-vectors.S
+-bootblock
+-entryother
+-initcode
+-initcode.out
+-kernel
+-kernelmemfs
+-mkfs
+-.gdbinit
+diff --git a/.idea/xv6.iml b/.idea/xv6.iml
+index 5aac3dd..771e54c 100644
+--- a/.idea/xv6.iml
++++ b/.idea/xv6.iml
+@@ -1,2 +1,2 @@
+ <?xml version="1.0" encoding="UTF-8"?>
+-<module classpath="External" external.linked.project.id="xv6" external.linked.project.path="C:\Users\Kotori\Desktop\Code Projects\School\xv6\xv6" external.root.project.path="$MODULE_DIR$" external.system.id="Makefile" type="CPP_MODULE" version="4" />
+\ No newline at end of file
++<module classpath="External" type="CPP_MODULE" version="4" />
+\ No newline at end of file
+diff --git a/BUGS b/BUGS
+deleted file mode 100644
+index 81d2220..0000000
+--- a/BUGS
++++ /dev/null
+@@ -1,7 +0,0 @@
+-formatting:
+-	need to fix PAGEBREAK mechanism
+-
+-sh:
+-	can't always runcmd in child -- breaks cd.
+-	maybe should hard-code PATH=/ ?
+-
+diff --git a/LICENSE b/LICENSE
+deleted file mode 100644
+index 422c0cc..0000000
+--- a/LICENSE
++++ /dev/null
+@@ -1,24 +0,0 @@
+-The xv6 software is:
+-
+-Copyright (c) 2006-2018 Frans Kaashoek, Robert Morris, Russ Cox,
+-                        Massachusetts Institute of Technology
+-
+-Permission is hereby granted, free of charge, to any person obtaining
+-a copy of this software and associated documentation files (the
+-"Software"), to deal in the Software without restriction, including
+-without limitation the rights to use, copy, modify, merge, publish,
+-distribute, sublicense, and/or sell copies of the Software, and to
+-permit persons to whom the Software is furnished to do so, subject to
+-the following conditions:
+-
+-The above copyright notice and this permission notice shall be
+-included in all copies or substantial portions of the Software.
+-
+-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-
 diff --git a/Makefile b/Makefile
-index 09d790c..04d74d5 100644
+deleted file mode 100644
+index 04d74d5..0000000
 --- a/Makefile
-+++ b/Makefile
-@@ -181,6 +181,7 @@ UPROGS=\
- 	_usertests\
- 	_wc\
- 	_zombie\
-+	_lab1\
- 
- fs.img: mkfs README $(UPROGS)
- 	./mkfs fs.img README $(UPROGS)
-diff --git a/cat.c b/cat.c
-index 5ddc820..68b1b8d 100644
---- a/cat.c
-+++ b/cat.c
-@@ -12,12 +12,12 @@ cat(int fd)
-   while((n = read(fd, buf, sizeof(buf))) > 0) {
-     if (write(1, buf, n) != n) {
-       printf(1, "cat: write error\n");
--      exit();
-+      exit(3);
-     }
-   }
-   if(n < 0){
-     printf(1, "cat: read error\n");
--    exit();
-+    exit(4);
-   }
- }
- 
-@@ -28,16 +28,16 @@ main(int argc, char *argv[])
- 
-   if(argc <= 1){
-     cat(0);
--    exit();
-+    exit(1);
-   }
- 
-   for(i = 1; i < argc; i++){
-     if((fd = open(argv[i], 0)) < 0){
-       printf(1, "cat: cannot open %s\n", argv[i]);
--      exit();
-+      exit(2);
-     }
-     cat(fd);
-     close(fd);
-   }
--  exit();
-+  exit(0);
- }
-diff --git a/cuth b/cuth
-old mode 100755
-new mode 100644
-diff --git a/defs.h b/defs.h
-index 82fb982..d1934ca 100644
---- a/defs.h
-+++ b/defs.h
-@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
- //PAGEBREAK: 16
- // proc.c
- int             cpuid(void);
--void            exit(void);
-+void            exit(int status);
- int             fork(void);
- int             growproc(int);
- int             kill(int);
-@@ -117,7 +117,8 @@ void            sched(void);
- void            setproc(struct proc*);
- void            sleep(void*, struct spinlock*);
- void            userinit(void);
--int             wait(void);
-+int             wait(int* status);
-+int             waitpid(int pid, int* status, int options);
- void            wakeup(void*);
- void            yield(void);
- 
-diff --git a/dot-bochsrc b/dot-bochsrc
-old mode 100755
-new mode 100644
-diff --git a/echo.c b/echo.c
-index 806dee0..eed68a0 100644
---- a/echo.c
-+++ b/echo.c
-@@ -9,5 +9,5 @@ main(int argc, char *argv[])
- 
-   for(i = 1; i < argc; i++)
-     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
--  exit();
-+  exit(0);
- }
-diff --git a/forktest.c b/forktest.c
-index 8bc984d..a4b35ed 100644
---- a/forktest.c
-+++ b/forktest.c
-@@ -25,24 +25,24 @@ forktest(void)
-     if(pid < 0)
-       break;
-     if(pid == 0)
--      exit();
-+      exit(4);
-   }
- 
-   if(n == N){
-     printf(1, "fork claimed to work N times!\n", N);
--    exit();
-+    exit(3);
-   }
- 
-   for(; n > 0; n--){
--    if(wait() < 0){
-+    if(wait(NULL) < 0){
-       printf(1, "wait stopped early\n");
--      exit();
-+      exit(2);
-     }
-   }
- 
--  if(wait() != -1){
-+  if(wait(NULL) != -1){
-     printf(1, "wait got too many\n");
--    exit();
-+    exit(1);
-   }
- 
-   printf(1, "fork test OK\n");
-@@ -52,5 +52,5 @@ int
- main(void)
- {
-   forktest();
--  exit();
-+  exit(0);
- }
-diff --git a/grep.c b/grep.c
-index adc4835..4be3256 100644
---- a/grep.c
-+++ b/grep.c
-@@ -43,24 +43,24 @@ main(int argc, char *argv[])
- 
-   if(argc <= 1){
-     printf(2, "usage: grep pattern [file ...]\n");
--    exit();
-+    exit(1);
-   }
-   pattern = argv[1];
- 
-   if(argc <= 2){
-     grep(pattern, 0);
--    exit();
-+    exit(2);
-   }
- 
-   for(i = 2; i < argc; i++){
-     if((fd = open(argv[i], 0)) < 0){
-       printf(1, "grep: cannot open %s\n", argv[i]);
--      exit();
-+      exit(3);
-     }
-     grep(pattern, fd);
-     close(fd);
-   }
--  exit();
-+  exit(0);
- }
- 
- // Regexp matcher from Kernighan & Pike,
-diff --git a/init.c b/init.c
-index 046b551..bc6547f 100644
---- a/init.c
-+++ b/init.c
-@@ -24,14 +24,14 @@ main(void)
-     pid = fork();
-     if(pid < 0){
-       printf(1, "init: fork failed\n");
--      exit();
-+      exit(2);
-     }
-     if(pid == 0){
-       exec("sh", argv);
-       printf(1, "init: exec sh failed\n");
--      exit();
-+      exit(1);
-     }
--    while((wpid=wait()) >= 0 && wpid != pid)
-+    while((wpid=wait(NULL)) >= 0 && wpid != pid)
-       printf(1, "zombie!\n");
-   }
- }
-diff --git a/kill.c b/kill.c
-index 364f6af..875916c 100644
---- a/kill.c
-+++ b/kill.c
-@@ -9,9 +9,9 @@ main(int argc, char **argv)
- 
-   if(argc < 2){
-     printf(2, "usage: kill pid...\n");
--    exit();
-+    exit(1);
-   }
-   for(i=1; i<argc; i++)
-     kill(atoi(argv[i]));
--  exit();
-+  exit(0);
- }
-diff --git a/lab1.c b/lab1.c
-index 89668ce..2192a52 100644
---- a/lab1.c
-+++ b/lab1.c
-@@ -25,7 +25,7 @@ int main(int argc, char **argv) {
-     if(pid > 0)
-     {
-         waitpid(pid, NULL, 0);
--        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);
-+        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
-         exit(0);
-     }
- 
-diff --git a/ln.c b/ln.c
-index cf8a64e..fb17c3b 100644
---- a/ln.c
-+++ b/ln.c
-@@ -7,9 +7,9 @@ main(int argc, char *argv[])
- {
-   if(argc != 3){
-     printf(2, "Usage: ln old new\n");
--    exit();
-+    exit(1);
-   }
-   if(link(argv[1], argv[2]) < 0)
-     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
--  exit();
-+  exit(0);
- }
-diff --git a/ls.c b/ls.c
-index 2862913..6bf943b 100644
---- a/ls.c
-+++ b/ls.c
-@@ -77,9 +77,9 @@ main(int argc, char *argv[])
- 
-   if(argc < 2){
-     ls(".");
--    exit();
-+    exit(1);
-   }
-   for(i=1; i<argc; i++)
-     ls(argv[i]);
--  exit();
-+  exit(0);
- }
-diff --git a/mkdir.c b/mkdir.c
-index 6e4c954..2d90781 100644
---- a/mkdir.c
-+++ b/mkdir.c
-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
- 
-   if(argc < 2){
-     printf(2, "Usage: mkdir files...\n");
--    exit();
-+    exit(1);
-   }
- 
-   for(i = 1; i < argc; i++){
-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
-     }
-   }
- 
--  exit();
-+  exit(0);
- }
-diff --git a/pr.pl b/pr.pl
-old mode 100755
-new mode 100644
-diff --git a/printpcs b/printpcs
-old mode 100755
-new mode 100644
-diff --git a/proc.c b/proc.c
-index 806b1b1..84b335f 100644
---- a/proc.c
-+++ b/proc.c
-@@ -1,3 +1,5 @@
-+#include <stddef.h>
-+
- #include "types.h"
- #include "defs.h"
- #include "param.h"
-@@ -8,61 +10,61 @@
- #include "spinlock.h"
- 
- struct {
--  struct spinlock lock;
--  struct proc proc[NPROC];
-+    struct spinlock lock;
-+    struct proc proc[NPROC];
- } ptable;
- 
- static struct proc *initproc;
- 
- int nextpid = 1;
-+
- extern void forkret(void);
-+
- extern void trapret(void);
- 
- static void wakeup1(void *chan);
- 
- void
--pinit(void)
--{
--  initlock(&ptable.lock, "ptable");
-+pinit(void) {
-+    initlock(&ptable.lock, "ptable");
- }
- 
- // Must be called with interrupts disabled
- int
- cpuid() {
--  return mycpu()-cpus;
-+    return mycpu() - cpus;
- }
- 
- // Must be called with interrupts disabled to avoid the caller being
- // rescheduled between reading lapicid and running through the loop.
--struct cpu*
--mycpu(void)
--{
--  int apicid, i;
--  
--  if(readeflags()&FL_IF)
--    panic("mycpu called with interrupts enabled\n");
--  
--  apicid = lapicid();
--  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
--  // a reverse map, or reserve a register to store &cpus[i].
--  for (i = 0; i < ncpu; ++i) {
--    if (cpus[i].apicid == apicid)
--      return &cpus[i];
--  }
--  panic("unknown apicid\n");
-+struct cpu *
-+mycpu(void) {
-+    int apicid, i;
-+
-+    if (readeflags() & FL_IF)
-+        panic("mycpu called with interrupts enabled\n");
-+
-+    apicid = lapicid();
-+    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
-+    // a reverse map, or reserve a register to store &cpus[i].
-+    for (i = 0; i < ncpu; ++i) {
-+        if (cpus[i].apicid == apicid)
-+            return &cpus[i];
-+    }
-+    panic("unknown apicid\n");
- }
- 
- // Disable interrupts so that we are not rescheduled
- // while reading proc from the cpu structure
--struct proc*
-+struct proc *
- myproc(void) {
--  struct cpu *c;
--  struct proc *p;
--  pushcli();
--  c = mycpu();
--  p = c->proc;
--  popcli();
--  return p;
-+    struct cpu *c;
-+    struct proc *p;
-+    pushcli();
-+    c = mycpu();
-+    p = c->proc;
-+    popcli();
-+    return p;
- }
- 
- //PAGEBREAK: 32
-@@ -70,245 +72,295 @@ myproc(void) {
- // If found, change state to EMBRYO and initialize
- // state required to run in the kernel.
- // Otherwise return 0.
--static struct proc*
--allocproc(void)
--{
--  struct proc *p;
--  char *sp;
-+static struct proc *
-+allocproc(void) {
-+    struct proc *p;
-+    char *sp;
- 
--  acquire(&ptable.lock);
-+    acquire(&ptable.lock);
- 
--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
--    if(p->state == UNUSED)
--      goto found;
-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-+        if (p->state == UNUSED)
-+            goto found;
- 
--  release(&ptable.lock);
--  return 0;
-+    release(&ptable.lock);
-+    return 0;
- 
--found:
--  p->state = EMBRYO;
--  p->pid = nextpid++;
-+    found:
-+    p->state = EMBRYO;
-+    p->pid = nextpid++;
- 
--  release(&ptable.lock);
-+    release(&ptable.lock);
- 
--  // Allocate kernel stack.
--  if((p->kstack = kalloc()) == 0){
--    p->state = UNUSED;
--    return 0;
--  }
--  sp = p->kstack + KSTACKSIZE;
-+    // Allocate kernel stack.
-+    if ((p->kstack = kalloc()) == 0) {
-+        p->state = UNUSED;
-+        return 0;
-+    }
-+    sp = p->kstack + KSTACKSIZE;
- 
--  // Leave room for trap frame.
--  sp -= sizeof *p->tf;
--  p->tf = (struct trapframe*)sp;
-+    // Leave room for trap frame.
-+    sp -= sizeof *p->tf;
-+    p->tf = (struct trapframe *) sp;
- 
--  // Set up new context to start executing at forkret,
--  // which returns to trapret.
--  sp -= 4;
--  *(uint*)sp = (uint)trapret;
-+    // Set up new context to start executing at forkret,
-+    // which returns to trapret.
-+    sp -= 4;
-+    *(uint *) sp = (uint) trapret;
- 
--  sp -= sizeof *p->context;
--  p->context = (struct context*)sp;
--  memset(p->context, 0, sizeof *p->context);
--  p->context->eip = (uint)forkret;
-+    sp -= sizeof *p->context;
-+    p->context = (struct context *) sp;
-+    memset(p->context, 0, sizeof *p->context);
-+    p->context->eip = (uint) forkret;
- 
--  return p;
-+    return p;
- }
- 
- //PAGEBREAK: 32
- // Set up first user process.
- void
--userinit(void)
--{
--  struct proc *p;
--  extern char _binary_initcode_start[], _binary_initcode_size[];
++++ /dev/null
+@@ -1,287 +0,0 @@
+-OBJS = \
+-	bio.o\
+-	console.o\
+-	exec.o\
+-	file.o\
+-	fs.o\
+-	ide.o\
+-	ioapic.o\
+-	kalloc.o\
+-	kbd.o\
+-	lapic.o\
+-	log.o\
+-	main.o\
+-	mp.o\
+-	picirq.o\
+-	pipe.o\
+-	proc.o\
+-	sleeplock.o\
+-	spinlock.o\
+-	string.o\
+-	swtch.o\
+-	syscall.o\
+-	sysfile.o\
+-	sysproc.o\
+-	trapasm.o\
+-	trap.o\
+-	uart.o\
+-	vectors.o\
+-	vm.o\
 -
--  p = allocproc();
--  
--  initproc = p;
--  if((p->pgdir = setupkvm()) == 0)
--    panic("userinit: out of memory?");
--  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
--  p->sz = PGSIZE;
--  memset(p->tf, 0, sizeof(*p->tf));
--  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
--  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
--  p->tf->es = p->tf->ds;
--  p->tf->ss = p->tf->ds;
--  p->tf->eflags = FL_IF;
--  p->tf->esp = PGSIZE;
--  p->tf->eip = 0;  // beginning of initcode.S
--
--  safestrcpy(p->name, "initcode", sizeof(p->name));
--  p->cwd = namei("/");
--
--  // this assignment to p->state lets other cores
--  // run this process. the acquire forces the above
--  // writes to be visible, and the lock is also needed
--  // because the assignment might not be atomic.
--  acquire(&ptable.lock);
--
--  p->state = RUNNABLE;
--
--  release(&ptable.lock);
-+userinit(void) {
-+    struct proc *p;
-+    extern char _binary_initcode_start[], _binary_initcode_size[];
-+
-+    p = allocproc();
-+
-+    initproc = p;
-+    if ((p->pgdir = setupkvm()) == 0)
-+        panic("userinit: out of memory?");
-+    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
-+    p->sz = PGSIZE;
-+    memset(p->tf, 0, sizeof(*p->tf));
-+    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
-+    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
-+    p->tf->es = p->tf->ds;
-+    p->tf->ss = p->tf->ds;
-+    p->tf->eflags = FL_IF;
-+    p->tf->esp = PGSIZE;
-+    p->tf->eip = 0;  // beginning of initcode.S
-+
-+    safestrcpy(p->name, "initcode", sizeof(p->name));
-+    p->cwd = namei("/");
-+
-+    // this assignment to p->state lets other cores
-+    // run this process. the acquire forces the above
-+    // writes to be visible, and the lock is also needed
-+    // because the assignment might not be atomic.
-+    acquire(&ptable.lock);
-+
-+    p->state = RUNNABLE;
-+
-+    release(&ptable.lock);
- }
- 
- // Grow current process's memory by n bytes.
- // Return 0 on success, -1 on failure.
- int
--growproc(int n)
--{
--  uint sz;
--  struct proc *curproc = myproc();
+-# Cross-compiling (e.g., on Mac OS X)
+-# TOOLPREFIX = i386-jos-elf
 -
--  sz = curproc->sz;
--  if(n > 0){
--    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
--      return -1;
--  } else if(n < 0){
--    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
--      return -1;
--  }
--  curproc->sz = sz;
--  switchuvm(curproc);
--  return 0;
-+growproc(int n) {
-+    uint sz;
-+    struct proc *curproc = myproc();
-+
-+    sz = curproc->sz;
-+    if (n > 0) {
-+        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
-+            return -1;
-+    } else if (n < 0) {
-+        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
-+            return -1;
-+    }
-+    curproc->sz = sz;
-+    switchuvm(curproc);
-+    return 0;
- }
- 
- // Create a new process copying p as the parent.
- // Sets up stack to return as if from system call.
- // Caller must set state of returned proc to RUNNABLE.
- int
--fork(void)
--{
--  int i, pid;
--  struct proc *np;
--  struct proc *curproc = myproc();
+-# Using native tools (e.g., on X86 Linux)
+-#TOOLPREFIX = 
 -
--  // Allocate process.
--  if((np = allocproc()) == 0){
--    return -1;
--  }
-+fork(void) {
-+    int i, pid;
-+    struct proc *np;
-+    struct proc *curproc = myproc();
-+
-+    // Allocate process.
-+    if ((np = allocproc()) == 0) {
-+        return -1;
-+    }
- 
--  // Copy process state from proc.
--  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
--    kfree(np->kstack);
--    np->kstack = 0;
--    np->state = UNUSED;
--    return -1;
--  }
--  np->sz = curproc->sz;
--  np->parent = curproc;
--  *np->tf = *curproc->tf;
-+    // Copy process state from proc.
-+    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
-+        kfree(np->kstack);
-+        np->kstack = 0;
-+        np->state = UNUSED;
-+        return -1;
-+    }
-+    np->sz = curproc->sz;
-+    np->parent = curproc;
-+    *np->tf = *curproc->tf;
- 
--  // Clear %eax so that fork returns 0 in the child.
--  np->tf->eax = 0;
-+    // Clear %eax so that fork returns 0 in the child.
-+    np->tf->eax = 0;
- 
--  for(i = 0; i < NOFILE; i++)
--    if(curproc->ofile[i])
--      np->ofile[i] = filedup(curproc->ofile[i]);
--  np->cwd = idup(curproc->cwd);
-+    for (i = 0; i < NOFILE; i++)
-+        if (curproc->ofile[i])
-+            np->ofile[i] = filedup(curproc->ofile[i]);
-+    np->cwd = idup(curproc->cwd);
- 
--  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
-+    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
- 
--  pid = np->pid;
-+    pid = np->pid;
- 
--  acquire(&ptable.lock);
-+    acquire(&ptable.lock);
- 
--  np->state = RUNNABLE;
-+    np->state = RUNNABLE;
- 
--  release(&ptable.lock);
-+    release(&ptable.lock);
- 
--  return pid;
-+    return pid;
- }
- 
- // Exit the current process.  Does not return.
- // An exited process remains in the zombie state
- // until its parent calls wait() to find out it exited.
- void
--exit(void)
--{
--  struct proc *curproc = myproc();
--  struct proc *p;
--  int fd;
+-# Try to infer the correct TOOLPREFIX if not set
+-ifndef TOOLPREFIX
+-TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+-	then echo 'i386-jos-elf-'; \
+-	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+-	then echo ''; \
+-	else echo "***" 1>&2; \
+-	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+-	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+-	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+-	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+-	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+-	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+-	echo "***" 1>&2; exit 1; fi)
+-endif
 -
--  if(curproc == initproc)
--    panic("init exiting");
+-# If the makefile can't find QEMU, specify its path here
+-# QEMU = qemu-system-i386
 -
--  // Close all open files.
--  for(fd = 0; fd < NOFILE; fd++){
--    if(curproc->ofile[fd]){
--      fileclose(curproc->ofile[fd]);
--      curproc->ofile[fd] = 0;
-+exit(int status) {
-+    struct proc *curproc = myproc();
-+    struct proc *p;
-+    int fd;
-+
-+    curproc->status = status;
-+
-+    if (curproc == initproc)
-+        panic("init exiting");
-+
-+    // Close all open files.
-+    for (fd = 0; fd < NOFILE; fd++) {
-+        if (curproc->ofile[fd]) {
-+            fileclose(curproc->ofile[fd]);
-+            curproc->ofile[fd] = 0;
-+        }
-     }
--  }
- 
--  begin_op();
--  iput(curproc->cwd);
--  end_op();
--  curproc->cwd = 0;
-+    begin_op();
-+    iput(curproc->cwd);
-+    end_op();
-+    curproc->cwd = 0;
- 
--  acquire(&ptable.lock);
-+    acquire(&ptable.lock);
- 
--  // Parent might be sleeping in wait().
--  wakeup1(curproc->parent);
-+    // Parent might be sleeping in wait().
-+    wakeup1(curproc->parent);
- 
--  // Pass abandoned children to init.
--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
--    if(p->parent == curproc){
--      p->parent = initproc;
--      if(p->state == ZOMBIE)
--        wakeup1(initproc);
-+    // Pass abandoned children to init.
-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-+        if (p->parent == curproc) {
-+            p->parent = initproc;
-+            if (p->state == ZOMBIE)
-+                wakeup1(initproc);
-+        }
-     }
--  }
- 
--  // Jump into the scheduler, never to return.
--  curproc->state = ZOMBIE;
--  sched();
--  panic("zombie exit");
-+    // Jump into the scheduler, never to return.
-+    curproc->state = ZOMBIE;
-+    sched();
-+    panic("zombie exit");
- }
- 
- // Wait for a child process to exit and return its pid.
- // Return -1 if this process has no children.
- int
--wait(void)
--{
--  struct proc *p;
--  int havekids, pid;
--  struct proc *curproc = myproc();
--  
--  acquire(&ptable.lock);
--  for(;;){
--    // Scan through table looking for exited children.
--    havekids = 0;
--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
--      if(p->parent != curproc)
--        continue;
--      havekids = 1;
--      if(p->state == ZOMBIE){
--        // Found one.
--        pid = p->pid;
--        kfree(p->kstack);
--        p->kstack = 0;
--        freevm(p->pgdir);
--        p->pid = 0;
--        p->parent = 0;
--        p->name[0] = 0;
--        p->killed = 0;
--        p->state = UNUSED;
--        release(&ptable.lock);
--        return pid;
--      }
--    }
-+wait(int *status) {
-+    struct proc *p;
-+    int havekids, pid;
-+    struct proc *curproc = myproc();
- 
--    // No point waiting if we don't have any children.
--    if(!havekids || curproc->killed){
--      release(&ptable.lock);
--      return -1;
-+    acquire(&ptable.lock);
-+    for (;;) {
-+        // Scan through table looking for exited children.
-+        havekids = 0;
-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-+            if (p->parent != curproc)
-+                continue;
-+            havekids = 1;
-+            if (p->state == ZOMBIE) {
-+                // Found one.
-+                pid = p->pid;
-+                kfree(p->kstack);
-+                p->kstack = 0;
-+                freevm(p->pgdir);
-+                p->pid = 0;
-+                p->parent = 0;
-+                p->name[0] = 0;
-+                p->killed = 0;
-+                p->state = UNUSED;
-+                release(&ptable.lock);
-+                if (status != NULL)
-+                    *status = p->status;
-+                return pid;
-+            }
-+        }
-+
-+        // No point waiting if we don't have any children.
-+        if (!havekids || curproc->killed) {
-+            release(&ptable.lock);
-+            return -1;
-+        }
-+
-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
-     }
-+}
- 
--    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
--    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
--  }
-+// Wait for a child process to exit and return its pid.
-+// Return -1 if this process has no children.
-+int
-+waitpid(int pidBeingSearchedFor, int *status, int options) {
-+    struct proc *p;
-+    int doesProcExist, pidFound;
-+    struct proc *curproc = myproc();
-+    acquire(&ptable.lock);
-+    for (;;) {
-+        // Scan through table looking for exited children.
-+        doesProcExist = 0;
-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-+//            if(p->parent != curproc)
-+//                continue;
-+
-+            if (p->pid != pidBeingSearchedFor)
-+                continue;
-+
-+            doesProcExist = 1;
-+            if (p->state == ZOMBIE) {
-+                // Found one.
-+                pidFound = p->pid;
-+                kfree(p->kstack);
-+                p->kstack = 0;
-+                freevm(p->pgdir);
-+                p->pid = 0;
-+                p->parent = 0;
-+                p->name[0] = 0;
-+                p->killed = 0;
-+                p->state = UNUSED;
-+                release(&ptable.lock);
-+                if (status != NULL)
-+                    *status = p->status;
-+                return pidFound;
-+            }
-+        }
-+
-+//        // No point waiting if we don't have any children.
-+//        if(!havekids || curproc->killed){
-+//            release(&ptable.lock);
-+//            return -1;
-+//        }
-+
-+        if (!doesProcExist || curproc->killed) {
-+            release(&ptable.lock);
-+            return -1;
-+        }
-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
-+    }
- }
- 
- //PAGEBREAK: 42
-@@ -320,39 +372,38 @@ wait(void)
- //  - eventually that process transfers control
- //      via swtch back to the scheduler.
- void
--scheduler(void)
--{
--  struct proc *p;
--  struct cpu *c = mycpu();
--  c->proc = 0;
--  
--  for(;;){
--    // Enable interrupts on this processor.
--    sti();
+-# Try to infer the correct QEMU
+-ifndef QEMU
+-QEMU = $(shell if which qemu > /dev/null; \
+-	then echo qemu; exit; \
+-	elif which qemu-system-i386 > /dev/null; \
+-	then echo qemu-system-i386; exit; \
+-	elif which qemu-system-x86_64 > /dev/null; \
+-	then echo qemu-system-x86_64; exit; \
+-	else \
+-	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+-	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+-	echo "***" 1>&2; \
+-	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+-	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+-	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+-	echo "***" 1>&2; exit 1)
+-endif
 -
--    // Loop over process table looking for process to run.
--    acquire(&ptable.lock);
--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
--      if(p->state != RUNNABLE)
--        continue;
+-CC = $(TOOLPREFIX)gcc
+-AS = $(TOOLPREFIX)gas
+-LD = $(TOOLPREFIX)ld
+-OBJCOPY = $(TOOLPREFIX)objcopy
+-OBJDUMP = $(TOOLPREFIX)objdump
+-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+-CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+-ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+-# FreeBSD ld wants ``elf_i386_fbsd''
+-LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
 -
--      // Switch to chosen process.  It is the process's job
--      // to release ptable.lock and then reacquire it
--      // before jumping back to us.
--      c->proc = p;
--      switchuvm(p);
--      p->state = RUNNING;
+-# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+-CFLAGS += -fno-pie -no-pie
+-endif
+-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+-CFLAGS += -fno-pie -nopie
+-endif
 -
--      swtch(&(c->scheduler), p->context);
--      switchkvm();
+-xv6.img: bootblock kernel
+-	dd if=/dev/zero of=xv6.img count=10000
+-	dd if=bootblock of=xv6.img conv=notrunc
+-	dd if=kernel of=xv6.img seek=1 conv=notrunc
 -
--      // Process is done running for now.
--      // It should have changed its p->state before coming back.
--      c->proc = 0;
--    }
--    release(&ptable.lock);
-+scheduler(void) {
-+    struct proc *p;
-+    struct cpu *c = mycpu();
-+    c->proc = 0;
-+
-+    for (;;) {
-+        // Enable interrupts on this processor.
-+        sti();
-+
-+        // Loop over process table looking for process to run.
-+        acquire(&ptable.lock);
-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-+            if (p->state != RUNNABLE)
-+                continue;
-+
-+            // Switch to chosen process.  It is the process's job
-+            // to release ptable.lock and then reacquire it
-+            // before jumping back to us.
-+            c->proc = p;
-+            switchuvm(p);
-+            p->state = RUNNING;
-+
-+            swtch(&(c->scheduler), p->context);
-+            switchkvm();
-+
-+            // Process is done running for now.
-+            // It should have changed its p->state before coming back.
-+            c->proc = 0;
-+        }
-+        release(&ptable.lock);
- 
--  }
-+    }
- }
- 
- // Enter scheduler.  Must hold only ptable.lock
-@@ -363,137 +414,130 @@ scheduler(void)
- // break in the few places where a lock is held but
- // there's no process.
- void
--sched(void)
--{
--  int intena;
--  struct proc *p = myproc();
--
--  if(!holding(&ptable.lock))
--    panic("sched ptable.lock");
--  if(mycpu()->ncli != 1)
--    panic("sched locks");
--  if(p->state == RUNNING)
--    panic("sched running");
--  if(readeflags()&FL_IF)
--    panic("sched interruptible");
--  intena = mycpu()->intena;
--  swtch(&p->context, mycpu()->scheduler);
--  mycpu()->intena = intena;
-+sched(void) {
-+    int intena;
-+    struct proc *p = myproc();
-+
-+    if (!holding(&ptable.lock))
-+        panic("sched ptable.lock");
-+    if (mycpu()->ncli != 1)
-+        panic("sched locks");
-+    if (p->state == RUNNING)
-+        panic("sched running");
-+    if (readeflags() & FL_IF)
-+        panic("sched interruptible");
-+    intena = mycpu()->intena;
-+    swtch(&p->context, mycpu()->scheduler);
-+    mycpu()->intena = intena;
- }
- 
- // Give up the CPU for one scheduling round.
- void
--yield(void)
--{
--  acquire(&ptable.lock);  //DOC: yieldlock
--  myproc()->state = RUNNABLE;
--  sched();
--  release(&ptable.lock);
-+yield(void) {
-+    acquire(&ptable.lock);  //DOC: yieldlock
-+    myproc()->state = RUNNABLE;
-+    sched();
-+    release(&ptable.lock);
- }
- 
- // A fork child's very first scheduling by scheduler()
- // will swtch here.  "Return" to user space.
- void
--forkret(void)
--{
--  static int first = 1;
--  // Still holding ptable.lock from scheduler.
--  release(&ptable.lock);
--
--  if (first) {
--    // Some initialization functions must be run in the context
--    // of a regular process (e.g., they call sleep), and thus cannot
--    // be run from main().
--    first = 0;
--    iinit(ROOTDEV);
--    initlog(ROOTDEV);
--  }
--
--  // Return to "caller", actually trapret (see allocproc).
-+forkret(void) {
-+    static int first = 1;
-+    // Still holding ptable.lock from scheduler.
-+    release(&ptable.lock);
-+
-+    if (first) {
-+        // Some initialization functions must be run in the context
-+        // of a regular process (e.g., they call sleep), and thus cannot
-+        // be run from main().
-+        first = 0;
-+        iinit(ROOTDEV);
-+        initlog(ROOTDEV);
-+    }
-+
-+    // Return to "caller", actually trapret (see allocproc).
- }
- 
- // Atomically release lock and sleep on chan.
- // Reacquires lock when awakened.
- void
--sleep(void *chan, struct spinlock *lk)
--{
--  struct proc *p = myproc();
--  
--  if(p == 0)
--    panic("sleep");
+-xv6memfs.img: bootblock kernelmemfs
+-	dd if=/dev/zero of=xv6memfs.img count=10000
+-	dd if=bootblock of=xv6memfs.img conv=notrunc
+-	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
 -
--  if(lk == 0)
--    panic("sleep without lk");
+-bootblock: bootasm.S bootmain.c
+-	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+-	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+-	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+-	$(OBJDUMP) -S bootblock.o > bootblock.asm
+-	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+-	./sign.pl bootblock
 -
--  // Must acquire ptable.lock in order to
--  // change p->state and then call sched.
--  // Once we hold ptable.lock, we can be
--  // guaranteed that we won't miss any wakeup
--  // (wakeup runs with ptable.lock locked),
--  // so it's okay to release lk.
--  if(lk != &ptable.lock){  //DOC: sleeplock0
--    acquire(&ptable.lock);  //DOC: sleeplock1
--    release(lk);
--  }
--  // Go to sleep.
--  p->chan = chan;
--  p->state = SLEEPING;
+-entryother: entryother.S
+-	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+-	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+-	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+-	$(OBJDUMP) -S bootblockother.o > entryother.asm
 -
--  sched();
+-initcode: initcode.S
+-	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+-	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+-	$(OBJCOPY) -S -O binary initcode.out initcode
+-	$(OBJDUMP) -S initcode.o > initcode.asm
 -
--  // Tidy up.
--  p->chan = 0;
+-kernel: $(OBJS) entry.o entryother initcode kernel.ld
+-	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+-	$(OBJDUMP) -S kernel > kernel.asm
+-	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
 -
--  // Reacquire original lock.
--  if(lk != &ptable.lock){  //DOC: sleeplock2
--    release(&ptable.lock);
--    acquire(lk);
--  }
-+sleep(void *chan, struct spinlock *lk) {
-+    struct proc *p = myproc();
-+
-+    if (p == 0)
-+        panic("sleep");
-+
-+    if (lk == 0)
-+        panic("sleep without lk");
-+
-+    // Must acquire ptable.lock in order to
-+    // change p->state and then call sched.
-+    // Once we hold ptable.lock, we can be
-+    // guaranteed that we won't miss any wakeup
-+    // (wakeup runs with ptable.lock locked),
-+    // so it's okay to release lk.
-+    if (lk != &ptable.lock) {  //DOC: sleeplock0
-+        acquire(&ptable.lock);  //DOC: sleeplock1
-+        release(lk);
-+    }
-+    // Go to sleep.
-+    p->chan = chan;
-+    p->state = SLEEPING;
-+
-+    sched();
-+
-+    // Tidy up.
-+    p->chan = 0;
-+
-+    // Reacquire original lock.
-+    if (lk != &ptable.lock) {  //DOC: sleeplock2
-+        release(&ptable.lock);
-+        acquire(lk);
-+    }
- }
- 
- //PAGEBREAK!
- // Wake up all processes sleeping on chan.
- // The ptable lock must be held.
- static void
--wakeup1(void *chan)
--{
--  struct proc *p;
-+wakeup1(void *chan) {
-+    struct proc *p;
- 
--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
--    if(p->state == SLEEPING && p->chan == chan)
--      p->state = RUNNABLE;
-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-+        if (p->state == SLEEPING && p->chan == chan)
-+            p->state = RUNNABLE;
- }
- 
- // Wake up all processes sleeping on chan.
- void
--wakeup(void *chan)
--{
--  acquire(&ptable.lock);
--  wakeup1(chan);
--  release(&ptable.lock);
-+wakeup(void *chan) {
-+    acquire(&ptable.lock);
-+    wakeup1(chan);
-+    release(&ptable.lock);
- }
- 
- // Kill the process with the given pid.
- // Process won't exit until it returns
- // to user space (see trap in trap.c).
- int
--kill(int pid)
--{
--  struct proc *p;
--
--  acquire(&ptable.lock);
--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
--    if(p->pid == pid){
--      p->killed = 1;
--      // Wake process from sleep if necessary.
--      if(p->state == SLEEPING)
--        p->state = RUNNABLE;
--      release(&ptable.lock);
--      return 0;
-+kill(int pid) {
-+    struct proc *p;
-+
-+    acquire(&ptable.lock);
-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-+        if (p->pid == pid) {
-+            p->killed = 1;
-+            // Wake process from sleep if necessary.
-+            if (p->state == SLEEPING)
-+                p->state = RUNNABLE;
-+            release(&ptable.lock);
-+            return 0;
-+        }
-     }
--  }
--  release(&ptable.lock);
--  return -1;
-+    release(&ptable.lock);
-+    return -1;
- }
- 
- //PAGEBREAK: 36
-@@ -501,34 +545,33 @@ kill(int pid)
- // Runs when user types ^P on console.
- // No lock to avoid wedging a stuck machine further.
- void
--procdump(void)
--{
--  static char *states[] = {
--  [UNUSED]    "unused",
--  [EMBRYO]    "embryo",
--  [SLEEPING]  "sleep ",
--  [RUNNABLE]  "runble",
--  [RUNNING]   "run   ",
--  [ZOMBIE]    "zombie"
--  };
--  int i;
--  struct proc *p;
--  char *state;
--  uint pc[10];
+-# kernelmemfs is a copy of kernel that maintains the
+-# disk image in memory instead of writing to a disk.
+-# This is not so useful for testing persistent storage or
+-# exploring disk buffering implementations, but it is
+-# great for testing the kernel on real hardware without
+-# needing a scratch disk.
+-MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+-kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+-	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+-	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+-	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
 -
--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
--    if(p->state == UNUSED)
+-tags: $(OBJS) entryother.S _init
+-	etags *.S *.c
+-
+-vectors.S: vectors.pl
+-	./vectors.pl > vectors.S
+-
+-ULIB = ulib.o usys.o printf.o umalloc.o
+-
+-_%: %.o $(ULIB)
+-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+-	$(OBJDUMP) -S $@ > $*.asm
+-	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+-
+-_forktest: forktest.o $(ULIB)
+-	# forktest has less library code linked in - needs to be small
+-	# in order to be able to max out the proc table.
+-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+-	$(OBJDUMP) -S _forktest > forktest.asm
+-
+-mkfs: mkfs.c fs.h
+-	gcc -Werror -Wall -o mkfs mkfs.c
+-
+-# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+-# that disk image changes after first build are persistent until clean.  More
+-# details:
+-# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+-.PRECIOUS: %.o
+-
+-UPROGS=\
+-	_cat\
+-	_echo\
+-	_forktest\
+-	_grep\
+-	_init\
+-	_kill\
+-	_ln\
+-	_ls\
+-	_mkdir\
+-	_rm\
+-	_sh\
+-	_stressfs\
+-	_usertests\
+-	_wc\
+-	_zombie\
+-	_lab1\
+-
+-fs.img: mkfs README $(UPROGS)
+-	./mkfs fs.img README $(UPROGS)
+-
+--include *.d
+-
+-clean: 
+-	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+-	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+-	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+-	xv6memfs.img mkfs .gdbinit \
+-	$(UPROGS)
+-
+-# make a printout
+-FILES = $(shell grep -v '^\#' runoff.list)
+-PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+-
+-xv6.pdf: $(PRINT)
+-	./runoff
+-	ls -l xv6.pdf
+-
+-print: xv6.pdf
+-
+-# run in emulators
+-
+-bochs : fs.img xv6.img
+-	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+-	bochs -q
+-
+-# try to generate a unique GDB port
+-GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+-# QEMU's gdb stub command line changed in 0.11
+-QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+-	then echo "-gdb tcp::$(GDBPORT)"; \
+-	else echo "-s -p $(GDBPORT)"; fi)
+-ifndef CPUS
+-CPUS := 2
+-endif
+-QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+-
+-qemu: fs.img xv6.img
+-	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+-
+-qemu-memfs: xv6memfs.img
+-	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+-
+-qemu-nox: fs.img xv6.img
+-	$(QEMU) -nographic $(QEMUOPTS)
+-
+-.gdbinit: .gdbinit.tmpl
+-	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+-
+-qemu-gdb: fs.img xv6.img .gdbinit
+-	@echo "*** Now run 'gdb'." 1>&2
+-	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+-
+-qemu-nox-gdb: fs.img xv6.img .gdbinit
+-	@echo "*** Now run 'gdb'." 1>&2
+-	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+-
+-# CUT HERE
+-# prepare dist for students
+-# after running make dist, probably want to
+-# rename it to rev0 or rev1 or so on and then
+-# check in that version.
+-
+-EXTRA=\
+-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+-	printf.c umalloc.c\
+-	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+-	.gdbinit.tmpl gdbutil\
+-
+-dist:
+-	rm -rf dist
+-	mkdir dist
+-	for i in $(FILES); \
+-	do \
+-		grep -v PAGEBREAK $$i >dist/$$i; \
+-	done
+-	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+-	echo >dist/runoff.spec
+-	cp $(EXTRA) dist
+-
+-dist-test:
+-	rm -rf dist
+-	make dist
+-	rm -rf dist-test
+-	mkdir dist-test
+-	cp dist/* dist-test
+-	cd dist-test; $(MAKE) print
+-	cd dist-test; $(MAKE) bochs || true
+-	cd dist-test; $(MAKE) qemu
+-
+-# update this rule (change rev#) when it is time to
+-# make a new revision.
+-tar:
+-	rm -rf /tmp/xv6
+-	mkdir -p /tmp/xv6
+-	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+-	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+-
+-.PHONY: dist-test dist
+diff --git a/Notes b/Notes
+deleted file mode 100644
+index 74c8aea..0000000
+--- a/Notes
++++ /dev/null
+@@ -1,123 +0,0 @@
+-bochs 2.2.6:
+-./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae --disable-reset-on-triple-fault
+-bochs CVS after 2.2.6:
+-./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae 
+-
+-bootmain.c doesn't work right if the ELF sections aren't
+-sector-aligned. so you can't use ld -N. and the sections may also need
+-to be non-zero length, only really matters for tiny "kernels".
+-
+-kernel loaded at 1 megabyte. stack same place that bootasm.S left it.
+-
+-kinit() should find real mem size
+-  and rescue useable memory below 1 meg
+-
+-no paging, no use of page table hardware, just segments
+-
+-no user area: no magic kernel stack mapping
+-  so no copying of kernel stack during fork
+-  though there is a kernel stack page for each process
+-
+-no kernel malloc(), just kalloc() for user core
+-
+-user pointers aren't valid in the kernel
+-
+-are interrupts turned on in the kernel? yes.
+-
+-pass curproc explicitly, or implicit from cpu #?
+-  e.g. argument to newproc()?
+-  hmm, you need a global curproc[cpu] for trap() &c
+-
+-no stack expansion
+-
+-test running out of memory, process slots
+-
+-we can't really use a separate stack segment, since stack addresses
+-need to work correctly as ordinary pointers. the same may be true of
+-data vs text. how can we have a gap between data and stack, so that
+-both can grow, without committing 4GB of physical memory? does this
+-mean we need paging?
+-
+-perhaps have fixed-size stack, put it in the data segment?
+-
+-oops, if kernel stack is in contiguous user phys mem, then moving
+-users' memory (e.g. to expand it) will wreck any pointers into the
+-kernel stack.
+-
+-do we need to set fs and gs? so user processes can't abuse them?
+-
+-setupsegs() may modify current segment table, is that legal?
+-
+-trap() ought to lgdt on return, since currently only done in swtch()
+-
+-protect hardware interrupt vectors from user INT instructions?
+-
+-test out-of-fd cases for creating pipe.
+-test pipe reader closes then write
+-test two readers, two writers.
+-test children being inherited by grandparent &c
+-
+-some sleep()s should be interruptible by kill()
+-
+-locks
+-  init_lock
+-    sequences CPU startup
+-  proc_table_lock
+-    also protects next_pid
+-  per-fd lock *just* protects count read-modify-write
+-    also maybe freeness?
+-  memory allocator
+-  printf
+-
+-in general, the table locks protect both free-ness and
+-  public variables of table elements
+-  in many cases you can use table elements w/o a lock
+-  e.g. if you are the process, or you are using an fd
+-
+-lock order
+-  per-pipe lock
+-  proc_table_lock fd_table_lock kalloc_lock
+-  console_lock
+-
+-do you have to be holding the mutex in order to call wakeup()? yes
+-
+-device interrupts don't clear FL_IF
+-  so a recursive timer interrupt is possible
+-
+-what does inode->busy mean?
+-  might be held across disk reads
+-  no-one is allowed to do anything to the inode
+-  protected by inode_table_lock
+-inode->count counts in-memory pointers to the struct
+-  prevents inode[] element from being re-used
+-  protected by inode_table_lock
+-
+-blocks and inodes have ad-hoc sleep-locks
+-  provide a single mechanism?
+-
+-kalloc() can return 0; do callers handle this right?
+-
+-test: one process unlinks a file while another links to it
+-test: one process opens a file while another deletes it
+-test: deadlock d/.. vs ../d, two processes.
+-test: dup() shared fd->off
+-test: does echo foo > x truncate x?
+-
+-sh: ioredirection incorrect now we have pipes
+-sh: chain of pipes won't work, also ugly that parent closes fdarray entries too
+-sh: dynamic memory allocation?
+-sh: should sh support ; () &
+-sh: stop stdin on ctrl-d (for cat > y)
+-
+-really should have bdwrite() for file content
+-  and make some inode updates async
+-  so soft updates make sense
+-
+-disk scheduling
+-echo foo > bar should truncate bar
+-  so O_CREATE should not truncate
+-  but O_TRUNC should
+-
+-make it work on a real machine
+-release before acquire at end of sleep?
+-check 2nd disk (i.e. if not in .bochsrc)
+diff --git a/README b/README
+deleted file mode 100644
+index 923e0a4..0000000
+--- a/README
++++ /dev/null
+@@ -1,51 +0,0 @@
+-NOTE: we have stopped maintaining the x86 version of xv6, and switched
+-our efforts to the RISC-V version
+-(https://github.com/mit-pdos/xv6-riscv.git)
+-
+-xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
+-Version 6 (v6).  xv6 loosely follows the structure and style of v6,
+-but is implemented for a modern x86-based multiprocessor using ANSI C.
+-
+-ACKNOWLEDGMENTS
+-
+-xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
+-to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
+-2000)). See also https://pdos.csail.mit.edu/6.828/, which
+-provides pointers to on-line resources for v6.
+-
+-xv6 borrows code from the following sources:
+-    JOS (asm.h, elf.h, mmu.h, bootasm.S, ide.c, console.c, and others)
+-    Plan 9 (entryother.S, mp.h, mp.c, lapic.c)
+-    FreeBSD (ioapic.c)
+-    NetBSD (console.c)
+-
+-The following people have made contributions: Russ Cox (context switching,
+-locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
+-Clements.
+-
+-We are also grateful for the bug reports and patches contributed by Silas
+-Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,
+-Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter
+-Froehlich, Yakir Goaron,Shivam Handa, Bryan Henry, Jim Huang, Alexander
+-Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller, Eddie Kohler, Austin
+-Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi
+-Merimovich, Mark Morrissey, mtasm, Joel Nider, Greg Price, Ayan Shafqat,
+-Eldar Sehayek, Yongming Shen, Cam Tenny, tyfkda, Rafael Ubal, Warren
+-Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
+-Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang Wei.
+-
+-The code in the files that constitute xv6 is
+-Copyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.
+-
+-ERROR REPORTS
+-
+-We don't process error reports (see note on top of this file).
+-
+-BUILDING AND RUNNING XV6
+-
+-To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
+-"make". On non-x86 or non-ELF machines (like OS X, even on x86), you
+-will need to install a cross-compiler gcc suite capable of producing
+-x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
+-Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
+-simulator and run "make qemu".
+\ No newline at end of file
+diff --git a/TRICKS b/TRICKS
+deleted file mode 100644
+index 8d1439f..0000000
+--- a/TRICKS
++++ /dev/null
+@@ -1,140 +0,0 @@
+-This file lists subtle things that might not be commented 
+-as well as they should be in the source code and that
+-might be worth pointing out in a longer explanation or in class.
+-
+----
+-
+-[2009/07/12: No longer relevant; forkret1 changed
+-and this is now cleaner.]
+-
+-forkret1 in trapasm.S is called with a tf argument.
+-In order to use it, forkret1 copies the tf pointer into
+-%esp and then jumps to trapret, which pops the 
+-register state out of the trap frame.  If an interrupt
+-came in between the mov tf, %esp and the iret that
+-goes back out to user space, the interrupt stack frame
+-would end up scribbling over the tf and whatever memory
+-lay under it.
+-
+-Why is this safe?  Because forkret1 is only called
+-the first time a process returns to user space, and
+-at that point, cp->tf is set to point to a trap frame
+-constructed at the top of cp's kernel stack.  So tf 
+-*is* a valid %esp that can hold interrupt state.
+-
+-If other tf's were used in forkret1, we could add
+-a cli before the mov tf, %esp.
+-
+----
+-
+-In pushcli, must cli() no matter what.  It is not safe to do
+-
+-  if(cpus[cpu()].ncli == 0)
+-    cli();
+-  cpus[cpu()].ncli++;
+-
+-because if interrupts are off then we might call cpu(), get
+-rescheduled to a different cpu, look at cpus[oldcpu].ncli,
+-and wrongly decide not to disable interrupts on the new cpu.
+-
+-Instead do 
+-
+-  cli();
+-  cpus[cpu()].ncli++;
+-
+-always.
+-
+----
+-
+-There is a (harmless) race in pushcli, which does
+-
+-	eflags = readeflags();
+-	cli();
+-	if(c->ncli++ == 0)
+-		c->intena = eflags & FL_IF;
+-
+-Consider a bottom-level pushcli.  
+-If interrupts are disabled already, then the right thing
+-happens: read_eflags finds that FL_IF is not set,
+-and intena = 0.  If interrupts are enabled, then
+-it is less clear that the right thing happens:
+-the readeflags can execute, then the process
+-can get preempted and rescheduled on another cpu,
+-and then once it starts running, perhaps with 
+-interrupts disabled (can happen since the scheduler
+-only enables interrupts once per scheduling loop,
+-not every time it schedules a process), it will 
+-incorrectly record that interrupts *were* enabled.
+-This doesn't matter, because if it was safe to be
+-running with interrupts enabled before the context
+-switch, it is still safe (and arguably more correct)
+-to run with them enabled after the context switch too.
+-
+-In fact it would be safe if scheduler always set
+-	c->intena = 1;
+-before calling swtch, and perhaps it should.
+-
+----
+-
+-The x86's processor-ordering memory model 
+-matches spin locks well, so no explicit memory
+-synchronization instructions are required in
+-acquire and release.  
+-
+-Consider two sequences of code on different CPUs:
+-
+-CPU0
+-A;
+-release(lk);
+-
+-and
+-
+-CPU1
+-acquire(lk);
+-B;
+-
+-We want to make sure that:
+-  - all reads in B see the effects of writes in A.
+-  - all reads in A do *not* see the effects of writes in B.
+- 
+-The x86 guarantees that writes in A will go out
+-to memory before the write of lk->locked = 0 in 
+-release(lk).  It further guarantees that CPU1 
+-will observe CPU0's write of lk->locked = 0 only
+-after observing the earlier writes by CPU0.
+-So any reads in B are guaranteed to observe the
+-effects of writes in A.
+-
+-According to the Intel manual behavior spec, the
+-second condition requires a serialization instruction
+-in release, to avoid reads in A happening after giving
+-up lk.  No Intel SMP processor in existence actually
+-moves reads down after writes, but the language in
+-the spec allows it.  There is no telling whether future
+-processors will need it.
+-
+----
+-
+-The code in fork needs to read np->pid before
+-setting np->state to RUNNABLE.  The following
+-is not a correct way to do this:
+-
+-	int
+-	fork(void)
+-	{
+-	  ...
+-	  np->state = RUNNABLE;
+-	  return np->pid; // oops
+-	}
+-
+-After setting np->state to RUNNABLE, some other CPU
+-might run the process, it might exit, and then it might
+-get reused for a different process (with a new pid), all
+-before the return statement.  So it's not safe to just
+-"return np->pid". Even saving a copy of np->pid before
+-setting np->state isn't safe, since the compiler is
+-allowed to re-order statements.
+-
+-The real code saves a copy of np->pid, then acquires a lock
+-around the write to np->state. The acquire() prevents the
+-compiler from re-ordering.
+diff --git a/asm.h b/asm.h
+deleted file mode 100644
+index b8a7353..0000000
+--- a/asm.h
++++ /dev/null
+@@ -1,18 +0,0 @@
+-//
+-// assembler macros to create x86 segments
+-//
+-
+-#define SEG_NULLASM                                             \
+-        .word 0, 0;                                             \
+-        .byte 0, 0, 0, 0
+-
+-// The 0xC0 means the limit is in 4096-byte units
+-// and (for executable segments) 32-bit mode.
+-#define SEG_ASM(type,base,lim)                                  \
+-        .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
+-        .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
+-                (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
+-
+-#define STA_X     0x8       // Executable segment
+-#define STA_W     0x2       // Writeable (non-executable segments)
+-#define STA_R     0x2       // Readable (executable segments)
+diff --git a/bio.c b/bio.c
+deleted file mode 100644
+index a45ff3e..0000000
+--- a/bio.c
++++ /dev/null
+@@ -1,144 +0,0 @@
+-// Buffer cache.
+-//
+-// The buffer cache is a linked list of buf structures holding
+-// cached copies of disk block contents.  Caching disk blocks
+-// in memory reduces the number of disk reads and also provides
+-// a synchronization point for disk blocks used by multiple processes.
+-//
+-// Interface:
+-// * To get a buffer for a particular disk block, call bread.
+-// * After changing buffer data, call bwrite to write it to disk.
+-// * When done with the buffer, call brelse.
+-// * Do not use the buffer after calling brelse.
+-// * Only one process at a time can use a buffer,
+-//     so do not keep them longer than necessary.
+-//
+-// The implementation uses two state flags internally:
+-// * B_VALID: the buffer data has been read from the disk.
+-// * B_DIRTY: the buffer data has been modified
+-//     and needs to be written to disk.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "buf.h"
+-
+-struct {
+-  struct spinlock lock;
+-  struct buf buf[NBUF];
+-
+-  // Linked list of all buffers, through prev/next.
+-  // head.next is most recently used.
+-  struct buf head;
+-} bcache;
+-
+-void
+-binit(void)
+-{
+-  struct buf *b;
+-
+-  initlock(&bcache.lock, "bcache");
+-
+-//PAGEBREAK!
+-  // Create linked list of buffers
+-  bcache.head.prev = &bcache.head;
+-  bcache.head.next = &bcache.head;
+-  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+-    b->next = bcache.head.next;
+-    b->prev = &bcache.head;
+-    initsleeplock(&b->lock, "buffer");
+-    bcache.head.next->prev = b;
+-    bcache.head.next = b;
+-  }
+-}
+-
+-// Look through buffer cache for block on device dev.
+-// If not found, allocate a buffer.
+-// In either case, return locked buffer.
+-static struct buf*
+-bget(uint dev, uint blockno)
+-{
+-  struct buf *b;
+-
+-  acquire(&bcache.lock);
+-
+-  // Is the block already cached?
+-  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+-    if(b->dev == dev && b->blockno == blockno){
+-      b->refcnt++;
+-      release(&bcache.lock);
+-      acquiresleep(&b->lock);
+-      return b;
+-    }
+-  }
+-
+-  // Not cached; recycle an unused buffer.
+-  // Even if refcnt==0, B_DIRTY indicates a buffer is in use
+-  // because log.c has modified it but not yet committed it.
+-  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+-    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
+-      b->dev = dev;
+-      b->blockno = blockno;
+-      b->flags = 0;
+-      b->refcnt = 1;
+-      release(&bcache.lock);
+-      acquiresleep(&b->lock);
+-      return b;
+-    }
+-  }
+-  panic("bget: no buffers");
+-}
+-
+-// Return a locked buf with the contents of the indicated block.
+-struct buf*
+-bread(uint dev, uint blockno)
+-{
+-  struct buf *b;
+-
+-  b = bget(dev, blockno);
+-  if((b->flags & B_VALID) == 0) {
+-    iderw(b);
+-  }
+-  return b;
+-}
+-
+-// Write b's contents to disk.  Must be locked.
+-void
+-bwrite(struct buf *b)
+-{
+-  if(!holdingsleep(&b->lock))
+-    panic("bwrite");
+-  b->flags |= B_DIRTY;
+-  iderw(b);
+-}
+-
+-// Release a locked buffer.
+-// Move to the head of the MRU list.
+-void
+-brelse(struct buf *b)
+-{
+-  if(!holdingsleep(&b->lock))
+-    panic("brelse");
+-
+-  releasesleep(&b->lock);
+-
+-  acquire(&bcache.lock);
+-  b->refcnt--;
+-  if (b->refcnt == 0) {
+-    // no one is waiting for it.
+-    b->next->prev = b->prev;
+-    b->prev->next = b->next;
+-    b->next = bcache.head.next;
+-    b->prev = &bcache.head;
+-    bcache.head.next->prev = b;
+-    bcache.head.next = b;
+-  }
+-  
+-  release(&bcache.lock);
+-}
+-//PAGEBREAK!
+-// Blank page.
+-
+diff --git a/bootasm.S b/bootasm.S
+deleted file mode 100644
+index 257867c..0000000
+--- a/bootasm.S
++++ /dev/null
+@@ -1,88 +0,0 @@
+-#include "asm.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-
+-# Start the first CPU: switch to 32-bit protected mode, jump into C.
+-# The BIOS loads this code from the first sector of the hard disk into
+-# memory at physical address 0x7c00 and starts executing in real mode
+-# with %cs=0 %ip=7c00.
+-
+-.code16                       # Assemble for 16-bit mode
+-.globl start
+-start:
+-  cli                         # BIOS enabled interrupts; disable
+-
+-  # Zero data segment registers DS, ES, and SS.
+-  xorw    %ax,%ax             # Set %ax to zero
+-  movw    %ax,%ds             # -> Data Segment
+-  movw    %ax,%es             # -> Extra Segment
+-  movw    %ax,%ss             # -> Stack Segment
+-
+-  # Physical address line A20 is tied to zero so that the first PCs 
+-  # with 2 MB would run software that assumed 1 MB.  Undo that.
+-seta20.1:
+-  inb     $0x64,%al               # Wait for not busy
+-  testb   $0x2,%al
+-  jnz     seta20.1
+-
+-  movb    $0xd1,%al               # 0xd1 -> port 0x64
+-  outb    %al,$0x64
+-
+-seta20.2:
+-  inb     $0x64,%al               # Wait for not busy
+-  testb   $0x2,%al
+-  jnz     seta20.2
+-
+-  movb    $0xdf,%al               # 0xdf -> port 0x60
+-  outb    %al,$0x60
+-
+-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+-  # virtual addresses map directly to physical addresses so that the
+-  # effective memory map doesn't change during the transition.
+-  lgdt    gdtdesc
+-  movl    %cr0, %eax
+-  orl     $CR0_PE, %eax
+-  movl    %eax, %cr0
+-
+-//PAGEBREAK!
+-  # Complete the transition to 32-bit protected mode by using a long jmp
+-  # to reload %cs and %eip.  The segment descriptors are set up with no
+-  # translation, so that the mapping is still the identity mapping.
+-  ljmp    $(SEG_KCODE<<3), $start32
+-
+-.code32  # Tell assembler to generate 32-bit code now.
+-start32:
+-  # Set up the protected-mode data segment registers
+-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+-  movw    %ax, %ds                # -> DS: Data Segment
+-  movw    %ax, %es                # -> ES: Extra Segment
+-  movw    %ax, %ss                # -> SS: Stack Segment
+-  movw    $0, %ax                 # Zero segments not ready for use
+-  movw    %ax, %fs                # -> FS
+-  movw    %ax, %gs                # -> GS
+-
+-  # Set up the stack pointer and call into C.
+-  movl    $start, %esp
+-  call    bootmain
+-
+-  # If bootmain returns (it shouldn't), trigger a Bochs
+-  # breakpoint if running under Bochs, then loop.
+-  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
+-  movw    %ax, %dx
+-  outw    %ax, %dx
+-  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
+-  outw    %ax, %dx
+-spin:
+-  jmp     spin
+-
+-# Bootstrap GDT
+-.p2align 2                                # force 4 byte alignment
+-gdt:
+-  SEG_NULLASM                             # null seg
+-  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg
+-  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg
+-
+-gdtdesc:
+-  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
+-  .long   gdt                             # address gdt
+-
+diff --git a/bootmain.c b/bootmain.c
+deleted file mode 100644
+index 1f20e5b..0000000
+--- a/bootmain.c
++++ /dev/null
+@@ -1,96 +0,0 @@
+-// Boot loader.
+-//
+-// Part of the boot block, along with bootasm.S, which calls bootmain().
+-// bootasm.S has put the processor into protected 32-bit mode.
+-// bootmain() loads an ELF kernel image from the disk starting at
+-// sector 1 and then jumps to the kernel entry routine.
+-
+-#include "types.h"
+-#include "elf.h"
+-#include "x86.h"
+-#include "memlayout.h"
+-
+-#define SECTSIZE  512
+-
+-void readseg(uchar*, uint, uint);
+-
+-void
+-bootmain(void)
+-{
+-  struct elfhdr *elf;
+-  struct proghdr *ph, *eph;
+-  void (*entry)(void);
+-  uchar* pa;
+-
+-  elf = (struct elfhdr*)0x10000;  // scratch space
+-
+-  // Read 1st page off disk
+-  readseg((uchar*)elf, 4096, 0);
+-
+-  // Is this an ELF executable?
+-  if(elf->magic != ELF_MAGIC)
+-    return;  // let bootasm.S handle error
+-
+-  // Load each program segment (ignores ph flags).
+-  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
+-  eph = ph + elf->phnum;
+-  for(; ph < eph; ph++){
+-    pa = (uchar*)ph->paddr;
+-    readseg(pa, ph->filesz, ph->off);
+-    if(ph->memsz > ph->filesz)
+-      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
+-  }
+-
+-  // Call the entry point from the ELF header.
+-  // Does not return!
+-  entry = (void(*)(void))(elf->entry);
+-  entry();
+-}
+-
+-void
+-waitdisk(void)
+-{
+-  // Wait for disk ready.
+-  while((inb(0x1F7) & 0xC0) != 0x40)
+-    ;
+-}
+-
+-// Read a single sector at offset into dst.
+-void
+-readsect(void *dst, uint offset)
+-{
+-  // Issue command.
+-  waitdisk();
+-  outb(0x1F2, 1);   // count = 1
+-  outb(0x1F3, offset);
+-  outb(0x1F4, offset >> 8);
+-  outb(0x1F5, offset >> 16);
+-  outb(0x1F6, (offset >> 24) | 0xE0);
+-  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
+-
+-  // Read data.
+-  waitdisk();
+-  insl(0x1F0, dst, SECTSIZE/4);
+-}
+-
+-// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
+-// Might copy more than asked.
+-void
+-readseg(uchar* pa, uint count, uint offset)
+-{
+-  uchar* epa;
+-
+-  epa = pa + count;
+-
+-  // Round down to sector boundary.
+-  pa -= offset % SECTSIZE;
+-
+-  // Translate from bytes to sectors; kernel starts at sector 1.
+-  offset = (offset / SECTSIZE) + 1;
+-
+-  // If this is too slow, we could read lots of sectors at a time.
+-  // We'd write more to memory than asked, but it doesn't matter --
+-  // we load in increasing order.
+-  for(; pa < epa; pa += SECTSIZE, offset++)
+-    readsect(pa, offset);
+-}
+diff --git a/buf.h b/buf.h
+deleted file mode 100644
+index 3266495..0000000
+--- a/buf.h
++++ /dev/null
+@@ -1,14 +0,0 @@
+-struct buf {
+-  int flags;
+-  uint dev;
+-  uint blockno;
+-  struct sleeplock lock;
+-  uint refcnt;
+-  struct buf *prev; // LRU cache list
+-  struct buf *next;
+-  struct buf *qnext; // disk queue
+-  uchar data[BSIZE];
+-};
+-#define B_VALID 0x2  // buffer has been read from disk
+-#define B_DIRTY 0x4  // buffer needs to be written to disk
+-
+diff --git a/cat.c b/cat.c
+deleted file mode 100644
+index 68b1b8d..0000000
+--- a/cat.c
++++ /dev/null
+@@ -1,43 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-char buf[512];
+-
+-void
+-cat(int fd)
+-{
+-  int n;
+-
+-  while((n = read(fd, buf, sizeof(buf))) > 0) {
+-    if (write(1, buf, n) != n) {
+-      printf(1, "cat: write error\n");
+-      exit(3);
+-    }
+-  }
+-  if(n < 0){
+-    printf(1, "cat: read error\n");
+-    exit(4);
+-  }
+-}
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int fd, i;
+-
+-  if(argc <= 1){
+-    cat(0);
+-    exit(1);
+-  }
+-
+-  for(i = 1; i < argc; i++){
+-    if((fd = open(argv[i], 0)) < 0){
+-      printf(1, "cat: cannot open %s\n", argv[i]);
+-      exit(2);
+-    }
+-    cat(fd);
+-    close(fd);
+-  }
+-  exit(0);
+-}
+diff --git a/code.diff b/code.diff
+deleted file mode 100644
+index c889659..0000000
+--- a/code.diff
++++ /dev/null
+@@ -1,2919 +0,0 @@
+-diff --git a/Makefile b/Makefile
+-index 09d790c..04d74d5 100644
+---- a/Makefile
+-+++ b/Makefile
+-@@ -181,6 +181,7 @@ UPROGS=\
+- 	_usertests\
+- 	_wc\
+- 	_zombie\
+-+	_lab1\
+- 
+- fs.img: mkfs README $(UPROGS)
+- 	./mkfs fs.img README $(UPROGS)
+-diff --git a/cat.c b/cat.c
+-index 5ddc820..68b1b8d 100644
+---- a/cat.c
+-+++ b/cat.c
+-@@ -12,12 +12,12 @@ cat(int fd)
+-   while((n = read(fd, buf, sizeof(buf))) > 0) {
+-     if (write(1, buf, n) != n) {
+-       printf(1, "cat: write error\n");
+--      exit();
+-+      exit(3);
+-     }
+-   }
+-   if(n < 0){
+-     printf(1, "cat: read error\n");
+--    exit();
+-+    exit(4);
+-   }
+- }
+- 
+-@@ -28,16 +28,16 @@ main(int argc, char *argv[])
+- 
+-   if(argc <= 1){
+-     cat(0);
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-     if((fd = open(argv[i], 0)) < 0){
+-       printf(1, "cat: cannot open %s\n", argv[i]);
+--      exit();
+-+      exit(2);
+-     }
+-     cat(fd);
+-     close(fd);
+-   }
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/cuth b/cuth
+-old mode 100755
+-new mode 100644
+-diff --git a/defs.h b/defs.h
+-index 82fb982..d1934ca 100644
+---- a/defs.h
+-+++ b/defs.h
+-@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
+- //PAGEBREAK: 16
+- // proc.c
+- int             cpuid(void);
+--void            exit(void);
+-+void            exit(int status);
+- int             fork(void);
+- int             growproc(int);
+- int             kill(int);
+-@@ -117,7 +117,8 @@ void            sched(void);
+- void            setproc(struct proc*);
+- void            sleep(void*, struct spinlock*);
+- void            userinit(void);
+--int             wait(void);
+-+int             wait(int* status);
+-+int             waitpid(int pid, int* status, int options);
+- void            wakeup(void*);
+- void            yield(void);
+- 
+-diff --git a/dot-bochsrc b/dot-bochsrc
+-old mode 100755
+-new mode 100644
+-diff --git a/echo.c b/echo.c
+-index 806dee0..eed68a0 100644
+---- a/echo.c
+-+++ b/echo.c
+-@@ -9,5 +9,5 @@ main(int argc, char *argv[])
+- 
+-   for(i = 1; i < argc; i++)
+-     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/forktest.c b/forktest.c
+-index 8bc984d..a4b35ed 100644
+---- a/forktest.c
+-+++ b/forktest.c
+-@@ -25,24 +25,24 @@ forktest(void)
+-     if(pid < 0)
+-       break;
+-     if(pid == 0)
+--      exit();
+-+      exit(4);
+-   }
+- 
+-   if(n == N){
+-     printf(1, "fork claimed to work N times!\n", N);
+--    exit();
+-+    exit(3);
+-   }
+- 
+-   for(; n > 0; n--){
+--    if(wait() < 0){
+-+    if(wait(NULL) < 0){
+-       printf(1, "wait stopped early\n");
+--      exit();
+-+      exit(2);
+-     }
+-   }
+- 
+--  if(wait() != -1){
+-+  if(wait(NULL) != -1){
+-     printf(1, "wait got too many\n");
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   printf(1, "fork test OK\n");
+-@@ -52,5 +52,5 @@ int
+- main(void)
+- {
+-   forktest();
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/grep.c b/grep.c
+-index adc4835..4be3256 100644
+---- a/grep.c
+-+++ b/grep.c
+-@@ -43,24 +43,24 @@ main(int argc, char *argv[])
+- 
+-   if(argc <= 1){
+-     printf(2, "usage: grep pattern [file ...]\n");
+--    exit();
+-+    exit(1);
+-   }
+-   pattern = argv[1];
+- 
+-   if(argc <= 2){
+-     grep(pattern, 0);
+--    exit();
+-+    exit(2);
+-   }
+- 
+-   for(i = 2; i < argc; i++){
+-     if((fd = open(argv[i], 0)) < 0){
+-       printf(1, "grep: cannot open %s\n", argv[i]);
+--      exit();
+-+      exit(3);
+-     }
+-     grep(pattern, fd);
+-     close(fd);
+-   }
+--  exit();
+-+  exit(0);
+- }
+- 
+- // Regexp matcher from Kernighan & Pike,
+-diff --git a/init.c b/init.c
+-index 046b551..bc6547f 100644
+---- a/init.c
+-+++ b/init.c
+-@@ -24,14 +24,14 @@ main(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "init: fork failed\n");
+--      exit();
+-+      exit(2);
+-     }
+-     if(pid == 0){
+-       exec("sh", argv);
+-       printf(1, "init: exec sh failed\n");
+--      exit();
+-+      exit(1);
+-     }
+--    while((wpid=wait()) >= 0 && wpid != pid)
+-+    while((wpid=wait(NULL)) >= 0 && wpid != pid)
+-       printf(1, "zombie!\n");
+-   }
+- }
+-diff --git a/kill.c b/kill.c
+-index 364f6af..875916c 100644
+---- a/kill.c
+-+++ b/kill.c
+-@@ -9,9 +9,9 @@ main(int argc, char **argv)
+- 
+-   if(argc < 2){
+-     printf(2, "usage: kill pid...\n");
+--    exit();
+-+    exit(1);
+-   }
+-   for(i=1; i<argc; i++)
+-     kill(atoi(argv[i]));
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/lab1.c b/lab1.c
+-index 89668ce..2192a52 100644
+---- a/lab1.c
+-+++ b/lab1.c
+-@@ -25,7 +25,7 @@ int main(int argc, char **argv) {
+-     if(pid > 0)
+-     {
+-         waitpid(pid, NULL, 0);
+--        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);
+-+        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
+-         exit(0);
+-     }
+- 
+-diff --git a/ln.c b/ln.c
+-index cf8a64e..fb17c3b 100644
+---- a/ln.c
+-+++ b/ln.c
+-@@ -7,9 +7,9 @@ main(int argc, char *argv[])
+- {
+-   if(argc != 3){
+-     printf(2, "Usage: ln old new\n");
+--    exit();
+-+    exit(1);
+-   }
+-   if(link(argv[1], argv[2]) < 0)
+-     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/ls.c b/ls.c
+-index 2862913..6bf943b 100644
+---- a/ls.c
+-+++ b/ls.c
+-@@ -77,9 +77,9 @@ main(int argc, char *argv[])
+- 
+-   if(argc < 2){
+-     ls(".");
+--    exit();
+-+    exit(1);
+-   }
+-   for(i=1; i<argc; i++)
+-     ls(argv[i]);
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/mkdir.c b/mkdir.c
+-index 6e4c954..2d90781 100644
+---- a/mkdir.c
+-+++ b/mkdir.c
+-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
+- 
+-   if(argc < 2){
+-     printf(2, "Usage: mkdir files...\n");
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
+-     }
+-   }
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/pr.pl b/pr.pl
+-old mode 100755
+-new mode 100644
+-diff --git a/printpcs b/printpcs
+-old mode 100755
+-new mode 100644
+-diff --git a/proc.c b/proc.c
+-index 806b1b1..84b335f 100644
+---- a/proc.c
+-+++ b/proc.c
+-@@ -1,3 +1,5 @@
+-+#include <stddef.h>
+-+
+- #include "types.h"
+- #include "defs.h"
+- #include "param.h"
+-@@ -8,61 +10,61 @@
+- #include "spinlock.h"
+- 
+- struct {
+--  struct spinlock lock;
+--  struct proc proc[NPROC];
+-+    struct spinlock lock;
+-+    struct proc proc[NPROC];
+- } ptable;
+- 
+- static struct proc *initproc;
+- 
+- int nextpid = 1;
+-+
+- extern void forkret(void);
+-+
+- extern void trapret(void);
+- 
+- static void wakeup1(void *chan);
+- 
+- void
+--pinit(void)
+--{
+--  initlock(&ptable.lock, "ptable");
+-+pinit(void) {
+-+    initlock(&ptable.lock, "ptable");
+- }
+- 
+- // Must be called with interrupts disabled
+- int
+- cpuid() {
+--  return mycpu()-cpus;
+-+    return mycpu() - cpus;
+- }
+- 
+- // Must be called with interrupts disabled to avoid the caller being
+- // rescheduled between reading lapicid and running through the loop.
+--struct cpu*
+--mycpu(void)
+--{
+--  int apicid, i;
+--  
+--  if(readeflags()&FL_IF)
+--    panic("mycpu called with interrupts enabled\n");
+--  
+--  apicid = lapicid();
+--  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+--  // a reverse map, or reserve a register to store &cpus[i].
+--  for (i = 0; i < ncpu; ++i) {
+--    if (cpus[i].apicid == apicid)
+--      return &cpus[i];
+--  }
+--  panic("unknown apicid\n");
+-+struct cpu *
+-+mycpu(void) {
+-+    int apicid, i;
+-+
+-+    if (readeflags() & FL_IF)
+-+        panic("mycpu called with interrupts enabled\n");
+-+
+-+    apicid = lapicid();
+-+    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+-+    // a reverse map, or reserve a register to store &cpus[i].
+-+    for (i = 0; i < ncpu; ++i) {
+-+        if (cpus[i].apicid == apicid)
+-+            return &cpus[i];
+-+    }
+-+    panic("unknown apicid\n");
+- }
+- 
+- // Disable interrupts so that we are not rescheduled
+- // while reading proc from the cpu structure
+--struct proc*
+-+struct proc *
+- myproc(void) {
+--  struct cpu *c;
+--  struct proc *p;
+--  pushcli();
+--  c = mycpu();
+--  p = c->proc;
+--  popcli();
+--  return p;
+-+    struct cpu *c;
+-+    struct proc *p;
+-+    pushcli();
+-+    c = mycpu();
+-+    p = c->proc;
+-+    popcli();
+-+    return p;
+- }
+- 
+- //PAGEBREAK: 32
+-@@ -70,245 +72,295 @@ myproc(void) {
+- // If found, change state to EMBRYO and initialize
+- // state required to run in the kernel.
+- // Otherwise return 0.
+--static struct proc*
+--allocproc(void)
+--{
+--  struct proc *p;
+--  char *sp;
+-+static struct proc *
+-+allocproc(void) {
+-+    struct proc *p;
+-+    char *sp;
+- 
+--  acquire(&ptable.lock);
+-+    acquire(&ptable.lock);
+- 
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+--    if(p->state == UNUSED)
+--      goto found;
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-+        if (p->state == UNUSED)
+-+            goto found;
+- 
+--  release(&ptable.lock);
+--  return 0;
+-+    release(&ptable.lock);
+-+    return 0;
+- 
+--found:
+--  p->state = EMBRYO;
+--  p->pid = nextpid++;
+-+    found:
+-+    p->state = EMBRYO;
+-+    p->pid = nextpid++;
+- 
+--  release(&ptable.lock);
+-+    release(&ptable.lock);
+- 
+--  // Allocate kernel stack.
+--  if((p->kstack = kalloc()) == 0){
+--    p->state = UNUSED;
+--    return 0;
+--  }
+--  sp = p->kstack + KSTACKSIZE;
+-+    // Allocate kernel stack.
+-+    if ((p->kstack = kalloc()) == 0) {
+-+        p->state = UNUSED;
+-+        return 0;
+-+    }
+-+    sp = p->kstack + KSTACKSIZE;
+- 
+--  // Leave room for trap frame.
+--  sp -= sizeof *p->tf;
+--  p->tf = (struct trapframe*)sp;
+-+    // Leave room for trap frame.
+-+    sp -= sizeof *p->tf;
+-+    p->tf = (struct trapframe *) sp;
+- 
+--  // Set up new context to start executing at forkret,
+--  // which returns to trapret.
+--  sp -= 4;
+--  *(uint*)sp = (uint)trapret;
+-+    // Set up new context to start executing at forkret,
+-+    // which returns to trapret.
+-+    sp -= 4;
+-+    *(uint *) sp = (uint) trapret;
+- 
+--  sp -= sizeof *p->context;
+--  p->context = (struct context*)sp;
+--  memset(p->context, 0, sizeof *p->context);
+--  p->context->eip = (uint)forkret;
+-+    sp -= sizeof *p->context;
+-+    p->context = (struct context *) sp;
+-+    memset(p->context, 0, sizeof *p->context);
+-+    p->context->eip = (uint) forkret;
+- 
+--  return p;
+-+    return p;
+- }
+- 
+- //PAGEBREAK: 32
+- // Set up first user process.
+- void
+--userinit(void)
+--{
+--  struct proc *p;
+--  extern char _binary_initcode_start[], _binary_initcode_size[];
+--
+--  p = allocproc();
+--  
+--  initproc = p;
+--  if((p->pgdir = setupkvm()) == 0)
+--    panic("userinit: out of memory?");
+--  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+--  p->sz = PGSIZE;
+--  memset(p->tf, 0, sizeof(*p->tf));
+--  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+--  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+--  p->tf->es = p->tf->ds;
+--  p->tf->ss = p->tf->ds;
+--  p->tf->eflags = FL_IF;
+--  p->tf->esp = PGSIZE;
+--  p->tf->eip = 0;  // beginning of initcode.S
+--
+--  safestrcpy(p->name, "initcode", sizeof(p->name));
+--  p->cwd = namei("/");
+--
+--  // this assignment to p->state lets other cores
+--  // run this process. the acquire forces the above
+--  // writes to be visible, and the lock is also needed
+--  // because the assignment might not be atomic.
+--  acquire(&ptable.lock);
+--
+--  p->state = RUNNABLE;
+--
+--  release(&ptable.lock);
+-+userinit(void) {
+-+    struct proc *p;
+-+    extern char _binary_initcode_start[], _binary_initcode_size[];
+-+
+-+    p = allocproc();
+-+
+-+    initproc = p;
+-+    if ((p->pgdir = setupkvm()) == 0)
+-+        panic("userinit: out of memory?");
+-+    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
+-+    p->sz = PGSIZE;
+-+    memset(p->tf, 0, sizeof(*p->tf));
+-+    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+-+    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+-+    p->tf->es = p->tf->ds;
+-+    p->tf->ss = p->tf->ds;
+-+    p->tf->eflags = FL_IF;
+-+    p->tf->esp = PGSIZE;
+-+    p->tf->eip = 0;  // beginning of initcode.S
+-+
+-+    safestrcpy(p->name, "initcode", sizeof(p->name));
+-+    p->cwd = namei("/");
+-+
+-+    // this assignment to p->state lets other cores
+-+    // run this process. the acquire forces the above
+-+    // writes to be visible, and the lock is also needed
+-+    // because the assignment might not be atomic.
+-+    acquire(&ptable.lock);
+-+
+-+    p->state = RUNNABLE;
+-+
+-+    release(&ptable.lock);
+- }
+- 
+- // Grow current process's memory by n bytes.
+- // Return 0 on success, -1 on failure.
+- int
+--growproc(int n)
+--{
+--  uint sz;
+--  struct proc *curproc = myproc();
+--
+--  sz = curproc->sz;
+--  if(n > 0){
+--    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+--      return -1;
+--  } else if(n < 0){
+--    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+--      return -1;
+--  }
+--  curproc->sz = sz;
+--  switchuvm(curproc);
+--  return 0;
+-+growproc(int n) {
+-+    uint sz;
+-+    struct proc *curproc = myproc();
+-+
+-+    sz = curproc->sz;
+-+    if (n > 0) {
+-+        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-+            return -1;
+-+    } else if (n < 0) {
+-+        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-+            return -1;
+-+    }
+-+    curproc->sz = sz;
+-+    switchuvm(curproc);
+-+    return 0;
+- }
+- 
+- // Create a new process copying p as the parent.
+- // Sets up stack to return as if from system call.
+- // Caller must set state of returned proc to RUNNABLE.
+- int
+--fork(void)
+--{
+--  int i, pid;
+--  struct proc *np;
+--  struct proc *curproc = myproc();
+--
+--  // Allocate process.
+--  if((np = allocproc()) == 0){
+--    return -1;
+--  }
+-+fork(void) {
+-+    int i, pid;
+-+    struct proc *np;
+-+    struct proc *curproc = myproc();
+-+
+-+    // Allocate process.
+-+    if ((np = allocproc()) == 0) {
+-+        return -1;
+-+    }
+- 
+--  // Copy process state from proc.
+--  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+--    kfree(np->kstack);
+--    np->kstack = 0;
+--    np->state = UNUSED;
+--    return -1;
+--  }
+--  np->sz = curproc->sz;
+--  np->parent = curproc;
+--  *np->tf = *curproc->tf;
+-+    // Copy process state from proc.
+-+    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
+-+        kfree(np->kstack);
+-+        np->kstack = 0;
+-+        np->state = UNUSED;
+-+        return -1;
+-+    }
+-+    np->sz = curproc->sz;
+-+    np->parent = curproc;
+-+    *np->tf = *curproc->tf;
+- 
+--  // Clear %eax so that fork returns 0 in the child.
+--  np->tf->eax = 0;
+-+    // Clear %eax so that fork returns 0 in the child.
+-+    np->tf->eax = 0;
+- 
+--  for(i = 0; i < NOFILE; i++)
+--    if(curproc->ofile[i])
+--      np->ofile[i] = filedup(curproc->ofile[i]);
+--  np->cwd = idup(curproc->cwd);
+-+    for (i = 0; i < NOFILE; i++)
+-+        if (curproc->ofile[i])
+-+            np->ofile[i] = filedup(curproc->ofile[i]);
+-+    np->cwd = idup(curproc->cwd);
+- 
+--  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+-+    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+- 
+--  pid = np->pid;
+-+    pid = np->pid;
+- 
+--  acquire(&ptable.lock);
+-+    acquire(&ptable.lock);
+- 
+--  np->state = RUNNABLE;
+-+    np->state = RUNNABLE;
+- 
+--  release(&ptable.lock);
+-+    release(&ptable.lock);
+- 
+--  return pid;
+-+    return pid;
+- }
+- 
+- // Exit the current process.  Does not return.
+- // An exited process remains in the zombie state
+- // until its parent calls wait() to find out it exited.
+- void
+--exit(void)
+--{
+--  struct proc *curproc = myproc();
+--  struct proc *p;
+--  int fd;
+--
+--  if(curproc == initproc)
+--    panic("init exiting");
+--
+--  // Close all open files.
+--  for(fd = 0; fd < NOFILE; fd++){
+--    if(curproc->ofile[fd]){
+--      fileclose(curproc->ofile[fd]);
+--      curproc->ofile[fd] = 0;
+-+exit(int status) {
+-+    struct proc *curproc = myproc();
+-+    struct proc *p;
+-+    int fd;
+-+
+-+    curproc->status = status;
+-+
+-+    if (curproc == initproc)
+-+        panic("init exiting");
+-+
+-+    // Close all open files.
+-+    for (fd = 0; fd < NOFILE; fd++) {
+-+        if (curproc->ofile[fd]) {
+-+            fileclose(curproc->ofile[fd]);
+-+            curproc->ofile[fd] = 0;
+-+        }
+-     }
+--  }
+- 
+--  begin_op();
+--  iput(curproc->cwd);
+--  end_op();
+--  curproc->cwd = 0;
+-+    begin_op();
+-+    iput(curproc->cwd);
+-+    end_op();
+-+    curproc->cwd = 0;
+- 
+--  acquire(&ptable.lock);
+-+    acquire(&ptable.lock);
+- 
+--  // Parent might be sleeping in wait().
+--  wakeup1(curproc->parent);
+-+    // Parent might be sleeping in wait().
+-+    wakeup1(curproc->parent);
+- 
+--  // Pass abandoned children to init.
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--    if(p->parent == curproc){
+--      p->parent = initproc;
+--      if(p->state == ZOMBIE)
+--        wakeup1(initproc);
+-+    // Pass abandoned children to init.
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+        if (p->parent == curproc) {
+-+            p->parent = initproc;
+-+            if (p->state == ZOMBIE)
+-+                wakeup1(initproc);
+-+        }
+-     }
+--  }
+- 
+--  // Jump into the scheduler, never to return.
+--  curproc->state = ZOMBIE;
+--  sched();
+--  panic("zombie exit");
+-+    // Jump into the scheduler, never to return.
+-+    curproc->state = ZOMBIE;
+-+    sched();
+-+    panic("zombie exit");
+- }
+- 
+- // Wait for a child process to exit and return its pid.
+- // Return -1 if this process has no children.
+- int
+--wait(void)
+--{
+--  struct proc *p;
+--  int havekids, pid;
+--  struct proc *curproc = myproc();
+--  
+--  acquire(&ptable.lock);
+--  for(;;){
+--    // Scan through table looking for exited children.
+--    havekids = 0;
+--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--      if(p->parent != curproc)
+--        continue;
+--      havekids = 1;
+--      if(p->state == ZOMBIE){
+--        // Found one.
+--        pid = p->pid;
+--        kfree(p->kstack);
+--        p->kstack = 0;
+--        freevm(p->pgdir);
+--        p->pid = 0;
+--        p->parent = 0;
+--        p->name[0] = 0;
+--        p->killed = 0;
+--        p->state = UNUSED;
+--        release(&ptable.lock);
+--        return pid;
+--      }
+--    }
+-+wait(int *status) {
+-+    struct proc *p;
+-+    int havekids, pid;
+-+    struct proc *curproc = myproc();
+- 
+--    // No point waiting if we don't have any children.
+--    if(!havekids || curproc->killed){
+--      release(&ptable.lock);
+--      return -1;
+-+    acquire(&ptable.lock);
+-+    for (;;) {
+-+        // Scan through table looking for exited children.
+-+        havekids = 0;
+-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+            if (p->parent != curproc)
+-+                continue;
+-+            havekids = 1;
+-+            if (p->state == ZOMBIE) {
+-+                // Found one.
+-+                pid = p->pid;
+-+                kfree(p->kstack);
+-+                p->kstack = 0;
+-+                freevm(p->pgdir);
+-+                p->pid = 0;
+-+                p->parent = 0;
+-+                p->name[0] = 0;
+-+                p->killed = 0;
+-+                p->state = UNUSED;
+-+                release(&ptable.lock);
+-+                if (status != NULL)
+-+                    *status = p->status;
+-+                return pid;
+-+            }
+-+        }
+-+
+-+        // No point waiting if we don't have any children.
+-+        if (!havekids || curproc->killed) {
+-+            release(&ptable.lock);
+-+            return -1;
+-+        }
+-+
+-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+-     }
+-+}
+- 
+--    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+--    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+--  }
+-+// Wait for a child process to exit and return its pid.
+-+// Return -1 if this process has no children.
+-+int
+-+waitpid(int pidBeingSearchedFor, int *status, int options) {
+-+    struct proc *p;
+-+    int doesProcExist, pidFound;
+-+    struct proc *curproc = myproc();
+-+    acquire(&ptable.lock);
+-+    for (;;) {
+-+        // Scan through table looking for exited children.
+-+        doesProcExist = 0;
+-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+//            if(p->parent != curproc)
+-+//                continue;
+-+
+-+            if (p->pid != pidBeingSearchedFor)
+-+                continue;
+-+
+-+            doesProcExist = 1;
+-+            if (p->state == ZOMBIE) {
+-+                // Found one.
+-+                pidFound = p->pid;
+-+                kfree(p->kstack);
+-+                p->kstack = 0;
+-+                freevm(p->pgdir);
+-+                p->pid = 0;
+-+                p->parent = 0;
+-+                p->name[0] = 0;
+-+                p->killed = 0;
+-+                p->state = UNUSED;
+-+                release(&ptable.lock);
+-+                if (status != NULL)
+-+                    *status = p->status;
+-+                return pidFound;
+-+            }
+-+        }
+-+
+-+//        // No point waiting if we don't have any children.
+-+//        if(!havekids || curproc->killed){
+-+//            release(&ptable.lock);
+-+//            return -1;
+-+//        }
+-+
+-+        if (!doesProcExist || curproc->killed) {
+-+            release(&ptable.lock);
+-+            return -1;
+-+        }
+-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+-+    }
+- }
+- 
+- //PAGEBREAK: 42
+-@@ -320,39 +372,38 @@ wait(void)
+- //  - eventually that process transfers control
+- //      via swtch back to the scheduler.
+- void
+--scheduler(void)
+--{
+--  struct proc *p;
+--  struct cpu *c = mycpu();
+--  c->proc = 0;
+--  
+--  for(;;){
+--    // Enable interrupts on this processor.
+--    sti();
+--
+--    // Loop over process table looking for process to run.
+--    acquire(&ptable.lock);
+--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--      if(p->state != RUNNABLE)
+--        continue;
+--
+--      // Switch to chosen process.  It is the process's job
+--      // to release ptable.lock and then reacquire it
+--      // before jumping back to us.
+--      c->proc = p;
+--      switchuvm(p);
+--      p->state = RUNNING;
+--
+--      swtch(&(c->scheduler), p->context);
+--      switchkvm();
+--
+--      // Process is done running for now.
+--      // It should have changed its p->state before coming back.
+--      c->proc = 0;
+--    }
+--    release(&ptable.lock);
+-+scheduler(void) {
+-+    struct proc *p;
+-+    struct cpu *c = mycpu();
+-+    c->proc = 0;
+-+
+-+    for (;;) {
+-+        // Enable interrupts on this processor.
+-+        sti();
+-+
+-+        // Loop over process table looking for process to run.
+-+        acquire(&ptable.lock);
+-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+            if (p->state != RUNNABLE)
+-+                continue;
+-+
+-+            // Switch to chosen process.  It is the process's job
+-+            // to release ptable.lock and then reacquire it
+-+            // before jumping back to us.
+-+            c->proc = p;
+-+            switchuvm(p);
+-+            p->state = RUNNING;
+-+
+-+            swtch(&(c->scheduler), p->context);
+-+            switchkvm();
+-+
+-+            // Process is done running for now.
+-+            // It should have changed its p->state before coming back.
+-+            c->proc = 0;
+-+        }
+-+        release(&ptable.lock);
+- 
+--  }
+-+    }
+- }
+- 
+- // Enter scheduler.  Must hold only ptable.lock
+-@@ -363,137 +414,130 @@ scheduler(void)
+- // break in the few places where a lock is held but
+- // there's no process.
+- void
+--sched(void)
+--{
+--  int intena;
+--  struct proc *p = myproc();
+--
+--  if(!holding(&ptable.lock))
+--    panic("sched ptable.lock");
+--  if(mycpu()->ncli != 1)
+--    panic("sched locks");
+--  if(p->state == RUNNING)
+--    panic("sched running");
+--  if(readeflags()&FL_IF)
+--    panic("sched interruptible");
+--  intena = mycpu()->intena;
+--  swtch(&p->context, mycpu()->scheduler);
+--  mycpu()->intena = intena;
+-+sched(void) {
+-+    int intena;
+-+    struct proc *p = myproc();
+-+
+-+    if (!holding(&ptable.lock))
+-+        panic("sched ptable.lock");
+-+    if (mycpu()->ncli != 1)
+-+        panic("sched locks");
+-+    if (p->state == RUNNING)
+-+        panic("sched running");
+-+    if (readeflags() & FL_IF)
+-+        panic("sched interruptible");
+-+    intena = mycpu()->intena;
+-+    swtch(&p->context, mycpu()->scheduler);
+-+    mycpu()->intena = intena;
+- }
+- 
+- // Give up the CPU for one scheduling round.
+- void
+--yield(void)
+--{
+--  acquire(&ptable.lock);  //DOC: yieldlock
+--  myproc()->state = RUNNABLE;
+--  sched();
+--  release(&ptable.lock);
+-+yield(void) {
+-+    acquire(&ptable.lock);  //DOC: yieldlock
+-+    myproc()->state = RUNNABLE;
+-+    sched();
+-+    release(&ptable.lock);
+- }
+- 
+- // A fork child's very first scheduling by scheduler()
+- // will swtch here.  "Return" to user space.
+- void
+--forkret(void)
+--{
+--  static int first = 1;
+--  // Still holding ptable.lock from scheduler.
+--  release(&ptable.lock);
+--
+--  if (first) {
+--    // Some initialization functions must be run in the context
+--    // of a regular process (e.g., they call sleep), and thus cannot
+--    // be run from main().
+--    first = 0;
+--    iinit(ROOTDEV);
+--    initlog(ROOTDEV);
+--  }
+--
+--  // Return to "caller", actually trapret (see allocproc).
+-+forkret(void) {
+-+    static int first = 1;
+-+    // Still holding ptable.lock from scheduler.
+-+    release(&ptable.lock);
+-+
+-+    if (first) {
+-+        // Some initialization functions must be run in the context
+-+        // of a regular process (e.g., they call sleep), and thus cannot
+-+        // be run from main().
+-+        first = 0;
+-+        iinit(ROOTDEV);
+-+        initlog(ROOTDEV);
+-+    }
+-+
+-+    // Return to "caller", actually trapret (see allocproc).
+- }
+- 
+- // Atomically release lock and sleep on chan.
+- // Reacquires lock when awakened.
+- void
+--sleep(void *chan, struct spinlock *lk)
+--{
+--  struct proc *p = myproc();
+--  
+--  if(p == 0)
+--    panic("sleep");
+--
+--  if(lk == 0)
+--    panic("sleep without lk");
+--
+--  // Must acquire ptable.lock in order to
+--  // change p->state and then call sched.
+--  // Once we hold ptable.lock, we can be
+--  // guaranteed that we won't miss any wakeup
+--  // (wakeup runs with ptable.lock locked),
+--  // so it's okay to release lk.
+--  if(lk != &ptable.lock){  //DOC: sleeplock0
+--    acquire(&ptable.lock);  //DOC: sleeplock1
+--    release(lk);
+--  }
+--  // Go to sleep.
+--  p->chan = chan;
+--  p->state = SLEEPING;
+--
+--  sched();
+--
+--  // Tidy up.
+--  p->chan = 0;
+--
+--  // Reacquire original lock.
+--  if(lk != &ptable.lock){  //DOC: sleeplock2
+--    release(&ptable.lock);
+--    acquire(lk);
+--  }
+-+sleep(void *chan, struct spinlock *lk) {
+-+    struct proc *p = myproc();
+-+
+-+    if (p == 0)
+-+        panic("sleep");
+-+
+-+    if (lk == 0)
+-+        panic("sleep without lk");
+-+
+-+    // Must acquire ptable.lock in order to
+-+    // change p->state and then call sched.
+-+    // Once we hold ptable.lock, we can be
+-+    // guaranteed that we won't miss any wakeup
+-+    // (wakeup runs with ptable.lock locked),
+-+    // so it's okay to release lk.
+-+    if (lk != &ptable.lock) {  //DOC: sleeplock0
+-+        acquire(&ptable.lock);  //DOC: sleeplock1
+-+        release(lk);
+-+    }
+-+    // Go to sleep.
+-+    p->chan = chan;
+-+    p->state = SLEEPING;
+-+
+-+    sched();
+-+
+-+    // Tidy up.
+-+    p->chan = 0;
+-+
+-+    // Reacquire original lock.
+-+    if (lk != &ptable.lock) {  //DOC: sleeplock2
+-+        release(&ptable.lock);
+-+        acquire(lk);
+-+    }
+- }
+- 
+- //PAGEBREAK!
+- // Wake up all processes sleeping on chan.
+- // The ptable lock must be held.
+- static void
+--wakeup1(void *chan)
+--{
+--  struct proc *p;
+-+wakeup1(void *chan) {
+-+    struct proc *p;
+- 
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+--    if(p->state == SLEEPING && p->chan == chan)
+--      p->state = RUNNABLE;
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-+        if (p->state == SLEEPING && p->chan == chan)
+-+            p->state = RUNNABLE;
+- }
+- 
+- // Wake up all processes sleeping on chan.
+- void
+--wakeup(void *chan)
+--{
+--  acquire(&ptable.lock);
+--  wakeup1(chan);
+--  release(&ptable.lock);
+-+wakeup(void *chan) {
+-+    acquire(&ptable.lock);
+-+    wakeup1(chan);
+-+    release(&ptable.lock);
+- }
+- 
+- // Kill the process with the given pid.
+- // Process won't exit until it returns
+- // to user space (see trap in trap.c).
+- int
+--kill(int pid)
+--{
+--  struct proc *p;
+--
+--  acquire(&ptable.lock);
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--    if(p->pid == pid){
+--      p->killed = 1;
+--      // Wake process from sleep if necessary.
+--      if(p->state == SLEEPING)
+--        p->state = RUNNABLE;
+--      release(&ptable.lock);
+--      return 0;
+-+kill(int pid) {
+-+    struct proc *p;
+-+
+-+    acquire(&ptable.lock);
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+        if (p->pid == pid) {
+-+            p->killed = 1;
+-+            // Wake process from sleep if necessary.
+-+            if (p->state == SLEEPING)
+-+                p->state = RUNNABLE;
+-+            release(&ptable.lock);
+-+            return 0;
+-+        }
+-     }
+--  }
+--  release(&ptable.lock);
+--  return -1;
+-+    release(&ptable.lock);
+-+    return -1;
+- }
+- 
+- //PAGEBREAK: 36
+-@@ -501,34 +545,33 @@ kill(int pid)
+- // Runs when user types ^P on console.
+- // No lock to avoid wedging a stuck machine further.
+- void
+--procdump(void)
+--{
+--  static char *states[] = {
+--  [UNUSED]    "unused",
+--  [EMBRYO]    "embryo",
+--  [SLEEPING]  "sleep ",
+--  [RUNNABLE]  "runble",
+--  [RUNNING]   "run   ",
+--  [ZOMBIE]    "zombie"
+--  };
+--  int i;
+--  struct proc *p;
+--  char *state;
+--  uint pc[10];
+--
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--    if(p->state == UNUSED)
+--      continue;
+--    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+--      state = states[p->state];
+--    else
+--      state = "???";
+--    cprintf("%d %s %s", p->pid, state, p->name);
+--    if(p->state == SLEEPING){
+--      getcallerpcs((uint*)p->context->ebp+2, pc);
+--      for(i=0; i<10 && pc[i] != 0; i++)
+--        cprintf(" %p", pc[i]);
+-+procdump(void) {
+-+    static char *states[] = {
+-+            [UNUSED]    "unused",
+-+            [EMBRYO]    "embryo",
+-+            [SLEEPING]  "sleep ",
+-+            [RUNNABLE]  "runble",
+-+            [RUNNING]   "run   ",
+-+            [ZOMBIE]    "zombie"
+-+    };
+-+    int i;
+-+    struct proc *p;
+-+    char *state;
+-+    uint pc[10];
+-+
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+        if (p->state == UNUSED)
+-+            continue;
+-+        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
+-+            state = states[p->state];
+-+        else
+-+            state = "???";
+-+        cprintf("%d %s %s", p->pid, state, p->name);
+-+        if (p->state == SLEEPING) {
+-+            getcallerpcs((uint *) p->context->ebp + 2, pc);
+-+            for (i = 0; i < 10 && pc[i] != 0; i++)
+-+                cprintf(" %p", pc[i]);
+-+        }
+-+        cprintf("\n");
+-     }
+--    cprintf("\n");
+--  }
+- }
+-diff --git a/proc.h b/proc.h
+-index 1647114..a06b921 100644
+---- a/proc.h
+-+++ b/proc.h
+-@@ -49,6 +49,7 @@ struct proc {
+-   struct file *ofile[NOFILE];  // Open files
+-   struct inode *cwd;           // Current directory
+-   char name[16];               // Process name (debugging)
+-+  int status;                  // Exit status
+- };
+- 
+- // Process memory is laid out contiguously, low addresses first:
+-diff --git a/rm.c b/rm.c
+-index 4fd33c8..1e6daec 100644
+---- a/rm.c
+-+++ b/rm.c
+-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
+- 
+-   if(argc < 2){
+-     printf(2, "Usage: rm files...\n");
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
+-     }
+-   }
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/runoff b/runoff
+-old mode 100755
+-new mode 100644
+-diff --git a/runoff1 b/runoff1
+-old mode 100755
+-new mode 100644
+-diff --git a/sh.c b/sh.c
+-index 054bab9..ca2ae37 100644
+---- a/sh.c
+-+++ b/sh.c
+-@@ -65,7 +65,7 @@ runcmd(struct cmd *cmd)
+-   struct redircmd *rcmd;
+- 
+-   if(cmd == 0)
+--    exit();
+-+    exit(1);
+- 
+-   switch(cmd->type){
+-   default:
+-@@ -74,7 +74,7 @@ runcmd(struct cmd *cmd)
+-   case EXEC:
+-     ecmd = (struct execcmd*)cmd;
+-     if(ecmd->argv[0] == 0)
+--      exit();
+-+      exit(2);
+-     exec(ecmd->argv[0], ecmd->argv);
+-     printf(2, "exec %s failed\n", ecmd->argv[0]);
+-     break;
+-@@ -84,7 +84,7 @@ runcmd(struct cmd *cmd)
+-     close(rcmd->fd);
+-     if(open(rcmd->file, rcmd->mode) < 0){
+-       printf(2, "open %s failed\n", rcmd->file);
+--      exit();
+-+      exit(6);
+-     }
+-     runcmd(rcmd->cmd);
+-     break;
+-@@ -93,7 +93,7 @@ runcmd(struct cmd *cmd)
+-     lcmd = (struct listcmd*)cmd;
+-     if(fork1() == 0)
+-       runcmd(lcmd->left);
+--    wait();
+-+    wait(NULL);
+-     runcmd(lcmd->right);
+-     break;
+- 
+-@@ -117,8 +117,8 @@ runcmd(struct cmd *cmd)
+-     }
+-     close(p[0]);
+-     close(p[1]);
+--    wait();
+--    wait();
+-+    wait(NULL);
+-+    wait(NULL);
+-     break;
+- 
+-   case BACK:
+-@@ -127,7 +127,7 @@ runcmd(struct cmd *cmd)
+-       runcmd(bcmd->cmd);
+-     break;
+-   }
+--  exit();
+-+  exit(3);
+- }
+- 
+- int
+-@@ -166,16 +166,16 @@ main(void)
+-     }
+-     if(fork1() == 0)
+-       runcmd(parsecmd(buf));
+--    wait();
+-+    wait(NULL);
+-   }
+--  exit();
+-+  exit(0);
+- }
+- 
+- void
+- panic(char *s)
+- {
+-   printf(2, "%s\n", s);
+--  exit();
+-+  exit(5);
+- }
+- 
+- int
+-diff --git a/show1 b/show1
+-old mode 100755
+-new mode 100644
+-diff --git a/sign.pl b/sign.pl
+-old mode 100755
+-new mode 100644
+-diff --git a/spinp b/spinp
+-old mode 100755
+-new mode 100644
+-diff --git a/stressfs.c b/stressfs.c
+-index c0a4743..46e0e66 100644
+---- a/stressfs.c
+-+++ b/stressfs.c
+-@@ -43,7 +43,7 @@ main(int argc, char *argv[])
+-     read(fd, data, sizeof(data));
+-   close(fd);
+- 
+--  wait();
+-+  wait(NULL);
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/syscall.c b/syscall.c
+-index ee85261..41a8c3c 100644
+---- a/syscall.c
+-+++ b/syscall.c
+-@@ -101,6 +101,7 @@ extern int sys_sbrk(void);
+- extern int sys_sleep(void);
+- extern int sys_unlink(void);
+- extern int sys_wait(void);
+-+extern int sys_waitpid(void);
+- extern int sys_write(void);
+- extern int sys_uptime(void);
+- 
+-@@ -108,6 +109,7 @@ static int (*syscalls[])(void) = {
+- [SYS_fork]    sys_fork,
+- [SYS_exit]    sys_exit,
+- [SYS_wait]    sys_wait,
+-+[SYS_waitpid] sys_waitpid,
+- [SYS_pipe]    sys_pipe,
+- [SYS_read]    sys_read,
+- [SYS_kill]    sys_kill,
+-diff --git a/syscall.h b/syscall.h
+-index bc5f356..374ff05 100644
+---- a/syscall.h
+-+++ b/syscall.h
+-@@ -1,22 +1,23 @@
+- // System call numbers
+--#define SYS_fork    1
+--#define SYS_exit    2
+--#define SYS_wait    3
+--#define SYS_pipe    4
+--#define SYS_read    5
+--#define SYS_kill    6
+--#define SYS_exec    7
+--#define SYS_fstat   8
+--#define SYS_chdir   9
+--#define SYS_dup    10
+--#define SYS_getpid 11
+--#define SYS_sbrk   12
+--#define SYS_sleep  13
+--#define SYS_uptime 14
+--#define SYS_open   15
+--#define SYS_write  16
+--#define SYS_mknod  17
+--#define SYS_unlink 18
+--#define SYS_link   19
+--#define SYS_mkdir  20
+--#define SYS_close  21
+-+#define SYS_fork     1
+-+#define SYS_exit     2
+-+#define SYS_wait     3
+-+#define SYS_pipe     4
+-+#define SYS_read     5
+-+#define SYS_kill     6
+-+#define SYS_exec     7
+-+#define SYS_fstat    8
+-+#define SYS_chdir    9
+-+#define SYS_dup     10
+-+#define SYS_getpid  11
+-+#define SYS_sbrk    12
+-+#define SYS_sleep   13
+-+#define SYS_uptime  14
+-+#define SYS_open    15
+-+#define SYS_write   16
+-+#define SYS_mknod   17
+-+#define SYS_unlink  18
+-+#define SYS_link    19
+-+#define SYS_mkdir   20
+-+#define SYS_close   21
+-+#define SYS_waitpid 22
+-\ No newline at end of file
+-diff --git a/sysproc.c b/sysproc.c
+-index 0686d29..ebccf84 100644
+---- a/sysproc.c
+-+++ b/sysproc.c
+-@@ -14,16 +14,22 @@ sys_fork(void)
+- }
+- 
+- int
+--sys_exit(void)
+-+sys_exit(int status)
+- {
+--  exit();
+-+  exit(status);
+-   return 0;  // not reached
+- }
+- 
+- int
+--sys_wait(void)
+-+sys_wait(int* status)
+- {
+--  return wait();
+-+  return wait(status);
+-+}
+-+
+-+int
+-+sys_waitpid(int pid, int* status, int options)
+-+{
+-+    return waitpid(pid, status, options);
+- }
+- 
+- int
+-diff --git a/trap.c b/trap.c
+-index 41c66eb..432ea5b 100644
+---- a/trap.c
+-+++ b/trap.c
+-@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
+- {
+-   if(tf->trapno == T_SYSCALL){
+-     if(myproc()->killed)
+--      exit();
+-+      exit(4);
+-     myproc()->tf = tf;
+-     syscall();
+-     if(myproc()->killed)
+--      exit();
+-+      exit(3);
+-     return;
+-   }
+- 
+-@@ -98,7 +98,7 @@ trap(struct trapframe *tf)
+-   // (If it is still executing in the kernel, let it keep running
+-   // until it gets to the regular system call return.)
+-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+--    exit();
+-+    exit(2);
+- 
+-   // Force process to give up CPU on clock tick.
+-   // If interrupts were on while locks held, would need to check nlock.
+-@@ -108,5 +108,5 @@ trap(struct trapframe *tf)
+- 
+-   // Check if the process has been killed since we yielded
+-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+--    exit();
+-+    exit(1);
+- }
+-diff --git a/user.h b/user.h
+-index 4f99c52..0931387 100644
+---- a/user.h
+-+++ b/user.h
+-@@ -1,10 +1,13 @@
+-+#include <stddef.h>
+-+
+- struct stat;
+- struct rtcdate;
+- 
+- // system calls
+- int fork(void);
+--int exit(void) __attribute__((noreturn));
+--int wait(void);
+-+int exit(int status) __attribute__((noreturn));
+-+int wait(int* status);
+-+int waitpid(int pid, int* status, int options);
+- int pipe(int*);
+- int write(int, const void*, int);
+- int read(int, void*, int);
+-diff --git a/usertests.c b/usertests.c
+-index a1e97e7..2c2c128 100644
+---- a/usertests.c
+-+++ b/usertests.c
+-@@ -21,19 +21,19 @@ iputtest(void)
+- 
+-   if(mkdir("iputdir") < 0){
+-     printf(stdout, "mkdir failed\n");
+--    exit();
+-+    exit(184);
+-   }
+-   if(chdir("iputdir") < 0){
+-     printf(stdout, "chdir iputdir failed\n");
+--    exit();
+-+    exit(183);
+-   }
+-   if(unlink("../iputdir") < 0){
+-     printf(stdout, "unlink ../iputdir failed\n");
+--    exit();
+-+    exit(182);
+-   }
+-   if(chdir("/") < 0){
+-     printf(stdout, "chdir / failed\n");
+--    exit();
+-+    exit(181);
+-   }
+-   printf(stdout, "iput test ok\n");
+- }
+-@@ -49,24 +49,24 @@ exitiputtest(void)
+-   pid = fork();
+-   if(pid < 0){
+-     printf(stdout, "fork failed\n");
+--    exit();
+-+    exit(180);
+-   }
+-   if(pid == 0){
+-     if(mkdir("iputdir") < 0){
+-       printf(stdout, "mkdir failed\n");
+--      exit();
+-+      exit(179);
+-     }
+-     if(chdir("iputdir") < 0){
+-       printf(stdout, "child chdir failed\n");
+--      exit();
+-+      exit(178);
+-     }
+-     if(unlink("../iputdir") < 0){
+-       printf(stdout, "unlink ../iputdir failed\n");
+--      exit();
+-+      exit(177);
+-     }
+--    exit();
+-+    exit(176);
+-   }
+--  wait();
+-+  wait(NULL);
+-   printf(stdout, "exitiput test ok\n");
+- }
+- 
+-@@ -89,27 +89,27 @@ openiputtest(void)
+-   printf(stdout, "openiput test\n");
+-   if(mkdir("oidir") < 0){
+-     printf(stdout, "mkdir oidir failed\n");
+--    exit();
+-+    exit(175);
+-   }
+-   pid = fork();
+-   if(pid < 0){
+-     printf(stdout, "fork failed\n");
+--    exit();
+-+    exit(174);
+-   }
+-   if(pid == 0){
+-     int fd = open("oidir", O_RDWR);
+-     if(fd >= 0){
+-       printf(stdout, "open directory for write succeeded\n");
+--      exit();
+-+      exit(0);
+-     }
+--    exit();
+-+    exit(172);
+-   }
+-   sleep(1);
+-   if(unlink("oidir") != 0){
+-     printf(stdout, "unlink failed\n");
+--    exit();
+-+    exit(171);
+-   }
+--  wait();
+-+  wait(NULL);
+-   printf(stdout, "openiput test ok\n");
+- }
+- 
+-@@ -124,13 +124,13 @@ opentest(void)
+-   fd = open("echo", 0);
+-   if(fd < 0){
+-     printf(stdout, "open echo failed!\n");
+--    exit();
+-+    exit(170);
+-   }
+-   close(fd);
+-   fd = open("doesnotexist", 0);
+-   if(fd >= 0){
+-     printf(stdout, "open doesnotexist succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   printf(stdout, "open test ok\n");
+- }
+-@@ -147,16 +147,16 @@ writetest(void)
+-     printf(stdout, "creat small succeeded; ok\n");
+-   } else {
+-     printf(stdout, "error: creat small failed!\n");
+--    exit();
+-+    exit(168);
+-   }
+-   for(i = 0; i < 100; i++){
+-     if(write(fd, "aaaaaaaaaa", 10) != 10){
+-       printf(stdout, "error: write aa %d new file failed\n", i);
+--      exit();
+-+      exit(167);
+-     }
+-     if(write(fd, "bbbbbbbbbb", 10) != 10){
+-       printf(stdout, "error: write bb %d new file failed\n", i);
+--      exit();
+-+      exit(166);
+-     }
+-   }
+-   printf(stdout, "writes ok\n");
+-@@ -166,20 +166,20 @@ writetest(void)
+-     printf(stdout, "open small succeeded ok\n");
+-   } else {
+-     printf(stdout, "error: open small failed!\n");
+--    exit();
+-+    exit(165);
+-   }
+-   i = read(fd, buf, 2000);
+-   if(i == 2000){
+-     printf(stdout, "read succeeded ok\n");
+-   } else {
+-     printf(stdout, "read failed\n");
+--    exit();
+-+    exit(164);
+-   }
+-   close(fd);
+- 
+-   if(unlink("small") < 0){
+-     printf(stdout, "unlink small failed\n");
+--    exit();
+-+    exit(163);
+-   }
+-   printf(stdout, "small file test ok\n");
+- }
+-@@ -194,14 +194,14 @@ writetest1(void)
+-   fd = open("big", O_CREATE|O_RDWR);
+-   if(fd < 0){
+-     printf(stdout, "error: creat big failed!\n");
+--    exit();
+-+    exit(162);
+-   }
+- 
+-   for(i = 0; i < MAXFILE; i++){
+-     ((int*)buf)[0] = i;
+-     if(write(fd, buf, 512) != 512){
+-       printf(stdout, "error: write big file failed\n", i);
+--      exit();
+-+      exit(161);
+-     }
+-   }
+- 
+-@@ -210,7 +210,7 @@ writetest1(void)
+-   fd = open("big", O_RDONLY);
+-   if(fd < 0){
+-     printf(stdout, "error: open big failed!\n");
+--    exit();
+-+    exit(160);
+-   }
+- 
+-   n = 0;
+-@@ -219,24 +219,24 @@ writetest1(void)
+-     if(i == 0){
+-       if(n == MAXFILE - 1){
+-         printf(stdout, "read only %d blocks from big", n);
+--        exit();
+-+        exit(159);
+-       }
+-       break;
+-     } else if(i != 512){
+-       printf(stdout, "read failed %d\n", i);
+--      exit();
+-+      exit(158);
+-     }
+-     if(((int*)buf)[0] != n){
+-       printf(stdout, "read content of block %d is %d\n",
+-              n, ((int*)buf)[0]);
+--      exit();
+-+      exit(157);
+-     }
+-     n++;
+-   }
+-   close(fd);
+-   if(unlink("big") < 0){
+-     printf(stdout, "unlink big failed\n");
+--    exit();
+-+    exit(156);
+-   }
+-   printf(stdout, "big files ok\n");
+- }
+-@@ -270,22 +270,22 @@ void dirtest(void)
+- 
+-   if(mkdir("dir0") < 0){
+-     printf(stdout, "mkdir failed\n");
+--    exit();
+-+    exit(155);
+-   }
+- 
+-   if(chdir("dir0") < 0){
+-     printf(stdout, "chdir dir0 failed\n");
+--    exit();
+-+    exit(154);
+-   }
+- 
+-   if(chdir("..") < 0){
+-     printf(stdout, "chdir .. failed\n");
+--    exit();
+-+    exit(153);
+-   }
+- 
+-   if(unlink("dir0") < 0){
+-     printf(stdout, "unlink dir0 failed\n");
+--    exit();
+-+    exit(152);
+-   }
+-   printf(stdout, "mkdir test ok\n");
+- }
+-@@ -296,7 +296,7 @@ exectest(void)
+-   printf(stdout, "exec test\n");
+-   if(exec("echo", echoargv) < 0){
+-     printf(stdout, "exec echo failed\n");
+--    exit();
+-+    exit(151);
+-   }
+- }
+- 
+-@@ -310,7 +310,7 @@ pipe1(void)
+- 
+-   if(pipe(fds) != 0){
+-     printf(1, "pipe() failed\n");
+--    exit();
+-+    exit(150);
+-   }
+-   pid = fork();
+-   seq = 0;
+-@@ -321,10 +321,10 @@ pipe1(void)
+-         buf[i] = seq++;
+-       if(write(fds[1], buf, 1033) != 1033){
+-         printf(1, "pipe1 oops 1\n");
+--        exit();
+-+        exit(149);
+-       }
+-     }
+--    exit();
+-+    exit(148);
+-   } else if(pid > 0){
+-     close(fds[1]);
+-     total = 0;
+-@@ -343,13 +343,13 @@ pipe1(void)
+-     }
+-     if(total != 5 * 1033){
+-       printf(1, "pipe1 oops 3 total %d\n", total);
+--      exit();
+-+      exit(147);
+-     }
+-     close(fds[0]);
+--    wait();
+-+    wait(NULL);
+-   } else {
+-     printf(1, "fork() failed\n");
+--    exit();
+-+    exit(146);
+-   }
+-   printf(1, "pipe1 ok\n");
+- }
+-@@ -394,9 +394,9 @@ preempt(void)
+-   kill(pid2);
+-   kill(pid3);
+-   printf(1, "wait... ");
+--  wait();
+--  wait();
+--  wait();
+-+  wait(NULL);
+-+  wait(NULL);
+-+  wait(NULL);
+-   printf(1, "preempt ok\n");
+- }
+- 
+-@@ -413,12 +413,12 @@ exitwait(void)
+-       return;
+-     }
+-     if(pid){
+--      if(wait() != pid){
+-+      if(wait(NULL) != pid){
+-         printf(1, "wait wrong pid\n");
+-         return;
+-       }
+-     } else {
+--      exit();
+-+      exit(145);
+-     }
+-   }
+-   printf(1, "exitwait ok\n");
+-@@ -447,13 +447,13 @@ mem(void)
+-     if(m1 == 0){
+-       printf(1, "couldn't allocate mem?!!\n");
+-       kill(ppid);
+--      exit();
+-+      exit(144);
+-     }
+-     free(m1);
+-     printf(1, "mem ok\n");
+--    exit();
+-+    exit(0);
+-   } else {
+--    wait();
+-+    wait(NULL);
+-   }
+- }
+- 
+-@@ -484,9 +484,9 @@ sharedfd(void)
+-     }
+-   }
+-   if(pid == 0)
+--    exit();
+-+    exit(142);
+-   else
+--    wait();
+-+    wait(NULL);
+-   close(fd);
+-   fd = open("sharedfd", 0);
+-   if(fd < 0){
+-@@ -508,7 +508,7 @@ sharedfd(void)
+-     printf(1, "sharedfd ok\n");
+-   } else {
+-     printf(1, "sharedfd oops %d %d\n", nc, np);
+--    exit();
+-+    exit(141);
+-   }
+- }
+- 
+-@@ -530,29 +530,29 @@ fourfiles(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "fork failed\n");
+--      exit();
+-+      exit(140);
+-     }
+- 
+-     if(pid == 0){
+-       fd = open(fname, O_CREATE | O_RDWR);
+-       if(fd < 0){
+-         printf(1, "create failed\n");
+--        exit();
+-+        exit(139);
+-       }
+- 
+-       memset(buf, '0'+pi, 512);
+-       for(i = 0; i < 12; i++){
+-         if((n = write(fd, buf, 500)) != 500){
+-           printf(1, "write failed %d\n", n);
+--          exit();
+-+          exit(138);
+-         }
+-       }
+--      exit();
+-+      exit(137);
+-     }
+-   }
+- 
+-   for(pi = 0; pi < 4; pi++){
+--    wait();
+-+    wait(NULL);
+-   }
+- 
+-   for(i = 0; i < 2; i++){
+-@@ -563,7 +563,7 @@ fourfiles(void)
+-       for(j = 0; j < n; j++){
+-         if(buf[j] != '0'+i){
+-           printf(1, "wrong char\n");
+--          exit();
+-+          exit(136);
+-         }
+-       }
+-       total += n;
+-@@ -571,7 +571,7 @@ fourfiles(void)
+-     close(fd);
+-     if(total != 12*500){
+-       printf(1, "wrong length %d\n", total);
+--      exit();
+-+      exit(135);
+-     }
+-     unlink(fname);
+-   }
+-@@ -593,7 +593,7 @@ createdelete(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "fork failed\n");
+--      exit();
+-+      exit(134);
+-     }
+- 
+-     if(pid == 0){
+-@@ -604,23 +604,23 @@ createdelete(void)
+-         fd = open(name, O_CREATE | O_RDWR);
+-         if(fd < 0){
+-           printf(1, "create failed\n");
+--          exit();
+-+          exit(133);
+-         }
+-         close(fd);
+-         if(i > 0 && (i % 2 ) == 0){
+-           name[1] = '0' + (i / 2);
+-           if(unlink(name) < 0){
+-             printf(1, "unlink failed\n");
+--            exit();
+-+            exit(132);
+-           }
+-         }
+-       }
+--      exit();
+-+      exit(131);
+-     }
+-   }
+- 
+-   for(pi = 0; pi < 4; pi++){
+--    wait();
+-+    wait(NULL);
+-   }
+- 
+-   name[0] = name[1] = name[2] = 0;
+-@@ -631,10 +631,10 @@ createdelete(void)
+-       fd = open(name, 0);
+-       if((i == 0 || i >= N/2) && fd < 0){
+-         printf(1, "oops createdelete %s didn't exist\n", name);
+--        exit();
+-+        exit(130);
+-       } else if((i >= 1 && i < N/2) && fd >= 0){
+-         printf(1, "oops createdelete %s did exist\n", name);
+--        exit();
+-+        exit(129);
+-       }
+-       if(fd >= 0)
+-         close(fd);
+-@@ -662,7 +662,7 @@ unlinkread(void)
+-   fd = open("unlinkread", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create unlinkread failed\n");
+--    exit();
+-+    exit(128);
+-   }
+-   write(fd, "hello", 5);
+-   close(fd);
+-@@ -670,11 +670,11 @@ unlinkread(void)
+-   fd = open("unlinkread", O_RDWR);
+-   if(fd < 0){
+-     printf(1, "open unlinkread failed\n");
+--    exit();
+-+    exit(127);
+-   }
+-   if(unlink("unlinkread") != 0){
+-     printf(1, "unlink unlinkread failed\n");
+--    exit();
+-+    exit(126);
+-   }
+- 
+-   fd1 = open("unlinkread", O_CREATE | O_RDWR);
+-@@ -683,15 +683,15 @@ unlinkread(void)
+- 
+-   if(read(fd, buf, sizeof(buf)) != 5){
+-     printf(1, "unlinkread read failed");
+--    exit();
+-+    exit(125);
+-   }
+-   if(buf[0] != 'h'){
+-     printf(1, "unlinkread wrong data\n");
+--    exit();
+-+    exit(124);
+-   }
+-   if(write(fd, buf, 10) != 10){
+-     printf(1, "unlinkread write failed\n");
+--    exit();
+-+    exit(123);
+-   }
+-   close(fd);
+-   unlink("unlinkread");
+-@@ -711,50 +711,50 @@ linktest(void)
+-   fd = open("lf1", O_CREATE|O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create lf1 failed\n");
+--    exit();
+-+    exit(122);
+-   }
+-   if(write(fd, "hello", 5) != 5){
+-     printf(1, "write lf1 failed\n");
+--    exit();
+-+    exit(121);
+-   }
+-   close(fd);
+- 
+-   if(link("lf1", "lf2") < 0){
+-     printf(1, "link lf1 lf2 failed\n");
+--    exit();
+-+    exit(120);
+-   }
+-   unlink("lf1");
+- 
+-   if(open("lf1", 0) >= 0){
+-     printf(1, "unlinked lf1 but it is still there!\n");
+--    exit();
+-+    exit(119);
+-   }
+- 
+-   fd = open("lf2", 0);
+-   if(fd < 0){
+-     printf(1, "open lf2 failed\n");
+--    exit();
+-+    exit(118);
+-   }
+-   if(read(fd, buf, sizeof(buf)) != 5){
+-     printf(1, "read lf2 failed\n");
+--    exit();
+-+    exit(117);
+-   }
+-   close(fd);
+- 
+-   if(link("lf2", "lf2") >= 0){
+-     printf(1, "link lf2 lf2 succeeded! oops\n");
+--    exit();
+-+    exit(116);
+-   }
+- 
+-   unlink("lf2");
+-   if(link("lf2", "lf1") >= 0){
+-     printf(1, "link non-existant succeeded! oops\n");
+--    exit();
+-+    exit(115);
+-   }
+- 
+-   if(link(".", "lf1") >= 0){
+-     printf(1, "link . lf1 succeeded! oops\n");
+--    exit();
+-+    exit(114);
+-   }
+- 
+-   printf(1, "linktest ok\n");
+-@@ -787,14 +787,14 @@ concreate(void)
+-       fd = open(file, O_CREATE | O_RDWR);
+-       if(fd < 0){
+-         printf(1, "concreate create %s failed\n", file);
+--        exit();
+-+        exit(113);
+-       }
+-       close(fd);
+-     }
+-     if(pid == 0)
+--      exit();
+-+      exit(112);
+-     else
+--      wait();
+-+      wait(NULL);
+-   }
+- 
+-   memset(fa, 0, sizeof(fa));
+-@@ -807,11 +807,11 @@ concreate(void)
+-       i = de.name[1] - '0';
+-       if(i < 0 || i >= sizeof(fa)){
+-         printf(1, "concreate weird file %s\n", de.name);
+--        exit();
+-+        exit(111);
+-       }
+-       if(fa[i]){
+-         printf(1, "concreate duplicate file %s\n", de.name);
+--        exit();
+-+        exit(110);
+-       }
+-       fa[i] = 1;
+-       n++;
+-@@ -821,7 +821,7 @@ concreate(void)
+- 
+-   if(n != 40){
+-     printf(1, "concreate not enough files in directory listing\n");
+--    exit();
+-+    exit(109);
+-   }
+- 
+-   for(i = 0; i < 40; i++){
+-@@ -829,7 +829,7 @@ concreate(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "fork failed\n");
+--      exit();
+-+      exit(108);
+-     }
+-     if(((i % 3) == 0 && pid == 0) ||
+-        ((i % 3) == 1 && pid != 0)){
+-@@ -844,9 +844,9 @@ concreate(void)
+-       unlink(file);
+-     }
+-     if(pid == 0)
+--      exit();
+-+      exit(107);
+-     else
+--      wait();
+-+      wait(NULL);
+-   }
+- 
+-   printf(1, "concreate ok\n");
+-@@ -865,7 +865,7 @@ linkunlink()
+-   pid = fork();
+-   if(pid < 0){
+-     printf(1, "fork failed\n");
+--    exit();
+-+    exit(106);
+-   }
+- 
+-   unsigned int x = (pid ? 1 : 97);
+-@@ -881,9 +881,9 @@ linkunlink()
+-   }
+- 
+-   if(pid)
+--    wait();
+-+    wait(NULL);
+-   else
+--    exit();
+-+    exit(105);
+- 
+-   printf(1, "linkunlink ok\n");
+- }
+-@@ -901,7 +901,7 @@ bigdir(void)
+-   fd = open("bd", O_CREATE);
+-   if(fd < 0){
+-     printf(1, "bigdir create failed\n");
+--    exit();
+-+    exit(104);
+-   }
+-   close(fd);
+- 
+-@@ -912,7 +912,7 @@ bigdir(void)
+-     name[3] = '\0';
+-     if(link("bd", name) != 0){
+-       printf(1, "bigdir link failed\n");
+--      exit();
+-+      exit(103);
+-     }
+-   }
+- 
+-@@ -924,7 +924,7 @@ bigdir(void)
+-     name[3] = '\0';
+-     if(unlink(name) != 0){
+-       printf(1, "bigdir unlink failed");
+--      exit();
+-+      exit(102);
+-     }
+-   }
+- 
+-@@ -941,31 +941,31 @@ subdir(void)
+-   unlink("ff");
+-   if(mkdir("dd") != 0){
+-     printf(1, "subdir mkdir dd failed\n");
+--    exit();
+-+    exit(101);
+-   }
+- 
+-   fd = open("dd/ff", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create dd/ff failed\n");
+--    exit();
+-+    exit(100);
+-   }
+-   write(fd, "ff", 2);
+-   close(fd);
+- 
+-   if(unlink("dd") >= 0){
+-     printf(1, "unlink dd (non-empty dir) succeeded!\n");
+--    exit();
+-+    exit(99);
+-   }
+- 
+-   if(mkdir("/dd/dd") != 0){
+-     printf(1, "subdir mkdir dd/dd failed\n");
+--    exit();
+-+    exit(98);
+-   }
+- 
+-   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create dd/dd/ff failed\n");
+--    exit();
+-+    exit(97);
+-   }
+-   write(fd, "FF", 2);
+-   close(fd);
+-@@ -973,142 +973,142 @@ subdir(void)
+-   fd = open("dd/dd/../ff", 0);
+-   if(fd < 0){
+-     printf(1, "open dd/dd/../ff failed\n");
+--    exit();
+-+    exit(96);
+-   }
+-   cc = read(fd, buf, sizeof(buf));
+-   if(cc != 2 || buf[0] != 'f'){
+-     printf(1, "dd/dd/../ff wrong content\n");
+--    exit();
+-+    exit(95);
+-   }
+-   close(fd);
+- 
+-   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+-     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+--    exit();
+-+    exit(94);
+-   }
+- 
+-   if(unlink("dd/dd/ff") != 0){
+-     printf(1, "unlink dd/dd/ff failed\n");
+--    exit();
+-+    exit(93);
+-   }
+-   if(open("dd/dd/ff", O_RDONLY) >= 0){
+-     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+--    exit();
+-+    exit(92);
+-   }
+- 
+-   if(chdir("dd") != 0){
+-     printf(1, "chdir dd failed\n");
+--    exit();
+-+    exit(91);
+-   }
+-   if(chdir("dd/../../dd") != 0){
+-     printf(1, "chdir dd/../../dd failed\n");
+--    exit();
+-+    exit(90);
+-   }
+-   if(chdir("dd/../../../dd") != 0){
+-     printf(1, "chdir dd/../../dd failed\n");
+--    exit();
+-+    exit(89);
+-   }
+-   if(chdir("./..") != 0){
+-     printf(1, "chdir ./.. failed\n");
+--    exit();
+-+    exit(88);
+-   }
+- 
+-   fd = open("dd/dd/ffff", 0);
+-   if(fd < 0){
+-     printf(1, "open dd/dd/ffff failed\n");
+--    exit();
+-+    exit(87);
+-   }
+-   if(read(fd, buf, sizeof(buf)) != 2){
+-     printf(1, "read dd/dd/ffff wrong len\n");
+--    exit();
+-+    exit(86);
+-   }
+-   close(fd);
+- 
+-   if(open("dd/dd/ff", O_RDONLY) >= 0){
+-     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+- 
+-   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+-     printf(1, "create dd/ff/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+-     printf(1, "create dd/xx/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd", O_CREATE) >= 0){
+-     printf(1, "create dd succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd", O_RDWR) >= 0){
+-     printf(1, "open dd rdwr succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd", O_WRONLY) >= 0){
+-     printf(1, "open dd wronly succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("dd/ff/ff", "dd/dd/xx") == 0){
+-     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("dd/xx/ff", "dd/dd/xx") == 0){
+-     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("dd/ff", "dd/dd/ffff") == 0){
+-     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dd/ff/ff") == 0){
+-     printf(1, "mkdir dd/ff/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dd/xx/ff") == 0){
+-     printf(1, "mkdir dd/xx/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dd/dd/ffff") == 0){
+-     printf(1, "mkdir dd/dd/ffff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dd/xx/ff") == 0){
+-     printf(1, "unlink dd/xx/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dd/ff/ff") == 0){
+-     printf(1, "unlink dd/ff/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(chdir("dd/ff") == 0){
+-     printf(1, "chdir dd/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(chdir("dd/xx") == 0){
+-     printf(1, "chdir dd/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+- 
+-   if(unlink("dd/dd/ffff") != 0){
+-     printf(1, "unlink dd/dd/ff failed\n");
+--    exit();
+-+    exit(68);
+-   }
+-   if(unlink("dd/ff") != 0){
+-     printf(1, "unlink dd/ff failed\n");
+--    exit();
+-+    exit(67);
+-   }
+-   if(unlink("dd") == 0){
+-     printf(1, "unlink non-empty dd succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dd/dd") < 0){
+-     printf(1, "unlink dd/dd failed\n");
+--    exit();
+-+    exit(65);
+-   }
+-   if(unlink("dd") < 0){
+-     printf(1, "unlink dd failed\n");
+--    exit();
+-+    exit(64);
+-   }
+- 
+-   printf(1, "subdir ok\n");
+-@@ -1127,14 +1127,14 @@ bigwrite(void)
+-     fd = open("bigwrite", O_CREATE | O_RDWR);
+-     if(fd < 0){
+-       printf(1, "cannot create bigwrite\n");
+--      exit();
+-+      exit(63);
+-     }
+-     int i;
+-     for(i = 0; i < 2; i++){
+-       int cc = write(fd, buf, sz);
+-       if(cc != sz){
+-         printf(1, "write(%d) ret %d\n", sz, cc);
+--        exit();
+-+        exit(62);
+-       }
+-     }
+-     close(fd);
+-@@ -1155,13 +1155,13 @@ bigfile(void)
+-   fd = open("bigfile", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "cannot create bigfile");
+--    exit();
+-+    exit(61);
+-   }
+-   for(i = 0; i < 20; i++){
+-     memset(buf, i, 600);
+-     if(write(fd, buf, 600) != 600){
+-       printf(1, "write bigfile failed\n");
+--      exit();
+-+      exit(60);
+-     }
+-   }
+-   close(fd);
+-@@ -1169,31 +1169,31 @@ bigfile(void)
+-   fd = open("bigfile", 0);
+-   if(fd < 0){
+-     printf(1, "cannot open bigfile\n");
+--    exit();
+-+    exit(59);
+-   }
+-   total = 0;
+-   for(i = 0; ; i++){
+-     cc = read(fd, buf, 300);
+-     if(cc < 0){
+-       printf(1, "read bigfile failed\n");
+--      exit();
+-+      exit(58);
+-     }
+-     if(cc == 0)
+-       break;
+-     if(cc != 300){
+-       printf(1, "short read bigfile\n");
+--      exit();
+-+      exit(57);
+-     }
+-     if(buf[0] != i/2 || buf[299] != i/2){
+-       printf(1, "read bigfile wrong data\n");
+--      exit();
+-+      exit(56);
+-     }
+-     total += cc;
+-   }
+-   close(fd);
+-   if(total != 20*600){
+-     printf(1, "read bigfile wrong total\n");
+--    exit();
+-+    exit(55);
+-   }
+-   unlink("bigfile");
+- 
+-@@ -1210,32 +1210,32 @@ fourteen(void)
+- 
+-   if(mkdir("12345678901234") != 0){
+-     printf(1, "mkdir 12345678901234 failed\n");
+--    exit();
+-+    exit(54);
+-   }
+-   if(mkdir("12345678901234/123456789012345") != 0){
+-     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+--    exit();
+-+    exit(53);
+-   }
+-   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+-   if(fd < 0){
+-     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+--    exit();
+-+    exit(52);
+-   }
+-   close(fd);
+-   fd = open("12345678901234/12345678901234/12345678901234", 0);
+-   if(fd < 0){
+-     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+--    exit();
+-+    exit(51);
+-   }
+-   close(fd);
+- 
+-   if(mkdir("12345678901234/12345678901234") == 0){
+-     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("123456789012345/12345678901234") == 0){
+-     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+- 
+-   printf(1, "fourteen ok\n");
+-@@ -1247,35 +1247,35 @@ rmdot(void)
+-   printf(1, "rmdot test\n");
+-   if(mkdir("dots") != 0){
+-     printf(1, "mkdir dots failed\n");
+--    exit();
+-+    exit(48);
+-   }
+-   if(chdir("dots") != 0){
+-     printf(1, "chdir dots failed\n");
+--    exit();
+-+    exit(47);
+-   }
+-   if(unlink(".") == 0){
+-     printf(1, "rm . worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("..") == 0){
+-     printf(1, "rm .. worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(chdir("/") != 0){
+-     printf(1, "chdir / failed\n");
+--    exit();
+-+    exit(44);
+-   }
+-   if(unlink("dots/.") == 0){
+-     printf(1, "unlink dots/. worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dots/..") == 0){
+-     printf(1, "unlink dots/.. worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dots") != 0){
+-     printf(1, "unlink dots failed!\n");
+--    exit();
+-+    exit(41);
+-   }
+-   printf(1, "rmdot ok\n");
+- }
+-@@ -1290,49 +1290,49 @@ dirfile(void)
+-   fd = open("dirfile", O_CREATE);
+-   if(fd < 0){
+-     printf(1, "create dirfile failed\n");
+--    exit();
+-+    exit(40);
+-   }
+-   close(fd);
+-   if(chdir("dirfile") == 0){
+-     printf(1, "chdir dirfile succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   fd = open("dirfile/xx", 0);
+-   if(fd >= 0){
+-     printf(1, "create dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   fd = open("dirfile/xx", O_CREATE);
+-   if(fd >= 0){
+-     printf(1, "create dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dirfile/xx") == 0){
+-     printf(1, "mkdir dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dirfile/xx") == 0){
+-     printf(1, "unlink dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("README", "dirfile/xx") == 0){
+-     printf(1, "link to dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dirfile") != 0){
+-     printf(1, "unlink dirfile failed!\n");
+--    exit();
+-+    exit(33);
+-   }
+- 
+-   fd = open(".", O_RDWR);
+-   if(fd >= 0){
+-     printf(1, "open . for writing succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   fd = open(".", 0);
+-   if(write(fd, "x", 1) > 0){
+-     printf(1, "write . succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   close(fd);
+- 
+-@@ -1351,11 +1351,11 @@ iref(void)
+-   for(i = 0; i < 50 + 1; i++){
+-     if(mkdir("irefd") != 0){
+-       printf(1, "mkdir irefd failed\n");
+--      exit();
+-+      exit(30);
+-     }
+-     if(chdir("irefd") != 0){
+-       printf(1, "chdir irefd failed\n");
+--      exit();
+-+      exit(29);
+-     }
+- 
+-     mkdir("");
+-@@ -1388,24 +1388,24 @@ forktest(void)
+-     if(pid < 0)
+-       break;
+-     if(pid == 0)
+--      exit();
+-+      exit(28);
+-   }
+- 
+-   if(n == 1000){
+-     printf(1, "fork claimed to work 1000 times!\n");
+--    exit();
+-+    exit(27);
+-   }
+- 
+-   for(; n > 0; n--){
+--    if(wait() < 0){
+-+    if(wait(NULL) < 0){
+-       printf(1, "wait stopped early\n");
+--      exit();
+-+      exit(26);
+-     }
+-   }
+- 
+--  if(wait() != -1){
+-+  if(wait(NULL) != -1){
+-     printf(1, "wait got too many\n");
+--    exit();
+-+    exit(25);
+-   }
+- 
+-   printf(1, "fork test OK\n");
+-@@ -1428,7 +1428,7 @@ sbrktest(void)
+-     b = sbrk(1);
+-     if(b != a){
+-       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+--      exit();
+-+      exit(24);
+-     }
+-     *b = 1;
+-     a = b + 1;
+-@@ -1436,17 +1436,17 @@ sbrktest(void)
+-   pid = fork();
+-   if(pid < 0){
+-     printf(stdout, "sbrk test fork failed\n");
+--    exit();
+-+    exit(23);
+-   }
+-   c = sbrk(1);
+-   c = sbrk(1);
+-   if(c != a + 1){
+-     printf(stdout, "sbrk test failed post-fork\n");
+--    exit();
+-+    exit(22);
+-   }
+-   if(pid == 0)
+--    exit();
+--  wait();
+-+    exit(21);
+-+  wait(NULL);
+- 
+-   // can one grow address space to something big?
+- #define BIG (100*1024*1024)
+-@@ -1455,7 +1455,7 @@ sbrktest(void)
+-   p = sbrk(amt);
+-   if (p != a) {
+-     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+--    exit();
+-+    exit(20);
+-   }
+-   lastaddr = (char*) (BIG-1);
+-   *lastaddr = 99;
+-@@ -1465,12 +1465,12 @@ sbrktest(void)
+-   c = sbrk(-4096);
+-   if(c == (char*)0xffffffff){
+-     printf(stdout, "sbrk could not deallocate\n");
+--    exit();
+-+    exit(19);
+-   }
+-   c = sbrk(0);
+-   if(c != a - 4096){
+-     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+--    exit();
+-+    exit(18);
+-   }
+- 
+-   // can one re-allocate that page?
+-@@ -1478,19 +1478,19 @@ sbrktest(void)
+-   c = sbrk(4096);
+-   if(c != a || sbrk(0) != a + 4096){
+-     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+--    exit();
+-+    exit(17);
+-   }
+-   if(*lastaddr == 99){
+-     // should be zero
+-     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+--    exit();
+-+    exit(16);
+-   }
+- 
+-   a = sbrk(0);
+-   c = sbrk(-(sbrk(0) - oldbrk));
+-   if(c != a){
+-     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+--    exit();
+-+    exit(15);
+-   }
+- 
+-   // can we read the kernel's memory?
+-@@ -1499,21 +1499,21 @@ sbrktest(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(stdout, "fork failed\n");
+--      exit();
+-+      exit(14);
+-     }
+-     if(pid == 0){
+-       printf(stdout, "oops could read %x = %x\n", a, *a);
+-       kill(ppid);
+--      exit();
+-+      exit(13);
+-     }
+--    wait();
+-+    wait(NULL);
+-   }
+- 
+-   // if we run the system out of memory, does it clean up the last
+-   // failed allocation?
+-   if(pipe(fds) != 0){
+-     printf(1, "pipe() failed\n");
+--    exit();
+-+    exit(12);
+-   }
+-   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+-     if((pids[i] = fork()) == 0){
+-@@ -1533,11 +1533,11 @@ sbrktest(void)
+-     if(pids[i] == -1)
+-       continue;
+-     kill(pids[i]);
+--    wait();
+-+    wait(NULL);
+-   }
+-   if(c == (char*)0xffffffff){
+-     printf(stdout, "failed sbrk leaked memory\n");
+--    exit();
+-+    exit(10);
+-   }
+- 
+-   if(sbrk(0) > oldbrk)
+-@@ -1572,17 +1572,17 @@ validatetest(void)
+-     if((pid = fork()) == 0){
+-       // try to crash the kernel by passing in a badly placed integer
+-       validateint((int*)p);
+--      exit();
+-+      exit(9);
+-     }
+-     sleep(0);
+-     sleep(0);
+-     kill(pid);
+--    wait();
+-+    wait(NULL);
+- 
+-     // try to crash the kernel by passing in a bad string pointer
+-     if(link("nosuchfile", (char*)p) != -1){
+-       printf(stdout, "link should not succeed\n");
+--      exit();
+-+      exit(8);
+-     }
+-   }
+- 
+-@@ -1600,7 +1600,7 @@ bsstest(void)
+-   for(i = 0; i < sizeof(uninit); i++){
+-     if(uninit[i] != '\0'){
+-       printf(stdout, "bss test failed\n");
+--      exit();
+-+      exit(7);
+-     }
+-   }
+-   printf(stdout, "bss test ok\n");
+-@@ -1627,16 +1627,16 @@ bigargtest(void)
+-     printf(stdout, "bigarg test ok\n");
+-     fd = open("bigarg-ok", O_CREATE);
+-     close(fd);
+--    exit();
+-+    exit(6);
+-   } else if(pid < 0){
+-     printf(stdout, "bigargtest: fork failed\n");
+--    exit();
+-+    exit(5);
+-   }
+--  wait();
+-+  wait(NULL);
+-   fd = open("bigarg-ok", 0);
+-   if(fd < 0){
+-     printf(stdout, "bigarg test failed!\n");
+--    exit();
+-+    exit(4);
+-   }
+-   close(fd);
+-   unlink("bigarg-ok");
+-@@ -1715,12 +1715,12 @@ uio()
+-     port = RTC_DATA;
+-     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+-     printf(1, "uio: uio succeeded; test FAILED\n");
+--    exit();
+-+    exit(3);
+-   } else if(pid < 0){
+-     printf (1, "fork failed\n");
+--    exit();
+-+    exit(2);
+-   }
+--  wait();
+-+  wait(NULL);
+-   printf(1, "uio test done\n");
+- }
+- 
+-@@ -1730,7 +1730,7 @@ void argptest()
+-   fd = open("init", O_RDONLY);
+-   if (fd < 0) {
+-     printf(2, "open failed\n");
+--    exit();
+-+    exit(1);
+-   }
+-   read(fd, sbrk(0) - 1, -1);
+-   close(fd);
+-@@ -1752,7 +1752,7 @@ main(int argc, char *argv[])
+- 
+-   if(open("usertests.ran", 0) >= 0){
+-     printf(1, "already ran user tests -- rebuild fs.img\n");
+--    exit();
+-+    exit(1);
+-   }
+-   close(open("usertests.ran", O_CREATE));
+- 
+-@@ -1799,5 +1799,5 @@ main(int argc, char *argv[])
+- 
+-   exectest();
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/usys.S b/usys.S
+-index 8bfd8a1..1687ed0 100644
+---- a/usys.S
+-+++ b/usys.S
+-@@ -11,6 +11,7 @@
+- SYSCALL(fork)
+- SYSCALL(exit)
+- SYSCALL(wait)
+-+SYSCALL(waitpid)
+- SYSCALL(pipe)
+- SYSCALL(read)
+- SYSCALL(write)
+-diff --git a/vectors.pl b/vectors.pl
+-old mode 100755
+-new mode 100644
+-diff --git a/wc.c b/wc.c
+-index d6a54df..08b93b6 100644
+---- a/wc.c
+-+++ b/wc.c
+-@@ -27,7 +27,7 @@ wc(int fd, char *name)
+-   }
+-   if(n < 0){
+-     printf(1, "wc: read error\n");
+--    exit();
+-+    exit(3);
+-   }
+-   printf(1, "%d %d %d %s\n", l, w, c, name);
+- }
+-@@ -39,16 +39,16 @@ main(int argc, char *argv[])
+- 
+-   if(argc <= 1){
+-     wc(0, "");
+--    exit();
+-+    exit(2);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-     if((fd = open(argv[i], 0)) < 0){
+-       printf(1, "wc: cannot open %s\n", argv[i]);
+--      exit();
+-+      exit(1);
+-     }
+-     wc(fd, argv[i]);
+-     close(fd);
+-   }
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/zombie.c b/zombie.c
+-index ee817da..c96b92d 100644
+---- a/zombie.c
+-+++ b/zombie.c
+-@@ -10,5 +10,5 @@ main(void)
+- {
+-   if(fork() > 0)
+-     sleep(5);  // Let child exit before parent.
+--  exit();
+-+  exit(0);
+- }
+diff --git a/console.c b/console.c
+deleted file mode 100644
+index a280d2b..0000000
+--- a/console.c
++++ /dev/null
+@@ -1,299 +0,0 @@
+-// Console input and output.
+-// Input is from the keyboard or serial port.
+-// Output is written to the screen and serial port.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "traps.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "file.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-
+-static void consputc(int);
+-
+-static int panicked = 0;
+-
+-static struct {
+-  struct spinlock lock;
+-  int locking;
+-} cons;
+-
+-static void
+-printint(int xx, int base, int sign)
+-{
+-  static char digits[] = "0123456789abcdef";
+-  char buf[16];
+-  int i;
+-  uint x;
+-
+-  if(sign && (sign = xx < 0))
+-    x = -xx;
+-  else
+-    x = xx;
+-
+-  i = 0;
+-  do{
+-    buf[i++] = digits[x % base];
+-  }while((x /= base) != 0);
+-
+-  if(sign)
+-    buf[i++] = '-';
+-
+-  while(--i >= 0)
+-    consputc(buf[i]);
+-}
+-//PAGEBREAK: 50
+-
+-// Print to the console. only understands %d, %x, %p, %s.
+-void
+-cprintf(char *fmt, ...)
+-{
+-  int i, c, locking;
+-  uint *argp;
+-  char *s;
+-
+-  locking = cons.locking;
+-  if(locking)
+-    acquire(&cons.lock);
+-
+-  if (fmt == 0)
+-    panic("null fmt");
+-
+-  argp = (uint*)(void*)(&fmt + 1);
+-  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+-    if(c != '%'){
+-      consputc(c);
 -      continue;
--    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
--      state = states[p->state];
--    else
--      state = "???";
--    cprintf("%d %s %s", p->pid, state, p->name);
--    if(p->state == SLEEPING){
--      getcallerpcs((uint*)p->context->ebp+2, pc);
--      for(i=0; i<10 && pc[i] != 0; i++)
--        cprintf(" %p", pc[i]);
-+procdump(void) {
-+    static char *states[] = {
-+            [UNUSED]    "unused",
-+            [EMBRYO]    "embryo",
-+            [SLEEPING]  "sleep ",
-+            [RUNNABLE]  "runble",
-+            [RUNNING]   "run   ",
-+            [ZOMBIE]    "zombie"
-+    };
-+    int i;
-+    struct proc *p;
-+    char *state;
-+    uint pc[10];
-+
-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-+        if (p->state == UNUSED)
-+            continue;
-+        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
-+            state = states[p->state];
-+        else
-+            state = "???";
-+        cprintf("%d %s %s", p->pid, state, p->name);
-+        if (p->state == SLEEPING) {
-+            getcallerpcs((uint *) p->context->ebp + 2, pc);
-+            for (i = 0; i < 10 && pc[i] != 0; i++)
-+                cprintf(" %p", pc[i]);
-+        }
-+        cprintf("\n");
-     }
--    cprintf("\n");
+-    }
+-    c = fmt[++i] & 0xff;
+-    if(c == 0)
+-      break;
+-    switch(c){
+-    case 'd':
+-      printint(*argp++, 10, 1);
+-      break;
+-    case 'x':
+-    case 'p':
+-      printint(*argp++, 16, 0);
+-      break;
+-    case 's':
+-      if((s = (char*)*argp++) == 0)
+-        s = "(null)";
+-      for(; *s; s++)
+-        consputc(*s);
+-      break;
+-    case '%':
+-      consputc('%');
+-      break;
+-    default:
+-      // Print unknown % sequence to draw attention.
+-      consputc('%');
+-      consputc(c);
+-      break;
+-    }
 -  }
- }
-diff --git a/proc.h b/proc.h
-index 1647114..a06b921 100644
---- a/proc.h
-+++ b/proc.h
-@@ -49,6 +49,7 @@ struct proc {
-   struct file *ofile[NOFILE];  // Open files
-   struct inode *cwd;           // Current directory
-   char name[16];               // Process name (debugging)
-+  int status;                  // Exit status
- };
- 
- // Process memory is laid out contiguously, low addresses first:
-diff --git a/rm.c b/rm.c
-index 4fd33c8..1e6daec 100644
---- a/rm.c
-+++ b/rm.c
-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
- 
-   if(argc < 2){
-     printf(2, "Usage: rm files...\n");
--    exit();
-+    exit(1);
-   }
- 
-   for(i = 1; i < argc; i++){
-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
-     }
-   }
- 
--  exit();
-+  exit(0);
- }
-diff --git a/runoff b/runoff
-old mode 100755
-new mode 100644
-diff --git a/runoff1 b/runoff1
-old mode 100755
-new mode 100644
-diff --git a/sh.c b/sh.c
-index 054bab9..ca2ae37 100644
---- a/sh.c
-+++ b/sh.c
-@@ -65,7 +65,7 @@ runcmd(struct cmd *cmd)
-   struct redircmd *rcmd;
- 
-   if(cmd == 0)
--    exit();
-+    exit(1);
- 
-   switch(cmd->type){
-   default:
-@@ -74,7 +74,7 @@ runcmd(struct cmd *cmd)
-   case EXEC:
-     ecmd = (struct execcmd*)cmd;
-     if(ecmd->argv[0] == 0)
--      exit();
-+      exit(2);
-     exec(ecmd->argv[0], ecmd->argv);
-     printf(2, "exec %s failed\n", ecmd->argv[0]);
-     break;
-@@ -84,7 +84,7 @@ runcmd(struct cmd *cmd)
-     close(rcmd->fd);
-     if(open(rcmd->file, rcmd->mode) < 0){
-       printf(2, "open %s failed\n", rcmd->file);
--      exit();
-+      exit(6);
-     }
-     runcmd(rcmd->cmd);
-     break;
-@@ -93,7 +93,7 @@ runcmd(struct cmd *cmd)
-     lcmd = (struct listcmd*)cmd;
-     if(fork1() == 0)
-       runcmd(lcmd->left);
--    wait();
-+    wait(NULL);
-     runcmd(lcmd->right);
-     break;
- 
-@@ -117,8 +117,8 @@ runcmd(struct cmd *cmd)
-     }
-     close(p[0]);
-     close(p[1]);
--    wait();
--    wait();
-+    wait(NULL);
-+    wait(NULL);
-     break;
- 
-   case BACK:
-@@ -127,7 +127,7 @@ runcmd(struct cmd *cmd)
-       runcmd(bcmd->cmd);
-     break;
-   }
--  exit();
-+  exit(3);
- }
- 
- int
-@@ -166,16 +166,16 @@ main(void)
-     }
-     if(fork1() == 0)
-       runcmd(parsecmd(buf));
--    wait();
-+    wait(NULL);
-   }
--  exit();
-+  exit(0);
- }
- 
- void
- panic(char *s)
- {
-   printf(2, "%s\n", s);
--  exit();
-+  exit(5);
- }
- 
- int
-diff --git a/show1 b/show1
-old mode 100755
-new mode 100644
-diff --git a/sign.pl b/sign.pl
-old mode 100755
-new mode 100644
-diff --git a/spinp b/spinp
-old mode 100755
-new mode 100644
-diff --git a/stressfs.c b/stressfs.c
-index c0a4743..46e0e66 100644
---- a/stressfs.c
-+++ b/stressfs.c
-@@ -43,7 +43,7 @@ main(int argc, char *argv[])
-     read(fd, data, sizeof(data));
-   close(fd);
- 
--  wait();
-+  wait(NULL);
- 
--  exit();
-+  exit(0);
- }
-diff --git a/syscall.c b/syscall.c
-index ee85261..41a8c3c 100644
---- a/syscall.c
-+++ b/syscall.c
-@@ -101,6 +101,7 @@ extern int sys_sbrk(void);
- extern int sys_sleep(void);
- extern int sys_unlink(void);
- extern int sys_wait(void);
-+extern int sys_waitpid(void);
- extern int sys_write(void);
- extern int sys_uptime(void);
- 
-@@ -108,6 +109,7 @@ static int (*syscalls[])(void) = {
- [SYS_fork]    sys_fork,
- [SYS_exit]    sys_exit,
- [SYS_wait]    sys_wait,
-+[SYS_waitpid] sys_waitpid,
- [SYS_pipe]    sys_pipe,
- [SYS_read]    sys_read,
- [SYS_kill]    sys_kill,
-diff --git a/syscall.h b/syscall.h
-index bc5f356..374ff05 100644
---- a/syscall.h
-+++ b/syscall.h
-@@ -1,22 +1,23 @@
- // System call numbers
--#define SYS_fork    1
--#define SYS_exit    2
--#define SYS_wait    3
--#define SYS_pipe    4
--#define SYS_read    5
--#define SYS_kill    6
--#define SYS_exec    7
--#define SYS_fstat   8
--#define SYS_chdir   9
--#define SYS_dup    10
--#define SYS_getpid 11
--#define SYS_sbrk   12
--#define SYS_sleep  13
--#define SYS_uptime 14
--#define SYS_open   15
--#define SYS_write  16
--#define SYS_mknod  17
--#define SYS_unlink 18
--#define SYS_link   19
--#define SYS_mkdir  20
--#define SYS_close  21
-+#define SYS_fork     1
-+#define SYS_exit     2
-+#define SYS_wait     3
-+#define SYS_pipe     4
-+#define SYS_read     5
-+#define SYS_kill     6
-+#define SYS_exec     7
-+#define SYS_fstat    8
-+#define SYS_chdir    9
-+#define SYS_dup     10
-+#define SYS_getpid  11
-+#define SYS_sbrk    12
-+#define SYS_sleep   13
-+#define SYS_uptime  14
-+#define SYS_open    15
-+#define SYS_write   16
-+#define SYS_mknod   17
-+#define SYS_unlink  18
-+#define SYS_link    19
-+#define SYS_mkdir   20
-+#define SYS_close   21
-+#define SYS_waitpid 22
-\ No newline at end of file
-diff --git a/sysproc.c b/sysproc.c
-index 0686d29..ebccf84 100644
---- a/sysproc.c
-+++ b/sysproc.c
-@@ -14,16 +14,22 @@ sys_fork(void)
- }
- 
- int
--sys_exit(void)
-+sys_exit(int status)
- {
--  exit();
-+  exit(status);
-   return 0;  // not reached
- }
- 
- int
--sys_wait(void)
-+sys_wait(int* status)
- {
--  return wait();
-+  return wait(status);
+-
+-  if(locking)
+-    release(&cons.lock);
+-}
+-
+-void
+-panic(char *s)
+-{
+-  int i;
+-  uint pcs[10];
+-
+-  cli();
+-  cons.locking = 0;
+-  // use lapiccpunum so that we can call panic from mycpu()
+-  cprintf("lapicid %d: panic: ", lapicid());
+-  cprintf(s);
+-  cprintf("\n");
+-  getcallerpcs(&s, pcs);
+-  for(i=0; i<10; i++)
+-    cprintf(" %p", pcs[i]);
+-  panicked = 1; // freeze other CPU
+-  for(;;)
+-    ;
+-}
+-
+-//PAGEBREAK: 50
+-#define BACKSPACE 0x100
+-#define CRTPORT 0x3d4
+-static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
+-
+-static void
+-cgaputc(int c)
+-{
+-  int pos;
+-
+-  // Cursor position: col + 80*row.
+-  outb(CRTPORT, 14);
+-  pos = inb(CRTPORT+1) << 8;
+-  outb(CRTPORT, 15);
+-  pos |= inb(CRTPORT+1);
+-
+-  if(c == '\n')
+-    pos += 80 - pos%80;
+-  else if(c == BACKSPACE){
+-    if(pos > 0) --pos;
+-  } else
+-    crt[pos++] = (c&0xff) | 0x0700;  // black on white
+-
+-  if(pos < 0 || pos > 25*80)
+-    panic("pos under/overflow");
+-
+-  if((pos/80) >= 24){  // Scroll up.
+-    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+-    pos -= 80;
+-    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+-  }
+-
+-  outb(CRTPORT, 14);
+-  outb(CRTPORT+1, pos>>8);
+-  outb(CRTPORT, 15);
+-  outb(CRTPORT+1, pos);
+-  crt[pos] = ' ' | 0x0700;
+-}
+-
+-void
+-consputc(int c)
+-{
+-  if(panicked){
+-    cli();
+-    for(;;)
+-      ;
+-  }
+-
+-  if(c == BACKSPACE){
+-    uartputc('\b'); uartputc(' '); uartputc('\b');
+-  } else
+-    uartputc(c);
+-  cgaputc(c);
+-}
+-
+-#define INPUT_BUF 128
+-struct {
+-  char buf[INPUT_BUF];
+-  uint r;  // Read index
+-  uint w;  // Write index
+-  uint e;  // Edit index
+-} input;
+-
+-#define C(x)  ((x)-'@')  // Control-x
+-
+-void
+-consoleintr(int (*getc)(void))
+-{
+-  int c, doprocdump = 0;
+-
+-  acquire(&cons.lock);
+-  while((c = getc()) >= 0){
+-    switch(c){
+-    case C('P'):  // Process listing.
+-      // procdump() locks cons.lock indirectly; invoke later
+-      doprocdump = 1;
+-      break;
+-    case C('U'):  // Kill line.
+-      while(input.e != input.w &&
+-            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+-        input.e--;
+-        consputc(BACKSPACE);
+-      }
+-      break;
+-    case C('H'): case '\x7f':  // Backspace
+-      if(input.e != input.w){
+-        input.e--;
+-        consputc(BACKSPACE);
+-      }
+-      break;
+-    default:
+-      if(c != 0 && input.e-input.r < INPUT_BUF){
+-        c = (c == '\r') ? '\n' : c;
+-        input.buf[input.e++ % INPUT_BUF] = c;
+-        consputc(c);
+-        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
+-          input.w = input.e;
+-          wakeup(&input.r);
+-        }
+-      }
+-      break;
+-    }
+-  }
+-  release(&cons.lock);
+-  if(doprocdump) {
+-    procdump();  // now call procdump() wo. cons.lock held
+-  }
+-}
+-
+-int
+-consoleread(struct inode *ip, char *dst, int n)
+-{
+-  uint target;
+-  int c;
+-
+-  iunlock(ip);
+-  target = n;
+-  acquire(&cons.lock);
+-  while(n > 0){
+-    while(input.r == input.w){
+-      if(myproc()->killed){
+-        release(&cons.lock);
+-        ilock(ip);
+-        return -1;
+-      }
+-      sleep(&input.r, &cons.lock);
+-    }
+-    c = input.buf[input.r++ % INPUT_BUF];
+-    if(c == C('D')){  // EOF
+-      if(n < target){
+-        // Save ^D for next time, to make sure
+-        // caller gets a 0-byte result.
+-        input.r--;
+-      }
+-      break;
+-    }
+-    *dst++ = c;
+-    --n;
+-    if(c == '\n')
+-      break;
+-  }
+-  release(&cons.lock);
+-  ilock(ip);
+-
+-  return target - n;
+-}
+-
+-int
+-consolewrite(struct inode *ip, char *buf, int n)
+-{
+-  int i;
+-
+-  iunlock(ip);
+-  acquire(&cons.lock);
+-  for(i = 0; i < n; i++)
+-    consputc(buf[i] & 0xff);
+-  release(&cons.lock);
+-  ilock(ip);
+-
+-  return n;
+-}
+-
+-void
+-consoleinit(void)
+-{
+-  initlock(&cons.lock, "console");
+-
+-  devsw[CONSOLE].write = consolewrite;
+-  devsw[CONSOLE].read = consoleread;
+-  cons.locking = 1;
+-
+-  ioapicenable(IRQ_KBD, 0);
+-}
+-
+diff --git a/cuth b/cuth
+deleted file mode 100644
+index cce8c0c..0000000
+--- a/cuth
++++ /dev/null
+@@ -1,48 +0,0 @@
+-#!/usr/bin/perl
+-
+-$| = 1;
+-
+-sub writefile($@){
+-	my ($file, @lines) = @_;
+-	
+-	sleep(1);
+-	open(F, ">$file") || die "open >$file: $!";
+-	print F @lines;
+-	close(F);
+-}
+-
+-# Cut out #include lines that don't contribute anything.
+-for($i=0; $i<@ARGV; $i++){
+-	$file = $ARGV[$i];
+-	if(!open(F, $file)){
+-		print STDERR "open $file: $!\n";
+-		next;
+-	}
+-	@lines = <F>;
+-	close(F);
+-	
+-	$obj = "$file.o";
+-	$obj =~ s/\.c\.o$/.o/;
+-	system("touch $file");
+-
+-	if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
+-		print STDERR "make $obj failed: $rv\n";
+-		next;
+-	}
+-
+-	system("cp $file =$file");
+-	for($j=@lines-1; $j>=0; $j--){
+-		if($lines[$j] =~ /^#include/){
+-			$old = $lines[$j];
+-			$lines[$j] = "/* CUT-H */\n";
+-			writefile($file, @lines);
+-			if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
+-				$lines[$j] = $old;
+-			}else{
+-				print STDERR "$file $old";
+-			}
+-		}
+-	}
+-	writefile($file, grep {!/CUT-H/} @lines);
+-	system("rm =$file");
+-}
+diff --git a/date.h b/date.h
+deleted file mode 100644
+index 94aec4b..0000000
+--- a/date.h
++++ /dev/null
+@@ -1,8 +0,0 @@
+-struct rtcdate {
+-  uint second;
+-  uint minute;
+-  uint hour;
+-  uint day;
+-  uint month;
+-  uint year;
+-};
+diff --git a/defs.h b/defs.h
+deleted file mode 100644
+index d1934ca..0000000
+--- a/defs.h
++++ /dev/null
+@@ -1,191 +0,0 @@
+-struct buf;
+-struct context;
+-struct file;
+-struct inode;
+-struct pipe;
+-struct proc;
+-struct rtcdate;
+-struct spinlock;
+-struct sleeplock;
+-struct stat;
+-struct superblock;
+-
+-// bio.c
+-void            binit(void);
+-struct buf*     bread(uint, uint);
+-void            brelse(struct buf*);
+-void            bwrite(struct buf*);
+-
+-// console.c
+-void            consoleinit(void);
+-void            cprintf(char*, ...);
+-void            consoleintr(int(*)(void));
+-void            panic(char*) __attribute__((noreturn));
+-
+-// exec.c
+-int             exec(char*, char**);
+-
+-// file.c
+-struct file*    filealloc(void);
+-void            fileclose(struct file*);
+-struct file*    filedup(struct file*);
+-void            fileinit(void);
+-int             fileread(struct file*, char*, int n);
+-int             filestat(struct file*, struct stat*);
+-int             filewrite(struct file*, char*, int n);
+-
+-// fs.c
+-void            readsb(int dev, struct superblock *sb);
+-int             dirlink(struct inode*, char*, uint);
+-struct inode*   dirlookup(struct inode*, char*, uint*);
+-struct inode*   ialloc(uint, short);
+-struct inode*   idup(struct inode*);
+-void            iinit(int dev);
+-void            ilock(struct inode*);
+-void            iput(struct inode*);
+-void            iunlock(struct inode*);
+-void            iunlockput(struct inode*);
+-void            iupdate(struct inode*);
+-int             namecmp(const char*, const char*);
+-struct inode*   namei(char*);
+-struct inode*   nameiparent(char*, char*);
+-int             readi(struct inode*, char*, uint, uint);
+-void            stati(struct inode*, struct stat*);
+-int             writei(struct inode*, char*, uint, uint);
+-
+-// ide.c
+-void            ideinit(void);
+-void            ideintr(void);
+-void            iderw(struct buf*);
+-
+-// ioapic.c
+-void            ioapicenable(int irq, int cpu);
+-extern uchar    ioapicid;
+-void            ioapicinit(void);
+-
+-// kalloc.c
+-char*           kalloc(void);
+-void            kfree(char*);
+-void            kinit1(void*, void*);
+-void            kinit2(void*, void*);
+-
+-// kbd.c
+-void            kbdintr(void);
+-
+-// lapic.c
+-void            cmostime(struct rtcdate *r);
+-int             lapicid(void);
+-extern volatile uint*    lapic;
+-void            lapiceoi(void);
+-void            lapicinit(void);
+-void            lapicstartap(uchar, uint);
+-void            microdelay(int);
+-
+-// log.c
+-void            initlog(int dev);
+-void            log_write(struct buf*);
+-void            begin_op();
+-void            end_op();
+-
+-// mp.c
+-extern int      ismp;
+-void            mpinit(void);
+-
+-// picirq.c
+-void            picenable(int);
+-void            picinit(void);
+-
+-// pipe.c
+-int             pipealloc(struct file**, struct file**);
+-void            pipeclose(struct pipe*, int);
+-int             piperead(struct pipe*, char*, int);
+-int             pipewrite(struct pipe*, char*, int);
+-
+-//PAGEBREAK: 16
+-// proc.c
+-int             cpuid(void);
+-void            exit(int status);
+-int             fork(void);
+-int             growproc(int);
+-int             kill(int);
+-struct cpu*     mycpu(void);
+-struct proc*    myproc();
+-void            pinit(void);
+-void            procdump(void);
+-void            scheduler(void) __attribute__((noreturn));
+-void            sched(void);
+-void            setproc(struct proc*);
+-void            sleep(void*, struct spinlock*);
+-void            userinit(void);
+-int             wait(int* status);
+-int             waitpid(int pid, int* status, int options);
+-void            wakeup(void*);
+-void            yield(void);
+-
+-// swtch.S
+-void            swtch(struct context**, struct context*);
+-
+-// spinlock.c
+-void            acquire(struct spinlock*);
+-void            getcallerpcs(void*, uint*);
+-int             holding(struct spinlock*);
+-void            initlock(struct spinlock*, char*);
+-void            release(struct spinlock*);
+-void            pushcli(void);
+-void            popcli(void);
+-
+-// sleeplock.c
+-void            acquiresleep(struct sleeplock*);
+-void            releasesleep(struct sleeplock*);
+-int             holdingsleep(struct sleeplock*);
+-void            initsleeplock(struct sleeplock*, char*);
+-
+-// string.c
+-int             memcmp(const void*, const void*, uint);
+-void*           memmove(void*, const void*, uint);
+-void*           memset(void*, int, uint);
+-char*           safestrcpy(char*, const char*, int);
+-int             strlen(const char*);
+-int             strncmp(const char*, const char*, uint);
+-char*           strncpy(char*, const char*, int);
+-
+-// syscall.c
+-int             argint(int, int*);
+-int             argptr(int, char**, int);
+-int             argstr(int, char**);
+-int             fetchint(uint, int*);
+-int             fetchstr(uint, char**);
+-void            syscall(void);
+-
+-// timer.c
+-void            timerinit(void);
+-
+-// trap.c
+-void            idtinit(void);
+-extern uint     ticks;
+-void            tvinit(void);
+-extern struct spinlock tickslock;
+-
+-// uart.c
+-void            uartinit(void);
+-void            uartintr(void);
+-void            uartputc(int);
+-
+-// vm.c
+-void            seginit(void);
+-void            kvmalloc(void);
+-pde_t*          setupkvm(void);
+-char*           uva2ka(pde_t*, char*);
+-int             allocuvm(pde_t*, uint, uint);
+-int             deallocuvm(pde_t*, uint, uint);
+-void            freevm(pde_t*);
+-void            inituvm(pde_t*, char*, uint);
+-int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
+-pde_t*          copyuvm(pde_t*, uint);
+-void            switchuvm(struct proc*);
+-void            switchkvm(void);
+-int             copyout(pde_t*, uint, void*, uint);
+-void            clearpteu(pde_t *pgdir, char *uva);
+-
+-// number of elements in fixed-size array
+-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+diff --git a/dot-bochsrc b/dot-bochsrc
+deleted file mode 100644
+index ba13db7..0000000
+--- a/dot-bochsrc
++++ /dev/null
+@@ -1,738 +0,0 @@
+-# You may now use double quotes around pathnames, in case
+-# your pathname includes spaces.
+-
+-#=======================================================================
+-# CONFIG_INTERFACE
+-#
+-# The configuration interface is a series of menus or dialog boxes that
+-# allows you to change all the settings that control Bochs's behavior.
+-# There are two choices of configuration interface: a text mode version
+-# called "textconfig" and a graphical version called "wx".  The text
+-# mode version uses stdin/stdout and is always compiled in.  The graphical
+-# version is only available when you use "--with-wx" on the configure 
+-# command.  If you do not write a config_interface line, Bochs will 
+-# choose a default for you.
+-#
+-# NOTE: if you use the "wx" configuration interface, you must also use
+-# the "wx" display library.
+-#=======================================================================
+-#config_interface: textconfig
+-#config_interface: wx
+-
+-#=======================================================================
+-# DISPLAY_LIBRARY
+-#
+-# The display library is the code that displays the Bochs VGA screen.  Bochs 
+-# has a selection of about 10 different display library implementations for 
+-# different platforms.  If you run configure with multiple --with-* options, 
+-# the display_library command lets you choose which one you want to run with.
+-# If you do not write a display_library line, Bochs will choose a default for
+-# you.
+-#
+-# The choices are: 
+-#   x              use X windows interface, cross platform
+-#   win32          use native win32 libraries
+-#   carbon         use Carbon library (for MacOS X)
+-#   beos           use native BeOS libraries
+-#   macintosh      use MacOS pre-10
+-#   amigaos        use native AmigaOS libraries
+-#   sdl            use SDL library, cross platform
+-#   svga           use SVGALIB library for Linux, allows graphics without X11
+-#   term           text only, uses curses/ncurses library, cross platform
+-#   rfb            provides an interface to AT&T's VNC viewer, cross platform
+-#   wx             use wxWidgets library, cross platform
+-#   nogui          no display at all
+-#
+-# NOTE: if you use the "wx" configuration interface, you must also use
+-# the "wx" display library.
+-#
+-# Specific options:
+-# Some display libraries now support specific option to control their
+-# behaviour. See the examples below for currently supported options.
+-#=======================================================================
+-#display_library: amigaos
+-#display_library: beos
+-#display_library: carbon
+-#display_library: macintosh
+-#display_library: nogui
+-#display_library: rfb, options="timeout=60" # time to wait for client
+-#display_library: sdl, options="fullscreen" # startup in fullscreen mode
+-#display_library: term
+-#display_library: win32, options="legacyF12" # use F12 to toggle mouse
+-#display_library: wx
+-#display_library: x
+-
+-#=======================================================================
+-# ROMIMAGE:
+-# The ROM BIOS controls what the PC does when it first powers on.
+-# Normally, you can use a precompiled BIOS in the source or binary
+-# distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded
+-# starting at address 0xf0000, and it is exactly 64k long.
+-# You can also use the environment variable $BXSHARE to specify the
+-# location of the BIOS.
+-# The usage of external large BIOS images (up to 512k) at memory top is
+-# now supported, but we still recommend to use the BIOS distributed with
+-# Bochs. Now the start address can be calculated from image size.
+-#=======================================================================
+-romimage: file=$BXSHARE/BIOS-bochs-latest
+-#romimage: file=mybios.bin, address=0xfff80000 # 512k at memory top
+-#romimage: file=mybios.bin # calculate start address from image size
+-
+-#=======================================================================
+-# CPU:
+-# This defines cpu-related parameters inside Bochs:
+-#
+-#  COUNT:
+-#  Set the number of processors when Bochs is compiled for SMP emulation.
+-#  Bochs currently supports up to 8 processors. If Bochs is compiled
+-#  without SMP support, it won't accept values different from 1.
+-#
+-#  IPS:
+-#  Emulated Instructions Per Second.  This is the number of IPS that bochs
+-#  is capable of running on your machine. You can recompile Bochs with
+-#  --enable-show-ips option enabled, to find your workstation's capability.
+-#  Measured IPS value will then be logged into your log file or status bar
+-#  (if supported by the gui).
+-#
+-#  IPS is used to calibrate many time-dependent events within the bochs 
+-#  simulation.  For example, changing IPS affects the frequency of VGA
+-#  updates, the duration of time before a key starts to autorepeat, and
+-#  the measurement of BogoMips and other benchmarks.
+-#
+-#  Examples:
+-#  Machine                                         Mips
+-# ________________________________________________________________
+-#  2.1Ghz Athlon XP with Linux 2.6/g++ 3.4         12 to 15 Mips
+-#  1.6Ghz Intel P4 with Win2000/g++ 3.3             5 to  7 Mips
+-#  650Mhz Athlon K-7 with Linux 2.4.4/egcs-2.91.66  2 to  2.5 Mips
+-#  400Mhz Pentium II with Linux 2.0.36/egcs-1.0.3   1 to  1.8 Mips
+-#=======================================================================
+-cpu: count=2, ips=10000000
+-
+-#=======================================================================
+-# MEGS
+-# Set the number of Megabytes of physical memory you want to emulate. 
+-# The default is 32MB, most OS's won't need more than that.
+-# The maximum amount of memory supported is 2048Mb.
+-#=======================================================================
+-#megs: 256
+-#megs: 128
+-#megs: 64
+-megs: 32
+-#megs: 16
+-#megs: 8
+-
+-#=======================================================================
+-# OPTROMIMAGE[1-4]:
+-# You may now load up to 4 optional ROM images. Be sure to use a 
+-# read-only area, typically between C8000 and EFFFF. These optional
+-# ROM images should not overwrite the rombios (located at
+-# F0000-FFFFF) and the videobios (located at C0000-C7FFF).
+-# Those ROM images will be initialized by the bios if they contain 
+-# the right signature (0x55AA) and a valid checksum.
+-# It can also be a convenient way to upload some arbitrary code/data
+-# in the simulation, that can be retrieved by the boot loader
+-#=======================================================================
+-#optromimage1: file=optionalrom.bin, address=0xd0000
+-#optromimage2: file=optionalrom.bin, address=0xd1000
+-#optromimage3: file=optionalrom.bin, address=0xd2000
+-#optromimage4: file=optionalrom.bin, address=0xd3000
+-
+-#optramimage1: file=/path/file1.img, address=0x0010000
+-#optramimage2: file=/path/file2.img, address=0x0020000
+-#optramimage3: file=/path/file3.img, address=0x0030000
+-#optramimage4: file=/path/file4.img, address=0x0040000
+-
+-#=======================================================================
+-# VGAROMIMAGE
+-# You now need to load a VGA ROM BIOS into C0000.
+-#=======================================================================
+-#vgaromimage: file=bios/VGABIOS-elpin-2.40
+-vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
+-#vgaromimage: file=bios/VGABIOS-lgpl-latest-cirrus
+-
+-#=======================================================================
+-# VGA:
+-# Here you can specify the display extension to be used. With the value
+-# 'none' you can use standard VGA with no extension. Other supported
+-# values are 'vbe' for Bochs VBE and 'cirrus' for Cirrus SVGA support.
+-#=======================================================================
+-#vga: extension=cirrus
+-#vga: extension=vbe
+-vga: extension=none
+-
+-#=======================================================================
+-# FLOPPYA:
+-# Point this to pathname of floppy image file or device
+-# This should be of a bootable floppy(image/device) if you're
+-# booting from 'a' (or 'floppy').
+-#
+-# You can set the initial status of the media to 'ejected' or 'inserted'.
+-#   floppya: 2_88=path, status=ejected             (2.88M 3.5" floppy)
+-#   floppya: 1_44=path, status=inserted            (1.44M 3.5" floppy)
+-#   floppya: 1_2=path, status=ejected              (1.2M  5.25" floppy)
+-#   floppya: 720k=path, status=inserted            (720K  3.5" floppy)
+-#   floppya: 360k=path, status=inserted            (360K  5.25" floppy)
+-#   floppya: 320k=path, status=inserted            (320K  5.25" floppy)
+-#   floppya: 180k=path, status=inserted            (180K  5.25" floppy)
+-#   floppya: 160k=path, status=inserted            (160K  5.25" floppy)
+-#   floppya: image=path, status=inserted           (guess type from image size)
+-#
+-# The path should be the name of a disk image file.  On Unix, you can use a raw
+-# device name such as /dev/fd0 on Linux.  On win32 platforms, use drive letters
+-# such as a: or b: as the path.  The parameter 'image' works with image files
+-# only. In that case the size must match one of the supported types.
+-#=======================================================================
+-floppya: 1_44=/dev/fd0, status=inserted
+-#floppya: image=../1.44, status=inserted
+-#floppya: 1_44=/dev/fd0H1440, status=inserted
+-#floppya: 1_2=../1_2, status=inserted
+-#floppya: 1_44=a:, status=inserted
+-#floppya: 1_44=a.img, status=inserted
+-#floppya: 1_44=/dev/rfd0a, status=inserted
+-
+-#=======================================================================
+-# FLOPPYB:
+-# See FLOPPYA above for syntax
+-#=======================================================================
+-#floppyb: 1_44=b:, status=inserted
+-floppyb: 1_44=b.img, status=inserted
+-
+-#=======================================================================
+-# ATA0, ATA1, ATA2, ATA3
+-# ATA controller for hard disks and cdroms
+-#
+-# ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
+-# 
+-# These options enables up to 4 ata channels. For each channel
+-# the two base io addresses and the irq must be specified.
+-# 
+-# ata0 and ata1 are enabled by default with the values shown below
+-#
+-# Examples:
+-#   ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
+-#   ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
+-#   ata2: enabled=1, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
+-#   ata3: enabled=1, ioaddr1=0x168, ioaddr2=0x360, irq=9
+-#=======================================================================
+-ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
+-ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
+-ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
+-ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9
+-
+-#=======================================================================
+-# ATA[0-3]-MASTER, ATA[0-3]-SLAVE
+-#
+-# This defines the type and characteristics of all attached ata devices:
+-#   type=       type of attached device [disk|cdrom] 
+-#   mode=       only valid for disks [flat|concat|external|dll|sparse|vmware3]
+-#   mode=       only valid for disks [undoable|growing|volatile]
+-#   path=       path of the image
+-#   cylinders=  only valid for disks
+-#   heads=      only valid for disks
+-#   spt=        only valid for disks
+-#   status=     only valid for cdroms [inserted|ejected]
+-#   biosdetect= type of biosdetection [none|auto], only for disks on ata0 [cmos]
+-#   translation=type of translation of the bios, only for disks [none|lba|large|rechs|auto]
+-#   model=      string returned by identify device command
+-#   journal=    optional filename of the redolog for undoable and volatile disks
+-#   
+-# Point this at a hard disk image file, cdrom iso file, or physical cdrom
+-# device.  To create a hard disk image, try running bximage.  It will help you
+-# choose the size and then suggest a line that works with it.
+-#
+-# In UNIX it may be possible to use a raw device as a Bochs hard disk, 
+-# but WE DON'T RECOMMEND IT.  In Windows there is no easy way.
+-#
+-# In windows, the drive letter + colon notation should be used for cdroms.
+-# Depending on versions of windows and drivers, you may only be able to 
+-# access the "first" cdrom in the system.  On MacOSX, use path="drive"
+-# to access the physical drive.
+-#
+-# The path is always mandatory. For flat hard disk images created with
+-# bximage geometry autodetection can be used (cylinders=0 -> cylinders are
+-# calculated using heads=16 and spt=63). For other hard disk images and modes
+-# the cylinders, heads, and spt are mandatory.
+-#
+-# Default values are:
+-#   mode=flat, biosdetect=auto, translation=auto, model="Generic 1234"
+-#
+-# The biosdetect option has currently no effect on the bios
+-#
+-# Examples:
+-#   ata0-master: type=disk, mode=flat, path=10M.sample, cylinders=306, heads=4, spt=17
+-#   ata0-slave:  type=disk, mode=flat, path=20M.sample, cylinders=615, heads=4, spt=17
+-#   ata1-master: type=disk, mode=flat, path=30M.sample, cylinders=615, heads=6, spt=17
+-#   ata1-slave:  type=disk, mode=flat, path=46M.sample, cylinders=940, heads=6, spt=17
+-#   ata2-master: type=disk, mode=flat, path=62M.sample, cylinders=940, heads=8, spt=17
+-#   ata2-slave:  type=disk, mode=flat, path=112M.sample, cylinders=900, heads=15, spt=17
+-#   ata3-master: type=disk, mode=flat, path=483M.sample, cylinders=1024, heads=15, spt=63
+-#   ata3-slave:  type=cdrom, path=iso.sample, status=inserted
+-#=======================================================================
+-ata0-master: type=disk, mode=flat, path="xv6.img", cylinders=100, heads=10, spt=10
+-ata0-slave: type=disk, mode=flat, path="fs.img", cylinders=1024, heads=1, spt=1
+-#ata0-slave: type=cdrom, path=D:, status=inserted
+-#ata0-slave: type=cdrom, path=/dev/cdrom, status=inserted
+-#ata0-slave: type=cdrom, path="drive", status=inserted
+-#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted 
+-
+-#=======================================================================
+-# BOOT:
+-# This defines the boot sequence. Now you can specify up to 3 boot drives.
+-# You can either boot from 'floppy', 'disk' or 'cdrom'
+-# legacy 'a' and 'c' are also supported
+-# Examples:
+-#   boot: floppy
+-#   boot: disk
+-#   boot: cdrom
+-#   boot: c
+-#   boot: a
+-#   boot: cdrom, floppy, disk
+-#=======================================================================
+-#boot: floppy
+-boot: disk
+-
+-#=======================================================================
+-# CLOCK:
+-# This defines the parameters of the clock inside Bochs:
+-#
+-#  SYNC:
+-#  TO BE COMPLETED (see Greg explanation in feature request #536329)
+-#
+-#  TIME0:
+-#  Specifies the start (boot) time of the virtual machine. Use a time 
+-#  value as returned by the time(2) system call. If no time0 value is 
+-#  set or if time0 equal to 1 (special case) or if time0 equal 'local', 
+-#  the simulation will be started at the current local host time.
+-#  If time0 equal to 2 (special case) or if time0 equal 'utc',
+-#  the simulation will be started at the current utc time.
+-#
+-# Syntax:
+-#  clock: sync=[none|slowdown|realtime|both], time0=[timeValue|local|utc]
+-#
+-# Example:
+-#   clock: sync=none,     time0=local       # Now (localtime)
+-#   clock: sync=slowdown, time0=315529200   # Tue Jan  1 00:00:00 1980
+-#   clock: sync=none,     time0=631148400   # Mon Jan  1 00:00:00 1990
+-#   clock: sync=realtime, time0=938581955   # Wed Sep 29 07:12:35 1999
+-#   clock: sync=realtime, time0=946681200   # Sat Jan  1 00:00:00 2000
+-#   clock: sync=none,     time0=1           # Now (localtime)
+-#   clock: sync=none,     time0=utc         # Now (utc/gmt)
+-# 
+-# Default value are sync=none, time0=local
+-#=======================================================================
+-#clock: sync=none, time0=local
+-
+-
+-#=======================================================================
+-# FLOPPY_BOOTSIG_CHECK: disabled=[0|1]
+-# Enables or disables the 0xaa55 signature check on boot floppies
+-# Defaults to disabled=0
+-# Examples:
+-#   floppy_bootsig_check: disabled=0
+-#   floppy_bootsig_check: disabled=1
+-#=======================================================================
+-#floppy_bootsig_check: disabled=1
+-floppy_bootsig_check: disabled=0
+-
+-#=======================================================================
+-# LOG:
+-# Give the path of the log file you'd like Bochs debug and misc. verbiage
+-# to be written to. If you don't use this option or set the filename to
+-# '-' the output is written to the console. If you really don't want it,
+-# make it "/dev/null" (Unix) or "nul" (win32). :^(
+-#
+-# Examples:
+-#   log: ./bochs.out
+-#   log: /dev/tty
+-#=======================================================================
+-#log: /dev/null
+-log: bochsout.txt
+-
+-#=======================================================================
+-# LOGPREFIX:
+-# This handles the format of the string prepended to each log line.
+-# You may use those special tokens :
+-#   %t : 11 decimal digits timer tick
+-#   %i : 8 hexadecimal digits of cpu current eip (ignored in SMP configuration)
+-#   %e : 1 character event type ('i'nfo, 'd'ebug, 'p'anic, 'e'rror)
+-#   %d : 5 characters string of the device, between brackets
+-# 
+-# Default : %t%e%d
+-# Examples:
+-#   logprefix: %t-%e-@%i-%d
+-#   logprefix: %i%e%d
+-#=======================================================================
+-#logprefix: %t%e%d
+-
+-#=======================================================================
+-# LOG CONTROLS
+-#
+-# Bochs now has four severity levels for event logging.
+-#   panic: cannot proceed.  If you choose to continue after a panic, 
+-#          don't be surprised if you get strange behavior or crashes.
+-#   error: something went wrong, but it is probably safe to continue the
+-#          simulation.
+-#   info: interesting or useful messages.
+-#   debug: messages useful only when debugging the code.  This may
+-#          spit out thousands per second.
+-#
+-# For events of each level, you can choose to crash, report, or ignore.
+-# TODO: allow choice based on the facility: e.g. crash on panics from
+-#       everything except the cdrom, and only report those.
+-#
+-# If you are experiencing many panics, it can be helpful to change
+-# the panic action to report instead of fatal.  However, be aware
+-# that anything executed after a panic is uncharted territory and can 
+-# cause bochs to become unstable.  The panic is a "graceful exit," so
+-# if you disable it you may get a spectacular disaster instead.
+-#=======================================================================
+-panic: action=ask
+-error: action=report
+-info: action=report
+-debug: action=ignore
+-#pass: action=fatal
+-
+-#=======================================================================
+-# DEBUGGER_LOG:
+-# Give the path of the log file you'd like Bochs to log debugger output.
+-# If you really don't want it, make it /dev/null or '-'. :^(
+-#
+-# Examples:
+-#   debugger_log: ./debugger.out
+-#=======================================================================
+-#debugger_log: /dev/null
+-#debugger_log: debugger.out
+-debugger_log: -
+-
+-#=======================================================================
+-# COM1, COM2, COM3, COM4:
+-# This defines a serial port (UART type 16550A). In the 'term' you can specify
+-# a device to use as com1. This can be a real serial line, or a pty.  To use
+-# a pty (under X/Unix), create two windows (xterms, usually).  One of them will
+-# run bochs, and the other will act as com1. Find out the tty the com1
+-# window using the `tty' command, and use that as the `dev' parameter.
+-# Then do `sleep 1000000' in the com1 window to keep the shell from
+-# messing with things, and run bochs in the other window.  Serial I/O to
+-# com1 (port 0x3f8) will all go to the other window.
+-# Other serial modes are 'null' (no input/output), 'file' (output to a file
+-# specified as the 'dev' parameter), 'raw' (use the real serial port - under
+-# construction for win32), 'mouse' (standard serial mouse - requires
+-# mouse option setting 'type=serial' or 'type=serial_wheel') and 'socket'
+-# (connect a networking socket).
+-#
+-# Examples:
+-#   com1: enabled=1, mode=null
+-#   com1: enabled=1, mode=mouse
+-#   com2: enabled=1, mode=file, dev=serial.out
+-#   com3: enabled=1, mode=raw, dev=com1
+-#   com3: enabled=1, mode=socket, dev=localhost:8888
+-#=======================================================================
+-#com1: enabled=1, mode=term, dev=/dev/ttyp9
+-
+-
+-#=======================================================================
+-# PARPORT1, PARPORT2:
+-# This defines a parallel (printer) port. When turned on and an output file is
+-# defined the emulated printer port sends characters printed by the guest OS
+-# into the output file. On some platforms a device filename can be used to
+-# send the data to the real parallel port (e.g. "/dev/lp0" on Linux, "lpt1" on
+-# win32 platforms).
+-#
+-# Examples:
+-#   parport1: enabled=1, file="parport.out"
+-#   parport2: enabled=1, file="/dev/lp0"
+-#   parport1: enabled=0
+-#=======================================================================
+-parport1: enabled=1, file="/dev/stdout"
+-
+-#=======================================================================
+-# SB16:
+-# This defines the SB16 sound emulation. It can have several of the
+-# following properties.
+-# All properties are in the format sb16: property=value
+-# midi: The filename is where the midi data is sent. This can be a
+-#       device or just a file if you want to record the midi data.
+-# midimode:
+-#      0=no data
+-#      1=output to device (system dependent. midi denotes the device driver)
+-#      2=SMF file output, including headers
+-#      3=output the midi data stream to the file (no midi headers and no
+-#        delta times, just command and data bytes)
+-# wave: This is the device/file where wave output is stored
+-# wavemode:
+-#      0=no data
+-#      1=output to device (system dependent. wave denotes the device driver)
+-#      2=VOC file output, incl. headers
+-#      3=output the raw wave stream to the file
+-# log:  The file to write the sb16 emulator messages to.
+-# loglevel:
+-#      0=no log
+-#      1=resource changes, midi program and bank changes
+-#      2=severe errors
+-#      3=all errors
+-#      4=all errors plus all port accesses
+-#      5=all errors and port accesses plus a lot of extra info
+-# dmatimer:
+-#      microseconds per second for a DMA cycle.  Make it smaller to fix
+-#      non-continuous sound.  750000 is usually a good value.  This needs a
+-#      reasonably correct setting for the IPS parameter of the CPU option.
+-#
+-# For an example look at the next line:
+-#=======================================================================
+-
+-#sb16: midimode=1, midi=/dev/midi00, wavemode=1, wave=/dev/dsp, loglevel=2, log=sb16.log, dmatimer=600000
+-
+-#=======================================================================
+-# VGA_UPDATE_INTERVAL:
+-# Video memory is scanned for updates and screen updated every so many
+-# virtual seconds.  The default is 40000, about 25Hz. Keep in mind that
+-# you must tweak the 'cpu: ips=N' directive to be as close to the number
+-# of emulated instructions-per-second your workstation can do, for this
+-# to be accurate.
+-#
+-# Examples:
+-#   vga_update_interval: 250000
+-#=======================================================================
+-vga_update_interval: 300000
+-
+-# using for Winstone '98 tests
+-#vga_update_interval:  100000
+-
+-#=======================================================================
+-# KEYBOARD_SERIAL_DELAY:
+-# Approximate time in microseconds that it takes one character to
+-# be transfered from the keyboard to controller over the serial path.
+-# Examples:
+-#   keyboard_serial_delay: 200
+-#=======================================================================
+-keyboard_serial_delay: 250
+-
+-#=======================================================================
+-# KEYBOARD_PASTE_DELAY:
+-# Approximate time in microseconds between attempts to paste
+-# characters to the keyboard controller. This leaves time for the
+-# guest os to deal with the flow of characters.  The ideal setting
+-# depends on how your operating system processes characters.  The
+-# default of 100000 usec (.1 seconds) was chosen because it works 
+-# consistently in Windows.
+-#
+-# If your OS is losing characters during a paste, increase the paste
+-# delay until it stops losing characters.
+-#
+-# Examples:
+-#   keyboard_paste_delay: 100000
+-#=======================================================================
+-keyboard_paste_delay: 100000
+-
+-#=======================================================================
+-# MOUSE: 
+-# This option prevents Bochs from creating mouse "events" unless a mouse
+-# is  enabled. The hardware emulation itself is not disabled by this.
+-# You can turn the mouse on by setting enabled to 1, or turn it off by
+-# setting enabled to 0. Unless you have a particular reason for enabling
+-# the mouse by default, it is recommended that you leave it off.
+-# You can also toggle the mouse usage at runtime (control key + middle
+-# mouse button on X11, SDL, wxWidgets and Win32).
+-# With the mouse type option you can select the type of mouse to emulate.
+-# The default value is 'ps2'. The other choices are 'imps2' (wheel mouse
+-# on PS/2), 'serial', 'serial_wheel' (one com port requires setting
+-# 'mode=mouse') and 'usb' (3-button mouse - one of the USB ports must be
+-# connected with the 'mouse' device - requires PCI and USB support).
+-#
+-# Examples:
+-#   mouse: enabled=1
+-#   mouse: enabled=1, type=imps2
+-#   mouse: enabled=1, type=serial
+-#   mouse: enabled=0
+-#=======================================================================
+-mouse: enabled=0
+-
+-#=======================================================================
+-# private_colormap: Request that the GUI create and use it's own
+-#                   non-shared colormap.  This colormap will be used
+-#                   when in the bochs window.  If not enabled, a
+-#                   shared colormap scheme may be used.  Not implemented
+-#                   on all GUI's.
+-#
+-# Examples:
+-#   private_colormap: enabled=1
+-#   private_colormap: enabled=0
+-#=======================================================================
+-private_colormap: enabled=0
+-
+-#=======================================================================
+-# fullscreen: ONLY IMPLEMENTED ON AMIGA
+-#             Request that Bochs occupy the entire screen instead of a 
+-#             window.
+-#
+-# Examples:
+-#   fullscreen: enabled=0
+-#   fullscreen: enabled=1
+-#=======================================================================
+-#fullscreen: enabled=0
+-#screenmode: name="sample"
+-
+-#=======================================================================
+-# ne2k: NE2000 compatible ethernet adapter
+-#
+-# Examples:
+-# ne2k: ioaddr=IOADDR, irq=IRQ, mac=MACADDR, ethmod=MODULE, ethdev=DEVICE, script=SCRIPT
+-#
+-# ioaddr, irq: You probably won't need to change ioaddr and irq, unless there
+-# are IRQ conflicts.
+-#
+-# mac: The MAC address MUST NOT match the address of any machine on the net.
+-# Also, the first byte must be an even number (bit 0 set means a multicast
+-# address), and you cannot use ff:ff:ff:ff:ff:ff because that's the broadcast
+-# address.  For the ethertap module, you must use fe:fd:00:00:00:01.  There may
+-# be other restrictions too.  To be safe, just use the b0:c4... address.
+-#
+-# ethdev: The ethdev value is the name of the network interface on your host
+-# platform.  On UNIX machines, you can get the name by running ifconfig.  On
+-# Windows machines, you must run niclist to get the name of the ethdev.
+-# Niclist source code is in misc/niclist.c and it is included in Windows 
+-# binary releases.
+-#
+-# script: The script value is optional, and is the name of a script that 
+-# is executed after bochs initialize the network interface. You can use 
+-# this script to configure this network interface, or enable masquerading.
+-# This is mainly useful for the tun/tap devices that only exist during
+-# Bochs execution. The network interface name is supplied to the script
+-# as first parameter
+-#
+-# If you don't want to make connections to any physical networks,
+-# you can use the following 'ethmod's to simulate a virtual network.
+-#   null: All packets are discarded, but logged to a few files.
+-#   arpback: ARP is simulated. Disabled by default.
+-#   vde:  Virtual Distributed Ethernet
+-#   vnet: ARP, ICMP-echo(ping), DHCP and read/write TFTP are simulated.
+-#         The virtual host uses 192.168.10.1.
+-#         DHCP assigns 192.168.10.2 to the guest.
+-#         TFTP uses the ethdev value for the root directory and doesn't
+-#         overwrite files.
+-#
+-#=======================================================================
+-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=fbsd, ethdev=en0 #macosx
+-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=fbsd, ethdev=xl0
+-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=linux, ethdev=eth0
+-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=win32, ethdev=MYCARD
+-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tap, ethdev=tap0
+-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tuntap, ethdev=/dev/net/tun0, script=./tunconfig
+-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=null, ethdev=eth0
+-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vde, ethdev="/tmp/vde.ctl"
+-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vnet, ethdev="c:/temp"
+-
+-#=======================================================================
+-# KEYBOARD_MAPPING:
+-# This enables a remap of a physical localized keyboard to a 
+-# virtualized us keyboard, as the PC architecture expects.
+-# If enabled, the keymap file must be specified.
+-# 
+-# Examples:
+-#   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
+-#=======================================================================
+-keyboard_mapping: enabled=0, map=
+-
+-#=======================================================================
+-# KEYBOARD_TYPE:
+-# Type of keyboard return by a "identify keyboard" command to the
+-# keyboard controler. It must be one of "xt", "at" or "mf".
+-# Defaults to "mf". It should be ok for almost everybody. A known
+-# exception is french macs, that do have a "at"-like keyboard.
+-#
+-# Examples:
+-#   keyboard_type: mf
+-#=======================================================================
+-#keyboard_type: mf
+-
+-#=======================================================================
+-# USER_SHORTCUT:
+-# This defines the keyboard shortcut to be sent when you press the "user"
+-# button in the headerbar. The shortcut string is a combination of maximum
+-# 3 key names (listed below) separated with a '-' character. The old-style
+-# syntax (without the '-') still works for the key combinations supported
+-# in Bochs 2.2.1.
+-# Valid key names:
+-# "alt", "bksl", "bksp", "ctrl", "del", "down", "end", "enter", "esc",
+-# "f1", ... "f12", "home", "ins", "left", "menu", "minus", "pgdwn", "pgup",
+-# "plus", "right", "shift", "space", "tab", "up", and "win".
+-#
+-# Example:
+-#   user_shortcut: keys=ctrl-alt-del
+-#=======================================================================
+-#user_shortcut: keys=ctrl-alt-del
+-
+-#=======================================================================
+-# I440FXSUPPORT:
+-# This option controls the presence of the i440FX PCI chipset. You can
+-# also specify the devices connected to PCI slots. Up to 5 slots are
+-# available now. These devices are currently supported: ne2k, pcivga,
+-# pcidev and pcipnic. If Bochs is compiled with Cirrus SVGA support
+-# you'll have the additional choice 'cirrus'.
+-#
+-# Example:
+-#   i440fxsupport: enabled=1, slot1=pcivga, slot2=ne2k
+-#=======================================================================
+-#i440fxsupport: enabled=1
+-
+-#=======================================================================
+-# USB1:
+-# This option controls the presence of the USB root hub which is a part
+-# of the i440FX PCI chipset. With the portX option you can connect devices
+-# to the hub (currently supported: 'mouse' and 'keypad'). If you connect
+-# the mouse to one of the ports and use the mouse option 'type=usb' you'll
+-# have a 3-button USB mouse.
+-#
+-# Example:
+-#   usb1: enabled=1, port1=mouse, port2=keypad
+-#=======================================================================
+-#usb1: enabled=1
+-
+-#=======================================================================
+-# CMOSIMAGE:
+-# This defines image file that can be loaded into the CMOS RAM at startup.
+-# The rtc_init parameter controls whether initialize the RTC with values stored
+-# in the image. By default the time0 argument given to the clock option is used.
+-# With 'rtc_init=image' the image is the source for the initial time.
+-#
+-# Example:
+-#   cmosimage: file=cmos.img, rtc_init=image
+-#=======================================================================
+-#cmosimage: file=cmos.img, rtc_init=time0
+-
+-#=======================================================================
+-# other stuff
+-#=======================================================================
+-#magic_break: enabled=1
+-#load32bitOSImage: os=nullkernel, path=../kernel.img, iolog=../vga_io.log
+-#load32bitOSImage: os=linux, path=../linux.img, iolog=../vga_io.log, initrd=../initrd.img
+-#text_snapshot_check: enable
+-
+-#-------------------------
+-# PCI host device mapping
+-#-------------------------
+-#pcidev: vendor=0x1234, device=0x5678
+-
+-#=======================================================================
+-# GDBSTUB:
+-# Enable GDB stub. See user documentation for details.
+-# Default value is enabled=0.
+-#=======================================================================
+-#gdbstub: enabled=0, port=1234, text_base=0, data_base=0, bss_base=0
+-
+-#=======================================================================
+-# IPS:
+-# The IPS directive is DEPRECATED. Use the parameter IPS of the CPU
+-# directive instead.
+-#=======================================================================
+-#ips: 10000000
+-
+-#=======================================================================
+-# for Macintosh, use the style of pathnames in the following
+-# examples.
+-#
+-# vgaromimage: :bios:VGABIOS-elpin-2.40
+-# romimage: file=:bios:BIOS-bochs-latest, address=0xf0000
+-# floppya: 1_44=[fd:], status=inserted
+-#=======================================================================
+diff --git a/echo.c b/echo.c
+deleted file mode 100644
+index eed68a0..0000000
+--- a/echo.c
++++ /dev/null
+@@ -1,13 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int i;
+-
+-  for(i = 1; i < argc; i++)
+-    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+-  exit(0);
+-}
+diff --git a/elf.h b/elf.h
+deleted file mode 100644
+index d16c967..0000000
+--- a/elf.h
++++ /dev/null
+@@ -1,42 +0,0 @@
+-// Format of an ELF executable file
+-
+-#define ELF_MAGIC 0x464C457FU  // "\x7FELF" in little endian
+-
+-// File header
+-struct elfhdr {
+-  uint magic;  // must equal ELF_MAGIC
+-  uchar elf[12];
+-  ushort type;
+-  ushort machine;
+-  uint version;
+-  uint entry;
+-  uint phoff;
+-  uint shoff;
+-  uint flags;
+-  ushort ehsize;
+-  ushort phentsize;
+-  ushort phnum;
+-  ushort shentsize;
+-  ushort shnum;
+-  ushort shstrndx;
+-};
+-
+-// Program section header
+-struct proghdr {
+-  uint type;
+-  uint off;
+-  uint vaddr;
+-  uint paddr;
+-  uint filesz;
+-  uint memsz;
+-  uint flags;
+-  uint align;
+-};
+-
+-// Values for Proghdr type
+-#define ELF_PROG_LOAD           1
+-
+-// Flag bits for Proghdr flags
+-#define ELF_PROG_FLAG_EXEC      1
+-#define ELF_PROG_FLAG_WRITE     2
+-#define ELF_PROG_FLAG_READ      4
+diff --git a/entry.S b/entry.S
+deleted file mode 100644
+index bc79bab..0000000
+--- a/entry.S
++++ /dev/null
+@@ -1,68 +0,0 @@
+-# The xv6 kernel starts executing in this file. This file is linked with
+-# the kernel C code, so it can refer to kernel symbols such as main().
+-# The boot block (bootasm.S and bootmain.c) jumps to entry below.
+-        
+-# Multiboot header, for multiboot boot loaders like GNU Grub.
+-# http://www.gnu.org/software/grub/manual/multiboot/multiboot.html
+-#
+-# Using GRUB 2, you can boot xv6 from a file stored in a
+-# Linux file system by copying kernel or kernelmemfs to /boot
+-# and then adding this menu entry:
+-#
+-# menuentry "xv6" {
+-# 	insmod ext2
+-# 	set root='(hd0,msdos1)'
+-# 	set kernel='/boot/kernel'
+-# 	echo "Loading ${kernel}..."
+-# 	multiboot ${kernel} ${kernel}
+-# 	boot
+-# }
+-
+-#include "asm.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "param.h"
+-
+-# Multiboot header.  Data to direct multiboot loader.
+-.p2align 2
+-.text
+-.globl multiboot_header
+-multiboot_header:
+-  #define magic 0x1badb002
+-  #define flags 0
+-  .long magic
+-  .long flags
+-  .long (-magic-flags)
+-
+-# By convention, the _start symbol specifies the ELF entry point.
+-# Since we haven't set up virtual memory yet, our entry point is
+-# the physical address of 'entry'.
+-.globl _start
+-_start = V2P_WO(entry)
+-
+-# Entering xv6 on boot processor, with paging off.
+-.globl entry
+-entry:
+-  # Turn on page size extension for 4Mbyte pages
+-  movl    %cr4, %eax
+-  orl     $(CR4_PSE), %eax
+-  movl    %eax, %cr4
+-  # Set page directory
+-  movl    $(V2P_WO(entrypgdir)), %eax
+-  movl    %eax, %cr3
+-  # Turn on paging.
+-  movl    %cr0, %eax
+-  orl     $(CR0_PG|CR0_WP), %eax
+-  movl    %eax, %cr0
+-
+-  # Set up the stack pointer.
+-  movl $(stack + KSTACKSIZE), %esp
+-
+-  # Jump to main(), and switch to executing at
+-  # high addresses. The indirect call is needed because
+-  # the assembler produces a PC-relative instruction
+-  # for a direct jump.
+-  mov $main, %eax
+-  jmp *%eax
+-
+-.comm stack, KSTACKSIZE
+diff --git a/entryother.S b/entryother.S
+deleted file mode 100644
+index a3b6dc2..0000000
+--- a/entryother.S
++++ /dev/null
+@@ -1,93 +0,0 @@
+-#include "asm.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-	
+-# Each non-boot CPU ("AP") is started up in response to a STARTUP
+-# IPI from the boot CPU.  Section B.4.2 of the Multi-Processor
+-# Specification says that the AP will start in real mode with CS:IP
+-# set to XY00:0000, where XY is an 8-bit value sent with the
+-# STARTUP. Thus this code must start at a 4096-byte boundary.
+-#
+-# Because this code sets DS to zero, it must sit
+-# at an address in the low 2^16 bytes.
+-#
+-# Startothers (in main.c) sends the STARTUPs one at a time.
+-# It copies this code (start) at 0x7000.  It puts the address of
+-# a newly allocated per-core stack in start-4,the address of the
+-# place to jump to (mpenter) in start-8, and the physical address
+-# of entrypgdir in start-12.
+-#
+-# This code combines elements of bootasm.S and entry.S.
+-
+-.code16           
+-.globl start
+-start:
+-  cli            
+-
+-  # Zero data segment registers DS, ES, and SS.
+-  xorw    %ax,%ax
+-  movw    %ax,%ds
+-  movw    %ax,%es
+-  movw    %ax,%ss
+-
+-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+-  # virtual addresses map directly to physical addresses so that the
+-  # effective memory map doesn't change during the transition.
+-  lgdt    gdtdesc
+-  movl    %cr0, %eax
+-  orl     $CR0_PE, %eax
+-  movl    %eax, %cr0
+-
+-  # Complete the transition to 32-bit protected mode by using a long jmp
+-  # to reload %cs and %eip.  The segment descriptors are set up with no
+-  # translation, so that the mapping is still the identity mapping.
+-  ljmpl    $(SEG_KCODE<<3), $(start32)
+-
+-//PAGEBREAK!
+-.code32  # Tell assembler to generate 32-bit code now.
+-start32:
+-  # Set up the protected-mode data segment registers
+-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+-  movw    %ax, %ds                # -> DS: Data Segment
+-  movw    %ax, %es                # -> ES: Extra Segment
+-  movw    %ax, %ss                # -> SS: Stack Segment
+-  movw    $0, %ax                 # Zero segments not ready for use
+-  movw    %ax, %fs                # -> FS
+-  movw    %ax, %gs                # -> GS
+-
+-  # Turn on page size extension for 4Mbyte pages
+-  movl    %cr4, %eax
+-  orl     $(CR4_PSE), %eax
+-  movl    %eax, %cr4
+-  # Use entrypgdir as our initial page table
+-  movl    (start-12), %eax
+-  movl    %eax, %cr3
+-  # Turn on paging.
+-  movl    %cr0, %eax
+-  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
+-  movl    %eax, %cr0
+-
+-  # Switch to the stack allocated by startothers()
+-  movl    (start-4), %esp
+-  # Call mpenter()
+-  call	 *(start-8)
+-
+-  movw    $0x8a00, %ax
+-  movw    %ax, %dx
+-  outw    %ax, %dx
+-  movw    $0x8ae0, %ax
+-  outw    %ax, %dx
+-spin:
+-  jmp     spin
+-
+-.p2align 2
+-gdt:
+-  SEG_NULLASM
+-  SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
+-  SEG_ASM(STA_W, 0, 0xffffffff)
+-
+-
+-gdtdesc:
+-  .word   (gdtdesc - gdt - 1)
+-  .long   gdt
+-
+diff --git a/exec.c b/exec.c
+deleted file mode 100644
+index b40134f..0000000
+--- a/exec.c
++++ /dev/null
+@@ -1,114 +0,0 @@
+-#include "types.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "defs.h"
+-#include "x86.h"
+-#include "elf.h"
+-
+-int
+-exec(char *path, char **argv)
+-{
+-  char *s, *last;
+-  int i, off;
+-  uint argc, sz, sp, ustack[3+MAXARG+1];
+-  struct elfhdr elf;
+-  struct inode *ip;
+-  struct proghdr ph;
+-  pde_t *pgdir, *oldpgdir;
+-  struct proc *curproc = myproc();
+-
+-  begin_op();
+-
+-  if((ip = namei(path)) == 0){
+-    end_op();
+-    cprintf("exec: fail\n");
+-    return -1;
+-  }
+-  ilock(ip);
+-  pgdir = 0;
+-
+-  // Check ELF header
+-  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
+-    goto bad;
+-  if(elf.magic != ELF_MAGIC)
+-    goto bad;
+-
+-  if((pgdir = setupkvm()) == 0)
+-    goto bad;
+-
+-  // Load program into memory.
+-  sz = 0;
+-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+-    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
+-      goto bad;
+-    if(ph.type != ELF_PROG_LOAD)
+-      continue;
+-    if(ph.memsz < ph.filesz)
+-      goto bad;
+-    if(ph.vaddr + ph.memsz < ph.vaddr)
+-      goto bad;
+-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+-      goto bad;
+-    if(ph.vaddr % PGSIZE != 0)
+-      goto bad;
+-    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+-      goto bad;
+-  }
+-  iunlockput(ip);
+-  end_op();
+-  ip = 0;
+-
+-  // Allocate two pages at the next page boundary.
+-  // Make the first inaccessible.  Use the second as the user stack.
+-  sz = PGROUNDUP(sz);
+-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+-    goto bad;
+-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+-  sp = sz;
+-
+-  // Push argument strings, prepare rest of stack in ustack.
+-  for(argc = 0; argv[argc]; argc++) {
+-    if(argc >= MAXARG)
+-      goto bad;
+-    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+-    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+-      goto bad;
+-    ustack[3+argc] = sp;
+-  }
+-  ustack[3+argc] = 0;
+-
+-  ustack[0] = 0xffffffff;  // fake return PC
+-  ustack[1] = argc;
+-  ustack[2] = sp - (argc+1)*4;  // argv pointer
+-
+-  sp -= (3+argc+1) * 4;
+-  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+-    goto bad;
+-
+-  // Save program name for debugging.
+-  for(last=s=path; *s; s++)
+-    if(*s == '/')
+-      last = s+1;
+-  safestrcpy(curproc->name, last, sizeof(curproc->name));
+-
+-  // Commit to the user image.
+-  oldpgdir = curproc->pgdir;
+-  curproc->pgdir = pgdir;
+-  curproc->sz = sz;
+-  curproc->tf->eip = elf.entry;  // main
+-  curproc->tf->esp = sp;
+-  switchuvm(curproc);
+-  freevm(oldpgdir);
+-  return 0;
+-
+- bad:
+-  if(pgdir)
+-    freevm(pgdir);
+-  if(ip){
+-    iunlockput(ip);
+-    end_op();
+-  }
+-  return -1;
+-}
+diff --git a/fcntl.h b/fcntl.h
+deleted file mode 100644
+index d565483..0000000
+--- a/fcntl.h
++++ /dev/null
+@@ -1,4 +0,0 @@
+-#define O_RDONLY  0x000
+-#define O_WRONLY  0x001
+-#define O_RDWR    0x002
+-#define O_CREATE  0x200
+diff --git a/file.c b/file.c
+deleted file mode 100644
+index 24b32c2..0000000
+--- a/file.c
++++ /dev/null
+@@ -1,157 +0,0 @@
+-//
+-// File descriptors
+-//
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "fs.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "file.h"
+-
+-struct devsw devsw[NDEV];
+-struct {
+-  struct spinlock lock;
+-  struct file file[NFILE];
+-} ftable;
+-
+-void
+-fileinit(void)
+-{
+-  initlock(&ftable.lock, "ftable");
+-}
+-
+-// Allocate a file structure.
+-struct file*
+-filealloc(void)
+-{
+-  struct file *f;
+-
+-  acquire(&ftable.lock);
+-  for(f = ftable.file; f < ftable.file + NFILE; f++){
+-    if(f->ref == 0){
+-      f->ref = 1;
+-      release(&ftable.lock);
+-      return f;
+-    }
+-  }
+-  release(&ftable.lock);
+-  return 0;
+-}
+-
+-// Increment ref count for file f.
+-struct file*
+-filedup(struct file *f)
+-{
+-  acquire(&ftable.lock);
+-  if(f->ref < 1)
+-    panic("filedup");
+-  f->ref++;
+-  release(&ftable.lock);
+-  return f;
+-}
+-
+-// Close file f.  (Decrement ref count, close when reaches 0.)
+-void
+-fileclose(struct file *f)
+-{
+-  struct file ff;
+-
+-  acquire(&ftable.lock);
+-  if(f->ref < 1)
+-    panic("fileclose");
+-  if(--f->ref > 0){
+-    release(&ftable.lock);
+-    return;
+-  }
+-  ff = *f;
+-  f->ref = 0;
+-  f->type = FD_NONE;
+-  release(&ftable.lock);
+-
+-  if(ff.type == FD_PIPE)
+-    pipeclose(ff.pipe, ff.writable);
+-  else if(ff.type == FD_INODE){
+-    begin_op();
+-    iput(ff.ip);
+-    end_op();
+-  }
+-}
+-
+-// Get metadata about file f.
+-int
+-filestat(struct file *f, struct stat *st)
+-{
+-  if(f->type == FD_INODE){
+-    ilock(f->ip);
+-    stati(f->ip, st);
+-    iunlock(f->ip);
+-    return 0;
+-  }
+-  return -1;
+-}
+-
+-// Read from file f.
+-int
+-fileread(struct file *f, char *addr, int n)
+-{
+-  int r;
+-
+-  if(f->readable == 0)
+-    return -1;
+-  if(f->type == FD_PIPE)
+-    return piperead(f->pipe, addr, n);
+-  if(f->type == FD_INODE){
+-    ilock(f->ip);
+-    if((r = readi(f->ip, addr, f->off, n)) > 0)
+-      f->off += r;
+-    iunlock(f->ip);
+-    return r;
+-  }
+-  panic("fileread");
+-}
+-
+-//PAGEBREAK!
+-// Write to file f.
+-int
+-filewrite(struct file *f, char *addr, int n)
+-{
+-  int r;
+-
+-  if(f->writable == 0)
+-    return -1;
+-  if(f->type == FD_PIPE)
+-    return pipewrite(f->pipe, addr, n);
+-  if(f->type == FD_INODE){
+-    // write a few blocks at a time to avoid exceeding
+-    // the maximum log transaction size, including
+-    // i-node, indirect block, allocation blocks,
+-    // and 2 blocks of slop for non-aligned writes.
+-    // this really belongs lower down, since writei()
+-    // might be writing a device like the console.
+-    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
+-    int i = 0;
+-    while(i < n){
+-      int n1 = n - i;
+-      if(n1 > max)
+-        n1 = max;
+-
+-      begin_op();
+-      ilock(f->ip);
+-      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+-        f->off += r;
+-      iunlock(f->ip);
+-      end_op();
+-
+-      if(r < 0)
+-        break;
+-      if(r != n1)
+-        panic("short filewrite");
+-      i += r;
+-    }
+-    return i == n ? n : -1;
+-  }
+-  panic("filewrite");
+-}
+-
+diff --git a/file.h b/file.h
+deleted file mode 100644
+index 0990c82..0000000
+--- a/file.h
++++ /dev/null
+@@ -1,37 +0,0 @@
+-struct file {
+-  enum { FD_NONE, FD_PIPE, FD_INODE } type;
+-  int ref; // reference count
+-  char readable;
+-  char writable;
+-  struct pipe *pipe;
+-  struct inode *ip;
+-  uint off;
+-};
+-
+-
+-// in-memory copy of an inode
+-struct inode {
+-  uint dev;           // Device number
+-  uint inum;          // Inode number
+-  int ref;            // Reference count
+-  struct sleeplock lock; // protects everything below here
+-  int valid;          // inode has been read from disk?
+-
+-  short type;         // copy of disk inode
+-  short major;
+-  short minor;
+-  short nlink;
+-  uint size;
+-  uint addrs[NDIRECT+1];
+-};
+-
+-// table mapping major device number to
+-// device functions
+-struct devsw {
+-  int (*read)(struct inode*, char*, int);
+-  int (*write)(struct inode*, char*, int);
+-};
+-
+-extern struct devsw devsw[];
+-
+-#define CONSOLE 1
+diff --git a/forktest.c b/forktest.c
+deleted file mode 100644
+index a4b35ed..0000000
+--- a/forktest.c
++++ /dev/null
+@@ -1,56 +0,0 @@
+-// Test that fork fails gracefully.
+-// Tiny executable so that the limit can be filling the proc table.
+-
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-#define N  1000
+-
+-void
+-printf(int fd, const char *s, ...)
+-{
+-  write(fd, s, strlen(s));
+-}
+-
+-void
+-forktest(void)
+-{
+-  int n, pid;
+-
+-  printf(1, "fork test\n");
+-
+-  for(n=0; n<N; n++){
+-    pid = fork();
+-    if(pid < 0)
+-      break;
+-    if(pid == 0)
+-      exit(4);
+-  }
+-
+-  if(n == N){
+-    printf(1, "fork claimed to work N times!\n", N);
+-    exit(3);
+-  }
+-
+-  for(; n > 0; n--){
+-    if(wait(NULL) < 0){
+-      printf(1, "wait stopped early\n");
+-      exit(2);
+-    }
+-  }
+-
+-  if(wait(NULL) != -1){
+-    printf(1, "wait got too many\n");
+-    exit(1);
+-  }
+-
+-  printf(1, "fork test OK\n");
+-}
+-
+-int
+-main(void)
+-{
+-  forktest();
+-  exit(0);
+-}
+diff --git a/fs.c b/fs.c
+deleted file mode 100644
+index f77275f..0000000
+--- a/fs.c
++++ /dev/null
+@@ -1,670 +0,0 @@
+-// File system implementation.  Five layers:
+-//   + Blocks: allocator for raw disk blocks.
+-//   + Log: crash recovery for multi-step updates.
+-//   + Files: inode allocator, reading, writing, metadata.
+-//   + Directories: inode with special contents (list of other inodes!)
+-//   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
+-//
+-// This file contains the low-level file system manipulation
+-// routines.  The (higher-level) system call implementations
+-// are in sysfile.c.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "stat.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "buf.h"
+-#include "file.h"
+-
+-#define min(a, b) ((a) < (b) ? (a) : (b))
+-static void itrunc(struct inode*);
+-// there should be one superblock per disk device, but we run with
+-// only one device
+-struct superblock sb; 
+-
+-// Read the super block.
+-void
+-readsb(int dev, struct superblock *sb)
+-{
+-  struct buf *bp;
+-
+-  bp = bread(dev, 1);
+-  memmove(sb, bp->data, sizeof(*sb));
+-  brelse(bp);
+-}
+-
+-// Zero a block.
+-static void
+-bzero(int dev, int bno)
+-{
+-  struct buf *bp;
+-
+-  bp = bread(dev, bno);
+-  memset(bp->data, 0, BSIZE);
+-  log_write(bp);
+-  brelse(bp);
+-}
+-
+-// Blocks.
+-
+-// Allocate a zeroed disk block.
+-static uint
+-balloc(uint dev)
+-{
+-  int b, bi, m;
+-  struct buf *bp;
+-
+-  bp = 0;
+-  for(b = 0; b < sb.size; b += BPB){
+-    bp = bread(dev, BBLOCK(b, sb));
+-    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+-      m = 1 << (bi % 8);
+-      if((bp->data[bi/8] & m) == 0){  // Is block free?
+-        bp->data[bi/8] |= m;  // Mark block in use.
+-        log_write(bp);
+-        brelse(bp);
+-        bzero(dev, b + bi);
+-        return b + bi;
+-      }
+-    }
+-    brelse(bp);
+-  }
+-  panic("balloc: out of blocks");
+-}
+-
+-// Free a disk block.
+-static void
+-bfree(int dev, uint b)
+-{
+-  struct buf *bp;
+-  int bi, m;
+-
+-  bp = bread(dev, BBLOCK(b, sb));
+-  bi = b % BPB;
+-  m = 1 << (bi % 8);
+-  if((bp->data[bi/8] & m) == 0)
+-    panic("freeing free block");
+-  bp->data[bi/8] &= ~m;
+-  log_write(bp);
+-  brelse(bp);
+-}
+-
+-// Inodes.
+-//
+-// An inode describes a single unnamed file.
+-// The inode disk structure holds metadata: the file's type,
+-// its size, the number of links referring to it, and the
+-// list of blocks holding the file's content.
+-//
+-// The inodes are laid out sequentially on disk at
+-// sb.startinode. Each inode has a number, indicating its
+-// position on the disk.
+-//
+-// The kernel keeps a cache of in-use inodes in memory
+-// to provide a place for synchronizing access
+-// to inodes used by multiple processes. The cached
+-// inodes include book-keeping information that is
+-// not stored on disk: ip->ref and ip->valid.
+-//
+-// An inode and its in-memory representation go through a
+-// sequence of states before they can be used by the
+-// rest of the file system code.
+-//
+-// * Allocation: an inode is allocated if its type (on disk)
+-//   is non-zero. ialloc() allocates, and iput() frees if
+-//   the reference and link counts have fallen to zero.
+-//
+-// * Referencing in cache: an entry in the inode cache
+-//   is free if ip->ref is zero. Otherwise ip->ref tracks
+-//   the number of in-memory pointers to the entry (open
+-//   files and current directories). iget() finds or
+-//   creates a cache entry and increments its ref; iput()
+-//   decrements ref.
+-//
+-// * Valid: the information (type, size, &c) in an inode
+-//   cache entry is only correct when ip->valid is 1.
+-//   ilock() reads the inode from
+-//   the disk and sets ip->valid, while iput() clears
+-//   ip->valid if ip->ref has fallen to zero.
+-//
+-// * Locked: file system code may only examine and modify
+-//   the information in an inode and its content if it
+-//   has first locked the inode.
+-//
+-// Thus a typical sequence is:
+-//   ip = iget(dev, inum)
+-//   ilock(ip)
+-//   ... examine and modify ip->xxx ...
+-//   iunlock(ip)
+-//   iput(ip)
+-//
+-// ilock() is separate from iget() so that system calls can
+-// get a long-term reference to an inode (as for an open file)
+-// and only lock it for short periods (e.g., in read()).
+-// The separation also helps avoid deadlock and races during
+-// pathname lookup. iget() increments ip->ref so that the inode
+-// stays cached and pointers to it remain valid.
+-//
+-// Many internal file system functions expect the caller to
+-// have locked the inodes involved; this lets callers create
+-// multi-step atomic operations.
+-//
+-// The icache.lock spin-lock protects the allocation of icache
+-// entries. Since ip->ref indicates whether an entry is free,
+-// and ip->dev and ip->inum indicate which i-node an entry
+-// holds, one must hold icache.lock while using any of those fields.
+-//
+-// An ip->lock sleep-lock protects all ip-> fields other than ref,
+-// dev, and inum.  One must hold ip->lock in order to
+-// read or write that inode's ip->valid, ip->size, ip->type, &c.
+-
+-struct {
+-  struct spinlock lock;
+-  struct inode inode[NINODE];
+-} icache;
+-
+-void
+-iinit(int dev)
+-{
+-  int i = 0;
+-  
+-  initlock(&icache.lock, "icache");
+-  for(i = 0; i < NINODE; i++) {
+-    initsleeplock(&icache.inode[i].lock, "inode");
+-  }
+-
+-  readsb(dev, &sb);
+-  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
+- inodestart %d bmap start %d\n", sb.size, sb.nblocks,
+-          sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
+-          sb.bmapstart);
+-}
+-
+-static struct inode* iget(uint dev, uint inum);
+-
+-//PAGEBREAK!
+-// Allocate an inode on device dev.
+-// Mark it as allocated by  giving it type type.
+-// Returns an unlocked but allocated and referenced inode.
+-struct inode*
+-ialloc(uint dev, short type)
+-{
+-  int inum;
+-  struct buf *bp;
+-  struct dinode *dip;
+-
+-  for(inum = 1; inum < sb.ninodes; inum++){
+-    bp = bread(dev, IBLOCK(inum, sb));
+-    dip = (struct dinode*)bp->data + inum%IPB;
+-    if(dip->type == 0){  // a free inode
+-      memset(dip, 0, sizeof(*dip));
+-      dip->type = type;
+-      log_write(bp);   // mark it allocated on the disk
+-      brelse(bp);
+-      return iget(dev, inum);
+-    }
+-    brelse(bp);
+-  }
+-  panic("ialloc: no inodes");
+-}
+-
+-// Copy a modified in-memory inode to disk.
+-// Must be called after every change to an ip->xxx field
+-// that lives on disk, since i-node cache is write-through.
+-// Caller must hold ip->lock.
+-void
+-iupdate(struct inode *ip)
+-{
+-  struct buf *bp;
+-  struct dinode *dip;
+-
+-  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+-  dip = (struct dinode*)bp->data + ip->inum%IPB;
+-  dip->type = ip->type;
+-  dip->major = ip->major;
+-  dip->minor = ip->minor;
+-  dip->nlink = ip->nlink;
+-  dip->size = ip->size;
+-  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+-  log_write(bp);
+-  brelse(bp);
+-}
+-
+-// Find the inode with number inum on device dev
+-// and return the in-memory copy. Does not lock
+-// the inode and does not read it from disk.
+-static struct inode*
+-iget(uint dev, uint inum)
+-{
+-  struct inode *ip, *empty;
+-
+-  acquire(&icache.lock);
+-
+-  // Is the inode already cached?
+-  empty = 0;
+-  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+-    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+-      ip->ref++;
+-      release(&icache.lock);
+-      return ip;
+-    }
+-    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+-      empty = ip;
+-  }
+-
+-  // Recycle an inode cache entry.
+-  if(empty == 0)
+-    panic("iget: no inodes");
+-
+-  ip = empty;
+-  ip->dev = dev;
+-  ip->inum = inum;
+-  ip->ref = 1;
+-  ip->valid = 0;
+-  release(&icache.lock);
+-
+-  return ip;
+-}
+-
+-// Increment reference count for ip.
+-// Returns ip to enable ip = idup(ip1) idiom.
+-struct inode*
+-idup(struct inode *ip)
+-{
+-  acquire(&icache.lock);
+-  ip->ref++;
+-  release(&icache.lock);
+-  return ip;
+-}
+-
+-// Lock the given inode.
+-// Reads the inode from disk if necessary.
+-void
+-ilock(struct inode *ip)
+-{
+-  struct buf *bp;
+-  struct dinode *dip;
+-
+-  if(ip == 0 || ip->ref < 1)
+-    panic("ilock");
+-
+-  acquiresleep(&ip->lock);
+-
+-  if(ip->valid == 0){
+-    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+-    dip = (struct dinode*)bp->data + ip->inum%IPB;
+-    ip->type = dip->type;
+-    ip->major = dip->major;
+-    ip->minor = dip->minor;
+-    ip->nlink = dip->nlink;
+-    ip->size = dip->size;
+-    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+-    brelse(bp);
+-    ip->valid = 1;
+-    if(ip->type == 0)
+-      panic("ilock: no type");
+-  }
+-}
+-
+-// Unlock the given inode.
+-void
+-iunlock(struct inode *ip)
+-{
+-  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+-    panic("iunlock");
+-
+-  releasesleep(&ip->lock);
+-}
+-
+-// Drop a reference to an in-memory inode.
+-// If that was the last reference, the inode cache entry can
+-// be recycled.
+-// If that was the last reference and the inode has no links
+-// to it, free the inode (and its content) on disk.
+-// All calls to iput() must be inside a transaction in
+-// case it has to free the inode.
+-void
+-iput(struct inode *ip)
+-{
+-  acquiresleep(&ip->lock);
+-  if(ip->valid && ip->nlink == 0){
+-    acquire(&icache.lock);
+-    int r = ip->ref;
+-    release(&icache.lock);
+-    if(r == 1){
+-      // inode has no links and no other references: truncate and free.
+-      itrunc(ip);
+-      ip->type = 0;
+-      iupdate(ip);
+-      ip->valid = 0;
+-    }
+-  }
+-  releasesleep(&ip->lock);
+-
+-  acquire(&icache.lock);
+-  ip->ref--;
+-  release(&icache.lock);
+-}
+-
+-// Common idiom: unlock, then put.
+-void
+-iunlockput(struct inode *ip)
+-{
+-  iunlock(ip);
+-  iput(ip);
+-}
+-
+-//PAGEBREAK!
+-// Inode content
+-//
+-// The content (data) associated with each inode is stored
+-// in blocks on the disk. The first NDIRECT block numbers
+-// are listed in ip->addrs[].  The next NINDIRECT blocks are
+-// listed in block ip->addrs[NDIRECT].
+-
+-// Return the disk block address of the nth block in inode ip.
+-// If there is no such block, bmap allocates one.
+-static uint
+-bmap(struct inode *ip, uint bn)
+-{
+-  uint addr, *a;
+-  struct buf *bp;
+-
+-  if(bn < NDIRECT){
+-    if((addr = ip->addrs[bn]) == 0)
+-      ip->addrs[bn] = addr = balloc(ip->dev);
+-    return addr;
+-  }
+-  bn -= NDIRECT;
+-
+-  if(bn < NINDIRECT){
+-    // Load indirect block, allocating if necessary.
+-    if((addr = ip->addrs[NDIRECT]) == 0)
+-      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+-    bp = bread(ip->dev, addr);
+-    a = (uint*)bp->data;
+-    if((addr = a[bn]) == 0){
+-      a[bn] = addr = balloc(ip->dev);
+-      log_write(bp);
+-    }
+-    brelse(bp);
+-    return addr;
+-  }
+-
+-  panic("bmap: out of range");
+-}
+-
+-// Truncate inode (discard contents).
+-// Only called when the inode has no links
+-// to it (no directory entries referring to it)
+-// and has no in-memory reference to it (is
+-// not an open file or current directory).
+-static void
+-itrunc(struct inode *ip)
+-{
+-  int i, j;
+-  struct buf *bp;
+-  uint *a;
+-
+-  for(i = 0; i < NDIRECT; i++){
+-    if(ip->addrs[i]){
+-      bfree(ip->dev, ip->addrs[i]);
+-      ip->addrs[i] = 0;
+-    }
+-  }
+-
+-  if(ip->addrs[NDIRECT]){
+-    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+-    a = (uint*)bp->data;
+-    for(j = 0; j < NINDIRECT; j++){
+-      if(a[j])
+-        bfree(ip->dev, a[j]);
+-    }
+-    brelse(bp);
+-    bfree(ip->dev, ip->addrs[NDIRECT]);
+-    ip->addrs[NDIRECT] = 0;
+-  }
+-
+-  ip->size = 0;
+-  iupdate(ip);
+-}
+-
+-// Copy stat information from inode.
+-// Caller must hold ip->lock.
+-void
+-stati(struct inode *ip, struct stat *st)
+-{
+-  st->dev = ip->dev;
+-  st->ino = ip->inum;
+-  st->type = ip->type;
+-  st->nlink = ip->nlink;
+-  st->size = ip->size;
+-}
+-
+-//PAGEBREAK!
+-// Read data from inode.
+-// Caller must hold ip->lock.
+-int
+-readi(struct inode *ip, char *dst, uint off, uint n)
+-{
+-  uint tot, m;
+-  struct buf *bp;
+-
+-  if(ip->type == T_DEV){
+-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+-      return -1;
+-    return devsw[ip->major].read(ip, dst, n);
+-  }
+-
+-  if(off > ip->size || off + n < off)
+-    return -1;
+-  if(off + n > ip->size)
+-    n = ip->size - off;
+-
+-  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+-    m = min(n - tot, BSIZE - off%BSIZE);
+-    memmove(dst, bp->data + off%BSIZE, m);
+-    brelse(bp);
+-  }
+-  return n;
+-}
+-
+-// PAGEBREAK!
+-// Write data to inode.
+-// Caller must hold ip->lock.
+-int
+-writei(struct inode *ip, char *src, uint off, uint n)
+-{
+-  uint tot, m;
+-  struct buf *bp;
+-
+-  if(ip->type == T_DEV){
+-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+-      return -1;
+-    return devsw[ip->major].write(ip, src, n);
+-  }
+-
+-  if(off > ip->size || off + n < off)
+-    return -1;
+-  if(off + n > MAXFILE*BSIZE)
+-    return -1;
+-
+-  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+-    m = min(n - tot, BSIZE - off%BSIZE);
+-    memmove(bp->data + off%BSIZE, src, m);
+-    log_write(bp);
+-    brelse(bp);
+-  }
+-
+-  if(n > 0 && off > ip->size){
+-    ip->size = off;
+-    iupdate(ip);
+-  }
+-  return n;
+-}
+-
+-//PAGEBREAK!
+-// Directories
+-
+-int
+-namecmp(const char *s, const char *t)
+-{
+-  return strncmp(s, t, DIRSIZ);
+-}
+-
+-// Look for a directory entry in a directory.
+-// If found, set *poff to byte offset of entry.
+-struct inode*
+-dirlookup(struct inode *dp, char *name, uint *poff)
+-{
+-  uint off, inum;
+-  struct dirent de;
+-
+-  if(dp->type != T_DIR)
+-    panic("dirlookup not DIR");
+-
+-  for(off = 0; off < dp->size; off += sizeof(de)){
+-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+-      panic("dirlookup read");
+-    if(de.inum == 0)
+-      continue;
+-    if(namecmp(name, de.name) == 0){
+-      // entry matches path element
+-      if(poff)
+-        *poff = off;
+-      inum = de.inum;
+-      return iget(dp->dev, inum);
+-    }
+-  }
+-
+-  return 0;
+-}
+-
+-// Write a new directory entry (name, inum) into the directory dp.
+-int
+-dirlink(struct inode *dp, char *name, uint inum)
+-{
+-  int off;
+-  struct dirent de;
+-  struct inode *ip;
+-
+-  // Check that name is not present.
+-  if((ip = dirlookup(dp, name, 0)) != 0){
+-    iput(ip);
+-    return -1;
+-  }
+-
+-  // Look for an empty dirent.
+-  for(off = 0; off < dp->size; off += sizeof(de)){
+-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+-      panic("dirlink read");
+-    if(de.inum == 0)
+-      break;
+-  }
+-
+-  strncpy(de.name, name, DIRSIZ);
+-  de.inum = inum;
+-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+-    panic("dirlink");
+-
+-  return 0;
+-}
+-
+-//PAGEBREAK!
+-// Paths
+-
+-// Copy the next path element from path into name.
+-// Return a pointer to the element following the copied one.
+-// The returned path has no leading slashes,
+-// so the caller can check *path=='\0' to see if the name is the last one.
+-// If no name to remove, return 0.
+-//
+-// Examples:
+-//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
+-//   skipelem("///a//bb", name) = "bb", setting name = "a"
+-//   skipelem("a", name) = "", setting name = "a"
+-//   skipelem("", name) = skipelem("////", name) = 0
+-//
+-static char*
+-skipelem(char *path, char *name)
+-{
+-  char *s;
+-  int len;
+-
+-  while(*path == '/')
+-    path++;
+-  if(*path == 0)
+-    return 0;
+-  s = path;
+-  while(*path != '/' && *path != 0)
+-    path++;
+-  len = path - s;
+-  if(len >= DIRSIZ)
+-    memmove(name, s, DIRSIZ);
+-  else {
+-    memmove(name, s, len);
+-    name[len] = 0;
+-  }
+-  while(*path == '/')
+-    path++;
+-  return path;
+-}
+-
+-// Look up and return the inode for a path name.
+-// If parent != 0, return the inode for the parent and copy the final
+-// path element into name, which must have room for DIRSIZ bytes.
+-// Must be called inside a transaction since it calls iput().
+-static struct inode*
+-namex(char *path, int nameiparent, char *name)
+-{
+-  struct inode *ip, *next;
+-
+-  if(*path == '/')
+-    ip = iget(ROOTDEV, ROOTINO);
+-  else
+-    ip = idup(myproc()->cwd);
+-
+-  while((path = skipelem(path, name)) != 0){
+-    ilock(ip);
+-    if(ip->type != T_DIR){
+-      iunlockput(ip);
+-      return 0;
+-    }
+-    if(nameiparent && *path == '\0'){
+-      // Stop one level early.
+-      iunlock(ip);
+-      return ip;
+-    }
+-    if((next = dirlookup(ip, name, 0)) == 0){
+-      iunlockput(ip);
+-      return 0;
+-    }
+-    iunlockput(ip);
+-    ip = next;
+-  }
+-  if(nameiparent){
+-    iput(ip);
+-    return 0;
+-  }
+-  return ip;
+-}
+-
+-struct inode*
+-namei(char *path)
+-{
+-  char name[DIRSIZ];
+-  return namex(path, 0, name);
+-}
+-
+-struct inode*
+-nameiparent(char *path, char *name)
+-{
+-  return namex(path, 1, name);
+-}
+diff --git a/fs.h b/fs.h
+deleted file mode 100644
+index 3214f1d..0000000
+--- a/fs.h
++++ /dev/null
+@@ -1,57 +0,0 @@
+-// On-disk file system format.
+-// Both the kernel and user programs use this header file.
+-
+-
+-#define ROOTINO 1  // root i-number
+-#define BSIZE 512  // block size
+-
+-// Disk layout:
+-// [ boot block | super block | log | inode blocks |
+-//                                          free bit map | data blocks]
+-//
+-// mkfs computes the super block and builds an initial file system. The
+-// super block describes the disk layout:
+-struct superblock {
+-  uint size;         // Size of file system image (blocks)
+-  uint nblocks;      // Number of data blocks
+-  uint ninodes;      // Number of inodes.
+-  uint nlog;         // Number of log blocks
+-  uint logstart;     // Block number of first log block
+-  uint inodestart;   // Block number of first inode block
+-  uint bmapstart;    // Block number of first free map block
+-};
+-
+-#define NDIRECT 12
+-#define NINDIRECT (BSIZE / sizeof(uint))
+-#define MAXFILE (NDIRECT + NINDIRECT)
+-
+-// On-disk inode structure
+-struct dinode {
+-  short type;           // File type
+-  short major;          // Major device number (T_DEV only)
+-  short minor;          // Minor device number (T_DEV only)
+-  short nlink;          // Number of links to inode in file system
+-  uint size;            // Size of file (bytes)
+-  uint addrs[NDIRECT+1];   // Data block addresses
+-};
+-
+-// Inodes per block.
+-#define IPB           (BSIZE / sizeof(struct dinode))
+-
+-// Block containing inode i
+-#define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
+-
+-// Bitmap bits per block
+-#define BPB           (BSIZE*8)
+-
+-// Block of free map containing bit for block b
+-#define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
+-
+-// Directory is a file containing a sequence of dirent structures.
+-#define DIRSIZ 14
+-
+-struct dirent {
+-  ushort inum;
+-  char name[DIRSIZ];
+-};
+-
+diff --git a/gdbutil b/gdbutil
+deleted file mode 100644
+index e0c362f..0000000
+--- a/gdbutil
++++ /dev/null
+@@ -1,291 +0,0 @@
+-# -*- gdb-script -*-
+-
+-# Utility functions to pretty-print x86 segment/interrupt descriptors.
+-# To load this file, run "source gdbutil" in gdb.
+-# printdesc and printdescs are the main entry points.
+-
+-# IA32 2007, Volume 3A, Table 3-2
+-set $STS_T16A = 0x1
+-set $STS_LDT  = 0x2
+-set $STS_T16B = 0x3
+-set $STS_CG16 = 0x4
+-set $STS_TG   = 0x5
+-set $STS_IG16 = 0x6
+-set $STS_TG16 = 0x7
+-set $STS_T32A = 0x9
+-set $STS_T32B = 0xB
+-set $STS_CG32 = 0xC
+-set $STS_IG32 = 0xE
+-set $STS_TG32 = 0xF
+-
+-define outputsts
+-  while 1
+-    if $arg0 == $STS_T16A
+-      echo STS_T16A
+-      loop_break
+-    end
+-    if $arg0 == $STS_LDT
+-      echo STS_LDT\ 
+-      loop_break
+-    end
+-    if $arg0 == $STS_T16B
+-      echo STS_T16B
+-      loop_break
+-    end
+-    if $arg0 == $STS_CG16
+-      echo STS_CG16
+-      loop_break
+-    end
+-    if $arg0 == $STS_TG
+-      echo STS_TG\ \ 
+-      loop_break
+-    end
+-    if $arg0 == $STS_IG16
+-      echo STS_IG16
+-      loop_break
+-    end
+-    if $arg0 == $STS_TG16
+-      echo STS_TG16
+-      loop_break
+-    end
+-    if $arg0 == $STS_T32A
+-      echo STS_T32A
+-      loop_break
+-    end
+-    if $arg0 == $STS_T32B
+-      echo STS_T32B
+-      loop_break
+-    end
+-    if $arg0 == $STS_CG32
+-      echo STS_CG32
+-      loop_break
+-    end
+-    if $arg0 == $STS_IG32
+-      echo STS_IG32
+-      loop_break
+-    end
+-    if $arg0 == $STS_TG32
+-      echo STS_TG32
+-      loop_break
+-    end
+-    echo Reserved
+-    loop_break
+-  end
+-end  
+-
+-# IA32 2007, Volume 3A, Table 3-1
+-set $STA_X = 0x8
+-set $STA_E = 0x4
+-set $STA_C = 0x4
+-set $STA_W = 0x2
+-set $STA_R = 0x2
+-set $STA_A = 0x1
+-
+-define outputsta
+-  if $arg0 & $STA_X
+-    # Code segment
+-    echo code
+-    if $arg0 & $STA_C
+-      echo |STA_C
+-    end
+-    if $arg0 & $STA_R
+-      echo |STA_R
+-    end
+-  else
+-    # Data segment
+-    echo data
+-    if $arg0 & $STA_E
+-      echo |STA_E
+-    end
+-    if $arg0 & $STA_W
+-      echo |STA_W
+-    end
+-  end
+-  if $arg0 & $STA_A
+-    echo |STA_A
+-  else
+-    printf "      "
+-  end
+-end
+-
+-# xv6-specific
+-set $SEG_KCODE = 1
+-set $SEG_KDATA = 2
+-set $SEG_KCPU  = 3
+-set $SEG_UCODE = 4
+-set $SEG_UDATA = 5
+-set $SEG_TSS   = 6
+-
+-define outputcs
+-  if ($arg0 & 4) == 0
+-    if $arg0 >> 3 == $SEG_KCODE
+-      printf "SEG_KCODE<<3"
+-    end
+-    if $arg0 >> 3 == $SEG_KDATA
+-      printf "SEG_KDATA<<3"
+-    end
+-    if $arg0 >> 3 == $SEG_KCPU
+-      printf "SEG_KCPU<<3"
+-    end
+-    if $arg0 >> 3 == $SEG_UCODE
+-      printf "SEG_UCODE<<3"
+-    end
+-    if $arg0 >> 3 == $SEG_UDATA
+-      printf "SEG_UDATA<<3"
+-    end
+-    if $arg0 >> 3 == $SEG_TSS
+-      printf "SEG_TSS<<3"
+-    end
+-    if ($arg0 >> 3 < 1) + ($arg0 >> 3 > 6)
+-      printf "GDT[%d]", $arg0 >> 3
+-    end
+-  else
+-    printf "LDT[%d]", $arg0 >> 3
+-  end
+-  if ($arg0 & 3) > 0
+-    printf "|"
+-    outputdpl ($arg0&3)
+-  end
+-end
+-
+-define outputdpl
+-  if $arg0 == 0
+-    printf "DPL_KERN"
+-  else
+-    if $arg0 == 3
+-      printf "DPL_USER"
+-    else
+-      printf "DPL%d", $arg0
+-    end
+-  end
+-end
+-
+-define printdesc
+-  if $argc != 1
+-    echo Usage: printdesc expr
+-  else
+-    _printdesc ((uint*)&($arg0))[0] ((uint*)&($arg0))[1]
+-    printf "\n"
+-  end
+-end
+-
+-document printdesc
+-Print an x86 segment or gate descriptor.
+-printdesc EXPR
+-EXPR must evaluate to a descriptor value.  It can be of any C type.
+-end
+-
+-define _printdesc
+-  _printdesc1 $arg0 $arg1 ($arg1>>15&1) ($arg1>>13&3) ($arg1>>12&1) ($arg1>>8&15)
+-end
+-
+-define _printdesc1
+-  # 2:P 3:DPL 4:S 5:Type
+-  if $arg2 == 0
+-    printf "P = 0 (Not present)"
+-  else
+-    printf "type = "
+-    if $arg4 == 0
+-      # System segment
+-      outputsts $arg5
+-      printf " (0x%x)    ", $arg5
+-      _printsysdesc $arg0 $arg1 $arg5
+-    else
+-      # Code/data segment
+-      outputsta $arg5
+-      printf "  "
+-      _printsegdesc $arg0 $arg1
+-    end
+-
+-    printf "  DPL = "
+-    outputdpl $arg3
+-    printf " (%d)", $arg3
+-  end
+-end
+-
+-define _printsysdesc
+-  # 2:Type
+-  # GDB's || is buggy
+-  if ($arg2 == $STS_TG) + (($arg2&7) == $STS_IG16) + (($arg2&7) == $STS_TG16)
+-    # Gate descriptor
+-    _printgate $arg2 ($arg0>>16) ($arg0&0xFFFF) ($arg1>>16)
+-  else
+-    # System segment descriptor
+-    _printsegdesc $arg0 $arg1
+-  end
+-end
+-
+-define _printgate
+-  # IA32 2007, Voume 3A, Figure 5-2
+-  # 0:Type 1:CS 2:Offset 15..0 3:Offset 31..16
+-  printf "CS = "
+-  outputcs $arg1
+-  printf " (%d)", $arg1
+-
+-  if (($arg0&7) == $STS_IG16) + (($arg0&7) == $STS_TG16)
+-    printf "  Offset = "
+-    output/a $arg3 << 16 | $arg2
+-  end
+-end
+-
+-define _printsegdesc
+-  # IA32 20007, Volume 3A, Figure 3-8 and Figure 4-1
+-  _printsegdesc1 ($arg0>>16) ($arg1&0xFF) ($arg1>>24) ($arg0&0xFFFF) ($arg1>>16&15) ($arg1>>23&1)
+-  if ($arg1>>12&1) == 1
+-    printf "  AVL = %d", $arg1>>20&1
+-    if ($arg1>>11&1) == 0
+-      # Data segment
+-      if ($arg1>>22&1) == 0
+-        printf "  B = small (0) "
+-      else
+-        printf "  B = big (1)   "
+-      end
+-    else
+-      # Code segment
+-      printf "  D = "
+-      if ($arg1>>22&1) == 0
+-        printf "16-bit (0)"
+-      else
+-        printf "32-bit (1)"
+-      end
+-    end
+-  end
+-end
+-
+-define _printsegdesc1
+-  # 0:Base 0..15  1:Base 16..23  2:Base 24..32  3:Limit 0..15  4:Limit 16..19  5:G
+-  printf "base = 0x%08x", $arg0 | ($arg1<<16) | ($arg2<<24)
+-  printf "  limit = 0x"
+-  if $arg5 == 0
+-    printf "%08x", $arg3 | ($arg4<<16)
+-  else
+-    printf "%08x", (($arg3 | ($arg4<<16)) << 12) | 0xFFF
+-  end
+-end
+-
+-define printdescs
+-  if $argc < 1 || $argc > 2
+-    echo Usage: printdescs expr [count]
+-  else
+-    if $argc == 1
+-      _printdescs ($arg0) (sizeof($arg0)/sizeof(($arg0)[0]))
+-    else
+-      _printdescs ($arg0) ($arg1)
+-    end
+-  end
+-end
+-
+-document printdescs
+-Print an array of x86 segment or gate descriptors.
+-printdescs EXPR [COUNT]
+-EXPR must evaluate to an array of descriptors.
+-end
+-
+-define _printdescs
+-  set $i = 0
+-  while $i < $arg1
+-    printf "[%d] ", $i
+-    printdesc $arg0[$i]
+-    set $i = $i + 1
+-  end
+-end
+diff --git a/grep.c b/grep.c
+deleted file mode 100644
+index 4be3256..0000000
+--- a/grep.c
++++ /dev/null
+@@ -1,107 +0,0 @@
+-// Simple grep.  Only supports ^ . * $ operators.
+-
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-char buf[1024];
+-int match(char*, char*);
+-
+-void
+-grep(char *pattern, int fd)
+-{
+-  int n, m;
+-  char *p, *q;
+-
+-  m = 0;
+-  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+-    m += n;
+-    buf[m] = '\0';
+-    p = buf;
+-    while((q = strchr(p, '\n')) != 0){
+-      *q = 0;
+-      if(match(pattern, p)){
+-        *q = '\n';
+-        write(1, p, q+1 - p);
+-      }
+-      p = q+1;
+-    }
+-    if(p == buf)
+-      m = 0;
+-    if(m > 0){
+-      m -= p - buf;
+-      memmove(buf, p, m);
+-    }
+-  }
+-}
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int fd, i;
+-  char *pattern;
+-
+-  if(argc <= 1){
+-    printf(2, "usage: grep pattern [file ...]\n");
+-    exit(1);
+-  }
+-  pattern = argv[1];
+-
+-  if(argc <= 2){
+-    grep(pattern, 0);
+-    exit(2);
+-  }
+-
+-  for(i = 2; i < argc; i++){
+-    if((fd = open(argv[i], 0)) < 0){
+-      printf(1, "grep: cannot open %s\n", argv[i]);
+-      exit(3);
+-    }
+-    grep(pattern, fd);
+-    close(fd);
+-  }
+-  exit(0);
+-}
+-
+-// Regexp matcher from Kernighan & Pike,
+-// The Practice of Programming, Chapter 9.
+-
+-int matchhere(char*, char*);
+-int matchstar(int, char*, char*);
+-
+-int
+-match(char *re, char *text)
+-{
+-  if(re[0] == '^')
+-    return matchhere(re+1, text);
+-  do{  // must look at empty string
+-    if(matchhere(re, text))
+-      return 1;
+-  }while(*text++ != '\0');
+-  return 0;
+-}
+-
+-// matchhere: search for re at beginning of text
+-int matchhere(char *re, char *text)
+-{
+-  if(re[0] == '\0')
+-    return 1;
+-  if(re[1] == '*')
+-    return matchstar(re[0], re+2, text);
+-  if(re[0] == '$' && re[1] == '\0')
+-    return *text == '\0';
+-  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+-    return matchhere(re+1, text+1);
+-  return 0;
+-}
+-
+-// matchstar: search for c*re at beginning of text
+-int matchstar(int c, char *re, char *text)
+-{
+-  do{  // a * matches zero or more instances
+-    if(matchhere(re, text))
+-      return 1;
+-  }while(*text!='\0' && (*text++==c || c=='.'));
+-  return 0;
+-}
+-
+diff --git a/ide.c b/ide.c
+deleted file mode 100644
+index b4c0b1f..0000000
+--- a/ide.c
++++ /dev/null
+@@ -1,168 +0,0 @@
+-// Simple PIO-based (non-DMA) IDE driver code.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-#include "traps.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "buf.h"
+-
+-#define SECTOR_SIZE   512
+-#define IDE_BSY       0x80
+-#define IDE_DRDY      0x40
+-#define IDE_DF        0x20
+-#define IDE_ERR       0x01
+-
+-#define IDE_CMD_READ  0x20
+-#define IDE_CMD_WRITE 0x30
+-#define IDE_CMD_RDMUL 0xc4
+-#define IDE_CMD_WRMUL 0xc5
+-
+-// idequeue points to the buf now being read/written to the disk.
+-// idequeue->qnext points to the next buf to be processed.
+-// You must hold idelock while manipulating queue.
+-
+-static struct spinlock idelock;
+-static struct buf *idequeue;
+-
+-static int havedisk1;
+-static void idestart(struct buf*);
+-
+-// Wait for IDE disk to become ready.
+-static int
+-idewait(int checkerr)
+-{
+-  int r;
+-
+-  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+-    ;
+-  if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
+-    return -1;
+-  return 0;
+-}
+-
+-void
+-ideinit(void)
+-{
+-  int i;
+-
+-  initlock(&idelock, "ide");
+-  ioapicenable(IRQ_IDE, ncpu - 1);
+-  idewait(0);
+-
+-  // Check if disk 1 is present
+-  outb(0x1f6, 0xe0 | (1<<4));
+-  for(i=0; i<1000; i++){
+-    if(inb(0x1f7) != 0){
+-      havedisk1 = 1;
+-      break;
+-    }
+-  }
+-
+-  // Switch back to disk 0.
+-  outb(0x1f6, 0xe0 | (0<<4));
+-}
+-
+-// Start the request for b.  Caller must hold idelock.
+-static void
+-idestart(struct buf *b)
+-{
+-  if(b == 0)
+-    panic("idestart");
+-  if(b->blockno >= FSSIZE)
+-    panic("incorrect blockno");
+-  int sector_per_block =  BSIZE/SECTOR_SIZE;
+-  int sector = b->blockno * sector_per_block;
+-  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
+-  int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
+-
+-  if (sector_per_block > 7) panic("idestart");
+-
+-  idewait(0);
+-  outb(0x3f6, 0);  // generate interrupt
+-  outb(0x1f2, sector_per_block);  // number of sectors
+-  outb(0x1f3, sector & 0xff);
+-  outb(0x1f4, (sector >> 8) & 0xff);
+-  outb(0x1f5, (sector >> 16) & 0xff);
+-  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
+-  if(b->flags & B_DIRTY){
+-    outb(0x1f7, write_cmd);
+-    outsl(0x1f0, b->data, BSIZE/4);
+-  } else {
+-    outb(0x1f7, read_cmd);
+-  }
+-}
+-
+-// Interrupt handler.
+-void
+-ideintr(void)
+-{
+-  struct buf *b;
+-
+-  // First queued buffer is the active request.
+-  acquire(&idelock);
+-
+-  if((b = idequeue) == 0){
+-    release(&idelock);
+-    return;
+-  }
+-  idequeue = b->qnext;
+-
+-  // Read data if needed.
+-  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
+-    insl(0x1f0, b->data, BSIZE/4);
+-
+-  // Wake process waiting for this buf.
+-  b->flags |= B_VALID;
+-  b->flags &= ~B_DIRTY;
+-  wakeup(b);
+-
+-  // Start disk on next buf in queue.
+-  if(idequeue != 0)
+-    idestart(idequeue);
+-
+-  release(&idelock);
+-}
+-
+-//PAGEBREAK!
+-// Sync buf with disk.
+-// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+-// Else if B_VALID is not set, read buf from disk, set B_VALID.
+-void
+-iderw(struct buf *b)
+-{
+-  struct buf **pp;
+-
+-  if(!holdingsleep(&b->lock))
+-    panic("iderw: buf not locked");
+-  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+-    panic("iderw: nothing to do");
+-  if(b->dev != 0 && !havedisk1)
+-    panic("iderw: ide disk 1 not present");
+-
+-  acquire(&idelock);  //DOC:acquire-lock
+-
+-  // Append b to idequeue.
+-  b->qnext = 0;
+-  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+-    ;
+-  *pp = b;
+-
+-  // Start disk if necessary.
+-  if(idequeue == b)
+-    idestart(b);
+-
+-  // Wait for request to finish.
+-  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+-    sleep(b, &idelock);
+-  }
+-
+-
+-  release(&idelock);
+-}
+diff --git a/init.c b/init.c
+deleted file mode 100644
+index bc6547f..0000000
+--- a/init.c
++++ /dev/null
+@@ -1,37 +0,0 @@
+-// init: The initial user-level program
+-
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-#include "fcntl.h"
+-
+-char *argv[] = { "sh", 0 };
+-
+-int
+-main(void)
+-{
+-  int pid, wpid;
+-
+-  if(open("console", O_RDWR) < 0){
+-    mknod("console", 1, 1);
+-    open("console", O_RDWR);
+-  }
+-  dup(0);  // stdout
+-  dup(0);  // stderr
+-
+-  for(;;){
+-    printf(1, "init: starting sh\n");
+-    pid = fork();
+-    if(pid < 0){
+-      printf(1, "init: fork failed\n");
+-      exit(2);
+-    }
+-    if(pid == 0){
+-      exec("sh", argv);
+-      printf(1, "init: exec sh failed\n");
+-      exit(1);
+-    }
+-    while((wpid=wait(NULL)) >= 0 && wpid != pid)
+-      printf(1, "zombie!\n");
+-  }
+-}
+diff --git a/initcode.S b/initcode.S
+deleted file mode 100644
+index 80ac5d8..0000000
+--- a/initcode.S
++++ /dev/null
+@@ -1,32 +0,0 @@
+-# Initial process execs /init.
+-# This code runs in user space.
+-
+-#include "syscall.h"
+-#include "traps.h"
+-
+-
+-# exec(init, argv)
+-.globl start
+-start:
+-  pushl $argv
+-  pushl $init
+-  pushl $0  // where caller pc would be
+-  movl $SYS_exec, %eax
+-  int $T_SYSCALL
+-
+-# for(;;) exit();
+-exit:
+-  movl $SYS_exit, %eax
+-  int $T_SYSCALL
+-  jmp exit
+-
+-# char init[] = "/init\0";
+-init:
+-  .string "/init\0"
+-
+-# char *argv[] = { init, 0 };
+-.p2align 2
+-argv:
+-  .long init
+-  .long 0
+-
+diff --git a/ioapic.c b/ioapic.c
+deleted file mode 100644
+index cb0f015..0000000
+--- a/ioapic.c
++++ /dev/null
+@@ -1,75 +0,0 @@
+-// The I/O APIC manages hardware interrupts for an SMP system.
+-// http://www.intel.com/design/chipsets/datashts/29056601.pdf
+-// See also picirq.c.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "traps.h"
+-
+-#define IOAPIC  0xFEC00000   // Default physical address of IO APIC
+-
+-#define REG_ID     0x00  // Register index: ID
+-#define REG_VER    0x01  // Register index: version
+-#define REG_TABLE  0x10  // Redirection table base
+-
+-// The redirection table starts at REG_TABLE and uses
+-// two registers to configure each interrupt.
+-// The first (low) register in a pair contains configuration bits.
+-// The second (high) register contains a bitmask telling which
+-// CPUs can serve that interrupt.
+-#define INT_DISABLED   0x00010000  // Interrupt disabled
+-#define INT_LEVEL      0x00008000  // Level-triggered (vs edge-)
+-#define INT_ACTIVELOW  0x00002000  // Active low (vs high)
+-#define INT_LOGICAL    0x00000800  // Destination is CPU id (vs APIC ID)
+-
+-volatile struct ioapic *ioapic;
+-
+-// IO APIC MMIO structure: write reg, then read or write data.
+-struct ioapic {
+-  uint reg;
+-  uint pad[3];
+-  uint data;
+-};
+-
+-static uint
+-ioapicread(int reg)
+-{
+-  ioapic->reg = reg;
+-  return ioapic->data;
+-}
+-
+-static void
+-ioapicwrite(int reg, uint data)
+-{
+-  ioapic->reg = reg;
+-  ioapic->data = data;
+-}
+-
+-void
+-ioapicinit(void)
+-{
+-  int i, id, maxintr;
+-
+-  ioapic = (volatile struct ioapic*)IOAPIC;
+-  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
+-  id = ioapicread(REG_ID) >> 24;
+-  if(id != ioapicid)
+-    cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
+-
+-  // Mark all interrupts edge-triggered, active high, disabled,
+-  // and not routed to any CPUs.
+-  for(i = 0; i <= maxintr; i++){
+-    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
+-    ioapicwrite(REG_TABLE+2*i+1, 0);
+-  }
+-}
+-
+-void
+-ioapicenable(int irq, int cpunum)
+-{
+-  // Mark interrupt edge-triggered, active high,
+-  // enabled, and routed to the given cpunum,
+-  // which happens to be that cpu's APIC ID.
+-  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
+-  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
+-}
+diff --git a/kalloc.c b/kalloc.c
+deleted file mode 100644
+index 14cd4f4..0000000
+--- a/kalloc.c
++++ /dev/null
+@@ -1,96 +0,0 @@
+-// Physical memory allocator, intended to allocate
+-// memory for user processes, kernel stacks, page table pages,
+-// and pipe buffers. Allocates 4096-byte pages.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "spinlock.h"
+-
+-void freerange(void *vstart, void *vend);
+-extern char end[]; // first address after kernel loaded from ELF file
+-                   // defined by the kernel linker script in kernel.ld
+-
+-struct run {
+-  struct run *next;
+-};
+-
+-struct {
+-  struct spinlock lock;
+-  int use_lock;
+-  struct run *freelist;
+-} kmem;
+-
+-// Initialization happens in two phases.
+-// 1. main() calls kinit1() while still using entrypgdir to place just
+-// the pages mapped by entrypgdir on free list.
+-// 2. main() calls kinit2() with the rest of the physical pages
+-// after installing a full page table that maps them on all cores.
+-void
+-kinit1(void *vstart, void *vend)
+-{
+-  initlock(&kmem.lock, "kmem");
+-  kmem.use_lock = 0;
+-  freerange(vstart, vend);
+-}
+-
+-void
+-kinit2(void *vstart, void *vend)
+-{
+-  freerange(vstart, vend);
+-  kmem.use_lock = 1;
+-}
+-
+-void
+-freerange(void *vstart, void *vend)
+-{
+-  char *p;
+-  p = (char*)PGROUNDUP((uint)vstart);
+-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+-    kfree(p);
+-}
+-//PAGEBREAK: 21
+-// Free the page of physical memory pointed at by v,
+-// which normally should have been returned by a
+-// call to kalloc().  (The exception is when
+-// initializing the allocator; see kinit above.)
+-void
+-kfree(char *v)
+-{
+-  struct run *r;
+-
+-  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
+-    panic("kfree");
+-
+-  // Fill with junk to catch dangling refs.
+-  memset(v, 1, PGSIZE);
+-
+-  if(kmem.use_lock)
+-    acquire(&kmem.lock);
+-  r = (struct run*)v;
+-  r->next = kmem.freelist;
+-  kmem.freelist = r;
+-  if(kmem.use_lock)
+-    release(&kmem.lock);
+-}
+-
+-// Allocate one 4096-byte page of physical memory.
+-// Returns a pointer that the kernel can use.
+-// Returns 0 if the memory cannot be allocated.
+-char*
+-kalloc(void)
+-{
+-  struct run *r;
+-
+-  if(kmem.use_lock)
+-    acquire(&kmem.lock);
+-  r = kmem.freelist;
+-  if(r)
+-    kmem.freelist = r->next;
+-  if(kmem.use_lock)
+-    release(&kmem.lock);
+-  return (char*)r;
+-}
+-
+diff --git a/kbd.c b/kbd.c
+deleted file mode 100644
+index 32c1463..0000000
+--- a/kbd.c
++++ /dev/null
+@@ -1,50 +0,0 @@
+-#include "types.h"
+-#include "x86.h"
+-#include "defs.h"
+-#include "kbd.h"
+-
+-int
+-kbdgetc(void)
+-{
+-  static uint shift;
+-  static uchar *charcode[4] = {
+-    normalmap, shiftmap, ctlmap, ctlmap
+-  };
+-  uint st, data, c;
+-
+-  st = inb(KBSTATP);
+-  if((st & KBS_DIB) == 0)
+-    return -1;
+-  data = inb(KBDATAP);
+-
+-  if(data == 0xE0){
+-    shift |= E0ESC;
+-    return 0;
+-  } else if(data & 0x80){
+-    // Key released
+-    data = (shift & E0ESC ? data : data & 0x7F);
+-    shift &= ~(shiftcode[data] | E0ESC);
+-    return 0;
+-  } else if(shift & E0ESC){
+-    // Last character was an E0 escape; or with 0x80
+-    data |= 0x80;
+-    shift &= ~E0ESC;
+-  }
+-
+-  shift |= shiftcode[data];
+-  shift ^= togglecode[data];
+-  c = charcode[shift & (CTL | SHIFT)][data];
+-  if(shift & CAPSLOCK){
+-    if('a' <= c && c <= 'z')
+-      c += 'A' - 'a';
+-    else if('A' <= c && c <= 'Z')
+-      c += 'a' - 'A';
+-  }
+-  return c;
+-}
+-
+-void
+-kbdintr(void)
+-{
+-  consoleintr(kbdgetc);
+-}
+diff --git a/kbd.h b/kbd.h
+deleted file mode 100644
+index babbd6e..0000000
+--- a/kbd.h
++++ /dev/null
+@@ -1,112 +0,0 @@
+-// PC keyboard interface constants
+-
+-#define KBSTATP         0x64    // kbd controller status port(I)
+-#define KBS_DIB         0x01    // kbd data in buffer
+-#define KBDATAP         0x60    // kbd data port(I)
+-
+-#define NO              0
+-
+-#define SHIFT           (1<<0)
+-#define CTL             (1<<1)
+-#define ALT             (1<<2)
+-
+-#define CAPSLOCK        (1<<3)
+-#define NUMLOCK         (1<<4)
+-#define SCROLLLOCK      (1<<5)
+-
+-#define E0ESC           (1<<6)
+-
+-// Special keycodes
+-#define KEY_HOME        0xE0
+-#define KEY_END         0xE1
+-#define KEY_UP          0xE2
+-#define KEY_DN          0xE3
+-#define KEY_LF          0xE4
+-#define KEY_RT          0xE5
+-#define KEY_PGUP        0xE6
+-#define KEY_PGDN        0xE7
+-#define KEY_INS         0xE8
+-#define KEY_DEL         0xE9
+-
+-// C('A') == Control-A
+-#define C(x) (x - '@')
+-
+-static uchar shiftcode[256] =
+-{
+-  [0x1D] CTL,
+-  [0x2A] SHIFT,
+-  [0x36] SHIFT,
+-  [0x38] ALT,
+-  [0x9D] CTL,
+-  [0xB8] ALT
+-};
+-
+-static uchar togglecode[256] =
+-{
+-  [0x3A] CAPSLOCK,
+-  [0x45] NUMLOCK,
+-  [0x46] SCROLLLOCK
+-};
+-
+-static uchar normalmap[256] =
+-{
+-  NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  // 0x00
+-  '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
+-  'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  // 0x10
+-  'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
+-  'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  // 0x20
+-  '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
+-  'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  // 0x30
+-  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+-  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
+-  [0x9C] '\n',      // KP_Enter
+-  [0xB5] '/',       // KP_Div
+-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
+-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
+-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
+-  [0x97] KEY_HOME,  [0xCF] KEY_END,
+-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
+-};
+-
+-static uchar shiftmap[256] =
+-{
+-  NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  // 0x00
+-  '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
+-  'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  // 0x10
+-  'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
+-  'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  // 0x20
+-  '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
+-  'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  // 0x30
+-  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+-  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
+-  [0x9C] '\n',      // KP_Enter
+-  [0xB5] '/',       // KP_Div
+-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
+-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
+-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
+-  [0x97] KEY_HOME,  [0xCF] KEY_END,
+-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
+-};
+-
+-static uchar ctlmap[256] =
+-{
+-  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+-  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+-  C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
+-  C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
+-  C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
+-  NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
+-  C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
+-  [0x9C] '\r',      // KP_Enter
+-  [0xB5] C('/'),    // KP_Div
+-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
+-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
+-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
+-  [0x97] KEY_HOME,  [0xCF] KEY_END,
+-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
+-};
+-
+diff --git a/kernel.ld b/kernel.ld
+deleted file mode 100644
+index 4e12e14..0000000
+--- a/kernel.ld
++++ /dev/null
+@@ -1,64 +0,0 @@
+-/* Simple linker script for the JOS kernel.
+-   See the GNU ld 'info' manual ("info ld") to learn the syntax. */
+-
+-OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+-OUTPUT_ARCH(i386)
+-ENTRY(_start)
+-
+-SECTIONS
+-{
+-	/* Link the kernel at this address: "." means the current address */
+-        /* Must be equal to KERNLINK */
+-	. = 0x80100000;
+-
+-	.text : AT(0x100000) {
+-		*(.text .stub .text.* .gnu.linkonce.t.*)
+-	}
+-
+-	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
+-
+-	.rodata : {
+-		*(.rodata .rodata.* .gnu.linkonce.r.*)
+-	}
+-
+-	/* Include debugging information in kernel memory */
+-	.stab : {
+-		PROVIDE(__STAB_BEGIN__ = .);
+-		*(.stab);
+-		PROVIDE(__STAB_END__ = .);
+-	}
+-
+-	.stabstr : {
+-		PROVIDE(__STABSTR_BEGIN__ = .);
+-		*(.stabstr);
+-		PROVIDE(__STABSTR_END__ = .);
+-	}
+-
+-	/* Adjust the address for the data segment to the next page */
+-	. = ALIGN(0x1000);
+-
+-	/* Conventionally, Unix linkers provide pseudo-symbols
+-	 * etext, edata, and end, at the end of the text, data, and bss.
+-	 * For the kernel mapping, we need the address at the beginning
+-	 * of the data section, but that's not one of the conventional
+-	 * symbols, because the convention started before there was a
+-	 * read-only rodata section between text and data. */
+-	PROVIDE(data = .);
+-
+-	/* The data segment */
+-	.data : {
+-		*(.data)
+-	}
+-
+-	PROVIDE(edata = .);
+-
+-	.bss : {
+-		*(.bss)
+-	}
+-
+-	PROVIDE(end = .);
+-
+-	/DISCARD/ : {
+-		*(.eh_frame .note.GNU-stack)
+-	}
+-}
+diff --git a/kill.c b/kill.c
+deleted file mode 100644
+index 875916c..0000000
+--- a/kill.c
++++ /dev/null
+@@ -1,17 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-int
+-main(int argc, char **argv)
+-{
+-  int i;
+-
+-  if(argc < 2){
+-    printf(2, "usage: kill pid...\n");
+-    exit(1);
+-  }
+-  for(i=1; i<argc; i++)
+-    kill(atoi(argv[i]));
+-  exit(0);
+-}
+diff --git a/lab1.c b/lab3.c
+similarity index 50%
+rename from lab1.c
+rename to lab3.c
+index 2192a52..7cf6b00 100644
+--- a/lab1.c
++++ b/lab3.c
+@@ -16,54 +16,11 @@
+ #include "types.h"
+ #include "user.h"
+ 
+-int main(int argc, char **argv) {
++int main(int argc, char *argv[]) {
+ 
+-    int pid;
++    int v = argc;
+ 
+-    pid = fork();
+-
+-    if(pid > 0)
+-    {
+-        waitpid(pid, NULL, 0);
+-        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
+-        exit(0);
+-    }
+-
+-
+-    pid = fork();
+-
+-    if(pid == 0)
+-    {
+-        printf(1, "I'm the child! PID: %d\n", pid);
+-    }
+-    else
+-    {
+-        printf(1, "I'm the parent! PID: %d\n", pid);
+-        waitpid(pid, NULL, 0);
+-
+-    }
+-
+-
+-    exit(0);
++    printf(1, "%d",sizeof(*argv) / sizeof(*argv[0]));
++    printf(1, "%p\n", &v);
++    exit();
+ }
+-//    printf(1, "Waitpid Demo Initializing...\n"); // fd=1 means standard output.
+-//
+-//    int defValue = -1;
+-//    int* status = &defValue;
+-//
+-//    int pid = fork();
+-//
+-//
+-//    if(pid > 0)
+-//    while(waitpid(pid, status, 0) == -1);
+-//
+-//    if(pid == 0)
+-//    {
+-//        printf(1, "hi im the child :)\n"); // fd=1 means standard output.
+-//        exit(0);
+-//    }
+-//
+-//    printf(1, "Exit status returned is: %d\n", *status); // fd=1 means standard output.
+-//
+-//    exit(0);
+-//}
+diff --git a/lab3p2.c b/lab3p2.c
+new file mode 100644
+index 0000000..f94207f
+--- /dev/null
++++ b/lab3p2.c
+@@ -0,0 +1,31 @@
++#include "types.h"
++#include "user.h"
++
++// Prevent this function from being optimized, which might give it closed form
++#pragma GCC push_options
++#pragma GCC optimize ("O0")
++static int
++recurse(int n)
++{
++    if(n == 0)
++        return 0;
++    return n + recurse(n - 1);
 +}
++#pragma GCC pop_options
 +
 +int
-+sys_waitpid(int pid, int* status, int options)
++main(int argc, char *argv[])
 +{
-+    return waitpid(pid, status, options);
- }
- 
- int
++    int n, m;
++
++    if(argc != 2){
++        printf(1, "Usage: %s levels\n", argv[0]);
++        exit();
++    }
++
++    n = atoi(argv[1]);
++    printf(1, "Lab 3: Recursing %d levels\n", n);
++    m = recurse(n);
++    printf(1, "Lab 3: Yielded a value of %d\n", m);
++    exit();
++}
+\ No newline at end of file
+diff --git a/lapic.c b/lapic.c
+deleted file mode 100644
+index b22bbd7..0000000
+--- a/lapic.c
++++ /dev/null
+@@ -1,229 +0,0 @@
+-// The local APIC manages internal (non-I/O) interrupts.
+-// See Chapter 8 & Appendix C of Intel processor manual volume 3.
+-
+-#include "param.h"
+-#include "types.h"
+-#include "defs.h"
+-#include "date.h"
+-#include "memlayout.h"
+-#include "traps.h"
+-#include "mmu.h"
+-#include "x86.h"
+-
+-// Local APIC registers, divided by 4 for use as uint[] indices.
+-#define ID      (0x0020/4)   // ID
+-#define VER     (0x0030/4)   // Version
+-#define TPR     (0x0080/4)   // Task Priority
+-#define EOI     (0x00B0/4)   // EOI
+-#define SVR     (0x00F0/4)   // Spurious Interrupt Vector
+-  #define ENABLE     0x00000100   // Unit Enable
+-#define ESR     (0x0280/4)   // Error Status
+-#define ICRLO   (0x0300/4)   // Interrupt Command
+-  #define INIT       0x00000500   // INIT/RESET
+-  #define STARTUP    0x00000600   // Startup IPI
+-  #define DELIVS     0x00001000   // Delivery status
+-  #define ASSERT     0x00004000   // Assert interrupt (vs deassert)
+-  #define DEASSERT   0x00000000
+-  #define LEVEL      0x00008000   // Level triggered
+-  #define BCAST      0x00080000   // Send to all APICs, including self.
+-  #define BUSY       0x00001000
+-  #define FIXED      0x00000000
+-#define ICRHI   (0x0310/4)   // Interrupt Command [63:32]
+-#define TIMER   (0x0320/4)   // Local Vector Table 0 (TIMER)
+-  #define X1         0x0000000B   // divide counts by 1
+-  #define PERIODIC   0x00020000   // Periodic
+-#define PCINT   (0x0340/4)   // Performance Counter LVT
+-#define LINT0   (0x0350/4)   // Local Vector Table 1 (LINT0)
+-#define LINT1   (0x0360/4)   // Local Vector Table 2 (LINT1)
+-#define ERROR   (0x0370/4)   // Local Vector Table 3 (ERROR)
+-  #define MASKED     0x00010000   // Interrupt masked
+-#define TICR    (0x0380/4)   // Timer Initial Count
+-#define TCCR    (0x0390/4)   // Timer Current Count
+-#define TDCR    (0x03E0/4)   // Timer Divide Configuration
+-
+-volatile uint *lapic;  // Initialized in mp.c
+-
+-//PAGEBREAK!
+-static void
+-lapicw(int index, int value)
+-{
+-  lapic[index] = value;
+-  lapic[ID];  // wait for write to finish, by reading
+-}
+-
+-void
+-lapicinit(void)
+-{
+-  if(!lapic)
+-    return;
+-
+-  // Enable local APIC; set spurious interrupt vector.
+-  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
+-
+-  // The timer repeatedly counts down at bus frequency
+-  // from lapic[TICR] and then issues an interrupt.
+-  // If xv6 cared more about precise timekeeping,
+-  // TICR would be calibrated using an external time source.
+-  lapicw(TDCR, X1);
+-  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
+-  lapicw(TICR, 10000000);
+-
+-  // Disable logical interrupt lines.
+-  lapicw(LINT0, MASKED);
+-  lapicw(LINT1, MASKED);
+-
+-  // Disable performance counter overflow interrupts
+-  // on machines that provide that interrupt entry.
+-  if(((lapic[VER]>>16) & 0xFF) >= 4)
+-    lapicw(PCINT, MASKED);
+-
+-  // Map error interrupt to IRQ_ERROR.
+-  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
+-
+-  // Clear error status register (requires back-to-back writes).
+-  lapicw(ESR, 0);
+-  lapicw(ESR, 0);
+-
+-  // Ack any outstanding interrupts.
+-  lapicw(EOI, 0);
+-
+-  // Send an Init Level De-Assert to synchronise arbitration ID's.
+-  lapicw(ICRHI, 0);
+-  lapicw(ICRLO, BCAST | INIT | LEVEL);
+-  while(lapic[ICRLO] & DELIVS)
+-    ;
+-
+-  // Enable interrupts on the APIC (but not on the processor).
+-  lapicw(TPR, 0);
+-}
+-
+-int
+-lapicid(void)
+-{
+-  if (!lapic)
+-    return 0;
+-  return lapic[ID] >> 24;
+-}
+-
+-// Acknowledge interrupt.
+-void
+-lapiceoi(void)
+-{
+-  if(lapic)
+-    lapicw(EOI, 0);
+-}
+-
+-// Spin for a given number of microseconds.
+-// On real hardware would want to tune this dynamically.
+-void
+-microdelay(int us)
+-{
+-}
+-
+-#define CMOS_PORT    0x70
+-#define CMOS_RETURN  0x71
+-
+-// Start additional processor running entry code at addr.
+-// See Appendix B of MultiProcessor Specification.
+-void
+-lapicstartap(uchar apicid, uint addr)
+-{
+-  int i;
+-  ushort *wrv;
+-
+-  // "The BSP must initialize CMOS shutdown code to 0AH
+-  // and the warm reset vector (DWORD based at 40:67) to point at
+-  // the AP startup code prior to the [universal startup algorithm]."
+-  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
+-  outb(CMOS_PORT+1, 0x0A);
+-  wrv = (ushort*)P2V((0x40<<4 | 0x67));  // Warm reset vector
+-  wrv[0] = 0;
+-  wrv[1] = addr >> 4;
+-
+-  // "Universal startup algorithm."
+-  // Send INIT (level-triggered) interrupt to reset other CPU.
+-  lapicw(ICRHI, apicid<<24);
+-  lapicw(ICRLO, INIT | LEVEL | ASSERT);
+-  microdelay(200);
+-  lapicw(ICRLO, INIT | LEVEL);
+-  microdelay(100);    // should be 10ms, but too slow in Bochs!
+-
+-  // Send startup IPI (twice!) to enter code.
+-  // Regular hardware is supposed to only accept a STARTUP
+-  // when it is in the halted state due to an INIT.  So the second
+-  // should be ignored, but it is part of the official Intel algorithm.
+-  // Bochs complains about the second one.  Too bad for Bochs.
+-  for(i = 0; i < 2; i++){
+-    lapicw(ICRHI, apicid<<24);
+-    lapicw(ICRLO, STARTUP | (addr>>12));
+-    microdelay(200);
+-  }
+-}
+-
+-#define CMOS_STATA   0x0a
+-#define CMOS_STATB   0x0b
+-#define CMOS_UIP    (1 << 7)        // RTC update in progress
+-
+-#define SECS    0x00
+-#define MINS    0x02
+-#define HOURS   0x04
+-#define DAY     0x07
+-#define MONTH   0x08
+-#define YEAR    0x09
+-
+-static uint
+-cmos_read(uint reg)
+-{
+-  outb(CMOS_PORT,  reg);
+-  microdelay(200);
+-
+-  return inb(CMOS_RETURN);
+-}
+-
+-static void
+-fill_rtcdate(struct rtcdate *r)
+-{
+-  r->second = cmos_read(SECS);
+-  r->minute = cmos_read(MINS);
+-  r->hour   = cmos_read(HOURS);
+-  r->day    = cmos_read(DAY);
+-  r->month  = cmos_read(MONTH);
+-  r->year   = cmos_read(YEAR);
+-}
+-
+-// qemu seems to use 24-hour GWT and the values are BCD encoded
+-void
+-cmostime(struct rtcdate *r)
+-{
+-  struct rtcdate t1, t2;
+-  int sb, bcd;
+-
+-  sb = cmos_read(CMOS_STATB);
+-
+-  bcd = (sb & (1 << 2)) == 0;
+-
+-  // make sure CMOS doesn't modify time while we read it
+-  for(;;) {
+-    fill_rtcdate(&t1);
+-    if(cmos_read(CMOS_STATA) & CMOS_UIP)
+-        continue;
+-    fill_rtcdate(&t2);
+-    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
+-      break;
+-  }
+-
+-  // convert
+-  if(bcd) {
+-#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
+-    CONV(second);
+-    CONV(minute);
+-    CONV(hour  );
+-    CONV(day   );
+-    CONV(month );
+-    CONV(year  );
+-#undef     CONV
+-  }
+-
+-  *r = t1;
+-  r->year += 2000;
+-}
+diff --git a/ln.c b/ln.c
+deleted file mode 100644
+index fb17c3b..0000000
+--- a/ln.c
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  if(argc != 3){
+-    printf(2, "Usage: ln old new\n");
+-    exit(1);
+-  }
+-  if(link(argv[1], argv[2]) < 0)
+-    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+-  exit(0);
+-}
+diff --git a/log.c b/log.c
+deleted file mode 100644
+index a64c0f6..0000000
+--- a/log.c
++++ /dev/null
+@@ -1,234 +0,0 @@
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "buf.h"
+-
+-// Simple logging that allows concurrent FS system calls.
+-//
+-// A log transaction contains the updates of multiple FS system
+-// calls. The logging system only commits when there are
+-// no FS system calls active. Thus there is never
+-// any reasoning required about whether a commit might
+-// write an uncommitted system call's updates to disk.
+-//
+-// A system call should call begin_op()/end_op() to mark
+-// its start and end. Usually begin_op() just increments
+-// the count of in-progress FS system calls and returns.
+-// But if it thinks the log is close to running out, it
+-// sleeps until the last outstanding end_op() commits.
+-//
+-// The log is a physical re-do log containing disk blocks.
+-// The on-disk log format:
+-//   header block, containing block #s for block A, B, C, ...
+-//   block A
+-//   block B
+-//   block C
+-//   ...
+-// Log appends are synchronous.
+-
+-// Contents of the header block, used for both the on-disk header block
+-// and to keep track in memory of logged block# before commit.
+-struct logheader {
+-  int n;
+-  int block[LOGSIZE];
+-};
+-
+-struct log {
+-  struct spinlock lock;
+-  int start;
+-  int size;
+-  int outstanding; // how many FS sys calls are executing.
+-  int committing;  // in commit(), please wait.
+-  int dev;
+-  struct logheader lh;
+-};
+-struct log log;
+-
+-static void recover_from_log(void);
+-static void commit();
+-
+-void
+-initlog(int dev)
+-{
+-  if (sizeof(struct logheader) >= BSIZE)
+-    panic("initlog: too big logheader");
+-
+-  struct superblock sb;
+-  initlock(&log.lock, "log");
+-  readsb(dev, &sb);
+-  log.start = sb.logstart;
+-  log.size = sb.nlog;
+-  log.dev = dev;
+-  recover_from_log();
+-}
+-
+-// Copy committed blocks from log to their home location
+-static void
+-install_trans(void)
+-{
+-  int tail;
+-
+-  for (tail = 0; tail < log.lh.n; tail++) {
+-    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
+-    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+-    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+-    bwrite(dbuf);  // write dst to disk
+-    brelse(lbuf);
+-    brelse(dbuf);
+-  }
+-}
+-
+-// Read the log header from disk into the in-memory log header
+-static void
+-read_head(void)
+-{
+-  struct buf *buf = bread(log.dev, log.start);
+-  struct logheader *lh = (struct logheader *) (buf->data);
+-  int i;
+-  log.lh.n = lh->n;
+-  for (i = 0; i < log.lh.n; i++) {
+-    log.lh.block[i] = lh->block[i];
+-  }
+-  brelse(buf);
+-}
+-
+-// Write in-memory log header to disk.
+-// This is the true point at which the
+-// current transaction commits.
+-static void
+-write_head(void)
+-{
+-  struct buf *buf = bread(log.dev, log.start);
+-  struct logheader *hb = (struct logheader *) (buf->data);
+-  int i;
+-  hb->n = log.lh.n;
+-  for (i = 0; i < log.lh.n; i++) {
+-    hb->block[i] = log.lh.block[i];
+-  }
+-  bwrite(buf);
+-  brelse(buf);
+-}
+-
+-static void
+-recover_from_log(void)
+-{
+-  read_head();
+-  install_trans(); // if committed, copy from log to disk
+-  log.lh.n = 0;
+-  write_head(); // clear the log
+-}
+-
+-// called at the start of each FS system call.
+-void
+-begin_op(void)
+-{
+-  acquire(&log.lock);
+-  while(1){
+-    if(log.committing){
+-      sleep(&log, &log.lock);
+-    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
+-      // this op might exhaust log space; wait for commit.
+-      sleep(&log, &log.lock);
+-    } else {
+-      log.outstanding += 1;
+-      release(&log.lock);
+-      break;
+-    }
+-  }
+-}
+-
+-// called at the end of each FS system call.
+-// commits if this was the last outstanding operation.
+-void
+-end_op(void)
+-{
+-  int do_commit = 0;
+-
+-  acquire(&log.lock);
+-  log.outstanding -= 1;
+-  if(log.committing)
+-    panic("log.committing");
+-  if(log.outstanding == 0){
+-    do_commit = 1;
+-    log.committing = 1;
+-  } else {
+-    // begin_op() may be waiting for log space,
+-    // and decrementing log.outstanding has decreased
+-    // the amount of reserved space.
+-    wakeup(&log);
+-  }
+-  release(&log.lock);
+-
+-  if(do_commit){
+-    // call commit w/o holding locks, since not allowed
+-    // to sleep with locks.
+-    commit();
+-    acquire(&log.lock);
+-    log.committing = 0;
+-    wakeup(&log);
+-    release(&log.lock);
+-  }
+-}
+-
+-// Copy modified blocks from cache to log.
+-static void
+-write_log(void)
+-{
+-  int tail;
+-
+-  for (tail = 0; tail < log.lh.n; tail++) {
+-    struct buf *to = bread(log.dev, log.start+tail+1); // log block
+-    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+-    memmove(to->data, from->data, BSIZE);
+-    bwrite(to);  // write the log
+-    brelse(from);
+-    brelse(to);
+-  }
+-}
+-
+-static void
+-commit()
+-{
+-  if (log.lh.n > 0) {
+-    write_log();     // Write modified blocks from cache to log
+-    write_head();    // Write header to disk -- the real commit
+-    install_trans(); // Now install writes to home locations
+-    log.lh.n = 0;
+-    write_head();    // Erase the transaction from the log
+-  }
+-}
+-
+-// Caller has modified b->data and is done with the buffer.
+-// Record the block number and pin in the cache with B_DIRTY.
+-// commit()/write_log() will do the disk write.
+-//
+-// log_write() replaces bwrite(); a typical use is:
+-//   bp = bread(...)
+-//   modify bp->data[]
+-//   log_write(bp)
+-//   brelse(bp)
+-void
+-log_write(struct buf *b)
+-{
+-  int i;
+-
+-  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+-    panic("too big a transaction");
+-  if (log.outstanding < 1)
+-    panic("log_write outside of trans");
+-
+-  acquire(&log.lock);
+-  for (i = 0; i < log.lh.n; i++) {
+-    if (log.lh.block[i] == b->blockno)   // log absorbtion
+-      break;
+-  }
+-  log.lh.block[i] = b->blockno;
+-  if (i == log.lh.n)
+-    log.lh.n++;
+-  b->flags |= B_DIRTY; // prevent eviction
+-  release(&log.lock);
+-}
+-
+diff --git a/ls.c b/ls.c
+deleted file mode 100644
+index 6bf943b..0000000
+--- a/ls.c
++++ /dev/null
+@@ -1,85 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-#include "fs.h"
+-
+-char*
+-fmtname(char *path)
+-{
+-  static char buf[DIRSIZ+1];
+-  char *p;
+-
+-  // Find first character after last slash.
+-  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+-    ;
+-  p++;
+-
+-  // Return blank-padded name.
+-  if(strlen(p) >= DIRSIZ)
+-    return p;
+-  memmove(buf, p, strlen(p));
+-  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+-  return buf;
+-}
+-
+-void
+-ls(char *path)
+-{
+-  char buf[512], *p;
+-  int fd;
+-  struct dirent de;
+-  struct stat st;
+-
+-  if((fd = open(path, 0)) < 0){
+-    printf(2, "ls: cannot open %s\n", path);
+-    return;
+-  }
+-
+-  if(fstat(fd, &st) < 0){
+-    printf(2, "ls: cannot stat %s\n", path);
+-    close(fd);
+-    return;
+-  }
+-
+-  switch(st.type){
+-  case T_FILE:
+-    printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
+-    break;
+-
+-  case T_DIR:
+-    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+-      printf(1, "ls: path too long\n");
+-      break;
+-    }
+-    strcpy(buf, path);
+-    p = buf+strlen(buf);
+-    *p++ = '/';
+-    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+-      if(de.inum == 0)
+-        continue;
+-      memmove(p, de.name, DIRSIZ);
+-      p[DIRSIZ] = 0;
+-      if(stat(buf, &st) < 0){
+-        printf(1, "ls: cannot stat %s\n", buf);
+-        continue;
+-      }
+-      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
+-    }
+-    break;
+-  }
+-  close(fd);
+-}
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int i;
+-
+-  if(argc < 2){
+-    ls(".");
+-    exit(1);
+-  }
+-  for(i=1; i<argc; i++)
+-    ls(argv[i]);
+-  exit(0);
+-}
+diff --git a/main.c b/main.c
+deleted file mode 100644
+index 9924e64..0000000
+--- a/main.c
++++ /dev/null
+@@ -1,116 +0,0 @@
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-
+-static void startothers(void);
+-static void mpmain(void)  __attribute__((noreturn));
+-extern pde_t *kpgdir;
+-extern char end[]; // first address after kernel loaded from ELF file
+-
+-// Bootstrap processor starts running C code here.
+-// Allocate a real stack and switch to it, first
+-// doing some setup required for memory allocator to work.
+-int
+-main(void)
+-{
+-  kinit1(end, P2V(4*1024*1024)); // phys page allocator
+-  kvmalloc();      // kernel page table
+-  mpinit();        // detect other processors
+-  lapicinit();     // interrupt controller
+-  seginit();       // segment descriptors
+-  picinit();       // disable pic
+-  ioapicinit();    // another interrupt controller
+-  consoleinit();   // console hardware
+-  uartinit();      // serial port
+-  pinit();         // process table
+-  tvinit();        // trap vectors
+-  binit();         // buffer cache
+-  fileinit();      // file table
+-  ideinit();       // disk 
+-  startothers();   // start other processors
+-  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+-  userinit();      // first user process
+-  mpmain();        // finish this processor's setup
+-}
+-
+-// Other CPUs jump here from entryother.S.
+-static void
+-mpenter(void)
+-{
+-  switchkvm();
+-  seginit();
+-  lapicinit();
+-  mpmain();
+-}
+-
+-// Common CPU setup code.
+-static void
+-mpmain(void)
+-{
+-  cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
+-  idtinit();       // load idt register
+-  xchg(&(mycpu()->started), 1); // tell startothers() we're up
+-  scheduler();     // start running processes
+-}
+-
+-pde_t entrypgdir[];  // For entry.S
+-
+-// Start the non-boot (AP) processors.
+-static void
+-startothers(void)
+-{
+-  extern uchar _binary_entryother_start[], _binary_entryother_size[];
+-  uchar *code;
+-  struct cpu *c;
+-  char *stack;
+-
+-  // Write entry code to unused memory at 0x7000.
+-  // The linker has placed the image of entryother.S in
+-  // _binary_entryother_start.
+-  code = P2V(0x7000);
+-  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+-
+-  for(c = cpus; c < cpus+ncpu; c++){
+-    if(c == mycpu())  // We've started already.
+-      continue;
+-
+-    // Tell entryother.S what stack to use, where to enter, and what
+-    // pgdir to use. We cannot use kpgdir yet, because the AP processor
+-    // is running in low  memory, so we use entrypgdir for the APs too.
+-    stack = kalloc();
+-    *(void**)(code-4) = stack + KSTACKSIZE;
+-    *(void(**)(void))(code-8) = mpenter;
+-    *(int**)(code-12) = (void *) V2P(entrypgdir);
+-
+-    lapicstartap(c->apicid, V2P(code));
+-
+-    // wait for cpu to finish mpmain()
+-    while(c->started == 0)
+-      ;
+-  }
+-}
+-
+-// The boot page table used in entry.S and entryother.S.
+-// Page directories (and page tables) must start on page boundaries,
+-// hence the __aligned__ attribute.
+-// PTE_PS in a page directory entry enables 4Mbyte pages.
+-
+-__attribute__((__aligned__(PGSIZE)))
+-pde_t entrypgdir[NPDENTRIES] = {
+-  // Map VA's [0, 4MB) to PA's [0, 4MB)
+-  [0] = (0) | PTE_P | PTE_W | PTE_PS,
+-  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
+-  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
+-};
+-
+-//PAGEBREAK!
+-// Blank page.
+-//PAGEBREAK!
+-// Blank page.
+-//PAGEBREAK!
+-// Blank page.
+-
+diff --git a/memide.c b/memide.c
+deleted file mode 100644
+index ba267ac..0000000
+--- a/memide.c
++++ /dev/null
+@@ -1,60 +0,0 @@
+-// Fake IDE disk; stores blocks in memory.
+-// Useful for running kernel without scratch disk.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-#include "traps.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "buf.h"
+-
+-extern uchar _binary_fs_img_start[], _binary_fs_img_size[];
+-
+-static int disksize;
+-static uchar *memdisk;
+-
+-void
+-ideinit(void)
+-{
+-  memdisk = _binary_fs_img_start;
+-  disksize = (uint)_binary_fs_img_size/BSIZE;
+-}
+-
+-// Interrupt handler.
+-void
+-ideintr(void)
+-{
+-  // no-op
+-}
+-
+-// Sync buf with disk.
+-// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+-// Else if B_VALID is not set, read buf from disk, set B_VALID.
+-void
+-iderw(struct buf *b)
+-{
+-  uchar *p;
+-
+-  if(!holdingsleep(&b->lock))
+-    panic("iderw: buf not locked");
+-  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+-    panic("iderw: nothing to do");
+-  if(b->dev != 1)
+-    panic("iderw: request not for disk 1");
+-  if(b->blockno >= disksize)
+-    panic("iderw: block out of range");
+-
+-  p = memdisk + b->blockno*BSIZE;
+-
+-  if(b->flags & B_DIRTY){
+-    b->flags &= ~B_DIRTY;
+-    memmove(p, b->data, BSIZE);
+-  } else
+-    memmove(b->data, p, BSIZE);
+-  b->flags |= B_VALID;
+-}
+diff --git a/memlayout.h b/memlayout.h
+deleted file mode 100644
+index d1615f7..0000000
+--- a/memlayout.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-// Memory layout
+-
+-#define EXTMEM  0x100000            // Start of extended memory
+-#define PHYSTOP 0xE000000           // Top physical memory
+-#define DEVSPACE 0xFE000000         // Other devices are at high addresses
+-
+-// Key addresses for address space layout (see kmap in vm.c for layout)
+-#define KERNBASE 0x80000000         // First kernel virtual address
+-#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
+-
+-#define V2P(a) (((uint) (a)) - KERNBASE)
+-#define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
+-
+-#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
+-#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts
+diff --git a/mkdir.c b/mkdir.c
+deleted file mode 100644
+index 2d90781..0000000
+--- a/mkdir.c
++++ /dev/null
+@@ -1,23 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int i;
+-
+-  if(argc < 2){
+-    printf(2, "Usage: mkdir files...\n");
+-    exit(1);
+-  }
+-
+-  for(i = 1; i < argc; i++){
+-    if(mkdir(argv[i]) < 0){
+-      printf(2, "mkdir: %s failed to create\n", argv[i]);
+-      break;
+-    }
+-  }
+-
+-  exit(0);
+-}
+diff --git a/mkfs.c b/mkfs.c
+deleted file mode 100644
+index 8e011a7..0000000
+--- a/mkfs.c
++++ /dev/null
+@@ -1,297 +0,0 @@
+-#include <stdio.h>
+-#include <unistd.h>
+-#include <stdlib.h>
+-#include <string.h>
+-#include <fcntl.h>
+-#include <assert.h>
+-
+-#define stat xv6_stat  // avoid clash with host struct stat
+-#include "types.h"
+-#include "fs.h"
+-#include "stat.h"
+-#include "param.h"
+-
+-#ifndef static_assert
+-#define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0)
+-#endif
+-
+-#define NINODES 200
+-
+-// Disk layout:
+-// [ boot block | sb block | log | inode blocks | free bit map | data blocks ]
+-
+-int nbitmap = FSSIZE/(BSIZE*8) + 1;
+-int ninodeblocks = NINODES / IPB + 1;
+-int nlog = LOGSIZE;
+-int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
+-int nblocks;  // Number of data blocks
+-
+-int fsfd;
+-struct superblock sb;
+-char zeroes[BSIZE];
+-uint freeinode = 1;
+-uint freeblock;
+-
+-
+-void balloc(int);
+-void wsect(uint, void*);
+-void winode(uint, struct dinode*);
+-void rinode(uint inum, struct dinode *ip);
+-void rsect(uint sec, void *buf);
+-uint ialloc(ushort type);
+-void iappend(uint inum, void *p, int n);
+-
+-// convert to intel byte order
+-ushort
+-xshort(ushort x)
+-{
+-  ushort y;
+-  uchar *a = (uchar*)&y;
+-  a[0] = x;
+-  a[1] = x >> 8;
+-  return y;
+-}
+-
+-uint
+-xint(uint x)
+-{
+-  uint y;
+-  uchar *a = (uchar*)&y;
+-  a[0] = x;
+-  a[1] = x >> 8;
+-  a[2] = x >> 16;
+-  a[3] = x >> 24;
+-  return y;
+-}
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int i, cc, fd;
+-  uint rootino, inum, off;
+-  struct dirent de;
+-  char buf[BSIZE];
+-  struct dinode din;
+-
+-
+-  static_assert(sizeof(int) == 4, "Integers must be 4 bytes!");
+-
+-  if(argc < 2){
+-    fprintf(stderr, "Usage: mkfs fs.img files...\n");
+-    exit(1);
+-  }
+-
+-  assert((BSIZE % sizeof(struct dinode)) == 0);
+-  assert((BSIZE % sizeof(struct dirent)) == 0);
+-
+-  fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);
+-  if(fsfd < 0){
+-    perror(argv[1]);
+-    exit(1);
+-  }
+-
+-  // 1 fs block = 1 disk sector
+-  nmeta = 2 + nlog + ninodeblocks + nbitmap;
+-  nblocks = FSSIZE - nmeta;
+-
+-  sb.size = xint(FSSIZE);
+-  sb.nblocks = xint(nblocks);
+-  sb.ninodes = xint(NINODES);
+-  sb.nlog = xint(nlog);
+-  sb.logstart = xint(2);
+-  sb.inodestart = xint(2+nlog);
+-  sb.bmapstart = xint(2+nlog+ninodeblocks);
+-
+-  printf("nmeta %d (boot, super, log blocks %u inode blocks %u, bitmap blocks %u) blocks %d total %d\n",
+-         nmeta, nlog, ninodeblocks, nbitmap, nblocks, FSSIZE);
+-
+-  freeblock = nmeta;     // the first free block that we can allocate
+-
+-  for(i = 0; i < FSSIZE; i++)
+-    wsect(i, zeroes);
+-
+-  memset(buf, 0, sizeof(buf));
+-  memmove(buf, &sb, sizeof(sb));
+-  wsect(1, buf);
+-
+-  rootino = ialloc(T_DIR);
+-  assert(rootino == ROOTINO);
+-
+-  bzero(&de, sizeof(de));
+-  de.inum = xshort(rootino);
+-  strcpy(de.name, ".");
+-  iappend(rootino, &de, sizeof(de));
+-
+-  bzero(&de, sizeof(de));
+-  de.inum = xshort(rootino);
+-  strcpy(de.name, "..");
+-  iappend(rootino, &de, sizeof(de));
+-
+-  for(i = 2; i < argc; i++){
+-    assert(index(argv[i], '/') == 0);
+-
+-    if((fd = open(argv[i], 0)) < 0){
+-      perror(argv[i]);
+-      exit(1);
+-    }
+-
+-    // Skip leading _ in name when writing to file system.
+-    // The binaries are named _rm, _cat, etc. to keep the
+-    // build operating system from trying to execute them
+-    // in place of system binaries like rm and cat.
+-    if(argv[i][0] == '_')
+-      ++argv[i];
+-
+-    inum = ialloc(T_FILE);
+-
+-    bzero(&de, sizeof(de));
+-    de.inum = xshort(inum);
+-    strncpy(de.name, argv[i], DIRSIZ);
+-    iappend(rootino, &de, sizeof(de));
+-
+-    while((cc = read(fd, buf, sizeof(buf))) > 0)
+-      iappend(inum, buf, cc);
+-
+-    close(fd);
+-  }
+-
+-  // fix size of root inode dir
+-  rinode(rootino, &din);
+-  off = xint(din.size);
+-  off = ((off/BSIZE) + 1) * BSIZE;
+-  din.size = xint(off);
+-  winode(rootino, &din);
+-
+-  balloc(freeblock);
+-
+-  exit(0);
+-}
+-
+-void
+-wsect(uint sec, void *buf)
+-{
+-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
+-    perror("lseek");
+-    exit(1);
+-  }
+-  if(write(fsfd, buf, BSIZE) != BSIZE){
+-    perror("write");
+-    exit(1);
+-  }
+-}
+-
+-void
+-winode(uint inum, struct dinode *ip)
+-{
+-  char buf[BSIZE];
+-  uint bn;
+-  struct dinode *dip;
+-
+-  bn = IBLOCK(inum, sb);
+-  rsect(bn, buf);
+-  dip = ((struct dinode*)buf) + (inum % IPB);
+-  *dip = *ip;
+-  wsect(bn, buf);
+-}
+-
+-void
+-rinode(uint inum, struct dinode *ip)
+-{
+-  char buf[BSIZE];
+-  uint bn;
+-  struct dinode *dip;
+-
+-  bn = IBLOCK(inum, sb);
+-  rsect(bn, buf);
+-  dip = ((struct dinode*)buf) + (inum % IPB);
+-  *ip = *dip;
+-}
+-
+-void
+-rsect(uint sec, void *buf)
+-{
+-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
+-    perror("lseek");
+-    exit(1);
+-  }
+-  if(read(fsfd, buf, BSIZE) != BSIZE){
+-    perror("read");
+-    exit(1);
+-  }
+-}
+-
+-uint
+-ialloc(ushort type)
+-{
+-  uint inum = freeinode++;
+-  struct dinode din;
+-
+-  bzero(&din, sizeof(din));
+-  din.type = xshort(type);
+-  din.nlink = xshort(1);
+-  din.size = xint(0);
+-  winode(inum, &din);
+-  return inum;
+-}
+-
+-void
+-balloc(int used)
+-{
+-  uchar buf[BSIZE];
+-  int i;
+-
+-  printf("balloc: first %d blocks have been allocated\n", used);
+-  assert(used < BSIZE*8);
+-  bzero(buf, BSIZE);
+-  for(i = 0; i < used; i++){
+-    buf[i/8] = buf[i/8] | (0x1 << (i%8));
+-  }
+-  printf("balloc: write bitmap block at sector %d\n", sb.bmapstart);
+-  wsect(sb.bmapstart, buf);
+-}
+-
+-#define min(a, b) ((a) < (b) ? (a) : (b))
+-
+-void
+-iappend(uint inum, void *xp, int n)
+-{
+-  char *p = (char*)xp;
+-  uint fbn, off, n1;
+-  struct dinode din;
+-  char buf[BSIZE];
+-  uint indirect[NINDIRECT];
+-  uint x;
+-
+-  rinode(inum, &din);
+-  off = xint(din.size);
+-  // printf("append inum %d at off %d sz %d\n", inum, off, n);
+-  while(n > 0){
+-    fbn = off / BSIZE;
+-    assert(fbn < MAXFILE);
+-    if(fbn < NDIRECT){
+-      if(xint(din.addrs[fbn]) == 0){
+-        din.addrs[fbn] = xint(freeblock++);
+-      }
+-      x = xint(din.addrs[fbn]);
+-    } else {
+-      if(xint(din.addrs[NDIRECT]) == 0){
+-        din.addrs[NDIRECT] = xint(freeblock++);
+-      }
+-      rsect(xint(din.addrs[NDIRECT]), (char*)indirect);
+-      if(indirect[fbn - NDIRECT] == 0){
+-        indirect[fbn - NDIRECT] = xint(freeblock++);
+-        wsect(xint(din.addrs[NDIRECT]), (char*)indirect);
+-      }
+-      x = xint(indirect[fbn-NDIRECT]);
+-    }
+-    n1 = min(n, (fbn + 1) * BSIZE - off);
+-    rsect(x, buf);
+-    bcopy(p, buf + off - (fbn * BSIZE), n1);
+-    wsect(x, buf);
+-    n -= n1;
+-    off += n1;
+-    p += n1;
+-  }
+-  din.size = xint(off);
+-  winode(inum, &din);
+-}
+diff --git a/mmu.h b/mmu.h
+deleted file mode 100644
+index a82d8e2..0000000
+--- a/mmu.h
++++ /dev/null
+@@ -1,181 +0,0 @@
+-// This file contains definitions for the
+-// x86 memory management unit (MMU).
+-
+-// Eflags register
+-#define FL_IF           0x00000200      // Interrupt Enable
+-
+-// Control Register flags
+-#define CR0_PE          0x00000001      // Protection Enable
+-#define CR0_WP          0x00010000      // Write Protect
+-#define CR0_PG          0x80000000      // Paging
+-
+-#define CR4_PSE         0x00000010      // Page size extension
+-
+-// various segment selectors.
+-#define SEG_KCODE 1  // kernel code
+-#define SEG_KDATA 2  // kernel data+stack
+-#define SEG_UCODE 3  // user code
+-#define SEG_UDATA 4  // user data+stack
+-#define SEG_TSS   5  // this process's task state
+-
+-// cpu->gdt[NSEGS] holds the above segments.
+-#define NSEGS     6
+-
+-#ifndef __ASSEMBLER__
+-// Segment Descriptor
+-struct segdesc {
+-  uint lim_15_0 : 16;  // Low bits of segment limit
+-  uint base_15_0 : 16; // Low bits of segment base address
+-  uint base_23_16 : 8; // Middle bits of segment base address
+-  uint type : 4;       // Segment type (see STS_ constants)
+-  uint s : 1;          // 0 = system, 1 = application
+-  uint dpl : 2;        // Descriptor Privilege Level
+-  uint p : 1;          // Present
+-  uint lim_19_16 : 4;  // High bits of segment limit
+-  uint avl : 1;        // Unused (available for software use)
+-  uint rsv1 : 1;       // Reserved
+-  uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
+-  uint g : 1;          // Granularity: limit scaled by 4K when set
+-  uint base_31_24 : 8; // High bits of segment base address
+-};
+-
+-// Normal segment
+-#define SEG(type, base, lim, dpl) (struct segdesc)    \
+-{ ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
+-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
+-  (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
+-#define SEG16(type, base, lim, dpl) (struct segdesc)  \
+-{ (lim) & 0xffff, (uint)(base) & 0xffff,              \
+-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
+-  (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
+-#endif
+-
+-#define DPL_USER    0x3     // User DPL
+-
+-// Application segment type bits
+-#define STA_X       0x8     // Executable segment
+-#define STA_W       0x2     // Writeable (non-executable segments)
+-#define STA_R       0x2     // Readable (executable segments)
+-
+-// System segment type bits
+-#define STS_T32A    0x9     // Available 32-bit TSS
+-#define STS_IG32    0xE     // 32-bit Interrupt Gate
+-#define STS_TG32    0xF     // 32-bit Trap Gate
+-
+-// A virtual address 'la' has a three-part structure as follows:
+-//
+-// +--------10------+-------10-------+---------12----------+
+-// | Page Directory |   Page Table   | Offset within Page  |
+-// |      Index     |      Index     |                     |
+-// +----------------+----------------+---------------------+
+-//  \--- PDX(va) --/ \--- PTX(va) --/
+-
+-// page directory index
+-#define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
+-
+-// page table index
+-#define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
+-
+-// construct virtual address from indexes and offset
+-#define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
+-
+-// Page directory and page table constants.
+-#define NPDENTRIES      1024    // # directory entries per page directory
+-#define NPTENTRIES      1024    // # PTEs per page table
+-#define PGSIZE          4096    // bytes mapped by a page
+-
+-#define PTXSHIFT        12      // offset of PTX in a linear address
+-#define PDXSHIFT        22      // offset of PDX in a linear address
+-
+-#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
+-#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
+-
+-// Page table/directory entry flags.
+-#define PTE_P           0x001   // Present
+-#define PTE_W           0x002   // Writeable
+-#define PTE_U           0x004   // User
+-#define PTE_PS          0x080   // Page Size
+-
+-// Address in page table or page directory entry
+-#define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
+-#define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
+-
+-#ifndef __ASSEMBLER__
+-typedef uint pte_t;
+-
+-// Task state segment format
+-struct taskstate {
+-  uint link;         // Old ts selector
+-  uint esp0;         // Stack pointers and segment selectors
+-  ushort ss0;        //   after an increase in privilege level
+-  ushort padding1;
+-  uint *esp1;
+-  ushort ss1;
+-  ushort padding2;
+-  uint *esp2;
+-  ushort ss2;
+-  ushort padding3;
+-  void *cr3;         // Page directory base
+-  uint *eip;         // Saved state from last task switch
+-  uint eflags;
+-  uint eax;          // More saved state (registers)
+-  uint ecx;
+-  uint edx;
+-  uint ebx;
+-  uint *esp;
+-  uint *ebp;
+-  uint esi;
+-  uint edi;
+-  ushort es;         // Even more saved state (segment selectors)
+-  ushort padding4;
+-  ushort cs;
+-  ushort padding5;
+-  ushort ss;
+-  ushort padding6;
+-  ushort ds;
+-  ushort padding7;
+-  ushort fs;
+-  ushort padding8;
+-  ushort gs;
+-  ushort padding9;
+-  ushort ldt;
+-  ushort padding10;
+-  ushort t;          // Trap on task switch
+-  ushort iomb;       // I/O map base address
+-};
+-
+-// Gate descriptors for interrupts and traps
+-struct gatedesc {
+-  uint off_15_0 : 16;   // low 16 bits of offset in segment
+-  uint cs : 16;         // code segment selector
+-  uint args : 5;        // # args, 0 for interrupt/trap gates
+-  uint rsv1 : 3;        // reserved(should be zero I guess)
+-  uint type : 4;        // type(STS_{IG32,TG32})
+-  uint s : 1;           // must be 0 (system)
+-  uint dpl : 2;         // descriptor(meaning new) privilege level
+-  uint p : 1;           // Present
+-  uint off_31_16 : 16;  // high bits of offset in segment
+-};
+-
+-// Set up a normal interrupt/trap gate descriptor.
+-// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
+-//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
+-// - sel: Code segment selector for interrupt/trap handler
+-// - off: Offset in code segment for interrupt/trap handler
+-// - dpl: Descriptor Privilege Level -
+-//        the privilege level required for software to invoke
+-//        this interrupt/trap gate explicitly using an int instruction.
+-#define SETGATE(gate, istrap, sel, off, d)                \
+-{                                                         \
+-  (gate).off_15_0 = (uint)(off) & 0xffff;                \
+-  (gate).cs = (sel);                                      \
+-  (gate).args = 0;                                        \
+-  (gate).rsv1 = 0;                                        \
+-  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
+-  (gate).s = 0;                                           \
+-  (gate).dpl = (d);                                       \
+-  (gate).p = 1;                                           \
+-  (gate).off_31_16 = (uint)(off) >> 16;                  \
+-}
+-
+-#endif
+diff --git a/mp.c b/mp.c
+deleted file mode 100644
+index 79bb0ad..0000000
+--- a/mp.c
++++ /dev/null
+@@ -1,139 +0,0 @@
+-// Multiprocessor support
+-// Search memory for MP description structures.
+-// http://developer.intel.com/design/pentium/datashts/24201606.pdf
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mp.h"
+-#include "x86.h"
+-#include "mmu.h"
+-#include "proc.h"
+-
+-struct cpu cpus[NCPU];
+-int ncpu;
+-uchar ioapicid;
+-
+-static uchar
+-sum(uchar *addr, int len)
+-{
+-  int i, sum;
+-
+-  sum = 0;
+-  for(i=0; i<len; i++)
+-    sum += addr[i];
+-  return sum;
+-}
+-
+-// Look for an MP structure in the len bytes at addr.
+-static struct mp*
+-mpsearch1(uint a, int len)
+-{
+-  uchar *e, *p, *addr;
+-
+-  addr = P2V(a);
+-  e = addr+len;
+-  for(p = addr; p < e; p += sizeof(struct mp))
+-    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+-      return (struct mp*)p;
+-  return 0;
+-}
+-
+-// Search for the MP Floating Pointer Structure, which according to the
+-// spec is in one of the following three locations:
+-// 1) in the first KB of the EBDA;
+-// 2) in the last KB of system base memory;
+-// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
+-static struct mp*
+-mpsearch(void)
+-{
+-  uchar *bda;
+-  uint p;
+-  struct mp *mp;
+-
+-  bda = (uchar *) P2V(0x400);
+-  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
+-    if((mp = mpsearch1(p, 1024)))
+-      return mp;
+-  } else {
+-    p = ((bda[0x14]<<8)|bda[0x13])*1024;
+-    if((mp = mpsearch1(p-1024, 1024)))
+-      return mp;
+-  }
+-  return mpsearch1(0xF0000, 0x10000);
+-}
+-
+-// Search for an MP configuration table.  For now,
+-// don't accept the default configurations (physaddr == 0).
+-// Check for correct signature, calculate the checksum and,
+-// if correct, check the version.
+-// To do: check extended table checksum.
+-static struct mpconf*
+-mpconfig(struct mp **pmp)
+-{
+-  struct mpconf *conf;
+-  struct mp *mp;
+-
+-  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+-    return 0;
+-  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+-  if(memcmp(conf, "PCMP", 4) != 0)
+-    return 0;
+-  if(conf->version != 1 && conf->version != 4)
+-    return 0;
+-  if(sum((uchar*)conf, conf->length) != 0)
+-    return 0;
+-  *pmp = mp;
+-  return conf;
+-}
+-
+-void
+-mpinit(void)
+-{
+-  uchar *p, *e;
+-  int ismp;
+-  struct mp *mp;
+-  struct mpconf *conf;
+-  struct mpproc *proc;
+-  struct mpioapic *ioapic;
+-
+-  if((conf = mpconfig(&mp)) == 0)
+-    panic("Expect to run on an SMP");
+-  ismp = 1;
+-  lapic = (uint*)conf->lapicaddr;
+-  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+-    switch(*p){
+-    case MPPROC:
+-      proc = (struct mpproc*)p;
+-      if(ncpu < NCPU) {
+-        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+-        ncpu++;
+-      }
+-      p += sizeof(struct mpproc);
+-      continue;
+-    case MPIOAPIC:
+-      ioapic = (struct mpioapic*)p;
+-      ioapicid = ioapic->apicno;
+-      p += sizeof(struct mpioapic);
+-      continue;
+-    case MPBUS:
+-    case MPIOINTR:
+-    case MPLINTR:
+-      p += 8;
+-      continue;
+-    default:
+-      ismp = 0;
+-      break;
+-    }
+-  }
+-  if(!ismp)
+-    panic("Didn't find a suitable machine");
+-
+-  if(mp->imcrp){
+-    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
+-    // But it would on real hardware.
+-    outb(0x22, 0x70);   // Select IMCR
+-    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
+-  }
+-}
+diff --git a/mp.h b/mp.h
+deleted file mode 100644
+index 4d17283..0000000
+--- a/mp.h
++++ /dev/null
+@@ -1,56 +0,0 @@
+-// See MultiProcessor Specification Version 1.[14]
+-
+-struct mp {             // floating pointer
+-  uchar signature[4];           // "_MP_"
+-  void *physaddr;               // phys addr of MP config table
+-  uchar length;                 // 1
+-  uchar specrev;                // [14]
+-  uchar checksum;               // all bytes must add up to 0
+-  uchar type;                   // MP system config type
+-  uchar imcrp;
+-  uchar reserved[3];
+-};
+-
+-struct mpconf {         // configuration table header
+-  uchar signature[4];           // "PCMP"
+-  ushort length;                // total table length
+-  uchar version;                // [14]
+-  uchar checksum;               // all bytes must add up to 0
+-  uchar product[20];            // product id
+-  uint *oemtable;               // OEM table pointer
+-  ushort oemlength;             // OEM table length
+-  ushort entry;                 // entry count
+-  uint *lapicaddr;              // address of local APIC
+-  ushort xlength;               // extended table length
+-  uchar xchecksum;              // extended table checksum
+-  uchar reserved;
+-};
+-
+-struct mpproc {         // processor table entry
+-  uchar type;                   // entry type (0)
+-  uchar apicid;                 // local APIC id
+-  uchar version;                // local APIC verison
+-  uchar flags;                  // CPU flags
+-    #define MPBOOT 0x02           // This proc is the bootstrap processor.
+-  uchar signature[4];           // CPU signature
+-  uint feature;                 // feature flags from CPUID instruction
+-  uchar reserved[8];
+-};
+-
+-struct mpioapic {       // I/O APIC table entry
+-  uchar type;                   // entry type (2)
+-  uchar apicno;                 // I/O APIC id
+-  uchar version;                // I/O APIC version
+-  uchar flags;                  // I/O APIC flags
+-  uint *addr;                  // I/O APIC address
+-};
+-
+-// Table entry types
+-#define MPPROC    0x00  // One per processor
+-#define MPBUS     0x01  // One per bus
+-#define MPIOAPIC  0x02  // One per I/O APIC
+-#define MPIOINTR  0x03  // One per bus interrupt source
+-#define MPLINTR   0x04  // One per system interrupt source
+-
+-//PAGEBREAK!
+-// Blank page.
+diff --git a/param.h b/param.h
+deleted file mode 100644
+index a7e90ef..0000000
+--- a/param.h
++++ /dev/null
+@@ -1,14 +0,0 @@
+-#define NPROC        64  // maximum number of processes
+-#define KSTACKSIZE 4096  // size of per-process kernel stack
+-#define NCPU          8  // maximum number of CPUs
+-#define NOFILE       16  // open files per process
+-#define NFILE       100  // open files per system
+-#define NINODE       50  // maximum number of active i-nodes
+-#define NDEV         10  // maximum major device number
+-#define ROOTDEV       1  // device number of file system root disk
+-#define MAXARG       32  // max exec arguments
+-#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
+-#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
+-#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
+-#define FSSIZE       1000  // size of file system in blocks
+-
+diff --git a/picirq.c b/picirq.c
+deleted file mode 100644
+index e26957f..0000000
+--- a/picirq.c
++++ /dev/null
+@@ -1,19 +0,0 @@
+-#include "types.h"
+-#include "x86.h"
+-#include "traps.h"
+-
+-// I/O Addresses of the two programmable interrupt controllers
+-#define IO_PIC1         0x20    // Master (IRQs 0-7)
+-#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
+-
+-// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
+-void
+-picinit(void)
+-{
+-  // mask all interrupts
+-  outb(IO_PIC1+1, 0xFF);
+-  outb(IO_PIC2+1, 0xFF);
+-}
+-
+-//PAGEBREAK!
+-// Blank page.
+diff --git a/pipe.c b/pipe.c
+deleted file mode 100644
+index e9abe7f..0000000
+--- a/pipe.c
++++ /dev/null
+@@ -1,121 +0,0 @@
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "fs.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "file.h"
+-
+-#define PIPESIZE 512
+-
+-struct pipe {
+-  struct spinlock lock;
+-  char data[PIPESIZE];
+-  uint nread;     // number of bytes read
+-  uint nwrite;    // number of bytes written
+-  int readopen;   // read fd is still open
+-  int writeopen;  // write fd is still open
+-};
+-
+-int
+-pipealloc(struct file **f0, struct file **f1)
+-{
+-  struct pipe *p;
+-
+-  p = 0;
+-  *f0 = *f1 = 0;
+-  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
+-    goto bad;
+-  if((p = (struct pipe*)kalloc()) == 0)
+-    goto bad;
+-  p->readopen = 1;
+-  p->writeopen = 1;
+-  p->nwrite = 0;
+-  p->nread = 0;
+-  initlock(&p->lock, "pipe");
+-  (*f0)->type = FD_PIPE;
+-  (*f0)->readable = 1;
+-  (*f0)->writable = 0;
+-  (*f0)->pipe = p;
+-  (*f1)->type = FD_PIPE;
+-  (*f1)->readable = 0;
+-  (*f1)->writable = 1;
+-  (*f1)->pipe = p;
+-  return 0;
+-
+-//PAGEBREAK: 20
+- bad:
+-  if(p)
+-    kfree((char*)p);
+-  if(*f0)
+-    fileclose(*f0);
+-  if(*f1)
+-    fileclose(*f1);
+-  return -1;
+-}
+-
+-void
+-pipeclose(struct pipe *p, int writable)
+-{
+-  acquire(&p->lock);
+-  if(writable){
+-    p->writeopen = 0;
+-    wakeup(&p->nread);
+-  } else {
+-    p->readopen = 0;
+-    wakeup(&p->nwrite);
+-  }
+-  if(p->readopen == 0 && p->writeopen == 0){
+-    release(&p->lock);
+-    kfree((char*)p);
+-  } else
+-    release(&p->lock);
+-}
+-
+-//PAGEBREAK: 40
+-int
+-pipewrite(struct pipe *p, char *addr, int n)
+-{
+-  int i;
+-
+-  acquire(&p->lock);
+-  for(i = 0; i < n; i++){
+-    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+-      if(p->readopen == 0 || myproc()->killed){
+-        release(&p->lock);
+-        return -1;
+-      }
+-      wakeup(&p->nread);
+-      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+-    }
+-    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+-  }
+-  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+-  release(&p->lock);
+-  return n;
+-}
+-
+-int
+-piperead(struct pipe *p, char *addr, int n)
+-{
+-  int i;
+-
+-  acquire(&p->lock);
+-  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+-    if(myproc()->killed){
+-      release(&p->lock);
+-      return -1;
+-    }
+-    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+-  }
+-  for(i = 0; i < n; i++){  //DOC: piperead-copy
+-    if(p->nread == p->nwrite)
+-      break;
+-    addr[i] = p->data[p->nread++ % PIPESIZE];
+-  }
+-  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+-  release(&p->lock);
+-  return i;
+-}
+diff --git a/pr.pl b/pr.pl
+deleted file mode 100644
+index 46905bd..0000000
+--- a/pr.pl
++++ /dev/null
+@@ -1,36 +0,0 @@
+-#!/usr/bin/perl
+-
+-use POSIX qw(strftime);
+-
+-if($ARGV[0] eq "-h"){
+-	shift @ARGV;
+-	$h = $ARGV[0];
+-	shift @ARGV;
+-}else{
+-	$h = $ARGV[0];
+-}
+-
+-$page = 0;
+-$now = strftime "%b %e %H:%M %Y", localtime;
+-
+-@lines = <>;
+-for($i=0; $i<@lines; $i+=50){
+-	print "\n\n";
+-	++$page;
+-	print "$now  $h  Page $page\n";
+-	print "\n\n";
+-	for($j=$i; $j<@lines && $j<$i +50; $j++){
+-		$lines[$j] =~ s!//DOC.*!!;
+-		print $lines[$j];
+-	}
+-	for(; $j<$i+50; $j++){
+-		print "\n";
+-	}
+-	$sheet = "";
+-	if($lines[$i] =~ /^([0-9][0-9])[0-9][0-9] /){
+-		$sheet = "Sheet $1";
+-	}
+-	print "\n\n";
+-	print "$sheet\n";
+-	print "\n\n";
+-}
+diff --git a/printf.c b/printf.c
+deleted file mode 100644
+index b3298aa..0000000
+--- a/printf.c
++++ /dev/null
+@@ -1,85 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-static void
+-putc(int fd, char c)
+-{
+-  write(fd, &c, 1);
+-}
+-
+-static void
+-printint(int fd, int xx, int base, int sgn)
+-{
+-  static char digits[] = "0123456789ABCDEF";
+-  char buf[16];
+-  int i, neg;
+-  uint x;
+-
+-  neg = 0;
+-  if(sgn && xx < 0){
+-    neg = 1;
+-    x = -xx;
+-  } else {
+-    x = xx;
+-  }
+-
+-  i = 0;
+-  do{
+-    buf[i++] = digits[x % base];
+-  }while((x /= base) != 0);
+-  if(neg)
+-    buf[i++] = '-';
+-
+-  while(--i >= 0)
+-    putc(fd, buf[i]);
+-}
+-
+-// Print to the given fd. Only understands %d, %x, %p, %s.
+-void
+-printf(int fd, const char *fmt, ...)
+-{
+-  char *s;
+-  int c, i, state;
+-  uint *ap;
+-
+-  state = 0;
+-  ap = (uint*)(void*)&fmt + 1;
+-  for(i = 0; fmt[i]; i++){
+-    c = fmt[i] & 0xff;
+-    if(state == 0){
+-      if(c == '%'){
+-        state = '%';
+-      } else {
+-        putc(fd, c);
+-      }
+-    } else if(state == '%'){
+-      if(c == 'd'){
+-        printint(fd, *ap, 10, 1);
+-        ap++;
+-      } else if(c == 'x' || c == 'p'){
+-        printint(fd, *ap, 16, 0);
+-        ap++;
+-      } else if(c == 's'){
+-        s = (char*)*ap;
+-        ap++;
+-        if(s == 0)
+-          s = "(null)";
+-        while(*s != 0){
+-          putc(fd, *s);
+-          s++;
+-        }
+-      } else if(c == 'c'){
+-        putc(fd, *ap);
+-        ap++;
+-      } else if(c == '%'){
+-        putc(fd, c);
+-      } else {
+-        // Unknown % sequence.  Print it to draw attention.
+-        putc(fd, '%');
+-        putc(fd, c);
+-      }
+-      state = 0;
+-    }
+-  }
+-}
+diff --git a/printpcs b/printpcs
+deleted file mode 100644
+index 81d039b..0000000
+--- a/printpcs
++++ /dev/null
+@@ -1,14 +0,0 @@
+-#!/bin/sh
+-
+-# Decode the symbols from a panic EIP list
+-
+-# Find a working addr2line
+-for p in i386-jos-elf-addr2line addr2line; do
+-    if which $p 2>&1 >/dev/null && \
+-       $p -h 2>&1 | grep -q '\belf32-i386\b'; then
+-        break
+-    fi
+-done
+-
+-# Enable as much pretty-printing as this addr2line can do
+-$p $($p -h | grep ' -[aipsf] ' | awk '{print $1}') -e kernel "$@"
+diff --git a/proc.c b/proc.c
+deleted file mode 100644
+index 84b335f..0000000
+--- a/proc.c
++++ /dev/null
+@@ -1,577 +0,0 @@
+-#include <stddef.h>
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "x86.h"
+-#include "proc.h"
+-#include "spinlock.h"
+-
+-struct {
+-    struct spinlock lock;
+-    struct proc proc[NPROC];
+-} ptable;
+-
+-static struct proc *initproc;
+-
+-int nextpid = 1;
+-
+-extern void forkret(void);
+-
+-extern void trapret(void);
+-
+-static void wakeup1(void *chan);
+-
+-void
+-pinit(void) {
+-    initlock(&ptable.lock, "ptable");
+-}
+-
+-// Must be called with interrupts disabled
+-int
+-cpuid() {
+-    return mycpu() - cpus;
+-}
+-
+-// Must be called with interrupts disabled to avoid the caller being
+-// rescheduled between reading lapicid and running through the loop.
+-struct cpu *
+-mycpu(void) {
+-    int apicid, i;
+-
+-    if (readeflags() & FL_IF)
+-        panic("mycpu called with interrupts enabled\n");
+-
+-    apicid = lapicid();
+-    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+-    // a reverse map, or reserve a register to store &cpus[i].
+-    for (i = 0; i < ncpu; ++i) {
+-        if (cpus[i].apicid == apicid)
+-            return &cpus[i];
+-    }
+-    panic("unknown apicid\n");
+-}
+-
+-// Disable interrupts so that we are not rescheduled
+-// while reading proc from the cpu structure
+-struct proc *
+-myproc(void) {
+-    struct cpu *c;
+-    struct proc *p;
+-    pushcli();
+-    c = mycpu();
+-    p = c->proc;
+-    popcli();
+-    return p;
+-}
+-
+-//PAGEBREAK: 32
+-// Look in the process table for an UNUSED proc.
+-// If found, change state to EMBRYO and initialize
+-// state required to run in the kernel.
+-// Otherwise return 0.
+-static struct proc *
+-allocproc(void) {
+-    struct proc *p;
+-    char *sp;
+-
+-    acquire(&ptable.lock);
+-
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-        if (p->state == UNUSED)
+-            goto found;
+-
+-    release(&ptable.lock);
+-    return 0;
+-
+-    found:
+-    p->state = EMBRYO;
+-    p->pid = nextpid++;
+-
+-    release(&ptable.lock);
+-
+-    // Allocate kernel stack.
+-    if ((p->kstack = kalloc()) == 0) {
+-        p->state = UNUSED;
+-        return 0;
+-    }
+-    sp = p->kstack + KSTACKSIZE;
+-
+-    // Leave room for trap frame.
+-    sp -= sizeof *p->tf;
+-    p->tf = (struct trapframe *) sp;
+-
+-    // Set up new context to start executing at forkret,
+-    // which returns to trapret.
+-    sp -= 4;
+-    *(uint *) sp = (uint) trapret;
+-
+-    sp -= sizeof *p->context;
+-    p->context = (struct context *) sp;
+-    memset(p->context, 0, sizeof *p->context);
+-    p->context->eip = (uint) forkret;
+-
+-    return p;
+-}
+-
+-//PAGEBREAK: 32
+-// Set up first user process.
+-void
+-userinit(void) {
+-    struct proc *p;
+-    extern char _binary_initcode_start[], _binary_initcode_size[];
+-
+-    p = allocproc();
+-
+-    initproc = p;
+-    if ((p->pgdir = setupkvm()) == 0)
+-        panic("userinit: out of memory?");
+-    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
+-    p->sz = PGSIZE;
+-    memset(p->tf, 0, sizeof(*p->tf));
+-    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+-    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+-    p->tf->es = p->tf->ds;
+-    p->tf->ss = p->tf->ds;
+-    p->tf->eflags = FL_IF;
+-    p->tf->esp = PGSIZE;
+-    p->tf->eip = 0;  // beginning of initcode.S
+-
+-    safestrcpy(p->name, "initcode", sizeof(p->name));
+-    p->cwd = namei("/");
+-
+-    // this assignment to p->state lets other cores
+-    // run this process. the acquire forces the above
+-    // writes to be visible, and the lock is also needed
+-    // because the assignment might not be atomic.
+-    acquire(&ptable.lock);
+-
+-    p->state = RUNNABLE;
+-
+-    release(&ptable.lock);
+-}
+-
+-// Grow current process's memory by n bytes.
+-// Return 0 on success, -1 on failure.
+-int
+-growproc(int n) {
+-    uint sz;
+-    struct proc *curproc = myproc();
+-
+-    sz = curproc->sz;
+-    if (n > 0) {
+-        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-            return -1;
+-    } else if (n < 0) {
+-        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-            return -1;
+-    }
+-    curproc->sz = sz;
+-    switchuvm(curproc);
+-    return 0;
+-}
+-
+-// Create a new process copying p as the parent.
+-// Sets up stack to return as if from system call.
+-// Caller must set state of returned proc to RUNNABLE.
+-int
+-fork(void) {
+-    int i, pid;
+-    struct proc *np;
+-    struct proc *curproc = myproc();
+-
+-    // Allocate process.
+-    if ((np = allocproc()) == 0) {
+-        return -1;
+-    }
+-
+-    // Copy process state from proc.
+-    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
+-        kfree(np->kstack);
+-        np->kstack = 0;
+-        np->state = UNUSED;
+-        return -1;
+-    }
+-    np->sz = curproc->sz;
+-    np->parent = curproc;
+-    *np->tf = *curproc->tf;
+-
+-    // Clear %eax so that fork returns 0 in the child.
+-    np->tf->eax = 0;
+-
+-    for (i = 0; i < NOFILE; i++)
+-        if (curproc->ofile[i])
+-            np->ofile[i] = filedup(curproc->ofile[i]);
+-    np->cwd = idup(curproc->cwd);
+-
+-    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+-
+-    pid = np->pid;
+-
+-    acquire(&ptable.lock);
+-
+-    np->state = RUNNABLE;
+-
+-    release(&ptable.lock);
+-
+-    return pid;
+-}
+-
+-// Exit the current process.  Does not return.
+-// An exited process remains in the zombie state
+-// until its parent calls wait() to find out it exited.
+-void
+-exit(int status) {
+-    struct proc *curproc = myproc();
+-    struct proc *p;
+-    int fd;
+-
+-    curproc->status = status;
+-
+-    if (curproc == initproc)
+-        panic("init exiting");
+-
+-    // Close all open files.
+-    for (fd = 0; fd < NOFILE; fd++) {
+-        if (curproc->ofile[fd]) {
+-            fileclose(curproc->ofile[fd]);
+-            curproc->ofile[fd] = 0;
+-        }
+-    }
+-
+-    begin_op();
+-    iput(curproc->cwd);
+-    end_op();
+-    curproc->cwd = 0;
+-
+-    acquire(&ptable.lock);
+-
+-    // Parent might be sleeping in wait().
+-    wakeup1(curproc->parent);
+-
+-    // Pass abandoned children to init.
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-        if (p->parent == curproc) {
+-            p->parent = initproc;
+-            if (p->state == ZOMBIE)
+-                wakeup1(initproc);
+-        }
+-    }
+-
+-    // Jump into the scheduler, never to return.
+-    curproc->state = ZOMBIE;
+-    sched();
+-    panic("zombie exit");
+-}
+-
+-// Wait for a child process to exit and return its pid.
+-// Return -1 if this process has no children.
+-int
+-wait(int *status) {
+-    struct proc *p;
+-    int havekids, pid;
+-    struct proc *curproc = myproc();
+-
+-    acquire(&ptable.lock);
+-    for (;;) {
+-        // Scan through table looking for exited children.
+-        havekids = 0;
+-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-            if (p->parent != curproc)
+-                continue;
+-            havekids = 1;
+-            if (p->state == ZOMBIE) {
+-                // Found one.
+-                pid = p->pid;
+-                kfree(p->kstack);
+-                p->kstack = 0;
+-                freevm(p->pgdir);
+-                p->pid = 0;
+-                p->parent = 0;
+-                p->name[0] = 0;
+-                p->killed = 0;
+-                p->state = UNUSED;
+-                release(&ptable.lock);
+-                if (status != NULL)
+-                    *status = p->status;
+-                return pid;
+-            }
+-        }
+-
+-        // No point waiting if we don't have any children.
+-        if (!havekids || curproc->killed) {
+-            release(&ptable.lock);
+-            return -1;
+-        }
+-
+-        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+-    }
+-}
+-
+-// Wait for a child process to exit and return its pid.
+-// Return -1 if this process has no children.
+-int
+-waitpid(int pidBeingSearchedFor, int *status, int options) {
+-    struct proc *p;
+-    int doesProcExist, pidFound;
+-    struct proc *curproc = myproc();
+-    acquire(&ptable.lock);
+-    for (;;) {
+-        // Scan through table looking for exited children.
+-        doesProcExist = 0;
+-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-//            if(p->parent != curproc)
+-//                continue;
+-
+-            if (p->pid != pidBeingSearchedFor)
+-                continue;
+-
+-            doesProcExist = 1;
+-            if (p->state == ZOMBIE) {
+-                // Found one.
+-                pidFound = p->pid;
+-                kfree(p->kstack);
+-                p->kstack = 0;
+-                freevm(p->pgdir);
+-                p->pid = 0;
+-                p->parent = 0;
+-                p->name[0] = 0;
+-                p->killed = 0;
+-                p->state = UNUSED;
+-                release(&ptable.lock);
+-                if (status != NULL)
+-                    *status = p->status;
+-                return pidFound;
+-            }
+-        }
+-
+-//        // No point waiting if we don't have any children.
+-//        if(!havekids || curproc->killed){
+-//            release(&ptable.lock);
+-//            return -1;
+-//        }
+-
+-        if (!doesProcExist || curproc->killed) {
+-            release(&ptable.lock);
+-            return -1;
+-        }
+-        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+-    }
+-}
+-
+-//PAGEBREAK: 42
+-// Per-CPU process scheduler.
+-// Each CPU calls scheduler() after setting itself up.
+-// Scheduler never returns.  It loops, doing:
+-//  - choose a process to run
+-//  - swtch to start running that process
+-//  - eventually that process transfers control
+-//      via swtch back to the scheduler.
+-void
+-scheduler(void) {
+-    struct proc *p;
+-    struct cpu *c = mycpu();
+-    c->proc = 0;
+-
+-    for (;;) {
+-        // Enable interrupts on this processor.
+-        sti();
+-
+-        // Loop over process table looking for process to run.
+-        acquire(&ptable.lock);
+-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-            if (p->state != RUNNABLE)
+-                continue;
+-
+-            // Switch to chosen process.  It is the process's job
+-            // to release ptable.lock and then reacquire it
+-            // before jumping back to us.
+-            c->proc = p;
+-            switchuvm(p);
+-            p->state = RUNNING;
+-
+-            swtch(&(c->scheduler), p->context);
+-            switchkvm();
+-
+-            // Process is done running for now.
+-            // It should have changed its p->state before coming back.
+-            c->proc = 0;
+-        }
+-        release(&ptable.lock);
+-
+-    }
+-}
+-
+-// Enter scheduler.  Must hold only ptable.lock
+-// and have changed proc->state. Saves and restores
+-// intena because intena is a property of this
+-// kernel thread, not this CPU. It should
+-// be proc->intena and proc->ncli, but that would
+-// break in the few places where a lock is held but
+-// there's no process.
+-void
+-sched(void) {
+-    int intena;
+-    struct proc *p = myproc();
+-
+-    if (!holding(&ptable.lock))
+-        panic("sched ptable.lock");
+-    if (mycpu()->ncli != 1)
+-        panic("sched locks");
+-    if (p->state == RUNNING)
+-        panic("sched running");
+-    if (readeflags() & FL_IF)
+-        panic("sched interruptible");
+-    intena = mycpu()->intena;
+-    swtch(&p->context, mycpu()->scheduler);
+-    mycpu()->intena = intena;
+-}
+-
+-// Give up the CPU for one scheduling round.
+-void
+-yield(void) {
+-    acquire(&ptable.lock);  //DOC: yieldlock
+-    myproc()->state = RUNNABLE;
+-    sched();
+-    release(&ptable.lock);
+-}
+-
+-// A fork child's very first scheduling by scheduler()
+-// will swtch here.  "Return" to user space.
+-void
+-forkret(void) {
+-    static int first = 1;
+-    // Still holding ptable.lock from scheduler.
+-    release(&ptable.lock);
+-
+-    if (first) {
+-        // Some initialization functions must be run in the context
+-        // of a regular process (e.g., they call sleep), and thus cannot
+-        // be run from main().
+-        first = 0;
+-        iinit(ROOTDEV);
+-        initlog(ROOTDEV);
+-    }
+-
+-    // Return to "caller", actually trapret (see allocproc).
+-}
+-
+-// Atomically release lock and sleep on chan.
+-// Reacquires lock when awakened.
+-void
+-sleep(void *chan, struct spinlock *lk) {
+-    struct proc *p = myproc();
+-
+-    if (p == 0)
+-        panic("sleep");
+-
+-    if (lk == 0)
+-        panic("sleep without lk");
+-
+-    // Must acquire ptable.lock in order to
+-    // change p->state and then call sched.
+-    // Once we hold ptable.lock, we can be
+-    // guaranteed that we won't miss any wakeup
+-    // (wakeup runs with ptable.lock locked),
+-    // so it's okay to release lk.
+-    if (lk != &ptable.lock) {  //DOC: sleeplock0
+-        acquire(&ptable.lock);  //DOC: sleeplock1
+-        release(lk);
+-    }
+-    // Go to sleep.
+-    p->chan = chan;
+-    p->state = SLEEPING;
+-
+-    sched();
+-
+-    // Tidy up.
+-    p->chan = 0;
+-
+-    // Reacquire original lock.
+-    if (lk != &ptable.lock) {  //DOC: sleeplock2
+-        release(&ptable.lock);
+-        acquire(lk);
+-    }
+-}
+-
+-//PAGEBREAK!
+-// Wake up all processes sleeping on chan.
+-// The ptable lock must be held.
+-static void
+-wakeup1(void *chan) {
+-    struct proc *p;
+-
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-        if (p->state == SLEEPING && p->chan == chan)
+-            p->state = RUNNABLE;
+-}
+-
+-// Wake up all processes sleeping on chan.
+-void
+-wakeup(void *chan) {
+-    acquire(&ptable.lock);
+-    wakeup1(chan);
+-    release(&ptable.lock);
+-}
+-
+-// Kill the process with the given pid.
+-// Process won't exit until it returns
+-// to user space (see trap in trap.c).
+-int
+-kill(int pid) {
+-    struct proc *p;
+-
+-    acquire(&ptable.lock);
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-        if (p->pid == pid) {
+-            p->killed = 1;
+-            // Wake process from sleep if necessary.
+-            if (p->state == SLEEPING)
+-                p->state = RUNNABLE;
+-            release(&ptable.lock);
+-            return 0;
+-        }
+-    }
+-    release(&ptable.lock);
+-    return -1;
+-}
+-
+-//PAGEBREAK: 36
+-// Print a process listing to console.  For debugging.
+-// Runs when user types ^P on console.
+-// No lock to avoid wedging a stuck machine further.
+-void
+-procdump(void) {
+-    static char *states[] = {
+-            [UNUSED]    "unused",
+-            [EMBRYO]    "embryo",
+-            [SLEEPING]  "sleep ",
+-            [RUNNABLE]  "runble",
+-            [RUNNING]   "run   ",
+-            [ZOMBIE]    "zombie"
+-    };
+-    int i;
+-    struct proc *p;
+-    char *state;
+-    uint pc[10];
+-
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-        if (p->state == UNUSED)
+-            continue;
+-        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
+-            state = states[p->state];
+-        else
+-            state = "???";
+-        cprintf("%d %s %s", p->pid, state, p->name);
+-        if (p->state == SLEEPING) {
+-            getcallerpcs((uint *) p->context->ebp + 2, pc);
+-            for (i = 0; i < 10 && pc[i] != 0; i++)
+-                cprintf(" %p", pc[i]);
+-        }
+-        cprintf("\n");
+-    }
+-}
+diff --git a/proc.h b/proc.h
+deleted file mode 100644
+index a06b921..0000000
+--- a/proc.h
++++ /dev/null
+@@ -1,59 +0,0 @@
+-// Per-CPU state
+-struct cpu {
+-  uchar apicid;                // Local APIC ID
+-  struct context *scheduler;   // swtch() here to enter scheduler
+-  struct taskstate ts;         // Used by x86 to find stack for interrupt
+-  struct segdesc gdt[NSEGS];   // x86 global descriptor table
+-  volatile uint started;       // Has the CPU started?
+-  int ncli;                    // Depth of pushcli nesting.
+-  int intena;                  // Were interrupts enabled before pushcli?
+-  struct proc *proc;           // The process running on this cpu or null
+-};
+-
+-extern struct cpu cpus[NCPU];
+-extern int ncpu;
+-
+-//PAGEBREAK: 17
+-// Saved registers for kernel context switches.
+-// Don't need to save all the segment registers (%cs, etc),
+-// because they are constant across kernel contexts.
+-// Don't need to save %eax, %ecx, %edx, because the
+-// x86 convention is that the caller has saved them.
+-// Contexts are stored at the bottom of the stack they
+-// describe; the stack pointer is the address of the context.
+-// The layout of the context matches the layout of the stack in swtch.S
+-// at the "Switch stacks" comment. Switch doesn't save eip explicitly,
+-// but it is on the stack and allocproc() manipulates it.
+-struct context {
+-  uint edi;
+-  uint esi;
+-  uint ebx;
+-  uint ebp;
+-  uint eip;
+-};
+-
+-enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+-
+-// Per-process state
+-struct proc {
+-  uint sz;                     // Size of process memory (bytes)
+-  pde_t* pgdir;                // Page table
+-  char *kstack;                // Bottom of kernel stack for this process
+-  enum procstate state;        // Process state
+-  int pid;                     // Process ID
+-  struct proc *parent;         // Parent process
+-  struct trapframe *tf;        // Trap frame for current syscall
+-  struct context *context;     // swtch() here to run process
+-  void *chan;                  // If non-zero, sleeping on chan
+-  int killed;                  // If non-zero, have been killed
+-  struct file *ofile[NOFILE];  // Open files
+-  struct inode *cwd;           // Current directory
+-  char name[16];               // Process name (debugging)
+-  int status;                  // Exit status
+-};
+-
+-// Process memory is laid out contiguously, low addresses first:
+-//   text
+-//   original data and bss
+-//   fixed-size stack
+-//   expandable heap
+diff --git a/rm.c b/rm.c
+deleted file mode 100644
+index 1e6daec..0000000
+--- a/rm.c
++++ /dev/null
+@@ -1,23 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int i;
+-
+-  if(argc < 2){
+-    printf(2, "Usage: rm files...\n");
+-    exit(1);
+-  }
+-
+-  for(i = 1; i < argc; i++){
+-    if(unlink(argv[i]) < 0){
+-      printf(2, "rm: %s failed to delete\n", argv[i]);
+-      break;
+-    }
+-  }
+-
+-  exit(0);
+-}
+diff --git a/runoff b/runoff
+deleted file mode 100644
+index be362d0..0000000
+--- a/runoff
++++ /dev/null
+@@ -1,246 +0,0 @@
+-#!/bin/sh
+-
+-echo This script takes a minute to run.  Be patient. 1>&2
+-
+-LC_CTYPE=C export LC_CTYPE
+-
+-# pad stdin to multiple of 120 lines
+-pad()
+-{
+-	awk '{print} END{for(; NR%120!=0; NR++) print ""}'
+-}
+-
+-# create formatted (numbered) files
+-mkdir -p fmt
+-rm -f fmt/*
+-cp README fmt
+-echo > fmt/blank
+-files=`grep -v '^#' runoff.list | awk '{print $1}'`
+-n=99
+-for i in $files
+-do
+-	./runoff1 -n $n $i >fmt/$i
+-	nn=`tail -1 fmt/$i | sed 's/ .*//; s/^0*//'`
+-	if [ "x$nn" != x ]; then
+-		n=$nn
+-	fi
+-done
+-
+-# create table of contents
+-cat toc.hdr >fmt/toc
+-pr -e8 -t runoff.list | awk '
+-/^[a-z0-9]/ {
+-	s=$0
+-	f="fmt/"$1
+-	getline<f
+-	close(f)
+-	n=$1
+-	printf("%02d %s\n", n/100, s);
+-	printf("TOC: %04d %s\n", n, s) >"fmt/tocdata"
+-	next
+-}
+-{
+-	print
+-}' | pr -3 -t >>fmt/toc
+-cat toc.ftr >>fmt/toc
+-
+-# check for bad alignments
+-perl -e '
+-	$leftwarn = 0;
+-	while(<>){
+-		chomp;
+-		s!#.*!!;
+-		s!\s+! !g;
+-		s! +$!!;
+-		next if /^$/;
+-		
+-		if(/TOC: (\d+) (.*)/){
+-			$toc{$2} = $1;
+-			next;
+-		}
+-		
+-		if(/sheet1: (left|right)$/){
+-			print STDERR "assuming that sheet 1 is a $1 page.  double-check!\n";
+-			$left = $1 eq "left" ? "13579" : "02468";
+-			$right = $1 eq "left" ? "02468" : "13579";
+-			next;
+-		}
+-		
+-		if(/even: (.*)/){
+-			$file = $1;
+-			if(!defined($toc{$file})){
+-				print STDERR "Have no toc for $file\n";
+-				next;
+-			}
+-			if($toc{$file} =~ /^\d\d[^0]/){
+-				print STDERR "$file does not start on a fresh page.\n";
+-			}
+-			next;
+-		}
+-		
+-		if(/odd: (.*)/){
+-			$file = $1;
+-			if(!defined($toc{$file})){
+-				print STDERR "Have no toc for $file\n";
+-				next;
+-			}
+-			if($toc{$file} !~ /^\d\d5/){
+-				print STDERR "$file does not start on a second half page.\n";
+-			}
+-			next;
+-		}
+-		
+-		if(/(left|right): (.*)/){
+-			$what = $1;
+-			$file = $2;
+-			if(!defined($toc{$file})){
+-				print STDERR "Have no toc for $file\n";
+-				next;
+-			}
+-			if($what eq "left" && !($toc{$file} =~ /^\d[$left][05]/)){
+-				print STDERR "$file does not start on a left page [$toc{$file}]\n";
+-			}
+-			# why does this not work if I inline $x in the if?
+-			$x = ($toc{$file} =~ /^\d[$right][05]/);
+-			if($what eq "right" && !$x){
+-				print STDERR "$file does not start on a right page [$toc{$file}] [$x]\n";
+-			}
+-			next;
+-		}
+-		
+-		print STDERR "Unknown spec: $_\n";
+-	}
+-' fmt/tocdata runoff.spec
+-
+-# make definition list
+-cd fmt
+-perl -e '
+-	while(<>) {
+-		chomp;
+-
+-		s!//.*!!;
+-		s!/\*([^*]|[*][^/])*\*/!!g;
+-		s!\s! !g;
+-		s! +$!!;
+-
+-		# look for declarations like char* x;
+-		if (/^[0-9]+ typedef .* u(int|short|long|char);/) {
+-			next;
+-		}
+-		if (/^[0-9]+ extern/) {
+-			next;
+-		}
+-		if (/^[0-9]+ struct [a-zA-Z0-9_]+;/) {
+-			next;
+-		}
+-		if (/^([0-9]+) #define +([A-za-z0-9_]+) +?\(.*/) {
+-			print "$1 $2\n"
+-		}
+-		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+) +([^ ]+)/) {
+-			print "$1 $2 $3\n";
+-		}
+-		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+)/) {
+-			print "$1 $2\n";
+-		}
+-		
+-		if(/^^([0-9]+) \.globl ([a-zA-Z0-9_]+)/){
+-			$isglobl{$2} = 1;
+-		}
+-		if(/^^([0-9]+) ([a-zA-Z0-9_]+):$/ && $isglobl{$2}){
+-			print "$1 $2\n";
+-		}
+-		
+-		if (/\(/) {
+-			next;
+-		}
+-
+-		if (/^([0-9]+) (((static|struct|extern|union|enum) +)*([A-Za-z0-9_]+))( .*)? +([A-Za-z_][A-Za-z0-9_]*)(,|;|=| =)/) {
+-			print "$1 $7\n";
+-		}
+-		
+-		elsif(/^([0-9]+) (enum|struct|union) +([A-Za-z0-9_]+) +{/){ 
+-			print "$1 $3\n";
+-		}
+-		# TODO: enum members
+-	}
+-' $files >defs
+-
+-(for i in $files
+-do
+-	case "$i" in
+-	*.S)
+-		cat $i | sed 's;#.*;;; s;//.*;;;'
+-		;;
+-	*)
+-		cat $i | sed 's;//.*;;; s;"([^"\\]|\\.)*";;;'
+-	esac
+-done
+-) >alltext
+-
+-perl -n -e 'print if s/^([0-9]+ [a-zA-Z0-9_]+)\(.*$/\1/;' alltext |
+-	egrep -v ' (STUB|usage|main|if|for)$' >>defs
+-#perl -n -e 'print if s/^([0-9]+) STUB\(([a-zA-Z0-9_]+)\)$/\1 \2/;' alltext \
+-#	>>defs
+-(
+->s.defs
+-
+-# make reference list
+-for i in `awk '{print $2}' defs | sort -f | uniq`
+-do
+-	defs=`egrep '^[0-9]+ '$i'( |$)' defs | awk '{print $1}'`
+-	echo $i $defs >>s.defs
+-	uses=`egrep -h '([^a-zA-Z_0-9])'$i'($|[^a-zA-Z_0-9])' alltext | awk '{print $1}'`
+-	if [ "x$defs" != "x$uses" ]; then
+-		echo $i $defs
+-		echo $uses |fmt -29 | sed 's/^/    /'
+-#	else
+-#		echo $i defined but not used >&2
+-	fi
+-done
+-) >refs
+-
+-# build defs list
+-awk '
+-{
+-	printf("%04d %s\n", $2, $1);
+-	for(i=3; i<=NF; i++)
+-		printf("%04d    \" \n", $i);
+-}
+-' s.defs > t.defs
+-
+-# format the whole thing
+-(
+-	../pr.pl README
+-	../pr.pl -h "table of contents" toc
+-	# pr -t -2 t.defs | ../pr.pl -h "definitions" | pad
+-	pr -t -l50 -2 refs | ../pr.pl -h "cross-references" | pad
+-	# pr.pl -h "definitions" -2 t.defs | pad
+-	# pr.pl -h "cross-references" -2 refs | pad
+-	../pr.pl blank  # make sheet 1 start on left page
+-	../pr.pl blank
+-	for i in $files
+-	do
+-		../pr.pl -h "xv6/$i" $i
+-	done
+-) | mpage -m50t50b -o -bLetter -T -t -2 -FCourier -L60 >all.ps
+-grep Pages: all.ps
+-
+-# if we have the nice font, use it
+-nicefont=LucidaSans-Typewriter83
+-if [ ! -f ../$nicefont ]
+-then
+-	if git cat-file blob font:$nicefont > ../$nicefont~; then
+-		mv ../$nicefont~ ../$nicefont
+-	fi
+-fi
+-if [ -f ../$nicefont ]
+-then
+-	echo nicefont
+-	(sed 1q all.ps; cat ../$nicefont; sed "1d; s/Courier/$nicefont/" all.ps) >allf.ps
+-else
+-	echo ugly font!
+-	cp all.ps allf.ps
+-fi
+-ps2pdf allf.ps ../xv6.pdf
+-# cd ..
+-# pdftops xv6.pdf xv6.ps
+diff --git a/runoff.list b/runoff.list
+deleted file mode 100644
+index 2df9b81..0000000
+--- a/runoff.list
++++ /dev/null
+@@ -1,80 +0,0 @@
+-# basic headers
+-types.h
+-param.h
+-memlayout.h
+-defs.h
+-x86.h
+-asm.h
+-mmu.h
+-elf.h
+-date.h
+-
+-# entering xv6
+-entry.S
+-entryother.S
+-main.c
+-
+-# locks
+-spinlock.h
+-spinlock.c
+-
+-# processes
+-vm.c
+-proc.h
+-proc.c
+-swtch.S
+-kalloc.c
+-
+-# system calls
+-traps.h
+-vectors.pl
+-trapasm.S
+-trap.c
+-syscall.h
+-syscall.c
+-sysproc.c
+-
+-# file system
+-buf.h
+-sleeplock.h
+-fcntl.h
+-stat.h
+-fs.h
+-file.h
+-ide.c
+-bio.c
+-sleeplock.c
+-log.c
+-fs.c
+-file.c
+-sysfile.c
+-exec.c
+-
+-# pipes
+-pipe.c
+-
+-# string operations
+-string.c
+-
+-# low-level hardware
+-mp.h
+-mp.c
+-lapic.c
+-ioapic.c
+-kbd.h
+-kbd.c
+-console.c
+-uart.c
+-
+-# user-level
+-initcode.S
+-usys.S
+-init.c
+-sh.c
+-
+-# bootloader
+-bootasm.S
+-bootmain.c
+-
+-# link
+-kernel.ld
+diff --git a/runoff.spec b/runoff.spec
+deleted file mode 100644
+index 9247948..0000000
+--- a/runoff.spec
++++ /dev/null
+@@ -1,102 +0,0 @@
+-# Is sheet 01 (after the TOC) a left sheet or a right sheet?
+-sheet1: left
+-
+-# "left" and "right" specify which page of a two-page spread a file
+-# must start on.  "left" means that a file must start on the first of
+-# the two pages.  "right" means it must start on the second of the two
+-# pages.  The file may start in either column.
+-#
+-# "even" and "odd" specify which column a file must start on.  "even"
+-# means it must start in the left of the two columns (00).  "odd" means it
+-# must start in the right of the two columns (50).
+-#
+-# You'd think these would be the other way around.
+-
+-# types.h either
+-# param.h either
+-# defs.h either
+-# x86.h either
+-# asm.h either
+-# mmu.h either
+-# elf.h either
+-# mp.h either
+-
+-even: entry.S  # mild preference
+-even: entryother.S  # mild preference
+-even: main.c
+-# mp.c don't care at all
+-# even: initcode.S
+-# odd: init.c
+-
+-left: spinlock.h
+-even: spinlock.h
+-
+-# This gets struct proc and allocproc on the same spread
+-left: proc.h
+-even: proc.h
+-
+-# goal is to have two action-packed 2-page spreads,
+-# one with
+-#     userinit growproc fork exit wait
+-# and another with
+-#     scheduler sched yield forkret sleep wakeup1 wakeup
+-right: proc.c   # VERY important
+-even: proc.c   # VERY important
+-
+-# A few more action packed spreads
+-# page table creation and process loading
+-#     walkpgdir mappages setupkvm switch[ku]vm inituvm (loaduvm)
+-# process memory management
+-#     allocuvm deallocuvm freevm
+-left: vm.c
+-
+-even: kalloc.c  # mild preference
+-
+-# syscall.h either
+-# trapasm.S either
+-# traps.h either
+-# even: trap.c
+-# vectors.pl either
+-# syscall.c either
+-# sysproc.c either
+-
+-# buf.h either
+-# dev.h either
+-# fcntl.h either
+-# stat.h either
+-# file.h either
+-# fs.h either
+-# fsvar.h either
+-# left: ide.c # mild preference
+-even: ide.c
+-# odd: bio.c
+-
+-# log.c fits nicely in a spread
+-even: log.c
+-left: log.c
+-
+-# with fs.c starting on 2nd column of a left page, we get these 2-page spreads:
+-#	ialloc iupdate iget idup ilock iunlock iput iunlockput
+-#	bmap itrunc stati readi writei
+-#	namecmp dirlookup dirlink skipelem namex namei
+-#	fileinit filealloc filedup fileclose filestat fileread filewrite
+-# starting on 2nd column of a right page is not terrible either
+-odd: fs.c   # VERY important
+-left: fs.c  # mild preference
+-# file.c either
+-# exec.c either
+-# sysfile.c either
+-
+-# Mild preference, but makes spreads of mp.c, lapic.c, and ioapic.c+picirq.c
+-even: mp.c
+-left: mp.c
+-
+-# even: pipe.c  # mild preference
+-# string.c either
+-# left: kbd.h  # mild preference
+-even: kbd.h
+-even: console.c
+-odd: sh.c
+-
+-even: bootasm.S   # mild preference
+-even: bootmain.c  # mild preference
+diff --git a/runoff1 b/runoff1
+deleted file mode 100644
+index 532f844..0000000
+--- a/runoff1
++++ /dev/null
+@@ -1,108 +0,0 @@
+-#!/usr/bin/perl
+-
+-$n = 0;
+-$v = 0;
+-if($ARGV[0] eq "-v") {
+-	$v = 1;
+-	shift @ARGV;
+-}
+-if($ARGV[0] eq "-n") {
+-	$n = $ARGV[1];
+-	shift @ARGV;
+-	shift @ARGV;
+-}
+-$n = int(($n+49)/50)*50 - 1;
+-
+-$file = $ARGV[0];
+-@lines = <>;
+-$linenum = 0;
+-foreach (@lines) {
+-	$linenum++;
+-	chomp;
+-	s/\s+$//;
+-	if(length() >= 75){
+-		print STDERR "$file:$linenum: line too long\n";
+-	}
+-}
+-@outlines = ();
+-$nextout = 0;
+-
+-for($i=0; $i<@lines; ){
+-	# Skip leading blank lines.
+-	$i++ while $i<@lines && $lines[$i] =~ /^$/;
+-	last if $i>=@lines;
+-
+-	# If the rest of the file fits, use the whole thing.
+-	if(@lines <= $i+50 && !grep { /PAGEBREAK/ } @lines){
+-		$breakbefore = @lines;
+-	}else{
+-		# Find a good next page break;
+-		# Hope for end of function.
+-		# but settle for a blank line (but not first blank line
+-		# in function, which comes after variable declarations).
+-		$breakbefore = $i;
+-		$lastblank = $i;
+-		$sawbrace = 0;
+-		$breaksize = 15;  # 15 lines to get to function
+-		for($j=$i; $j<$i+50 && $j < @lines; $j++){
+-			if($lines[$j] =~ /PAGEBREAK!/){
+-				$lines[$j] = "";
+-				$breakbefore = $j;
+-				$breaksize = 100;
+-				last;
+-			}
+-			if($lines[$j] =~ /PAGEBREAK:\s*([0-9]+)/){
+-				$breaksize = $1;
+-				$breakbefore = $j;
+-				$lines[$j] = "";
+-			}
+-			if($lines[$j] =~ /^};?$/){
+-				$breakbefore = $j+1;
+-				$breaksize = 15;
+-			}
+-			if($lines[$j] =~ /^{$/){
+-				$sawbrace = 1;
+-			}
+-			if($lines[$j] =~ /^$/){
+-				if($sawbrace){
+-					$sawbrace = 0;
+-				}else{
+-					$lastblank = $j;
+-				}
+-			}
+-		}
+-		if($j<@lines && $lines[$j] =~ /^$/){
+-			$lastblank = $j;
+-		}
+-
+-		# If we are not putting enough on a page, try a blank line.
+-		if($breakbefore - $i < 50 - $breaksize && $lastblank > $breakbefore && $lastblank >= $i+50 - 5){
+-			if($v){
+-				print STDERR "breakbefore $breakbefore i $i breaksize $breaksize\n";
+-			}
+-			$breakbefore = $lastblank;
+-			$breaksize = 5;  # only 5 lines to get to blank line
+-		}
+-
+-		# If we are not putting enough on a page, force a full page.
+-		if($breakbefore - $i < 50 - $breaksize && $breakbefore != @lines){
+-			$breakbefore = $i + 50;
+-			$breakbefore = @lines if @lines < $breakbefore;
+-		}
+-
+-		if($breakbefore < $i+2){
+-			$breakbefore = $i+2;
+-		}
+-	}
+-
+-	# Emit the page.
+-	$i50 = $i + 50;
+-	for(; $i<$breakbefore; $i++){
+-		printf "%04d %s\n", ++$n, $lines[$i];
+-	}
+-
+-	# Finish page
+-	for($j=$i; $j<$i50; $j++){
+-		printf "%04d \n", ++$n;
+-	}
+-}
+diff --git a/sh.c b/sh.c
+deleted file mode 100644
+index ca2ae37..0000000
+--- a/sh.c
++++ /dev/null
+@@ -1,493 +0,0 @@
+-// Shell.
+-
+-#include "types.h"
+-#include "user.h"
+-#include "fcntl.h"
+-
+-// Parsed command representation
+-#define EXEC  1
+-#define REDIR 2
+-#define PIPE  3
+-#define LIST  4
+-#define BACK  5
+-
+-#define MAXARGS 10
+-
+-struct cmd {
+-  int type;
+-};
+-
+-struct execcmd {
+-  int type;
+-  char *argv[MAXARGS];
+-  char *eargv[MAXARGS];
+-};
+-
+-struct redircmd {
+-  int type;
+-  struct cmd *cmd;
+-  char *file;
+-  char *efile;
+-  int mode;
+-  int fd;
+-};
+-
+-struct pipecmd {
+-  int type;
+-  struct cmd *left;
+-  struct cmd *right;
+-};
+-
+-struct listcmd {
+-  int type;
+-  struct cmd *left;
+-  struct cmd *right;
+-};
+-
+-struct backcmd {
+-  int type;
+-  struct cmd *cmd;
+-};
+-
+-int fork1(void);  // Fork but panics on failure.
+-void panic(char*);
+-struct cmd *parsecmd(char*);
+-
+-// Execute cmd.  Never returns.
+-void
+-runcmd(struct cmd *cmd)
+-{
+-  int p[2];
+-  struct backcmd *bcmd;
+-  struct execcmd *ecmd;
+-  struct listcmd *lcmd;
+-  struct pipecmd *pcmd;
+-  struct redircmd *rcmd;
+-
+-  if(cmd == 0)
+-    exit(1);
+-
+-  switch(cmd->type){
+-  default:
+-    panic("runcmd");
+-
+-  case EXEC:
+-    ecmd = (struct execcmd*)cmd;
+-    if(ecmd->argv[0] == 0)
+-      exit(2);
+-    exec(ecmd->argv[0], ecmd->argv);
+-    printf(2, "exec %s failed\n", ecmd->argv[0]);
+-    break;
+-
+-  case REDIR:
+-    rcmd = (struct redircmd*)cmd;
+-    close(rcmd->fd);
+-    if(open(rcmd->file, rcmd->mode) < 0){
+-      printf(2, "open %s failed\n", rcmd->file);
+-      exit(6);
+-    }
+-    runcmd(rcmd->cmd);
+-    break;
+-
+-  case LIST:
+-    lcmd = (struct listcmd*)cmd;
+-    if(fork1() == 0)
+-      runcmd(lcmd->left);
+-    wait(NULL);
+-    runcmd(lcmd->right);
+-    break;
+-
+-  case PIPE:
+-    pcmd = (struct pipecmd*)cmd;
+-    if(pipe(p) < 0)
+-      panic("pipe");
+-    if(fork1() == 0){
+-      close(1);
+-      dup(p[1]);
+-      close(p[0]);
+-      close(p[1]);
+-      runcmd(pcmd->left);
+-    }
+-    if(fork1() == 0){
+-      close(0);
+-      dup(p[0]);
+-      close(p[0]);
+-      close(p[1]);
+-      runcmd(pcmd->right);
+-    }
+-    close(p[0]);
+-    close(p[1]);
+-    wait(NULL);
+-    wait(NULL);
+-    break;
+-
+-  case BACK:
+-    bcmd = (struct backcmd*)cmd;
+-    if(fork1() == 0)
+-      runcmd(bcmd->cmd);
+-    break;
+-  }
+-  exit(3);
+-}
+-
+-int
+-getcmd(char *buf, int nbuf)
+-{
+-  printf(2, "$ ");
+-  memset(buf, 0, nbuf);
+-  gets(buf, nbuf);
+-  if(buf[0] == 0) // EOF
+-    return -1;
+-  return 0;
+-}
+-
+-int
+-main(void)
+-{
+-  static char buf[100];
+-  int fd;
+-
+-  // Ensure that three file descriptors are open.
+-  while((fd = open("console", O_RDWR)) >= 0){
+-    if(fd >= 3){
+-      close(fd);
+-      break;
+-    }
+-  }
+-
+-  // Read and run input commands.
+-  while(getcmd(buf, sizeof(buf)) >= 0){
+-    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+-      // Chdir must be called by the parent, not the child.
+-      buf[strlen(buf)-1] = 0;  // chop \n
+-      if(chdir(buf+3) < 0)
+-        printf(2, "cannot cd %s\n", buf+3);
+-      continue;
+-    }
+-    if(fork1() == 0)
+-      runcmd(parsecmd(buf));
+-    wait(NULL);
+-  }
+-  exit(0);
+-}
+-
+-void
+-panic(char *s)
+-{
+-  printf(2, "%s\n", s);
+-  exit(5);
+-}
+-
+-int
+-fork1(void)
+-{
+-  int pid;
+-
+-  pid = fork();
+-  if(pid == -1)
+-    panic("fork");
+-  return pid;
+-}
+-
+-//PAGEBREAK!
+-// Constructors
+-
+-struct cmd*
+-execcmd(void)
+-{
+-  struct execcmd *cmd;
+-
+-  cmd = malloc(sizeof(*cmd));
+-  memset(cmd, 0, sizeof(*cmd));
+-  cmd->type = EXEC;
+-  return (struct cmd*)cmd;
+-}
+-
+-struct cmd*
+-redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
+-{
+-  struct redircmd *cmd;
+-
+-  cmd = malloc(sizeof(*cmd));
+-  memset(cmd, 0, sizeof(*cmd));
+-  cmd->type = REDIR;
+-  cmd->cmd = subcmd;
+-  cmd->file = file;
+-  cmd->efile = efile;
+-  cmd->mode = mode;
+-  cmd->fd = fd;
+-  return (struct cmd*)cmd;
+-}
+-
+-struct cmd*
+-pipecmd(struct cmd *left, struct cmd *right)
+-{
+-  struct pipecmd *cmd;
+-
+-  cmd = malloc(sizeof(*cmd));
+-  memset(cmd, 0, sizeof(*cmd));
+-  cmd->type = PIPE;
+-  cmd->left = left;
+-  cmd->right = right;
+-  return (struct cmd*)cmd;
+-}
+-
+-struct cmd*
+-listcmd(struct cmd *left, struct cmd *right)
+-{
+-  struct listcmd *cmd;
+-
+-  cmd = malloc(sizeof(*cmd));
+-  memset(cmd, 0, sizeof(*cmd));
+-  cmd->type = LIST;
+-  cmd->left = left;
+-  cmd->right = right;
+-  return (struct cmd*)cmd;
+-}
+-
+-struct cmd*
+-backcmd(struct cmd *subcmd)
+-{
+-  struct backcmd *cmd;
+-
+-  cmd = malloc(sizeof(*cmd));
+-  memset(cmd, 0, sizeof(*cmd));
+-  cmd->type = BACK;
+-  cmd->cmd = subcmd;
+-  return (struct cmd*)cmd;
+-}
+-//PAGEBREAK!
+-// Parsing
+-
+-char whitespace[] = " \t\r\n\v";
+-char symbols[] = "<|>&;()";
+-
+-int
+-gettoken(char **ps, char *es, char **q, char **eq)
+-{
+-  char *s;
+-  int ret;
+-
+-  s = *ps;
+-  while(s < es && strchr(whitespace, *s))
+-    s++;
+-  if(q)
+-    *q = s;
+-  ret = *s;
+-  switch(*s){
+-  case 0:
+-    break;
+-  case '|':
+-  case '(':
+-  case ')':
+-  case ';':
+-  case '&':
+-  case '<':
+-    s++;
+-    break;
+-  case '>':
+-    s++;
+-    if(*s == '>'){
+-      ret = '+';
+-      s++;
+-    }
+-    break;
+-  default:
+-    ret = 'a';
+-    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+-      s++;
+-    break;
+-  }
+-  if(eq)
+-    *eq = s;
+-
+-  while(s < es && strchr(whitespace, *s))
+-    s++;
+-  *ps = s;
+-  return ret;
+-}
+-
+-int
+-peek(char **ps, char *es, char *toks)
+-{
+-  char *s;
+-
+-  s = *ps;
+-  while(s < es && strchr(whitespace, *s))
+-    s++;
+-  *ps = s;
+-  return *s && strchr(toks, *s);
+-}
+-
+-struct cmd *parseline(char**, char*);
+-struct cmd *parsepipe(char**, char*);
+-struct cmd *parseexec(char**, char*);
+-struct cmd *nulterminate(struct cmd*);
+-
+-struct cmd*
+-parsecmd(char *s)
+-{
+-  char *es;
+-  struct cmd *cmd;
+-
+-  es = s + strlen(s);
+-  cmd = parseline(&s, es);
+-  peek(&s, es, "");
+-  if(s != es){
+-    printf(2, "leftovers: %s\n", s);
+-    panic("syntax");
+-  }
+-  nulterminate(cmd);
+-  return cmd;
+-}
+-
+-struct cmd*
+-parseline(char **ps, char *es)
+-{
+-  struct cmd *cmd;
+-
+-  cmd = parsepipe(ps, es);
+-  while(peek(ps, es, "&")){
+-    gettoken(ps, es, 0, 0);
+-    cmd = backcmd(cmd);
+-  }
+-  if(peek(ps, es, ";")){
+-    gettoken(ps, es, 0, 0);
+-    cmd = listcmd(cmd, parseline(ps, es));
+-  }
+-  return cmd;
+-}
+-
+-struct cmd*
+-parsepipe(char **ps, char *es)
+-{
+-  struct cmd *cmd;
+-
+-  cmd = parseexec(ps, es);
+-  if(peek(ps, es, "|")){
+-    gettoken(ps, es, 0, 0);
+-    cmd = pipecmd(cmd, parsepipe(ps, es));
+-  }
+-  return cmd;
+-}
+-
+-struct cmd*
+-parseredirs(struct cmd *cmd, char **ps, char *es)
+-{
+-  int tok;
+-  char *q, *eq;
+-
+-  while(peek(ps, es, "<>")){
+-    tok = gettoken(ps, es, 0, 0);
+-    if(gettoken(ps, es, &q, &eq) != 'a')
+-      panic("missing file for redirection");
+-    switch(tok){
+-    case '<':
+-      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
+-      break;
+-    case '>':
+-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+-      break;
+-    case '+':  // >>
+-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+-      break;
+-    }
+-  }
+-  return cmd;
+-}
+-
+-struct cmd*
+-parseblock(char **ps, char *es)
+-{
+-  struct cmd *cmd;
+-
+-  if(!peek(ps, es, "("))
+-    panic("parseblock");
+-  gettoken(ps, es, 0, 0);
+-  cmd = parseline(ps, es);
+-  if(!peek(ps, es, ")"))
+-    panic("syntax - missing )");
+-  gettoken(ps, es, 0, 0);
+-  cmd = parseredirs(cmd, ps, es);
+-  return cmd;
+-}
+-
+-struct cmd*
+-parseexec(char **ps, char *es)
+-{
+-  char *q, *eq;
+-  int tok, argc;
+-  struct execcmd *cmd;
+-  struct cmd *ret;
+-
+-  if(peek(ps, es, "("))
+-    return parseblock(ps, es);
+-
+-  ret = execcmd();
+-  cmd = (struct execcmd*)ret;
+-
+-  argc = 0;
+-  ret = parseredirs(ret, ps, es);
+-  while(!peek(ps, es, "|)&;")){
+-    if((tok=gettoken(ps, es, &q, &eq)) == 0)
+-      break;
+-    if(tok != 'a')
+-      panic("syntax");
+-    cmd->argv[argc] = q;
+-    cmd->eargv[argc] = eq;
+-    argc++;
+-    if(argc >= MAXARGS)
+-      panic("too many args");
+-    ret = parseredirs(ret, ps, es);
+-  }
+-  cmd->argv[argc] = 0;
+-  cmd->eargv[argc] = 0;
+-  return ret;
+-}
+-
+-// NUL-terminate all the counted strings.
+-struct cmd*
+-nulterminate(struct cmd *cmd)
+-{
+-  int i;
+-  struct backcmd *bcmd;
+-  struct execcmd *ecmd;
+-  struct listcmd *lcmd;
+-  struct pipecmd *pcmd;
+-  struct redircmd *rcmd;
+-
+-  if(cmd == 0)
+-    return 0;
+-
+-  switch(cmd->type){
+-  case EXEC:
+-    ecmd = (struct execcmd*)cmd;
+-    for(i=0; ecmd->argv[i]; i++)
+-      *ecmd->eargv[i] = 0;
+-    break;
+-
+-  case REDIR:
+-    rcmd = (struct redircmd*)cmd;
+-    nulterminate(rcmd->cmd);
+-    *rcmd->efile = 0;
+-    break;
+-
+-  case PIPE:
+-    pcmd = (struct pipecmd*)cmd;
+-    nulterminate(pcmd->left);
+-    nulterminate(pcmd->right);
+-    break;
+-
+-  case LIST:
+-    lcmd = (struct listcmd*)cmd;
+-    nulterminate(lcmd->left);
+-    nulterminate(lcmd->right);
+-    break;
+-
+-  case BACK:
+-    bcmd = (struct backcmd*)cmd;
+-    nulterminate(bcmd->cmd);
+-    break;
+-  }
+-  return cmd;
+-}
+diff --git a/show1 b/show1
+deleted file mode 100644
+index e0d3d83..0000000
+--- a/show1
++++ /dev/null
+@@ -1,3 +0,0 @@
+-#!/bin/sh
+-
+-runoff1 "$@" | pr.pl -h "xv6/$@" | mpage -m50t50b -o -bLetter -T -t -2 -FLucidaSans-Typewriter83 -L60 >x.ps; gv --swap x.ps
+diff --git a/sign.pl b/sign.pl
+deleted file mode 100644
+index d793035..0000000
+--- a/sign.pl
++++ /dev/null
+@@ -1,19 +0,0 @@
+-#!/usr/bin/perl
+-
+-open(SIG, $ARGV[0]) || die "open $ARGV[0]: $!";
+-
+-$n = sysread(SIG, $buf, 1000);
+-
+-if($n > 510){
+-  print STDERR "boot block too large: $n bytes (max 510)\n";
+-  exit 1;
+-}
+-
+-print STDERR "boot block is $n bytes (max 510)\n";
+-
+-$buf .= "\0" x (510-$n);
+-$buf .= "\x55\xAA";
+-
+-open(SIG, ">$ARGV[0]") || die "open >$ARGV[0]: $!";
+-print SIG $buf;
+-close SIG;
+diff --git a/sleep1.p b/sleep1.p
+deleted file mode 100644
+index af69772..0000000
+--- a/sleep1.p
++++ /dev/null
+@@ -1,134 +0,0 @@
+-/*
+-This file defines a Promela model for xv6's
+-acquire, release, sleep, and wakeup, along with
+-a model of a simple producer/consumer queue.
+-
+-To run:
+-	spinp sleep1.p
+-
+-(You may need to install Spin, available at http://spinroot.com/.)
+-
+-After a successful run spin prints something like:
+-
+-	unreached in proctype consumer
+-		(0 of 37 states)
+-	unreached in proctype producer
+-		(0 of 23 states)
+-
+-After an unsuccessful run, the spinp script prints
+-an execution trace that causes a deadlock.
+-
+-The safe body of producer reads:
+-
+-		acquire(lk);
+-		x = value; value = x + 1; x = 0;
+-		wakeup(0);
+-		release(lk);
+-		i = i + 1;
+-
+-If this is changed to:
+-
+-		x = value; value = x + 1; x = 0;
+-		acquire(lk);
+-		wakeup(0);
+-		release(lk);
+-		i = i + 1;
+-
+-then a deadlock can happen, because the non-atomic
+-increment of value conflicts with the non-atomic 
+-decrement in consumer, causing value to have a bad value.
+-Try this.
+-
+-If it is changed to:
+-
+-		acquire(lk);
+-		x = value; value = x + 1; x = 0;
+-		release(lk);
+-		wakeup(0);
+-		i = i + 1;
+-
+-then nothing bad happens: it is okay to wakeup after release
+-instead of before, although it seems morally wrong.
+-*/
+-
+-#define ITER 4
+-#define N 2
+-
+-bit lk;
+-byte value;
+-bit sleeping[N];
+-
+-inline acquire(x)
+-{
+-	atomic { x == 0; x = 1 }
+-}
+-
+-inline release(x)
+-{
+-	assert x==1;
+-	x = 0
+-}
+-
+-inline sleep(cond, lk)
+-{
+-	assert !sleeping[_pid];
+-	if
+-	:: cond ->
+-		skip
+-	:: else ->
+-		atomic { release(lk); sleeping[_pid] = 1 };
+-		sleeping[_pid] == 0;
+-		acquire(lk)
+-	fi
+-}
+-
+-inline wakeup()
+-{
+-	w = 0;
+-	do
+-	:: w < N ->
+-		sleeping[w] = 0;
+-		w = w + 1
+-	:: else ->
+-		break
+-	od
+-}
+-
+-active[N] proctype consumer()
+-{
+-	byte i, x;
+-	
+-	i = 0;
+-	do
+-	:: i < ITER ->
+-		acquire(lk);
+-		sleep(value > 0, lk);
+-		x = value; value = x - 1; x = 0;
+-		release(lk);
+-		i = i + 1;
+-	:: else ->
+-		break
+-	od;
+-	i = 0;
+-	skip
+-}
+-
+-active[N] proctype producer()
+-{
+-	byte i, x, w;
+-	
+-	i = 0;
+-	do
+-	:: i < ITER ->
+-		acquire(lk);
+-		x = value; value = x + 1; x = 0;
+-		release(lk);
+-		wakeup();
+-		i = i + 1;
+-	:: else ->
+-		break
+-	od;
+-	i = 0;
+-	skip	
+-}
+-
+diff --git a/sleeplock.c b/sleeplock.c
+deleted file mode 100644
+index e0750ea..0000000
+--- a/sleeplock.c
++++ /dev/null
+@@ -1,56 +0,0 @@
+-// Sleeping locks
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "x86.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-
+-void
+-initsleeplock(struct sleeplock *lk, char *name)
+-{
+-  initlock(&lk->lk, "sleep lock");
+-  lk->name = name;
+-  lk->locked = 0;
+-  lk->pid = 0;
+-}
+-
+-void
+-acquiresleep(struct sleeplock *lk)
+-{
+-  acquire(&lk->lk);
+-  while (lk->locked) {
+-    sleep(lk, &lk->lk);
+-  }
+-  lk->locked = 1;
+-  lk->pid = myproc()->pid;
+-  release(&lk->lk);
+-}
+-
+-void
+-releasesleep(struct sleeplock *lk)
+-{
+-  acquire(&lk->lk);
+-  lk->locked = 0;
+-  lk->pid = 0;
+-  wakeup(lk);
+-  release(&lk->lk);
+-}
+-
+-int
+-holdingsleep(struct sleeplock *lk)
+-{
+-  int r;
+-  
+-  acquire(&lk->lk);
+-  r = lk->locked && (lk->pid == myproc()->pid);
+-  release(&lk->lk);
+-  return r;
+-}
+-
+-
+-
+diff --git a/sleeplock.h b/sleeplock.h
+deleted file mode 100644
+index 110e6f3..0000000
+--- a/sleeplock.h
++++ /dev/null
+@@ -1,10 +0,0 @@
+-// Long-term locks for processes
+-struct sleeplock {
+-  uint locked;       // Is the lock held?
+-  struct spinlock lk; // spinlock protecting this sleep lock
+-  
+-  // For debugging:
+-  char *name;        // Name of lock.
+-  int pid;           // Process holding lock
+-};
+-
+diff --git a/spinlock.c b/spinlock.c
+deleted file mode 100644
+index 4020186..0000000
+--- a/spinlock.c
++++ /dev/null
+@@ -1,126 +0,0 @@
+-// Mutual exclusion spin locks.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "x86.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "spinlock.h"
+-
+-void
+-initlock(struct spinlock *lk, char *name)
+-{
+-  lk->name = name;
+-  lk->locked = 0;
+-  lk->cpu = 0;
+-}
+-
+-// Acquire the lock.
+-// Loops (spins) until the lock is acquired.
+-// Holding a lock for a long time may cause
+-// other CPUs to waste time spinning to acquire it.
+-void
+-acquire(struct spinlock *lk)
+-{
+-  pushcli(); // disable interrupts to avoid deadlock.
+-  if(holding(lk))
+-    panic("acquire");
+-
+-  // The xchg is atomic.
+-  while(xchg(&lk->locked, 1) != 0)
+-    ;
+-
+-  // Tell the C compiler and the processor to not move loads or stores
+-  // past this point, to ensure that the critical section's memory
+-  // references happen after the lock is acquired.
+-  __sync_synchronize();
+-
+-  // Record info about lock acquisition for debugging.
+-  lk->cpu = mycpu();
+-  getcallerpcs(&lk, lk->pcs);
+-}
+-
+-// Release the lock.
+-void
+-release(struct spinlock *lk)
+-{
+-  if(!holding(lk))
+-    panic("release");
+-
+-  lk->pcs[0] = 0;
+-  lk->cpu = 0;
+-
+-  // Tell the C compiler and the processor to not move loads or stores
+-  // past this point, to ensure that all the stores in the critical
+-  // section are visible to other cores before the lock is released.
+-  // Both the C compiler and the hardware may re-order loads and
+-  // stores; __sync_synchronize() tells them both not to.
+-  __sync_synchronize();
+-
+-  // Release the lock, equivalent to lk->locked = 0.
+-  // This code can't use a C assignment, since it might
+-  // not be atomic. A real OS would use C atomics here.
+-  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+-
+-  popcli();
+-}
+-
+-// Record the current call stack in pcs[] by following the %ebp chain.
+-void
+-getcallerpcs(void *v, uint pcs[])
+-{
+-  uint *ebp;
+-  int i;
+-
+-  ebp = (uint*)v - 2;
+-  for(i = 0; i < 10; i++){
+-    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+-      break;
+-    pcs[i] = ebp[1];     // saved %eip
+-    ebp = (uint*)ebp[0]; // saved %ebp
+-  }
+-  for(; i < 10; i++)
+-    pcs[i] = 0;
+-}
+-
+-// Check whether this cpu is holding the lock.
+-int
+-holding(struct spinlock *lock)
+-{
+-  int r;
+-  pushcli();
+-  r = lock->locked && lock->cpu == mycpu();
+-  popcli();
+-  return r;
+-}
+-
+-
+-// Pushcli/popcli are like cli/sti except that they are matched:
+-// it takes two popcli to undo two pushcli.  Also, if interrupts
+-// are off, then pushcli, popcli leaves them off.
+-
+-void
+-pushcli(void)
+-{
+-  int eflags;
+-
+-  eflags = readeflags();
+-  cli();
+-  if(mycpu()->ncli == 0)
+-    mycpu()->intena = eflags & FL_IF;
+-  mycpu()->ncli += 1;
+-}
+-
+-void
+-popcli(void)
+-{
+-  if(readeflags()&FL_IF)
+-    panic("popcli - interruptible");
+-  if(--mycpu()->ncli < 0)
+-    panic("popcli");
+-  if(mycpu()->ncli == 0 && mycpu()->intena)
+-    sti();
+-}
+-
+diff --git a/spinlock.h b/spinlock.h
+deleted file mode 100644
+index 0a9d8e2..0000000
+--- a/spinlock.h
++++ /dev/null
+@@ -1,11 +0,0 @@
+-// Mutual exclusion lock.
+-struct spinlock {
+-  uint locked;       // Is the lock held?
+-
+-  // For debugging:
+-  char *name;        // Name of lock.
+-  struct cpu *cpu;   // The cpu holding the lock.
+-  uint pcs[10];      // The call stack (an array of program counters)
+-                     // that locked the lock.
+-};
+-
+diff --git a/spinp b/spinp
+deleted file mode 100644
+index db9614b..0000000
+--- a/spinp
++++ /dev/null
+@@ -1,16 +0,0 @@
+-#!/bin/sh
+-
+-if [ $# != 1 ] || [ ! -f "$1" ]; then
+-	echo 'usage: spinp file.p' 1>&2
+-	exit 1
+-fi
+-
+-rm -f $1.trail
+-spin -a $1 || exit 1
+-cc -DSAFETY -DREACH -DMEMLIM=500 -o pan pan.c
+-pan -i
+-rm pan.* pan
+-if [ -f $1.trail ]; then
+-	spin -t -p $1
+-fi
+-
+diff --git a/stat.h b/stat.h
+deleted file mode 100644
+index 8a80933..0000000
+--- a/stat.h
++++ /dev/null
+@@ -1,11 +0,0 @@
+-#define T_DIR  1   // Directory
+-#define T_FILE 2   // File
+-#define T_DEV  3   // Device
+-
+-struct stat {
+-  short type;  // Type of file
+-  int dev;     // File system's disk device
+-  uint ino;    // Inode number
+-  short nlink; // Number of links to file
+-  uint size;   // Size of file in bytes
+-};
+diff --git a/stressfs.c b/stressfs.c
+deleted file mode 100644
+index 46e0e66..0000000
+--- a/stressfs.c
++++ /dev/null
+@@ -1,49 +0,0 @@
+-// Demonstrate that moving the "acquire" in iderw after the loop that
+-// appends to the idequeue results in a race.
+-
+-// For this to work, you should also add a spin within iderw's
+-// idequeue traversal loop.  Adding the following demonstrated a panic
+-// after about 5 runs of stressfs in QEMU on a 2.1GHz CPU:
+-//    for (i = 0; i < 40000; i++)
+-//      asm volatile("");
+-
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-#include "fs.h"
+-#include "fcntl.h"
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int fd, i;
+-  char path[] = "stressfs0";
+-  char data[512];
+-
+-  printf(1, "stressfs starting\n");
+-  memset(data, 'a', sizeof(data));
+-
+-  for(i = 0; i < 4; i++)
+-    if(fork() > 0)
+-      break;
+-
+-  printf(1, "write %d\n", i);
+-
+-  path[8] += i;
+-  fd = open(path, O_CREATE | O_RDWR);
+-  for(i = 0; i < 20; i++)
+-//    printf(fd, "%d\n", i);
+-    write(fd, data, sizeof(data));
+-  close(fd);
+-
+-  printf(1, "read\n");
+-
+-  fd = open(path, O_RDONLY);
+-  for (i = 0; i < 20; i++)
+-    read(fd, data, sizeof(data));
+-  close(fd);
+-
+-  wait(NULL);
+-
+-  exit(0);
+-}
+diff --git a/string.c b/string.c
+deleted file mode 100644
+index a7cc61f..0000000
+--- a/string.c
++++ /dev/null
+@@ -1,105 +0,0 @@
+-#include "types.h"
+-#include "x86.h"
+-
+-void*
+-memset(void *dst, int c, uint n)
+-{
+-  if ((int)dst%4 == 0 && n%4 == 0){
+-    c &= 0xFF;
+-    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
+-  } else
+-    stosb(dst, c, n);
+-  return dst;
+-}
+-
+-int
+-memcmp(const void *v1, const void *v2, uint n)
+-{
+-  const uchar *s1, *s2;
+-
+-  s1 = v1;
+-  s2 = v2;
+-  while(n-- > 0){
+-    if(*s1 != *s2)
+-      return *s1 - *s2;
+-    s1++, s2++;
+-  }
+-
+-  return 0;
+-}
+-
+-void*
+-memmove(void *dst, const void *src, uint n)
+-{
+-  const char *s;
+-  char *d;
+-
+-  s = src;
+-  d = dst;
+-  if(s < d && s + n > d){
+-    s += n;
+-    d += n;
+-    while(n-- > 0)
+-      *--d = *--s;
+-  } else
+-    while(n-- > 0)
+-      *d++ = *s++;
+-
+-  return dst;
+-}
+-
+-// memcpy exists to placate GCC.  Use memmove.
+-void*
+-memcpy(void *dst, const void *src, uint n)
+-{
+-  return memmove(dst, src, n);
+-}
+-
+-int
+-strncmp(const char *p, const char *q, uint n)
+-{
+-  while(n > 0 && *p && *p == *q)
+-    n--, p++, q++;
+-  if(n == 0)
+-    return 0;
+-  return (uchar)*p - (uchar)*q;
+-}
+-
+-char*
+-strncpy(char *s, const char *t, int n)
+-{
+-  char *os;
+-
+-  os = s;
+-  while(n-- > 0 && (*s++ = *t++) != 0)
+-    ;
+-  while(n-- > 0)
+-    *s++ = 0;
+-  return os;
+-}
+-
+-// Like strncpy but guaranteed to NUL-terminate.
+-char*
+-safestrcpy(char *s, const char *t, int n)
+-{
+-  char *os;
+-
+-  os = s;
+-  if(n <= 0)
+-    return os;
+-  while(--n > 0 && (*s++ = *t++) != 0)
+-    ;
+-  *s = 0;
+-  return os;
+-}
+-
+-int
+-strlen(const char *s)
+-{
+-  int n;
+-
+-  for(n = 0; s[n]; n++)
+-    ;
+-  return n;
+-}
+-
+diff --git a/swtch.S b/swtch.S
+deleted file mode 100644
+index 63a7dcc..0000000
+--- a/swtch.S
++++ /dev/null
+@@ -1,29 +0,0 @@
+-# Context switch
+-#
+-#   void swtch(struct context **old, struct context *new);
+-# 
+-# Save the current registers on the stack, creating
+-# a struct context, and save its address in *old.
+-# Switch stacks to new and pop previously-saved registers.
+-
+-.globl swtch
+-swtch:
+-  movl 4(%esp), %eax
+-  movl 8(%esp), %edx
+-
+-  # Save old callee-saved registers
+-  pushl %ebp
+-  pushl %ebx
+-  pushl %esi
+-  pushl %edi
+-
+-  # Switch stacks
+-  movl %esp, (%eax)
+-  movl %edx, %esp
+-
+-  # Load new callee-saved registers
+-  popl %edi
+-  popl %esi
+-  popl %ebx
+-  popl %ebp
+-  ret
+diff --git a/syscall.c b/syscall.c
+deleted file mode 100644
+index 41a8c3c..0000000
+--- a/syscall.c
++++ /dev/null
+@@ -1,147 +0,0 @@
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-#include "syscall.h"
+-
+-// User code makes a system call with INT T_SYSCALL.
+-// System call number in %eax.
+-// Arguments on the stack, from the user call to the C
+-// library system call function. The saved user %esp points
+-// to a saved program counter, and then the first argument.
+-
+-// Fetch the int at addr from the current process.
+-int
+-fetchint(uint addr, int *ip)
+-{
+-  struct proc *curproc = myproc();
+-
+-  if(addr >= curproc->sz || addr+4 > curproc->sz)
+-    return -1;
+-  *ip = *(int*)(addr);
+-  return 0;
+-}
+-
+-// Fetch the nul-terminated string at addr from the current process.
+-// Doesn't actually copy the string - just sets *pp to point at it.
+-// Returns length of string, not including nul.
+-int
+-fetchstr(uint addr, char **pp)
+-{
+-  char *s, *ep;
+-  struct proc *curproc = myproc();
+-
+-  if(addr >= curproc->sz)
+-    return -1;
+-  *pp = (char*)addr;
+-  ep = (char*)curproc->sz;
+-  for(s = *pp; s < ep; s++){
+-    if(*s == 0)
+-      return s - *pp;
+-  }
+-  return -1;
+-}
+-
+-// Fetch the nth 32-bit system call argument.
+-int
+-argint(int n, int *ip)
+-{
+-  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+-}
+-
+-// Fetch the nth word-sized system call argument as a pointer
+-// to a block of memory of size bytes.  Check that the pointer
+-// lies within the process address space.
+-int
+-argptr(int n, char **pp, int size)
+-{
+-  int i;
+-  struct proc *curproc = myproc();
+- 
+-  if(argint(n, &i) < 0)
+-    return -1;
+-  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+-    return -1;
+-  *pp = (char*)i;
+-  return 0;
+-}
+-
+-// Fetch the nth word-sized system call argument as a string pointer.
+-// Check that the pointer is valid and the string is nul-terminated.
+-// (There is no shared writable memory, so the string can't change
+-// between this check and being used by the kernel.)
+-int
+-argstr(int n, char **pp)
+-{
+-  int addr;
+-  if(argint(n, &addr) < 0)
+-    return -1;
+-  return fetchstr(addr, pp);
+-}
+-
+-extern int sys_chdir(void);
+-extern int sys_close(void);
+-extern int sys_dup(void);
+-extern int sys_exec(void);
+-extern int sys_exit(void);
+-extern int sys_fork(void);
+-extern int sys_fstat(void);
+-extern int sys_getpid(void);
+-extern int sys_kill(void);
+-extern int sys_link(void);
+-extern int sys_mkdir(void);
+-extern int sys_mknod(void);
+-extern int sys_open(void);
+-extern int sys_pipe(void);
+-extern int sys_read(void);
+-extern int sys_sbrk(void);
+-extern int sys_sleep(void);
+-extern int sys_unlink(void);
+-extern int sys_wait(void);
+-extern int sys_waitpid(void);
+-extern int sys_write(void);
+-extern int sys_uptime(void);
+-
+-static int (*syscalls[])(void) = {
+-[SYS_fork]    sys_fork,
+-[SYS_exit]    sys_exit,
+-[SYS_wait]    sys_wait,
+-[SYS_waitpid] sys_waitpid,
+-[SYS_pipe]    sys_pipe,
+-[SYS_read]    sys_read,
+-[SYS_kill]    sys_kill,
+-[SYS_exec]    sys_exec,
+-[SYS_fstat]   sys_fstat,
+-[SYS_chdir]   sys_chdir,
+-[SYS_dup]     sys_dup,
+-[SYS_getpid]  sys_getpid,
+-[SYS_sbrk]    sys_sbrk,
+-[SYS_sleep]   sys_sleep,
+-[SYS_uptime]  sys_uptime,
+-[SYS_open]    sys_open,
+-[SYS_write]   sys_write,
+-[SYS_mknod]   sys_mknod,
+-[SYS_unlink]  sys_unlink,
+-[SYS_link]    sys_link,
+-[SYS_mkdir]   sys_mkdir,
+-[SYS_close]   sys_close,
+-};
+-
+-void
+-syscall(void)
+-{
+-  int num;
+-  struct proc *curproc = myproc();
+-
+-  num = curproc->tf->eax;
+-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+-    curproc->tf->eax = syscalls[num]();
+-  } else {
+-    cprintf("%d %s: unknown sys call %d\n",
+-            curproc->pid, curproc->name, num);
+-    curproc->tf->eax = -1;
+-  }
+-}
+diff --git a/syscall.h b/syscall.h
+deleted file mode 100644
+index 374ff05..0000000
+--- a/syscall.h
++++ /dev/null
+@@ -1,23 +0,0 @@
+-// System call numbers
+-#define SYS_fork     1
+-#define SYS_exit     2
+-#define SYS_wait     3
+-#define SYS_pipe     4
+-#define SYS_read     5
+-#define SYS_kill     6
+-#define SYS_exec     7
+-#define SYS_fstat    8
+-#define SYS_chdir    9
+-#define SYS_dup     10
+-#define SYS_getpid  11
+-#define SYS_sbrk    12
+-#define SYS_sleep   13
+-#define SYS_uptime  14
+-#define SYS_open    15
+-#define SYS_write   16
+-#define SYS_mknod   17
+-#define SYS_unlink  18
+-#define SYS_link    19
+-#define SYS_mkdir   20
+-#define SYS_close   21
+-#define SYS_waitpid 22
+\ No newline at end of file
+diff --git a/sysfile.c b/sysfile.c
+deleted file mode 100644
+index bfe61b7..0000000
+--- a/sysfile.c
++++ /dev/null
+@@ -1,444 +0,0 @@
+-//
+-// File-system system calls.
+-// Mostly argument checking, since we don't trust
+-// user code, and calls into file.c and fs.c.
+-//
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "stat.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "fs.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "file.h"
+-#include "fcntl.h"
+-
+-// Fetch the nth word-sized system call argument as a file descriptor
+-// and return both the descriptor and the corresponding struct file.
+-static int
+-argfd(int n, int *pfd, struct file **pf)
+-{
+-  int fd;
+-  struct file *f;
+-
+-  if(argint(n, &fd) < 0)
+-    return -1;
+-  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+-    return -1;
+-  if(pfd)
+-    *pfd = fd;
+-  if(pf)
+-    *pf = f;
+-  return 0;
+-}
+-
+-// Allocate a file descriptor for the given file.
+-// Takes over file reference from caller on success.
+-static int
+-fdalloc(struct file *f)
+-{
+-  int fd;
+-  struct proc *curproc = myproc();
+-
+-  for(fd = 0; fd < NOFILE; fd++){
+-    if(curproc->ofile[fd] == 0){
+-      curproc->ofile[fd] = f;
+-      return fd;
+-    }
+-  }
+-  return -1;
+-}
+-
+-int
+-sys_dup(void)
+-{
+-  struct file *f;
+-  int fd;
+-
+-  if(argfd(0, 0, &f) < 0)
+-    return -1;
+-  if((fd=fdalloc(f)) < 0)
+-    return -1;
+-  filedup(f);
+-  return fd;
+-}
+-
+-int
+-sys_read(void)
+-{
+-  struct file *f;
+-  int n;
+-  char *p;
+-
+-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+-    return -1;
+-  return fileread(f, p, n);
+-}
+-
+-int
+-sys_write(void)
+-{
+-  struct file *f;
+-  int n;
+-  char *p;
+-
+-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+-    return -1;
+-  return filewrite(f, p, n);
+-}
+-
+-int
+-sys_close(void)
+-{
+-  int fd;
+-  struct file *f;
+-
+-  if(argfd(0, &fd, &f) < 0)
+-    return -1;
+-  myproc()->ofile[fd] = 0;
+-  fileclose(f);
+-  return 0;
+-}
+-
+-int
+-sys_fstat(void)
+-{
+-  struct file *f;
+-  struct stat *st;
+-
+-  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+-    return -1;
+-  return filestat(f, st);
+-}
+-
+-// Create the path new as a link to the same inode as old.
+-int
+-sys_link(void)
+-{
+-  char name[DIRSIZ], *new, *old;
+-  struct inode *dp, *ip;
+-
+-  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
+-    return -1;
+-
+-  begin_op();
+-  if((ip = namei(old)) == 0){
+-    end_op();
+-    return -1;
+-  }
+-
+-  ilock(ip);
+-  if(ip->type == T_DIR){
+-    iunlockput(ip);
+-    end_op();
+-    return -1;
+-  }
+-
+-  ip->nlink++;
+-  iupdate(ip);
+-  iunlock(ip);
+-
+-  if((dp = nameiparent(new, name)) == 0)
+-    goto bad;
+-  ilock(dp);
+-  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+-    iunlockput(dp);
+-    goto bad;
+-  }
+-  iunlockput(dp);
+-  iput(ip);
+-
+-  end_op();
+-
+-  return 0;
+-
+-bad:
+-  ilock(ip);
+-  ip->nlink--;
+-  iupdate(ip);
+-  iunlockput(ip);
+-  end_op();
+-  return -1;
+-}
+-
+-// Is the directory dp empty except for "." and ".." ?
+-static int
+-isdirempty(struct inode *dp)
+-{
+-  int off;
+-  struct dirent de;
+-
+-  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+-      panic("isdirempty: readi");
+-    if(de.inum != 0)
+-      return 0;
+-  }
+-  return 1;
+-}
+-
+-//PAGEBREAK!
+-int
+-sys_unlink(void)
+-{
+-  struct inode *ip, *dp;
+-  struct dirent de;
+-  char name[DIRSIZ], *path;
+-  uint off;
+-
+-  if(argstr(0, &path) < 0)
+-    return -1;
+-
+-  begin_op();
+-  if((dp = nameiparent(path, name)) == 0){
+-    end_op();
+-    return -1;
+-  }
+-
+-  ilock(dp);
+-
+-  // Cannot unlink "." or "..".
+-  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+-    goto bad;
+-
+-  if((ip = dirlookup(dp, name, &off)) == 0)
+-    goto bad;
+-  ilock(ip);
+-
+-  if(ip->nlink < 1)
+-    panic("unlink: nlink < 1");
+-  if(ip->type == T_DIR && !isdirempty(ip)){
+-    iunlockput(ip);
+-    goto bad;
+-  }
+-
+-  memset(&de, 0, sizeof(de));
+-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+-    panic("unlink: writei");
+-  if(ip->type == T_DIR){
+-    dp->nlink--;
+-    iupdate(dp);
+-  }
+-  iunlockput(dp);
+-
+-  ip->nlink--;
+-  iupdate(ip);
+-  iunlockput(ip);
+-
+-  end_op();
+-
+-  return 0;
+-
+-bad:
+-  iunlockput(dp);
+-  end_op();
+-  return -1;
+-}
+-
+-static struct inode*
+-create(char *path, short type, short major, short minor)
+-{
+-  struct inode *ip, *dp;
+-  char name[DIRSIZ];
+-
+-  if((dp = nameiparent(path, name)) == 0)
+-    return 0;
+-  ilock(dp);
+-
+-  if((ip = dirlookup(dp, name, 0)) != 0){
+-    iunlockput(dp);
+-    ilock(ip);
+-    if(type == T_FILE && ip->type == T_FILE)
+-      return ip;
+-    iunlockput(ip);
+-    return 0;
+-  }
+-
+-  if((ip = ialloc(dp->dev, type)) == 0)
+-    panic("create: ialloc");
+-
+-  ilock(ip);
+-  ip->major = major;
+-  ip->minor = minor;
+-  ip->nlink = 1;
+-  iupdate(ip);
+-
+-  if(type == T_DIR){  // Create . and .. entries.
+-    dp->nlink++;  // for ".."
+-    iupdate(dp);
+-    // No ip->nlink++ for ".": avoid cyclic ref count.
+-    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+-      panic("create dots");
+-  }
+-
+-  if(dirlink(dp, name, ip->inum) < 0)
+-    panic("create: dirlink");
+-
+-  iunlockput(dp);
+-
+-  return ip;
+-}
+-
+-int
+-sys_open(void)
+-{
+-  char *path;
+-  int fd, omode;
+-  struct file *f;
+-  struct inode *ip;
+-
+-  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
+-    return -1;
+-
+-  begin_op();
+-
+-  if(omode & O_CREATE){
+-    ip = create(path, T_FILE, 0, 0);
+-    if(ip == 0){
+-      end_op();
+-      return -1;
+-    }
+-  } else {
+-    if((ip = namei(path)) == 0){
+-      end_op();
+-      return -1;
+-    }
+-    ilock(ip);
+-    if(ip->type == T_DIR && omode != O_RDONLY){
+-      iunlockput(ip);
+-      end_op();
+-      return -1;
+-    }
+-  }
+-
+-  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
+-    if(f)
+-      fileclose(f);
+-    iunlockput(ip);
+-    end_op();
+-    return -1;
+-  }
+-  iunlock(ip);
+-  end_op();
+-
+-  f->type = FD_INODE;
+-  f->ip = ip;
+-  f->off = 0;
+-  f->readable = !(omode & O_WRONLY);
+-  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+-  return fd;
+-}
+-
+-int
+-sys_mkdir(void)
+-{
+-  char *path;
+-  struct inode *ip;
+-
+-  begin_op();
+-  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
+-    end_op();
+-    return -1;
+-  }
+-  iunlockput(ip);
+-  end_op();
+-  return 0;
+-}
+-
+-int
+-sys_mknod(void)
+-{
+-  struct inode *ip;
+-  char *path;
+-  int major, minor;
+-
+-  begin_op();
+-  if((argstr(0, &path)) < 0 ||
+-     argint(1, &major) < 0 ||
+-     argint(2, &minor) < 0 ||
+-     (ip = create(path, T_DEV, major, minor)) == 0){
+-    end_op();
+-    return -1;
+-  }
+-  iunlockput(ip);
+-  end_op();
+-  return 0;
+-}
+-
+-int
+-sys_chdir(void)
+-{
+-  char *path;
+-  struct inode *ip;
+-  struct proc *curproc = myproc();
+-  
+-  begin_op();
+-  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
+-    end_op();
+-    return -1;
+-  }
+-  ilock(ip);
+-  if(ip->type != T_DIR){
+-    iunlockput(ip);
+-    end_op();
+-    return -1;
+-  }
+-  iunlock(ip);
+-  iput(curproc->cwd);
+-  end_op();
+-  curproc->cwd = ip;
+-  return 0;
+-}
+-
+-int
+-sys_exec(void)
+-{
+-  char *path, *argv[MAXARG];
+-  int i;
+-  uint uargv, uarg;
+-
+-  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
+-    return -1;
+-  }
+-  memset(argv, 0, sizeof(argv));
+-  for(i=0;; i++){
+-    if(i >= NELEM(argv))
+-      return -1;
+-    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
+-      return -1;
+-    if(uarg == 0){
+-      argv[i] = 0;
+-      break;
+-    }
+-    if(fetchstr(uarg, &argv[i]) < 0)
+-      return -1;
+-  }
+-  return exec(path, argv);
+-}
+-
+-int
+-sys_pipe(void)
+-{
+-  int *fd;
+-  struct file *rf, *wf;
+-  int fd0, fd1;
+-
+-  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
+-    return -1;
+-  if(pipealloc(&rf, &wf) < 0)
+-    return -1;
+-  fd0 = -1;
+-  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
+-    if(fd0 >= 0)
+-      myproc()->ofile[fd0] = 0;
+-    fileclose(rf);
+-    fileclose(wf);
+-    return -1;
+-  }
+-  fd[0] = fd0;
+-  fd[1] = fd1;
+-  return 0;
+-}
+diff --git a/sysproc.c b/sysproc.c
+deleted file mode 100644
+index ebccf84..0000000
+--- a/sysproc.c
++++ /dev/null
+@@ -1,97 +0,0 @@
+-#include "types.h"
+-#include "x86.h"
+-#include "defs.h"
+-#include "date.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-
+-int
+-sys_fork(void)
+-{
+-  return fork();
+-}
+-
+-int
+-sys_exit(int status)
+-{
+-  exit(status);
+-  return 0;  // not reached
+-}
+-
+-int
+-sys_wait(int* status)
+-{
+-  return wait(status);
+-}
+-
+-int
+-sys_waitpid(int pid, int* status, int options)
+-{
+-    return waitpid(pid, status, options);
+-}
+-
+-int
+-sys_kill(void)
+-{
+-  int pid;
+-
+-  if(argint(0, &pid) < 0)
+-    return -1;
+-  return kill(pid);
+-}
+-
+-int
+-sys_getpid(void)
+-{
+-  return myproc()->pid;
+-}
+-
+-int
+-sys_sbrk(void)
+-{
+-  int addr;
+-  int n;
+-
+-  if(argint(0, &n) < 0)
+-    return -1;
+-  addr = myproc()->sz;
+-  if(growproc(n) < 0)
+-    return -1;
+-  return addr;
+-}
+-
+-int
+-sys_sleep(void)
+-{
+-  int n;
+-  uint ticks0;
+-
+-  if(argint(0, &n) < 0)
+-    return -1;
+-  acquire(&tickslock);
+-  ticks0 = ticks;
+-  while(ticks - ticks0 < n){
+-    if(myproc()->killed){
+-      release(&tickslock);
+-      return -1;
+-    }
+-    sleep(&ticks, &tickslock);
+-  }
+-  release(&tickslock);
+-  return 0;
+-}
+-
+-// return how many clock tick interrupts have occurred
+-// since start.
+-int
+-sys_uptime(void)
+-{
+-  uint xticks;
+-
+-  acquire(&tickslock);
+-  xticks = ticks;
+-  release(&tickslock);
+-  return xticks;
+-}
+diff --git a/toc.ftr b/toc.ftr
+deleted file mode 100644
+index 0061c1d..0000000
+--- a/toc.ftr
++++ /dev/null
+@@ -1,13 +0,0 @@
+-
+-
+-The source listing is preceded by a cross-reference that lists every defined 
+-constant, struct, global variable, and function in xv6.  Each entry gives,
+-on the same line as the name, the line number (or, in a few cases, numbers)
+-where the name is defined.  Successive lines in an entry list the line
+-numbers where the name is used.  For example, this entry:
+-
+-    swtch 2658
+-        0374 2428 2466 2657 2658
+-
+-indicates that swtch is defined on line 2658 and is mentioned on five lines
+-on sheets 03, 24, and 26.
+diff --git a/toc.hdr b/toc.hdr
+deleted file mode 100644
+index 3698d81..0000000
+--- a/toc.hdr
++++ /dev/null
+@@ -1,6 +0,0 @@
+-The numbers to the left of the file names in the table are sheet numbers.
+-The source code has been printed in a double column format with fifty
+-lines per column, giving one hundred lines per sheet (or page).
+-Thus there is a convenient relationship between line numbers and sheet numbers.
+-
+-
 diff --git a/trap.c b/trap.c
-index 41c66eb..432ea5b 100644
+deleted file mode 100644
+index 432ea5b..0000000
 --- a/trap.c
-+++ b/trap.c
-@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
- {
-   if(tf->trapno == T_SYSCALL){
-     if(myproc()->killed)
--      exit();
-+      exit(4);
-     myproc()->tf = tf;
-     syscall();
-     if(myproc()->killed)
--      exit();
-+      exit(3);
-     return;
-   }
- 
-@@ -98,7 +98,7 @@ trap(struct trapframe *tf)
-   // (If it is still executing in the kernel, let it keep running
-   // until it gets to the regular system call return.)
-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
--    exit();
-+    exit(2);
- 
-   // Force process to give up CPU on clock tick.
-   // If interrupts were on while locks held, would need to check nlock.
-@@ -108,5 +108,5 @@ trap(struct trapframe *tf)
- 
-   // Check if the process has been killed since we yielded
-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
--    exit();
-+    exit(1);
- }
++++ /dev/null
+@@ -1,112 +0,0 @@
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-#include "traps.h"
+-#include "spinlock.h"
+-
+-// Interrupt descriptor table (shared by all CPUs).
+-struct gatedesc idt[256];
+-extern uint vectors[];  // in vectors.S: array of 256 entry pointers
+-struct spinlock tickslock;
+-uint ticks;
+-
+-void
+-tvinit(void)
+-{
+-  int i;
+-
+-  for(i = 0; i < 256; i++)
+-    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
+-  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+-
+-  initlock(&tickslock, "time");
+-}
+-
+-void
+-idtinit(void)
+-{
+-  lidt(idt, sizeof(idt));
+-}
+-
+-//PAGEBREAK: 41
+-void
+-trap(struct trapframe *tf)
+-{
+-  if(tf->trapno == T_SYSCALL){
+-    if(myproc()->killed)
+-      exit(4);
+-    myproc()->tf = tf;
+-    syscall();
+-    if(myproc()->killed)
+-      exit(3);
+-    return;
+-  }
+-
+-  switch(tf->trapno){
+-  case T_IRQ0 + IRQ_TIMER:
+-    if(cpuid() == 0){
+-      acquire(&tickslock);
+-      ticks++;
+-      wakeup(&ticks);
+-      release(&tickslock);
+-    }
+-    lapiceoi();
+-    break;
+-  case T_IRQ0 + IRQ_IDE:
+-    ideintr();
+-    lapiceoi();
+-    break;
+-  case T_IRQ0 + IRQ_IDE+1:
+-    // Bochs generates spurious IDE1 interrupts.
+-    break;
+-  case T_IRQ0 + IRQ_KBD:
+-    kbdintr();
+-    lapiceoi();
+-    break;
+-  case T_IRQ0 + IRQ_COM1:
+-    uartintr();
+-    lapiceoi();
+-    break;
+-  case T_IRQ0 + 7:
+-  case T_IRQ0 + IRQ_SPURIOUS:
+-    cprintf("cpu%d: spurious interrupt at %x:%x\n",
+-            cpuid(), tf->cs, tf->eip);
+-    lapiceoi();
+-    break;
+-
+-  //PAGEBREAK: 13
+-  default:
+-    if(myproc() == 0 || (tf->cs&3) == 0){
+-      // In kernel, it must be our mistake.
+-      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+-              tf->trapno, cpuid(), tf->eip, rcr2());
+-      panic("trap");
+-    }
+-    // In user space, assume process misbehaved.
+-    cprintf("pid %d %s: trap %d err %d on cpu %d "
+-            "eip 0x%x addr 0x%x--kill proc\n",
+-            myproc()->pid, myproc()->name, tf->trapno,
+-            tf->err, cpuid(), tf->eip, rcr2());
+-    myproc()->killed = 1;
+-  }
+-
+-  // Force process exit if it has been killed and is in user space.
+-  // (If it is still executing in the kernel, let it keep running
+-  // until it gets to the regular system call return.)
+-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+-    exit(2);
+-
+-  // Force process to give up CPU on clock tick.
+-  // If interrupts were on while locks held, would need to check nlock.
+-  if(myproc() && myproc()->state == RUNNING &&
+-     tf->trapno == T_IRQ0+IRQ_TIMER)
+-    yield();
+-
+-  // Check if the process has been killed since we yielded
+-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+-    exit(1);
+-}
+diff --git a/trapasm.S b/trapasm.S
+deleted file mode 100644
+index da8aefc..0000000
+--- a/trapasm.S
++++ /dev/null
+@@ -1,32 +0,0 @@
+-#include "mmu.h"
+-
+-  # vectors.S sends all traps here.
+-.globl alltraps
+-alltraps:
+-  # Build trap frame.
+-  pushl %ds
+-  pushl %es
+-  pushl %fs
+-  pushl %gs
+-  pushal
+-  
+-  # Set up data segments.
+-  movw $(SEG_KDATA<<3), %ax
+-  movw %ax, %ds
+-  movw %ax, %es
+-
+-  # Call trap(tf), where tf=%esp
+-  pushl %esp
+-  call trap
+-  addl $4, %esp
+-
+-  # Return falls through to trapret...
+-.globl trapret
+-trapret:
+-  popal
+-  popl %gs
+-  popl %fs
+-  popl %es
+-  popl %ds
+-  addl $0x8, %esp  # trapno and errcode
+-  iret
+diff --git a/traps.h b/traps.h
+deleted file mode 100644
+index 0bd1fd8..0000000
+--- a/traps.h
++++ /dev/null
+@@ -1,38 +0,0 @@
+-// x86 trap and interrupt constants.
+-
+-// Processor-defined:
+-#define T_DIVIDE         0      // divide error
+-#define T_DEBUG          1      // debug exception
+-#define T_NMI            2      // non-maskable interrupt
+-#define T_BRKPT          3      // breakpoint
+-#define T_OFLOW          4      // overflow
+-#define T_BOUND          5      // bounds check
+-#define T_ILLOP          6      // illegal opcode
+-#define T_DEVICE         7      // device not available
+-#define T_DBLFLT         8      // double fault
+-// #define T_COPROC      9      // reserved (not used since 486)
+-#define T_TSS           10      // invalid task switch segment
+-#define T_SEGNP         11      // segment not present
+-#define T_STACK         12      // stack exception
+-#define T_GPFLT         13      // general protection fault
+-#define T_PGFLT         14      // page fault
+-// #define T_RES        15      // reserved
+-#define T_FPERR         16      // floating point error
+-#define T_ALIGN         17      // aligment check
+-#define T_MCHK          18      // machine check
+-#define T_SIMDERR       19      // SIMD floating point error
+-
+-// These are arbitrarily chosen, but with care not to overlap
+-// processor defined exceptions or interrupt vectors.
+-#define T_SYSCALL       64      // system call
+-#define T_DEFAULT      500      // catchall
+-
+-#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ
+-
+-#define IRQ_TIMER        0
+-#define IRQ_KBD          1
+-#define IRQ_COM1         4
+-#define IRQ_IDE         14
+-#define IRQ_ERROR       19
+-#define IRQ_SPURIOUS    31
+-
+diff --git a/types.h b/types.h
+deleted file mode 100644
+index e4adf64..0000000
+--- a/types.h
++++ /dev/null
+@@ -1,4 +0,0 @@
+-typedef unsigned int   uint;
+-typedef unsigned short ushort;
+-typedef unsigned char  uchar;
+-typedef uint pde_t;
+diff --git a/uart.c b/uart.c
+deleted file mode 100644
+index b8946da..0000000
+--- a/uart.c
++++ /dev/null
+@@ -1,77 +0,0 @@
+-// Intel 8250 serial port (UART).
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "traps.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "file.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-
+-#define COM1    0x3f8
+-
+-static int uart;    // is there a uart?
+-
+-void
+-uartinit(void)
+-{
+-  char *p;
+-
+-  // Turn off the FIFO
+-  outb(COM1+2, 0);
+-
+-  // 9600 baud, 8 data bits, 1 stop bit, parity off.
+-  outb(COM1+3, 0x80);    // Unlock divisor
+-  outb(COM1+0, 115200/9600);
+-  outb(COM1+1, 0);
+-  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
+-  outb(COM1+4, 0);
+-  outb(COM1+1, 0x01);    // Enable receive interrupts.
+-
+-  // If status is 0xFF, no serial port.
+-  if(inb(COM1+5) == 0xFF)
+-    return;
+-  uart = 1;
+-
+-  // Acknowledge pre-existing interrupt conditions;
+-  // enable interrupts.
+-  inb(COM1+2);
+-  inb(COM1+0);
+-  ioapicenable(IRQ_COM1, 0);
+-
+-  // Announce that we're here.
+-  for(p="xv6...\n"; *p; p++)
+-    uartputc(*p);
+-}
+-
+-void
+-uartputc(int c)
+-{
+-  int i;
+-
+-  if(!uart)
+-    return;
+-  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
+-    microdelay(10);
+-  outb(COM1+0, c);
+-}
+-
+-static int
+-uartgetc(void)
+-{
+-  if(!uart)
+-    return -1;
+-  if(!(inb(COM1+5) & 0x01))
+-    return -1;
+-  return inb(COM1+0);
+-}
+-
+-void
+-uartintr(void)
+-{
+-  consoleintr(uartgetc);
+-}
+diff --git a/ulib.c b/ulib.c
+deleted file mode 100644
+index 8e1e1a2..0000000
+--- a/ulib.c
++++ /dev/null
+@@ -1,106 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "fcntl.h"
+-#include "user.h"
+-#include "x86.h"
+-
+-char*
+-strcpy(char *s, const char *t)
+-{
+-  char *os;
+-
+-  os = s;
+-  while((*s++ = *t++) != 0)
+-    ;
+-  return os;
+-}
+-
+-int
+-strcmp(const char *p, const char *q)
+-{
+-  while(*p && *p == *q)
+-    p++, q++;
+-  return (uchar)*p - (uchar)*q;
+-}
+-
+-uint
+-strlen(const char *s)
+-{
+-  int n;
+-
+-  for(n = 0; s[n]; n++)
+-    ;
+-  return n;
+-}
+-
+-void*
+-memset(void *dst, int c, uint n)
+-{
+-  stosb(dst, c, n);
+-  return dst;
+-}
+-
+-char*
+-strchr(const char *s, char c)
+-{
+-  for(; *s; s++)
+-    if(*s == c)
+-      return (char*)s;
+-  return 0;
+-}
+-
+-char*
+-gets(char *buf, int max)
+-{
+-  int i, cc;
+-  char c;
+-
+-  for(i=0; i+1 < max; ){
+-    cc = read(0, &c, 1);
+-    if(cc < 1)
+-      break;
+-    buf[i++] = c;
+-    if(c == '\n' || c == '\r')
+-      break;
+-  }
+-  buf[i] = '\0';
+-  return buf;
+-}
+-
+-int
+-stat(const char *n, struct stat *st)
+-{
+-  int fd;
+-  int r;
+-
+-  fd = open(n, O_RDONLY);
+-  if(fd < 0)
+-    return -1;
+-  r = fstat(fd, st);
+-  close(fd);
+-  return r;
+-}
+-
+-int
+-atoi(const char *s)
+-{
+-  int n;
+-
+-  n = 0;
+-  while('0' <= *s && *s <= '9')
+-    n = n*10 + *s++ - '0';
+-  return n;
+-}
+-
+-void*
+-memmove(void *vdst, const void *vsrc, int n)
+-{
+-  char *dst;
+-  const char *src;
+-
+-  dst = vdst;
+-  src = vsrc;
+-  while(n-- > 0)
+-    *dst++ = *src++;
+-  return vdst;
+-}
+diff --git a/umalloc.c b/umalloc.c
+deleted file mode 100644
+index a7e7d2c..0000000
+--- a/umalloc.c
++++ /dev/null
+@@ -1,90 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-#include "param.h"
+-
+-// Memory allocator by Kernighan and Ritchie,
+-// The C programming Language, 2nd ed.  Section 8.7.
+-
+-typedef long Align;
+-
+-union header {
+-  struct {
+-    union header *ptr;
+-    uint size;
+-  } s;
+-  Align x;
+-};
+-
+-typedef union header Header;
+-
+-static Header base;
+-static Header *freep;
+-
+-void
+-free(void *ap)
+-{
+-  Header *bp, *p;
+-
+-  bp = (Header*)ap - 1;
+-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+-      break;
+-  if(bp + bp->s.size == p->s.ptr){
+-    bp->s.size += p->s.ptr->s.size;
+-    bp->s.ptr = p->s.ptr->s.ptr;
+-  } else
+-    bp->s.ptr = p->s.ptr;
+-  if(p + p->s.size == bp){
+-    p->s.size += bp->s.size;
+-    p->s.ptr = bp->s.ptr;
+-  } else
+-    p->s.ptr = bp;
+-  freep = p;
+-}
+-
+-static Header*
+-morecore(uint nu)
+-{
+-  char *p;
+-  Header *hp;
+-
+-  if(nu < 4096)
+-    nu = 4096;
+-  p = sbrk(nu * sizeof(Header));
+-  if(p == (char*)-1)
+-    return 0;
+-  hp = (Header*)p;
+-  hp->s.size = nu;
+-  free((void*)(hp + 1));
+-  return freep;
+-}
+-
+-void*
+-malloc(uint nbytes)
+-{
+-  Header *p, *prevp;
+-  uint nunits;
+-
+-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+-  if((prevp = freep) == 0){
+-    base.s.ptr = freep = prevp = &base;
+-    base.s.size = 0;
+-  }
+-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+-    if(p->s.size >= nunits){
+-      if(p->s.size == nunits)
+-        prevp->s.ptr = p->s.ptr;
+-      else {
+-        p->s.size -= nunits;
+-        p += p->s.size;
+-        p->s.size = nunits;
+-      }
+-      freep = prevp;
+-      return (void*)(p + 1);
+-    }
+-    if(p == freep)
+-      if((p = morecore(nunits)) == 0)
+-        return 0;
+-  }
+-}
 diff --git a/user.h b/user.h
-index 4f99c52..0931387 100644
+deleted file mode 100644
+index 0931387..0000000
 --- a/user.h
-+++ b/user.h
-@@ -1,10 +1,13 @@
-+#include <stddef.h>
-+
- struct stat;
- struct rtcdate;
- 
- // system calls
- int fork(void);
--int exit(void) __attribute__((noreturn));
--int wait(void);
-+int exit(int status) __attribute__((noreturn));
-+int wait(int* status);
-+int waitpid(int pid, int* status, int options);
- int pipe(int*);
- int write(int, const void*, int);
- int read(int, void*, int);
++++ /dev/null
+@@ -1,42 +0,0 @@
+-#include <stddef.h>
+-
+-struct stat;
+-struct rtcdate;
+-
+-// system calls
+-int fork(void);
+-int exit(int status) __attribute__((noreturn));
+-int wait(int* status);
+-int waitpid(int pid, int* status, int options);
+-int pipe(int*);
+-int write(int, const void*, int);
+-int read(int, void*, int);
+-int close(int);
+-int kill(int);
+-int exec(char*, char**);
+-int open(const char*, int);
+-int mknod(const char*, short, short);
+-int unlink(const char*);
+-int fstat(int fd, struct stat*);
+-int link(const char*, const char*);
+-int mkdir(const char*);
+-int chdir(const char*);
+-int dup(int);
+-int getpid(void);
+-char* sbrk(int);
+-int sleep(int);
+-int uptime(void);
+-
+-// ulib.c
+-int stat(const char*, struct stat*);
+-char* strcpy(char*, const char*);
+-void *memmove(void*, const void*, int);
+-char* strchr(const char*, char c);
+-int strcmp(const char*, const char*);
+-void printf(int, const char*, ...);
+-char* gets(char*, int max);
+-uint strlen(const char*);
+-void* memset(void*, int, uint);
+-void* malloc(uint);
+-void free(void*);
+-int atoi(const char*);
 diff --git a/usertests.c b/usertests.c
-index a1e97e7..2c2c128 100644
+deleted file mode 100644
+index 2c2c128..0000000
 --- a/usertests.c
-+++ b/usertests.c
-@@ -21,19 +21,19 @@ iputtest(void)
- 
-   if(mkdir("iputdir") < 0){
-     printf(stdout, "mkdir failed\n");
--    exit();
-+    exit(184);
-   }
-   if(chdir("iputdir") < 0){
-     printf(stdout, "chdir iputdir failed\n");
--    exit();
-+    exit(183);
-   }
-   if(unlink("../iputdir") < 0){
-     printf(stdout, "unlink ../iputdir failed\n");
--    exit();
-+    exit(182);
-   }
-   if(chdir("/") < 0){
-     printf(stdout, "chdir / failed\n");
--    exit();
-+    exit(181);
-   }
-   printf(stdout, "iput test ok\n");
- }
-@@ -49,24 +49,24 @@ exitiputtest(void)
-   pid = fork();
-   if(pid < 0){
-     printf(stdout, "fork failed\n");
--    exit();
-+    exit(180);
-   }
-   if(pid == 0){
-     if(mkdir("iputdir") < 0){
-       printf(stdout, "mkdir failed\n");
--      exit();
-+      exit(179);
-     }
-     if(chdir("iputdir") < 0){
-       printf(stdout, "child chdir failed\n");
--      exit();
-+      exit(178);
-     }
-     if(unlink("../iputdir") < 0){
-       printf(stdout, "unlink ../iputdir failed\n");
--      exit();
-+      exit(177);
-     }
--    exit();
-+    exit(176);
-   }
--  wait();
-+  wait(NULL);
-   printf(stdout, "exitiput test ok\n");
- }
- 
-@@ -89,27 +89,27 @@ openiputtest(void)
-   printf(stdout, "openiput test\n");
-   if(mkdir("oidir") < 0){
-     printf(stdout, "mkdir oidir failed\n");
--    exit();
-+    exit(175);
-   }
-   pid = fork();
-   if(pid < 0){
-     printf(stdout, "fork failed\n");
--    exit();
-+    exit(174);
-   }
-   if(pid == 0){
-     int fd = open("oidir", O_RDWR);
-     if(fd >= 0){
-       printf(stdout, "open directory for write succeeded\n");
--      exit();
-+      exit(0);
-     }
--    exit();
-+    exit(172);
-   }
-   sleep(1);
-   if(unlink("oidir") != 0){
-     printf(stdout, "unlink failed\n");
--    exit();
-+    exit(171);
-   }
--  wait();
-+  wait(NULL);
-   printf(stdout, "openiput test ok\n");
- }
- 
-@@ -124,13 +124,13 @@ opentest(void)
-   fd = open("echo", 0);
-   if(fd < 0){
-     printf(stdout, "open echo failed!\n");
--    exit();
-+    exit(170);
-   }
-   close(fd);
-   fd = open("doesnotexist", 0);
-   if(fd >= 0){
-     printf(stdout, "open doesnotexist succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   printf(stdout, "open test ok\n");
- }
-@@ -147,16 +147,16 @@ writetest(void)
-     printf(stdout, "creat small succeeded; ok\n");
-   } else {
-     printf(stdout, "error: creat small failed!\n");
--    exit();
-+    exit(168);
-   }
-   for(i = 0; i < 100; i++){
-     if(write(fd, "aaaaaaaaaa", 10) != 10){
-       printf(stdout, "error: write aa %d new file failed\n", i);
--      exit();
-+      exit(167);
-     }
-     if(write(fd, "bbbbbbbbbb", 10) != 10){
-       printf(stdout, "error: write bb %d new file failed\n", i);
--      exit();
-+      exit(166);
-     }
-   }
-   printf(stdout, "writes ok\n");
-@@ -166,20 +166,20 @@ writetest(void)
-     printf(stdout, "open small succeeded ok\n");
-   } else {
-     printf(stdout, "error: open small failed!\n");
--    exit();
-+    exit(165);
-   }
-   i = read(fd, buf, 2000);
-   if(i == 2000){
-     printf(stdout, "read succeeded ok\n");
-   } else {
-     printf(stdout, "read failed\n");
--    exit();
-+    exit(164);
-   }
-   close(fd);
- 
-   if(unlink("small") < 0){
-     printf(stdout, "unlink small failed\n");
--    exit();
-+    exit(163);
-   }
-   printf(stdout, "small file test ok\n");
- }
-@@ -194,14 +194,14 @@ writetest1(void)
-   fd = open("big", O_CREATE|O_RDWR);
-   if(fd < 0){
-     printf(stdout, "error: creat big failed!\n");
--    exit();
-+    exit(162);
-   }
- 
-   for(i = 0; i < MAXFILE; i++){
-     ((int*)buf)[0] = i;
-     if(write(fd, buf, 512) != 512){
-       printf(stdout, "error: write big file failed\n", i);
--      exit();
-+      exit(161);
-     }
-   }
- 
-@@ -210,7 +210,7 @@ writetest1(void)
-   fd = open("big", O_RDONLY);
-   if(fd < 0){
-     printf(stdout, "error: open big failed!\n");
--    exit();
-+    exit(160);
-   }
- 
-   n = 0;
-@@ -219,24 +219,24 @@ writetest1(void)
-     if(i == 0){
-       if(n == MAXFILE - 1){
-         printf(stdout, "read only %d blocks from big", n);
--        exit();
-+        exit(159);
-       }
-       break;
-     } else if(i != 512){
-       printf(stdout, "read failed %d\n", i);
--      exit();
-+      exit(158);
-     }
-     if(((int*)buf)[0] != n){
-       printf(stdout, "read content of block %d is %d\n",
-              n, ((int*)buf)[0]);
--      exit();
-+      exit(157);
-     }
-     n++;
-   }
-   close(fd);
-   if(unlink("big") < 0){
-     printf(stdout, "unlink big failed\n");
--    exit();
-+    exit(156);
-   }
-   printf(stdout, "big files ok\n");
- }
-@@ -270,22 +270,22 @@ void dirtest(void)
- 
-   if(mkdir("dir0") < 0){
-     printf(stdout, "mkdir failed\n");
--    exit();
-+    exit(155);
-   }
- 
-   if(chdir("dir0") < 0){
-     printf(stdout, "chdir dir0 failed\n");
--    exit();
-+    exit(154);
-   }
- 
-   if(chdir("..") < 0){
-     printf(stdout, "chdir .. failed\n");
--    exit();
-+    exit(153);
-   }
- 
-   if(unlink("dir0") < 0){
-     printf(stdout, "unlink dir0 failed\n");
--    exit();
-+    exit(152);
-   }
-   printf(stdout, "mkdir test ok\n");
- }
-@@ -296,7 +296,7 @@ exectest(void)
-   printf(stdout, "exec test\n");
-   if(exec("echo", echoargv) < 0){
-     printf(stdout, "exec echo failed\n");
--    exit();
-+    exit(151);
-   }
- }
- 
-@@ -310,7 +310,7 @@ pipe1(void)
- 
-   if(pipe(fds) != 0){
-     printf(1, "pipe() failed\n");
--    exit();
-+    exit(150);
-   }
-   pid = fork();
-   seq = 0;
-@@ -321,10 +321,10 @@ pipe1(void)
-         buf[i] = seq++;
-       if(write(fds[1], buf, 1033) != 1033){
-         printf(1, "pipe1 oops 1\n");
--        exit();
-+        exit(149);
-       }
-     }
--    exit();
-+    exit(148);
-   } else if(pid > 0){
-     close(fds[1]);
-     total = 0;
-@@ -343,13 +343,13 @@ pipe1(void)
-     }
-     if(total != 5 * 1033){
-       printf(1, "pipe1 oops 3 total %d\n", total);
--      exit();
-+      exit(147);
-     }
-     close(fds[0]);
--    wait();
-+    wait(NULL);
-   } else {
-     printf(1, "fork() failed\n");
--    exit();
-+    exit(146);
-   }
-   printf(1, "pipe1 ok\n");
- }
-@@ -394,9 +394,9 @@ preempt(void)
-   kill(pid2);
-   kill(pid3);
-   printf(1, "wait... ");
--  wait();
--  wait();
--  wait();
-+  wait(NULL);
-+  wait(NULL);
-+  wait(NULL);
-   printf(1, "preempt ok\n");
- }
- 
-@@ -413,12 +413,12 @@ exitwait(void)
-       return;
-     }
-     if(pid){
--      if(wait() != pid){
-+      if(wait(NULL) != pid){
-         printf(1, "wait wrong pid\n");
-         return;
-       }
-     } else {
--      exit();
-+      exit(145);
-     }
-   }
-   printf(1, "exitwait ok\n");
-@@ -447,13 +447,13 @@ mem(void)
-     if(m1 == 0){
-       printf(1, "couldn't allocate mem?!!\n");
-       kill(ppid);
--      exit();
-+      exit(144);
-     }
-     free(m1);
-     printf(1, "mem ok\n");
--    exit();
-+    exit(0);
-   } else {
--    wait();
-+    wait(NULL);
-   }
- }
- 
-@@ -484,9 +484,9 @@ sharedfd(void)
-     }
-   }
-   if(pid == 0)
--    exit();
-+    exit(142);
-   else
--    wait();
-+    wait(NULL);
-   close(fd);
-   fd = open("sharedfd", 0);
-   if(fd < 0){
-@@ -508,7 +508,7 @@ sharedfd(void)
-     printf(1, "sharedfd ok\n");
-   } else {
-     printf(1, "sharedfd oops %d %d\n", nc, np);
--    exit();
-+    exit(141);
-   }
- }
- 
-@@ -530,29 +530,29 @@ fourfiles(void)
-     pid = fork();
-     if(pid < 0){
-       printf(1, "fork failed\n");
--      exit();
-+      exit(140);
-     }
- 
-     if(pid == 0){
-       fd = open(fname, O_CREATE | O_RDWR);
-       if(fd < 0){
-         printf(1, "create failed\n");
--        exit();
-+        exit(139);
-       }
- 
-       memset(buf, '0'+pi, 512);
-       for(i = 0; i < 12; i++){
-         if((n = write(fd, buf, 500)) != 500){
-           printf(1, "write failed %d\n", n);
--          exit();
-+          exit(138);
-         }
-       }
--      exit();
-+      exit(137);
-     }
-   }
- 
-   for(pi = 0; pi < 4; pi++){
--    wait();
-+    wait(NULL);
-   }
- 
-   for(i = 0; i < 2; i++){
-@@ -563,7 +563,7 @@ fourfiles(void)
-       for(j = 0; j < n; j++){
-         if(buf[j] != '0'+i){
-           printf(1, "wrong char\n");
--          exit();
-+          exit(136);
-         }
-       }
-       total += n;
-@@ -571,7 +571,7 @@ fourfiles(void)
-     close(fd);
-     if(total != 12*500){
-       printf(1, "wrong length %d\n", total);
--      exit();
-+      exit(135);
-     }
-     unlink(fname);
-   }
-@@ -593,7 +593,7 @@ createdelete(void)
-     pid = fork();
-     if(pid < 0){
-       printf(1, "fork failed\n");
--      exit();
-+      exit(134);
-     }
- 
-     if(pid == 0){
-@@ -604,23 +604,23 @@ createdelete(void)
-         fd = open(name, O_CREATE | O_RDWR);
-         if(fd < 0){
-           printf(1, "create failed\n");
--          exit();
-+          exit(133);
-         }
-         close(fd);
-         if(i > 0 && (i % 2 ) == 0){
-           name[1] = '0' + (i / 2);
-           if(unlink(name) < 0){
-             printf(1, "unlink failed\n");
--            exit();
-+            exit(132);
-           }
-         }
-       }
--      exit();
-+      exit(131);
-     }
-   }
- 
-   for(pi = 0; pi < 4; pi++){
--    wait();
-+    wait(NULL);
-   }
- 
-   name[0] = name[1] = name[2] = 0;
-@@ -631,10 +631,10 @@ createdelete(void)
-       fd = open(name, 0);
-       if((i == 0 || i >= N/2) && fd < 0){
-         printf(1, "oops createdelete %s didn't exist\n", name);
--        exit();
-+        exit(130);
-       } else if((i >= 1 && i < N/2) && fd >= 0){
-         printf(1, "oops createdelete %s did exist\n", name);
--        exit();
-+        exit(129);
-       }
-       if(fd >= 0)
-         close(fd);
-@@ -662,7 +662,7 @@ unlinkread(void)
-   fd = open("unlinkread", O_CREATE | O_RDWR);
-   if(fd < 0){
-     printf(1, "create unlinkread failed\n");
--    exit();
-+    exit(128);
-   }
-   write(fd, "hello", 5);
-   close(fd);
-@@ -670,11 +670,11 @@ unlinkread(void)
-   fd = open("unlinkread", O_RDWR);
-   if(fd < 0){
-     printf(1, "open unlinkread failed\n");
--    exit();
-+    exit(127);
-   }
-   if(unlink("unlinkread") != 0){
-     printf(1, "unlink unlinkread failed\n");
--    exit();
-+    exit(126);
-   }
- 
-   fd1 = open("unlinkread", O_CREATE | O_RDWR);
-@@ -683,15 +683,15 @@ unlinkread(void)
- 
-   if(read(fd, buf, sizeof(buf)) != 5){
-     printf(1, "unlinkread read failed");
--    exit();
-+    exit(125);
-   }
-   if(buf[0] != 'h'){
-     printf(1, "unlinkread wrong data\n");
--    exit();
-+    exit(124);
-   }
-   if(write(fd, buf, 10) != 10){
-     printf(1, "unlinkread write failed\n");
--    exit();
-+    exit(123);
-   }
-   close(fd);
-   unlink("unlinkread");
-@@ -711,50 +711,50 @@ linktest(void)
-   fd = open("lf1", O_CREATE|O_RDWR);
-   if(fd < 0){
-     printf(1, "create lf1 failed\n");
--    exit();
-+    exit(122);
-   }
-   if(write(fd, "hello", 5) != 5){
-     printf(1, "write lf1 failed\n");
--    exit();
-+    exit(121);
-   }
-   close(fd);
- 
-   if(link("lf1", "lf2") < 0){
-     printf(1, "link lf1 lf2 failed\n");
--    exit();
-+    exit(120);
-   }
-   unlink("lf1");
- 
-   if(open("lf1", 0) >= 0){
-     printf(1, "unlinked lf1 but it is still there!\n");
--    exit();
-+    exit(119);
-   }
- 
-   fd = open("lf2", 0);
-   if(fd < 0){
-     printf(1, "open lf2 failed\n");
--    exit();
-+    exit(118);
-   }
-   if(read(fd, buf, sizeof(buf)) != 5){
-     printf(1, "read lf2 failed\n");
--    exit();
-+    exit(117);
-   }
-   close(fd);
- 
-   if(link("lf2", "lf2") >= 0){
-     printf(1, "link lf2 lf2 succeeded! oops\n");
--    exit();
-+    exit(116);
-   }
- 
-   unlink("lf2");
-   if(link("lf2", "lf1") >= 0){
-     printf(1, "link non-existant succeeded! oops\n");
--    exit();
-+    exit(115);
-   }
- 
-   if(link(".", "lf1") >= 0){
-     printf(1, "link . lf1 succeeded! oops\n");
--    exit();
-+    exit(114);
-   }
- 
-   printf(1, "linktest ok\n");
-@@ -787,14 +787,14 @@ concreate(void)
-       fd = open(file, O_CREATE | O_RDWR);
-       if(fd < 0){
-         printf(1, "concreate create %s failed\n", file);
--        exit();
-+        exit(113);
-       }
-       close(fd);
-     }
-     if(pid == 0)
--      exit();
-+      exit(112);
-     else
--      wait();
-+      wait(NULL);
-   }
- 
-   memset(fa, 0, sizeof(fa));
-@@ -807,11 +807,11 @@ concreate(void)
-       i = de.name[1] - '0';
-       if(i < 0 || i >= sizeof(fa)){
-         printf(1, "concreate weird file %s\n", de.name);
--        exit();
-+        exit(111);
-       }
-       if(fa[i]){
-         printf(1, "concreate duplicate file %s\n", de.name);
--        exit();
-+        exit(110);
-       }
-       fa[i] = 1;
-       n++;
-@@ -821,7 +821,7 @@ concreate(void)
- 
-   if(n != 40){
-     printf(1, "concreate not enough files in directory listing\n");
--    exit();
-+    exit(109);
-   }
- 
-   for(i = 0; i < 40; i++){
-@@ -829,7 +829,7 @@ concreate(void)
-     pid = fork();
-     if(pid < 0){
-       printf(1, "fork failed\n");
--      exit();
-+      exit(108);
-     }
-     if(((i % 3) == 0 && pid == 0) ||
-        ((i % 3) == 1 && pid != 0)){
-@@ -844,9 +844,9 @@ concreate(void)
-       unlink(file);
-     }
-     if(pid == 0)
--      exit();
-+      exit(107);
-     else
--      wait();
-+      wait(NULL);
-   }
- 
-   printf(1, "concreate ok\n");
-@@ -865,7 +865,7 @@ linkunlink()
-   pid = fork();
-   if(pid < 0){
-     printf(1, "fork failed\n");
--    exit();
-+    exit(106);
-   }
- 
-   unsigned int x = (pid ? 1 : 97);
-@@ -881,9 +881,9 @@ linkunlink()
-   }
- 
-   if(pid)
--    wait();
-+    wait(NULL);
-   else
--    exit();
-+    exit(105);
- 
-   printf(1, "linkunlink ok\n");
- }
-@@ -901,7 +901,7 @@ bigdir(void)
-   fd = open("bd", O_CREATE);
-   if(fd < 0){
-     printf(1, "bigdir create failed\n");
--    exit();
-+    exit(104);
-   }
-   close(fd);
- 
-@@ -912,7 +912,7 @@ bigdir(void)
-     name[3] = '\0';
-     if(link("bd", name) != 0){
-       printf(1, "bigdir link failed\n");
--      exit();
-+      exit(103);
-     }
-   }
- 
-@@ -924,7 +924,7 @@ bigdir(void)
-     name[3] = '\0';
-     if(unlink(name) != 0){
-       printf(1, "bigdir unlink failed");
--      exit();
-+      exit(102);
-     }
-   }
- 
-@@ -941,31 +941,31 @@ subdir(void)
-   unlink("ff");
-   if(mkdir("dd") != 0){
-     printf(1, "subdir mkdir dd failed\n");
--    exit();
-+    exit(101);
-   }
- 
-   fd = open("dd/ff", O_CREATE | O_RDWR);
-   if(fd < 0){
-     printf(1, "create dd/ff failed\n");
--    exit();
-+    exit(100);
-   }
-   write(fd, "ff", 2);
-   close(fd);
- 
-   if(unlink("dd") >= 0){
-     printf(1, "unlink dd (non-empty dir) succeeded!\n");
--    exit();
-+    exit(99);
-   }
- 
-   if(mkdir("/dd/dd") != 0){
-     printf(1, "subdir mkdir dd/dd failed\n");
--    exit();
-+    exit(98);
-   }
- 
-   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
-   if(fd < 0){
-     printf(1, "create dd/dd/ff failed\n");
--    exit();
-+    exit(97);
-   }
-   write(fd, "FF", 2);
-   close(fd);
-@@ -973,142 +973,142 @@ subdir(void)
-   fd = open("dd/dd/../ff", 0);
-   if(fd < 0){
-     printf(1, "open dd/dd/../ff failed\n");
--    exit();
-+    exit(96);
-   }
-   cc = read(fd, buf, sizeof(buf));
-   if(cc != 2 || buf[0] != 'f'){
-     printf(1, "dd/dd/../ff wrong content\n");
--    exit();
-+    exit(95);
-   }
-   close(fd);
- 
-   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
-     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
--    exit();
-+    exit(94);
-   }
- 
-   if(unlink("dd/dd/ff") != 0){
-     printf(1, "unlink dd/dd/ff failed\n");
--    exit();
-+    exit(93);
-   }
-   if(open("dd/dd/ff", O_RDONLY) >= 0){
-     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
--    exit();
-+    exit(92);
-   }
- 
-   if(chdir("dd") != 0){
-     printf(1, "chdir dd failed\n");
--    exit();
-+    exit(91);
-   }
-   if(chdir("dd/../../dd") != 0){
-     printf(1, "chdir dd/../../dd failed\n");
--    exit();
-+    exit(90);
-   }
-   if(chdir("dd/../../../dd") != 0){
-     printf(1, "chdir dd/../../dd failed\n");
--    exit();
-+    exit(89);
-   }
-   if(chdir("./..") != 0){
-     printf(1, "chdir ./.. failed\n");
--    exit();
-+    exit(88);
-   }
- 
-   fd = open("dd/dd/ffff", 0);
-   if(fd < 0){
-     printf(1, "open dd/dd/ffff failed\n");
--    exit();
-+    exit(87);
-   }
-   if(read(fd, buf, sizeof(buf)) != 2){
-     printf(1, "read dd/dd/ffff wrong len\n");
--    exit();
-+    exit(86);
-   }
-   close(fd);
- 
-   if(open("dd/dd/ff", O_RDONLY) >= 0){
-     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
- 
-   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
-     printf(1, "create dd/ff/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
-     printf(1, "create dd/xx/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(open("dd", O_CREATE) >= 0){
-     printf(1, "create dd succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(open("dd", O_RDWR) >= 0){
-     printf(1, "open dd rdwr succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(open("dd", O_WRONLY) >= 0){
-     printf(1, "open dd wronly succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(link("dd/ff/ff", "dd/dd/xx") == 0){
-     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(link("dd/xx/ff", "dd/dd/xx") == 0){
-     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(link("dd/ff", "dd/dd/ffff") == 0){
-     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(mkdir("dd/ff/ff") == 0){
-     printf(1, "mkdir dd/ff/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(mkdir("dd/xx/ff") == 0){
-     printf(1, "mkdir dd/xx/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(mkdir("dd/dd/ffff") == 0){
-     printf(1, "mkdir dd/dd/ffff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dd/xx/ff") == 0){
-     printf(1, "unlink dd/xx/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dd/ff/ff") == 0){
-     printf(1, "unlink dd/ff/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(chdir("dd/ff") == 0){
-     printf(1, "chdir dd/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(chdir("dd/xx") == 0){
-     printf(1, "chdir dd/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
- 
-   if(unlink("dd/dd/ffff") != 0){
-     printf(1, "unlink dd/dd/ff failed\n");
--    exit();
-+    exit(68);
-   }
-   if(unlink("dd/ff") != 0){
-     printf(1, "unlink dd/ff failed\n");
--    exit();
-+    exit(67);
-   }
-   if(unlink("dd") == 0){
-     printf(1, "unlink non-empty dd succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dd/dd") < 0){
-     printf(1, "unlink dd/dd failed\n");
--    exit();
-+    exit(65);
-   }
-   if(unlink("dd") < 0){
-     printf(1, "unlink dd failed\n");
--    exit();
-+    exit(64);
-   }
- 
-   printf(1, "subdir ok\n");
-@@ -1127,14 +1127,14 @@ bigwrite(void)
-     fd = open("bigwrite", O_CREATE | O_RDWR);
-     if(fd < 0){
-       printf(1, "cannot create bigwrite\n");
--      exit();
-+      exit(63);
-     }
-     int i;
-     for(i = 0; i < 2; i++){
-       int cc = write(fd, buf, sz);
-       if(cc != sz){
-         printf(1, "write(%d) ret %d\n", sz, cc);
--        exit();
-+        exit(62);
-       }
-     }
-     close(fd);
-@@ -1155,13 +1155,13 @@ bigfile(void)
-   fd = open("bigfile", O_CREATE | O_RDWR);
-   if(fd < 0){
-     printf(1, "cannot create bigfile");
--    exit();
-+    exit(61);
-   }
-   for(i = 0; i < 20; i++){
-     memset(buf, i, 600);
-     if(write(fd, buf, 600) != 600){
-       printf(1, "write bigfile failed\n");
--      exit();
-+      exit(60);
-     }
-   }
-   close(fd);
-@@ -1169,31 +1169,31 @@ bigfile(void)
-   fd = open("bigfile", 0);
-   if(fd < 0){
-     printf(1, "cannot open bigfile\n");
--    exit();
-+    exit(59);
-   }
-   total = 0;
-   for(i = 0; ; i++){
-     cc = read(fd, buf, 300);
-     if(cc < 0){
-       printf(1, "read bigfile failed\n");
--      exit();
-+      exit(58);
-     }
-     if(cc == 0)
-       break;
-     if(cc != 300){
-       printf(1, "short read bigfile\n");
--      exit();
-+      exit(57);
-     }
-     if(buf[0] != i/2 || buf[299] != i/2){
-       printf(1, "read bigfile wrong data\n");
--      exit();
-+      exit(56);
-     }
-     total += cc;
-   }
-   close(fd);
-   if(total != 20*600){
-     printf(1, "read bigfile wrong total\n");
--    exit();
-+    exit(55);
-   }
-   unlink("bigfile");
- 
-@@ -1210,32 +1210,32 @@ fourteen(void)
- 
-   if(mkdir("12345678901234") != 0){
-     printf(1, "mkdir 12345678901234 failed\n");
--    exit();
-+    exit(54);
-   }
-   if(mkdir("12345678901234/123456789012345") != 0){
-     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
--    exit();
-+    exit(53);
-   }
-   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
-   if(fd < 0){
-     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
--    exit();
-+    exit(52);
-   }
-   close(fd);
-   fd = open("12345678901234/12345678901234/12345678901234", 0);
-   if(fd < 0){
-     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
--    exit();
-+    exit(51);
-   }
-   close(fd);
- 
-   if(mkdir("12345678901234/12345678901234") == 0){
-     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(mkdir("123456789012345/12345678901234") == 0){
-     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
--    exit();
-+    exit(0);
-   }
- 
-   printf(1, "fourteen ok\n");
-@@ -1247,35 +1247,35 @@ rmdot(void)
-   printf(1, "rmdot test\n");
-   if(mkdir("dots") != 0){
-     printf(1, "mkdir dots failed\n");
--    exit();
-+    exit(48);
-   }
-   if(chdir("dots") != 0){
-     printf(1, "chdir dots failed\n");
--    exit();
-+    exit(47);
-   }
-   if(unlink(".") == 0){
-     printf(1, "rm . worked!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("..") == 0){
-     printf(1, "rm .. worked!\n");
--    exit();
-+    exit(0);
-   }
-   if(chdir("/") != 0){
-     printf(1, "chdir / failed\n");
--    exit();
-+    exit(44);
-   }
-   if(unlink("dots/.") == 0){
-     printf(1, "unlink dots/. worked!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dots/..") == 0){
-     printf(1, "unlink dots/.. worked!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dots") != 0){
-     printf(1, "unlink dots failed!\n");
--    exit();
-+    exit(41);
-   }
-   printf(1, "rmdot ok\n");
- }
-@@ -1290,49 +1290,49 @@ dirfile(void)
-   fd = open("dirfile", O_CREATE);
-   if(fd < 0){
-     printf(1, "create dirfile failed\n");
--    exit();
-+    exit(40);
-   }
-   close(fd);
-   if(chdir("dirfile") == 0){
-     printf(1, "chdir dirfile succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   fd = open("dirfile/xx", 0);
-   if(fd >= 0){
-     printf(1, "create dirfile/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   fd = open("dirfile/xx", O_CREATE);
-   if(fd >= 0){
-     printf(1, "create dirfile/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(mkdir("dirfile/xx") == 0){
-     printf(1, "mkdir dirfile/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dirfile/xx") == 0){
-     printf(1, "unlink dirfile/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(link("README", "dirfile/xx") == 0){
-     printf(1, "link to dirfile/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dirfile") != 0){
-     printf(1, "unlink dirfile failed!\n");
--    exit();
-+    exit(33);
-   }
- 
-   fd = open(".", O_RDWR);
-   if(fd >= 0){
-     printf(1, "open . for writing succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   fd = open(".", 0);
-   if(write(fd, "x", 1) > 0){
-     printf(1, "write . succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   close(fd);
- 
-@@ -1351,11 +1351,11 @@ iref(void)
-   for(i = 0; i < 50 + 1; i++){
-     if(mkdir("irefd") != 0){
-       printf(1, "mkdir irefd failed\n");
--      exit();
-+      exit(30);
-     }
-     if(chdir("irefd") != 0){
-       printf(1, "chdir irefd failed\n");
--      exit();
-+      exit(29);
-     }
- 
-     mkdir("");
-@@ -1388,24 +1388,24 @@ forktest(void)
-     if(pid < 0)
-       break;
-     if(pid == 0)
--      exit();
-+      exit(28);
-   }
- 
-   if(n == 1000){
-     printf(1, "fork claimed to work 1000 times!\n");
--    exit();
-+    exit(27);
-   }
- 
-   for(; n > 0; n--){
--    if(wait() < 0){
-+    if(wait(NULL) < 0){
-       printf(1, "wait stopped early\n");
--      exit();
-+      exit(26);
-     }
-   }
- 
--  if(wait() != -1){
-+  if(wait(NULL) != -1){
-     printf(1, "wait got too many\n");
--    exit();
-+    exit(25);
-   }
- 
-   printf(1, "fork test OK\n");
-@@ -1428,7 +1428,7 @@ sbrktest(void)
-     b = sbrk(1);
-     if(b != a){
-       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
--      exit();
-+      exit(24);
-     }
-     *b = 1;
-     a = b + 1;
-@@ -1436,17 +1436,17 @@ sbrktest(void)
-   pid = fork();
-   if(pid < 0){
-     printf(stdout, "sbrk test fork failed\n");
--    exit();
-+    exit(23);
-   }
-   c = sbrk(1);
-   c = sbrk(1);
-   if(c != a + 1){
-     printf(stdout, "sbrk test failed post-fork\n");
--    exit();
-+    exit(22);
-   }
-   if(pid == 0)
--    exit();
--  wait();
-+    exit(21);
-+  wait(NULL);
- 
-   // can one grow address space to something big?
- #define BIG (100*1024*1024)
-@@ -1455,7 +1455,7 @@ sbrktest(void)
-   p = sbrk(amt);
-   if (p != a) {
-     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
--    exit();
-+    exit(20);
-   }
-   lastaddr = (char*) (BIG-1);
-   *lastaddr = 99;
-@@ -1465,12 +1465,12 @@ sbrktest(void)
-   c = sbrk(-4096);
-   if(c == (char*)0xffffffff){
-     printf(stdout, "sbrk could not deallocate\n");
--    exit();
-+    exit(19);
-   }
-   c = sbrk(0);
-   if(c != a - 4096){
-     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
--    exit();
-+    exit(18);
-   }
- 
-   // can one re-allocate that page?
-@@ -1478,19 +1478,19 @@ sbrktest(void)
-   c = sbrk(4096);
-   if(c != a || sbrk(0) != a + 4096){
-     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
--    exit();
-+    exit(17);
-   }
-   if(*lastaddr == 99){
-     // should be zero
-     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
--    exit();
-+    exit(16);
-   }
- 
-   a = sbrk(0);
-   c = sbrk(-(sbrk(0) - oldbrk));
-   if(c != a){
-     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
--    exit();
-+    exit(15);
-   }
- 
-   // can we read the kernel's memory?
-@@ -1499,21 +1499,21 @@ sbrktest(void)
-     pid = fork();
-     if(pid < 0){
-       printf(stdout, "fork failed\n");
--      exit();
-+      exit(14);
-     }
-     if(pid == 0){
-       printf(stdout, "oops could read %x = %x\n", a, *a);
-       kill(ppid);
--      exit();
-+      exit(13);
-     }
--    wait();
-+    wait(NULL);
-   }
- 
-   // if we run the system out of memory, does it clean up the last
-   // failed allocation?
-   if(pipe(fds) != 0){
-     printf(1, "pipe() failed\n");
--    exit();
-+    exit(12);
-   }
-   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-     if((pids[i] = fork()) == 0){
-@@ -1533,11 +1533,11 @@ sbrktest(void)
-     if(pids[i] == -1)
-       continue;
-     kill(pids[i]);
--    wait();
-+    wait(NULL);
-   }
-   if(c == (char*)0xffffffff){
-     printf(stdout, "failed sbrk leaked memory\n");
--    exit();
-+    exit(10);
-   }
- 
-   if(sbrk(0) > oldbrk)
-@@ -1572,17 +1572,17 @@ validatetest(void)
-     if((pid = fork()) == 0){
-       // try to crash the kernel by passing in a badly placed integer
-       validateint((int*)p);
--      exit();
-+      exit(9);
-     }
-     sleep(0);
-     sleep(0);
-     kill(pid);
--    wait();
-+    wait(NULL);
- 
-     // try to crash the kernel by passing in a bad string pointer
-     if(link("nosuchfile", (char*)p) != -1){
-       printf(stdout, "link should not succeed\n");
--      exit();
-+      exit(8);
-     }
-   }
- 
-@@ -1600,7 +1600,7 @@ bsstest(void)
-   for(i = 0; i < sizeof(uninit); i++){
-     if(uninit[i] != '\0'){
-       printf(stdout, "bss test failed\n");
--      exit();
-+      exit(7);
-     }
-   }
-   printf(stdout, "bss test ok\n");
-@@ -1627,16 +1627,16 @@ bigargtest(void)
-     printf(stdout, "bigarg test ok\n");
-     fd = open("bigarg-ok", O_CREATE);
-     close(fd);
--    exit();
-+    exit(6);
-   } else if(pid < 0){
-     printf(stdout, "bigargtest: fork failed\n");
--    exit();
-+    exit(5);
-   }
--  wait();
-+  wait(NULL);
-   fd = open("bigarg-ok", 0);
-   if(fd < 0){
-     printf(stdout, "bigarg test failed!\n");
--    exit();
-+    exit(4);
-   }
-   close(fd);
-   unlink("bigarg-ok");
-@@ -1715,12 +1715,12 @@ uio()
-     port = RTC_DATA;
-     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
-     printf(1, "uio: uio succeeded; test FAILED\n");
--    exit();
-+    exit(3);
-   } else if(pid < 0){
-     printf (1, "fork failed\n");
--    exit();
-+    exit(2);
-   }
--  wait();
-+  wait(NULL);
-   printf(1, "uio test done\n");
- }
- 
-@@ -1730,7 +1730,7 @@ void argptest()
-   fd = open("init", O_RDONLY);
-   if (fd < 0) {
-     printf(2, "open failed\n");
--    exit();
-+    exit(1);
-   }
-   read(fd, sbrk(0) - 1, -1);
-   close(fd);
-@@ -1752,7 +1752,7 @@ main(int argc, char *argv[])
- 
-   if(open("usertests.ran", 0) >= 0){
-     printf(1, "already ran user tests -- rebuild fs.img\n");
--    exit();
-+    exit(1);
-   }
-   close(open("usertests.ran", O_CREATE));
- 
-@@ -1799,5 +1799,5 @@ main(int argc, char *argv[])
- 
-   exectest();
- 
--  exit();
-+  exit(0);
- }
++++ /dev/null
+@@ -1,1803 +0,0 @@
+-#include "param.h"
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-#include "fs.h"
+-#include "fcntl.h"
+-#include "syscall.h"
+-#include "traps.h"
+-#include "memlayout.h"
+-
+-char buf[8192];
+-char name[3];
+-char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };
+-int stdout = 1;
+-
+-// does chdir() call iput(p->cwd) in a transaction?
+-void
+-iputtest(void)
+-{
+-  printf(stdout, "iput test\n");
+-
+-  if(mkdir("iputdir") < 0){
+-    printf(stdout, "mkdir failed\n");
+-    exit(184);
+-  }
+-  if(chdir("iputdir") < 0){
+-    printf(stdout, "chdir iputdir failed\n");
+-    exit(183);
+-  }
+-  if(unlink("../iputdir") < 0){
+-    printf(stdout, "unlink ../iputdir failed\n");
+-    exit(182);
+-  }
+-  if(chdir("/") < 0){
+-    printf(stdout, "chdir / failed\n");
+-    exit(181);
+-  }
+-  printf(stdout, "iput test ok\n");
+-}
+-
+-// does exit() call iput(p->cwd) in a transaction?
+-void
+-exitiputtest(void)
+-{
+-  int pid;
+-
+-  printf(stdout, "exitiput test\n");
+-
+-  pid = fork();
+-  if(pid < 0){
+-    printf(stdout, "fork failed\n");
+-    exit(180);
+-  }
+-  if(pid == 0){
+-    if(mkdir("iputdir") < 0){
+-      printf(stdout, "mkdir failed\n");
+-      exit(179);
+-    }
+-    if(chdir("iputdir") < 0){
+-      printf(stdout, "child chdir failed\n");
+-      exit(178);
+-    }
+-    if(unlink("../iputdir") < 0){
+-      printf(stdout, "unlink ../iputdir failed\n");
+-      exit(177);
+-    }
+-    exit(176);
+-  }
+-  wait(NULL);
+-  printf(stdout, "exitiput test ok\n");
+-}
+-
+-// does the error path in open() for attempt to write a
+-// directory call iput() in a transaction?
+-// needs a hacked kernel that pauses just after the namei()
+-// call in sys_open():
+-//    if((ip = namei(path)) == 0)
+-//      return -1;
+-//    {
+-//      int i;
+-//      for(i = 0; i < 10000; i++)
+-//        yield();
+-//    }
+-void
+-openiputtest(void)
+-{
+-  int pid;
+-
+-  printf(stdout, "openiput test\n");
+-  if(mkdir("oidir") < 0){
+-    printf(stdout, "mkdir oidir failed\n");
+-    exit(175);
+-  }
+-  pid = fork();
+-  if(pid < 0){
+-    printf(stdout, "fork failed\n");
+-    exit(174);
+-  }
+-  if(pid == 0){
+-    int fd = open("oidir", O_RDWR);
+-    if(fd >= 0){
+-      printf(stdout, "open directory for write succeeded\n");
+-      exit(0);
+-    }
+-    exit(172);
+-  }
+-  sleep(1);
+-  if(unlink("oidir") != 0){
+-    printf(stdout, "unlink failed\n");
+-    exit(171);
+-  }
+-  wait(NULL);
+-  printf(stdout, "openiput test ok\n");
+-}
+-
+-// simple file system tests
+-
+-void
+-opentest(void)
+-{
+-  int fd;
+-
+-  printf(stdout, "open test\n");
+-  fd = open("echo", 0);
+-  if(fd < 0){
+-    printf(stdout, "open echo failed!\n");
+-    exit(170);
+-  }
+-  close(fd);
+-  fd = open("doesnotexist", 0);
+-  if(fd >= 0){
+-    printf(stdout, "open doesnotexist succeeded!\n");
+-    exit(0);
+-  }
+-  printf(stdout, "open test ok\n");
+-}
+-
+-void
+-writetest(void)
+-{
+-  int fd;
+-  int i;
+-
+-  printf(stdout, "small file test\n");
+-  fd = open("small", O_CREATE|O_RDWR);
+-  if(fd >= 0){
+-    printf(stdout, "creat small succeeded; ok\n");
+-  } else {
+-    printf(stdout, "error: creat small failed!\n");
+-    exit(168);
+-  }
+-  for(i = 0; i < 100; i++){
+-    if(write(fd, "aaaaaaaaaa", 10) != 10){
+-      printf(stdout, "error: write aa %d new file failed\n", i);
+-      exit(167);
+-    }
+-    if(write(fd, "bbbbbbbbbb", 10) != 10){
+-      printf(stdout, "error: write bb %d new file failed\n", i);
+-      exit(166);
+-    }
+-  }
+-  printf(stdout, "writes ok\n");
+-  close(fd);
+-  fd = open("small", O_RDONLY);
+-  if(fd >= 0){
+-    printf(stdout, "open small succeeded ok\n");
+-  } else {
+-    printf(stdout, "error: open small failed!\n");
+-    exit(165);
+-  }
+-  i = read(fd, buf, 2000);
+-  if(i == 2000){
+-    printf(stdout, "read succeeded ok\n");
+-  } else {
+-    printf(stdout, "read failed\n");
+-    exit(164);
+-  }
+-  close(fd);
+-
+-  if(unlink("small") < 0){
+-    printf(stdout, "unlink small failed\n");
+-    exit(163);
+-  }
+-  printf(stdout, "small file test ok\n");
+-}
+-
+-void
+-writetest1(void)
+-{
+-  int i, fd, n;
+-
+-  printf(stdout, "big files test\n");
+-
+-  fd = open("big", O_CREATE|O_RDWR);
+-  if(fd < 0){
+-    printf(stdout, "error: creat big failed!\n");
+-    exit(162);
+-  }
+-
+-  for(i = 0; i < MAXFILE; i++){
+-    ((int*)buf)[0] = i;
+-    if(write(fd, buf, 512) != 512){
+-      printf(stdout, "error: write big file failed\n", i);
+-      exit(161);
+-    }
+-  }
+-
+-  close(fd);
+-
+-  fd = open("big", O_RDONLY);
+-  if(fd < 0){
+-    printf(stdout, "error: open big failed!\n");
+-    exit(160);
+-  }
+-
+-  n = 0;
+-  for(;;){
+-    i = read(fd, buf, 512);
+-    if(i == 0){
+-      if(n == MAXFILE - 1){
+-        printf(stdout, "read only %d blocks from big", n);
+-        exit(159);
+-      }
+-      break;
+-    } else if(i != 512){
+-      printf(stdout, "read failed %d\n", i);
+-      exit(158);
+-    }
+-    if(((int*)buf)[0] != n){
+-      printf(stdout, "read content of block %d is %d\n",
+-             n, ((int*)buf)[0]);
+-      exit(157);
+-    }
+-    n++;
+-  }
+-  close(fd);
+-  if(unlink("big") < 0){
+-    printf(stdout, "unlink big failed\n");
+-    exit(156);
+-  }
+-  printf(stdout, "big files ok\n");
+-}
+-
+-void
+-createtest(void)
+-{
+-  int i, fd;
+-
+-  printf(stdout, "many creates, followed by unlink test\n");
+-
+-  name[0] = 'a';
+-  name[2] = '\0';
+-  for(i = 0; i < 52; i++){
+-    name[1] = '0' + i;
+-    fd = open(name, O_CREATE|O_RDWR);
+-    close(fd);
+-  }
+-  name[0] = 'a';
+-  name[2] = '\0';
+-  for(i = 0; i < 52; i++){
+-    name[1] = '0' + i;
+-    unlink(name);
+-  }
+-  printf(stdout, "many creates, followed by unlink; ok\n");
+-}
+-
+-void dirtest(void)
+-{
+-  printf(stdout, "mkdir test\n");
+-
+-  if(mkdir("dir0") < 0){
+-    printf(stdout, "mkdir failed\n");
+-    exit(155);
+-  }
+-
+-  if(chdir("dir0") < 0){
+-    printf(stdout, "chdir dir0 failed\n");
+-    exit(154);
+-  }
+-
+-  if(chdir("..") < 0){
+-    printf(stdout, "chdir .. failed\n");
+-    exit(153);
+-  }
+-
+-  if(unlink("dir0") < 0){
+-    printf(stdout, "unlink dir0 failed\n");
+-    exit(152);
+-  }
+-  printf(stdout, "mkdir test ok\n");
+-}
+-
+-void
+-exectest(void)
+-{
+-  printf(stdout, "exec test\n");
+-  if(exec("echo", echoargv) < 0){
+-    printf(stdout, "exec echo failed\n");
+-    exit(151);
+-  }
+-}
+-
+-// simple fork and pipe read/write
+-
+-void
+-pipe1(void)
+-{
+-  int fds[2], pid;
+-  int seq, i, n, cc, total;
+-
+-  if(pipe(fds) != 0){
+-    printf(1, "pipe() failed\n");
+-    exit(150);
+-  }
+-  pid = fork();
+-  seq = 0;
+-  if(pid == 0){
+-    close(fds[0]);
+-    for(n = 0; n < 5; n++){
+-      for(i = 0; i < 1033; i++)
+-        buf[i] = seq++;
+-      if(write(fds[1], buf, 1033) != 1033){
+-        printf(1, "pipe1 oops 1\n");
+-        exit(149);
+-      }
+-    }
+-    exit(148);
+-  } else if(pid > 0){
+-    close(fds[1]);
+-    total = 0;
+-    cc = 1;
+-    while((n = read(fds[0], buf, cc)) > 0){
+-      for(i = 0; i < n; i++){
+-        if((buf[i] & 0xff) != (seq++ & 0xff)){
+-          printf(1, "pipe1 oops 2\n");
+-          return;
+-        }
+-      }
+-      total += n;
+-      cc = cc * 2;
+-      if(cc > sizeof(buf))
+-        cc = sizeof(buf);
+-    }
+-    if(total != 5 * 1033){
+-      printf(1, "pipe1 oops 3 total %d\n", total);
+-      exit(147);
+-    }
+-    close(fds[0]);
+-    wait(NULL);
+-  } else {
+-    printf(1, "fork() failed\n");
+-    exit(146);
+-  }
+-  printf(1, "pipe1 ok\n");
+-}
+-
+-// meant to be run w/ at most two CPUs
+-void
+-preempt(void)
+-{
+-  int pid1, pid2, pid3;
+-  int pfds[2];
+-
+-  printf(1, "preempt: ");
+-  pid1 = fork();
+-  if(pid1 == 0)
+-    for(;;)
+-      ;
+-
+-  pid2 = fork();
+-  if(pid2 == 0)
+-    for(;;)
+-      ;
+-
+-  pipe(pfds);
+-  pid3 = fork();
+-  if(pid3 == 0){
+-    close(pfds[0]);
+-    if(write(pfds[1], "x", 1) != 1)
+-      printf(1, "preempt write error");
+-    close(pfds[1]);
+-    for(;;)
+-      ;
+-  }
+-
+-  close(pfds[1]);
+-  if(read(pfds[0], buf, sizeof(buf)) != 1){
+-    printf(1, "preempt read error");
+-    return;
+-  }
+-  close(pfds[0]);
+-  printf(1, "kill... ");
+-  kill(pid1);
+-  kill(pid2);
+-  kill(pid3);
+-  printf(1, "wait... ");
+-  wait(NULL);
+-  wait(NULL);
+-  wait(NULL);
+-  printf(1, "preempt ok\n");
+-}
+-
+-// try to find any races between exit and wait
+-void
+-exitwait(void)
+-{
+-  int i, pid;
+-
+-  for(i = 0; i < 100; i++){
+-    pid = fork();
+-    if(pid < 0){
+-      printf(1, "fork failed\n");
+-      return;
+-    }
+-    if(pid){
+-      if(wait(NULL) != pid){
+-        printf(1, "wait wrong pid\n");
+-        return;
+-      }
+-    } else {
+-      exit(145);
+-    }
+-  }
+-  printf(1, "exitwait ok\n");
+-}
+-
+-void
+-mem(void)
+-{
+-  void *m1, *m2;
+-  int pid, ppid;
+-
+-  printf(1, "mem test\n");
+-  ppid = getpid();
+-  if((pid = fork()) == 0){
+-    m1 = 0;
+-    while((m2 = malloc(10001)) != 0){
+-      *(char**)m2 = m1;
+-      m1 = m2;
+-    }
+-    while(m1){
+-      m2 = *(char**)m1;
+-      free(m1);
+-      m1 = m2;
+-    }
+-    m1 = malloc(1024*20);
+-    if(m1 == 0){
+-      printf(1, "couldn't allocate mem?!!\n");
+-      kill(ppid);
+-      exit(144);
+-    }
+-    free(m1);
+-    printf(1, "mem ok\n");
+-    exit(0);
+-  } else {
+-    wait(NULL);
+-  }
+-}
+-
+-// More file system tests
+-
+-// two processes write to the same file descriptor
+-// is the offset shared? does inode locking work?
+-void
+-sharedfd(void)
+-{
+-  int fd, pid, i, n, nc, np;
+-  char buf[10];
+-
+-  printf(1, "sharedfd test\n");
+-
+-  unlink("sharedfd");
+-  fd = open("sharedfd", O_CREATE|O_RDWR);
+-  if(fd < 0){
+-    printf(1, "fstests: cannot open sharedfd for writing");
+-    return;
+-  }
+-  pid = fork();
+-  memset(buf, pid==0?'c':'p', sizeof(buf));
+-  for(i = 0; i < 1000; i++){
+-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+-      printf(1, "fstests: write sharedfd failed\n");
+-      break;
+-    }
+-  }
+-  if(pid == 0)
+-    exit(142);
+-  else
+-    wait(NULL);
+-  close(fd);
+-  fd = open("sharedfd", 0);
+-  if(fd < 0){
+-    printf(1, "fstests: cannot open sharedfd for reading\n");
+-    return;
+-  }
+-  nc = np = 0;
+-  while((n = read(fd, buf, sizeof(buf))) > 0){
+-    for(i = 0; i < sizeof(buf); i++){
+-      if(buf[i] == 'c')
+-        nc++;
+-      if(buf[i] == 'p')
+-        np++;
+-    }
+-  }
+-  close(fd);
+-  unlink("sharedfd");
+-  if(nc == 10000 && np == 10000){
+-    printf(1, "sharedfd ok\n");
+-  } else {
+-    printf(1, "sharedfd oops %d %d\n", nc, np);
+-    exit(141);
+-  }
+-}
+-
+-// four processes write different files at the same
+-// time, to test block allocation.
+-void
+-fourfiles(void)
+-{
+-  int fd, pid, i, j, n, total, pi;
+-  char *names[] = { "f0", "f1", "f2", "f3" };
+-  char *fname;
+-
+-  printf(1, "fourfiles test\n");
+-
+-  for(pi = 0; pi < 4; pi++){
+-    fname = names[pi];
+-    unlink(fname);
+-
+-    pid = fork();
+-    if(pid < 0){
+-      printf(1, "fork failed\n");
+-      exit(140);
+-    }
+-
+-    if(pid == 0){
+-      fd = open(fname, O_CREATE | O_RDWR);
+-      if(fd < 0){
+-        printf(1, "create failed\n");
+-        exit(139);
+-      }
+-
+-      memset(buf, '0'+pi, 512);
+-      for(i = 0; i < 12; i++){
+-        if((n = write(fd, buf, 500)) != 500){
+-          printf(1, "write failed %d\n", n);
+-          exit(138);
+-        }
+-      }
+-      exit(137);
+-    }
+-  }
+-
+-  for(pi = 0; pi < 4; pi++){
+-    wait(NULL);
+-  }
+-
+-  for(i = 0; i < 2; i++){
+-    fname = names[i];
+-    fd = open(fname, 0);
+-    total = 0;
+-    while((n = read(fd, buf, sizeof(buf))) > 0){
+-      for(j = 0; j < n; j++){
+-        if(buf[j] != '0'+i){
+-          printf(1, "wrong char\n");
+-          exit(136);
+-        }
+-      }
+-      total += n;
+-    }
+-    close(fd);
+-    if(total != 12*500){
+-      printf(1, "wrong length %d\n", total);
+-      exit(135);
+-    }
+-    unlink(fname);
+-  }
+-
+-  printf(1, "fourfiles ok\n");
+-}
+-
+-// four processes create and delete different files in same directory
+-void
+-createdelete(void)
+-{
+-  enum { N = 20 };
+-  int pid, i, fd, pi;
+-  char name[32];
+-
+-  printf(1, "createdelete test\n");
+-
+-  for(pi = 0; pi < 4; pi++){
+-    pid = fork();
+-    if(pid < 0){
+-      printf(1, "fork failed\n");
+-      exit(134);
+-    }
+-
+-    if(pid == 0){
+-      name[0] = 'p' + pi;
+-      name[2] = '\0';
+-      for(i = 0; i < N; i++){
+-        name[1] = '0' + i;
+-        fd = open(name, O_CREATE | O_RDWR);
+-        if(fd < 0){
+-          printf(1, "create failed\n");
+-          exit(133);
+-        }
+-        close(fd);
+-        if(i > 0 && (i % 2 ) == 0){
+-          name[1] = '0' + (i / 2);
+-          if(unlink(name) < 0){
+-            printf(1, "unlink failed\n");
+-            exit(132);
+-          }
+-        }
+-      }
+-      exit(131);
+-    }
+-  }
+-
+-  for(pi = 0; pi < 4; pi++){
+-    wait(NULL);
+-  }
+-
+-  name[0] = name[1] = name[2] = 0;
+-  for(i = 0; i < N; i++){
+-    for(pi = 0; pi < 4; pi++){
+-      name[0] = 'p' + pi;
+-      name[1] = '0' + i;
+-      fd = open(name, 0);
+-      if((i == 0 || i >= N/2) && fd < 0){
+-        printf(1, "oops createdelete %s didn't exist\n", name);
+-        exit(130);
+-      } else if((i >= 1 && i < N/2) && fd >= 0){
+-        printf(1, "oops createdelete %s did exist\n", name);
+-        exit(129);
+-      }
+-      if(fd >= 0)
+-        close(fd);
+-    }
+-  }
+-
+-  for(i = 0; i < N; i++){
+-    for(pi = 0; pi < 4; pi++){
+-      name[0] = 'p' + i;
+-      name[1] = '0' + i;
+-      unlink(name);
+-    }
+-  }
+-
+-  printf(1, "createdelete ok\n");
+-}
+-
+-// can I unlink a file and still read it?
+-void
+-unlinkread(void)
+-{
+-  int fd, fd1;
+-
+-  printf(1, "unlinkread test\n");
+-  fd = open("unlinkread", O_CREATE | O_RDWR);
+-  if(fd < 0){
+-    printf(1, "create unlinkread failed\n");
+-    exit(128);
+-  }
+-  write(fd, "hello", 5);
+-  close(fd);
+-
+-  fd = open("unlinkread", O_RDWR);
+-  if(fd < 0){
+-    printf(1, "open unlinkread failed\n");
+-    exit(127);
+-  }
+-  if(unlink("unlinkread") != 0){
+-    printf(1, "unlink unlinkread failed\n");
+-    exit(126);
+-  }
+-
+-  fd1 = open("unlinkread", O_CREATE | O_RDWR);
+-  write(fd1, "yyy", 3);
+-  close(fd1);
+-
+-  if(read(fd, buf, sizeof(buf)) != 5){
+-    printf(1, "unlinkread read failed");
+-    exit(125);
+-  }
+-  if(buf[0] != 'h'){
+-    printf(1, "unlinkread wrong data\n");
+-    exit(124);
+-  }
+-  if(write(fd, buf, 10) != 10){
+-    printf(1, "unlinkread write failed\n");
+-    exit(123);
+-  }
+-  close(fd);
+-  unlink("unlinkread");
+-  printf(1, "unlinkread ok\n");
+-}
+-
+-void
+-linktest(void)
+-{
+-  int fd;
+-
+-  printf(1, "linktest\n");
+-
+-  unlink("lf1");
+-  unlink("lf2");
+-
+-  fd = open("lf1", O_CREATE|O_RDWR);
+-  if(fd < 0){
+-    printf(1, "create lf1 failed\n");
+-    exit(122);
+-  }
+-  if(write(fd, "hello", 5) != 5){
+-    printf(1, "write lf1 failed\n");
+-    exit(121);
+-  }
+-  close(fd);
+-
+-  if(link("lf1", "lf2") < 0){
+-    printf(1, "link lf1 lf2 failed\n");
+-    exit(120);
+-  }
+-  unlink("lf1");
+-
+-  if(open("lf1", 0) >= 0){
+-    printf(1, "unlinked lf1 but it is still there!\n");
+-    exit(119);
+-  }
+-
+-  fd = open("lf2", 0);
+-  if(fd < 0){
+-    printf(1, "open lf2 failed\n");
+-    exit(118);
+-  }
+-  if(read(fd, buf, sizeof(buf)) != 5){
+-    printf(1, "read lf2 failed\n");
+-    exit(117);
+-  }
+-  close(fd);
+-
+-  if(link("lf2", "lf2") >= 0){
+-    printf(1, "link lf2 lf2 succeeded! oops\n");
+-    exit(116);
+-  }
+-
+-  unlink("lf2");
+-  if(link("lf2", "lf1") >= 0){
+-    printf(1, "link non-existant succeeded! oops\n");
+-    exit(115);
+-  }
+-
+-  if(link(".", "lf1") >= 0){
+-    printf(1, "link . lf1 succeeded! oops\n");
+-    exit(114);
+-  }
+-
+-  printf(1, "linktest ok\n");
+-}
+-
+-// test concurrent create/link/unlink of the same file
+-void
+-concreate(void)
+-{
+-  char file[3];
+-  int i, pid, n, fd;
+-  char fa[40];
+-  struct {
+-    ushort inum;
+-    char name[14];
+-  } de;
+-
+-  printf(1, "concreate test\n");
+-  file[0] = 'C';
+-  file[2] = '\0';
+-  for(i = 0; i < 40; i++){
+-    file[1] = '0' + i;
+-    unlink(file);
+-    pid = fork();
+-    if(pid && (i % 3) == 1){
+-      link("C0", file);
+-    } else if(pid == 0 && (i % 5) == 1){
+-      link("C0", file);
+-    } else {
+-      fd = open(file, O_CREATE | O_RDWR);
+-      if(fd < 0){
+-        printf(1, "concreate create %s failed\n", file);
+-        exit(113);
+-      }
+-      close(fd);
+-    }
+-    if(pid == 0)
+-      exit(112);
+-    else
+-      wait(NULL);
+-  }
+-
+-  memset(fa, 0, sizeof(fa));
+-  fd = open(".", 0);
+-  n = 0;
+-  while(read(fd, &de, sizeof(de)) > 0){
+-    if(de.inum == 0)
+-      continue;
+-    if(de.name[0] == 'C' && de.name[2] == '\0'){
+-      i = de.name[1] - '0';
+-      if(i < 0 || i >= sizeof(fa)){
+-        printf(1, "concreate weird file %s\n", de.name);
+-        exit(111);
+-      }
+-      if(fa[i]){
+-        printf(1, "concreate duplicate file %s\n", de.name);
+-        exit(110);
+-      }
+-      fa[i] = 1;
+-      n++;
+-    }
+-  }
+-  close(fd);
+-
+-  if(n != 40){
+-    printf(1, "concreate not enough files in directory listing\n");
+-    exit(109);
+-  }
+-
+-  for(i = 0; i < 40; i++){
+-    file[1] = '0' + i;
+-    pid = fork();
+-    if(pid < 0){
+-      printf(1, "fork failed\n");
+-      exit(108);
+-    }
+-    if(((i % 3) == 0 && pid == 0) ||
+-       ((i % 3) == 1 && pid != 0)){
+-      close(open(file, 0));
+-      close(open(file, 0));
+-      close(open(file, 0));
+-      close(open(file, 0));
+-    } else {
+-      unlink(file);
+-      unlink(file);
+-      unlink(file);
+-      unlink(file);
+-    }
+-    if(pid == 0)
+-      exit(107);
+-    else
+-      wait(NULL);
+-  }
+-
+-  printf(1, "concreate ok\n");
+-}
+-
+-// another concurrent link/unlink/create test,
+-// to look for deadlocks.
+-void
+-linkunlink()
+-{
+-  int pid, i;
+-
+-  printf(1, "linkunlink test\n");
+-
+-  unlink("x");
+-  pid = fork();
+-  if(pid < 0){
+-    printf(1, "fork failed\n");
+-    exit(106);
+-  }
+-
+-  unsigned int x = (pid ? 1 : 97);
+-  for(i = 0; i < 100; i++){
+-    x = x * 1103515245 + 12345;
+-    if((x % 3) == 0){
+-      close(open("x", O_RDWR | O_CREATE));
+-    } else if((x % 3) == 1){
+-      link("cat", "x");
+-    } else {
+-      unlink("x");
+-    }
+-  }
+-
+-  if(pid)
+-    wait(NULL);
+-  else
+-    exit(105);
+-
+-  printf(1, "linkunlink ok\n");
+-}
+-
+-// directory that uses indirect blocks
+-void
+-bigdir(void)
+-{
+-  int i, fd;
+-  char name[10];
+-
+-  printf(1, "bigdir test\n");
+-  unlink("bd");
+-
+-  fd = open("bd", O_CREATE);
+-  if(fd < 0){
+-    printf(1, "bigdir create failed\n");
+-    exit(104);
+-  }
+-  close(fd);
+-
+-  for(i = 0; i < 500; i++){
+-    name[0] = 'x';
+-    name[1] = '0' + (i / 64);
+-    name[2] = '0' + (i % 64);
+-    name[3] = '\0';
+-    if(link("bd", name) != 0){
+-      printf(1, "bigdir link failed\n");
+-      exit(103);
+-    }
+-  }
+-
+-  unlink("bd");
+-  for(i = 0; i < 500; i++){
+-    name[0] = 'x';
+-    name[1] = '0' + (i / 64);
+-    name[2] = '0' + (i % 64);
+-    name[3] = '\0';
+-    if(unlink(name) != 0){
+-      printf(1, "bigdir unlink failed");
+-      exit(102);
+-    }
+-  }
+-
+-  printf(1, "bigdir ok\n");
+-}
+-
+-void
+-subdir(void)
+-{
+-  int fd, cc;
+-
+-  printf(1, "subdir test\n");
+-
+-  unlink("ff");
+-  if(mkdir("dd") != 0){
+-    printf(1, "subdir mkdir dd failed\n");
+-    exit(101);
+-  }
+-
+-  fd = open("dd/ff", O_CREATE | O_RDWR);
+-  if(fd < 0){
+-    printf(1, "create dd/ff failed\n");
+-    exit(100);
+-  }
+-  write(fd, "ff", 2);
+-  close(fd);
+-
+-  if(unlink("dd") >= 0){
+-    printf(1, "unlink dd (non-empty dir) succeeded!\n");
+-    exit(99);
+-  }
+-
+-  if(mkdir("/dd/dd") != 0){
+-    printf(1, "subdir mkdir dd/dd failed\n");
+-    exit(98);
+-  }
+-
+-  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+-  if(fd < 0){
+-    printf(1, "create dd/dd/ff failed\n");
+-    exit(97);
+-  }
+-  write(fd, "FF", 2);
+-  close(fd);
+-
+-  fd = open("dd/dd/../ff", 0);
+-  if(fd < 0){
+-    printf(1, "open dd/dd/../ff failed\n");
+-    exit(96);
+-  }
+-  cc = read(fd, buf, sizeof(buf));
+-  if(cc != 2 || buf[0] != 'f'){
+-    printf(1, "dd/dd/../ff wrong content\n");
+-    exit(95);
+-  }
+-  close(fd);
+-
+-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+-    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+-    exit(94);
+-  }
+-
+-  if(unlink("dd/dd/ff") != 0){
+-    printf(1, "unlink dd/dd/ff failed\n");
+-    exit(93);
+-  }
+-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+-    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+-    exit(92);
+-  }
+-
+-  if(chdir("dd") != 0){
+-    printf(1, "chdir dd failed\n");
+-    exit(91);
+-  }
+-  if(chdir("dd/../../dd") != 0){
+-    printf(1, "chdir dd/../../dd failed\n");
+-    exit(90);
+-  }
+-  if(chdir("dd/../../../dd") != 0){
+-    printf(1, "chdir dd/../../dd failed\n");
+-    exit(89);
+-  }
+-  if(chdir("./..") != 0){
+-    printf(1, "chdir ./.. failed\n");
+-    exit(88);
+-  }
+-
+-  fd = open("dd/dd/ffff", 0);
+-  if(fd < 0){
+-    printf(1, "open dd/dd/ffff failed\n");
+-    exit(87);
+-  }
+-  if(read(fd, buf, sizeof(buf)) != 2){
+-    printf(1, "read dd/dd/ffff wrong len\n");
+-    exit(86);
+-  }
+-  close(fd);
+-
+-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+-    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+-    exit(0);
+-  }
+-
+-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+-    printf(1, "create dd/ff/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+-    printf(1, "create dd/xx/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(open("dd", O_CREATE) >= 0){
+-    printf(1, "create dd succeeded!\n");
+-    exit(0);
+-  }
+-  if(open("dd", O_RDWR) >= 0){
+-    printf(1, "open dd rdwr succeeded!\n");
+-    exit(0);
+-  }
+-  if(open("dd", O_WRONLY) >= 0){
+-    printf(1, "open dd wronly succeeded!\n");
+-    exit(0);
+-  }
+-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+-    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+-    exit(0);
+-  }
+-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+-    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+-    exit(0);
+-  }
+-  if(link("dd/ff", "dd/dd/ffff") == 0){
+-    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+-    exit(0);
+-  }
+-  if(mkdir("dd/ff/ff") == 0){
+-    printf(1, "mkdir dd/ff/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(mkdir("dd/xx/ff") == 0){
+-    printf(1, "mkdir dd/xx/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(mkdir("dd/dd/ffff") == 0){
+-    printf(1, "mkdir dd/dd/ffff succeeded!\n");
+-    exit(0);
+-  }
+-  if(unlink("dd/xx/ff") == 0){
+-    printf(1, "unlink dd/xx/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(unlink("dd/ff/ff") == 0){
+-    printf(1, "unlink dd/ff/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(chdir("dd/ff") == 0){
+-    printf(1, "chdir dd/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(chdir("dd/xx") == 0){
+-    printf(1, "chdir dd/xx succeeded!\n");
+-    exit(0);
+-  }
+-
+-  if(unlink("dd/dd/ffff") != 0){
+-    printf(1, "unlink dd/dd/ff failed\n");
+-    exit(68);
+-  }
+-  if(unlink("dd/ff") != 0){
+-    printf(1, "unlink dd/ff failed\n");
+-    exit(67);
+-  }
+-  if(unlink("dd") == 0){
+-    printf(1, "unlink non-empty dd succeeded!\n");
+-    exit(0);
+-  }
+-  if(unlink("dd/dd") < 0){
+-    printf(1, "unlink dd/dd failed\n");
+-    exit(65);
+-  }
+-  if(unlink("dd") < 0){
+-    printf(1, "unlink dd failed\n");
+-    exit(64);
+-  }
+-
+-  printf(1, "subdir ok\n");
+-}
+-
+-// test writes that are larger than the log.
+-void
+-bigwrite(void)
+-{
+-  int fd, sz;
+-
+-  printf(1, "bigwrite test\n");
+-
+-  unlink("bigwrite");
+-  for(sz = 499; sz < 12*512; sz += 471){
+-    fd = open("bigwrite", O_CREATE | O_RDWR);
+-    if(fd < 0){
+-      printf(1, "cannot create bigwrite\n");
+-      exit(63);
+-    }
+-    int i;
+-    for(i = 0; i < 2; i++){
+-      int cc = write(fd, buf, sz);
+-      if(cc != sz){
+-        printf(1, "write(%d) ret %d\n", sz, cc);
+-        exit(62);
+-      }
+-    }
+-    close(fd);
+-    unlink("bigwrite");
+-  }
+-
+-  printf(1, "bigwrite ok\n");
+-}
+-
+-void
+-bigfile(void)
+-{
+-  int fd, i, total, cc;
+-
+-  printf(1, "bigfile test\n");
+-
+-  unlink("bigfile");
+-  fd = open("bigfile", O_CREATE | O_RDWR);
+-  if(fd < 0){
+-    printf(1, "cannot create bigfile");
+-    exit(61);
+-  }
+-  for(i = 0; i < 20; i++){
+-    memset(buf, i, 600);
+-    if(write(fd, buf, 600) != 600){
+-      printf(1, "write bigfile failed\n");
+-      exit(60);
+-    }
+-  }
+-  close(fd);
+-
+-  fd = open("bigfile", 0);
+-  if(fd < 0){
+-    printf(1, "cannot open bigfile\n");
+-    exit(59);
+-  }
+-  total = 0;
+-  for(i = 0; ; i++){
+-    cc = read(fd, buf, 300);
+-    if(cc < 0){
+-      printf(1, "read bigfile failed\n");
+-      exit(58);
+-    }
+-    if(cc == 0)
+-      break;
+-    if(cc != 300){
+-      printf(1, "short read bigfile\n");
+-      exit(57);
+-    }
+-    if(buf[0] != i/2 || buf[299] != i/2){
+-      printf(1, "read bigfile wrong data\n");
+-      exit(56);
+-    }
+-    total += cc;
+-  }
+-  close(fd);
+-  if(total != 20*600){
+-    printf(1, "read bigfile wrong total\n");
+-    exit(55);
+-  }
+-  unlink("bigfile");
+-
+-  printf(1, "bigfile test ok\n");
+-}
+-
+-void
+-fourteen(void)
+-{
+-  int fd;
+-
+-  // DIRSIZ is 14.
+-  printf(1, "fourteen test\n");
+-
+-  if(mkdir("12345678901234") != 0){
+-    printf(1, "mkdir 12345678901234 failed\n");
+-    exit(54);
+-  }
+-  if(mkdir("12345678901234/123456789012345") != 0){
+-    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+-    exit(53);
+-  }
+-  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+-  if(fd < 0){
+-    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+-    exit(52);
+-  }
+-  close(fd);
+-  fd = open("12345678901234/12345678901234/12345678901234", 0);
+-  if(fd < 0){
+-    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+-    exit(51);
+-  }
+-  close(fd);
+-
+-  if(mkdir("12345678901234/12345678901234") == 0){
+-    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+-    exit(0);
+-  }
+-  if(mkdir("123456789012345/12345678901234") == 0){
+-    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+-    exit(0);
+-  }
+-
+-  printf(1, "fourteen ok\n");
+-}
+-
+-void
+-rmdot(void)
+-{
+-  printf(1, "rmdot test\n");
+-  if(mkdir("dots") != 0){
+-    printf(1, "mkdir dots failed\n");
+-    exit(48);
+-  }
+-  if(chdir("dots") != 0){
+-    printf(1, "chdir dots failed\n");
+-    exit(47);
+-  }
+-  if(unlink(".") == 0){
+-    printf(1, "rm . worked!\n");
+-    exit(0);
+-  }
+-  if(unlink("..") == 0){
+-    printf(1, "rm .. worked!\n");
+-    exit(0);
+-  }
+-  if(chdir("/") != 0){
+-    printf(1, "chdir / failed\n");
+-    exit(44);
+-  }
+-  if(unlink("dots/.") == 0){
+-    printf(1, "unlink dots/. worked!\n");
+-    exit(0);
+-  }
+-  if(unlink("dots/..") == 0){
+-    printf(1, "unlink dots/.. worked!\n");
+-    exit(0);
+-  }
+-  if(unlink("dots") != 0){
+-    printf(1, "unlink dots failed!\n");
+-    exit(41);
+-  }
+-  printf(1, "rmdot ok\n");
+-}
+-
+-void
+-dirfile(void)
+-{
+-  int fd;
+-
+-  printf(1, "dir vs file\n");
+-
+-  fd = open("dirfile", O_CREATE);
+-  if(fd < 0){
+-    printf(1, "create dirfile failed\n");
+-    exit(40);
+-  }
+-  close(fd);
+-  if(chdir("dirfile") == 0){
+-    printf(1, "chdir dirfile succeeded!\n");
+-    exit(0);
+-  }
+-  fd = open("dirfile/xx", 0);
+-  if(fd >= 0){
+-    printf(1, "create dirfile/xx succeeded!\n");
+-    exit(0);
+-  }
+-  fd = open("dirfile/xx", O_CREATE);
+-  if(fd >= 0){
+-    printf(1, "create dirfile/xx succeeded!\n");
+-    exit(0);
+-  }
+-  if(mkdir("dirfile/xx") == 0){
+-    printf(1, "mkdir dirfile/xx succeeded!\n");
+-    exit(0);
+-  }
+-  if(unlink("dirfile/xx") == 0){
+-    printf(1, "unlink dirfile/xx succeeded!\n");
+-    exit(0);
+-  }
+-  if(link("README", "dirfile/xx") == 0){
+-    printf(1, "link to dirfile/xx succeeded!\n");
+-    exit(0);
+-  }
+-  if(unlink("dirfile") != 0){
+-    printf(1, "unlink dirfile failed!\n");
+-    exit(33);
+-  }
+-
+-  fd = open(".", O_RDWR);
+-  if(fd >= 0){
+-    printf(1, "open . for writing succeeded!\n");
+-    exit(0);
+-  }
+-  fd = open(".", 0);
+-  if(write(fd, "x", 1) > 0){
+-    printf(1, "write . succeeded!\n");
+-    exit(0);
+-  }
+-  close(fd);
+-
+-  printf(1, "dir vs file OK\n");
+-}
+-
+-// test that iput() is called at the end of _namei()
+-void
+-iref(void)
+-{
+-  int i, fd;
+-
+-  printf(1, "empty file name\n");
+-
+-  // the 50 is NINODE
+-  for(i = 0; i < 50 + 1; i++){
+-    if(mkdir("irefd") != 0){
+-      printf(1, "mkdir irefd failed\n");
+-      exit(30);
+-    }
+-    if(chdir("irefd") != 0){
+-      printf(1, "chdir irefd failed\n");
+-      exit(29);
+-    }
+-
+-    mkdir("");
+-    link("README", "");
+-    fd = open("", O_CREATE);
+-    if(fd >= 0)
+-      close(fd);
+-    fd = open("xx", O_CREATE);
+-    if(fd >= 0)
+-      close(fd);
+-    unlink("xx");
+-  }
+-
+-  chdir("/");
+-  printf(1, "empty file name OK\n");
+-}
+-
+-// test that fork fails gracefully
+-// the forktest binary also does this, but it runs out of proc entries first.
+-// inside the bigger usertests binary, we run out of memory first.
+-void
+-forktest(void)
+-{
+-  int n, pid;
+-
+-  printf(1, "fork test\n");
+-
+-  for(n=0; n<1000; n++){
+-    pid = fork();
+-    if(pid < 0)
+-      break;
+-    if(pid == 0)
+-      exit(28);
+-  }
+-
+-  if(n == 1000){
+-    printf(1, "fork claimed to work 1000 times!\n");
+-    exit(27);
+-  }
+-
+-  for(; n > 0; n--){
+-    if(wait(NULL) < 0){
+-      printf(1, "wait stopped early\n");
+-      exit(26);
+-    }
+-  }
+-
+-  if(wait(NULL) != -1){
+-    printf(1, "wait got too many\n");
+-    exit(25);
+-  }
+-
+-  printf(1, "fork test OK\n");
+-}
+-
+-void
+-sbrktest(void)
+-{
+-  int fds[2], pid, pids[10], ppid;
+-  char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
+-  uint amt;
+-
+-  printf(stdout, "sbrk test\n");
+-  oldbrk = sbrk(0);
+-
+-  // can one sbrk() less than a page?
+-  a = sbrk(0);
+-  int i;
+-  for(i = 0; i < 5000; i++){
+-    b = sbrk(1);
+-    if(b != a){
+-      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+-      exit(24);
+-    }
+-    *b = 1;
+-    a = b + 1;
+-  }
+-  pid = fork();
+-  if(pid < 0){
+-    printf(stdout, "sbrk test fork failed\n");
+-    exit(23);
+-  }
+-  c = sbrk(1);
+-  c = sbrk(1);
+-  if(c != a + 1){
+-    printf(stdout, "sbrk test failed post-fork\n");
+-    exit(22);
+-  }
+-  if(pid == 0)
+-    exit(21);
+-  wait(NULL);
+-
+-  // can one grow address space to something big?
+-#define BIG (100*1024*1024)
+-  a = sbrk(0);
+-  amt = (BIG) - (uint)a;
+-  p = sbrk(amt);
+-  if (p != a) {
+-    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+-    exit(20);
+-  }
+-  lastaddr = (char*) (BIG-1);
+-  *lastaddr = 99;
+-
+-  // can one de-allocate?
+-  a = sbrk(0);
+-  c = sbrk(-4096);
+-  if(c == (char*)0xffffffff){
+-    printf(stdout, "sbrk could not deallocate\n");
+-    exit(19);
+-  }
+-  c = sbrk(0);
+-  if(c != a - 4096){
+-    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+-    exit(18);
+-  }
+-
+-  // can one re-allocate that page?
+-  a = sbrk(0);
+-  c = sbrk(4096);
+-  if(c != a || sbrk(0) != a + 4096){
+-    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+-    exit(17);
+-  }
+-  if(*lastaddr == 99){
+-    // should be zero
+-    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+-    exit(16);
+-  }
+-
+-  a = sbrk(0);
+-  c = sbrk(-(sbrk(0) - oldbrk));
+-  if(c != a){
+-    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+-    exit(15);
+-  }
+-
+-  // can we read the kernel's memory?
+-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+-    ppid = getpid();
+-    pid = fork();
+-    if(pid < 0){
+-      printf(stdout, "fork failed\n");
+-      exit(14);
+-    }
+-    if(pid == 0){
+-      printf(stdout, "oops could read %x = %x\n", a, *a);
+-      kill(ppid);
+-      exit(13);
+-    }
+-    wait(NULL);
+-  }
+-
+-  // if we run the system out of memory, does it clean up the last
+-  // failed allocation?
+-  if(pipe(fds) != 0){
+-    printf(1, "pipe() failed\n");
+-    exit(12);
+-  }
+-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+-    if((pids[i] = fork()) == 0){
+-      // allocate a lot of memory
+-      sbrk(BIG - (uint)sbrk(0));
+-      write(fds[1], "x", 1);
+-      // sit around until killed
+-      for(;;) sleep(1000);
+-    }
+-    if(pids[i] != -1)
+-      read(fds[0], &scratch, 1);
+-  }
+-  // if those failed allocations freed up the pages they did allocate,
+-  // we'll be able to allocate here
+-  c = sbrk(4096);
+-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+-    if(pids[i] == -1)
+-      continue;
+-    kill(pids[i]);
+-    wait(NULL);
+-  }
+-  if(c == (char*)0xffffffff){
+-    printf(stdout, "failed sbrk leaked memory\n");
+-    exit(10);
+-  }
+-
+-  if(sbrk(0) > oldbrk)
+-    sbrk(-(sbrk(0) - oldbrk));
+-
+-  printf(stdout, "sbrk test OK\n");
+-}
+-
+-void
+-validateint(int *p)
+-{
+-  int res;
+-  asm("mov %%esp, %%ebx\n\t"
+-      "mov %3, %%esp\n\t"
+-      "int %2\n\t"
+-      "mov %%ebx, %%esp" :
+-      "=a" (res) :
+-      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
+-      "ebx");
+-}
+-
+-void
+-validatetest(void)
+-{
+-  int hi, pid;
+-  uint p;
+-
+-  printf(stdout, "validate test\n");
+-  hi = 1100*1024;
+-
+-  for(p = 0; p <= (uint)hi; p += 4096){
+-    if((pid = fork()) == 0){
+-      // try to crash the kernel by passing in a badly placed integer
+-      validateint((int*)p);
+-      exit(9);
+-    }
+-    sleep(0);
+-    sleep(0);
+-    kill(pid);
+-    wait(NULL);
+-
+-    // try to crash the kernel by passing in a bad string pointer
+-    if(link("nosuchfile", (char*)p) != -1){
+-      printf(stdout, "link should not succeed\n");
+-      exit(8);
+-    }
+-  }
+-
+-  printf(stdout, "validate ok\n");
+-}
+-
+-// does unintialized data start out zero?
+-char uninit[10000];
+-void
+-bsstest(void)
+-{
+-  int i;
+-
+-  printf(stdout, "bss test\n");
+-  for(i = 0; i < sizeof(uninit); i++){
+-    if(uninit[i] != '\0'){
+-      printf(stdout, "bss test failed\n");
+-      exit(7);
+-    }
+-  }
+-  printf(stdout, "bss test ok\n");
+-}
+-
+-// does exec return an error if the arguments
+-// are larger than a page? or does it write
+-// below the stack and wreck the instructions/data?
+-void
+-bigargtest(void)
+-{
+-  int pid, fd;
+-
+-  unlink("bigarg-ok");
+-  pid = fork();
+-  if(pid == 0){
+-    static char *args[MAXARG];
+-    int i;
+-    for(i = 0; i < MAXARG-1; i++)
+-      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
+-    args[MAXARG-1] = 0;
+-    printf(stdout, "bigarg test\n");
+-    exec("echo", args);
+-    printf(stdout, "bigarg test ok\n");
+-    fd = open("bigarg-ok", O_CREATE);
+-    close(fd);
+-    exit(6);
+-  } else if(pid < 0){
+-    printf(stdout, "bigargtest: fork failed\n");
+-    exit(5);
+-  }
+-  wait(NULL);
+-  fd = open("bigarg-ok", 0);
+-  if(fd < 0){
+-    printf(stdout, "bigarg test failed!\n");
+-    exit(4);
+-  }
+-  close(fd);
+-  unlink("bigarg-ok");
+-}
+-
+-// what happens when the file system runs out of blocks?
+-// answer: balloc panics, so this test is not useful.
+-void
+-fsfull()
+-{
+-  int nfiles;
+-  int fsblocks = 0;
+-
+-  printf(1, "fsfull test\n");
+-
+-  for(nfiles = 0; ; nfiles++){
+-    char name[64];
+-    name[0] = 'f';
+-    name[1] = '0' + nfiles / 1000;
+-    name[2] = '0' + (nfiles % 1000) / 100;
+-    name[3] = '0' + (nfiles % 100) / 10;
+-    name[4] = '0' + (nfiles % 10);
+-    name[5] = '\0';
+-    printf(1, "writing %s\n", name);
+-    int fd = open(name, O_CREATE|O_RDWR);
+-    if(fd < 0){
+-      printf(1, "open %s failed\n", name);
+-      break;
+-    }
+-    int total = 0;
+-    while(1){
+-      int cc = write(fd, buf, 512);
+-      if(cc < 512)
+-        break;
+-      total += cc;
+-      fsblocks++;
+-    }
+-    printf(1, "wrote %d bytes\n", total);
+-    close(fd);
+-    if(total == 0)
+-      break;
+-  }
+-
+-  while(nfiles >= 0){
+-    char name[64];
+-    name[0] = 'f';
+-    name[1] = '0' + nfiles / 1000;
+-    name[2] = '0' + (nfiles % 1000) / 100;
+-    name[3] = '0' + (nfiles % 100) / 10;
+-    name[4] = '0' + (nfiles % 10);
+-    name[5] = '\0';
+-    unlink(name);
+-    nfiles--;
+-  }
+-
+-  printf(1, "fsfull test finished\n");
+-}
+-
+-void
+-uio()
+-{
+-  #define RTC_ADDR 0x70
+-  #define RTC_DATA 0x71
+-
+-  ushort port = 0;
+-  uchar val = 0;
+-  int pid;
+-
+-  printf(1, "uio test\n");
+-  pid = fork();
+-  if(pid == 0){
+-    port = RTC_ADDR;
+-    val = 0x09;  /* year */
+-    /* http://wiki.osdev.org/Inline_Assembly/Examples */
+-    asm volatile("outb %0,%1"::"a"(val), "d" (port));
+-    port = RTC_DATA;
+-    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+-    printf(1, "uio: uio succeeded; test FAILED\n");
+-    exit(3);
+-  } else if(pid < 0){
+-    printf (1, "fork failed\n");
+-    exit(2);
+-  }
+-  wait(NULL);
+-  printf(1, "uio test done\n");
+-}
+-
+-void argptest()
+-{
+-  int fd;
+-  fd = open("init", O_RDONLY);
+-  if (fd < 0) {
+-    printf(2, "open failed\n");
+-    exit(1);
+-  }
+-  read(fd, sbrk(0) - 1, -1);
+-  close(fd);
+-  printf(1, "arg test passed\n");
+-}
+-
+-unsigned long randstate = 1;
+-unsigned int
+-rand()
+-{
+-  randstate = randstate * 1664525 + 1013904223;
+-  return randstate;
+-}
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  printf(1, "usertests starting\n");
+-
+-  if(open("usertests.ran", 0) >= 0){
+-    printf(1, "already ran user tests -- rebuild fs.img\n");
+-    exit(1);
+-  }
+-  close(open("usertests.ran", O_CREATE));
+-
+-  argptest();
+-  createdelete();
+-  linkunlink();
+-  concreate();
+-  fourfiles();
+-  sharedfd();
+-
+-  bigargtest();
+-  bigwrite();
+-  bigargtest();
+-  bsstest();
+-  sbrktest();
+-  validatetest();
+-
+-  opentest();
+-  writetest();
+-  writetest1();
+-  createtest();
+-
+-  openiputtest();
+-  exitiputtest();
+-  iputtest();
+-
+-  mem();
+-  pipe1();
+-  preempt();
+-  exitwait();
+-
+-  rmdot();
+-  fourteen();
+-  bigfile();
+-  subdir();
+-  linktest();
+-  unlinkread();
+-  dirfile();
+-  iref();
+-  forktest();
+-  bigdir(); // slow
+-
+-  uio();
+-
+-  exectest();
+-
+-  exit(0);
+-}
 diff --git a/usys.S b/usys.S
-index 8bfd8a1..1687ed0 100644
+deleted file mode 100644
+index 1687ed0..0000000
 --- a/usys.S
-+++ b/usys.S
-@@ -11,6 +11,7 @@
- SYSCALL(fork)
- SYSCALL(exit)
- SYSCALL(wait)
-+SYSCALL(waitpid)
- SYSCALL(pipe)
- SYSCALL(read)
- SYSCALL(write)
++++ /dev/null
+@@ -1,32 +0,0 @@
+-#include "syscall.h"
+-#include "traps.h"
+-
+-#define SYSCALL(name) \
+-  .globl name; \
+-  name: \
+-    movl $SYS_ ## name, %eax; \
+-    int $T_SYSCALL; \
+-    ret
+-
+-SYSCALL(fork)
+-SYSCALL(exit)
+-SYSCALL(wait)
+-SYSCALL(waitpid)
+-SYSCALL(pipe)
+-SYSCALL(read)
+-SYSCALL(write)
+-SYSCALL(close)
+-SYSCALL(kill)
+-SYSCALL(exec)
+-SYSCALL(open)
+-SYSCALL(mknod)
+-SYSCALL(unlink)
+-SYSCALL(fstat)
+-SYSCALL(link)
+-SYSCALL(mkdir)
+-SYSCALL(chdir)
+-SYSCALL(dup)
+-SYSCALL(getpid)
+-SYSCALL(sbrk)
+-SYSCALL(sleep)
+-SYSCALL(uptime)
 diff --git a/vectors.pl b/vectors.pl
-old mode 100755
-new mode 100644
+deleted file mode 100644
+index 57b49dd..0000000
+--- a/vectors.pl
++++ /dev/null
+@@ -1,47 +0,0 @@
+-#!/usr/bin/perl -w
+-
+-# Generate vectors.S, the trap/interrupt entry points.
+-# There has to be one entry point per interrupt number
+-# since otherwise there's no way for trap() to discover
+-# the interrupt number.
+-
+-print "# generated by vectors.pl - do not edit\n";
+-print "# handlers\n";
+-print ".globl alltraps\n";
+-for(my $i = 0; $i < 256; $i++){
+-    print ".globl vector$i\n";
+-    print "vector$i:\n";
+-    if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
+-        print "  pushl \$0\n";
+-    }
+-    print "  pushl \$$i\n";
+-    print "  jmp alltraps\n";
+-}
+-
+-print "\n# vector table\n";
+-print ".data\n";
+-print ".globl vectors\n";
+-print "vectors:\n";
+-for(my $i = 0; $i < 256; $i++){
+-    print "  .long vector$i\n";
+-}
+-
+-# sample output:
+-#   # handlers
+-#   .globl alltraps
+-#   .globl vector0
+-#   vector0:
+-#     pushl $0
+-#     pushl $0
+-#     jmp alltraps
+-#   ...
+-#   
+-#   # vector table
+-#   .data
+-#   .globl vectors
+-#   vectors:
+-#     .long vector0
+-#     .long vector1
+-#     .long vector2
+-#   ...
+-
+diff --git a/vm.c b/vm.c
+deleted file mode 100644
+index 7134cff..0000000
+--- a/vm.c
++++ /dev/null
+@@ -1,394 +0,0 @@
+-#include "param.h"
+-#include "types.h"
+-#include "defs.h"
+-#include "x86.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "elf.h"
+-
+-extern char data[];  // defined by kernel.ld
+-pde_t *kpgdir;  // for use in scheduler()
+-
+-// Set up CPU's kernel segment descriptors.
+-// Run once on entry on each CPU.
+-void
+-seginit(void)
+-{
+-  struct cpu *c;
+-
+-  // Map "logical" addresses to virtual addresses using identity map.
+-  // Cannot share a CODE descriptor for both kernel and user
+-  // because it would have to have DPL_USR, but the CPU forbids
+-  // an interrupt from CPL=0 to DPL=3.
+-  c = &cpus[cpuid()];
+-  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+-  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+-  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+-  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+-  lgdt(c->gdt, sizeof(c->gdt));
+-}
+-
+-// Return the address of the PTE in page table pgdir
+-// that corresponds to virtual address va.  If alloc!=0,
+-// create any required page table pages.
+-static pte_t *
+-walkpgdir(pde_t *pgdir, const void *va, int alloc)
+-{
+-  pde_t *pde;
+-  pte_t *pgtab;
+-
+-  pde = &pgdir[PDX(va)];
+-  if(*pde & PTE_P){
+-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+-  } else {
+-    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+-      return 0;
+-    // Make sure all those PTE_P bits are zero.
+-    memset(pgtab, 0, PGSIZE);
+-    // The permissions here are overly generous, but they can
+-    // be further restricted by the permissions in the page table
+-    // entries, if necessary.
+-    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+-  }
+-  return &pgtab[PTX(va)];
+-}
+-
+-// Create PTEs for virtual addresses starting at va that refer to
+-// physical addresses starting at pa. va and size might not
+-// be page-aligned.
+-static int
+-mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
+-{
+-  char *a, *last;
+-  pte_t *pte;
+-
+-  a = (char*)PGROUNDDOWN((uint)va);
+-  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+-  for(;;){
+-    if((pte = walkpgdir(pgdir, a, 1)) == 0)
+-      return -1;
+-    if(*pte & PTE_P)
+-      panic("remap");
+-    *pte = pa | perm | PTE_P;
+-    if(a == last)
+-      break;
+-    a += PGSIZE;
+-    pa += PGSIZE;
+-  }
+-  return 0;
+-}
+-
+-// There is one page table per process, plus one that's used when
+-// a CPU is not running any process (kpgdir). The kernel uses the
+-// current process's page table during system calls and interrupts;
+-// page protection bits prevent user code from using the kernel's
+-// mappings.
+-//
+-// setupkvm() and exec() set up every page table like this:
+-//
+-//   0..KERNBASE: user memory (text+data+stack+heap), mapped to
+-//                phys memory allocated by the kernel
+-//   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)
+-//   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)
+-//                for the kernel's instructions and r/o data
+-//   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,
+-//                                  rw data + free physical memory
+-//   0xfe000000..0: mapped direct (devices such as ioapic)
+-//
+-// The kernel allocates physical memory for its heap and for user memory
+-// between V2P(end) and the end of physical memory (PHYSTOP)
+-// (directly addressable from end..P2V(PHYSTOP)).
+-
+-// This table defines the kernel's mappings, which are present in
+-// every process's page table.
+-static struct kmap {
+-  void *virt;
+-  uint phys_start;
+-  uint phys_end;
+-  int perm;
+-} kmap[] = {
+- { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
+- { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
+- { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
+- { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
+-};
+-
+-// Set up kernel part of a page table.
+-pde_t*
+-setupkvm(void)
+-{
+-  pde_t *pgdir;
+-  struct kmap *k;
+-
+-  if((pgdir = (pde_t*)kalloc()) == 0)
+-    return 0;
+-  memset(pgdir, 0, PGSIZE);
+-  if (P2V(PHYSTOP) > (void*)DEVSPACE)
+-    panic("PHYSTOP too high");
+-  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+-    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+-                (uint)k->phys_start, k->perm) < 0) {
+-      freevm(pgdir);
+-      return 0;
+-    }
+-  return pgdir;
+-}
+-
+-// Allocate one page table for the machine for the kernel address
+-// space for scheduler processes.
+-void
+-kvmalloc(void)
+-{
+-  kpgdir = setupkvm();
+-  switchkvm();
+-}
+-
+-// Switch h/w page table register to the kernel-only page table,
+-// for when no process is running.
+-void
+-switchkvm(void)
+-{
+-  lcr3(V2P(kpgdir));   // switch to the kernel page table
+-}
+-
+-// Switch TSS and h/w page table to correspond to process p.
+-void
+-switchuvm(struct proc *p)
+-{
+-  if(p == 0)
+-    panic("switchuvm: no process");
+-  if(p->kstack == 0)
+-    panic("switchuvm: no kstack");
+-  if(p->pgdir == 0)
+-    panic("switchuvm: no pgdir");
+-
+-  pushcli();
+-  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
+-                                sizeof(mycpu()->ts)-1, 0);
+-  mycpu()->gdt[SEG_TSS].s = 0;
+-  mycpu()->ts.ss0 = SEG_KDATA << 3;
+-  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+-  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
+-  // forbids I/O instructions (e.g., inb and outb) from user space
+-  mycpu()->ts.iomb = (ushort) 0xFFFF;
+-  ltr(SEG_TSS << 3);
+-  lcr3(V2P(p->pgdir));  // switch to process's address space
+-  popcli();
+-}
+-
+-// Load the initcode into address 0 of pgdir.
+-// sz must be less than a page.
+-void
+-inituvm(pde_t *pgdir, char *init, uint sz)
+-{
+-  char *mem;
+-
+-  if(sz >= PGSIZE)
+-    panic("inituvm: more than a page");
+-  mem = kalloc();
+-  memset(mem, 0, PGSIZE);
+-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
+-  memmove(mem, init, sz);
+-}
+-
+-// Load a program segment into pgdir.  addr must be page-aligned
+-// and the pages from addr to addr+sz must already be mapped.
+-int
+-loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
+-{
+-  uint i, pa, n;
+-  pte_t *pte;
+-
+-  if((uint) addr % PGSIZE != 0)
+-    panic("loaduvm: addr must be page aligned");
+-  for(i = 0; i < sz; i += PGSIZE){
+-    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
+-      panic("loaduvm: address should exist");
+-    pa = PTE_ADDR(*pte);
+-    if(sz - i < PGSIZE)
+-      n = sz - i;
+-    else
+-      n = PGSIZE;
+-    if(readi(ip, P2V(pa), offset+i, n) != n)
+-      return -1;
+-  }
+-  return 0;
+-}
+-
+-// Allocate page tables and physical memory to grow process from oldsz to
+-// newsz, which need not be page aligned.  Returns new size or 0 on error.
+-int
+-allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+-{
+-  char *mem;
+-  uint a;
+-
+-  if(newsz >= KERNBASE)
+-    return 0;
+-  if(newsz < oldsz)
+-    return oldsz;
+-
+-  a = PGROUNDUP(oldsz);
+-  for(; a < newsz; a += PGSIZE){
+-    mem = kalloc();
+-    if(mem == 0){
+-      cprintf("allocuvm out of memory\n");
+-      deallocuvm(pgdir, newsz, oldsz);
+-      return 0;
+-    }
+-    memset(mem, 0, PGSIZE);
+-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
+-      cprintf("allocuvm out of memory (2)\n");
+-      deallocuvm(pgdir, newsz, oldsz);
+-      kfree(mem);
+-      return 0;
+-    }
+-  }
+-  return newsz;
+-}
+-
+-// Deallocate user pages to bring the process size from oldsz to
+-// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+-// need to be less than oldsz.  oldsz can be larger than the actual
+-// process size.  Returns the new process size.
+-int
+-deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+-{
+-  pte_t *pte;
+-  uint a, pa;
+-
+-  if(newsz >= oldsz)
+-    return oldsz;
+-
+-  a = PGROUNDUP(newsz);
+-  for(; a  < oldsz; a += PGSIZE){
+-    pte = walkpgdir(pgdir, (char*)a, 0);
+-    if(!pte)
+-      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+-    else if((*pte & PTE_P) != 0){
+-      pa = PTE_ADDR(*pte);
+-      if(pa == 0)
+-        panic("kfree");
+-      char *v = P2V(pa);
+-      kfree(v);
+-      *pte = 0;
+-    }
+-  }
+-  return newsz;
+-}
+-
+-// Free a page table and all the physical memory pages
+-// in the user part.
+-void
+-freevm(pde_t *pgdir)
+-{
+-  uint i;
+-
+-  if(pgdir == 0)
+-    panic("freevm: no pgdir");
+-  deallocuvm(pgdir, KERNBASE, 0);
+-  for(i = 0; i < NPDENTRIES; i++){
+-    if(pgdir[i] & PTE_P){
+-      char * v = P2V(PTE_ADDR(pgdir[i]));
+-      kfree(v);
+-    }
+-  }
+-  kfree((char*)pgdir);
+-}
+-
+-// Clear PTE_U on a page. Used to create an inaccessible
+-// page beneath the user stack.
+-void
+-clearpteu(pde_t *pgdir, char *uva)
+-{
+-  pte_t *pte;
+-
+-  pte = walkpgdir(pgdir, uva, 0);
+-  if(pte == 0)
+-    panic("clearpteu");
+-  *pte &= ~PTE_U;
+-}
+-
+-// Given a parent process's page table, create a copy
+-// of it for a child.
+-pde_t*
+-copyuvm(pde_t *pgdir, uint sz)
+-{
+-  pde_t *d;
+-  pte_t *pte;
+-  uint pa, i, flags;
+-  char *mem;
+-
+-  if((d = setupkvm()) == 0)
+-    return 0;
+-  for(i = 0; i < sz; i += PGSIZE){
+-    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+-      panic("copyuvm: pte should exist");
+-    if(!(*pte & PTE_P))
+-      panic("copyuvm: page not present");
+-    pa = PTE_ADDR(*pte);
+-    flags = PTE_FLAGS(*pte);
+-    if((mem = kalloc()) == 0)
+-      goto bad;
+-    memmove(mem, (char*)P2V(pa), PGSIZE);
+-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
+-      kfree(mem);
+-      goto bad;
+-    }
+-  }
+-  return d;
+-
+-bad:
+-  freevm(d);
+-  return 0;
+-}
+-
+-//PAGEBREAK!
+-// Map user virtual address to kernel address.
+-char*
+-uva2ka(pde_t *pgdir, char *uva)
+-{
+-  pte_t *pte;
+-
+-  pte = walkpgdir(pgdir, uva, 0);
+-  if((*pte & PTE_P) == 0)
+-    return 0;
+-  if((*pte & PTE_U) == 0)
+-    return 0;
+-  return (char*)P2V(PTE_ADDR(*pte));
+-}
+-
+-// Copy len bytes from p to user address va in page table pgdir.
+-// Most useful when pgdir is not the current page table.
+-// uva2ka ensures this only works for PTE_U pages.
+-int
+-copyout(pde_t *pgdir, uint va, void *p, uint len)
+-{
+-  char *buf, *pa0;
+-  uint n, va0;
+-
+-  buf = (char*)p;
+-  while(len > 0){
+-    va0 = (uint)PGROUNDDOWN(va);
+-    pa0 = uva2ka(pgdir, (char*)va0);
+-    if(pa0 == 0)
+-      return -1;
+-    n = PGSIZE - (va - va0);
+-    if(n > len)
+-      n = len;
+-    memmove(pa0 + (va - va0), buf, n);
+-    len -= n;
+-    buf += n;
+-    va = va0 + PGSIZE;
+-  }
+-  return 0;
+-}
+-
+-//PAGEBREAK!
+-// Blank page.
+-//PAGEBREAK!
+-// Blank page.
+-//PAGEBREAK!
+-// Blank page.
+-
 diff --git a/wc.c b/wc.c
-index d6a54df..08b93b6 100644
+deleted file mode 100644
+index 08b93b6..0000000
 --- a/wc.c
-+++ b/wc.c
-@@ -27,7 +27,7 @@ wc(int fd, char *name)
-   }
-   if(n < 0){
-     printf(1, "wc: read error\n");
--    exit();
-+    exit(3);
-   }
-   printf(1, "%d %d %d %s\n", l, w, c, name);
- }
-@@ -39,16 +39,16 @@ main(int argc, char *argv[])
- 
-   if(argc <= 1){
-     wc(0, "");
--    exit();
-+    exit(2);
-   }
- 
-   for(i = 1; i < argc; i++){
-     if((fd = open(argv[i], 0)) < 0){
-       printf(1, "wc: cannot open %s\n", argv[i]);
--      exit();
-+      exit(1);
-     }
-     wc(fd, argv[i]);
-     close(fd);
-   }
--  exit();
-+  exit(0);
- }
++++ /dev/null
+@@ -1,54 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-char buf[512];
+-
+-void
+-wc(int fd, char *name)
+-{
+-  int i, n;
+-  int l, w, c, inword;
+-
+-  l = w = c = 0;
+-  inword = 0;
+-  while((n = read(fd, buf, sizeof(buf))) > 0){
+-    for(i=0; i<n; i++){
+-      c++;
+-      if(buf[i] == '\n')
+-        l++;
+-      if(strchr(" \r\t\n\v", buf[i]))
+-        inword = 0;
+-      else if(!inword){
+-        w++;
+-        inword = 1;
+-      }
+-    }
+-  }
+-  if(n < 0){
+-    printf(1, "wc: read error\n");
+-    exit(3);
+-  }
+-  printf(1, "%d %d %d %s\n", l, w, c, name);
+-}
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int fd, i;
+-
+-  if(argc <= 1){
+-    wc(0, "");
+-    exit(2);
+-  }
+-
+-  for(i = 1; i < argc; i++){
+-    if((fd = open(argv[i], 0)) < 0){
+-      printf(1, "wc: cannot open %s\n", argv[i]);
+-      exit(1);
+-    }
+-    wc(fd, argv[i]);
+-    close(fd);
+-  }
+-  exit(0);
+-}
+diff --git a/x86.h b/x86.h
+deleted file mode 100644
+index 07312a5..0000000
+--- a/x86.h
++++ /dev/null
+@@ -1,183 +0,0 @@
+-// Routines to let C code use special x86 instructions.
+-
+-static inline uchar
+-inb(ushort port)
+-{
+-  uchar data;
+-
+-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+-  return data;
+-}
+-
+-static inline void
+-insl(int port, void *addr, int cnt)
+-{
+-  asm volatile("cld; rep insl" :
+-               "=D" (addr), "=c" (cnt) :
+-               "d" (port), "0" (addr), "1" (cnt) :
+-               "memory", "cc");
+-}
+-
+-static inline void
+-outb(ushort port, uchar data)
+-{
+-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+-}
+-
+-static inline void
+-outw(ushort port, ushort data)
+-{
+-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+-}
+-
+-static inline void
+-outsl(int port, const void *addr, int cnt)
+-{
+-  asm volatile("cld; rep outsl" :
+-               "=S" (addr), "=c" (cnt) :
+-               "d" (port), "0" (addr), "1" (cnt) :
+-               "cc");
+-}
+-
+-static inline void
+-stosb(void *addr, int data, int cnt)
+-{
+-  asm volatile("cld; rep stosb" :
+-               "=D" (addr), "=c" (cnt) :
+-               "0" (addr), "1" (cnt), "a" (data) :
+-               "memory", "cc");
+-}
+-
+-static inline void
+-stosl(void *addr, int data, int cnt)
+-{
+-  asm volatile("cld; rep stosl" :
+-               "=D" (addr), "=c" (cnt) :
+-               "0" (addr), "1" (cnt), "a" (data) :
+-               "memory", "cc");
+-}
+-
+-struct segdesc;
+-
+-static inline void
+-lgdt(struct segdesc *p, int size)
+-{
+-  volatile ushort pd[3];
+-
+-  pd[0] = size-1;
+-  pd[1] = (uint)p;
+-  pd[2] = (uint)p >> 16;
+-
+-  asm volatile("lgdt (%0)" : : "r" (pd));
+-}
+-
+-struct gatedesc;
+-
+-static inline void
+-lidt(struct gatedesc *p, int size)
+-{
+-  volatile ushort pd[3];
+-
+-  pd[0] = size-1;
+-  pd[1] = (uint)p;
+-  pd[2] = (uint)p >> 16;
+-
+-  asm volatile("lidt (%0)" : : "r" (pd));
+-}
+-
+-static inline void
+-ltr(ushort sel)
+-{
+-  asm volatile("ltr %0" : : "r" (sel));
+-}
+-
+-static inline uint
+-readeflags(void)
+-{
+-  uint eflags;
+-  asm volatile("pushfl; popl %0" : "=r" (eflags));
+-  return eflags;
+-}
+-
+-static inline void
+-loadgs(ushort v)
+-{
+-  asm volatile("movw %0, %%gs" : : "r" (v));
+-}
+-
+-static inline void
+-cli(void)
+-{
+-  asm volatile("cli");
+-}
+-
+-static inline void
+-sti(void)
+-{
+-  asm volatile("sti");
+-}
+-
+-static inline uint
+-xchg(volatile uint *addr, uint newval)
+-{
+-  uint result;
+-
+-  // The + in "+m" denotes a read-modify-write operand.
+-  asm volatile("lock; xchgl %0, %1" :
+-               "+m" (*addr), "=a" (result) :
+-               "1" (newval) :
+-               "cc");
+-  return result;
+-}
+-
+-static inline uint
+-rcr2(void)
+-{
+-  uint val;
+-  asm volatile("movl %%cr2,%0" : "=r" (val));
+-  return val;
+-}
+-
+-static inline void
+-lcr3(uint val)
+-{
+-  asm volatile("movl %0,%%cr3" : : "r" (val));
+-}
+-
+-//PAGEBREAK: 36
+-// Layout of the trap frame built on the stack by the
+-// hardware and by trapasm.S, and passed to trap().
+-struct trapframe {
+-  // registers as pushed by pusha
+-  uint edi;
+-  uint esi;
+-  uint ebp;
+-  uint oesp;      // useless & ignored
+-  uint ebx;
+-  uint edx;
+-  uint ecx;
+-  uint eax;
+-
+-  // rest of trap frame
+-  ushort gs;
+-  ushort padding1;
+-  ushort fs;
+-  ushort padding2;
+-  ushort es;
+-  ushort padding3;
+-  ushort ds;
+-  ushort padding4;
+-  uint trapno;
+-
+-  // below here defined by x86 hardware
+-  uint err;
+-  uint eip;
+-  ushort cs;
+-  ushort padding5;
+-  uint eflags;
+-
+-  // below here only when crossing rings, such as from user to kernel
+-  uint esp;
+-  ushort ss;
+-  ushort padding6;
+-};
 diff --git a/zombie.c b/zombie.c
-index ee817da..c96b92d 100644
+deleted file mode 100644
+index c96b92d..0000000
 --- a/zombie.c
-+++ b/zombie.c
-@@ -10,5 +10,5 @@ main(void)
- {
-   if(fork() > 0)
-     sleep(5);  // Let child exit before parent.
--  exit();
-+  exit(0);
- }
++++ /dev/null
+@@ -1,14 +0,0 @@
+-// Create a zombie process that
+-// must be reparented at exit.
+-
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-int
+-main(void)
+-{
+-  if(fork() > 0)
+-    sleep(5);  // Let child exit before parent.
+-  exit(0);
+-}
diff --git a/code2.diff b/code2.diff
new file mode 100644
index 0000000..3794ab0
--- /dev/null
+++ b/code2.diff
@@ -0,0 +1,5876 @@
+diff --git a/Makefile b/Makefile
+index 04d74d5..09d790c 100644
+--- a/Makefile
++++ b/Makefile
+@@ -181,7 +181,6 @@ UPROGS=\
+ 	_usertests\
+ 	_wc\
+ 	_zombie\
+-	_lab1\
+ 
+ fs.img: mkfs README $(UPROGS)
+ 	./mkfs fs.img README $(UPROGS)
+diff --git a/cat.c b/cat.c
+index 68b1b8d..5ddc820 100644
+--- a/cat.c
++++ b/cat.c
+@@ -12,12 +12,12 @@ cat(int fd)
+   while((n = read(fd, buf, sizeof(buf))) > 0) {
+     if (write(1, buf, n) != n) {
+       printf(1, "cat: write error\n");
+-      exit(3);
++      exit();
+     }
+   }
+   if(n < 0){
+     printf(1, "cat: read error\n");
+-    exit(4);
++    exit();
+   }
+ }
+ 
+@@ -28,16 +28,16 @@ main(int argc, char *argv[])
+ 
+   if(argc <= 1){
+     cat(0);
+-    exit(1);
++    exit();
+   }
+ 
+   for(i = 1; i < argc; i++){
+     if((fd = open(argv[i], 0)) < 0){
+       printf(1, "cat: cannot open %s\n", argv[i]);
+-      exit(2);
++      exit();
+     }
+     cat(fd);
+     close(fd);
+   }
+-  exit(0);
++  exit();
+ }
+diff --git a/code.diff b/code.diff
+deleted file mode 100644
+index c889659..0000000
+--- a/code.diff
++++ /dev/null
+@@ -1,2919 +0,0 @@
+-diff --git a/Makefile b/Makefile
+-index 09d790c..04d74d5 100644
+---- a/Makefile
+-+++ b/Makefile
+-@@ -181,6 +181,7 @@ UPROGS=\
+- 	_usertests\
+- 	_wc\
+- 	_zombie\
+-+	_lab1\
+- 
+- fs.img: mkfs README $(UPROGS)
+- 	./mkfs fs.img README $(UPROGS)
+-diff --git a/cat.c b/cat.c
+-index 5ddc820..68b1b8d 100644
+---- a/cat.c
+-+++ b/cat.c
+-@@ -12,12 +12,12 @@ cat(int fd)
+-   while((n = read(fd, buf, sizeof(buf))) > 0) {
+-     if (write(1, buf, n) != n) {
+-       printf(1, "cat: write error\n");
+--      exit();
+-+      exit(3);
+-     }
+-   }
+-   if(n < 0){
+-     printf(1, "cat: read error\n");
+--    exit();
+-+    exit(4);
+-   }
+- }
+- 
+-@@ -28,16 +28,16 @@ main(int argc, char *argv[])
+- 
+-   if(argc <= 1){
+-     cat(0);
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-     if((fd = open(argv[i], 0)) < 0){
+-       printf(1, "cat: cannot open %s\n", argv[i]);
+--      exit();
+-+      exit(2);
+-     }
+-     cat(fd);
+-     close(fd);
+-   }
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/cuth b/cuth
+-old mode 100755
+-new mode 100644
+-diff --git a/defs.h b/defs.h
+-index 82fb982..d1934ca 100644
+---- a/defs.h
+-+++ b/defs.h
+-@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
+- //PAGEBREAK: 16
+- // proc.c
+- int             cpuid(void);
+--void            exit(void);
+-+void            exit(int status);
+- int             fork(void);
+- int             growproc(int);
+- int             kill(int);
+-@@ -117,7 +117,8 @@ void            sched(void);
+- void            setproc(struct proc*);
+- void            sleep(void*, struct spinlock*);
+- void            userinit(void);
+--int             wait(void);
+-+int             wait(int* status);
+-+int             waitpid(int pid, int* status, int options);
+- void            wakeup(void*);
+- void            yield(void);
+- 
+-diff --git a/dot-bochsrc b/dot-bochsrc
+-old mode 100755
+-new mode 100644
+-diff --git a/echo.c b/echo.c
+-index 806dee0..eed68a0 100644
+---- a/echo.c
+-+++ b/echo.c
+-@@ -9,5 +9,5 @@ main(int argc, char *argv[])
+- 
+-   for(i = 1; i < argc; i++)
+-     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/forktest.c b/forktest.c
+-index 8bc984d..a4b35ed 100644
+---- a/forktest.c
+-+++ b/forktest.c
+-@@ -25,24 +25,24 @@ forktest(void)
+-     if(pid < 0)
+-       break;
+-     if(pid == 0)
+--      exit();
+-+      exit(4);
+-   }
+- 
+-   if(n == N){
+-     printf(1, "fork claimed to work N times!\n", N);
+--    exit();
+-+    exit(3);
+-   }
+- 
+-   for(; n > 0; n--){
+--    if(wait() < 0){
+-+    if(wait(NULL) < 0){
+-       printf(1, "wait stopped early\n");
+--      exit();
+-+      exit(2);
+-     }
+-   }
+- 
+--  if(wait() != -1){
+-+  if(wait(NULL) != -1){
+-     printf(1, "wait got too many\n");
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   printf(1, "fork test OK\n");
+-@@ -52,5 +52,5 @@ int
+- main(void)
+- {
+-   forktest();
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/grep.c b/grep.c
+-index adc4835..4be3256 100644
+---- a/grep.c
+-+++ b/grep.c
+-@@ -43,24 +43,24 @@ main(int argc, char *argv[])
+- 
+-   if(argc <= 1){
+-     printf(2, "usage: grep pattern [file ...]\n");
+--    exit();
+-+    exit(1);
+-   }
+-   pattern = argv[1];
+- 
+-   if(argc <= 2){
+-     grep(pattern, 0);
+--    exit();
+-+    exit(2);
+-   }
+- 
+-   for(i = 2; i < argc; i++){
+-     if((fd = open(argv[i], 0)) < 0){
+-       printf(1, "grep: cannot open %s\n", argv[i]);
+--      exit();
+-+      exit(3);
+-     }
+-     grep(pattern, fd);
+-     close(fd);
+-   }
+--  exit();
+-+  exit(0);
+- }
+- 
+- // Regexp matcher from Kernighan & Pike,
+-diff --git a/init.c b/init.c
+-index 046b551..bc6547f 100644
+---- a/init.c
+-+++ b/init.c
+-@@ -24,14 +24,14 @@ main(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "init: fork failed\n");
+--      exit();
+-+      exit(2);
+-     }
+-     if(pid == 0){
+-       exec("sh", argv);
+-       printf(1, "init: exec sh failed\n");
+--      exit();
+-+      exit(1);
+-     }
+--    while((wpid=wait()) >= 0 && wpid != pid)
+-+    while((wpid=wait(NULL)) >= 0 && wpid != pid)
+-       printf(1, "zombie!\n");
+-   }
+- }
+-diff --git a/kill.c b/kill.c
+-index 364f6af..875916c 100644
+---- a/kill.c
+-+++ b/kill.c
+-@@ -9,9 +9,9 @@ main(int argc, char **argv)
+- 
+-   if(argc < 2){
+-     printf(2, "usage: kill pid...\n");
+--    exit();
+-+    exit(1);
+-   }
+-   for(i=1; i<argc; i++)
+-     kill(atoi(argv[i]));
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/lab1.c b/lab1.c
+-index 89668ce..2192a52 100644
+---- a/lab1.c
+-+++ b/lab1.c
+-@@ -25,7 +25,7 @@ int main(int argc, char **argv) {
+-     if(pid > 0)
+-     {
+-         waitpid(pid, NULL, 0);
+--        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);
+-+        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
+-         exit(0);
+-     }
+- 
+-diff --git a/ln.c b/ln.c
+-index cf8a64e..fb17c3b 100644
+---- a/ln.c
+-+++ b/ln.c
+-@@ -7,9 +7,9 @@ main(int argc, char *argv[])
+- {
+-   if(argc != 3){
+-     printf(2, "Usage: ln old new\n");
+--    exit();
+-+    exit(1);
+-   }
+-   if(link(argv[1], argv[2]) < 0)
+-     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/ls.c b/ls.c
+-index 2862913..6bf943b 100644
+---- a/ls.c
+-+++ b/ls.c
+-@@ -77,9 +77,9 @@ main(int argc, char *argv[])
+- 
+-   if(argc < 2){
+-     ls(".");
+--    exit();
+-+    exit(1);
+-   }
+-   for(i=1; i<argc; i++)
+-     ls(argv[i]);
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/mkdir.c b/mkdir.c
+-index 6e4c954..2d90781 100644
+---- a/mkdir.c
+-+++ b/mkdir.c
+-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
+- 
+-   if(argc < 2){
+-     printf(2, "Usage: mkdir files...\n");
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
+-     }
+-   }
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/pr.pl b/pr.pl
+-old mode 100755
+-new mode 100644
+-diff --git a/printpcs b/printpcs
+-old mode 100755
+-new mode 100644
+-diff --git a/proc.c b/proc.c
+-index 806b1b1..84b335f 100644
+---- a/proc.c
+-+++ b/proc.c
+-@@ -1,3 +1,5 @@
+-+#include <stddef.h>
+-+
+- #include "types.h"
+- #include "defs.h"
+- #include "param.h"
+-@@ -8,61 +10,61 @@
+- #include "spinlock.h"
+- 
+- struct {
+--  struct spinlock lock;
+--  struct proc proc[NPROC];
+-+    struct spinlock lock;
+-+    struct proc proc[NPROC];
+- } ptable;
+- 
+- static struct proc *initproc;
+- 
+- int nextpid = 1;
+-+
+- extern void forkret(void);
+-+
+- extern void trapret(void);
+- 
+- static void wakeup1(void *chan);
+- 
+- void
+--pinit(void)
+--{
+--  initlock(&ptable.lock, "ptable");
+-+pinit(void) {
+-+    initlock(&ptable.lock, "ptable");
+- }
+- 
+- // Must be called with interrupts disabled
+- int
+- cpuid() {
+--  return mycpu()-cpus;
+-+    return mycpu() - cpus;
+- }
+- 
+- // Must be called with interrupts disabled to avoid the caller being
+- // rescheduled between reading lapicid and running through the loop.
+--struct cpu*
+--mycpu(void)
+--{
+--  int apicid, i;
+--  
+--  if(readeflags()&FL_IF)
+--    panic("mycpu called with interrupts enabled\n");
+--  
+--  apicid = lapicid();
+--  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+--  // a reverse map, or reserve a register to store &cpus[i].
+--  for (i = 0; i < ncpu; ++i) {
+--    if (cpus[i].apicid == apicid)
+--      return &cpus[i];
+--  }
+--  panic("unknown apicid\n");
+-+struct cpu *
+-+mycpu(void) {
+-+    int apicid, i;
+-+
+-+    if (readeflags() & FL_IF)
+-+        panic("mycpu called with interrupts enabled\n");
+-+
+-+    apicid = lapicid();
+-+    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+-+    // a reverse map, or reserve a register to store &cpus[i].
+-+    for (i = 0; i < ncpu; ++i) {
+-+        if (cpus[i].apicid == apicid)
+-+            return &cpus[i];
+-+    }
+-+    panic("unknown apicid\n");
+- }
+- 
+- // Disable interrupts so that we are not rescheduled
+- // while reading proc from the cpu structure
+--struct proc*
+-+struct proc *
+- myproc(void) {
+--  struct cpu *c;
+--  struct proc *p;
+--  pushcli();
+--  c = mycpu();
+--  p = c->proc;
+--  popcli();
+--  return p;
+-+    struct cpu *c;
+-+    struct proc *p;
+-+    pushcli();
+-+    c = mycpu();
+-+    p = c->proc;
+-+    popcli();
+-+    return p;
+- }
+- 
+- //PAGEBREAK: 32
+-@@ -70,245 +72,295 @@ myproc(void) {
+- // If found, change state to EMBRYO and initialize
+- // state required to run in the kernel.
+- // Otherwise return 0.
+--static struct proc*
+--allocproc(void)
+--{
+--  struct proc *p;
+--  char *sp;
+-+static struct proc *
+-+allocproc(void) {
+-+    struct proc *p;
+-+    char *sp;
+- 
+--  acquire(&ptable.lock);
+-+    acquire(&ptable.lock);
+- 
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+--    if(p->state == UNUSED)
+--      goto found;
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-+        if (p->state == UNUSED)
+-+            goto found;
+- 
+--  release(&ptable.lock);
+--  return 0;
+-+    release(&ptable.lock);
+-+    return 0;
+- 
+--found:
+--  p->state = EMBRYO;
+--  p->pid = nextpid++;
+-+    found:
+-+    p->state = EMBRYO;
+-+    p->pid = nextpid++;
+- 
+--  release(&ptable.lock);
+-+    release(&ptable.lock);
+- 
+--  // Allocate kernel stack.
+--  if((p->kstack = kalloc()) == 0){
+--    p->state = UNUSED;
+--    return 0;
+--  }
+--  sp = p->kstack + KSTACKSIZE;
+-+    // Allocate kernel stack.
+-+    if ((p->kstack = kalloc()) == 0) {
+-+        p->state = UNUSED;
+-+        return 0;
+-+    }
+-+    sp = p->kstack + KSTACKSIZE;
+- 
+--  // Leave room for trap frame.
+--  sp -= sizeof *p->tf;
+--  p->tf = (struct trapframe*)sp;
+-+    // Leave room for trap frame.
+-+    sp -= sizeof *p->tf;
+-+    p->tf = (struct trapframe *) sp;
+- 
+--  // Set up new context to start executing at forkret,
+--  // which returns to trapret.
+--  sp -= 4;
+--  *(uint*)sp = (uint)trapret;
+-+    // Set up new context to start executing at forkret,
+-+    // which returns to trapret.
+-+    sp -= 4;
+-+    *(uint *) sp = (uint) trapret;
+- 
+--  sp -= sizeof *p->context;
+--  p->context = (struct context*)sp;
+--  memset(p->context, 0, sizeof *p->context);
+--  p->context->eip = (uint)forkret;
+-+    sp -= sizeof *p->context;
+-+    p->context = (struct context *) sp;
+-+    memset(p->context, 0, sizeof *p->context);
+-+    p->context->eip = (uint) forkret;
+- 
+--  return p;
+-+    return p;
+- }
+- 
+- //PAGEBREAK: 32
+- // Set up first user process.
+- void
+--userinit(void)
+--{
+--  struct proc *p;
+--  extern char _binary_initcode_start[], _binary_initcode_size[];
+--
+--  p = allocproc();
+--  
+--  initproc = p;
+--  if((p->pgdir = setupkvm()) == 0)
+--    panic("userinit: out of memory?");
+--  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+--  p->sz = PGSIZE;
+--  memset(p->tf, 0, sizeof(*p->tf));
+--  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+--  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+--  p->tf->es = p->tf->ds;
+--  p->tf->ss = p->tf->ds;
+--  p->tf->eflags = FL_IF;
+--  p->tf->esp = PGSIZE;
+--  p->tf->eip = 0;  // beginning of initcode.S
+--
+--  safestrcpy(p->name, "initcode", sizeof(p->name));
+--  p->cwd = namei("/");
+--
+--  // this assignment to p->state lets other cores
+--  // run this process. the acquire forces the above
+--  // writes to be visible, and the lock is also needed
+--  // because the assignment might not be atomic.
+--  acquire(&ptable.lock);
+--
+--  p->state = RUNNABLE;
+--
+--  release(&ptable.lock);
+-+userinit(void) {
+-+    struct proc *p;
+-+    extern char _binary_initcode_start[], _binary_initcode_size[];
+-+
+-+    p = allocproc();
+-+
+-+    initproc = p;
+-+    if ((p->pgdir = setupkvm()) == 0)
+-+        panic("userinit: out of memory?");
+-+    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
+-+    p->sz = PGSIZE;
+-+    memset(p->tf, 0, sizeof(*p->tf));
+-+    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+-+    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+-+    p->tf->es = p->tf->ds;
+-+    p->tf->ss = p->tf->ds;
+-+    p->tf->eflags = FL_IF;
+-+    p->tf->esp = PGSIZE;
+-+    p->tf->eip = 0;  // beginning of initcode.S
+-+
+-+    safestrcpy(p->name, "initcode", sizeof(p->name));
+-+    p->cwd = namei("/");
+-+
+-+    // this assignment to p->state lets other cores
+-+    // run this process. the acquire forces the above
+-+    // writes to be visible, and the lock is also needed
+-+    // because the assignment might not be atomic.
+-+    acquire(&ptable.lock);
+-+
+-+    p->state = RUNNABLE;
+-+
+-+    release(&ptable.lock);
+- }
+- 
+- // Grow current process's memory by n bytes.
+- // Return 0 on success, -1 on failure.
+- int
+--growproc(int n)
+--{
+--  uint sz;
+--  struct proc *curproc = myproc();
+--
+--  sz = curproc->sz;
+--  if(n > 0){
+--    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+--      return -1;
+--  } else if(n < 0){
+--    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+--      return -1;
+--  }
+--  curproc->sz = sz;
+--  switchuvm(curproc);
+--  return 0;
+-+growproc(int n) {
+-+    uint sz;
+-+    struct proc *curproc = myproc();
+-+
+-+    sz = curproc->sz;
+-+    if (n > 0) {
+-+        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-+            return -1;
+-+    } else if (n < 0) {
+-+        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-+            return -1;
+-+    }
+-+    curproc->sz = sz;
+-+    switchuvm(curproc);
+-+    return 0;
+- }
+- 
+- // Create a new process copying p as the parent.
+- // Sets up stack to return as if from system call.
+- // Caller must set state of returned proc to RUNNABLE.
+- int
+--fork(void)
+--{
+--  int i, pid;
+--  struct proc *np;
+--  struct proc *curproc = myproc();
+--
+--  // Allocate process.
+--  if((np = allocproc()) == 0){
+--    return -1;
+--  }
+-+fork(void) {
+-+    int i, pid;
+-+    struct proc *np;
+-+    struct proc *curproc = myproc();
+-+
+-+    // Allocate process.
+-+    if ((np = allocproc()) == 0) {
+-+        return -1;
+-+    }
+- 
+--  // Copy process state from proc.
+--  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+--    kfree(np->kstack);
+--    np->kstack = 0;
+--    np->state = UNUSED;
+--    return -1;
+--  }
+--  np->sz = curproc->sz;
+--  np->parent = curproc;
+--  *np->tf = *curproc->tf;
+-+    // Copy process state from proc.
+-+    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
+-+        kfree(np->kstack);
+-+        np->kstack = 0;
+-+        np->state = UNUSED;
+-+        return -1;
+-+    }
+-+    np->sz = curproc->sz;
+-+    np->parent = curproc;
+-+    *np->tf = *curproc->tf;
+- 
+--  // Clear %eax so that fork returns 0 in the child.
+--  np->tf->eax = 0;
+-+    // Clear %eax so that fork returns 0 in the child.
+-+    np->tf->eax = 0;
+- 
+--  for(i = 0; i < NOFILE; i++)
+--    if(curproc->ofile[i])
+--      np->ofile[i] = filedup(curproc->ofile[i]);
+--  np->cwd = idup(curproc->cwd);
+-+    for (i = 0; i < NOFILE; i++)
+-+        if (curproc->ofile[i])
+-+            np->ofile[i] = filedup(curproc->ofile[i]);
+-+    np->cwd = idup(curproc->cwd);
+- 
+--  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+-+    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+- 
+--  pid = np->pid;
+-+    pid = np->pid;
+- 
+--  acquire(&ptable.lock);
+-+    acquire(&ptable.lock);
+- 
+--  np->state = RUNNABLE;
+-+    np->state = RUNNABLE;
+- 
+--  release(&ptable.lock);
+-+    release(&ptable.lock);
+- 
+--  return pid;
+-+    return pid;
+- }
+- 
+- // Exit the current process.  Does not return.
+- // An exited process remains in the zombie state
+- // until its parent calls wait() to find out it exited.
+- void
+--exit(void)
+--{
+--  struct proc *curproc = myproc();
+--  struct proc *p;
+--  int fd;
+--
+--  if(curproc == initproc)
+--    panic("init exiting");
+--
+--  // Close all open files.
+--  for(fd = 0; fd < NOFILE; fd++){
+--    if(curproc->ofile[fd]){
+--      fileclose(curproc->ofile[fd]);
+--      curproc->ofile[fd] = 0;
+-+exit(int status) {
+-+    struct proc *curproc = myproc();
+-+    struct proc *p;
+-+    int fd;
+-+
+-+    curproc->status = status;
+-+
+-+    if (curproc == initproc)
+-+        panic("init exiting");
+-+
+-+    // Close all open files.
+-+    for (fd = 0; fd < NOFILE; fd++) {
+-+        if (curproc->ofile[fd]) {
+-+            fileclose(curproc->ofile[fd]);
+-+            curproc->ofile[fd] = 0;
+-+        }
+-     }
+--  }
+- 
+--  begin_op();
+--  iput(curproc->cwd);
+--  end_op();
+--  curproc->cwd = 0;
+-+    begin_op();
+-+    iput(curproc->cwd);
+-+    end_op();
+-+    curproc->cwd = 0;
+- 
+--  acquire(&ptable.lock);
+-+    acquire(&ptable.lock);
+- 
+--  // Parent might be sleeping in wait().
+--  wakeup1(curproc->parent);
+-+    // Parent might be sleeping in wait().
+-+    wakeup1(curproc->parent);
+- 
+--  // Pass abandoned children to init.
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--    if(p->parent == curproc){
+--      p->parent = initproc;
+--      if(p->state == ZOMBIE)
+--        wakeup1(initproc);
+-+    // Pass abandoned children to init.
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+        if (p->parent == curproc) {
+-+            p->parent = initproc;
+-+            if (p->state == ZOMBIE)
+-+                wakeup1(initproc);
+-+        }
+-     }
+--  }
+- 
+--  // Jump into the scheduler, never to return.
+--  curproc->state = ZOMBIE;
+--  sched();
+--  panic("zombie exit");
+-+    // Jump into the scheduler, never to return.
+-+    curproc->state = ZOMBIE;
+-+    sched();
+-+    panic("zombie exit");
+- }
+- 
+- // Wait for a child process to exit and return its pid.
+- // Return -1 if this process has no children.
+- int
+--wait(void)
+--{
+--  struct proc *p;
+--  int havekids, pid;
+--  struct proc *curproc = myproc();
+--  
+--  acquire(&ptable.lock);
+--  for(;;){
+--    // Scan through table looking for exited children.
+--    havekids = 0;
+--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--      if(p->parent != curproc)
+--        continue;
+--      havekids = 1;
+--      if(p->state == ZOMBIE){
+--        // Found one.
+--        pid = p->pid;
+--        kfree(p->kstack);
+--        p->kstack = 0;
+--        freevm(p->pgdir);
+--        p->pid = 0;
+--        p->parent = 0;
+--        p->name[0] = 0;
+--        p->killed = 0;
+--        p->state = UNUSED;
+--        release(&ptable.lock);
+--        return pid;
+--      }
+--    }
+-+wait(int *status) {
+-+    struct proc *p;
+-+    int havekids, pid;
+-+    struct proc *curproc = myproc();
+- 
+--    // No point waiting if we don't have any children.
+--    if(!havekids || curproc->killed){
+--      release(&ptable.lock);
+--      return -1;
+-+    acquire(&ptable.lock);
+-+    for (;;) {
+-+        // Scan through table looking for exited children.
+-+        havekids = 0;
+-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+            if (p->parent != curproc)
+-+                continue;
+-+            havekids = 1;
+-+            if (p->state == ZOMBIE) {
+-+                // Found one.
+-+                pid = p->pid;
+-+                kfree(p->kstack);
+-+                p->kstack = 0;
+-+                freevm(p->pgdir);
+-+                p->pid = 0;
+-+                p->parent = 0;
+-+                p->name[0] = 0;
+-+                p->killed = 0;
+-+                p->state = UNUSED;
+-+                release(&ptable.lock);
+-+                if (status != NULL)
+-+                    *status = p->status;
+-+                return pid;
+-+            }
+-+        }
+-+
+-+        // No point waiting if we don't have any children.
+-+        if (!havekids || curproc->killed) {
+-+            release(&ptable.lock);
+-+            return -1;
+-+        }
+-+
+-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+-     }
+-+}
+- 
+--    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+--    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+--  }
+-+// Wait for a child process to exit and return its pid.
+-+// Return -1 if this process has no children.
+-+int
+-+waitpid(int pidBeingSearchedFor, int *status, int options) {
+-+    struct proc *p;
+-+    int doesProcExist, pidFound;
+-+    struct proc *curproc = myproc();
+-+    acquire(&ptable.lock);
+-+    for (;;) {
+-+        // Scan through table looking for exited children.
+-+        doesProcExist = 0;
+-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+//            if(p->parent != curproc)
+-+//                continue;
+-+
+-+            if (p->pid != pidBeingSearchedFor)
+-+                continue;
+-+
+-+            doesProcExist = 1;
+-+            if (p->state == ZOMBIE) {
+-+                // Found one.
+-+                pidFound = p->pid;
+-+                kfree(p->kstack);
+-+                p->kstack = 0;
+-+                freevm(p->pgdir);
+-+                p->pid = 0;
+-+                p->parent = 0;
+-+                p->name[0] = 0;
+-+                p->killed = 0;
+-+                p->state = UNUSED;
+-+                release(&ptable.lock);
+-+                if (status != NULL)
+-+                    *status = p->status;
+-+                return pidFound;
+-+            }
+-+        }
+-+
+-+//        // No point waiting if we don't have any children.
+-+//        if(!havekids || curproc->killed){
+-+//            release(&ptable.lock);
+-+//            return -1;
+-+//        }
+-+
+-+        if (!doesProcExist || curproc->killed) {
+-+            release(&ptable.lock);
+-+            return -1;
+-+        }
+-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+-+    }
+- }
+- 
+- //PAGEBREAK: 42
+-@@ -320,39 +372,38 @@ wait(void)
+- //  - eventually that process transfers control
+- //      via swtch back to the scheduler.
+- void
+--scheduler(void)
+--{
+--  struct proc *p;
+--  struct cpu *c = mycpu();
+--  c->proc = 0;
+--  
+--  for(;;){
+--    // Enable interrupts on this processor.
+--    sti();
+--
+--    // Loop over process table looking for process to run.
+--    acquire(&ptable.lock);
+--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--      if(p->state != RUNNABLE)
+--        continue;
+--
+--      // Switch to chosen process.  It is the process's job
+--      // to release ptable.lock and then reacquire it
+--      // before jumping back to us.
+--      c->proc = p;
+--      switchuvm(p);
+--      p->state = RUNNING;
+--
+--      swtch(&(c->scheduler), p->context);
+--      switchkvm();
+--
+--      // Process is done running for now.
+--      // It should have changed its p->state before coming back.
+--      c->proc = 0;
+--    }
+--    release(&ptable.lock);
+-+scheduler(void) {
+-+    struct proc *p;
+-+    struct cpu *c = mycpu();
+-+    c->proc = 0;
+-+
+-+    for (;;) {
+-+        // Enable interrupts on this processor.
+-+        sti();
+-+
+-+        // Loop over process table looking for process to run.
+-+        acquire(&ptable.lock);
+-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+            if (p->state != RUNNABLE)
+-+                continue;
+-+
+-+            // Switch to chosen process.  It is the process's job
+-+            // to release ptable.lock and then reacquire it
+-+            // before jumping back to us.
+-+            c->proc = p;
+-+            switchuvm(p);
+-+            p->state = RUNNING;
+-+
+-+            swtch(&(c->scheduler), p->context);
+-+            switchkvm();
+-+
+-+            // Process is done running for now.
+-+            // It should have changed its p->state before coming back.
+-+            c->proc = 0;
+-+        }
+-+        release(&ptable.lock);
+- 
+--  }
+-+    }
+- }
+- 
+- // Enter scheduler.  Must hold only ptable.lock
+-@@ -363,137 +414,130 @@ scheduler(void)
+- // break in the few places where a lock is held but
+- // there's no process.
+- void
+--sched(void)
+--{
+--  int intena;
+--  struct proc *p = myproc();
+--
+--  if(!holding(&ptable.lock))
+--    panic("sched ptable.lock");
+--  if(mycpu()->ncli != 1)
+--    panic("sched locks");
+--  if(p->state == RUNNING)
+--    panic("sched running");
+--  if(readeflags()&FL_IF)
+--    panic("sched interruptible");
+--  intena = mycpu()->intena;
+--  swtch(&p->context, mycpu()->scheduler);
+--  mycpu()->intena = intena;
+-+sched(void) {
+-+    int intena;
+-+    struct proc *p = myproc();
+-+
+-+    if (!holding(&ptable.lock))
+-+        panic("sched ptable.lock");
+-+    if (mycpu()->ncli != 1)
+-+        panic("sched locks");
+-+    if (p->state == RUNNING)
+-+        panic("sched running");
+-+    if (readeflags() & FL_IF)
+-+        panic("sched interruptible");
+-+    intena = mycpu()->intena;
+-+    swtch(&p->context, mycpu()->scheduler);
+-+    mycpu()->intena = intena;
+- }
+- 
+- // Give up the CPU for one scheduling round.
+- void
+--yield(void)
+--{
+--  acquire(&ptable.lock);  //DOC: yieldlock
+--  myproc()->state = RUNNABLE;
+--  sched();
+--  release(&ptable.lock);
+-+yield(void) {
+-+    acquire(&ptable.lock);  //DOC: yieldlock
+-+    myproc()->state = RUNNABLE;
+-+    sched();
+-+    release(&ptable.lock);
+- }
+- 
+- // A fork child's very first scheduling by scheduler()
+- // will swtch here.  "Return" to user space.
+- void
+--forkret(void)
+--{
+--  static int first = 1;
+--  // Still holding ptable.lock from scheduler.
+--  release(&ptable.lock);
+--
+--  if (first) {
+--    // Some initialization functions must be run in the context
+--    // of a regular process (e.g., they call sleep), and thus cannot
+--    // be run from main().
+--    first = 0;
+--    iinit(ROOTDEV);
+--    initlog(ROOTDEV);
+--  }
+--
+--  // Return to "caller", actually trapret (see allocproc).
+-+forkret(void) {
+-+    static int first = 1;
+-+    // Still holding ptable.lock from scheduler.
+-+    release(&ptable.lock);
+-+
+-+    if (first) {
+-+        // Some initialization functions must be run in the context
+-+        // of a regular process (e.g., they call sleep), and thus cannot
+-+        // be run from main().
+-+        first = 0;
+-+        iinit(ROOTDEV);
+-+        initlog(ROOTDEV);
+-+    }
+-+
+-+    // Return to "caller", actually trapret (see allocproc).
+- }
+- 
+- // Atomically release lock and sleep on chan.
+- // Reacquires lock when awakened.
+- void
+--sleep(void *chan, struct spinlock *lk)
+--{
+--  struct proc *p = myproc();
+--  
+--  if(p == 0)
+--    panic("sleep");
+--
+--  if(lk == 0)
+--    panic("sleep without lk");
+--
+--  // Must acquire ptable.lock in order to
+--  // change p->state and then call sched.
+--  // Once we hold ptable.lock, we can be
+--  // guaranteed that we won't miss any wakeup
+--  // (wakeup runs with ptable.lock locked),
+--  // so it's okay to release lk.
+--  if(lk != &ptable.lock){  //DOC: sleeplock0
+--    acquire(&ptable.lock);  //DOC: sleeplock1
+--    release(lk);
+--  }
+--  // Go to sleep.
+--  p->chan = chan;
+--  p->state = SLEEPING;
+--
+--  sched();
+--
+--  // Tidy up.
+--  p->chan = 0;
+--
+--  // Reacquire original lock.
+--  if(lk != &ptable.lock){  //DOC: sleeplock2
+--    release(&ptable.lock);
+--    acquire(lk);
+--  }
+-+sleep(void *chan, struct spinlock *lk) {
+-+    struct proc *p = myproc();
+-+
+-+    if (p == 0)
+-+        panic("sleep");
+-+
+-+    if (lk == 0)
+-+        panic("sleep without lk");
+-+
+-+    // Must acquire ptable.lock in order to
+-+    // change p->state and then call sched.
+-+    // Once we hold ptable.lock, we can be
+-+    // guaranteed that we won't miss any wakeup
+-+    // (wakeup runs with ptable.lock locked),
+-+    // so it's okay to release lk.
+-+    if (lk != &ptable.lock) {  //DOC: sleeplock0
+-+        acquire(&ptable.lock);  //DOC: sleeplock1
+-+        release(lk);
+-+    }
+-+    // Go to sleep.
+-+    p->chan = chan;
+-+    p->state = SLEEPING;
+-+
+-+    sched();
+-+
+-+    // Tidy up.
+-+    p->chan = 0;
+-+
+-+    // Reacquire original lock.
+-+    if (lk != &ptable.lock) {  //DOC: sleeplock2
+-+        release(&ptable.lock);
+-+        acquire(lk);
+-+    }
+- }
+- 
+- //PAGEBREAK!
+- // Wake up all processes sleeping on chan.
+- // The ptable lock must be held.
+- static void
+--wakeup1(void *chan)
+--{
+--  struct proc *p;
+-+wakeup1(void *chan) {
+-+    struct proc *p;
+- 
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+--    if(p->state == SLEEPING && p->chan == chan)
+--      p->state = RUNNABLE;
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-+        if (p->state == SLEEPING && p->chan == chan)
+-+            p->state = RUNNABLE;
+- }
+- 
+- // Wake up all processes sleeping on chan.
+- void
+--wakeup(void *chan)
+--{
+--  acquire(&ptable.lock);
+--  wakeup1(chan);
+--  release(&ptable.lock);
+-+wakeup(void *chan) {
+-+    acquire(&ptable.lock);
+-+    wakeup1(chan);
+-+    release(&ptable.lock);
+- }
+- 
+- // Kill the process with the given pid.
+- // Process won't exit until it returns
+- // to user space (see trap in trap.c).
+- int
+--kill(int pid)
+--{
+--  struct proc *p;
+--
+--  acquire(&ptable.lock);
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--    if(p->pid == pid){
+--      p->killed = 1;
+--      // Wake process from sleep if necessary.
+--      if(p->state == SLEEPING)
+--        p->state = RUNNABLE;
+--      release(&ptable.lock);
+--      return 0;
+-+kill(int pid) {
+-+    struct proc *p;
+-+
+-+    acquire(&ptable.lock);
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+        if (p->pid == pid) {
+-+            p->killed = 1;
+-+            // Wake process from sleep if necessary.
+-+            if (p->state == SLEEPING)
+-+                p->state = RUNNABLE;
+-+            release(&ptable.lock);
+-+            return 0;
+-+        }
+-     }
+--  }
+--  release(&ptable.lock);
+--  return -1;
+-+    release(&ptable.lock);
+-+    return -1;
+- }
+- 
+- //PAGEBREAK: 36
+-@@ -501,34 +545,33 @@ kill(int pid)
+- // Runs when user types ^P on console.
+- // No lock to avoid wedging a stuck machine further.
+- void
+--procdump(void)
+--{
+--  static char *states[] = {
+--  [UNUSED]    "unused",
+--  [EMBRYO]    "embryo",
+--  [SLEEPING]  "sleep ",
+--  [RUNNABLE]  "runble",
+--  [RUNNING]   "run   ",
+--  [ZOMBIE]    "zombie"
+--  };
+--  int i;
+--  struct proc *p;
+--  char *state;
+--  uint pc[10];
+--
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--    if(p->state == UNUSED)
+--      continue;
+--    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+--      state = states[p->state];
+--    else
+--      state = "???";
+--    cprintf("%d %s %s", p->pid, state, p->name);
+--    if(p->state == SLEEPING){
+--      getcallerpcs((uint*)p->context->ebp+2, pc);
+--      for(i=0; i<10 && pc[i] != 0; i++)
+--        cprintf(" %p", pc[i]);
+-+procdump(void) {
+-+    static char *states[] = {
+-+            [UNUSED]    "unused",
+-+            [EMBRYO]    "embryo",
+-+            [SLEEPING]  "sleep ",
+-+            [RUNNABLE]  "runble",
+-+            [RUNNING]   "run   ",
+-+            [ZOMBIE]    "zombie"
+-+    };
+-+    int i;
+-+    struct proc *p;
+-+    char *state;
+-+    uint pc[10];
+-+
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+        if (p->state == UNUSED)
+-+            continue;
+-+        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
+-+            state = states[p->state];
+-+        else
+-+            state = "???";
+-+        cprintf("%d %s %s", p->pid, state, p->name);
+-+        if (p->state == SLEEPING) {
+-+            getcallerpcs((uint *) p->context->ebp + 2, pc);
+-+            for (i = 0; i < 10 && pc[i] != 0; i++)
+-+                cprintf(" %p", pc[i]);
+-+        }
+-+        cprintf("\n");
+-     }
+--    cprintf("\n");
+--  }
+- }
+-diff --git a/proc.h b/proc.h
+-index 1647114..a06b921 100644
+---- a/proc.h
+-+++ b/proc.h
+-@@ -49,6 +49,7 @@ struct proc {
+-   struct file *ofile[NOFILE];  // Open files
+-   struct inode *cwd;           // Current directory
+-   char name[16];               // Process name (debugging)
+-+  int status;                  // Exit status
+- };
+- 
+- // Process memory is laid out contiguously, low addresses first:
+-diff --git a/rm.c b/rm.c
+-index 4fd33c8..1e6daec 100644
+---- a/rm.c
+-+++ b/rm.c
+-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
+- 
+-   if(argc < 2){
+-     printf(2, "Usage: rm files...\n");
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
+-     }
+-   }
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/runoff b/runoff
+-old mode 100755
+-new mode 100644
+-diff --git a/runoff1 b/runoff1
+-old mode 100755
+-new mode 100644
+-diff --git a/sh.c b/sh.c
+-index 054bab9..ca2ae37 100644
+---- a/sh.c
+-+++ b/sh.c
+-@@ -65,7 +65,7 @@ runcmd(struct cmd *cmd)
+-   struct redircmd *rcmd;
+- 
+-   if(cmd == 0)
+--    exit();
+-+    exit(1);
+- 
+-   switch(cmd->type){
+-   default:
+-@@ -74,7 +74,7 @@ runcmd(struct cmd *cmd)
+-   case EXEC:
+-     ecmd = (struct execcmd*)cmd;
+-     if(ecmd->argv[0] == 0)
+--      exit();
+-+      exit(2);
+-     exec(ecmd->argv[0], ecmd->argv);
+-     printf(2, "exec %s failed\n", ecmd->argv[0]);
+-     break;
+-@@ -84,7 +84,7 @@ runcmd(struct cmd *cmd)
+-     close(rcmd->fd);
+-     if(open(rcmd->file, rcmd->mode) < 0){
+-       printf(2, "open %s failed\n", rcmd->file);
+--      exit();
+-+      exit(6);
+-     }
+-     runcmd(rcmd->cmd);
+-     break;
+-@@ -93,7 +93,7 @@ runcmd(struct cmd *cmd)
+-     lcmd = (struct listcmd*)cmd;
+-     if(fork1() == 0)
+-       runcmd(lcmd->left);
+--    wait();
+-+    wait(NULL);
+-     runcmd(lcmd->right);
+-     break;
+- 
+-@@ -117,8 +117,8 @@ runcmd(struct cmd *cmd)
+-     }
+-     close(p[0]);
+-     close(p[1]);
+--    wait();
+--    wait();
+-+    wait(NULL);
+-+    wait(NULL);
+-     break;
+- 
+-   case BACK:
+-@@ -127,7 +127,7 @@ runcmd(struct cmd *cmd)
+-       runcmd(bcmd->cmd);
+-     break;
+-   }
+--  exit();
+-+  exit(3);
+- }
+- 
+- int
+-@@ -166,16 +166,16 @@ main(void)
+-     }
+-     if(fork1() == 0)
+-       runcmd(parsecmd(buf));
+--    wait();
+-+    wait(NULL);
+-   }
+--  exit();
+-+  exit(0);
+- }
+- 
+- void
+- panic(char *s)
+- {
+-   printf(2, "%s\n", s);
+--  exit();
+-+  exit(5);
+- }
+- 
+- int
+-diff --git a/show1 b/show1
+-old mode 100755
+-new mode 100644
+-diff --git a/sign.pl b/sign.pl
+-old mode 100755
+-new mode 100644
+-diff --git a/spinp b/spinp
+-old mode 100755
+-new mode 100644
+-diff --git a/stressfs.c b/stressfs.c
+-index c0a4743..46e0e66 100644
+---- a/stressfs.c
+-+++ b/stressfs.c
+-@@ -43,7 +43,7 @@ main(int argc, char *argv[])
+-     read(fd, data, sizeof(data));
+-   close(fd);
+- 
+--  wait();
+-+  wait(NULL);
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/syscall.c b/syscall.c
+-index ee85261..41a8c3c 100644
+---- a/syscall.c
+-+++ b/syscall.c
+-@@ -101,6 +101,7 @@ extern int sys_sbrk(void);
+- extern int sys_sleep(void);
+- extern int sys_unlink(void);
+- extern int sys_wait(void);
+-+extern int sys_waitpid(void);
+- extern int sys_write(void);
+- extern int sys_uptime(void);
+- 
+-@@ -108,6 +109,7 @@ static int (*syscalls[])(void) = {
+- [SYS_fork]    sys_fork,
+- [SYS_exit]    sys_exit,
+- [SYS_wait]    sys_wait,
+-+[SYS_waitpid] sys_waitpid,
+- [SYS_pipe]    sys_pipe,
+- [SYS_read]    sys_read,
+- [SYS_kill]    sys_kill,
+-diff --git a/syscall.h b/syscall.h
+-index bc5f356..374ff05 100644
+---- a/syscall.h
+-+++ b/syscall.h
+-@@ -1,22 +1,23 @@
+- // System call numbers
+--#define SYS_fork    1
+--#define SYS_exit    2
+--#define SYS_wait    3
+--#define SYS_pipe    4
+--#define SYS_read    5
+--#define SYS_kill    6
+--#define SYS_exec    7
+--#define SYS_fstat   8
+--#define SYS_chdir   9
+--#define SYS_dup    10
+--#define SYS_getpid 11
+--#define SYS_sbrk   12
+--#define SYS_sleep  13
+--#define SYS_uptime 14
+--#define SYS_open   15
+--#define SYS_write  16
+--#define SYS_mknod  17
+--#define SYS_unlink 18
+--#define SYS_link   19
+--#define SYS_mkdir  20
+--#define SYS_close  21
+-+#define SYS_fork     1
+-+#define SYS_exit     2
+-+#define SYS_wait     3
+-+#define SYS_pipe     4
+-+#define SYS_read     5
+-+#define SYS_kill     6
+-+#define SYS_exec     7
+-+#define SYS_fstat    8
+-+#define SYS_chdir    9
+-+#define SYS_dup     10
+-+#define SYS_getpid  11
+-+#define SYS_sbrk    12
+-+#define SYS_sleep   13
+-+#define SYS_uptime  14
+-+#define SYS_open    15
+-+#define SYS_write   16
+-+#define SYS_mknod   17
+-+#define SYS_unlink  18
+-+#define SYS_link    19
+-+#define SYS_mkdir   20
+-+#define SYS_close   21
+-+#define SYS_waitpid 22
+-\ No newline at end of file
+-diff --git a/sysproc.c b/sysproc.c
+-index 0686d29..ebccf84 100644
+---- a/sysproc.c
+-+++ b/sysproc.c
+-@@ -14,16 +14,22 @@ sys_fork(void)
+- }
+- 
+- int
+--sys_exit(void)
+-+sys_exit(int status)
+- {
+--  exit();
+-+  exit(status);
+-   return 0;  // not reached
+- }
+- 
+- int
+--sys_wait(void)
+-+sys_wait(int* status)
+- {
+--  return wait();
+-+  return wait(status);
+-+}
+-+
+-+int
+-+sys_waitpid(int pid, int* status, int options)
+-+{
+-+    return waitpid(pid, status, options);
+- }
+- 
+- int
+-diff --git a/trap.c b/trap.c
+-index 41c66eb..432ea5b 100644
+---- a/trap.c
+-+++ b/trap.c
+-@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
+- {
+-   if(tf->trapno == T_SYSCALL){
+-     if(myproc()->killed)
+--      exit();
+-+      exit(4);
+-     myproc()->tf = tf;
+-     syscall();
+-     if(myproc()->killed)
+--      exit();
+-+      exit(3);
+-     return;
+-   }
+- 
+-@@ -98,7 +98,7 @@ trap(struct trapframe *tf)
+-   // (If it is still executing in the kernel, let it keep running
+-   // until it gets to the regular system call return.)
+-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+--    exit();
+-+    exit(2);
+- 
+-   // Force process to give up CPU on clock tick.
+-   // If interrupts were on while locks held, would need to check nlock.
+-@@ -108,5 +108,5 @@ trap(struct trapframe *tf)
+- 
+-   // Check if the process has been killed since we yielded
+-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+--    exit();
+-+    exit(1);
+- }
+-diff --git a/user.h b/user.h
+-index 4f99c52..0931387 100644
+---- a/user.h
+-+++ b/user.h
+-@@ -1,10 +1,13 @@
+-+#include <stddef.h>
+-+
+- struct stat;
+- struct rtcdate;
+- 
+- // system calls
+- int fork(void);
+--int exit(void) __attribute__((noreturn));
+--int wait(void);
+-+int exit(int status) __attribute__((noreturn));
+-+int wait(int* status);
+-+int waitpid(int pid, int* status, int options);
+- int pipe(int*);
+- int write(int, const void*, int);
+- int read(int, void*, int);
+-diff --git a/usertests.c b/usertests.c
+-index a1e97e7..2c2c128 100644
+---- a/usertests.c
+-+++ b/usertests.c
+-@@ -21,19 +21,19 @@ iputtest(void)
+- 
+-   if(mkdir("iputdir") < 0){
+-     printf(stdout, "mkdir failed\n");
+--    exit();
+-+    exit(184);
+-   }
+-   if(chdir("iputdir") < 0){
+-     printf(stdout, "chdir iputdir failed\n");
+--    exit();
+-+    exit(183);
+-   }
+-   if(unlink("../iputdir") < 0){
+-     printf(stdout, "unlink ../iputdir failed\n");
+--    exit();
+-+    exit(182);
+-   }
+-   if(chdir("/") < 0){
+-     printf(stdout, "chdir / failed\n");
+--    exit();
+-+    exit(181);
+-   }
+-   printf(stdout, "iput test ok\n");
+- }
+-@@ -49,24 +49,24 @@ exitiputtest(void)
+-   pid = fork();
+-   if(pid < 0){
+-     printf(stdout, "fork failed\n");
+--    exit();
+-+    exit(180);
+-   }
+-   if(pid == 0){
+-     if(mkdir("iputdir") < 0){
+-       printf(stdout, "mkdir failed\n");
+--      exit();
+-+      exit(179);
+-     }
+-     if(chdir("iputdir") < 0){
+-       printf(stdout, "child chdir failed\n");
+--      exit();
+-+      exit(178);
+-     }
+-     if(unlink("../iputdir") < 0){
+-       printf(stdout, "unlink ../iputdir failed\n");
+--      exit();
+-+      exit(177);
+-     }
+--    exit();
+-+    exit(176);
+-   }
+--  wait();
+-+  wait(NULL);
+-   printf(stdout, "exitiput test ok\n");
+- }
+- 
+-@@ -89,27 +89,27 @@ openiputtest(void)
+-   printf(stdout, "openiput test\n");
+-   if(mkdir("oidir") < 0){
+-     printf(stdout, "mkdir oidir failed\n");
+--    exit();
+-+    exit(175);
+-   }
+-   pid = fork();
+-   if(pid < 0){
+-     printf(stdout, "fork failed\n");
+--    exit();
+-+    exit(174);
+-   }
+-   if(pid == 0){
+-     int fd = open("oidir", O_RDWR);
+-     if(fd >= 0){
+-       printf(stdout, "open directory for write succeeded\n");
+--      exit();
+-+      exit(0);
+-     }
+--    exit();
+-+    exit(172);
+-   }
+-   sleep(1);
+-   if(unlink("oidir") != 0){
+-     printf(stdout, "unlink failed\n");
+--    exit();
+-+    exit(171);
+-   }
+--  wait();
+-+  wait(NULL);
+-   printf(stdout, "openiput test ok\n");
+- }
+- 
+-@@ -124,13 +124,13 @@ opentest(void)
+-   fd = open("echo", 0);
+-   if(fd < 0){
+-     printf(stdout, "open echo failed!\n");
+--    exit();
+-+    exit(170);
+-   }
+-   close(fd);
+-   fd = open("doesnotexist", 0);
+-   if(fd >= 0){
+-     printf(stdout, "open doesnotexist succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   printf(stdout, "open test ok\n");
+- }
+-@@ -147,16 +147,16 @@ writetest(void)
+-     printf(stdout, "creat small succeeded; ok\n");
+-   } else {
+-     printf(stdout, "error: creat small failed!\n");
+--    exit();
+-+    exit(168);
+-   }
+-   for(i = 0; i < 100; i++){
+-     if(write(fd, "aaaaaaaaaa", 10) != 10){
+-       printf(stdout, "error: write aa %d new file failed\n", i);
+--      exit();
+-+      exit(167);
+-     }
+-     if(write(fd, "bbbbbbbbbb", 10) != 10){
+-       printf(stdout, "error: write bb %d new file failed\n", i);
+--      exit();
+-+      exit(166);
+-     }
+-   }
+-   printf(stdout, "writes ok\n");
+-@@ -166,20 +166,20 @@ writetest(void)
+-     printf(stdout, "open small succeeded ok\n");
+-   } else {
+-     printf(stdout, "error: open small failed!\n");
+--    exit();
+-+    exit(165);
+-   }
+-   i = read(fd, buf, 2000);
+-   if(i == 2000){
+-     printf(stdout, "read succeeded ok\n");
+-   } else {
+-     printf(stdout, "read failed\n");
+--    exit();
+-+    exit(164);
+-   }
+-   close(fd);
+- 
+-   if(unlink("small") < 0){
+-     printf(stdout, "unlink small failed\n");
+--    exit();
+-+    exit(163);
+-   }
+-   printf(stdout, "small file test ok\n");
+- }
+-@@ -194,14 +194,14 @@ writetest1(void)
+-   fd = open("big", O_CREATE|O_RDWR);
+-   if(fd < 0){
+-     printf(stdout, "error: creat big failed!\n");
+--    exit();
+-+    exit(162);
+-   }
+- 
+-   for(i = 0; i < MAXFILE; i++){
+-     ((int*)buf)[0] = i;
+-     if(write(fd, buf, 512) != 512){
+-       printf(stdout, "error: write big file failed\n", i);
+--      exit();
+-+      exit(161);
+-     }
+-   }
+- 
+-@@ -210,7 +210,7 @@ writetest1(void)
+-   fd = open("big", O_RDONLY);
+-   if(fd < 0){
+-     printf(stdout, "error: open big failed!\n");
+--    exit();
+-+    exit(160);
+-   }
+- 
+-   n = 0;
+-@@ -219,24 +219,24 @@ writetest1(void)
+-     if(i == 0){
+-       if(n == MAXFILE - 1){
+-         printf(stdout, "read only %d blocks from big", n);
+--        exit();
+-+        exit(159);
+-       }
+-       break;
+-     } else if(i != 512){
+-       printf(stdout, "read failed %d\n", i);
+--      exit();
+-+      exit(158);
+-     }
+-     if(((int*)buf)[0] != n){
+-       printf(stdout, "read content of block %d is %d\n",
+-              n, ((int*)buf)[0]);
+--      exit();
+-+      exit(157);
+-     }
+-     n++;
+-   }
+-   close(fd);
+-   if(unlink("big") < 0){
+-     printf(stdout, "unlink big failed\n");
+--    exit();
+-+    exit(156);
+-   }
+-   printf(stdout, "big files ok\n");
+- }
+-@@ -270,22 +270,22 @@ void dirtest(void)
+- 
+-   if(mkdir("dir0") < 0){
+-     printf(stdout, "mkdir failed\n");
+--    exit();
+-+    exit(155);
+-   }
+- 
+-   if(chdir("dir0") < 0){
+-     printf(stdout, "chdir dir0 failed\n");
+--    exit();
+-+    exit(154);
+-   }
+- 
+-   if(chdir("..") < 0){
+-     printf(stdout, "chdir .. failed\n");
+--    exit();
+-+    exit(153);
+-   }
+- 
+-   if(unlink("dir0") < 0){
+-     printf(stdout, "unlink dir0 failed\n");
+--    exit();
+-+    exit(152);
+-   }
+-   printf(stdout, "mkdir test ok\n");
+- }
+-@@ -296,7 +296,7 @@ exectest(void)
+-   printf(stdout, "exec test\n");
+-   if(exec("echo", echoargv) < 0){
+-     printf(stdout, "exec echo failed\n");
+--    exit();
+-+    exit(151);
+-   }
+- }
+- 
+-@@ -310,7 +310,7 @@ pipe1(void)
+- 
+-   if(pipe(fds) != 0){
+-     printf(1, "pipe() failed\n");
+--    exit();
+-+    exit(150);
+-   }
+-   pid = fork();
+-   seq = 0;
+-@@ -321,10 +321,10 @@ pipe1(void)
+-         buf[i] = seq++;
+-       if(write(fds[1], buf, 1033) != 1033){
+-         printf(1, "pipe1 oops 1\n");
+--        exit();
+-+        exit(149);
+-       }
+-     }
+--    exit();
+-+    exit(148);
+-   } else if(pid > 0){
+-     close(fds[1]);
+-     total = 0;
+-@@ -343,13 +343,13 @@ pipe1(void)
+-     }
+-     if(total != 5 * 1033){
+-       printf(1, "pipe1 oops 3 total %d\n", total);
+--      exit();
+-+      exit(147);
+-     }
+-     close(fds[0]);
+--    wait();
+-+    wait(NULL);
+-   } else {
+-     printf(1, "fork() failed\n");
+--    exit();
+-+    exit(146);
+-   }
+-   printf(1, "pipe1 ok\n");
+- }
+-@@ -394,9 +394,9 @@ preempt(void)
+-   kill(pid2);
+-   kill(pid3);
+-   printf(1, "wait... ");
+--  wait();
+--  wait();
+--  wait();
+-+  wait(NULL);
+-+  wait(NULL);
+-+  wait(NULL);
+-   printf(1, "preempt ok\n");
+- }
+- 
+-@@ -413,12 +413,12 @@ exitwait(void)
+-       return;
+-     }
+-     if(pid){
+--      if(wait() != pid){
+-+      if(wait(NULL) != pid){
+-         printf(1, "wait wrong pid\n");
+-         return;
+-       }
+-     } else {
+--      exit();
+-+      exit(145);
+-     }
+-   }
+-   printf(1, "exitwait ok\n");
+-@@ -447,13 +447,13 @@ mem(void)
+-     if(m1 == 0){
+-       printf(1, "couldn't allocate mem?!!\n");
+-       kill(ppid);
+--      exit();
+-+      exit(144);
+-     }
+-     free(m1);
+-     printf(1, "mem ok\n");
+--    exit();
+-+    exit(0);
+-   } else {
+--    wait();
+-+    wait(NULL);
+-   }
+- }
+- 
+-@@ -484,9 +484,9 @@ sharedfd(void)
+-     }
+-   }
+-   if(pid == 0)
+--    exit();
+-+    exit(142);
+-   else
+--    wait();
+-+    wait(NULL);
+-   close(fd);
+-   fd = open("sharedfd", 0);
+-   if(fd < 0){
+-@@ -508,7 +508,7 @@ sharedfd(void)
+-     printf(1, "sharedfd ok\n");
+-   } else {
+-     printf(1, "sharedfd oops %d %d\n", nc, np);
+--    exit();
+-+    exit(141);
+-   }
+- }
+- 
+-@@ -530,29 +530,29 @@ fourfiles(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "fork failed\n");
+--      exit();
+-+      exit(140);
+-     }
+- 
+-     if(pid == 0){
+-       fd = open(fname, O_CREATE | O_RDWR);
+-       if(fd < 0){
+-         printf(1, "create failed\n");
+--        exit();
+-+        exit(139);
+-       }
+- 
+-       memset(buf, '0'+pi, 512);
+-       for(i = 0; i < 12; i++){
+-         if((n = write(fd, buf, 500)) != 500){
+-           printf(1, "write failed %d\n", n);
+--          exit();
+-+          exit(138);
+-         }
+-       }
+--      exit();
+-+      exit(137);
+-     }
+-   }
+- 
+-   for(pi = 0; pi < 4; pi++){
+--    wait();
+-+    wait(NULL);
+-   }
+- 
+-   for(i = 0; i < 2; i++){
+-@@ -563,7 +563,7 @@ fourfiles(void)
+-       for(j = 0; j < n; j++){
+-         if(buf[j] != '0'+i){
+-           printf(1, "wrong char\n");
+--          exit();
+-+          exit(136);
+-         }
+-       }
+-       total += n;
+-@@ -571,7 +571,7 @@ fourfiles(void)
+-     close(fd);
+-     if(total != 12*500){
+-       printf(1, "wrong length %d\n", total);
+--      exit();
+-+      exit(135);
+-     }
+-     unlink(fname);
+-   }
+-@@ -593,7 +593,7 @@ createdelete(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "fork failed\n");
+--      exit();
+-+      exit(134);
+-     }
+- 
+-     if(pid == 0){
+-@@ -604,23 +604,23 @@ createdelete(void)
+-         fd = open(name, O_CREATE | O_RDWR);
+-         if(fd < 0){
+-           printf(1, "create failed\n");
+--          exit();
+-+          exit(133);
+-         }
+-         close(fd);
+-         if(i > 0 && (i % 2 ) == 0){
+-           name[1] = '0' + (i / 2);
+-           if(unlink(name) < 0){
+-             printf(1, "unlink failed\n");
+--            exit();
+-+            exit(132);
+-           }
+-         }
+-       }
+--      exit();
+-+      exit(131);
+-     }
+-   }
+- 
+-   for(pi = 0; pi < 4; pi++){
+--    wait();
+-+    wait(NULL);
+-   }
+- 
+-   name[0] = name[1] = name[2] = 0;
+-@@ -631,10 +631,10 @@ createdelete(void)
+-       fd = open(name, 0);
+-       if((i == 0 || i >= N/2) && fd < 0){
+-         printf(1, "oops createdelete %s didn't exist\n", name);
+--        exit();
+-+        exit(130);
+-       } else if((i >= 1 && i < N/2) && fd >= 0){
+-         printf(1, "oops createdelete %s did exist\n", name);
+--        exit();
+-+        exit(129);
+-       }
+-       if(fd >= 0)
+-         close(fd);
+-@@ -662,7 +662,7 @@ unlinkread(void)
+-   fd = open("unlinkread", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create unlinkread failed\n");
+--    exit();
+-+    exit(128);
+-   }
+-   write(fd, "hello", 5);
+-   close(fd);
+-@@ -670,11 +670,11 @@ unlinkread(void)
+-   fd = open("unlinkread", O_RDWR);
+-   if(fd < 0){
+-     printf(1, "open unlinkread failed\n");
+--    exit();
+-+    exit(127);
+-   }
+-   if(unlink("unlinkread") != 0){
+-     printf(1, "unlink unlinkread failed\n");
+--    exit();
+-+    exit(126);
+-   }
+- 
+-   fd1 = open("unlinkread", O_CREATE | O_RDWR);
+-@@ -683,15 +683,15 @@ unlinkread(void)
+- 
+-   if(read(fd, buf, sizeof(buf)) != 5){
+-     printf(1, "unlinkread read failed");
+--    exit();
+-+    exit(125);
+-   }
+-   if(buf[0] != 'h'){
+-     printf(1, "unlinkread wrong data\n");
+--    exit();
+-+    exit(124);
+-   }
+-   if(write(fd, buf, 10) != 10){
+-     printf(1, "unlinkread write failed\n");
+--    exit();
+-+    exit(123);
+-   }
+-   close(fd);
+-   unlink("unlinkread");
+-@@ -711,50 +711,50 @@ linktest(void)
+-   fd = open("lf1", O_CREATE|O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create lf1 failed\n");
+--    exit();
+-+    exit(122);
+-   }
+-   if(write(fd, "hello", 5) != 5){
+-     printf(1, "write lf1 failed\n");
+--    exit();
+-+    exit(121);
+-   }
+-   close(fd);
+- 
+-   if(link("lf1", "lf2") < 0){
+-     printf(1, "link lf1 lf2 failed\n");
+--    exit();
+-+    exit(120);
+-   }
+-   unlink("lf1");
+- 
+-   if(open("lf1", 0) >= 0){
+-     printf(1, "unlinked lf1 but it is still there!\n");
+--    exit();
+-+    exit(119);
+-   }
+- 
+-   fd = open("lf2", 0);
+-   if(fd < 0){
+-     printf(1, "open lf2 failed\n");
+--    exit();
+-+    exit(118);
+-   }
+-   if(read(fd, buf, sizeof(buf)) != 5){
+-     printf(1, "read lf2 failed\n");
+--    exit();
+-+    exit(117);
+-   }
+-   close(fd);
+- 
+-   if(link("lf2", "lf2") >= 0){
+-     printf(1, "link lf2 lf2 succeeded! oops\n");
+--    exit();
+-+    exit(116);
+-   }
+- 
+-   unlink("lf2");
+-   if(link("lf2", "lf1") >= 0){
+-     printf(1, "link non-existant succeeded! oops\n");
+--    exit();
+-+    exit(115);
+-   }
+- 
+-   if(link(".", "lf1") >= 0){
+-     printf(1, "link . lf1 succeeded! oops\n");
+--    exit();
+-+    exit(114);
+-   }
+- 
+-   printf(1, "linktest ok\n");
+-@@ -787,14 +787,14 @@ concreate(void)
+-       fd = open(file, O_CREATE | O_RDWR);
+-       if(fd < 0){
+-         printf(1, "concreate create %s failed\n", file);
+--        exit();
+-+        exit(113);
+-       }
+-       close(fd);
+-     }
+-     if(pid == 0)
+--      exit();
+-+      exit(112);
+-     else
+--      wait();
+-+      wait(NULL);
+-   }
+- 
+-   memset(fa, 0, sizeof(fa));
+-@@ -807,11 +807,11 @@ concreate(void)
+-       i = de.name[1] - '0';
+-       if(i < 0 || i >= sizeof(fa)){
+-         printf(1, "concreate weird file %s\n", de.name);
+--        exit();
+-+        exit(111);
+-       }
+-       if(fa[i]){
+-         printf(1, "concreate duplicate file %s\n", de.name);
+--        exit();
+-+        exit(110);
+-       }
+-       fa[i] = 1;
+-       n++;
+-@@ -821,7 +821,7 @@ concreate(void)
+- 
+-   if(n != 40){
+-     printf(1, "concreate not enough files in directory listing\n");
+--    exit();
+-+    exit(109);
+-   }
+- 
+-   for(i = 0; i < 40; i++){
+-@@ -829,7 +829,7 @@ concreate(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "fork failed\n");
+--      exit();
+-+      exit(108);
+-     }
+-     if(((i % 3) == 0 && pid == 0) ||
+-        ((i % 3) == 1 && pid != 0)){
+-@@ -844,9 +844,9 @@ concreate(void)
+-       unlink(file);
+-     }
+-     if(pid == 0)
+--      exit();
+-+      exit(107);
+-     else
+--      wait();
+-+      wait(NULL);
+-   }
+- 
+-   printf(1, "concreate ok\n");
+-@@ -865,7 +865,7 @@ linkunlink()
+-   pid = fork();
+-   if(pid < 0){
+-     printf(1, "fork failed\n");
+--    exit();
+-+    exit(106);
+-   }
+- 
+-   unsigned int x = (pid ? 1 : 97);
+-@@ -881,9 +881,9 @@ linkunlink()
+-   }
+- 
+-   if(pid)
+--    wait();
+-+    wait(NULL);
+-   else
+--    exit();
+-+    exit(105);
+- 
+-   printf(1, "linkunlink ok\n");
+- }
+-@@ -901,7 +901,7 @@ bigdir(void)
+-   fd = open("bd", O_CREATE);
+-   if(fd < 0){
+-     printf(1, "bigdir create failed\n");
+--    exit();
+-+    exit(104);
+-   }
+-   close(fd);
+- 
+-@@ -912,7 +912,7 @@ bigdir(void)
+-     name[3] = '\0';
+-     if(link("bd", name) != 0){
+-       printf(1, "bigdir link failed\n");
+--      exit();
+-+      exit(103);
+-     }
+-   }
+- 
+-@@ -924,7 +924,7 @@ bigdir(void)
+-     name[3] = '\0';
+-     if(unlink(name) != 0){
+-       printf(1, "bigdir unlink failed");
+--      exit();
+-+      exit(102);
+-     }
+-   }
+- 
+-@@ -941,31 +941,31 @@ subdir(void)
+-   unlink("ff");
+-   if(mkdir("dd") != 0){
+-     printf(1, "subdir mkdir dd failed\n");
+--    exit();
+-+    exit(101);
+-   }
+- 
+-   fd = open("dd/ff", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create dd/ff failed\n");
+--    exit();
+-+    exit(100);
+-   }
+-   write(fd, "ff", 2);
+-   close(fd);
+- 
+-   if(unlink("dd") >= 0){
+-     printf(1, "unlink dd (non-empty dir) succeeded!\n");
+--    exit();
+-+    exit(99);
+-   }
+- 
+-   if(mkdir("/dd/dd") != 0){
+-     printf(1, "subdir mkdir dd/dd failed\n");
+--    exit();
+-+    exit(98);
+-   }
+- 
+-   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create dd/dd/ff failed\n");
+--    exit();
+-+    exit(97);
+-   }
+-   write(fd, "FF", 2);
+-   close(fd);
+-@@ -973,142 +973,142 @@ subdir(void)
+-   fd = open("dd/dd/../ff", 0);
+-   if(fd < 0){
+-     printf(1, "open dd/dd/../ff failed\n");
+--    exit();
+-+    exit(96);
+-   }
+-   cc = read(fd, buf, sizeof(buf));
+-   if(cc != 2 || buf[0] != 'f'){
+-     printf(1, "dd/dd/../ff wrong content\n");
+--    exit();
+-+    exit(95);
+-   }
+-   close(fd);
+- 
+-   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+-     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+--    exit();
+-+    exit(94);
+-   }
+- 
+-   if(unlink("dd/dd/ff") != 0){
+-     printf(1, "unlink dd/dd/ff failed\n");
+--    exit();
+-+    exit(93);
+-   }
+-   if(open("dd/dd/ff", O_RDONLY) >= 0){
+-     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+--    exit();
+-+    exit(92);
+-   }
+- 
+-   if(chdir("dd") != 0){
+-     printf(1, "chdir dd failed\n");
+--    exit();
+-+    exit(91);
+-   }
+-   if(chdir("dd/../../dd") != 0){
+-     printf(1, "chdir dd/../../dd failed\n");
+--    exit();
+-+    exit(90);
+-   }
+-   if(chdir("dd/../../../dd") != 0){
+-     printf(1, "chdir dd/../../dd failed\n");
+--    exit();
+-+    exit(89);
+-   }
+-   if(chdir("./..") != 0){
+-     printf(1, "chdir ./.. failed\n");
+--    exit();
+-+    exit(88);
+-   }
+- 
+-   fd = open("dd/dd/ffff", 0);
+-   if(fd < 0){
+-     printf(1, "open dd/dd/ffff failed\n");
+--    exit();
+-+    exit(87);
+-   }
+-   if(read(fd, buf, sizeof(buf)) != 2){
+-     printf(1, "read dd/dd/ffff wrong len\n");
+--    exit();
+-+    exit(86);
+-   }
+-   close(fd);
+- 
+-   if(open("dd/dd/ff", O_RDONLY) >= 0){
+-     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+- 
+-   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+-     printf(1, "create dd/ff/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+-     printf(1, "create dd/xx/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd", O_CREATE) >= 0){
+-     printf(1, "create dd succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd", O_RDWR) >= 0){
+-     printf(1, "open dd rdwr succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd", O_WRONLY) >= 0){
+-     printf(1, "open dd wronly succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("dd/ff/ff", "dd/dd/xx") == 0){
+-     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("dd/xx/ff", "dd/dd/xx") == 0){
+-     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("dd/ff", "dd/dd/ffff") == 0){
+-     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dd/ff/ff") == 0){
+-     printf(1, "mkdir dd/ff/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dd/xx/ff") == 0){
+-     printf(1, "mkdir dd/xx/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dd/dd/ffff") == 0){
+-     printf(1, "mkdir dd/dd/ffff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dd/xx/ff") == 0){
+-     printf(1, "unlink dd/xx/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dd/ff/ff") == 0){
+-     printf(1, "unlink dd/ff/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(chdir("dd/ff") == 0){
+-     printf(1, "chdir dd/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(chdir("dd/xx") == 0){
+-     printf(1, "chdir dd/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+- 
+-   if(unlink("dd/dd/ffff") != 0){
+-     printf(1, "unlink dd/dd/ff failed\n");
+--    exit();
+-+    exit(68);
+-   }
+-   if(unlink("dd/ff") != 0){
+-     printf(1, "unlink dd/ff failed\n");
+--    exit();
+-+    exit(67);
+-   }
+-   if(unlink("dd") == 0){
+-     printf(1, "unlink non-empty dd succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dd/dd") < 0){
+-     printf(1, "unlink dd/dd failed\n");
+--    exit();
+-+    exit(65);
+-   }
+-   if(unlink("dd") < 0){
+-     printf(1, "unlink dd failed\n");
+--    exit();
+-+    exit(64);
+-   }
+- 
+-   printf(1, "subdir ok\n");
+-@@ -1127,14 +1127,14 @@ bigwrite(void)
+-     fd = open("bigwrite", O_CREATE | O_RDWR);
+-     if(fd < 0){
+-       printf(1, "cannot create bigwrite\n");
+--      exit();
+-+      exit(63);
+-     }
+-     int i;
+-     for(i = 0; i < 2; i++){
+-       int cc = write(fd, buf, sz);
+-       if(cc != sz){
+-         printf(1, "write(%d) ret %d\n", sz, cc);
+--        exit();
+-+        exit(62);
+-       }
+-     }
+-     close(fd);
+-@@ -1155,13 +1155,13 @@ bigfile(void)
+-   fd = open("bigfile", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "cannot create bigfile");
+--    exit();
+-+    exit(61);
+-   }
+-   for(i = 0; i < 20; i++){
+-     memset(buf, i, 600);
+-     if(write(fd, buf, 600) != 600){
+-       printf(1, "write bigfile failed\n");
+--      exit();
+-+      exit(60);
+-     }
+-   }
+-   close(fd);
+-@@ -1169,31 +1169,31 @@ bigfile(void)
+-   fd = open("bigfile", 0);
+-   if(fd < 0){
+-     printf(1, "cannot open bigfile\n");
+--    exit();
+-+    exit(59);
+-   }
+-   total = 0;
+-   for(i = 0; ; i++){
+-     cc = read(fd, buf, 300);
+-     if(cc < 0){
+-       printf(1, "read bigfile failed\n");
+--      exit();
+-+      exit(58);
+-     }
+-     if(cc == 0)
+-       break;
+-     if(cc != 300){
+-       printf(1, "short read bigfile\n");
+--      exit();
+-+      exit(57);
+-     }
+-     if(buf[0] != i/2 || buf[299] != i/2){
+-       printf(1, "read bigfile wrong data\n");
+--      exit();
+-+      exit(56);
+-     }
+-     total += cc;
+-   }
+-   close(fd);
+-   if(total != 20*600){
+-     printf(1, "read bigfile wrong total\n");
+--    exit();
+-+    exit(55);
+-   }
+-   unlink("bigfile");
+- 
+-@@ -1210,32 +1210,32 @@ fourteen(void)
+- 
+-   if(mkdir("12345678901234") != 0){
+-     printf(1, "mkdir 12345678901234 failed\n");
+--    exit();
+-+    exit(54);
+-   }
+-   if(mkdir("12345678901234/123456789012345") != 0){
+-     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+--    exit();
+-+    exit(53);
+-   }
+-   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+-   if(fd < 0){
+-     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+--    exit();
+-+    exit(52);
+-   }
+-   close(fd);
+-   fd = open("12345678901234/12345678901234/12345678901234", 0);
+-   if(fd < 0){
+-     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+--    exit();
+-+    exit(51);
+-   }
+-   close(fd);
+- 
+-   if(mkdir("12345678901234/12345678901234") == 0){
+-     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("123456789012345/12345678901234") == 0){
+-     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+- 
+-   printf(1, "fourteen ok\n");
+-@@ -1247,35 +1247,35 @@ rmdot(void)
+-   printf(1, "rmdot test\n");
+-   if(mkdir("dots") != 0){
+-     printf(1, "mkdir dots failed\n");
+--    exit();
+-+    exit(48);
+-   }
+-   if(chdir("dots") != 0){
+-     printf(1, "chdir dots failed\n");
+--    exit();
+-+    exit(47);
+-   }
+-   if(unlink(".") == 0){
+-     printf(1, "rm . worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("..") == 0){
+-     printf(1, "rm .. worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(chdir("/") != 0){
+-     printf(1, "chdir / failed\n");
+--    exit();
+-+    exit(44);
+-   }
+-   if(unlink("dots/.") == 0){
+-     printf(1, "unlink dots/. worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dots/..") == 0){
+-     printf(1, "unlink dots/.. worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dots") != 0){
+-     printf(1, "unlink dots failed!\n");
+--    exit();
+-+    exit(41);
+-   }
+-   printf(1, "rmdot ok\n");
+- }
+-@@ -1290,49 +1290,49 @@ dirfile(void)
+-   fd = open("dirfile", O_CREATE);
+-   if(fd < 0){
+-     printf(1, "create dirfile failed\n");
+--    exit();
+-+    exit(40);
+-   }
+-   close(fd);
+-   if(chdir("dirfile") == 0){
+-     printf(1, "chdir dirfile succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   fd = open("dirfile/xx", 0);
+-   if(fd >= 0){
+-     printf(1, "create dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   fd = open("dirfile/xx", O_CREATE);
+-   if(fd >= 0){
+-     printf(1, "create dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dirfile/xx") == 0){
+-     printf(1, "mkdir dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dirfile/xx") == 0){
+-     printf(1, "unlink dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("README", "dirfile/xx") == 0){
+-     printf(1, "link to dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dirfile") != 0){
+-     printf(1, "unlink dirfile failed!\n");
+--    exit();
+-+    exit(33);
+-   }
+- 
+-   fd = open(".", O_RDWR);
+-   if(fd >= 0){
+-     printf(1, "open . for writing succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   fd = open(".", 0);
+-   if(write(fd, "x", 1) > 0){
+-     printf(1, "write . succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   close(fd);
+- 
+-@@ -1351,11 +1351,11 @@ iref(void)
+-   for(i = 0; i < 50 + 1; i++){
+-     if(mkdir("irefd") != 0){
+-       printf(1, "mkdir irefd failed\n");
+--      exit();
+-+      exit(30);
+-     }
+-     if(chdir("irefd") != 0){
+-       printf(1, "chdir irefd failed\n");
+--      exit();
+-+      exit(29);
+-     }
+- 
+-     mkdir("");
+-@@ -1388,24 +1388,24 @@ forktest(void)
+-     if(pid < 0)
+-       break;
+-     if(pid == 0)
+--      exit();
+-+      exit(28);
+-   }
+- 
+-   if(n == 1000){
+-     printf(1, "fork claimed to work 1000 times!\n");
+--    exit();
+-+    exit(27);
+-   }
+- 
+-   for(; n > 0; n--){
+--    if(wait() < 0){
+-+    if(wait(NULL) < 0){
+-       printf(1, "wait stopped early\n");
+--      exit();
+-+      exit(26);
+-     }
+-   }
+- 
+--  if(wait() != -1){
+-+  if(wait(NULL) != -1){
+-     printf(1, "wait got too many\n");
+--    exit();
+-+    exit(25);
+-   }
+- 
+-   printf(1, "fork test OK\n");
+-@@ -1428,7 +1428,7 @@ sbrktest(void)
+-     b = sbrk(1);
+-     if(b != a){
+-       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+--      exit();
+-+      exit(24);
+-     }
+-     *b = 1;
+-     a = b + 1;
+-@@ -1436,17 +1436,17 @@ sbrktest(void)
+-   pid = fork();
+-   if(pid < 0){
+-     printf(stdout, "sbrk test fork failed\n");
+--    exit();
+-+    exit(23);
+-   }
+-   c = sbrk(1);
+-   c = sbrk(1);
+-   if(c != a + 1){
+-     printf(stdout, "sbrk test failed post-fork\n");
+--    exit();
+-+    exit(22);
+-   }
+-   if(pid == 0)
+--    exit();
+--  wait();
+-+    exit(21);
+-+  wait(NULL);
+- 
+-   // can one grow address space to something big?
+- #define BIG (100*1024*1024)
+-@@ -1455,7 +1455,7 @@ sbrktest(void)
+-   p = sbrk(amt);
+-   if (p != a) {
+-     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+--    exit();
+-+    exit(20);
+-   }
+-   lastaddr = (char*) (BIG-1);
+-   *lastaddr = 99;
+-@@ -1465,12 +1465,12 @@ sbrktest(void)
+-   c = sbrk(-4096);
+-   if(c == (char*)0xffffffff){
+-     printf(stdout, "sbrk could not deallocate\n");
+--    exit();
+-+    exit(19);
+-   }
+-   c = sbrk(0);
+-   if(c != a - 4096){
+-     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+--    exit();
+-+    exit(18);
+-   }
+- 
+-   // can one re-allocate that page?
+-@@ -1478,19 +1478,19 @@ sbrktest(void)
+-   c = sbrk(4096);
+-   if(c != a || sbrk(0) != a + 4096){
+-     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+--    exit();
+-+    exit(17);
+-   }
+-   if(*lastaddr == 99){
+-     // should be zero
+-     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+--    exit();
+-+    exit(16);
+-   }
+- 
+-   a = sbrk(0);
+-   c = sbrk(-(sbrk(0) - oldbrk));
+-   if(c != a){
+-     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+--    exit();
+-+    exit(15);
+-   }
+- 
+-   // can we read the kernel's memory?
+-@@ -1499,21 +1499,21 @@ sbrktest(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(stdout, "fork failed\n");
+--      exit();
+-+      exit(14);
+-     }
+-     if(pid == 0){
+-       printf(stdout, "oops could read %x = %x\n", a, *a);
+-       kill(ppid);
+--      exit();
+-+      exit(13);
+-     }
+--    wait();
+-+    wait(NULL);
+-   }
+- 
+-   // if we run the system out of memory, does it clean up the last
+-   // failed allocation?
+-   if(pipe(fds) != 0){
+-     printf(1, "pipe() failed\n");
+--    exit();
+-+    exit(12);
+-   }
+-   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+-     if((pids[i] = fork()) == 0){
+-@@ -1533,11 +1533,11 @@ sbrktest(void)
+-     if(pids[i] == -1)
+-       continue;
+-     kill(pids[i]);
+--    wait();
+-+    wait(NULL);
+-   }
+-   if(c == (char*)0xffffffff){
+-     printf(stdout, "failed sbrk leaked memory\n");
+--    exit();
+-+    exit(10);
+-   }
+- 
+-   if(sbrk(0) > oldbrk)
+-@@ -1572,17 +1572,17 @@ validatetest(void)
+-     if((pid = fork()) == 0){
+-       // try to crash the kernel by passing in a badly placed integer
+-       validateint((int*)p);
+--      exit();
+-+      exit(9);
+-     }
+-     sleep(0);
+-     sleep(0);
+-     kill(pid);
+--    wait();
+-+    wait(NULL);
+- 
+-     // try to crash the kernel by passing in a bad string pointer
+-     if(link("nosuchfile", (char*)p) != -1){
+-       printf(stdout, "link should not succeed\n");
+--      exit();
+-+      exit(8);
+-     }
+-   }
+- 
+-@@ -1600,7 +1600,7 @@ bsstest(void)
+-   for(i = 0; i < sizeof(uninit); i++){
+-     if(uninit[i] != '\0'){
+-       printf(stdout, "bss test failed\n");
+--      exit();
+-+      exit(7);
+-     }
+-   }
+-   printf(stdout, "bss test ok\n");
+-@@ -1627,16 +1627,16 @@ bigargtest(void)
+-     printf(stdout, "bigarg test ok\n");
+-     fd = open("bigarg-ok", O_CREATE);
+-     close(fd);
+--    exit();
+-+    exit(6);
+-   } else if(pid < 0){
+-     printf(stdout, "bigargtest: fork failed\n");
+--    exit();
+-+    exit(5);
+-   }
+--  wait();
+-+  wait(NULL);
+-   fd = open("bigarg-ok", 0);
+-   if(fd < 0){
+-     printf(stdout, "bigarg test failed!\n");
+--    exit();
+-+    exit(4);
+-   }
+-   close(fd);
+-   unlink("bigarg-ok");
+-@@ -1715,12 +1715,12 @@ uio()
+-     port = RTC_DATA;
+-     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+-     printf(1, "uio: uio succeeded; test FAILED\n");
+--    exit();
+-+    exit(3);
+-   } else if(pid < 0){
+-     printf (1, "fork failed\n");
+--    exit();
+-+    exit(2);
+-   }
+--  wait();
+-+  wait(NULL);
+-   printf(1, "uio test done\n");
+- }
+- 
+-@@ -1730,7 +1730,7 @@ void argptest()
+-   fd = open("init", O_RDONLY);
+-   if (fd < 0) {
+-     printf(2, "open failed\n");
+--    exit();
+-+    exit(1);
+-   }
+-   read(fd, sbrk(0) - 1, -1);
+-   close(fd);
+-@@ -1752,7 +1752,7 @@ main(int argc, char *argv[])
+- 
+-   if(open("usertests.ran", 0) >= 0){
+-     printf(1, "already ran user tests -- rebuild fs.img\n");
+--    exit();
+-+    exit(1);
+-   }
+-   close(open("usertests.ran", O_CREATE));
+- 
+-@@ -1799,5 +1799,5 @@ main(int argc, char *argv[])
+- 
+-   exectest();
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/usys.S b/usys.S
+-index 8bfd8a1..1687ed0 100644
+---- a/usys.S
+-+++ b/usys.S
+-@@ -11,6 +11,7 @@
+- SYSCALL(fork)
+- SYSCALL(exit)
+- SYSCALL(wait)
+-+SYSCALL(waitpid)
+- SYSCALL(pipe)
+- SYSCALL(read)
+- SYSCALL(write)
+-diff --git a/vectors.pl b/vectors.pl
+-old mode 100755
+-new mode 100644
+-diff --git a/wc.c b/wc.c
+-index d6a54df..08b93b6 100644
+---- a/wc.c
+-+++ b/wc.c
+-@@ -27,7 +27,7 @@ wc(int fd, char *name)
+-   }
+-   if(n < 0){
+-     printf(1, "wc: read error\n");
+--    exit();
+-+    exit(3);
+-   }
+-   printf(1, "%d %d %d %s\n", l, w, c, name);
+- }
+-@@ -39,16 +39,16 @@ main(int argc, char *argv[])
+- 
+-   if(argc <= 1){
+-     wc(0, "");
+--    exit();
+-+    exit(2);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-     if((fd = open(argv[i], 0)) < 0){
+-       printf(1, "wc: cannot open %s\n", argv[i]);
+--      exit();
+-+      exit(1);
+-     }
+-     wc(fd, argv[i]);
+-     close(fd);
+-   }
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/zombie.c b/zombie.c
+-index ee817da..c96b92d 100644
+---- a/zombie.c
+-+++ b/zombie.c
+-@@ -10,5 +10,5 @@ main(void)
+- {
+-   if(fork() > 0)
+-     sleep(5);  // Let child exit before parent.
+--  exit();
+-+  exit(0);
+- }
+diff --git a/defs.h b/defs.h
+index d1934ca..82fb982 100644
+--- a/defs.h
++++ b/defs.h
+@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
+ //PAGEBREAK: 16
+ // proc.c
+ int             cpuid(void);
+-void            exit(int status);
++void            exit(void);
+ int             fork(void);
+ int             growproc(int);
+ int             kill(int);
+@@ -117,8 +117,7 @@ void            sched(void);
+ void            setproc(struct proc*);
+ void            sleep(void*, struct spinlock*);
+ void            userinit(void);
+-int             wait(int* status);
+-int             waitpid(int pid, int* status, int options);
++int             wait(void);
+ void            wakeup(void*);
+ void            yield(void);
+ 
+diff --git a/echo.c b/echo.c
+index eed68a0..806dee0 100644
+--- a/echo.c
++++ b/echo.c
+@@ -9,5 +9,5 @@ main(int argc, char *argv[])
+ 
+   for(i = 1; i < argc; i++)
+     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+-  exit(0);
++  exit();
+ }
+diff --git a/forktest.c b/forktest.c
+index a4b35ed..8bc984d 100644
+--- a/forktest.c
++++ b/forktest.c
+@@ -25,24 +25,24 @@ forktest(void)
+     if(pid < 0)
+       break;
+     if(pid == 0)
+-      exit(4);
++      exit();
+   }
+ 
+   if(n == N){
+     printf(1, "fork claimed to work N times!\n", N);
+-    exit(3);
++    exit();
+   }
+ 
+   for(; n > 0; n--){
+-    if(wait(NULL) < 0){
++    if(wait() < 0){
+       printf(1, "wait stopped early\n");
+-      exit(2);
++      exit();
+     }
+   }
+ 
+-  if(wait(NULL) != -1){
++  if(wait() != -1){
+     printf(1, "wait got too many\n");
+-    exit(1);
++    exit();
+   }
+ 
+   printf(1, "fork test OK\n");
+@@ -52,5 +52,5 @@ int
+ main(void)
+ {
+   forktest();
+-  exit(0);
++  exit();
+ }
+diff --git a/grep.c b/grep.c
+index 4be3256..adc4835 100644
+--- a/grep.c
++++ b/grep.c
+@@ -43,24 +43,24 @@ main(int argc, char *argv[])
+ 
+   if(argc <= 1){
+     printf(2, "usage: grep pattern [file ...]\n");
+-    exit(1);
++    exit();
+   }
+   pattern = argv[1];
+ 
+   if(argc <= 2){
+     grep(pattern, 0);
+-    exit(2);
++    exit();
+   }
+ 
+   for(i = 2; i < argc; i++){
+     if((fd = open(argv[i], 0)) < 0){
+       printf(1, "grep: cannot open %s\n", argv[i]);
+-      exit(3);
++      exit();
+     }
+     grep(pattern, fd);
+     close(fd);
+   }
+-  exit(0);
++  exit();
+ }
+ 
+ // Regexp matcher from Kernighan & Pike,
+diff --git a/init.c b/init.c
+index bc6547f..046b551 100644
+--- a/init.c
++++ b/init.c
+@@ -24,14 +24,14 @@ main(void)
+     pid = fork();
+     if(pid < 0){
+       printf(1, "init: fork failed\n");
+-      exit(2);
++      exit();
+     }
+     if(pid == 0){
+       exec("sh", argv);
+       printf(1, "init: exec sh failed\n");
+-      exit(1);
++      exit();
+     }
+-    while((wpid=wait(NULL)) >= 0 && wpid != pid)
++    while((wpid=wait()) >= 0 && wpid != pid)
+       printf(1, "zombie!\n");
+   }
+ }
+diff --git a/kill.c b/kill.c
+index 875916c..364f6af 100644
+--- a/kill.c
++++ b/kill.c
+@@ -9,9 +9,9 @@ main(int argc, char **argv)
+ 
+   if(argc < 2){
+     printf(2, "usage: kill pid...\n");
+-    exit(1);
++    exit();
+   }
+   for(i=1; i<argc; i++)
+     kill(atoi(argv[i]));
+-  exit(0);
++  exit();
+ }
+diff --git a/lab1.c b/lab1.c
+deleted file mode 100644
+index 2192a52..0000000
+--- a/lab1.c
++++ /dev/null
+@@ -1,69 +0,0 @@
+-// ------------------------------------------------------------
+-// steps to reproduce the hello program demo during lab session:
+-// ------------------------------------------------------------
+-// 1. Create new file named hello.c inside local copy of xv6 folder. Copy the source code below over.
+-// 2. Modify local Makefile to include this new user program to let xv6 recognize this new prog.
+-// add "_hello/" to variable UPROG
+-// 3. Make sure both hello.c and Makefile modifications are uploaded to remote copy;
+-// option1 (sync any changed file): tools -> deployment -> automatic upload (always);
+-// option2 (sync one specific file):
+-// choose the file to upload in project window -> tools -> deployment -> upload to <name of your deployment>
+-// 4. In a sledge terminal session:
+-// (after entering xv6 folder) $ make qemu-nox
+-// 5. Run new user program with command below:
+-// (xv6) $ hello
+-
+-#include "types.h"
+-#include "user.h"
+-
+-int main(int argc, char **argv) {
+-
+-    int pid;
+-
+-    pid = fork();
+-
+-    if(pid > 0)
+-    {
+-        waitpid(pid, NULL, 0);
+-        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
+-        exit(0);
+-    }
+-
+-
+-    pid = fork();
+-
+-    if(pid == 0)
+-    {
+-        printf(1, "I'm the child! PID: %d\n", pid);
+-    }
+-    else
+-    {
+-        printf(1, "I'm the parent! PID: %d\n", pid);
+-        waitpid(pid, NULL, 0);
+-
+-    }
+-
+-
+-    exit(0);
+-}
+-//    printf(1, "Waitpid Demo Initializing...\n"); // fd=1 means standard output.
+-//
+-//    int defValue = -1;
+-//    int* status = &defValue;
+-//
+-//    int pid = fork();
+-//
+-//
+-//    if(pid > 0)
+-//    while(waitpid(pid, status, 0) == -1);
+-//
+-//    if(pid == 0)
+-//    {
+-//        printf(1, "hi im the child :)\n"); // fd=1 means standard output.
+-//        exit(0);
+-//    }
+-//
+-//    printf(1, "Exit status returned is: %d\n", *status); // fd=1 means standard output.
+-//
+-//    exit(0);
+-//}
+diff --git a/ln.c b/ln.c
+index fb17c3b..cf8a64e 100644
+--- a/ln.c
++++ b/ln.c
+@@ -7,9 +7,9 @@ main(int argc, char *argv[])
+ {
+   if(argc != 3){
+     printf(2, "Usage: ln old new\n");
+-    exit(1);
++    exit();
+   }
+   if(link(argv[1], argv[2]) < 0)
+     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+-  exit(0);
++  exit();
+ }
+diff --git a/ls.c b/ls.c
+index 6bf943b..2862913 100644
+--- a/ls.c
++++ b/ls.c
+@@ -77,9 +77,9 @@ main(int argc, char *argv[])
+ 
+   if(argc < 2){
+     ls(".");
+-    exit(1);
++    exit();
+   }
+   for(i=1; i<argc; i++)
+     ls(argv[i]);
+-  exit(0);
++  exit();
+ }
+diff --git a/mkdir.c b/mkdir.c
+index 2d90781..6e4c954 100644
+--- a/mkdir.c
++++ b/mkdir.c
+@@ -9,7 +9,7 @@ main(int argc, char *argv[])
+ 
+   if(argc < 2){
+     printf(2, "Usage: mkdir files...\n");
+-    exit(1);
++    exit();
+   }
+ 
+   for(i = 1; i < argc; i++){
+@@ -19,5 +19,5 @@ main(int argc, char *argv[])
+     }
+   }
+ 
+-  exit(0);
++  exit();
+ }
+diff --git a/proc.c b/proc.c
+index 84b335f..806b1b1 100644
+--- a/proc.c
++++ b/proc.c
+@@ -1,5 +1,3 @@
+-#include <stddef.h>
+-
+ #include "types.h"
+ #include "defs.h"
+ #include "param.h"
+@@ -10,61 +8,61 @@
+ #include "spinlock.h"
+ 
+ struct {
+-    struct spinlock lock;
+-    struct proc proc[NPROC];
++  struct spinlock lock;
++  struct proc proc[NPROC];
+ } ptable;
+ 
+ static struct proc *initproc;
+ 
+ int nextpid = 1;
+-
+ extern void forkret(void);
+-
+ extern void trapret(void);
+ 
+ static void wakeup1(void *chan);
+ 
+ void
+-pinit(void) {
+-    initlock(&ptable.lock, "ptable");
++pinit(void)
++{
++  initlock(&ptable.lock, "ptable");
+ }
+ 
+ // Must be called with interrupts disabled
+ int
+ cpuid() {
+-    return mycpu() - cpus;
++  return mycpu()-cpus;
+ }
+ 
+ // Must be called with interrupts disabled to avoid the caller being
+ // rescheduled between reading lapicid and running through the loop.
+-struct cpu *
+-mycpu(void) {
+-    int apicid, i;
+-
+-    if (readeflags() & FL_IF)
+-        panic("mycpu called with interrupts enabled\n");
+-
+-    apicid = lapicid();
+-    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+-    // a reverse map, or reserve a register to store &cpus[i].
+-    for (i = 0; i < ncpu; ++i) {
+-        if (cpus[i].apicid == apicid)
+-            return &cpus[i];
+-    }
+-    panic("unknown apicid\n");
++struct cpu*
++mycpu(void)
++{
++  int apicid, i;
++  
++  if(readeflags()&FL_IF)
++    panic("mycpu called with interrupts enabled\n");
++  
++  apicid = lapicid();
++  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
++  // a reverse map, or reserve a register to store &cpus[i].
++  for (i = 0; i < ncpu; ++i) {
++    if (cpus[i].apicid == apicid)
++      return &cpus[i];
++  }
++  panic("unknown apicid\n");
+ }
+ 
+ // Disable interrupts so that we are not rescheduled
+ // while reading proc from the cpu structure
+-struct proc *
++struct proc*
+ myproc(void) {
+-    struct cpu *c;
+-    struct proc *p;
+-    pushcli();
+-    c = mycpu();
+-    p = c->proc;
+-    popcli();
+-    return p;
++  struct cpu *c;
++  struct proc *p;
++  pushcli();
++  c = mycpu();
++  p = c->proc;
++  popcli();
++  return p;
+ }
+ 
+ //PAGEBREAK: 32
+@@ -72,295 +70,245 @@ myproc(void) {
+ // If found, change state to EMBRYO and initialize
+ // state required to run in the kernel.
+ // Otherwise return 0.
+-static struct proc *
+-allocproc(void) {
+-    struct proc *p;
+-    char *sp;
++static struct proc*
++allocproc(void)
++{
++  struct proc *p;
++  char *sp;
+ 
+-    acquire(&ptable.lock);
++  acquire(&ptable.lock);
+ 
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-        if (p->state == UNUSED)
+-            goto found;
++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++    if(p->state == UNUSED)
++      goto found;
+ 
+-    release(&ptable.lock);
+-    return 0;
++  release(&ptable.lock);
++  return 0;
+ 
+-    found:
+-    p->state = EMBRYO;
+-    p->pid = nextpid++;
++found:
++  p->state = EMBRYO;
++  p->pid = nextpid++;
+ 
+-    release(&ptable.lock);
++  release(&ptable.lock);
+ 
+-    // Allocate kernel stack.
+-    if ((p->kstack = kalloc()) == 0) {
+-        p->state = UNUSED;
+-        return 0;
+-    }
+-    sp = p->kstack + KSTACKSIZE;
++  // Allocate kernel stack.
++  if((p->kstack = kalloc()) == 0){
++    p->state = UNUSED;
++    return 0;
++  }
++  sp = p->kstack + KSTACKSIZE;
+ 
+-    // Leave room for trap frame.
+-    sp -= sizeof *p->tf;
+-    p->tf = (struct trapframe *) sp;
++  // Leave room for trap frame.
++  sp -= sizeof *p->tf;
++  p->tf = (struct trapframe*)sp;
+ 
+-    // Set up new context to start executing at forkret,
+-    // which returns to trapret.
+-    sp -= 4;
+-    *(uint *) sp = (uint) trapret;
++  // Set up new context to start executing at forkret,
++  // which returns to trapret.
++  sp -= 4;
++  *(uint*)sp = (uint)trapret;
+ 
+-    sp -= sizeof *p->context;
+-    p->context = (struct context *) sp;
+-    memset(p->context, 0, sizeof *p->context);
+-    p->context->eip = (uint) forkret;
++  sp -= sizeof *p->context;
++  p->context = (struct context*)sp;
++  memset(p->context, 0, sizeof *p->context);
++  p->context->eip = (uint)forkret;
+ 
+-    return p;
++  return p;
+ }
+ 
+ //PAGEBREAK: 32
+ // Set up first user process.
+ void
+-userinit(void) {
+-    struct proc *p;
+-    extern char _binary_initcode_start[], _binary_initcode_size[];
+-
+-    p = allocproc();
+-
+-    initproc = p;
+-    if ((p->pgdir = setupkvm()) == 0)
+-        panic("userinit: out of memory?");
+-    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
+-    p->sz = PGSIZE;
+-    memset(p->tf, 0, sizeof(*p->tf));
+-    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+-    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+-    p->tf->es = p->tf->ds;
+-    p->tf->ss = p->tf->ds;
+-    p->tf->eflags = FL_IF;
+-    p->tf->esp = PGSIZE;
+-    p->tf->eip = 0;  // beginning of initcode.S
+-
+-    safestrcpy(p->name, "initcode", sizeof(p->name));
+-    p->cwd = namei("/");
+-
+-    // this assignment to p->state lets other cores
+-    // run this process. the acquire forces the above
+-    // writes to be visible, and the lock is also needed
+-    // because the assignment might not be atomic.
+-    acquire(&ptable.lock);
+-
+-    p->state = RUNNABLE;
+-
+-    release(&ptable.lock);
++userinit(void)
++{
++  struct proc *p;
++  extern char _binary_initcode_start[], _binary_initcode_size[];
++
++  p = allocproc();
++  
++  initproc = p;
++  if((p->pgdir = setupkvm()) == 0)
++    panic("userinit: out of memory?");
++  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
++  p->sz = PGSIZE;
++  memset(p->tf, 0, sizeof(*p->tf));
++  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
++  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
++  p->tf->es = p->tf->ds;
++  p->tf->ss = p->tf->ds;
++  p->tf->eflags = FL_IF;
++  p->tf->esp = PGSIZE;
++  p->tf->eip = 0;  // beginning of initcode.S
++
++  safestrcpy(p->name, "initcode", sizeof(p->name));
++  p->cwd = namei("/");
++
++  // this assignment to p->state lets other cores
++  // run this process. the acquire forces the above
++  // writes to be visible, and the lock is also needed
++  // because the assignment might not be atomic.
++  acquire(&ptable.lock);
++
++  p->state = RUNNABLE;
++
++  release(&ptable.lock);
+ }
+ 
+ // Grow current process's memory by n bytes.
+ // Return 0 on success, -1 on failure.
+ int
+-growproc(int n) {
+-    uint sz;
+-    struct proc *curproc = myproc();
+-
+-    sz = curproc->sz;
+-    if (n > 0) {
+-        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-            return -1;
+-    } else if (n < 0) {
+-        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-            return -1;
+-    }
+-    curproc->sz = sz;
+-    switchuvm(curproc);
+-    return 0;
++growproc(int n)
++{
++  uint sz;
++  struct proc *curproc = myproc();
++
++  sz = curproc->sz;
++  if(n > 0){
++    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
++      return -1;
++  } else if(n < 0){
++    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
++      return -1;
++  }
++  curproc->sz = sz;
++  switchuvm(curproc);
++  return 0;
+ }
+ 
+ // Create a new process copying p as the parent.
+ // Sets up stack to return as if from system call.
+ // Caller must set state of returned proc to RUNNABLE.
+ int
+-fork(void) {
+-    int i, pid;
+-    struct proc *np;
+-    struct proc *curproc = myproc();
+-
+-    // Allocate process.
+-    if ((np = allocproc()) == 0) {
+-        return -1;
+-    }
++fork(void)
++{
++  int i, pid;
++  struct proc *np;
++  struct proc *curproc = myproc();
++
++  // Allocate process.
++  if((np = allocproc()) == 0){
++    return -1;
++  }
+ 
+-    // Copy process state from proc.
+-    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
+-        kfree(np->kstack);
+-        np->kstack = 0;
+-        np->state = UNUSED;
+-        return -1;
+-    }
+-    np->sz = curproc->sz;
+-    np->parent = curproc;
+-    *np->tf = *curproc->tf;
++  // Copy process state from proc.
++  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
++    kfree(np->kstack);
++    np->kstack = 0;
++    np->state = UNUSED;
++    return -1;
++  }
++  np->sz = curproc->sz;
++  np->parent = curproc;
++  *np->tf = *curproc->tf;
+ 
+-    // Clear %eax so that fork returns 0 in the child.
+-    np->tf->eax = 0;
++  // Clear %eax so that fork returns 0 in the child.
++  np->tf->eax = 0;
+ 
+-    for (i = 0; i < NOFILE; i++)
+-        if (curproc->ofile[i])
+-            np->ofile[i] = filedup(curproc->ofile[i]);
+-    np->cwd = idup(curproc->cwd);
++  for(i = 0; i < NOFILE; i++)
++    if(curproc->ofile[i])
++      np->ofile[i] = filedup(curproc->ofile[i]);
++  np->cwd = idup(curproc->cwd);
+ 
+-    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
++  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+ 
+-    pid = np->pid;
++  pid = np->pid;
+ 
+-    acquire(&ptable.lock);
++  acquire(&ptable.lock);
+ 
+-    np->state = RUNNABLE;
++  np->state = RUNNABLE;
+ 
+-    release(&ptable.lock);
++  release(&ptable.lock);
+ 
+-    return pid;
++  return pid;
+ }
+ 
+ // Exit the current process.  Does not return.
+ // An exited process remains in the zombie state
+ // until its parent calls wait() to find out it exited.
+ void
+-exit(int status) {
+-    struct proc *curproc = myproc();
+-    struct proc *p;
+-    int fd;
+-
+-    curproc->status = status;
+-
+-    if (curproc == initproc)
+-        panic("init exiting");
+-
+-    // Close all open files.
+-    for (fd = 0; fd < NOFILE; fd++) {
+-        if (curproc->ofile[fd]) {
+-            fileclose(curproc->ofile[fd]);
+-            curproc->ofile[fd] = 0;
+-        }
++exit(void)
++{
++  struct proc *curproc = myproc();
++  struct proc *p;
++  int fd;
++
++  if(curproc == initproc)
++    panic("init exiting");
++
++  // Close all open files.
++  for(fd = 0; fd < NOFILE; fd++){
++    if(curproc->ofile[fd]){
++      fileclose(curproc->ofile[fd]);
++      curproc->ofile[fd] = 0;
+     }
++  }
+ 
+-    begin_op();
+-    iput(curproc->cwd);
+-    end_op();
+-    curproc->cwd = 0;
++  begin_op();
++  iput(curproc->cwd);
++  end_op();
++  curproc->cwd = 0;
+ 
+-    acquire(&ptable.lock);
++  acquire(&ptable.lock);
+ 
+-    // Parent might be sleeping in wait().
+-    wakeup1(curproc->parent);
++  // Parent might be sleeping in wait().
++  wakeup1(curproc->parent);
+ 
+-    // Pass abandoned children to init.
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-        if (p->parent == curproc) {
+-            p->parent = initproc;
+-            if (p->state == ZOMBIE)
+-                wakeup1(initproc);
+-        }
++  // Pass abandoned children to init.
++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++    if(p->parent == curproc){
++      p->parent = initproc;
++      if(p->state == ZOMBIE)
++        wakeup1(initproc);
+     }
++  }
+ 
+-    // Jump into the scheduler, never to return.
+-    curproc->state = ZOMBIE;
+-    sched();
+-    panic("zombie exit");
++  // Jump into the scheduler, never to return.
++  curproc->state = ZOMBIE;
++  sched();
++  panic("zombie exit");
+ }
+ 
+ // Wait for a child process to exit and return its pid.
+ // Return -1 if this process has no children.
+ int
+-wait(int *status) {
+-    struct proc *p;
+-    int havekids, pid;
+-    struct proc *curproc = myproc();
+-
+-    acquire(&ptable.lock);
+-    for (;;) {
+-        // Scan through table looking for exited children.
+-        havekids = 0;
+-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-            if (p->parent != curproc)
+-                continue;
+-            havekids = 1;
+-            if (p->state == ZOMBIE) {
+-                // Found one.
+-                pid = p->pid;
+-                kfree(p->kstack);
+-                p->kstack = 0;
+-                freevm(p->pgdir);
+-                p->pid = 0;
+-                p->parent = 0;
+-                p->name[0] = 0;
+-                p->killed = 0;
+-                p->state = UNUSED;
+-                release(&ptable.lock);
+-                if (status != NULL)
+-                    *status = p->status;
+-                return pid;
+-            }
+-        }
+-
+-        // No point waiting if we don't have any children.
+-        if (!havekids || curproc->killed) {
+-            release(&ptable.lock);
+-            return -1;
+-        }
+-
+-        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
++wait(void)
++{
++  struct proc *p;
++  int havekids, pid;
++  struct proc *curproc = myproc();
++  
++  acquire(&ptable.lock);
++  for(;;){
++    // Scan through table looking for exited children.
++    havekids = 0;
++    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++      if(p->parent != curproc)
++        continue;
++      havekids = 1;
++      if(p->state == ZOMBIE){
++        // Found one.
++        pid = p->pid;
++        kfree(p->kstack);
++        p->kstack = 0;
++        freevm(p->pgdir);
++        p->pid = 0;
++        p->parent = 0;
++        p->name[0] = 0;
++        p->killed = 0;
++        p->state = UNUSED;
++        release(&ptable.lock);
++        return pid;
++      }
+     }
+-}
+ 
+-// Wait for a child process to exit and return its pid.
+-// Return -1 if this process has no children.
+-int
+-waitpid(int pidBeingSearchedFor, int *status, int options) {
+-    struct proc *p;
+-    int doesProcExist, pidFound;
+-    struct proc *curproc = myproc();
+-    acquire(&ptable.lock);
+-    for (;;) {
+-        // Scan through table looking for exited children.
+-        doesProcExist = 0;
+-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-//            if(p->parent != curproc)
+-//                continue;
+-
+-            if (p->pid != pidBeingSearchedFor)
+-                continue;
+-
+-            doesProcExist = 1;
+-            if (p->state == ZOMBIE) {
+-                // Found one.
+-                pidFound = p->pid;
+-                kfree(p->kstack);
+-                p->kstack = 0;
+-                freevm(p->pgdir);
+-                p->pid = 0;
+-                p->parent = 0;
+-                p->name[0] = 0;
+-                p->killed = 0;
+-                p->state = UNUSED;
+-                release(&ptable.lock);
+-                if (status != NULL)
+-                    *status = p->status;
+-                return pidFound;
+-            }
+-        }
+-
+-//        // No point waiting if we don't have any children.
+-//        if(!havekids || curproc->killed){
+-//            release(&ptable.lock);
+-//            return -1;
+-//        }
+-
+-        if (!doesProcExist || curproc->killed) {
+-            release(&ptable.lock);
+-            return -1;
+-        }
+-        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
++    // No point waiting if we don't have any children.
++    if(!havekids || curproc->killed){
++      release(&ptable.lock);
++      return -1;
+     }
++
++    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
++    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
++  }
+ }
+ 
+ //PAGEBREAK: 42
+@@ -372,38 +320,39 @@ waitpid(int pidBeingSearchedFor, int *status, int options) {
+ //  - eventually that process transfers control
+ //      via swtch back to the scheduler.
+ void
+-scheduler(void) {
+-    struct proc *p;
+-    struct cpu *c = mycpu();
+-    c->proc = 0;
+-
+-    for (;;) {
+-        // Enable interrupts on this processor.
+-        sti();
+-
+-        // Loop over process table looking for process to run.
+-        acquire(&ptable.lock);
+-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-            if (p->state != RUNNABLE)
+-                continue;
+-
+-            // Switch to chosen process.  It is the process's job
+-            // to release ptable.lock and then reacquire it
+-            // before jumping back to us.
+-            c->proc = p;
+-            switchuvm(p);
+-            p->state = RUNNING;
+-
+-            swtch(&(c->scheduler), p->context);
+-            switchkvm();
+-
+-            // Process is done running for now.
+-            // It should have changed its p->state before coming back.
+-            c->proc = 0;
+-        }
+-        release(&ptable.lock);
+-
++scheduler(void)
++{
++  struct proc *p;
++  struct cpu *c = mycpu();
++  c->proc = 0;
++  
++  for(;;){
++    // Enable interrupts on this processor.
++    sti();
++
++    // Loop over process table looking for process to run.
++    acquire(&ptable.lock);
++    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++      if(p->state != RUNNABLE)
++        continue;
++
++      // Switch to chosen process.  It is the process's job
++      // to release ptable.lock and then reacquire it
++      // before jumping back to us.
++      c->proc = p;
++      switchuvm(p);
++      p->state = RUNNING;
++
++      swtch(&(c->scheduler), p->context);
++      switchkvm();
++
++      // Process is done running for now.
++      // It should have changed its p->state before coming back.
++      c->proc = 0;
+     }
++    release(&ptable.lock);
++
++  }
+ }
+ 
+ // Enter scheduler.  Must hold only ptable.lock
+@@ -414,130 +363,137 @@ scheduler(void) {
+ // break in the few places where a lock is held but
+ // there's no process.
+ void
+-sched(void) {
+-    int intena;
+-    struct proc *p = myproc();
+-
+-    if (!holding(&ptable.lock))
+-        panic("sched ptable.lock");
+-    if (mycpu()->ncli != 1)
+-        panic("sched locks");
+-    if (p->state == RUNNING)
+-        panic("sched running");
+-    if (readeflags() & FL_IF)
+-        panic("sched interruptible");
+-    intena = mycpu()->intena;
+-    swtch(&p->context, mycpu()->scheduler);
+-    mycpu()->intena = intena;
++sched(void)
++{
++  int intena;
++  struct proc *p = myproc();
++
++  if(!holding(&ptable.lock))
++    panic("sched ptable.lock");
++  if(mycpu()->ncli != 1)
++    panic("sched locks");
++  if(p->state == RUNNING)
++    panic("sched running");
++  if(readeflags()&FL_IF)
++    panic("sched interruptible");
++  intena = mycpu()->intena;
++  swtch(&p->context, mycpu()->scheduler);
++  mycpu()->intena = intena;
+ }
+ 
+ // Give up the CPU for one scheduling round.
+ void
+-yield(void) {
+-    acquire(&ptable.lock);  //DOC: yieldlock
+-    myproc()->state = RUNNABLE;
+-    sched();
+-    release(&ptable.lock);
++yield(void)
++{
++  acquire(&ptable.lock);  //DOC: yieldlock
++  myproc()->state = RUNNABLE;
++  sched();
++  release(&ptable.lock);
+ }
+ 
+ // A fork child's very first scheduling by scheduler()
+ // will swtch here.  "Return" to user space.
+ void
+-forkret(void) {
+-    static int first = 1;
+-    // Still holding ptable.lock from scheduler.
+-    release(&ptable.lock);
+-
+-    if (first) {
+-        // Some initialization functions must be run in the context
+-        // of a regular process (e.g., they call sleep), and thus cannot
+-        // be run from main().
+-        first = 0;
+-        iinit(ROOTDEV);
+-        initlog(ROOTDEV);
+-    }
+-
+-    // Return to "caller", actually trapret (see allocproc).
++forkret(void)
++{
++  static int first = 1;
++  // Still holding ptable.lock from scheduler.
++  release(&ptable.lock);
++
++  if (first) {
++    // Some initialization functions must be run in the context
++    // of a regular process (e.g., they call sleep), and thus cannot
++    // be run from main().
++    first = 0;
++    iinit(ROOTDEV);
++    initlog(ROOTDEV);
++  }
++
++  // Return to "caller", actually trapret (see allocproc).
+ }
+ 
+ // Atomically release lock and sleep on chan.
+ // Reacquires lock when awakened.
+ void
+-sleep(void *chan, struct spinlock *lk) {
+-    struct proc *p = myproc();
+-
+-    if (p == 0)
+-        panic("sleep");
+-
+-    if (lk == 0)
+-        panic("sleep without lk");
+-
+-    // Must acquire ptable.lock in order to
+-    // change p->state and then call sched.
+-    // Once we hold ptable.lock, we can be
+-    // guaranteed that we won't miss any wakeup
+-    // (wakeup runs with ptable.lock locked),
+-    // so it's okay to release lk.
+-    if (lk != &ptable.lock) {  //DOC: sleeplock0
+-        acquire(&ptable.lock);  //DOC: sleeplock1
+-        release(lk);
+-    }
+-    // Go to sleep.
+-    p->chan = chan;
+-    p->state = SLEEPING;
+-
+-    sched();
+-
+-    // Tidy up.
+-    p->chan = 0;
+-
+-    // Reacquire original lock.
+-    if (lk != &ptable.lock) {  //DOC: sleeplock2
+-        release(&ptable.lock);
+-        acquire(lk);
+-    }
++sleep(void *chan, struct spinlock *lk)
++{
++  struct proc *p = myproc();
++  
++  if(p == 0)
++    panic("sleep");
++
++  if(lk == 0)
++    panic("sleep without lk");
++
++  // Must acquire ptable.lock in order to
++  // change p->state and then call sched.
++  // Once we hold ptable.lock, we can be
++  // guaranteed that we won't miss any wakeup
++  // (wakeup runs with ptable.lock locked),
++  // so it's okay to release lk.
++  if(lk != &ptable.lock){  //DOC: sleeplock0
++    acquire(&ptable.lock);  //DOC: sleeplock1
++    release(lk);
++  }
++  // Go to sleep.
++  p->chan = chan;
++  p->state = SLEEPING;
++
++  sched();
++
++  // Tidy up.
++  p->chan = 0;
++
++  // Reacquire original lock.
++  if(lk != &ptable.lock){  //DOC: sleeplock2
++    release(&ptable.lock);
++    acquire(lk);
++  }
+ }
+ 
+ //PAGEBREAK!
+ // Wake up all processes sleeping on chan.
+ // The ptable lock must be held.
+ static void
+-wakeup1(void *chan) {
+-    struct proc *p;
++wakeup1(void *chan)
++{
++  struct proc *p;
+ 
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-        if (p->state == SLEEPING && p->chan == chan)
+-            p->state = RUNNABLE;
++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++    if(p->state == SLEEPING && p->chan == chan)
++      p->state = RUNNABLE;
+ }
+ 
+ // Wake up all processes sleeping on chan.
+ void
+-wakeup(void *chan) {
+-    acquire(&ptable.lock);
+-    wakeup1(chan);
+-    release(&ptable.lock);
++wakeup(void *chan)
++{
++  acquire(&ptable.lock);
++  wakeup1(chan);
++  release(&ptable.lock);
+ }
+ 
+ // Kill the process with the given pid.
+ // Process won't exit until it returns
+ // to user space (see trap in trap.c).
+ int
+-kill(int pid) {
+-    struct proc *p;
+-
+-    acquire(&ptable.lock);
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-        if (p->pid == pid) {
+-            p->killed = 1;
+-            // Wake process from sleep if necessary.
+-            if (p->state == SLEEPING)
+-                p->state = RUNNABLE;
+-            release(&ptable.lock);
+-            return 0;
+-        }
++kill(int pid)
++{
++  struct proc *p;
++
++  acquire(&ptable.lock);
++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++    if(p->pid == pid){
++      p->killed = 1;
++      // Wake process from sleep if necessary.
++      if(p->state == SLEEPING)
++        p->state = RUNNABLE;
++      release(&ptable.lock);
++      return 0;
+     }
+-    release(&ptable.lock);
+-    return -1;
++  }
++  release(&ptable.lock);
++  return -1;
+ }
+ 
+ //PAGEBREAK: 36
+@@ -545,33 +501,34 @@ kill(int pid) {
+ // Runs when user types ^P on console.
+ // No lock to avoid wedging a stuck machine further.
+ void
+-procdump(void) {
+-    static char *states[] = {
+-            [UNUSED]    "unused",
+-            [EMBRYO]    "embryo",
+-            [SLEEPING]  "sleep ",
+-            [RUNNABLE]  "runble",
+-            [RUNNING]   "run   ",
+-            [ZOMBIE]    "zombie"
+-    };
+-    int i;
+-    struct proc *p;
+-    char *state;
+-    uint pc[10];
+-
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-        if (p->state == UNUSED)
+-            continue;
+-        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
+-            state = states[p->state];
+-        else
+-            state = "???";
+-        cprintf("%d %s %s", p->pid, state, p->name);
+-        if (p->state == SLEEPING) {
+-            getcallerpcs((uint *) p->context->ebp + 2, pc);
+-            for (i = 0; i < 10 && pc[i] != 0; i++)
+-                cprintf(" %p", pc[i]);
+-        }
+-        cprintf("\n");
++procdump(void)
++{
++  static char *states[] = {
++  [UNUSED]    "unused",
++  [EMBRYO]    "embryo",
++  [SLEEPING]  "sleep ",
++  [RUNNABLE]  "runble",
++  [RUNNING]   "run   ",
++  [ZOMBIE]    "zombie"
++  };
++  int i;
++  struct proc *p;
++  char *state;
++  uint pc[10];
++
++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++    if(p->state == UNUSED)
++      continue;
++    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
++      state = states[p->state];
++    else
++      state = "???";
++    cprintf("%d %s %s", p->pid, state, p->name);
++    if(p->state == SLEEPING){
++      getcallerpcs((uint*)p->context->ebp+2, pc);
++      for(i=0; i<10 && pc[i] != 0; i++)
++        cprintf(" %p", pc[i]);
+     }
++    cprintf("\n");
++  }
+ }
+diff --git a/proc.h b/proc.h
+index a06b921..1647114 100644
+--- a/proc.h
++++ b/proc.h
+@@ -49,7 +49,6 @@ struct proc {
+   struct file *ofile[NOFILE];  // Open files
+   struct inode *cwd;           // Current directory
+   char name[16];               // Process name (debugging)
+-  int status;                  // Exit status
+ };
+ 
+ // Process memory is laid out contiguously, low addresses first:
+diff --git a/rm.c b/rm.c
+index 1e6daec..4fd33c8 100644
+--- a/rm.c
++++ b/rm.c
+@@ -9,7 +9,7 @@ main(int argc, char *argv[])
+ 
+   if(argc < 2){
+     printf(2, "Usage: rm files...\n");
+-    exit(1);
++    exit();
+   }
+ 
+   for(i = 1; i < argc; i++){
+@@ -19,5 +19,5 @@ main(int argc, char *argv[])
+     }
+   }
+ 
+-  exit(0);
++  exit();
+ }
+diff --git a/sh.c b/sh.c
+index ca2ae37..054bab9 100644
+--- a/sh.c
++++ b/sh.c
+@@ -65,7 +65,7 @@ runcmd(struct cmd *cmd)
+   struct redircmd *rcmd;
+ 
+   if(cmd == 0)
+-    exit(1);
++    exit();
+ 
+   switch(cmd->type){
+   default:
+@@ -74,7 +74,7 @@ runcmd(struct cmd *cmd)
+   case EXEC:
+     ecmd = (struct execcmd*)cmd;
+     if(ecmd->argv[0] == 0)
+-      exit(2);
++      exit();
+     exec(ecmd->argv[0], ecmd->argv);
+     printf(2, "exec %s failed\n", ecmd->argv[0]);
+     break;
+@@ -84,7 +84,7 @@ runcmd(struct cmd *cmd)
+     close(rcmd->fd);
+     if(open(rcmd->file, rcmd->mode) < 0){
+       printf(2, "open %s failed\n", rcmd->file);
+-      exit(6);
++      exit();
+     }
+     runcmd(rcmd->cmd);
+     break;
+@@ -93,7 +93,7 @@ runcmd(struct cmd *cmd)
+     lcmd = (struct listcmd*)cmd;
+     if(fork1() == 0)
+       runcmd(lcmd->left);
+-    wait(NULL);
++    wait();
+     runcmd(lcmd->right);
+     break;
+ 
+@@ -117,8 +117,8 @@ runcmd(struct cmd *cmd)
+     }
+     close(p[0]);
+     close(p[1]);
+-    wait(NULL);
+-    wait(NULL);
++    wait();
++    wait();
+     break;
+ 
+   case BACK:
+@@ -127,7 +127,7 @@ runcmd(struct cmd *cmd)
+       runcmd(bcmd->cmd);
+     break;
+   }
+-  exit(3);
++  exit();
+ }
+ 
+ int
+@@ -166,16 +166,16 @@ main(void)
+     }
+     if(fork1() == 0)
+       runcmd(parsecmd(buf));
+-    wait(NULL);
++    wait();
+   }
+-  exit(0);
++  exit();
+ }
+ 
+ void
+ panic(char *s)
+ {
+   printf(2, "%s\n", s);
+-  exit(5);
++  exit();
+ }
+ 
+ int
+diff --git a/stressfs.c b/stressfs.c
+index 46e0e66..c0a4743 100644
+--- a/stressfs.c
++++ b/stressfs.c
+@@ -43,7 +43,7 @@ main(int argc, char *argv[])
+     read(fd, data, sizeof(data));
+   close(fd);
+ 
+-  wait(NULL);
++  wait();
+ 
+-  exit(0);
++  exit();
+ }
+diff --git a/syscall.c b/syscall.c
+index 41a8c3c..ee85261 100644
+--- a/syscall.c
++++ b/syscall.c
+@@ -101,7 +101,6 @@ extern int sys_sbrk(void);
+ extern int sys_sleep(void);
+ extern int sys_unlink(void);
+ extern int sys_wait(void);
+-extern int sys_waitpid(void);
+ extern int sys_write(void);
+ extern int sys_uptime(void);
+ 
+@@ -109,7 +108,6 @@ static int (*syscalls[])(void) = {
+ [SYS_fork]    sys_fork,
+ [SYS_exit]    sys_exit,
+ [SYS_wait]    sys_wait,
+-[SYS_waitpid] sys_waitpid,
+ [SYS_pipe]    sys_pipe,
+ [SYS_read]    sys_read,
+ [SYS_kill]    sys_kill,
+diff --git a/syscall.h b/syscall.h
+index 374ff05..bc5f356 100644
+--- a/syscall.h
++++ b/syscall.h
+@@ -1,23 +1,22 @@
+ // System call numbers
+-#define SYS_fork     1
+-#define SYS_exit     2
+-#define SYS_wait     3
+-#define SYS_pipe     4
+-#define SYS_read     5
+-#define SYS_kill     6
+-#define SYS_exec     7
+-#define SYS_fstat    8
+-#define SYS_chdir    9
+-#define SYS_dup     10
+-#define SYS_getpid  11
+-#define SYS_sbrk    12
+-#define SYS_sleep   13
+-#define SYS_uptime  14
+-#define SYS_open    15
+-#define SYS_write   16
+-#define SYS_mknod   17
+-#define SYS_unlink  18
+-#define SYS_link    19
+-#define SYS_mkdir   20
+-#define SYS_close   21
+-#define SYS_waitpid 22
+\ No newline at end of file
++#define SYS_fork    1
++#define SYS_exit    2
++#define SYS_wait    3
++#define SYS_pipe    4
++#define SYS_read    5
++#define SYS_kill    6
++#define SYS_exec    7
++#define SYS_fstat   8
++#define SYS_chdir   9
++#define SYS_dup    10
++#define SYS_getpid 11
++#define SYS_sbrk   12
++#define SYS_sleep  13
++#define SYS_uptime 14
++#define SYS_open   15
++#define SYS_write  16
++#define SYS_mknod  17
++#define SYS_unlink 18
++#define SYS_link   19
++#define SYS_mkdir  20
++#define SYS_close  21
+diff --git a/sysproc.c b/sysproc.c
+index ebccf84..0686d29 100644
+--- a/sysproc.c
++++ b/sysproc.c
+@@ -14,22 +14,16 @@ sys_fork(void)
+ }
+ 
+ int
+-sys_exit(int status)
++sys_exit(void)
+ {
+-  exit(status);
++  exit();
+   return 0;  // not reached
+ }
+ 
+ int
+-sys_wait(int* status)
++sys_wait(void)
+ {
+-  return wait(status);
+-}
+-
+-int
+-sys_waitpid(int pid, int* status, int options)
+-{
+-    return waitpid(pid, status, options);
++  return wait();
+ }
+ 
+ int
+diff --git a/trap.c b/trap.c
+index 432ea5b..41c66eb 100644
+--- a/trap.c
++++ b/trap.c
+@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
+ {
+   if(tf->trapno == T_SYSCALL){
+     if(myproc()->killed)
+-      exit(4);
++      exit();
+     myproc()->tf = tf;
+     syscall();
+     if(myproc()->killed)
+-      exit(3);
++      exit();
+     return;
+   }
+ 
+@@ -98,7 +98,7 @@ trap(struct trapframe *tf)
+   // (If it is still executing in the kernel, let it keep running
+   // until it gets to the regular system call return.)
+   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+-    exit(2);
++    exit();
+ 
+   // Force process to give up CPU on clock tick.
+   // If interrupts were on while locks held, would need to check nlock.
+@@ -108,5 +108,5 @@ trap(struct trapframe *tf)
+ 
+   // Check if the process has been killed since we yielded
+   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+-    exit(1);
++    exit();
+ }
+diff --git a/user.h b/user.h
+index 0931387..4f99c52 100644
+--- a/user.h
++++ b/user.h
+@@ -1,13 +1,10 @@
+-#include <stddef.h>
+-
+ struct stat;
+ struct rtcdate;
+ 
+ // system calls
+ int fork(void);
+-int exit(int status) __attribute__((noreturn));
+-int wait(int* status);
+-int waitpid(int pid, int* status, int options);
++int exit(void) __attribute__((noreturn));
++int wait(void);
+ int pipe(int*);
+ int write(int, const void*, int);
+ int read(int, void*, int);
+diff --git a/usertests.c b/usertests.c
+index 2c2c128..a1e97e7 100644
+--- a/usertests.c
++++ b/usertests.c
+@@ -21,19 +21,19 @@ iputtest(void)
+ 
+   if(mkdir("iputdir") < 0){
+     printf(stdout, "mkdir failed\n");
+-    exit(184);
++    exit();
+   }
+   if(chdir("iputdir") < 0){
+     printf(stdout, "chdir iputdir failed\n");
+-    exit(183);
++    exit();
+   }
+   if(unlink("../iputdir") < 0){
+     printf(stdout, "unlink ../iputdir failed\n");
+-    exit(182);
++    exit();
+   }
+   if(chdir("/") < 0){
+     printf(stdout, "chdir / failed\n");
+-    exit(181);
++    exit();
+   }
+   printf(stdout, "iput test ok\n");
+ }
+@@ -49,24 +49,24 @@ exitiputtest(void)
+   pid = fork();
+   if(pid < 0){
+     printf(stdout, "fork failed\n");
+-    exit(180);
++    exit();
+   }
+   if(pid == 0){
+     if(mkdir("iputdir") < 0){
+       printf(stdout, "mkdir failed\n");
+-      exit(179);
++      exit();
+     }
+     if(chdir("iputdir") < 0){
+       printf(stdout, "child chdir failed\n");
+-      exit(178);
++      exit();
+     }
+     if(unlink("../iputdir") < 0){
+       printf(stdout, "unlink ../iputdir failed\n");
+-      exit(177);
++      exit();
+     }
+-    exit(176);
++    exit();
+   }
+-  wait(NULL);
++  wait();
+   printf(stdout, "exitiput test ok\n");
+ }
+ 
+@@ -89,27 +89,27 @@ openiputtest(void)
+   printf(stdout, "openiput test\n");
+   if(mkdir("oidir") < 0){
+     printf(stdout, "mkdir oidir failed\n");
+-    exit(175);
++    exit();
+   }
+   pid = fork();
+   if(pid < 0){
+     printf(stdout, "fork failed\n");
+-    exit(174);
++    exit();
+   }
+   if(pid == 0){
+     int fd = open("oidir", O_RDWR);
+     if(fd >= 0){
+       printf(stdout, "open directory for write succeeded\n");
+-      exit(0);
++      exit();
+     }
+-    exit(172);
++    exit();
+   }
+   sleep(1);
+   if(unlink("oidir") != 0){
+     printf(stdout, "unlink failed\n");
+-    exit(171);
++    exit();
+   }
+-  wait(NULL);
++  wait();
+   printf(stdout, "openiput test ok\n");
+ }
+ 
+@@ -124,13 +124,13 @@ opentest(void)
+   fd = open("echo", 0);
+   if(fd < 0){
+     printf(stdout, "open echo failed!\n");
+-    exit(170);
++    exit();
+   }
+   close(fd);
+   fd = open("doesnotexist", 0);
+   if(fd >= 0){
+     printf(stdout, "open doesnotexist succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   printf(stdout, "open test ok\n");
+ }
+@@ -147,16 +147,16 @@ writetest(void)
+     printf(stdout, "creat small succeeded; ok\n");
+   } else {
+     printf(stdout, "error: creat small failed!\n");
+-    exit(168);
++    exit();
+   }
+   for(i = 0; i < 100; i++){
+     if(write(fd, "aaaaaaaaaa", 10) != 10){
+       printf(stdout, "error: write aa %d new file failed\n", i);
+-      exit(167);
++      exit();
+     }
+     if(write(fd, "bbbbbbbbbb", 10) != 10){
+       printf(stdout, "error: write bb %d new file failed\n", i);
+-      exit(166);
++      exit();
+     }
+   }
+   printf(stdout, "writes ok\n");
+@@ -166,20 +166,20 @@ writetest(void)
+     printf(stdout, "open small succeeded ok\n");
+   } else {
+     printf(stdout, "error: open small failed!\n");
+-    exit(165);
++    exit();
+   }
+   i = read(fd, buf, 2000);
+   if(i == 2000){
+     printf(stdout, "read succeeded ok\n");
+   } else {
+     printf(stdout, "read failed\n");
+-    exit(164);
++    exit();
+   }
+   close(fd);
+ 
+   if(unlink("small") < 0){
+     printf(stdout, "unlink small failed\n");
+-    exit(163);
++    exit();
+   }
+   printf(stdout, "small file test ok\n");
+ }
+@@ -194,14 +194,14 @@ writetest1(void)
+   fd = open("big", O_CREATE|O_RDWR);
+   if(fd < 0){
+     printf(stdout, "error: creat big failed!\n");
+-    exit(162);
++    exit();
+   }
+ 
+   for(i = 0; i < MAXFILE; i++){
+     ((int*)buf)[0] = i;
+     if(write(fd, buf, 512) != 512){
+       printf(stdout, "error: write big file failed\n", i);
+-      exit(161);
++      exit();
+     }
+   }
+ 
+@@ -210,7 +210,7 @@ writetest1(void)
+   fd = open("big", O_RDONLY);
+   if(fd < 0){
+     printf(stdout, "error: open big failed!\n");
+-    exit(160);
++    exit();
+   }
+ 
+   n = 0;
+@@ -219,24 +219,24 @@ writetest1(void)
+     if(i == 0){
+       if(n == MAXFILE - 1){
+         printf(stdout, "read only %d blocks from big", n);
+-        exit(159);
++        exit();
+       }
+       break;
+     } else if(i != 512){
+       printf(stdout, "read failed %d\n", i);
+-      exit(158);
++      exit();
+     }
+     if(((int*)buf)[0] != n){
+       printf(stdout, "read content of block %d is %d\n",
+              n, ((int*)buf)[0]);
+-      exit(157);
++      exit();
+     }
+     n++;
+   }
+   close(fd);
+   if(unlink("big") < 0){
+     printf(stdout, "unlink big failed\n");
+-    exit(156);
++    exit();
+   }
+   printf(stdout, "big files ok\n");
+ }
+@@ -270,22 +270,22 @@ void dirtest(void)
+ 
+   if(mkdir("dir0") < 0){
+     printf(stdout, "mkdir failed\n");
+-    exit(155);
++    exit();
+   }
+ 
+   if(chdir("dir0") < 0){
+     printf(stdout, "chdir dir0 failed\n");
+-    exit(154);
++    exit();
+   }
+ 
+   if(chdir("..") < 0){
+     printf(stdout, "chdir .. failed\n");
+-    exit(153);
++    exit();
+   }
+ 
+   if(unlink("dir0") < 0){
+     printf(stdout, "unlink dir0 failed\n");
+-    exit(152);
++    exit();
+   }
+   printf(stdout, "mkdir test ok\n");
+ }
+@@ -296,7 +296,7 @@ exectest(void)
+   printf(stdout, "exec test\n");
+   if(exec("echo", echoargv) < 0){
+     printf(stdout, "exec echo failed\n");
+-    exit(151);
++    exit();
+   }
+ }
+ 
+@@ -310,7 +310,7 @@ pipe1(void)
+ 
+   if(pipe(fds) != 0){
+     printf(1, "pipe() failed\n");
+-    exit(150);
++    exit();
+   }
+   pid = fork();
+   seq = 0;
+@@ -321,10 +321,10 @@ pipe1(void)
+         buf[i] = seq++;
+       if(write(fds[1], buf, 1033) != 1033){
+         printf(1, "pipe1 oops 1\n");
+-        exit(149);
++        exit();
+       }
+     }
+-    exit(148);
++    exit();
+   } else if(pid > 0){
+     close(fds[1]);
+     total = 0;
+@@ -343,13 +343,13 @@ pipe1(void)
+     }
+     if(total != 5 * 1033){
+       printf(1, "pipe1 oops 3 total %d\n", total);
+-      exit(147);
++      exit();
+     }
+     close(fds[0]);
+-    wait(NULL);
++    wait();
+   } else {
+     printf(1, "fork() failed\n");
+-    exit(146);
++    exit();
+   }
+   printf(1, "pipe1 ok\n");
+ }
+@@ -394,9 +394,9 @@ preempt(void)
+   kill(pid2);
+   kill(pid3);
+   printf(1, "wait... ");
+-  wait(NULL);
+-  wait(NULL);
+-  wait(NULL);
++  wait();
++  wait();
++  wait();
+   printf(1, "preempt ok\n");
+ }
+ 
+@@ -413,12 +413,12 @@ exitwait(void)
+       return;
+     }
+     if(pid){
+-      if(wait(NULL) != pid){
++      if(wait() != pid){
+         printf(1, "wait wrong pid\n");
+         return;
+       }
+     } else {
+-      exit(145);
++      exit();
+     }
+   }
+   printf(1, "exitwait ok\n");
+@@ -447,13 +447,13 @@ mem(void)
+     if(m1 == 0){
+       printf(1, "couldn't allocate mem?!!\n");
+       kill(ppid);
+-      exit(144);
++      exit();
+     }
+     free(m1);
+     printf(1, "mem ok\n");
+-    exit(0);
++    exit();
+   } else {
+-    wait(NULL);
++    wait();
+   }
+ }
+ 
+@@ -484,9 +484,9 @@ sharedfd(void)
+     }
+   }
+   if(pid == 0)
+-    exit(142);
++    exit();
+   else
+-    wait(NULL);
++    wait();
+   close(fd);
+   fd = open("sharedfd", 0);
+   if(fd < 0){
+@@ -508,7 +508,7 @@ sharedfd(void)
+     printf(1, "sharedfd ok\n");
+   } else {
+     printf(1, "sharedfd oops %d %d\n", nc, np);
+-    exit(141);
++    exit();
+   }
+ }
+ 
+@@ -530,29 +530,29 @@ fourfiles(void)
+     pid = fork();
+     if(pid < 0){
+       printf(1, "fork failed\n");
+-      exit(140);
++      exit();
+     }
+ 
+     if(pid == 0){
+       fd = open(fname, O_CREATE | O_RDWR);
+       if(fd < 0){
+         printf(1, "create failed\n");
+-        exit(139);
++        exit();
+       }
+ 
+       memset(buf, '0'+pi, 512);
+       for(i = 0; i < 12; i++){
+         if((n = write(fd, buf, 500)) != 500){
+           printf(1, "write failed %d\n", n);
+-          exit(138);
++          exit();
+         }
+       }
+-      exit(137);
++      exit();
+     }
+   }
+ 
+   for(pi = 0; pi < 4; pi++){
+-    wait(NULL);
++    wait();
+   }
+ 
+   for(i = 0; i < 2; i++){
+@@ -563,7 +563,7 @@ fourfiles(void)
+       for(j = 0; j < n; j++){
+         if(buf[j] != '0'+i){
+           printf(1, "wrong char\n");
+-          exit(136);
++          exit();
+         }
+       }
+       total += n;
+@@ -571,7 +571,7 @@ fourfiles(void)
+     close(fd);
+     if(total != 12*500){
+       printf(1, "wrong length %d\n", total);
+-      exit(135);
++      exit();
+     }
+     unlink(fname);
+   }
+@@ -593,7 +593,7 @@ createdelete(void)
+     pid = fork();
+     if(pid < 0){
+       printf(1, "fork failed\n");
+-      exit(134);
++      exit();
+     }
+ 
+     if(pid == 0){
+@@ -604,23 +604,23 @@ createdelete(void)
+         fd = open(name, O_CREATE | O_RDWR);
+         if(fd < 0){
+           printf(1, "create failed\n");
+-          exit(133);
++          exit();
+         }
+         close(fd);
+         if(i > 0 && (i % 2 ) == 0){
+           name[1] = '0' + (i / 2);
+           if(unlink(name) < 0){
+             printf(1, "unlink failed\n");
+-            exit(132);
++            exit();
+           }
+         }
+       }
+-      exit(131);
++      exit();
+     }
+   }
+ 
+   for(pi = 0; pi < 4; pi++){
+-    wait(NULL);
++    wait();
+   }
+ 
+   name[0] = name[1] = name[2] = 0;
+@@ -631,10 +631,10 @@ createdelete(void)
+       fd = open(name, 0);
+       if((i == 0 || i >= N/2) && fd < 0){
+         printf(1, "oops createdelete %s didn't exist\n", name);
+-        exit(130);
++        exit();
+       } else if((i >= 1 && i < N/2) && fd >= 0){
+         printf(1, "oops createdelete %s did exist\n", name);
+-        exit(129);
++        exit();
+       }
+       if(fd >= 0)
+         close(fd);
+@@ -662,7 +662,7 @@ unlinkread(void)
+   fd = open("unlinkread", O_CREATE | O_RDWR);
+   if(fd < 0){
+     printf(1, "create unlinkread failed\n");
+-    exit(128);
++    exit();
+   }
+   write(fd, "hello", 5);
+   close(fd);
+@@ -670,11 +670,11 @@ unlinkread(void)
+   fd = open("unlinkread", O_RDWR);
+   if(fd < 0){
+     printf(1, "open unlinkread failed\n");
+-    exit(127);
++    exit();
+   }
+   if(unlink("unlinkread") != 0){
+     printf(1, "unlink unlinkread failed\n");
+-    exit(126);
++    exit();
+   }
+ 
+   fd1 = open("unlinkread", O_CREATE | O_RDWR);
+@@ -683,15 +683,15 @@ unlinkread(void)
+ 
+   if(read(fd, buf, sizeof(buf)) != 5){
+     printf(1, "unlinkread read failed");
+-    exit(125);
++    exit();
+   }
+   if(buf[0] != 'h'){
+     printf(1, "unlinkread wrong data\n");
+-    exit(124);
++    exit();
+   }
+   if(write(fd, buf, 10) != 10){
+     printf(1, "unlinkread write failed\n");
+-    exit(123);
++    exit();
+   }
+   close(fd);
+   unlink("unlinkread");
+@@ -711,50 +711,50 @@ linktest(void)
+   fd = open("lf1", O_CREATE|O_RDWR);
+   if(fd < 0){
+     printf(1, "create lf1 failed\n");
+-    exit(122);
++    exit();
+   }
+   if(write(fd, "hello", 5) != 5){
+     printf(1, "write lf1 failed\n");
+-    exit(121);
++    exit();
+   }
+   close(fd);
+ 
+   if(link("lf1", "lf2") < 0){
+     printf(1, "link lf1 lf2 failed\n");
+-    exit(120);
++    exit();
+   }
+   unlink("lf1");
+ 
+   if(open("lf1", 0) >= 0){
+     printf(1, "unlinked lf1 but it is still there!\n");
+-    exit(119);
++    exit();
+   }
+ 
+   fd = open("lf2", 0);
+   if(fd < 0){
+     printf(1, "open lf2 failed\n");
+-    exit(118);
++    exit();
+   }
+   if(read(fd, buf, sizeof(buf)) != 5){
+     printf(1, "read lf2 failed\n");
+-    exit(117);
++    exit();
+   }
+   close(fd);
+ 
+   if(link("lf2", "lf2") >= 0){
+     printf(1, "link lf2 lf2 succeeded! oops\n");
+-    exit(116);
++    exit();
+   }
+ 
+   unlink("lf2");
+   if(link("lf2", "lf1") >= 0){
+     printf(1, "link non-existant succeeded! oops\n");
+-    exit(115);
++    exit();
+   }
+ 
+   if(link(".", "lf1") >= 0){
+     printf(1, "link . lf1 succeeded! oops\n");
+-    exit(114);
++    exit();
+   }
+ 
+   printf(1, "linktest ok\n");
+@@ -787,14 +787,14 @@ concreate(void)
+       fd = open(file, O_CREATE | O_RDWR);
+       if(fd < 0){
+         printf(1, "concreate create %s failed\n", file);
+-        exit(113);
++        exit();
+       }
+       close(fd);
+     }
+     if(pid == 0)
+-      exit(112);
++      exit();
+     else
+-      wait(NULL);
++      wait();
+   }
+ 
+   memset(fa, 0, sizeof(fa));
+@@ -807,11 +807,11 @@ concreate(void)
+       i = de.name[1] - '0';
+       if(i < 0 || i >= sizeof(fa)){
+         printf(1, "concreate weird file %s\n", de.name);
+-        exit(111);
++        exit();
+       }
+       if(fa[i]){
+         printf(1, "concreate duplicate file %s\n", de.name);
+-        exit(110);
++        exit();
+       }
+       fa[i] = 1;
+       n++;
+@@ -821,7 +821,7 @@ concreate(void)
+ 
+   if(n != 40){
+     printf(1, "concreate not enough files in directory listing\n");
+-    exit(109);
++    exit();
+   }
+ 
+   for(i = 0; i < 40; i++){
+@@ -829,7 +829,7 @@ concreate(void)
+     pid = fork();
+     if(pid < 0){
+       printf(1, "fork failed\n");
+-      exit(108);
++      exit();
+     }
+     if(((i % 3) == 0 && pid == 0) ||
+        ((i % 3) == 1 && pid != 0)){
+@@ -844,9 +844,9 @@ concreate(void)
+       unlink(file);
+     }
+     if(pid == 0)
+-      exit(107);
++      exit();
+     else
+-      wait(NULL);
++      wait();
+   }
+ 
+   printf(1, "concreate ok\n");
+@@ -865,7 +865,7 @@ linkunlink()
+   pid = fork();
+   if(pid < 0){
+     printf(1, "fork failed\n");
+-    exit(106);
++    exit();
+   }
+ 
+   unsigned int x = (pid ? 1 : 97);
+@@ -881,9 +881,9 @@ linkunlink()
+   }
+ 
+   if(pid)
+-    wait(NULL);
++    wait();
+   else
+-    exit(105);
++    exit();
+ 
+   printf(1, "linkunlink ok\n");
+ }
+@@ -901,7 +901,7 @@ bigdir(void)
+   fd = open("bd", O_CREATE);
+   if(fd < 0){
+     printf(1, "bigdir create failed\n");
+-    exit(104);
++    exit();
+   }
+   close(fd);
+ 
+@@ -912,7 +912,7 @@ bigdir(void)
+     name[3] = '\0';
+     if(link("bd", name) != 0){
+       printf(1, "bigdir link failed\n");
+-      exit(103);
++      exit();
+     }
+   }
+ 
+@@ -924,7 +924,7 @@ bigdir(void)
+     name[3] = '\0';
+     if(unlink(name) != 0){
+       printf(1, "bigdir unlink failed");
+-      exit(102);
++      exit();
+     }
+   }
+ 
+@@ -941,31 +941,31 @@ subdir(void)
+   unlink("ff");
+   if(mkdir("dd") != 0){
+     printf(1, "subdir mkdir dd failed\n");
+-    exit(101);
++    exit();
+   }
+ 
+   fd = open("dd/ff", O_CREATE | O_RDWR);
+   if(fd < 0){
+     printf(1, "create dd/ff failed\n");
+-    exit(100);
++    exit();
+   }
+   write(fd, "ff", 2);
+   close(fd);
+ 
+   if(unlink("dd") >= 0){
+     printf(1, "unlink dd (non-empty dir) succeeded!\n");
+-    exit(99);
++    exit();
+   }
+ 
+   if(mkdir("/dd/dd") != 0){
+     printf(1, "subdir mkdir dd/dd failed\n");
+-    exit(98);
++    exit();
+   }
+ 
+   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+   if(fd < 0){
+     printf(1, "create dd/dd/ff failed\n");
+-    exit(97);
++    exit();
+   }
+   write(fd, "FF", 2);
+   close(fd);
+@@ -973,142 +973,142 @@ subdir(void)
+   fd = open("dd/dd/../ff", 0);
+   if(fd < 0){
+     printf(1, "open dd/dd/../ff failed\n");
+-    exit(96);
++    exit();
+   }
+   cc = read(fd, buf, sizeof(buf));
+   if(cc != 2 || buf[0] != 'f'){
+     printf(1, "dd/dd/../ff wrong content\n");
+-    exit(95);
++    exit();
+   }
+   close(fd);
+ 
+   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+-    exit(94);
++    exit();
+   }
+ 
+   if(unlink("dd/dd/ff") != 0){
+     printf(1, "unlink dd/dd/ff failed\n");
+-    exit(93);
++    exit();
+   }
+   if(open("dd/dd/ff", O_RDONLY) >= 0){
+     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+-    exit(92);
++    exit();
+   }
+ 
+   if(chdir("dd") != 0){
+     printf(1, "chdir dd failed\n");
+-    exit(91);
++    exit();
+   }
+   if(chdir("dd/../../dd") != 0){
+     printf(1, "chdir dd/../../dd failed\n");
+-    exit(90);
++    exit();
+   }
+   if(chdir("dd/../../../dd") != 0){
+     printf(1, "chdir dd/../../dd failed\n");
+-    exit(89);
++    exit();
+   }
+   if(chdir("./..") != 0){
+     printf(1, "chdir ./.. failed\n");
+-    exit(88);
++    exit();
+   }
+ 
+   fd = open("dd/dd/ffff", 0);
+   if(fd < 0){
+     printf(1, "open dd/dd/ffff failed\n");
+-    exit(87);
++    exit();
+   }
+   if(read(fd, buf, sizeof(buf)) != 2){
+     printf(1, "read dd/dd/ffff wrong len\n");
+-    exit(86);
++    exit();
+   }
+   close(fd);
+ 
+   if(open("dd/dd/ff", O_RDONLY) >= 0){
+     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+-    exit(0);
++    exit();
+   }
+ 
+   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+     printf(1, "create dd/ff/ff succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+     printf(1, "create dd/xx/ff succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(open("dd", O_CREATE) >= 0){
+     printf(1, "create dd succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(open("dd", O_RDWR) >= 0){
+     printf(1, "open dd rdwr succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(open("dd", O_WRONLY) >= 0){
+     printf(1, "open dd wronly succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(link("dd/ff/ff", "dd/dd/xx") == 0){
+     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(link("dd/xx/ff", "dd/dd/xx") == 0){
+     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(link("dd/ff", "dd/dd/ffff") == 0){
+     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(mkdir("dd/ff/ff") == 0){
+     printf(1, "mkdir dd/ff/ff succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(mkdir("dd/xx/ff") == 0){
+     printf(1, "mkdir dd/xx/ff succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(mkdir("dd/dd/ffff") == 0){
+     printf(1, "mkdir dd/dd/ffff succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(unlink("dd/xx/ff") == 0){
+     printf(1, "unlink dd/xx/ff succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(unlink("dd/ff/ff") == 0){
+     printf(1, "unlink dd/ff/ff succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(chdir("dd/ff") == 0){
+     printf(1, "chdir dd/ff succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(chdir("dd/xx") == 0){
+     printf(1, "chdir dd/xx succeeded!\n");
+-    exit(0);
++    exit();
+   }
+ 
+   if(unlink("dd/dd/ffff") != 0){
+     printf(1, "unlink dd/dd/ff failed\n");
+-    exit(68);
++    exit();
+   }
+   if(unlink("dd/ff") != 0){
+     printf(1, "unlink dd/ff failed\n");
+-    exit(67);
++    exit();
+   }
+   if(unlink("dd") == 0){
+     printf(1, "unlink non-empty dd succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(unlink("dd/dd") < 0){
+     printf(1, "unlink dd/dd failed\n");
+-    exit(65);
++    exit();
+   }
+   if(unlink("dd") < 0){
+     printf(1, "unlink dd failed\n");
+-    exit(64);
++    exit();
+   }
+ 
+   printf(1, "subdir ok\n");
+@@ -1127,14 +1127,14 @@ bigwrite(void)
+     fd = open("bigwrite", O_CREATE | O_RDWR);
+     if(fd < 0){
+       printf(1, "cannot create bigwrite\n");
+-      exit(63);
++      exit();
+     }
+     int i;
+     for(i = 0; i < 2; i++){
+       int cc = write(fd, buf, sz);
+       if(cc != sz){
+         printf(1, "write(%d) ret %d\n", sz, cc);
+-        exit(62);
++        exit();
+       }
+     }
+     close(fd);
+@@ -1155,13 +1155,13 @@ bigfile(void)
+   fd = open("bigfile", O_CREATE | O_RDWR);
+   if(fd < 0){
+     printf(1, "cannot create bigfile");
+-    exit(61);
++    exit();
+   }
+   for(i = 0; i < 20; i++){
+     memset(buf, i, 600);
+     if(write(fd, buf, 600) != 600){
+       printf(1, "write bigfile failed\n");
+-      exit(60);
++      exit();
+     }
+   }
+   close(fd);
+@@ -1169,31 +1169,31 @@ bigfile(void)
+   fd = open("bigfile", 0);
+   if(fd < 0){
+     printf(1, "cannot open bigfile\n");
+-    exit(59);
++    exit();
+   }
+   total = 0;
+   for(i = 0; ; i++){
+     cc = read(fd, buf, 300);
+     if(cc < 0){
+       printf(1, "read bigfile failed\n");
+-      exit(58);
++      exit();
+     }
+     if(cc == 0)
+       break;
+     if(cc != 300){
+       printf(1, "short read bigfile\n");
+-      exit(57);
++      exit();
+     }
+     if(buf[0] != i/2 || buf[299] != i/2){
+       printf(1, "read bigfile wrong data\n");
+-      exit(56);
++      exit();
+     }
+     total += cc;
+   }
+   close(fd);
+   if(total != 20*600){
+     printf(1, "read bigfile wrong total\n");
+-    exit(55);
++    exit();
+   }
+   unlink("bigfile");
+ 
+@@ -1210,32 +1210,32 @@ fourteen(void)
+ 
+   if(mkdir("12345678901234") != 0){
+     printf(1, "mkdir 12345678901234 failed\n");
+-    exit(54);
++    exit();
+   }
+   if(mkdir("12345678901234/123456789012345") != 0){
+     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+-    exit(53);
++    exit();
+   }
+   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+   if(fd < 0){
+     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+-    exit(52);
++    exit();
+   }
+   close(fd);
+   fd = open("12345678901234/12345678901234/12345678901234", 0);
+   if(fd < 0){
+     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+-    exit(51);
++    exit();
+   }
+   close(fd);
+ 
+   if(mkdir("12345678901234/12345678901234") == 0){
+     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(mkdir("123456789012345/12345678901234") == 0){
+     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+-    exit(0);
++    exit();
+   }
+ 
+   printf(1, "fourteen ok\n");
+@@ -1247,35 +1247,35 @@ rmdot(void)
+   printf(1, "rmdot test\n");
+   if(mkdir("dots") != 0){
+     printf(1, "mkdir dots failed\n");
+-    exit(48);
++    exit();
+   }
+   if(chdir("dots") != 0){
+     printf(1, "chdir dots failed\n");
+-    exit(47);
++    exit();
+   }
+   if(unlink(".") == 0){
+     printf(1, "rm . worked!\n");
+-    exit(0);
++    exit();
+   }
+   if(unlink("..") == 0){
+     printf(1, "rm .. worked!\n");
+-    exit(0);
++    exit();
+   }
+   if(chdir("/") != 0){
+     printf(1, "chdir / failed\n");
+-    exit(44);
++    exit();
+   }
+   if(unlink("dots/.") == 0){
+     printf(1, "unlink dots/. worked!\n");
+-    exit(0);
++    exit();
+   }
+   if(unlink("dots/..") == 0){
+     printf(1, "unlink dots/.. worked!\n");
+-    exit(0);
++    exit();
+   }
+   if(unlink("dots") != 0){
+     printf(1, "unlink dots failed!\n");
+-    exit(41);
++    exit();
+   }
+   printf(1, "rmdot ok\n");
+ }
+@@ -1290,49 +1290,49 @@ dirfile(void)
+   fd = open("dirfile", O_CREATE);
+   if(fd < 0){
+     printf(1, "create dirfile failed\n");
+-    exit(40);
++    exit();
+   }
+   close(fd);
+   if(chdir("dirfile") == 0){
+     printf(1, "chdir dirfile succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   fd = open("dirfile/xx", 0);
+   if(fd >= 0){
+     printf(1, "create dirfile/xx succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   fd = open("dirfile/xx", O_CREATE);
+   if(fd >= 0){
+     printf(1, "create dirfile/xx succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(mkdir("dirfile/xx") == 0){
+     printf(1, "mkdir dirfile/xx succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(unlink("dirfile/xx") == 0){
+     printf(1, "unlink dirfile/xx succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(link("README", "dirfile/xx") == 0){
+     printf(1, "link to dirfile/xx succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   if(unlink("dirfile") != 0){
+     printf(1, "unlink dirfile failed!\n");
+-    exit(33);
++    exit();
+   }
+ 
+   fd = open(".", O_RDWR);
+   if(fd >= 0){
+     printf(1, "open . for writing succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   fd = open(".", 0);
+   if(write(fd, "x", 1) > 0){
+     printf(1, "write . succeeded!\n");
+-    exit(0);
++    exit();
+   }
+   close(fd);
+ 
+@@ -1351,11 +1351,11 @@ iref(void)
+   for(i = 0; i < 50 + 1; i++){
+     if(mkdir("irefd") != 0){
+       printf(1, "mkdir irefd failed\n");
+-      exit(30);
++      exit();
+     }
+     if(chdir("irefd") != 0){
+       printf(1, "chdir irefd failed\n");
+-      exit(29);
++      exit();
+     }
+ 
+     mkdir("");
+@@ -1388,24 +1388,24 @@ forktest(void)
+     if(pid < 0)
+       break;
+     if(pid == 0)
+-      exit(28);
++      exit();
+   }
+ 
+   if(n == 1000){
+     printf(1, "fork claimed to work 1000 times!\n");
+-    exit(27);
++    exit();
+   }
+ 
+   for(; n > 0; n--){
+-    if(wait(NULL) < 0){
++    if(wait() < 0){
+       printf(1, "wait stopped early\n");
+-      exit(26);
++      exit();
+     }
+   }
+ 
+-  if(wait(NULL) != -1){
++  if(wait() != -1){
+     printf(1, "wait got too many\n");
+-    exit(25);
++    exit();
+   }
+ 
+   printf(1, "fork test OK\n");
+@@ -1428,7 +1428,7 @@ sbrktest(void)
+     b = sbrk(1);
+     if(b != a){
+       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+-      exit(24);
++      exit();
+     }
+     *b = 1;
+     a = b + 1;
+@@ -1436,17 +1436,17 @@ sbrktest(void)
+   pid = fork();
+   if(pid < 0){
+     printf(stdout, "sbrk test fork failed\n");
+-    exit(23);
++    exit();
+   }
+   c = sbrk(1);
+   c = sbrk(1);
+   if(c != a + 1){
+     printf(stdout, "sbrk test failed post-fork\n");
+-    exit(22);
++    exit();
+   }
+   if(pid == 0)
+-    exit(21);
+-  wait(NULL);
++    exit();
++  wait();
+ 
+   // can one grow address space to something big?
+ #define BIG (100*1024*1024)
+@@ -1455,7 +1455,7 @@ sbrktest(void)
+   p = sbrk(amt);
+   if (p != a) {
+     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+-    exit(20);
++    exit();
+   }
+   lastaddr = (char*) (BIG-1);
+   *lastaddr = 99;
+@@ -1465,12 +1465,12 @@ sbrktest(void)
+   c = sbrk(-4096);
+   if(c == (char*)0xffffffff){
+     printf(stdout, "sbrk could not deallocate\n");
+-    exit(19);
++    exit();
+   }
+   c = sbrk(0);
+   if(c != a - 4096){
+     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+-    exit(18);
++    exit();
+   }
+ 
+   // can one re-allocate that page?
+@@ -1478,19 +1478,19 @@ sbrktest(void)
+   c = sbrk(4096);
+   if(c != a || sbrk(0) != a + 4096){
+     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+-    exit(17);
++    exit();
+   }
+   if(*lastaddr == 99){
+     // should be zero
+     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+-    exit(16);
++    exit();
+   }
+ 
+   a = sbrk(0);
+   c = sbrk(-(sbrk(0) - oldbrk));
+   if(c != a){
+     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+-    exit(15);
++    exit();
+   }
+ 
+   // can we read the kernel's memory?
+@@ -1499,21 +1499,21 @@ sbrktest(void)
+     pid = fork();
+     if(pid < 0){
+       printf(stdout, "fork failed\n");
+-      exit(14);
++      exit();
+     }
+     if(pid == 0){
+       printf(stdout, "oops could read %x = %x\n", a, *a);
+       kill(ppid);
+-      exit(13);
++      exit();
+     }
+-    wait(NULL);
++    wait();
+   }
+ 
+   // if we run the system out of memory, does it clean up the last
+   // failed allocation?
+   if(pipe(fds) != 0){
+     printf(1, "pipe() failed\n");
+-    exit(12);
++    exit();
+   }
+   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+     if((pids[i] = fork()) == 0){
+@@ -1533,11 +1533,11 @@ sbrktest(void)
+     if(pids[i] == -1)
+       continue;
+     kill(pids[i]);
+-    wait(NULL);
++    wait();
+   }
+   if(c == (char*)0xffffffff){
+     printf(stdout, "failed sbrk leaked memory\n");
+-    exit(10);
++    exit();
+   }
+ 
+   if(sbrk(0) > oldbrk)
+@@ -1572,17 +1572,17 @@ validatetest(void)
+     if((pid = fork()) == 0){
+       // try to crash the kernel by passing in a badly placed integer
+       validateint((int*)p);
+-      exit(9);
++      exit();
+     }
+     sleep(0);
+     sleep(0);
+     kill(pid);
+-    wait(NULL);
++    wait();
+ 
+     // try to crash the kernel by passing in a bad string pointer
+     if(link("nosuchfile", (char*)p) != -1){
+       printf(stdout, "link should not succeed\n");
+-      exit(8);
++      exit();
+     }
+   }
+ 
+@@ -1600,7 +1600,7 @@ bsstest(void)
+   for(i = 0; i < sizeof(uninit); i++){
+     if(uninit[i] != '\0'){
+       printf(stdout, "bss test failed\n");
+-      exit(7);
++      exit();
+     }
+   }
+   printf(stdout, "bss test ok\n");
+@@ -1627,16 +1627,16 @@ bigargtest(void)
+     printf(stdout, "bigarg test ok\n");
+     fd = open("bigarg-ok", O_CREATE);
+     close(fd);
+-    exit(6);
++    exit();
+   } else if(pid < 0){
+     printf(stdout, "bigargtest: fork failed\n");
+-    exit(5);
++    exit();
+   }
+-  wait(NULL);
++  wait();
+   fd = open("bigarg-ok", 0);
+   if(fd < 0){
+     printf(stdout, "bigarg test failed!\n");
+-    exit(4);
++    exit();
+   }
+   close(fd);
+   unlink("bigarg-ok");
+@@ -1715,12 +1715,12 @@ uio()
+     port = RTC_DATA;
+     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+     printf(1, "uio: uio succeeded; test FAILED\n");
+-    exit(3);
++    exit();
+   } else if(pid < 0){
+     printf (1, "fork failed\n");
+-    exit(2);
++    exit();
+   }
+-  wait(NULL);
++  wait();
+   printf(1, "uio test done\n");
+ }
+ 
+@@ -1730,7 +1730,7 @@ void argptest()
+   fd = open("init", O_RDONLY);
+   if (fd < 0) {
+     printf(2, "open failed\n");
+-    exit(1);
++    exit();
+   }
+   read(fd, sbrk(0) - 1, -1);
+   close(fd);
+@@ -1752,7 +1752,7 @@ main(int argc, char *argv[])
+ 
+   if(open("usertests.ran", 0) >= 0){
+     printf(1, "already ran user tests -- rebuild fs.img\n");
+-    exit(1);
++    exit();
+   }
+   close(open("usertests.ran", O_CREATE));
+ 
+@@ -1799,5 +1799,5 @@ main(int argc, char *argv[])
+ 
+   exectest();
+ 
+-  exit(0);
++  exit();
+ }
+diff --git a/usys.S b/usys.S
+index 1687ed0..8bfd8a1 100644
+--- a/usys.S
++++ b/usys.S
+@@ -11,7 +11,6 @@
+ SYSCALL(fork)
+ SYSCALL(exit)
+ SYSCALL(wait)
+-SYSCALL(waitpid)
+ SYSCALL(pipe)
+ SYSCALL(read)
+ SYSCALL(write)
+diff --git a/wc.c b/wc.c
+index 08b93b6..d6a54df 100644
+--- a/wc.c
++++ b/wc.c
+@@ -27,7 +27,7 @@ wc(int fd, char *name)
+   }
+   if(n < 0){
+     printf(1, "wc: read error\n");
+-    exit(3);
++    exit();
+   }
+   printf(1, "%d %d %d %s\n", l, w, c, name);
+ }
+@@ -39,16 +39,16 @@ main(int argc, char *argv[])
+ 
+   if(argc <= 1){
+     wc(0, "");
+-    exit(2);
++    exit();
+   }
+ 
+   for(i = 1; i < argc; i++){
+     if((fd = open(argv[i], 0)) < 0){
+       printf(1, "wc: cannot open %s\n", argv[i]);
+-      exit(1);
++      exit();
+     }
+     wc(fd, argv[i]);
+     close(fd);
+   }
+-  exit(0);
++  exit();
+ }
+diff --git a/zombie.c b/zombie.c
+index c96b92d..ee817da 100644
+--- a/zombie.c
++++ b/zombie.c
+@@ -10,5 +10,5 @@ main(void)
+ {
+   if(fork() > 0)
+     sleep(5);  // Let child exit before parent.
+-  exit(0);
++  exit();
+ }
diff --git a/console.d b/console.d
new file mode 100644
index 0000000..7b5564c
--- /dev/null
+++ b/console.d
@@ -0,0 +1,3 @@
+console.o: console.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ traps.h spinlock.h sleeplock.h fs.h file.h memlayout.h mmu.h proc.h \
+ x86.h
diff --git a/console.o b/console.o
new file mode 100644
index 0000000..2d077bf
Binary files /dev/null and b/console.o differ
diff --git a/defs.h b/defs.h
index d1934ca..5b36aac 100644
--- a/defs.h
+++ b/defs.h
@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
 //PAGEBREAK: 16
 // proc.c
 int             cpuid(void);
-void            exit(int status);
+void            exit(void);
 int             fork(void);
 int             growproc(int);
 int             kill(int);
@@ -117,8 +117,7 @@ void            sched(void);
 void            setproc(struct proc*);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
-int             wait(int* status);
-int             waitpid(int pid, int* status, int options);
+int             wait(void);
 void            wakeup(void*);
 void            yield(void);
 
@@ -181,11 +180,23 @@ int             deallocuvm(pde_t*, uint, uint);
 void            freevm(pde_t*);
 void            inituvm(pde_t*, char*, uint);
 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
-pde_t*          copyuvm(pde_t*, uint);
+pde_t*          copyuvm(pde_t*, uint, uint);
 void            switchuvm(struct proc*);
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
+int             growstack(pde_t *pgdir, uint sp, uint topStack);
+void            setpteu(pde_t *pgdir, char *uva);
+
+
+//made mappages visible (and removed static) to facilitate implementing shm
+int
+mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm);
+
+//shm.c
+void shminit(void);
+int shm_open(int id, char **pointer);
+int shm_close(int id);
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/echo.asm b/echo.asm
new file mode 100644
index 0000000..46b5f43
--- /dev/null
+++ b/echo.asm
@@ -0,0 +1,1220 @@
+
+_echo:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	57                   	push   %edi
+    1004:	56                   	push   %esi
+    1005:	53                   	push   %ebx
+    1006:	83 e4 f0             	and    $0xfffffff0,%esp
+    1009:	83 ec 10             	sub    $0x10,%esp
+    100c:	8b 75 08             	mov    0x8(%ebp),%esi
+    100f:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  int i;
+
+  for(i = 1; i < argc; i++)
+    1012:	83 fe 01             	cmp    $0x1,%esi
+    1015:	7e 58                	jle    106f <main+0x6f>
+    1017:	bb 01 00 00 00       	mov    $0x1,%ebx
+    101c:	eb 26                	jmp    1044 <main+0x44>
+    101e:	66 90                	xchg   %ax,%ax
+    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+    1020:	c7 44 24 0c a1 17 00 	movl   $0x17a1,0xc(%esp)
+    1027:	00 
+    1028:	8b 44 9f fc          	mov    -0x4(%edi,%ebx,4),%eax
+    102c:	c7 44 24 04 a3 17 00 	movl   $0x17a3,0x4(%esp)
+    1033:	00 
+    1034:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    103b:	89 44 24 08          	mov    %eax,0x8(%esp)
+    103f:	e8 bc 03 00 00       	call   1400 <printf>
+    1044:	83 c3 01             	add    $0x1,%ebx
+    1047:	39 f3                	cmp    %esi,%ebx
+    1049:	75 d5                	jne    1020 <main+0x20>
+    104b:	c7 44 24 0c a8 17 00 	movl   $0x17a8,0xc(%esp)
+    1052:	00 
+    1053:	8b 44 9f fc          	mov    -0x4(%edi,%ebx,4),%eax
+    1057:	c7 44 24 04 a3 17 00 	movl   $0x17a3,0x4(%esp)
+    105e:	00 
+    105f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1066:	89 44 24 08          	mov    %eax,0x8(%esp)
+    106a:	e8 91 03 00 00       	call   1400 <printf>
+  exit();
+    106f:	e8 2e 02 00 00       	call   12a2 <exit>
+    1074:	66 90                	xchg   %ax,%ax
+    1076:	66 90                	xchg   %ax,%ax
+    1078:	66 90                	xchg   %ax,%ax
+    107a:	66 90                	xchg   %ax,%ax
+    107c:	66 90                	xchg   %ax,%ax
+    107e:	66 90                	xchg   %ax,%ax
+
+00001080 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1080:	55                   	push   %ebp
+    1081:	89 e5                	mov    %esp,%ebp
+    1083:	8b 45 08             	mov    0x8(%ebp),%eax
+    1086:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1089:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    108a:	89 c2                	mov    %eax,%edx
+    108c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1090:	83 c1 01             	add    $0x1,%ecx
+    1093:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1097:	83 c2 01             	add    $0x1,%edx
+    109a:	84 db                	test   %bl,%bl
+    109c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    109f:	75 ef                	jne    1090 <strcpy+0x10>
+    ;
+  return os;
+}
+    10a1:	5b                   	pop    %ebx
+    10a2:	5d                   	pop    %ebp
+    10a3:	c3                   	ret    
+    10a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    10aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+000010b0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    10b0:	55                   	push   %ebp
+    10b1:	89 e5                	mov    %esp,%ebp
+    10b3:	8b 55 08             	mov    0x8(%ebp),%edx
+    10b6:	53                   	push   %ebx
+    10b7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    10ba:	0f b6 02             	movzbl (%edx),%eax
+    10bd:	84 c0                	test   %al,%al
+    10bf:	74 2d                	je     10ee <strcmp+0x3e>
+    10c1:	0f b6 19             	movzbl (%ecx),%ebx
+    10c4:	38 d8                	cmp    %bl,%al
+    10c6:	74 0e                	je     10d6 <strcmp+0x26>
+    10c8:	eb 2b                	jmp    10f5 <strcmp+0x45>
+    10ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    10d0:	38 c8                	cmp    %cl,%al
+    10d2:	75 15                	jne    10e9 <strcmp+0x39>
+    p++, q++;
+    10d4:	89 d9                	mov    %ebx,%ecx
+    10d6:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    10d9:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    10dc:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    10df:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    10e3:	84 c0                	test   %al,%al
+    10e5:	75 e9                	jne    10d0 <strcmp+0x20>
+    10e7:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    10e9:	29 c8                	sub    %ecx,%eax
+}
+    10eb:	5b                   	pop    %ebx
+    10ec:	5d                   	pop    %ebp
+    10ed:	c3                   	ret    
+    10ee:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    10f1:	31 c0                	xor    %eax,%eax
+    10f3:	eb f4                	jmp    10e9 <strcmp+0x39>
+    10f5:	0f b6 cb             	movzbl %bl,%ecx
+    10f8:	eb ef                	jmp    10e9 <strcmp+0x39>
+    10fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001100 <strlen>:
+
+uint
+strlen(char *s)
+{
+    1100:	55                   	push   %ebp
+    1101:	89 e5                	mov    %esp,%ebp
+    1103:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    1106:	80 39 00             	cmpb   $0x0,(%ecx)
+    1109:	74 12                	je     111d <strlen+0x1d>
+    110b:	31 d2                	xor    %edx,%edx
+    110d:	8d 76 00             	lea    0x0(%esi),%esi
+    1110:	83 c2 01             	add    $0x1,%edx
+    1113:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    1117:	89 d0                	mov    %edx,%eax
+    1119:	75 f5                	jne    1110 <strlen+0x10>
+    ;
+  return n;
+}
+    111b:	5d                   	pop    %ebp
+    111c:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    111d:	31 c0                	xor    %eax,%eax
+}
+    111f:	5d                   	pop    %ebp
+    1120:	c3                   	ret    
+    1121:	eb 0d                	jmp    1130 <memset>
+    1123:	90                   	nop
+    1124:	90                   	nop
+    1125:	90                   	nop
+    1126:	90                   	nop
+    1127:	90                   	nop
+    1128:	90                   	nop
+    1129:	90                   	nop
+    112a:	90                   	nop
+    112b:	90                   	nop
+    112c:	90                   	nop
+    112d:	90                   	nop
+    112e:	90                   	nop
+    112f:	90                   	nop
+
+00001130 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    1130:	55                   	push   %ebp
+    1131:	89 e5                	mov    %esp,%ebp
+    1133:	8b 55 08             	mov    0x8(%ebp),%edx
+    1136:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    1137:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    113a:	8b 45 0c             	mov    0xc(%ebp),%eax
+    113d:	89 d7                	mov    %edx,%edi
+    113f:	fc                   	cld    
+    1140:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    1142:	89 d0                	mov    %edx,%eax
+    1144:	5f                   	pop    %edi
+    1145:	5d                   	pop    %ebp
+    1146:	c3                   	ret    
+    1147:	89 f6                	mov    %esi,%esi
+    1149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001150 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    1150:	55                   	push   %ebp
+    1151:	89 e5                	mov    %esp,%ebp
+    1153:	8b 45 08             	mov    0x8(%ebp),%eax
+    1156:	53                   	push   %ebx
+    1157:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    115a:	0f b6 18             	movzbl (%eax),%ebx
+    115d:	84 db                	test   %bl,%bl
+    115f:	74 1d                	je     117e <strchr+0x2e>
+    if(*s == c)
+    1161:	38 d3                	cmp    %dl,%bl
+    1163:	89 d1                	mov    %edx,%ecx
+    1165:	75 0d                	jne    1174 <strchr+0x24>
+    1167:	eb 17                	jmp    1180 <strchr+0x30>
+    1169:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1170:	38 ca                	cmp    %cl,%dl
+    1172:	74 0c                	je     1180 <strchr+0x30>
+  for(; *s; s++)
+    1174:	83 c0 01             	add    $0x1,%eax
+    1177:	0f b6 10             	movzbl (%eax),%edx
+    117a:	84 d2                	test   %dl,%dl
+    117c:	75 f2                	jne    1170 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    117e:	31 c0                	xor    %eax,%eax
+}
+    1180:	5b                   	pop    %ebx
+    1181:	5d                   	pop    %ebp
+    1182:	c3                   	ret    
+    1183:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1189:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001190 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1190:	55                   	push   %ebp
+    1191:	89 e5                	mov    %esp,%ebp
+    1193:	57                   	push   %edi
+    1194:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1195:	31 f6                	xor    %esi,%esi
+{
+    1197:	53                   	push   %ebx
+    1198:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    119b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    119e:	eb 31                	jmp    11d1 <gets+0x41>
+    cc = read(0, &c, 1);
+    11a0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    11a7:	00 
+    11a8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    11ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    11b3:	e8 02 01 00 00       	call   12ba <read>
+    if(cc < 1)
+    11b8:	85 c0                	test   %eax,%eax
+    11ba:	7e 1d                	jle    11d9 <gets+0x49>
+      break;
+    buf[i++] = c;
+    11bc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    11c0:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    11c2:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    11c5:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    11c7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    11cb:	74 0c                	je     11d9 <gets+0x49>
+    11cd:	3c 0a                	cmp    $0xa,%al
+    11cf:	74 08                	je     11d9 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    11d1:	8d 5e 01             	lea    0x1(%esi),%ebx
+    11d4:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    11d7:	7c c7                	jl     11a0 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    11d9:	8b 45 08             	mov    0x8(%ebp),%eax
+    11dc:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    11e0:	83 c4 2c             	add    $0x2c,%esp
+    11e3:	5b                   	pop    %ebx
+    11e4:	5e                   	pop    %esi
+    11e5:	5f                   	pop    %edi
+    11e6:	5d                   	pop    %ebp
+    11e7:	c3                   	ret    
+    11e8:	90                   	nop
+    11e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000011f0 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    11f0:	55                   	push   %ebp
+    11f1:	89 e5                	mov    %esp,%ebp
+    11f3:	56                   	push   %esi
+    11f4:	53                   	push   %ebx
+    11f5:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    11f8:	8b 45 08             	mov    0x8(%ebp),%eax
+    11fb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1202:	00 
+    1203:	89 04 24             	mov    %eax,(%esp)
+    1206:	e8 d7 00 00 00       	call   12e2 <open>
+  if(fd < 0)
+    120b:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    120d:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    120f:	78 27                	js     1238 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    1211:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1214:	89 1c 24             	mov    %ebx,(%esp)
+    1217:	89 44 24 04          	mov    %eax,0x4(%esp)
+    121b:	e8 da 00 00 00       	call   12fa <fstat>
+  close(fd);
+    1220:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    1223:	89 c6                	mov    %eax,%esi
+  close(fd);
+    1225:	e8 a0 00 00 00       	call   12ca <close>
+  return r;
+    122a:	89 f0                	mov    %esi,%eax
+}
+    122c:	83 c4 10             	add    $0x10,%esp
+    122f:	5b                   	pop    %ebx
+    1230:	5e                   	pop    %esi
+    1231:	5d                   	pop    %ebp
+    1232:	c3                   	ret    
+    1233:	90                   	nop
+    1234:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    1238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    123d:	eb ed                	jmp    122c <stat+0x3c>
+    123f:	90                   	nop
+
+00001240 <atoi>:
+
+int
+atoi(const char *s)
+{
+    1240:	55                   	push   %ebp
+    1241:	89 e5                	mov    %esp,%ebp
+    1243:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    1246:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    1247:	0f be 11             	movsbl (%ecx),%edx
+    124a:	8d 42 d0             	lea    -0x30(%edx),%eax
+    124d:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    124f:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    1254:	77 17                	ja     126d <atoi+0x2d>
+    1256:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    1258:	83 c1 01             	add    $0x1,%ecx
+    125b:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    125e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1262:	0f be 11             	movsbl (%ecx),%edx
+    1265:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1268:	80 fb 09             	cmp    $0x9,%bl
+    126b:	76 eb                	jbe    1258 <atoi+0x18>
+  return n;
+}
+    126d:	5b                   	pop    %ebx
+    126e:	5d                   	pop    %ebp
+    126f:	c3                   	ret    
+
+00001270 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1270:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1271:	31 d2                	xor    %edx,%edx
+{
+    1273:	89 e5                	mov    %esp,%ebp
+    1275:	56                   	push   %esi
+    1276:	8b 45 08             	mov    0x8(%ebp),%eax
+    1279:	53                   	push   %ebx
+    127a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    127d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1280:	85 db                	test   %ebx,%ebx
+    1282:	7e 12                	jle    1296 <memmove+0x26>
+    1284:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1288:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    128c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    128f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1292:	39 da                	cmp    %ebx,%edx
+    1294:	75 f2                	jne    1288 <memmove+0x18>
+  return vdst;
+}
+    1296:	5b                   	pop    %ebx
+    1297:	5e                   	pop    %esi
+    1298:	5d                   	pop    %ebp
+    1299:	c3                   	ret    
+
+0000129a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    129a:	b8 01 00 00 00       	mov    $0x1,%eax
+    129f:	cd 40                	int    $0x40
+    12a1:	c3                   	ret    
+
+000012a2 <exit>:
+SYSCALL(exit)
+    12a2:	b8 02 00 00 00       	mov    $0x2,%eax
+    12a7:	cd 40                	int    $0x40
+    12a9:	c3                   	ret    
+
+000012aa <wait>:
+SYSCALL(wait)
+    12aa:	b8 03 00 00 00       	mov    $0x3,%eax
+    12af:	cd 40                	int    $0x40
+    12b1:	c3                   	ret    
+
+000012b2 <pipe>:
+SYSCALL(pipe)
+    12b2:	b8 04 00 00 00       	mov    $0x4,%eax
+    12b7:	cd 40                	int    $0x40
+    12b9:	c3                   	ret    
+
+000012ba <read>:
+SYSCALL(read)
+    12ba:	b8 05 00 00 00       	mov    $0x5,%eax
+    12bf:	cd 40                	int    $0x40
+    12c1:	c3                   	ret    
+
+000012c2 <write>:
+SYSCALL(write)
+    12c2:	b8 10 00 00 00       	mov    $0x10,%eax
+    12c7:	cd 40                	int    $0x40
+    12c9:	c3                   	ret    
+
+000012ca <close>:
+SYSCALL(close)
+    12ca:	b8 15 00 00 00       	mov    $0x15,%eax
+    12cf:	cd 40                	int    $0x40
+    12d1:	c3                   	ret    
+
+000012d2 <kill>:
+SYSCALL(kill)
+    12d2:	b8 06 00 00 00       	mov    $0x6,%eax
+    12d7:	cd 40                	int    $0x40
+    12d9:	c3                   	ret    
+
+000012da <exec>:
+SYSCALL(exec)
+    12da:	b8 07 00 00 00       	mov    $0x7,%eax
+    12df:	cd 40                	int    $0x40
+    12e1:	c3                   	ret    
+
+000012e2 <open>:
+SYSCALL(open)
+    12e2:	b8 0f 00 00 00       	mov    $0xf,%eax
+    12e7:	cd 40                	int    $0x40
+    12e9:	c3                   	ret    
+
+000012ea <mknod>:
+SYSCALL(mknod)
+    12ea:	b8 11 00 00 00       	mov    $0x11,%eax
+    12ef:	cd 40                	int    $0x40
+    12f1:	c3                   	ret    
+
+000012f2 <unlink>:
+SYSCALL(unlink)
+    12f2:	b8 12 00 00 00       	mov    $0x12,%eax
+    12f7:	cd 40                	int    $0x40
+    12f9:	c3                   	ret    
+
+000012fa <fstat>:
+SYSCALL(fstat)
+    12fa:	b8 08 00 00 00       	mov    $0x8,%eax
+    12ff:	cd 40                	int    $0x40
+    1301:	c3                   	ret    
+
+00001302 <link>:
+SYSCALL(link)
+    1302:	b8 13 00 00 00       	mov    $0x13,%eax
+    1307:	cd 40                	int    $0x40
+    1309:	c3                   	ret    
+
+0000130a <mkdir>:
+SYSCALL(mkdir)
+    130a:	b8 14 00 00 00       	mov    $0x14,%eax
+    130f:	cd 40                	int    $0x40
+    1311:	c3                   	ret    
+
+00001312 <chdir>:
+SYSCALL(chdir)
+    1312:	b8 09 00 00 00       	mov    $0x9,%eax
+    1317:	cd 40                	int    $0x40
+    1319:	c3                   	ret    
+
+0000131a <dup>:
+SYSCALL(dup)
+    131a:	b8 0a 00 00 00       	mov    $0xa,%eax
+    131f:	cd 40                	int    $0x40
+    1321:	c3                   	ret    
+
+00001322 <getpid>:
+SYSCALL(getpid)
+    1322:	b8 0b 00 00 00       	mov    $0xb,%eax
+    1327:	cd 40                	int    $0x40
+    1329:	c3                   	ret    
+
+0000132a <sbrk>:
+SYSCALL(sbrk)
+    132a:	b8 0c 00 00 00       	mov    $0xc,%eax
+    132f:	cd 40                	int    $0x40
+    1331:	c3                   	ret    
+
+00001332 <sleep>:
+SYSCALL(sleep)
+    1332:	b8 0d 00 00 00       	mov    $0xd,%eax
+    1337:	cd 40                	int    $0x40
+    1339:	c3                   	ret    
+
+0000133a <uptime>:
+SYSCALL(uptime)
+    133a:	b8 0e 00 00 00       	mov    $0xe,%eax
+    133f:	cd 40                	int    $0x40
+    1341:	c3                   	ret    
+
+00001342 <shm_open>:
+SYSCALL(shm_open)
+    1342:	b8 16 00 00 00       	mov    $0x16,%eax
+    1347:	cd 40                	int    $0x40
+    1349:	c3                   	ret    
+
+0000134a <shm_close>:
+SYSCALL(shm_close)	
+    134a:	b8 17 00 00 00       	mov    $0x17,%eax
+    134f:	cd 40                	int    $0x40
+    1351:	c3                   	ret    
+    1352:	66 90                	xchg   %ax,%ax
+    1354:	66 90                	xchg   %ax,%ax
+    1356:	66 90                	xchg   %ax,%ax
+    1358:	66 90                	xchg   %ax,%ax
+    135a:	66 90                	xchg   %ax,%ax
+    135c:	66 90                	xchg   %ax,%ax
+    135e:	66 90                	xchg   %ax,%ax
+
+00001360 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1360:	55                   	push   %ebp
+    1361:	89 e5                	mov    %esp,%ebp
+    1363:	57                   	push   %edi
+    1364:	56                   	push   %esi
+    1365:	89 c6                	mov    %eax,%esi
+    1367:	53                   	push   %ebx
+    1368:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    136b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    136e:	85 db                	test   %ebx,%ebx
+    1370:	74 09                	je     137b <printint+0x1b>
+    1372:	89 d0                	mov    %edx,%eax
+    1374:	c1 e8 1f             	shr    $0x1f,%eax
+    1377:	84 c0                	test   %al,%al
+    1379:	75 75                	jne    13f0 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    137b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    137d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1384:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1387:	31 ff                	xor    %edi,%edi
+    1389:	89 ce                	mov    %ecx,%esi
+    138b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    138e:	eb 02                	jmp    1392 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1390:	89 cf                	mov    %ecx,%edi
+    1392:	31 d2                	xor    %edx,%edx
+    1394:	f7 f6                	div    %esi
+    1396:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1399:	0f b6 92 b1 17 00 00 	movzbl 0x17b1(%edx),%edx
+  }while((x /= base) != 0);
+    13a0:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    13a2:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    13a5:	75 e9                	jne    1390 <printint+0x30>
+  if(neg)
+    13a7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    13aa:	89 c8                	mov    %ecx,%eax
+    13ac:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    13af:	85 d2                	test   %edx,%edx
+    13b1:	74 08                	je     13bb <printint+0x5b>
+    buf[i++] = '-';
+    13b3:	8d 4f 02             	lea    0x2(%edi),%ecx
+    13b6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    13bb:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    13be:	66 90                	xchg   %ax,%ax
+    13c0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    13c5:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    13c8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    13cf:	00 
+    13d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    13d4:	89 34 24             	mov    %esi,(%esp)
+    13d7:	88 45 d7             	mov    %al,-0x29(%ebp)
+    13da:	e8 e3 fe ff ff       	call   12c2 <write>
+  while(--i >= 0)
+    13df:	83 ff ff             	cmp    $0xffffffff,%edi
+    13e2:	75 dc                	jne    13c0 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    13e4:	83 c4 4c             	add    $0x4c,%esp
+    13e7:	5b                   	pop    %ebx
+    13e8:	5e                   	pop    %esi
+    13e9:	5f                   	pop    %edi
+    13ea:	5d                   	pop    %ebp
+    13eb:	c3                   	ret    
+    13ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    13f0:	89 d0                	mov    %edx,%eax
+    13f2:	f7 d8                	neg    %eax
+    neg = 1;
+    13f4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    13fb:	eb 87                	jmp    1384 <printint+0x24>
+    13fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+00001400 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    1400:	55                   	push   %ebp
+    1401:	89 e5                	mov    %esp,%ebp
+    1403:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    1404:	31 ff                	xor    %edi,%edi
+{
+    1406:	56                   	push   %esi
+    1407:	53                   	push   %ebx
+    1408:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    140b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    140e:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    1411:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    1414:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    1417:	0f b6 13             	movzbl (%ebx),%edx
+    141a:	83 c3 01             	add    $0x1,%ebx
+    141d:	84 d2                	test   %dl,%dl
+    141f:	75 39                	jne    145a <printf+0x5a>
+    1421:	e9 c2 00 00 00       	jmp    14e8 <printf+0xe8>
+    1426:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    1428:	83 fa 25             	cmp    $0x25,%edx
+    142b:	0f 84 bf 00 00 00    	je     14f0 <printf+0xf0>
+  write(fd, &c, 1);
+    1431:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    1434:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    143b:	00 
+    143c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1440:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    1443:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    1446:	e8 77 fe ff ff       	call   12c2 <write>
+    144b:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    144e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    1452:	84 d2                	test   %dl,%dl
+    1454:	0f 84 8e 00 00 00    	je     14e8 <printf+0xe8>
+    if(state == 0){
+    145a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    145c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    145f:	74 c7                	je     1428 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1461:	83 ff 25             	cmp    $0x25,%edi
+    1464:	75 e5                	jne    144b <printf+0x4b>
+      if(c == 'd'){
+    1466:	83 fa 64             	cmp    $0x64,%edx
+    1469:	0f 84 31 01 00 00    	je     15a0 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    146f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1474:	83 f8 70             	cmp    $0x70,%eax
+    1477:	0f 84 83 00 00 00    	je     1500 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    147d:	83 fa 73             	cmp    $0x73,%edx
+    1480:	0f 84 a2 00 00 00    	je     1528 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1486:	83 fa 63             	cmp    $0x63,%edx
+    1489:	0f 84 35 01 00 00    	je     15c4 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    148f:	83 fa 25             	cmp    $0x25,%edx
+    1492:	0f 84 e0 00 00 00    	je     1578 <printf+0x178>
+  write(fd, &c, 1);
+    1498:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    149b:	83 c3 01             	add    $0x1,%ebx
+    149e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14a5:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    14a6:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    14a8:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14ac:	89 34 24             	mov    %esi,(%esp)
+    14af:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    14b2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    14b6:	e8 07 fe ff ff       	call   12c2 <write>
+        putc(fd, c);
+    14bb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    14be:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    14c1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14c8:	00 
+    14c9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14cd:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    14d0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    14d3:	e8 ea fd ff ff       	call   12c2 <write>
+  for(i = 0; fmt[i]; i++){
+    14d8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    14dc:	84 d2                	test   %dl,%dl
+    14de:	0f 85 76 ff ff ff    	jne    145a <printf+0x5a>
+    14e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    14e8:	83 c4 3c             	add    $0x3c,%esp
+    14eb:	5b                   	pop    %ebx
+    14ec:	5e                   	pop    %esi
+    14ed:	5f                   	pop    %edi
+    14ee:	5d                   	pop    %ebp
+    14ef:	c3                   	ret    
+        state = '%';
+    14f0:	bf 25 00 00 00       	mov    $0x25,%edi
+    14f5:	e9 51 ff ff ff       	jmp    144b <printf+0x4b>
+    14fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    1500:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1503:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    1508:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    150a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1511:	8b 10                	mov    (%eax),%edx
+    1513:	89 f0                	mov    %esi,%eax
+    1515:	e8 46 fe ff ff       	call   1360 <printint>
+        ap++;
+    151a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    151e:	e9 28 ff ff ff       	jmp    144b <printf+0x4b>
+    1523:	90                   	nop
+    1524:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    1528:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    152b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    152f:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    1531:	b8 aa 17 00 00       	mov    $0x17aa,%eax
+    1536:	85 ff                	test   %edi,%edi
+    1538:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    153b:	0f b6 07             	movzbl (%edi),%eax
+    153e:	84 c0                	test   %al,%al
+    1540:	74 2a                	je     156c <printf+0x16c>
+    1542:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1548:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    154b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    154e:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    1551:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1558:	00 
+    1559:	89 44 24 04          	mov    %eax,0x4(%esp)
+    155d:	89 34 24             	mov    %esi,(%esp)
+    1560:	e8 5d fd ff ff       	call   12c2 <write>
+        while(*s != 0){
+    1565:	0f b6 07             	movzbl (%edi),%eax
+    1568:	84 c0                	test   %al,%al
+    156a:	75 dc                	jne    1548 <printf+0x148>
+      state = 0;
+    156c:	31 ff                	xor    %edi,%edi
+    156e:	e9 d8 fe ff ff       	jmp    144b <printf+0x4b>
+    1573:	90                   	nop
+    1574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1578:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    157b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    157d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1584:	00 
+    1585:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1589:	89 34 24             	mov    %esi,(%esp)
+    158c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1590:	e8 2d fd ff ff       	call   12c2 <write>
+    1595:	e9 b1 fe ff ff       	jmp    144b <printf+0x4b>
+    159a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    15a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    15a3:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    15a8:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    15ab:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    15b2:	8b 10                	mov    (%eax),%edx
+    15b4:	89 f0                	mov    %esi,%eax
+    15b6:	e8 a5 fd ff ff       	call   1360 <printint>
+        ap++;
+    15bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15bf:	e9 87 fe ff ff       	jmp    144b <printf+0x4b>
+        putc(fd, *ap);
+    15c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    15c7:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    15c9:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    15cb:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    15d2:	00 
+    15d3:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    15d6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    15d9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    15dc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15e0:	e8 dd fc ff ff       	call   12c2 <write>
+        ap++;
+    15e5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15e9:	e9 5d fe ff ff       	jmp    144b <printf+0x4b>
+    15ee:	66 90                	xchg   %ax,%ax
+
+000015f0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    15f0:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15f1:	a1 6c 1a 00 00       	mov    0x1a6c,%eax
+{
+    15f6:	89 e5                	mov    %esp,%ebp
+    15f8:	57                   	push   %edi
+    15f9:	56                   	push   %esi
+    15fa:	53                   	push   %ebx
+    15fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15fe:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    1600:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1603:	39 d0                	cmp    %edx,%eax
+    1605:	72 11                	jb     1618 <free+0x28>
+    1607:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1608:	39 c8                	cmp    %ecx,%eax
+    160a:	72 04                	jb     1610 <free+0x20>
+    160c:	39 ca                	cmp    %ecx,%edx
+    160e:	72 10                	jb     1620 <free+0x30>
+    1610:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1612:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1614:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1616:	73 f0                	jae    1608 <free+0x18>
+    1618:	39 ca                	cmp    %ecx,%edx
+    161a:	72 04                	jb     1620 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    161c:	39 c8                	cmp    %ecx,%eax
+    161e:	72 f0                	jb     1610 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    1620:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    1623:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    1626:	39 cf                	cmp    %ecx,%edi
+    1628:	74 1e                	je     1648 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    162a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    162d:	8b 48 04             	mov    0x4(%eax),%ecx
+    1630:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    1633:	39 f2                	cmp    %esi,%edx
+    1635:	74 28                	je     165f <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    1637:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    1639:	a3 6c 1a 00 00       	mov    %eax,0x1a6c
+}
+    163e:	5b                   	pop    %ebx
+    163f:	5e                   	pop    %esi
+    1640:	5f                   	pop    %edi
+    1641:	5d                   	pop    %ebp
+    1642:	c3                   	ret    
+    1643:	90                   	nop
+    1644:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    1648:	03 71 04             	add    0x4(%ecx),%esi
+    164b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    164e:	8b 08                	mov    (%eax),%ecx
+    1650:	8b 09                	mov    (%ecx),%ecx
+    1652:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    1655:	8b 48 04             	mov    0x4(%eax),%ecx
+    1658:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    165b:	39 f2                	cmp    %esi,%edx
+    165d:	75 d8                	jne    1637 <free+0x47>
+    p->s.size += bp->s.size;
+    165f:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    1662:	a3 6c 1a 00 00       	mov    %eax,0x1a6c
+    p->s.size += bp->s.size;
+    1667:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    166a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    166d:	89 10                	mov    %edx,(%eax)
+}
+    166f:	5b                   	pop    %ebx
+    1670:	5e                   	pop    %esi
+    1671:	5f                   	pop    %edi
+    1672:	5d                   	pop    %ebp
+    1673:	c3                   	ret    
+    1674:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    167a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001680 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1680:	55                   	push   %ebp
+    1681:	89 e5                	mov    %esp,%ebp
+    1683:	57                   	push   %edi
+    1684:	56                   	push   %esi
+    1685:	53                   	push   %ebx
+    1686:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1689:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    168c:	8b 1d 6c 1a 00 00    	mov    0x1a6c,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1692:	8d 48 07             	lea    0x7(%eax),%ecx
+    1695:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1698:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    169a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    169d:	0f 84 9b 00 00 00    	je     173e <malloc+0xbe>
+    16a3:	8b 13                	mov    (%ebx),%edx
+    16a5:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    16a8:	39 fe                	cmp    %edi,%esi
+    16aa:	76 64                	jbe    1710 <malloc+0x90>
+    16ac:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    16b3:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    16b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    16bb:	eb 0e                	jmp    16cb <malloc+0x4b>
+    16bd:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    16c0:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    16c2:	8b 78 04             	mov    0x4(%eax),%edi
+    16c5:	39 fe                	cmp    %edi,%esi
+    16c7:	76 4f                	jbe    1718 <malloc+0x98>
+    16c9:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    16cb:	3b 15 6c 1a 00 00    	cmp    0x1a6c,%edx
+    16d1:	75 ed                	jne    16c0 <malloc+0x40>
+  if(nu < 4096)
+    16d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    16d6:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    16dc:	bf 00 10 00 00       	mov    $0x1000,%edi
+    16e1:	0f 43 fe             	cmovae %esi,%edi
+    16e4:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    16e7:	89 04 24             	mov    %eax,(%esp)
+    16ea:	e8 3b fc ff ff       	call   132a <sbrk>
+  if(p == (char*)-1)
+    16ef:	83 f8 ff             	cmp    $0xffffffff,%eax
+    16f2:	74 18                	je     170c <malloc+0x8c>
+  hp->s.size = nu;
+    16f4:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    16f7:	83 c0 08             	add    $0x8,%eax
+    16fa:	89 04 24             	mov    %eax,(%esp)
+    16fd:	e8 ee fe ff ff       	call   15f0 <free>
+  return freep;
+    1702:	8b 15 6c 1a 00 00    	mov    0x1a6c,%edx
+      if((p = morecore(nunits)) == 0)
+    1708:	85 d2                	test   %edx,%edx
+    170a:	75 b4                	jne    16c0 <malloc+0x40>
+        return 0;
+    170c:	31 c0                	xor    %eax,%eax
+    170e:	eb 20                	jmp    1730 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    1710:	89 d0                	mov    %edx,%eax
+    1712:	89 da                	mov    %ebx,%edx
+    1714:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    1718:	39 fe                	cmp    %edi,%esi
+    171a:	74 1c                	je     1738 <malloc+0xb8>
+        p->s.size -= nunits;
+    171c:	29 f7                	sub    %esi,%edi
+    171e:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    1721:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    1724:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    1727:	89 15 6c 1a 00 00    	mov    %edx,0x1a6c
+      return (void*)(p + 1);
+    172d:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    1730:	83 c4 1c             	add    $0x1c,%esp
+    1733:	5b                   	pop    %ebx
+    1734:	5e                   	pop    %esi
+    1735:	5f                   	pop    %edi
+    1736:	5d                   	pop    %ebp
+    1737:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    1738:	8b 08                	mov    (%eax),%ecx
+    173a:	89 0a                	mov    %ecx,(%edx)
+    173c:	eb e9                	jmp    1727 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    173e:	c7 05 6c 1a 00 00 70 	movl   $0x1a70,0x1a6c
+    1745:	1a 00 00 
+    base.s.size = 0;
+    1748:	ba 70 1a 00 00       	mov    $0x1a70,%edx
+    base.s.ptr = freep = prevp = &base;
+    174d:	c7 05 70 1a 00 00 70 	movl   $0x1a70,0x1a70
+    1754:	1a 00 00 
+    base.s.size = 0;
+    1757:	c7 05 74 1a 00 00 00 	movl   $0x0,0x1a74
+    175e:	00 00 00 
+    1761:	e9 46 ff ff ff       	jmp    16ac <malloc+0x2c>
+    1766:	66 90                	xchg   %ax,%ax
+    1768:	66 90                	xchg   %ax,%ax
+    176a:	66 90                	xchg   %ax,%ax
+    176c:	66 90                	xchg   %ax,%ax
+    176e:	66 90                	xchg   %ax,%ax
+
+00001770 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1770:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1771:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1776:	89 e5                	mov    %esp,%ebp
+    1778:	8b 55 08             	mov    0x8(%ebp),%edx
+    177b:	90                   	nop
+    177c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1780:	89 c8                	mov    %ecx,%eax
+    1782:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1785:	85 c0                	test   %eax,%eax
+    1787:	75 f7                	jne    1780 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1789:	0f ae f0             	mfence 
+}
+    178c:	5d                   	pop    %ebp
+    178d:	c3                   	ret    
+    178e:	66 90                	xchg   %ax,%ax
+
+00001790 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1790:	55                   	push   %ebp
+    1791:	89 e5                	mov    %esp,%ebp
+    1793:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1796:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1799:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    179f:	5d                   	pop    %ebp
+    17a0:	c3                   	ret    
diff --git a/echo.c b/echo.c
index eed68a0..806dee0 100644
--- a/echo.c
+++ b/echo.c
@@ -9,5 +9,5 @@ main(int argc, char *argv[])
 
   for(i = 1; i < argc; i++)
     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
-  exit(0);
+  exit();
 }
diff --git a/echo.d b/echo.d
new file mode 100644
index 0000000..16a6098
--- /dev/null
+++ b/echo.d
@@ -0,0 +1 @@
+echo.o: echo.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/echo.o b/echo.o
new file mode 100644
index 0000000..692b600
Binary files /dev/null and b/echo.o differ
diff --git a/echo.sym b/echo.sym
new file mode 100644
index 0000000..5c2052d
--- /dev/null
+++ b/echo.sym
@@ -0,0 +1,62 @@
+00001000 .text
+000017a1 .rodata
+000017c4 .eh_frame
+00001a6c .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 echo.c
+00000000 ulib.c
+00000000 printf.c
+00001360 printint
+000017b1 digits.1359
+00000000 umalloc.c
+00001a6c freep
+00001a70 base
+00000000 uspinlock.c
+00001080 strcpy
+00001400 printf
+00001270 memmove
+000012ea mknod
+00001342 shm_open
+00001190 gets
+00001322 getpid
+00001680 malloc
+00001332 sleep
+000012b2 pipe
+000012c2 write
+000012fa fstat
+000012d2 kill
+00001312 chdir
+000012da exec
+000012aa wait
+000012ba read
+000012f2 unlink
+00001770 uacquire
+0000129a fork
+0000132a sbrk
+0000134a shm_close
+0000133a uptime
+00001a6c __bss_start
+00001130 memset
+00001000 main
+000010b0 strcmp
+0000131a dup
+000011f0 stat
+00001a6c _edata
+00001a78 _end
+00001302 link
+000012a2 exit
+00001240 atoi
+00001100 strlen
+000012e2 open
+00001150 strchr
+0000130a mkdir
+000012ca close
+00001790 urelease
+000015f0 free
diff --git a/entry.o b/entry.o
new file mode 100644
index 0000000..aac007f
Binary files /dev/null and b/entry.o differ
diff --git a/entryother b/entryother
new file mode 100644
index 0000000..a7673de
Binary files /dev/null and b/entryother differ
diff --git a/entryother.asm b/entryother.asm
new file mode 100644
index 0000000..c845a5d
--- /dev/null
+++ b/entryother.asm
@@ -0,0 +1,125 @@
+
+bootblockother.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00007000 <start>:
+# This code combines elements of bootasm.S and entry.S.
+
+.code16           
+.globl start
+start:
+  cli            
+    7000:	fa                   	cli    
+
+  # Zero data segment registers DS, ES, and SS.
+  xorw    %ax,%ax
+    7001:	31 c0                	xor    %eax,%eax
+  movw    %ax,%ds
+    7003:	8e d8                	mov    %eax,%ds
+  movw    %ax,%es
+    7005:	8e c0                	mov    %eax,%es
+  movw    %ax,%ss
+    7007:	8e d0                	mov    %eax,%ss
+
+  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+  # virtual addresses map directly to physical addresses so that the
+  # effective memory map doesn't change during the transition.
+  lgdt    gdtdesc
+    7009:	0f 01 16             	lgdtl  (%esi)
+    700c:	84 70 0f             	test   %dh,0xf(%eax)
+  movl    %cr0, %eax
+    700f:	20 c0                	and    %al,%al
+  orl     $CR0_PE, %eax
+    7011:	66 83 c8 01          	or     $0x1,%ax
+  movl    %eax, %cr0
+    7015:	0f 22 c0             	mov    %eax,%cr0
+
+  # Complete the transition to 32-bit protected mode by using a long jmp
+  # to reload %cs and %eip.  The segment descriptors are set up with no
+  # translation, so that the mapping is still the identity mapping.
+  ljmpl    $(SEG_KCODE<<3), $(start32)
+    7018:	66 ea 20 70 00 00    	ljmpw  $0x0,$0x7020
+    701e:	08 00                	or     %al,(%eax)
+
+00007020 <start32>:
+
+//PAGEBREAK!
+.code32  # Tell assembler to generate 32-bit code now.
+start32:
+  # Set up the protected-mode data segment registers
+  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+    7020:	66 b8 10 00          	mov    $0x10,%ax
+  movw    %ax, %ds                # -> DS: Data Segment
+    7024:	8e d8                	mov    %eax,%ds
+  movw    %ax, %es                # -> ES: Extra Segment
+    7026:	8e c0                	mov    %eax,%es
+  movw    %ax, %ss                # -> SS: Stack Segment
+    7028:	8e d0                	mov    %eax,%ss
+  movw    $0, %ax                 # Zero segments not ready for use
+    702a:	66 b8 00 00          	mov    $0x0,%ax
+  movw    %ax, %fs                # -> FS
+    702e:	8e e0                	mov    %eax,%fs
+  movw    %ax, %gs                # -> GS
+    7030:	8e e8                	mov    %eax,%gs
+
+  # Turn on page size extension for 4Mbyte pages
+  movl    %cr4, %eax
+    7032:	0f 20 e0             	mov    %cr4,%eax
+  orl     $(CR4_PSE), %eax
+    7035:	83 c8 10             	or     $0x10,%eax
+  movl    %eax, %cr4
+    7038:	0f 22 e0             	mov    %eax,%cr4
+  # Use entrypgdir as our initial page table
+  movl    (start-12), %eax
+    703b:	a1 f4 6f 00 00       	mov    0x6ff4,%eax
+  movl    %eax, %cr3
+    7040:	0f 22 d8             	mov    %eax,%cr3
+  # Turn on paging.
+  movl    %cr0, %eax
+    7043:	0f 20 c0             	mov    %cr0,%eax
+  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
+    7046:	0d 01 00 01 80       	or     $0x80010001,%eax
+  movl    %eax, %cr0
+    704b:	0f 22 c0             	mov    %eax,%cr0
+
+  # Switch to the stack allocated by startothers()
+  movl    (start-4), %esp
+    704e:	8b 25 fc 6f 00 00    	mov    0x6ffc,%esp
+  # Call mpenter()
+  call	 *(start-8)
+    7054:	ff 15 f8 6f 00 00    	call   *0x6ff8
+
+  movw    $0x8a00, %ax
+    705a:	66 b8 00 8a          	mov    $0x8a00,%ax
+  movw    %ax, %dx
+    705e:	66 89 c2             	mov    %ax,%dx
+  outw    %ax, %dx
+    7061:	66 ef                	out    %ax,(%dx)
+  movw    $0x8ae0, %ax
+    7063:	66 b8 e0 8a          	mov    $0x8ae0,%ax
+  outw    %ax, %dx
+    7067:	66 ef                	out    %ax,(%dx)
+
+00007069 <spin>:
+spin:
+  jmp     spin
+    7069:	eb fe                	jmp    7069 <spin>
+    706b:	90                   	nop
+
+0000706c <gdt>:
+	...
+    7074:	ff                   	(bad)  
+    7075:	ff 00                	incl   (%eax)
+    7077:	00 00                	add    %al,(%eax)
+    7079:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
+    7080:	00                   	.byte 0x0
+    7081:	92                   	xchg   %eax,%edx
+    7082:	cf                   	iret   
+	...
+
+00007084 <gdtdesc>:
+    7084:	17                   	pop    %ss
+    7085:	00 6c 70 00          	add    %ch,0x0(%eax,%esi,2)
+	...
diff --git a/entryother.d b/entryother.d
new file mode 100644
index 0000000..a140303
--- /dev/null
+++ b/entryother.d
@@ -0,0 +1 @@
+entryother.o: entryother.S asm.h memlayout.h mmu.h
diff --git a/entryother.o b/entryother.o
new file mode 100644
index 0000000..3beef68
Binary files /dev/null and b/entryother.o differ
diff --git a/exec.c b/exec.c
index b40134f..bb64faa 100644
--- a/exec.c
+++ b/exec.c
@@ -13,70 +13,72 @@ exec(char *path, char **argv)
   char *s, *last;
   int i, off;
   uint argc, sz, sp, ustack[3+MAXARG+1];
+  uint stackTop;
   struct elfhdr elf;
   struct inode *ip;
   struct proghdr ph;
   pde_t *pgdir, *oldpgdir;
   struct proc *curproc = myproc();
 
-  begin_op();
+    begin_op();
 
-  if((ip = namei(path)) == 0){
-    end_op();
-    cprintf("exec: fail\n");
-    return -1;
-  }
-  ilock(ip);
-  pgdir = 0;
+    if ((ip = namei(path)) == 0) {
+        end_op();
+        cprintf("exec: fail\n");
+        return -1;
+    }
+    ilock(ip);
+    pgdir = 0;
 
-  // Check ELF header
-  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
-    goto bad;
-  if(elf.magic != ELF_MAGIC)
-    goto bad;
+    // Check ELF header
+    if (readi(ip, (char *) &elf, 0, sizeof(elf)) != sizeof(elf))
+        goto bad;
+    if (elf.magic != ELF_MAGIC)
+        goto bad;
 
-  if((pgdir = setupkvm()) == 0)
-    goto bad;
+    if ((pgdir = setupkvm()) == 0)
+        goto bad;
 
-  // Load program into memory.
-  sz = 0;
-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
-    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
-      goto bad;
-    if(ph.type != ELF_PROG_LOAD)
-      continue;
-    if(ph.memsz < ph.filesz)
-      goto bad;
-    if(ph.vaddr + ph.memsz < ph.vaddr)
-      goto bad;
-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
-      goto bad;
-    if(ph.vaddr % PGSIZE != 0)
-      goto bad;
-    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
-      goto bad;
-  }
-  iunlockput(ip);
-  end_op();
-  ip = 0;
+    // Load program into memory.
+    sz = 0;
+    for (i = 0, off = elf.phoff; i < elf.phnum; i++, off += sizeof(ph)) {
+        if (readi(ip, (char *) &ph, off, sizeof(ph)) != sizeof(ph))
+            goto bad;
+        if (ph.type != ELF_PROG_LOAD)
+            continue;
+        if (ph.memsz < ph.filesz)
+            goto bad;
+        if (ph.vaddr + ph.memsz < ph.vaddr)
+            goto bad;
+        if ((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+            goto bad;
+        if (ph.vaddr % PGSIZE != 0)
+            goto bad;
+        if (loaduvm(pgdir, (char *) ph.vaddr, ip, ph.off, ph.filesz) < 0)
+            goto bad;
+    }
+    iunlockput(ip);
+    end_op();
+    ip = 0;
 
-  // Allocate two pages at the next page boundary.
-  // Make the first inaccessible.  Use the second as the user stack.
-  sz = PGROUNDUP(sz);
-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
-    goto bad;
-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
-  sp = sz;
+    // Allocate two pages at the next page boundary.
+    // Make the first inaccessible.  Use the second as the user stack.
+//  sz = PGROUNDUP(sz);
+    stackTop = USERTOP - 2 * PGSIZE;
+    if ((sp = allocuvm(pgdir, stackTop, USERTOP)) == 0)
+        goto bad;
+    clearpteu(pgdir, (char *) (stackTop));
+    //sp = sz;
 
-  // Push argument strings, prepare rest of stack in ustack.
-  for(argc = 0; argv[argc]; argc++) {
-    if(argc >= MAXARG)
-      goto bad;
-    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
-    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
-      goto bad;
-    ustack[3+argc] = sp;
-  }
+    // Push argument strings, prepare rest of stack in ustack.
+    for (argc = 0; argv[argc]; argc++) {
+        if (argc >= MAXARG)
+            goto bad;
+        sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+        if (copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+            goto bad;
+        ustack[3 + argc] = sp;
+    }
   ustack[3+argc] = 0;
 
   ustack[0] = 0xffffffff;  // fake return PC
@@ -99,6 +101,7 @@ exec(char *path, char **argv)
   curproc->sz = sz;
   curproc->tf->eip = elf.entry;  // main
   curproc->tf->esp = sp;
+  curproc->stackTop = stackTop;
   switchuvm(curproc);
   freevm(oldpgdir);
   return 0;
diff --git a/exec.d b/exec.d
new file mode 100644
index 0000000..0400275
--- /dev/null
+++ b/exec.d
@@ -0,0 +1,2 @@
+exec.o: exec.c /usr/include/stdc-predef.h types.h param.h memlayout.h \
+ mmu.h proc.h defs.h x86.h elf.h
diff --git a/exec.o b/exec.o
new file mode 100644
index 0000000..410cb49
Binary files /dev/null and b/exec.o differ
diff --git a/file.c b/file.c
index 24b32c2..95cadb3 100644
--- a/file.c
+++ b/file.c
@@ -130,7 +130,7 @@ filewrite(struct file *f, char *addr, int n)
     // and 2 blocks of slop for non-aligned writes.
     // this really belongs lower down, since writei()
     // might be writing a device like the console.
-    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
+    int max = ((LOGSIZE-1-1-2) / 2) * 512;
     int i = 0;
     while(i < n){
       int n1 = n - i;
diff --git a/file.d b/file.d
new file mode 100644
index 0000000..fea73d1
--- /dev/null
+++ b/file.d
@@ -0,0 +1,2 @@
+file.o: file.c /usr/include/stdc-predef.h types.h defs.h param.h fs.h \
+ spinlock.h sleeplock.h file.h
diff --git a/file.o b/file.o
new file mode 100644
index 0000000..3fa31a8
Binary files /dev/null and b/file.o differ
diff --git a/forktest.asm b/forktest.asm
new file mode 100644
index 0000000..7cba8fd
--- /dev/null
+++ b/forktest.asm
@@ -0,0 +1,652 @@
+
+_forktest:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+  printf(1, "fork test OK\n");
+}
+
+int
+main(void)
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	83 e4 f0             	and    $0xfffffff0,%esp
+  forktest();
+    1006:	e8 35 00 00 00       	call   1040 <forktest>
+  exit();
+    100b:	e8 32 03 00 00       	call   1342 <exit>
+
+00001010 <printf>:
+{
+    1010:	55                   	push   %ebp
+    1011:	89 e5                	mov    %esp,%ebp
+    1013:	53                   	push   %ebx
+    1014:	83 ec 14             	sub    $0x14,%esp
+    1017:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  write(fd, s, strlen(s));
+    101a:	89 1c 24             	mov    %ebx,(%esp)
+    101d:	e8 7e 01 00 00       	call   11a0 <strlen>
+    1022:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1026:	89 44 24 08          	mov    %eax,0x8(%esp)
+    102a:	8b 45 08             	mov    0x8(%ebp),%eax
+    102d:	89 04 24             	mov    %eax,(%esp)
+    1030:	e8 2d 03 00 00       	call   1362 <write>
+}
+    1035:	83 c4 14             	add    $0x14,%esp
+    1038:	5b                   	pop    %ebx
+    1039:	5d                   	pop    %ebp
+    103a:	c3                   	ret    
+    103b:	90                   	nop
+    103c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00001040 <forktest>:
+{
+    1040:	55                   	push   %ebp
+    1041:	89 e5                	mov    %esp,%ebp
+    1043:	53                   	push   %ebx
+  for(n=0; n<N; n++){
+    1044:	31 db                	xor    %ebx,%ebx
+{
+    1046:	83 ec 14             	sub    $0x14,%esp
+  printf(1, "fork test\n");
+    1049:	c7 44 24 04 f4 13 00 	movl   $0x13f4,0x4(%esp)
+    1050:	00 
+    1051:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1058:	e8 b3 ff ff ff       	call   1010 <printf>
+    105d:	eb 13                	jmp    1072 <forktest+0x32>
+    105f:	90                   	nop
+    if(pid == 0)
+    1060:	0f 84 97 00 00 00    	je     10fd <forktest+0xbd>
+  for(n=0; n<N; n++){
+    1066:	83 c3 01             	add    $0x1,%ebx
+    1069:	81 fb e8 03 00 00    	cmp    $0x3e8,%ebx
+    106f:	90                   	nop
+    1070:	74 4e                	je     10c0 <forktest+0x80>
+    pid = fork();
+    1072:	e8 c3 02 00 00       	call   133a <fork>
+    if(pid < 0)
+    1077:	85 c0                	test   %eax,%eax
+    1079:	79 e5                	jns    1060 <forktest+0x20>
+  for(; n > 0; n--){
+    107b:	85 db                	test   %ebx,%ebx
+    107d:	8d 76 00             	lea    0x0(%esi),%esi
+    1080:	74 15                	je     1097 <forktest+0x57>
+    1082:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(wait() < 0){
+    1088:	e8 bd 02 00 00       	call   134a <wait>
+    108d:	85 c0                	test   %eax,%eax
+    108f:	90                   	nop
+    1090:	78 57                	js     10e9 <forktest+0xa9>
+  for(; n > 0; n--){
+    1092:	83 eb 01             	sub    $0x1,%ebx
+    1095:	75 f1                	jne    1088 <forktest+0x48>
+  if(wait() != -1){
+    1097:	e8 ae 02 00 00       	call   134a <wait>
+    109c:	83 f8 ff             	cmp    $0xffffffff,%eax
+    109f:	90                   	nop
+    10a0:	75 60                	jne    1102 <forktest+0xc2>
+  printf(1, "fork test OK\n");
+    10a2:	c7 44 24 04 26 14 00 	movl   $0x1426,0x4(%esp)
+    10a9:	00 
+    10aa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10b1:	e8 5a ff ff ff       	call   1010 <printf>
+}
+    10b6:	83 c4 14             	add    $0x14,%esp
+    10b9:	5b                   	pop    %ebx
+    10ba:	5d                   	pop    %ebp
+    10bb:	c3                   	ret    
+    10bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, s, strlen(s));
+    10c0:	c7 04 24 34 14 00 00 	movl   $0x1434,(%esp)
+    10c7:	e8 d4 00 00 00       	call   11a0 <strlen>
+    10cc:	c7 44 24 04 34 14 00 	movl   $0x1434,0x4(%esp)
+    10d3:	00 
+    10d4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10db:	89 44 24 08          	mov    %eax,0x8(%esp)
+    10df:	e8 7e 02 00 00       	call   1362 <write>
+    exit();
+    10e4:	e8 59 02 00 00       	call   1342 <exit>
+      printf(1, "wait stopped early\n");
+    10e9:	c7 44 24 04 ff 13 00 	movl   $0x13ff,0x4(%esp)
+    10f0:	00 
+    10f1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10f8:	e8 13 ff ff ff       	call   1010 <printf>
+      exit();
+    10fd:	e8 40 02 00 00       	call   1342 <exit>
+    printf(1, "wait got too many\n");
+    1102:	c7 44 24 04 13 14 00 	movl   $0x1413,0x4(%esp)
+    1109:	00 
+    110a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1111:	e8 fa fe ff ff       	call   1010 <printf>
+    exit();
+    1116:	e8 27 02 00 00       	call   1342 <exit>
+    111b:	66 90                	xchg   %ax,%ax
+    111d:	66 90                	xchg   %ax,%ax
+    111f:	90                   	nop
+
+00001120 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1120:	55                   	push   %ebp
+    1121:	89 e5                	mov    %esp,%ebp
+    1123:	8b 45 08             	mov    0x8(%ebp),%eax
+    1126:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1129:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    112a:	89 c2                	mov    %eax,%edx
+    112c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1130:	83 c1 01             	add    $0x1,%ecx
+    1133:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1137:	83 c2 01             	add    $0x1,%edx
+    113a:	84 db                	test   %bl,%bl
+    113c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    113f:	75 ef                	jne    1130 <strcpy+0x10>
+    ;
+  return os;
+}
+    1141:	5b                   	pop    %ebx
+    1142:	5d                   	pop    %ebp
+    1143:	c3                   	ret    
+    1144:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    114a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001150 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1150:	55                   	push   %ebp
+    1151:	89 e5                	mov    %esp,%ebp
+    1153:	8b 55 08             	mov    0x8(%ebp),%edx
+    1156:	53                   	push   %ebx
+    1157:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    115a:	0f b6 02             	movzbl (%edx),%eax
+    115d:	84 c0                	test   %al,%al
+    115f:	74 2d                	je     118e <strcmp+0x3e>
+    1161:	0f b6 19             	movzbl (%ecx),%ebx
+    1164:	38 d8                	cmp    %bl,%al
+    1166:	74 0e                	je     1176 <strcmp+0x26>
+    1168:	eb 2b                	jmp    1195 <strcmp+0x45>
+    116a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1170:	38 c8                	cmp    %cl,%al
+    1172:	75 15                	jne    1189 <strcmp+0x39>
+    p++, q++;
+    1174:	89 d9                	mov    %ebx,%ecx
+    1176:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    1179:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    117c:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    117f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    1183:	84 c0                	test   %al,%al
+    1185:	75 e9                	jne    1170 <strcmp+0x20>
+    1187:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    1189:	29 c8                	sub    %ecx,%eax
+}
+    118b:	5b                   	pop    %ebx
+    118c:	5d                   	pop    %ebp
+    118d:	c3                   	ret    
+    118e:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    1191:	31 c0                	xor    %eax,%eax
+    1193:	eb f4                	jmp    1189 <strcmp+0x39>
+    1195:	0f b6 cb             	movzbl %bl,%ecx
+    1198:	eb ef                	jmp    1189 <strcmp+0x39>
+    119a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000011a0 <strlen>:
+
+uint
+strlen(char *s)
+{
+    11a0:	55                   	push   %ebp
+    11a1:	89 e5                	mov    %esp,%ebp
+    11a3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    11a6:	80 39 00             	cmpb   $0x0,(%ecx)
+    11a9:	74 12                	je     11bd <strlen+0x1d>
+    11ab:	31 d2                	xor    %edx,%edx
+    11ad:	8d 76 00             	lea    0x0(%esi),%esi
+    11b0:	83 c2 01             	add    $0x1,%edx
+    11b3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    11b7:	89 d0                	mov    %edx,%eax
+    11b9:	75 f5                	jne    11b0 <strlen+0x10>
+    ;
+  return n;
+}
+    11bb:	5d                   	pop    %ebp
+    11bc:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    11bd:	31 c0                	xor    %eax,%eax
+}
+    11bf:	5d                   	pop    %ebp
+    11c0:	c3                   	ret    
+    11c1:	eb 0d                	jmp    11d0 <memset>
+    11c3:	90                   	nop
+    11c4:	90                   	nop
+    11c5:	90                   	nop
+    11c6:	90                   	nop
+    11c7:	90                   	nop
+    11c8:	90                   	nop
+    11c9:	90                   	nop
+    11ca:	90                   	nop
+    11cb:	90                   	nop
+    11cc:	90                   	nop
+    11cd:	90                   	nop
+    11ce:	90                   	nop
+    11cf:	90                   	nop
+
+000011d0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    11d0:	55                   	push   %ebp
+    11d1:	89 e5                	mov    %esp,%ebp
+    11d3:	8b 55 08             	mov    0x8(%ebp),%edx
+    11d6:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    11d7:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    11da:	8b 45 0c             	mov    0xc(%ebp),%eax
+    11dd:	89 d7                	mov    %edx,%edi
+    11df:	fc                   	cld    
+    11e0:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    11e2:	89 d0                	mov    %edx,%eax
+    11e4:	5f                   	pop    %edi
+    11e5:	5d                   	pop    %ebp
+    11e6:	c3                   	ret    
+    11e7:	89 f6                	mov    %esi,%esi
+    11e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+000011f0 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    11f0:	55                   	push   %ebp
+    11f1:	89 e5                	mov    %esp,%ebp
+    11f3:	8b 45 08             	mov    0x8(%ebp),%eax
+    11f6:	53                   	push   %ebx
+    11f7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    11fa:	0f b6 18             	movzbl (%eax),%ebx
+    11fd:	84 db                	test   %bl,%bl
+    11ff:	74 1d                	je     121e <strchr+0x2e>
+    if(*s == c)
+    1201:	38 d3                	cmp    %dl,%bl
+    1203:	89 d1                	mov    %edx,%ecx
+    1205:	75 0d                	jne    1214 <strchr+0x24>
+    1207:	eb 17                	jmp    1220 <strchr+0x30>
+    1209:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1210:	38 ca                	cmp    %cl,%dl
+    1212:	74 0c                	je     1220 <strchr+0x30>
+  for(; *s; s++)
+    1214:	83 c0 01             	add    $0x1,%eax
+    1217:	0f b6 10             	movzbl (%eax),%edx
+    121a:	84 d2                	test   %dl,%dl
+    121c:	75 f2                	jne    1210 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    121e:	31 c0                	xor    %eax,%eax
+}
+    1220:	5b                   	pop    %ebx
+    1221:	5d                   	pop    %ebp
+    1222:	c3                   	ret    
+    1223:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1229:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001230 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1230:	55                   	push   %ebp
+    1231:	89 e5                	mov    %esp,%ebp
+    1233:	57                   	push   %edi
+    1234:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1235:	31 f6                	xor    %esi,%esi
+{
+    1237:	53                   	push   %ebx
+    1238:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    123b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    123e:	eb 31                	jmp    1271 <gets+0x41>
+    cc = read(0, &c, 1);
+    1240:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1247:	00 
+    1248:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    124c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1253:	e8 02 01 00 00       	call   135a <read>
+    if(cc < 1)
+    1258:	85 c0                	test   %eax,%eax
+    125a:	7e 1d                	jle    1279 <gets+0x49>
+      break;
+    buf[i++] = c;
+    125c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    1260:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    1262:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    1265:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    1267:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    126b:	74 0c                	je     1279 <gets+0x49>
+    126d:	3c 0a                	cmp    $0xa,%al
+    126f:	74 08                	je     1279 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    1271:	8d 5e 01             	lea    0x1(%esi),%ebx
+    1274:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    1277:	7c c7                	jl     1240 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    1279:	8b 45 08             	mov    0x8(%ebp),%eax
+    127c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    1280:	83 c4 2c             	add    $0x2c,%esp
+    1283:	5b                   	pop    %ebx
+    1284:	5e                   	pop    %esi
+    1285:	5f                   	pop    %edi
+    1286:	5d                   	pop    %ebp
+    1287:	c3                   	ret    
+    1288:	90                   	nop
+    1289:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001290 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    1290:	55                   	push   %ebp
+    1291:	89 e5                	mov    %esp,%ebp
+    1293:	56                   	push   %esi
+    1294:	53                   	push   %ebx
+    1295:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    1298:	8b 45 08             	mov    0x8(%ebp),%eax
+    129b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    12a2:	00 
+    12a3:	89 04 24             	mov    %eax,(%esp)
+    12a6:	e8 d7 00 00 00       	call   1382 <open>
+  if(fd < 0)
+    12ab:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    12ad:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    12af:	78 27                	js     12d8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    12b1:	8b 45 0c             	mov    0xc(%ebp),%eax
+    12b4:	89 1c 24             	mov    %ebx,(%esp)
+    12b7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    12bb:	e8 da 00 00 00       	call   139a <fstat>
+  close(fd);
+    12c0:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    12c3:	89 c6                	mov    %eax,%esi
+  close(fd);
+    12c5:	e8 a0 00 00 00       	call   136a <close>
+  return r;
+    12ca:	89 f0                	mov    %esi,%eax
+}
+    12cc:	83 c4 10             	add    $0x10,%esp
+    12cf:	5b                   	pop    %ebx
+    12d0:	5e                   	pop    %esi
+    12d1:	5d                   	pop    %ebp
+    12d2:	c3                   	ret    
+    12d3:	90                   	nop
+    12d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    12d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    12dd:	eb ed                	jmp    12cc <stat+0x3c>
+    12df:	90                   	nop
+
+000012e0 <atoi>:
+
+int
+atoi(const char *s)
+{
+    12e0:	55                   	push   %ebp
+    12e1:	89 e5                	mov    %esp,%ebp
+    12e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    12e6:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    12e7:	0f be 11             	movsbl (%ecx),%edx
+    12ea:	8d 42 d0             	lea    -0x30(%edx),%eax
+    12ed:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    12ef:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    12f4:	77 17                	ja     130d <atoi+0x2d>
+    12f6:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    12f8:	83 c1 01             	add    $0x1,%ecx
+    12fb:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    12fe:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1302:	0f be 11             	movsbl (%ecx),%edx
+    1305:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1308:	80 fb 09             	cmp    $0x9,%bl
+    130b:	76 eb                	jbe    12f8 <atoi+0x18>
+  return n;
+}
+    130d:	5b                   	pop    %ebx
+    130e:	5d                   	pop    %ebp
+    130f:	c3                   	ret    
+
+00001310 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1310:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1311:	31 d2                	xor    %edx,%edx
+{
+    1313:	89 e5                	mov    %esp,%ebp
+    1315:	56                   	push   %esi
+    1316:	8b 45 08             	mov    0x8(%ebp),%eax
+    1319:	53                   	push   %ebx
+    131a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    131d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1320:	85 db                	test   %ebx,%ebx
+    1322:	7e 12                	jle    1336 <memmove+0x26>
+    1324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1328:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    132c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    132f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1332:	39 da                	cmp    %ebx,%edx
+    1334:	75 f2                	jne    1328 <memmove+0x18>
+  return vdst;
+}
+    1336:	5b                   	pop    %ebx
+    1337:	5e                   	pop    %esi
+    1338:	5d                   	pop    %ebp
+    1339:	c3                   	ret    
+
+0000133a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    133a:	b8 01 00 00 00       	mov    $0x1,%eax
+    133f:	cd 40                	int    $0x40
+    1341:	c3                   	ret    
+
+00001342 <exit>:
+SYSCALL(exit)
+    1342:	b8 02 00 00 00       	mov    $0x2,%eax
+    1347:	cd 40                	int    $0x40
+    1349:	c3                   	ret    
+
+0000134a <wait>:
+SYSCALL(wait)
+    134a:	b8 03 00 00 00       	mov    $0x3,%eax
+    134f:	cd 40                	int    $0x40
+    1351:	c3                   	ret    
+
+00001352 <pipe>:
+SYSCALL(pipe)
+    1352:	b8 04 00 00 00       	mov    $0x4,%eax
+    1357:	cd 40                	int    $0x40
+    1359:	c3                   	ret    
+
+0000135a <read>:
+SYSCALL(read)
+    135a:	b8 05 00 00 00       	mov    $0x5,%eax
+    135f:	cd 40                	int    $0x40
+    1361:	c3                   	ret    
+
+00001362 <write>:
+SYSCALL(write)
+    1362:	b8 10 00 00 00       	mov    $0x10,%eax
+    1367:	cd 40                	int    $0x40
+    1369:	c3                   	ret    
+
+0000136a <close>:
+SYSCALL(close)
+    136a:	b8 15 00 00 00       	mov    $0x15,%eax
+    136f:	cd 40                	int    $0x40
+    1371:	c3                   	ret    
+
+00001372 <kill>:
+SYSCALL(kill)
+    1372:	b8 06 00 00 00       	mov    $0x6,%eax
+    1377:	cd 40                	int    $0x40
+    1379:	c3                   	ret    
+
+0000137a <exec>:
+SYSCALL(exec)
+    137a:	b8 07 00 00 00       	mov    $0x7,%eax
+    137f:	cd 40                	int    $0x40
+    1381:	c3                   	ret    
+
+00001382 <open>:
+SYSCALL(open)
+    1382:	b8 0f 00 00 00       	mov    $0xf,%eax
+    1387:	cd 40                	int    $0x40
+    1389:	c3                   	ret    
+
+0000138a <mknod>:
+SYSCALL(mknod)
+    138a:	b8 11 00 00 00       	mov    $0x11,%eax
+    138f:	cd 40                	int    $0x40
+    1391:	c3                   	ret    
+
+00001392 <unlink>:
+SYSCALL(unlink)
+    1392:	b8 12 00 00 00       	mov    $0x12,%eax
+    1397:	cd 40                	int    $0x40
+    1399:	c3                   	ret    
+
+0000139a <fstat>:
+SYSCALL(fstat)
+    139a:	b8 08 00 00 00       	mov    $0x8,%eax
+    139f:	cd 40                	int    $0x40
+    13a1:	c3                   	ret    
+
+000013a2 <link>:
+SYSCALL(link)
+    13a2:	b8 13 00 00 00       	mov    $0x13,%eax
+    13a7:	cd 40                	int    $0x40
+    13a9:	c3                   	ret    
+
+000013aa <mkdir>:
+SYSCALL(mkdir)
+    13aa:	b8 14 00 00 00       	mov    $0x14,%eax
+    13af:	cd 40                	int    $0x40
+    13b1:	c3                   	ret    
+
+000013b2 <chdir>:
+SYSCALL(chdir)
+    13b2:	b8 09 00 00 00       	mov    $0x9,%eax
+    13b7:	cd 40                	int    $0x40
+    13b9:	c3                   	ret    
+
+000013ba <dup>:
+SYSCALL(dup)
+    13ba:	b8 0a 00 00 00       	mov    $0xa,%eax
+    13bf:	cd 40                	int    $0x40
+    13c1:	c3                   	ret    
+
+000013c2 <getpid>:
+SYSCALL(getpid)
+    13c2:	b8 0b 00 00 00       	mov    $0xb,%eax
+    13c7:	cd 40                	int    $0x40
+    13c9:	c3                   	ret    
+
+000013ca <sbrk>:
+SYSCALL(sbrk)
+    13ca:	b8 0c 00 00 00       	mov    $0xc,%eax
+    13cf:	cd 40                	int    $0x40
+    13d1:	c3                   	ret    
+
+000013d2 <sleep>:
+SYSCALL(sleep)
+    13d2:	b8 0d 00 00 00       	mov    $0xd,%eax
+    13d7:	cd 40                	int    $0x40
+    13d9:	c3                   	ret    
+
+000013da <uptime>:
+SYSCALL(uptime)
+    13da:	b8 0e 00 00 00       	mov    $0xe,%eax
+    13df:	cd 40                	int    $0x40
+    13e1:	c3                   	ret    
+
+000013e2 <shm_open>:
+SYSCALL(shm_open)
+    13e2:	b8 16 00 00 00       	mov    $0x16,%eax
+    13e7:	cd 40                	int    $0x40
+    13e9:	c3                   	ret    
+
+000013ea <shm_close>:
+SYSCALL(shm_close)	
+    13ea:	b8 17 00 00 00       	mov    $0x17,%eax
+    13ef:	cd 40                	int    $0x40
+    13f1:	c3                   	ret    
diff --git a/forktest.c b/forktest.c
index a4b35ed..73f2fe8 100644
--- a/forktest.c
+++ b/forktest.c
@@ -8,7 +8,7 @@
 #define N  1000
 
 void
-printf(int fd, const char *s, ...)
+printf(int fd, char *s, ...)
 {
   write(fd, s, strlen(s));
 }
@@ -25,24 +25,24 @@ forktest(void)
     if(pid < 0)
       break;
     if(pid == 0)
-      exit(4);
+      exit();
   }
 
   if(n == N){
     printf(1, "fork claimed to work N times!\n", N);
-    exit(3);
+    exit();
   }
 
   for(; n > 0; n--){
-    if(wait(NULL) < 0){
+    if(wait() < 0){
       printf(1, "wait stopped early\n");
-      exit(2);
+      exit();
     }
   }
 
-  if(wait(NULL) != -1){
+  if(wait() != -1){
     printf(1, "wait got too many\n");
-    exit(1);
+    exit();
   }
 
   printf(1, "fork test OK\n");
@@ -52,5 +52,5 @@ int
 main(void)
 {
   forktest();
-  exit(0);
+  exit();
 }
diff --git a/forktest.d b/forktest.d
new file mode 100644
index 0000000..d31a0c2
--- /dev/null
+++ b/forktest.d
@@ -0,0 +1 @@
+forktest.o: forktest.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/forktest.o b/forktest.o
new file mode 100644
index 0000000..ad946db
Binary files /dev/null and b/forktest.o differ
diff --git a/fs.c b/fs.c
index f77275f..feb59fe 100644
--- a/fs.c
+++ b/fs.c
@@ -84,6 +84,7 @@ bfree(int dev, uint b)
   struct buf *bp;
   int bi, m;
 
+  readsb(dev, &sb);
   bp = bread(dev, BBLOCK(b, sb));
   bi = b % BPB;
   m = 1 << (bi % 8);
diff --git a/fs.d b/fs.d
new file mode 100644
index 0000000..a1d05cc
--- /dev/null
+++ b/fs.d
@@ -0,0 +1,2 @@
+fs.o: fs.c /usr/include/stdc-predef.h types.h defs.h param.h stat.h mmu.h \
+ proc.h spinlock.h sleeplock.h fs.h buf.h file.h
diff --git a/fs.img b/fs.img
new file mode 100644
index 0000000..6ca46f9
Binary files /dev/null and b/fs.img differ
diff --git a/fs.o b/fs.o
new file mode 100644
index 0000000..e2776f5
Binary files /dev/null and b/fs.o differ
diff --git a/grep.asm b/grep.asm
new file mode 100644
index 0000000..7d34097
--- /dev/null
+++ b/grep.asm
@@ -0,0 +1,1546 @@
+
+_grep:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+  }
+}
+
+int
+main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	57                   	push   %edi
+    1004:	56                   	push   %esi
+    1005:	53                   	push   %ebx
+    1006:	83 e4 f0             	and    $0xfffffff0,%esp
+    1009:	83 ec 10             	sub    $0x10,%esp
+    100c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  int fd, i;
+  char *pattern;
+
+  if(argc <= 1){
+    100f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+    1013:	0f 8e 8b 00 00 00    	jle    10a4 <main+0xa4>
+    printf(2, "usage: grep pattern [file ...]\n");
+    exit();
+  }
+  pattern = argv[1];
+    1019:	8b 43 04             	mov    0x4(%ebx),%eax
+    101c:	83 c3 08             	add    $0x8,%ebx
+
+  if(argc <= 2){
+    101f:	be 02 00 00 00       	mov    $0x2,%esi
+    1024:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
+  pattern = argv[1];
+    1028:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  if(argc <= 2){
+    102c:	74 61                	je     108f <main+0x8f>
+    102e:	66 90                	xchg   %ax,%ax
+    grep(pattern, 0);
+    exit();
+  }
+
+  for(i = 2; i < argc; i++){
+    if((fd = open(argv[i], 0)) < 0){
+    1030:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1037:	00 
+    1038:	8b 03                	mov    (%ebx),%eax
+    103a:	89 04 24             	mov    %eax,(%esp)
+    103d:	e8 30 05 00 00       	call   1572 <open>
+    1042:	85 c0                	test   %eax,%eax
+    1044:	89 c7                	mov    %eax,%edi
+    1046:	78 28                	js     1070 <main+0x70>
+      printf(1, "grep: cannot open %s\n", argv[i]);
+      exit();
+    }
+    grep(pattern, fd);
+    1048:	89 44 24 04          	mov    %eax,0x4(%esp)
+    104c:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  for(i = 2; i < argc; i++){
+    1050:	83 c6 01             	add    $0x1,%esi
+    1053:	83 c3 04             	add    $0x4,%ebx
+    grep(pattern, fd);
+    1056:	89 04 24             	mov    %eax,(%esp)
+    1059:	e8 a2 01 00 00       	call   1200 <grep>
+    close(fd);
+    105e:	89 3c 24             	mov    %edi,(%esp)
+    1061:	e8 f4 04 00 00       	call   155a <close>
+  for(i = 2; i < argc; i++){
+    1066:	39 75 08             	cmp    %esi,0x8(%ebp)
+    1069:	7f c5                	jg     1030 <main+0x30>
+  }
+  exit();
+    106b:	e8 c2 04 00 00       	call   1532 <exit>
+      printf(1, "grep: cannot open %s\n", argv[i]);
+    1070:	8b 03                	mov    (%ebx),%eax
+    1072:	c7 44 24 04 54 1a 00 	movl   $0x1a54,0x4(%esp)
+    1079:	00 
+    107a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1081:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1085:	e8 06 06 00 00       	call   1690 <printf>
+      exit();
+    108a:	e8 a3 04 00 00       	call   1532 <exit>
+    grep(pattern, 0);
+    108f:	89 04 24             	mov    %eax,(%esp)
+    1092:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1099:	00 
+    109a:	e8 61 01 00 00       	call   1200 <grep>
+    exit();
+    109f:	e8 8e 04 00 00       	call   1532 <exit>
+    printf(2, "usage: grep pattern [file ...]\n");
+    10a4:	c7 44 24 04 34 1a 00 	movl   $0x1a34,0x4(%esp)
+    10ab:	00 
+    10ac:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    10b3:	e8 d8 05 00 00       	call   1690 <printf>
+    exit();
+    10b8:	e8 75 04 00 00       	call   1532 <exit>
+    10bd:	66 90                	xchg   %ax,%ax
+    10bf:	90                   	nop
+
+000010c0 <matchstar>:
+  return 0;
+}
+
+// matchstar: search for c*re at beginning of text
+int matchstar(int c, char *re, char *text)
+{
+    10c0:	55                   	push   %ebp
+    10c1:	89 e5                	mov    %esp,%ebp
+    10c3:	57                   	push   %edi
+    10c4:	56                   	push   %esi
+    10c5:	53                   	push   %ebx
+    10c6:	83 ec 1c             	sub    $0x1c,%esp
+    10c9:	8b 75 08             	mov    0x8(%ebp),%esi
+    10cc:	8b 7d 0c             	mov    0xc(%ebp),%edi
+    10cf:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    10d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  do{  // a * matches zero or more instances
+    if(matchhere(re, text))
+    10d8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    10dc:	89 3c 24             	mov    %edi,(%esp)
+    10df:	e8 3c 00 00 00       	call   1120 <matchhere>
+    10e4:	85 c0                	test   %eax,%eax
+    10e6:	75 20                	jne    1108 <matchstar+0x48>
+      return 1;
+  }while(*text!='\0' && (*text++==c || c=='.'));
+    10e8:	0f be 13             	movsbl (%ebx),%edx
+    10eb:	84 d2                	test   %dl,%dl
+    10ed:	74 0c                	je     10fb <matchstar+0x3b>
+    10ef:	83 c3 01             	add    $0x1,%ebx
+    10f2:	39 f2                	cmp    %esi,%edx
+    10f4:	74 e2                	je     10d8 <matchstar+0x18>
+    10f6:	83 fe 2e             	cmp    $0x2e,%esi
+    10f9:	74 dd                	je     10d8 <matchstar+0x18>
+  return 0;
+}
+    10fb:	83 c4 1c             	add    $0x1c,%esp
+    10fe:	5b                   	pop    %ebx
+    10ff:	5e                   	pop    %esi
+    1100:	5f                   	pop    %edi
+    1101:	5d                   	pop    %ebp
+    1102:	c3                   	ret    
+    1103:	90                   	nop
+    1104:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1108:	83 c4 1c             	add    $0x1c,%esp
+      return 1;
+    110b:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+    1110:	5b                   	pop    %ebx
+    1111:	5e                   	pop    %esi
+    1112:	5f                   	pop    %edi
+    1113:	5d                   	pop    %ebp
+    1114:	c3                   	ret    
+    1115:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1119:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001120 <matchhere>:
+{
+    1120:	55                   	push   %ebp
+    1121:	89 e5                	mov    %esp,%ebp
+    1123:	53                   	push   %ebx
+    1124:	83 ec 14             	sub    $0x14,%esp
+    1127:	8b 55 08             	mov    0x8(%ebp),%edx
+    112a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  if(re[0] == '\0')
+    112d:	0f be 02             	movsbl (%edx),%eax
+    1130:	84 c0                	test   %al,%al
+    1132:	75 20                	jne    1154 <matchhere+0x34>
+    1134:	eb 42                	jmp    1178 <matchhere+0x58>
+    1136:	66 90                	xchg   %ax,%ax
+  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+    1138:	0f b6 19             	movzbl (%ecx),%ebx
+    113b:	84 db                	test   %bl,%bl
+    113d:	74 31                	je     1170 <matchhere+0x50>
+    113f:	3c 2e                	cmp    $0x2e,%al
+    1141:	74 04                	je     1147 <matchhere+0x27>
+    1143:	38 d8                	cmp    %bl,%al
+    1145:	75 29                	jne    1170 <matchhere+0x50>
+    return matchhere(re+1, text+1);
+    1147:	83 c2 01             	add    $0x1,%edx
+  if(re[0] == '\0')
+    114a:	0f be 02             	movsbl (%edx),%eax
+    return matchhere(re+1, text+1);
+    114d:	83 c1 01             	add    $0x1,%ecx
+  if(re[0] == '\0')
+    1150:	84 c0                	test   %al,%al
+    1152:	74 24                	je     1178 <matchhere+0x58>
+  if(re[1] == '*')
+    1154:	0f b6 5a 01          	movzbl 0x1(%edx),%ebx
+    1158:	80 fb 2a             	cmp    $0x2a,%bl
+    115b:	74 2b                	je     1188 <matchhere+0x68>
+  if(re[0] == '$' && re[1] == '\0')
+    115d:	3c 24                	cmp    $0x24,%al
+    115f:	75 d7                	jne    1138 <matchhere+0x18>
+    1161:	84 db                	test   %bl,%bl
+    1163:	74 3c                	je     11a1 <matchhere+0x81>
+  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+    1165:	0f b6 19             	movzbl (%ecx),%ebx
+    1168:	84 db                	test   %bl,%bl
+    116a:	75 d7                	jne    1143 <matchhere+0x23>
+    116c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+    1170:	31 c0                	xor    %eax,%eax
+}
+    1172:	83 c4 14             	add    $0x14,%esp
+    1175:	5b                   	pop    %ebx
+    1176:	5d                   	pop    %ebp
+    1177:	c3                   	ret    
+    1178:	83 c4 14             	add    $0x14,%esp
+    return 1;
+    117b:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+    1180:	5b                   	pop    %ebx
+    1181:	5d                   	pop    %ebp
+    1182:	c3                   	ret    
+    1183:	90                   	nop
+    1184:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return matchstar(re[0], re+2, text);
+    1188:	83 c2 02             	add    $0x2,%edx
+    118b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+    118f:	89 54 24 04          	mov    %edx,0x4(%esp)
+    1193:	89 04 24             	mov    %eax,(%esp)
+    1196:	e8 25 ff ff ff       	call   10c0 <matchstar>
+}
+    119b:	83 c4 14             	add    $0x14,%esp
+    119e:	5b                   	pop    %ebx
+    119f:	5d                   	pop    %ebp
+    11a0:	c3                   	ret    
+    return *text == '\0';
+    11a1:	31 c0                	xor    %eax,%eax
+    11a3:	80 39 00             	cmpb   $0x0,(%ecx)
+    11a6:	0f 94 c0             	sete   %al
+    11a9:	eb c7                	jmp    1172 <matchhere+0x52>
+    11ab:	90                   	nop
+    11ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000011b0 <match>:
+{
+    11b0:	55                   	push   %ebp
+    11b1:	89 e5                	mov    %esp,%ebp
+    11b3:	56                   	push   %esi
+    11b4:	53                   	push   %ebx
+    11b5:	83 ec 10             	sub    $0x10,%esp
+    11b8:	8b 75 08             	mov    0x8(%ebp),%esi
+    11bb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  if(re[0] == '^')
+    11be:	80 3e 5e             	cmpb   $0x5e,(%esi)
+    11c1:	75 0e                	jne    11d1 <match+0x21>
+    11c3:	eb 28                	jmp    11ed <match+0x3d>
+    11c5:	8d 76 00             	lea    0x0(%esi),%esi
+  }while(*text++ != '\0');
+    11c8:	83 c3 01             	add    $0x1,%ebx
+    11cb:	80 7b ff 00          	cmpb   $0x0,-0x1(%ebx)
+    11cf:	74 15                	je     11e6 <match+0x36>
+    if(matchhere(re, text))
+    11d1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    11d5:	89 34 24             	mov    %esi,(%esp)
+    11d8:	e8 43 ff ff ff       	call   1120 <matchhere>
+    11dd:	85 c0                	test   %eax,%eax
+    11df:	74 e7                	je     11c8 <match+0x18>
+      return 1;
+    11e1:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+    11e6:	83 c4 10             	add    $0x10,%esp
+    11e9:	5b                   	pop    %ebx
+    11ea:	5e                   	pop    %esi
+    11eb:	5d                   	pop    %ebp
+    11ec:	c3                   	ret    
+    return matchhere(re+1, text);
+    11ed:	83 c6 01             	add    $0x1,%esi
+    11f0:	89 75 08             	mov    %esi,0x8(%ebp)
+}
+    11f3:	83 c4 10             	add    $0x10,%esp
+    11f6:	5b                   	pop    %ebx
+    11f7:	5e                   	pop    %esi
+    11f8:	5d                   	pop    %ebp
+    return matchhere(re+1, text);
+    11f9:	e9 22 ff ff ff       	jmp    1120 <matchhere>
+    11fe:	66 90                	xchg   %ax,%ax
+
+00001200 <grep>:
+{
+    1200:	55                   	push   %ebp
+    1201:	89 e5                	mov    %esp,%ebp
+    1203:	57                   	push   %edi
+    1204:	56                   	push   %esi
+    1205:	53                   	push   %ebx
+    1206:	83 ec 1c             	sub    $0x1c,%esp
+    1209:	8b 75 08             	mov    0x8(%ebp),%esi
+  m = 0;
+    120c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+    1213:	90                   	nop
+    1214:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+    1218:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+    121b:	b8 ff 03 00 00       	mov    $0x3ff,%eax
+    1220:	29 d0                	sub    %edx,%eax
+    1222:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1226:	89 d0                	mov    %edx,%eax
+    1228:	05 40 1e 00 00       	add    $0x1e40,%eax
+    122d:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1231:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1234:	89 04 24             	mov    %eax,(%esp)
+    1237:	e8 0e 03 00 00       	call   154a <read>
+    123c:	85 c0                	test   %eax,%eax
+    123e:	0f 8e b8 00 00 00    	jle    12fc <grep+0xfc>
+    m += n;
+    1244:	01 45 e4             	add    %eax,-0x1c(%ebp)
+    p = buf;
+    1247:	bb 40 1e 00 00       	mov    $0x1e40,%ebx
+    buf[m] = '\0';
+    124c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    124f:	c6 80 40 1e 00 00 00 	movb   $0x0,0x1e40(%eax)
+    1256:	66 90                	xchg   %ax,%ax
+    while((q = strchr(p, '\n')) != 0){
+    1258:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
+    125f:	00 
+    1260:	89 1c 24             	mov    %ebx,(%esp)
+    1263:	e8 78 01 00 00       	call   13e0 <strchr>
+    1268:	85 c0                	test   %eax,%eax
+    126a:	89 c7                	mov    %eax,%edi
+    126c:	74 42                	je     12b0 <grep+0xb0>
+      *q = 0;
+    126e:	c6 07 00             	movb   $0x0,(%edi)
+      if(match(pattern, p)){
+    1271:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1275:	89 34 24             	mov    %esi,(%esp)
+    1278:	e8 33 ff ff ff       	call   11b0 <match>
+    127d:	85 c0                	test   %eax,%eax
+    127f:	75 07                	jne    1288 <grep+0x88>
+    1281:	8d 5f 01             	lea    0x1(%edi),%ebx
+    1284:	eb d2                	jmp    1258 <grep+0x58>
+    1286:	66 90                	xchg   %ax,%ax
+        *q = '\n';
+    1288:	c6 07 0a             	movb   $0xa,(%edi)
+        write(1, p, q+1 - p);
+    128b:	83 c7 01             	add    $0x1,%edi
+    128e:	89 f8                	mov    %edi,%eax
+    1290:	29 d8                	sub    %ebx,%eax
+    1292:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1296:	89 fb                	mov    %edi,%ebx
+    1298:	89 44 24 08          	mov    %eax,0x8(%esp)
+    129c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    12a3:	e8 aa 02 00 00       	call   1552 <write>
+    12a8:	eb ae                	jmp    1258 <grep+0x58>
+    12aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(p == buf)
+    12b0:	81 fb 40 1e 00 00    	cmp    $0x1e40,%ebx
+    12b6:	74 38                	je     12f0 <grep+0xf0>
+    if(m > 0){
+    12b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    12bb:	85 c0                	test   %eax,%eax
+    12bd:	0f 8e 55 ff ff ff    	jle    1218 <grep+0x18>
+      m -= p - buf;
+    12c3:	b8 40 1e 00 00       	mov    $0x1e40,%eax
+    12c8:	29 d8                	sub    %ebx,%eax
+    12ca:	01 45 e4             	add    %eax,-0x1c(%ebp)
+      memmove(buf, p, m);
+    12cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    12d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    12d4:	c7 04 24 40 1e 00 00 	movl   $0x1e40,(%esp)
+    12db:	89 44 24 08          	mov    %eax,0x8(%esp)
+    12df:	e8 1c 02 00 00       	call   1500 <memmove>
+    12e4:	e9 2f ff ff ff       	jmp    1218 <grep+0x18>
+    12e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      m = 0;
+    12f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+    12f7:	e9 1c ff ff ff       	jmp    1218 <grep+0x18>
+}
+    12fc:	83 c4 1c             	add    $0x1c,%esp
+    12ff:	5b                   	pop    %ebx
+    1300:	5e                   	pop    %esi
+    1301:	5f                   	pop    %edi
+    1302:	5d                   	pop    %ebp
+    1303:	c3                   	ret    
+    1304:	66 90                	xchg   %ax,%ax
+    1306:	66 90                	xchg   %ax,%ax
+    1308:	66 90                	xchg   %ax,%ax
+    130a:	66 90                	xchg   %ax,%ax
+    130c:	66 90                	xchg   %ax,%ax
+    130e:	66 90                	xchg   %ax,%ax
+
+00001310 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1310:	55                   	push   %ebp
+    1311:	89 e5                	mov    %esp,%ebp
+    1313:	8b 45 08             	mov    0x8(%ebp),%eax
+    1316:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1319:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    131a:	89 c2                	mov    %eax,%edx
+    131c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1320:	83 c1 01             	add    $0x1,%ecx
+    1323:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1327:	83 c2 01             	add    $0x1,%edx
+    132a:	84 db                	test   %bl,%bl
+    132c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    132f:	75 ef                	jne    1320 <strcpy+0x10>
+    ;
+  return os;
+}
+    1331:	5b                   	pop    %ebx
+    1332:	5d                   	pop    %ebp
+    1333:	c3                   	ret    
+    1334:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    133a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001340 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1340:	55                   	push   %ebp
+    1341:	89 e5                	mov    %esp,%ebp
+    1343:	8b 55 08             	mov    0x8(%ebp),%edx
+    1346:	53                   	push   %ebx
+    1347:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    134a:	0f b6 02             	movzbl (%edx),%eax
+    134d:	84 c0                	test   %al,%al
+    134f:	74 2d                	je     137e <strcmp+0x3e>
+    1351:	0f b6 19             	movzbl (%ecx),%ebx
+    1354:	38 d8                	cmp    %bl,%al
+    1356:	74 0e                	je     1366 <strcmp+0x26>
+    1358:	eb 2b                	jmp    1385 <strcmp+0x45>
+    135a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1360:	38 c8                	cmp    %cl,%al
+    1362:	75 15                	jne    1379 <strcmp+0x39>
+    p++, q++;
+    1364:	89 d9                	mov    %ebx,%ecx
+    1366:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    1369:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    136c:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    136f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    1373:	84 c0                	test   %al,%al
+    1375:	75 e9                	jne    1360 <strcmp+0x20>
+    1377:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    1379:	29 c8                	sub    %ecx,%eax
+}
+    137b:	5b                   	pop    %ebx
+    137c:	5d                   	pop    %ebp
+    137d:	c3                   	ret    
+    137e:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    1381:	31 c0                	xor    %eax,%eax
+    1383:	eb f4                	jmp    1379 <strcmp+0x39>
+    1385:	0f b6 cb             	movzbl %bl,%ecx
+    1388:	eb ef                	jmp    1379 <strcmp+0x39>
+    138a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001390 <strlen>:
+
+uint
+strlen(char *s)
+{
+    1390:	55                   	push   %ebp
+    1391:	89 e5                	mov    %esp,%ebp
+    1393:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    1396:	80 39 00             	cmpb   $0x0,(%ecx)
+    1399:	74 12                	je     13ad <strlen+0x1d>
+    139b:	31 d2                	xor    %edx,%edx
+    139d:	8d 76 00             	lea    0x0(%esi),%esi
+    13a0:	83 c2 01             	add    $0x1,%edx
+    13a3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    13a7:	89 d0                	mov    %edx,%eax
+    13a9:	75 f5                	jne    13a0 <strlen+0x10>
+    ;
+  return n;
+}
+    13ab:	5d                   	pop    %ebp
+    13ac:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    13ad:	31 c0                	xor    %eax,%eax
+}
+    13af:	5d                   	pop    %ebp
+    13b0:	c3                   	ret    
+    13b1:	eb 0d                	jmp    13c0 <memset>
+    13b3:	90                   	nop
+    13b4:	90                   	nop
+    13b5:	90                   	nop
+    13b6:	90                   	nop
+    13b7:	90                   	nop
+    13b8:	90                   	nop
+    13b9:	90                   	nop
+    13ba:	90                   	nop
+    13bb:	90                   	nop
+    13bc:	90                   	nop
+    13bd:	90                   	nop
+    13be:	90                   	nop
+    13bf:	90                   	nop
+
+000013c0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    13c0:	55                   	push   %ebp
+    13c1:	89 e5                	mov    %esp,%ebp
+    13c3:	8b 55 08             	mov    0x8(%ebp),%edx
+    13c6:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    13c7:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    13ca:	8b 45 0c             	mov    0xc(%ebp),%eax
+    13cd:	89 d7                	mov    %edx,%edi
+    13cf:	fc                   	cld    
+    13d0:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    13d2:	89 d0                	mov    %edx,%eax
+    13d4:	5f                   	pop    %edi
+    13d5:	5d                   	pop    %ebp
+    13d6:	c3                   	ret    
+    13d7:	89 f6                	mov    %esi,%esi
+    13d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+000013e0 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    13e0:	55                   	push   %ebp
+    13e1:	89 e5                	mov    %esp,%ebp
+    13e3:	8b 45 08             	mov    0x8(%ebp),%eax
+    13e6:	53                   	push   %ebx
+    13e7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    13ea:	0f b6 18             	movzbl (%eax),%ebx
+    13ed:	84 db                	test   %bl,%bl
+    13ef:	74 1d                	je     140e <strchr+0x2e>
+    if(*s == c)
+    13f1:	38 d3                	cmp    %dl,%bl
+    13f3:	89 d1                	mov    %edx,%ecx
+    13f5:	75 0d                	jne    1404 <strchr+0x24>
+    13f7:	eb 17                	jmp    1410 <strchr+0x30>
+    13f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1400:	38 ca                	cmp    %cl,%dl
+    1402:	74 0c                	je     1410 <strchr+0x30>
+  for(; *s; s++)
+    1404:	83 c0 01             	add    $0x1,%eax
+    1407:	0f b6 10             	movzbl (%eax),%edx
+    140a:	84 d2                	test   %dl,%dl
+    140c:	75 f2                	jne    1400 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    140e:	31 c0                	xor    %eax,%eax
+}
+    1410:	5b                   	pop    %ebx
+    1411:	5d                   	pop    %ebp
+    1412:	c3                   	ret    
+    1413:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1419:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001420 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1420:	55                   	push   %ebp
+    1421:	89 e5                	mov    %esp,%ebp
+    1423:	57                   	push   %edi
+    1424:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1425:	31 f6                	xor    %esi,%esi
+{
+    1427:	53                   	push   %ebx
+    1428:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    142b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    142e:	eb 31                	jmp    1461 <gets+0x41>
+    cc = read(0, &c, 1);
+    1430:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1437:	00 
+    1438:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    143c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1443:	e8 02 01 00 00       	call   154a <read>
+    if(cc < 1)
+    1448:	85 c0                	test   %eax,%eax
+    144a:	7e 1d                	jle    1469 <gets+0x49>
+      break;
+    buf[i++] = c;
+    144c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    1450:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    1452:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    1455:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    1457:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    145b:	74 0c                	je     1469 <gets+0x49>
+    145d:	3c 0a                	cmp    $0xa,%al
+    145f:	74 08                	je     1469 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    1461:	8d 5e 01             	lea    0x1(%esi),%ebx
+    1464:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    1467:	7c c7                	jl     1430 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    1469:	8b 45 08             	mov    0x8(%ebp),%eax
+    146c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    1470:	83 c4 2c             	add    $0x2c,%esp
+    1473:	5b                   	pop    %ebx
+    1474:	5e                   	pop    %esi
+    1475:	5f                   	pop    %edi
+    1476:	5d                   	pop    %ebp
+    1477:	c3                   	ret    
+    1478:	90                   	nop
+    1479:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001480 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    1480:	55                   	push   %ebp
+    1481:	89 e5                	mov    %esp,%ebp
+    1483:	56                   	push   %esi
+    1484:	53                   	push   %ebx
+    1485:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    1488:	8b 45 08             	mov    0x8(%ebp),%eax
+    148b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1492:	00 
+    1493:	89 04 24             	mov    %eax,(%esp)
+    1496:	e8 d7 00 00 00       	call   1572 <open>
+  if(fd < 0)
+    149b:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    149d:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    149f:	78 27                	js     14c8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    14a1:	8b 45 0c             	mov    0xc(%ebp),%eax
+    14a4:	89 1c 24             	mov    %ebx,(%esp)
+    14a7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14ab:	e8 da 00 00 00       	call   158a <fstat>
+  close(fd);
+    14b0:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    14b3:	89 c6                	mov    %eax,%esi
+  close(fd);
+    14b5:	e8 a0 00 00 00       	call   155a <close>
+  return r;
+    14ba:	89 f0                	mov    %esi,%eax
+}
+    14bc:	83 c4 10             	add    $0x10,%esp
+    14bf:	5b                   	pop    %ebx
+    14c0:	5e                   	pop    %esi
+    14c1:	5d                   	pop    %ebp
+    14c2:	c3                   	ret    
+    14c3:	90                   	nop
+    14c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    14c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    14cd:	eb ed                	jmp    14bc <stat+0x3c>
+    14cf:	90                   	nop
+
+000014d0 <atoi>:
+
+int
+atoi(const char *s)
+{
+    14d0:	55                   	push   %ebp
+    14d1:	89 e5                	mov    %esp,%ebp
+    14d3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    14d6:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    14d7:	0f be 11             	movsbl (%ecx),%edx
+    14da:	8d 42 d0             	lea    -0x30(%edx),%eax
+    14dd:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    14df:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    14e4:	77 17                	ja     14fd <atoi+0x2d>
+    14e6:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    14e8:	83 c1 01             	add    $0x1,%ecx
+    14eb:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    14ee:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    14f2:	0f be 11             	movsbl (%ecx),%edx
+    14f5:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    14f8:	80 fb 09             	cmp    $0x9,%bl
+    14fb:	76 eb                	jbe    14e8 <atoi+0x18>
+  return n;
+}
+    14fd:	5b                   	pop    %ebx
+    14fe:	5d                   	pop    %ebp
+    14ff:	c3                   	ret    
+
+00001500 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1500:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1501:	31 d2                	xor    %edx,%edx
+{
+    1503:	89 e5                	mov    %esp,%ebp
+    1505:	56                   	push   %esi
+    1506:	8b 45 08             	mov    0x8(%ebp),%eax
+    1509:	53                   	push   %ebx
+    150a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    150d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1510:	85 db                	test   %ebx,%ebx
+    1512:	7e 12                	jle    1526 <memmove+0x26>
+    1514:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1518:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    151c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    151f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1522:	39 da                	cmp    %ebx,%edx
+    1524:	75 f2                	jne    1518 <memmove+0x18>
+  return vdst;
+}
+    1526:	5b                   	pop    %ebx
+    1527:	5e                   	pop    %esi
+    1528:	5d                   	pop    %ebp
+    1529:	c3                   	ret    
+
+0000152a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    152a:	b8 01 00 00 00       	mov    $0x1,%eax
+    152f:	cd 40                	int    $0x40
+    1531:	c3                   	ret    
+
+00001532 <exit>:
+SYSCALL(exit)
+    1532:	b8 02 00 00 00       	mov    $0x2,%eax
+    1537:	cd 40                	int    $0x40
+    1539:	c3                   	ret    
+
+0000153a <wait>:
+SYSCALL(wait)
+    153a:	b8 03 00 00 00       	mov    $0x3,%eax
+    153f:	cd 40                	int    $0x40
+    1541:	c3                   	ret    
+
+00001542 <pipe>:
+SYSCALL(pipe)
+    1542:	b8 04 00 00 00       	mov    $0x4,%eax
+    1547:	cd 40                	int    $0x40
+    1549:	c3                   	ret    
+
+0000154a <read>:
+SYSCALL(read)
+    154a:	b8 05 00 00 00       	mov    $0x5,%eax
+    154f:	cd 40                	int    $0x40
+    1551:	c3                   	ret    
+
+00001552 <write>:
+SYSCALL(write)
+    1552:	b8 10 00 00 00       	mov    $0x10,%eax
+    1557:	cd 40                	int    $0x40
+    1559:	c3                   	ret    
+
+0000155a <close>:
+SYSCALL(close)
+    155a:	b8 15 00 00 00       	mov    $0x15,%eax
+    155f:	cd 40                	int    $0x40
+    1561:	c3                   	ret    
+
+00001562 <kill>:
+SYSCALL(kill)
+    1562:	b8 06 00 00 00       	mov    $0x6,%eax
+    1567:	cd 40                	int    $0x40
+    1569:	c3                   	ret    
+
+0000156a <exec>:
+SYSCALL(exec)
+    156a:	b8 07 00 00 00       	mov    $0x7,%eax
+    156f:	cd 40                	int    $0x40
+    1571:	c3                   	ret    
+
+00001572 <open>:
+SYSCALL(open)
+    1572:	b8 0f 00 00 00       	mov    $0xf,%eax
+    1577:	cd 40                	int    $0x40
+    1579:	c3                   	ret    
+
+0000157a <mknod>:
+SYSCALL(mknod)
+    157a:	b8 11 00 00 00       	mov    $0x11,%eax
+    157f:	cd 40                	int    $0x40
+    1581:	c3                   	ret    
+
+00001582 <unlink>:
+SYSCALL(unlink)
+    1582:	b8 12 00 00 00       	mov    $0x12,%eax
+    1587:	cd 40                	int    $0x40
+    1589:	c3                   	ret    
+
+0000158a <fstat>:
+SYSCALL(fstat)
+    158a:	b8 08 00 00 00       	mov    $0x8,%eax
+    158f:	cd 40                	int    $0x40
+    1591:	c3                   	ret    
+
+00001592 <link>:
+SYSCALL(link)
+    1592:	b8 13 00 00 00       	mov    $0x13,%eax
+    1597:	cd 40                	int    $0x40
+    1599:	c3                   	ret    
+
+0000159a <mkdir>:
+SYSCALL(mkdir)
+    159a:	b8 14 00 00 00       	mov    $0x14,%eax
+    159f:	cd 40                	int    $0x40
+    15a1:	c3                   	ret    
+
+000015a2 <chdir>:
+SYSCALL(chdir)
+    15a2:	b8 09 00 00 00       	mov    $0x9,%eax
+    15a7:	cd 40                	int    $0x40
+    15a9:	c3                   	ret    
+
+000015aa <dup>:
+SYSCALL(dup)
+    15aa:	b8 0a 00 00 00       	mov    $0xa,%eax
+    15af:	cd 40                	int    $0x40
+    15b1:	c3                   	ret    
+
+000015b2 <getpid>:
+SYSCALL(getpid)
+    15b2:	b8 0b 00 00 00       	mov    $0xb,%eax
+    15b7:	cd 40                	int    $0x40
+    15b9:	c3                   	ret    
+
+000015ba <sbrk>:
+SYSCALL(sbrk)
+    15ba:	b8 0c 00 00 00       	mov    $0xc,%eax
+    15bf:	cd 40                	int    $0x40
+    15c1:	c3                   	ret    
+
+000015c2 <sleep>:
+SYSCALL(sleep)
+    15c2:	b8 0d 00 00 00       	mov    $0xd,%eax
+    15c7:	cd 40                	int    $0x40
+    15c9:	c3                   	ret    
+
+000015ca <uptime>:
+SYSCALL(uptime)
+    15ca:	b8 0e 00 00 00       	mov    $0xe,%eax
+    15cf:	cd 40                	int    $0x40
+    15d1:	c3                   	ret    
+
+000015d2 <shm_open>:
+SYSCALL(shm_open)
+    15d2:	b8 16 00 00 00       	mov    $0x16,%eax
+    15d7:	cd 40                	int    $0x40
+    15d9:	c3                   	ret    
+
+000015da <shm_close>:
+SYSCALL(shm_close)	
+    15da:	b8 17 00 00 00       	mov    $0x17,%eax
+    15df:	cd 40                	int    $0x40
+    15e1:	c3                   	ret    
+    15e2:	66 90                	xchg   %ax,%ax
+    15e4:	66 90                	xchg   %ax,%ax
+    15e6:	66 90                	xchg   %ax,%ax
+    15e8:	66 90                	xchg   %ax,%ax
+    15ea:	66 90                	xchg   %ax,%ax
+    15ec:	66 90                	xchg   %ax,%ax
+    15ee:	66 90                	xchg   %ax,%ax
+
+000015f0 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    15f0:	55                   	push   %ebp
+    15f1:	89 e5                	mov    %esp,%ebp
+    15f3:	57                   	push   %edi
+    15f4:	56                   	push   %esi
+    15f5:	89 c6                	mov    %eax,%esi
+    15f7:	53                   	push   %ebx
+    15f8:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    15fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    15fe:	85 db                	test   %ebx,%ebx
+    1600:	74 09                	je     160b <printint+0x1b>
+    1602:	89 d0                	mov    %edx,%eax
+    1604:	c1 e8 1f             	shr    $0x1f,%eax
+    1607:	84 c0                	test   %al,%al
+    1609:	75 75                	jne    1680 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    160b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    160d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1614:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1617:	31 ff                	xor    %edi,%edi
+    1619:	89 ce                	mov    %ecx,%esi
+    161b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    161e:	eb 02                	jmp    1622 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1620:	89 cf                	mov    %ecx,%edi
+    1622:	31 d2                	xor    %edx,%edx
+    1624:	f7 f6                	div    %esi
+    1626:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1629:	0f b6 92 71 1a 00 00 	movzbl 0x1a71(%edx),%edx
+  }while((x /= base) != 0);
+    1630:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1632:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1635:	75 e9                	jne    1620 <printint+0x30>
+  if(neg)
+    1637:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    163a:	89 c8                	mov    %ecx,%eax
+    163c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    163f:	85 d2                	test   %edx,%edx
+    1641:	74 08                	je     164b <printint+0x5b>
+    buf[i++] = '-';
+    1643:	8d 4f 02             	lea    0x2(%edi),%ecx
+    1646:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    164b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    164e:	66 90                	xchg   %ax,%ax
+    1650:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    1655:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    1658:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    165f:	00 
+    1660:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1664:	89 34 24             	mov    %esi,(%esp)
+    1667:	88 45 d7             	mov    %al,-0x29(%ebp)
+    166a:	e8 e3 fe ff ff       	call   1552 <write>
+  while(--i >= 0)
+    166f:	83 ff ff             	cmp    $0xffffffff,%edi
+    1672:	75 dc                	jne    1650 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    1674:	83 c4 4c             	add    $0x4c,%esp
+    1677:	5b                   	pop    %ebx
+    1678:	5e                   	pop    %esi
+    1679:	5f                   	pop    %edi
+    167a:	5d                   	pop    %ebp
+    167b:	c3                   	ret    
+    167c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    1680:	89 d0                	mov    %edx,%eax
+    1682:	f7 d8                	neg    %eax
+    neg = 1;
+    1684:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    168b:	eb 87                	jmp    1614 <printint+0x24>
+    168d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00001690 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    1690:	55                   	push   %ebp
+    1691:	89 e5                	mov    %esp,%ebp
+    1693:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    1694:	31 ff                	xor    %edi,%edi
+{
+    1696:	56                   	push   %esi
+    1697:	53                   	push   %ebx
+    1698:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    169b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    169e:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    16a1:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    16a4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    16a7:	0f b6 13             	movzbl (%ebx),%edx
+    16aa:	83 c3 01             	add    $0x1,%ebx
+    16ad:	84 d2                	test   %dl,%dl
+    16af:	75 39                	jne    16ea <printf+0x5a>
+    16b1:	e9 c2 00 00 00       	jmp    1778 <printf+0xe8>
+    16b6:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    16b8:	83 fa 25             	cmp    $0x25,%edx
+    16bb:	0f 84 bf 00 00 00    	je     1780 <printf+0xf0>
+  write(fd, &c, 1);
+    16c1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    16c4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    16cb:	00 
+    16cc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    16d0:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    16d3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    16d6:	e8 77 fe ff ff       	call   1552 <write>
+    16db:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    16de:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    16e2:	84 d2                	test   %dl,%dl
+    16e4:	0f 84 8e 00 00 00    	je     1778 <printf+0xe8>
+    if(state == 0){
+    16ea:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    16ec:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    16ef:	74 c7                	je     16b8 <printf+0x28>
+      }
+    } else if(state == '%'){
+    16f1:	83 ff 25             	cmp    $0x25,%edi
+    16f4:	75 e5                	jne    16db <printf+0x4b>
+      if(c == 'd'){
+    16f6:	83 fa 64             	cmp    $0x64,%edx
+    16f9:	0f 84 31 01 00 00    	je     1830 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    16ff:	25 f7 00 00 00       	and    $0xf7,%eax
+    1704:	83 f8 70             	cmp    $0x70,%eax
+    1707:	0f 84 83 00 00 00    	je     1790 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    170d:	83 fa 73             	cmp    $0x73,%edx
+    1710:	0f 84 a2 00 00 00    	je     17b8 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1716:	83 fa 63             	cmp    $0x63,%edx
+    1719:	0f 84 35 01 00 00    	je     1854 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    171f:	83 fa 25             	cmp    $0x25,%edx
+    1722:	0f 84 e0 00 00 00    	je     1808 <printf+0x178>
+  write(fd, &c, 1);
+    1728:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    172b:	83 c3 01             	add    $0x1,%ebx
+    172e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1735:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    1736:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    1738:	89 44 24 04          	mov    %eax,0x4(%esp)
+    173c:	89 34 24             	mov    %esi,(%esp)
+    173f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    1742:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    1746:	e8 07 fe ff ff       	call   1552 <write>
+        putc(fd, c);
+    174b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    174e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    1751:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1758:	00 
+    1759:	89 44 24 04          	mov    %eax,0x4(%esp)
+    175d:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    1760:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    1763:	e8 ea fd ff ff       	call   1552 <write>
+  for(i = 0; fmt[i]; i++){
+    1768:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    176c:	84 d2                	test   %dl,%dl
+    176e:	0f 85 76 ff ff ff    	jne    16ea <printf+0x5a>
+    1774:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    1778:	83 c4 3c             	add    $0x3c,%esp
+    177b:	5b                   	pop    %ebx
+    177c:	5e                   	pop    %esi
+    177d:	5f                   	pop    %edi
+    177e:	5d                   	pop    %ebp
+    177f:	c3                   	ret    
+        state = '%';
+    1780:	bf 25 00 00 00       	mov    $0x25,%edi
+    1785:	e9 51 ff ff ff       	jmp    16db <printf+0x4b>
+    178a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    1790:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1793:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    1798:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    179a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    17a1:	8b 10                	mov    (%eax),%edx
+    17a3:	89 f0                	mov    %esi,%eax
+    17a5:	e8 46 fe ff ff       	call   15f0 <printint>
+        ap++;
+    17aa:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    17ae:	e9 28 ff ff ff       	jmp    16db <printf+0x4b>
+    17b3:	90                   	nop
+    17b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    17b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    17bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    17bf:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    17c1:	b8 6a 1a 00 00       	mov    $0x1a6a,%eax
+    17c6:	85 ff                	test   %edi,%edi
+    17c8:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    17cb:	0f b6 07             	movzbl (%edi),%eax
+    17ce:	84 c0                	test   %al,%al
+    17d0:	74 2a                	je     17fc <printf+0x16c>
+    17d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    17d8:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    17db:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    17de:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    17e1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    17e8:	00 
+    17e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    17ed:	89 34 24             	mov    %esi,(%esp)
+    17f0:	e8 5d fd ff ff       	call   1552 <write>
+        while(*s != 0){
+    17f5:	0f b6 07             	movzbl (%edi),%eax
+    17f8:	84 c0                	test   %al,%al
+    17fa:	75 dc                	jne    17d8 <printf+0x148>
+      state = 0;
+    17fc:	31 ff                	xor    %edi,%edi
+    17fe:	e9 d8 fe ff ff       	jmp    16db <printf+0x4b>
+    1803:	90                   	nop
+    1804:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1808:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    180b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    180d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1814:	00 
+    1815:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1819:	89 34 24             	mov    %esi,(%esp)
+    181c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1820:	e8 2d fd ff ff       	call   1552 <write>
+    1825:	e9 b1 fe ff ff       	jmp    16db <printf+0x4b>
+    182a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    1830:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1833:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    1838:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    183b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1842:	8b 10                	mov    (%eax),%edx
+    1844:	89 f0                	mov    %esi,%eax
+    1846:	e8 a5 fd ff ff       	call   15f0 <printint>
+        ap++;
+    184b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    184f:	e9 87 fe ff ff       	jmp    16db <printf+0x4b>
+        putc(fd, *ap);
+    1854:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    1857:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    1859:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    185b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1862:	00 
+    1863:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    1866:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    1869:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    186c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1870:	e8 dd fc ff ff       	call   1552 <write>
+        ap++;
+    1875:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    1879:	e9 5d fe ff ff       	jmp    16db <printf+0x4b>
+    187e:	66 90                	xchg   %ax,%ax
+
+00001880 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    1880:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1881:	a1 20 1e 00 00       	mov    0x1e20,%eax
+{
+    1886:	89 e5                	mov    %esp,%ebp
+    1888:	57                   	push   %edi
+    1889:	56                   	push   %esi
+    188a:	53                   	push   %ebx
+    188b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    188e:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    1890:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1893:	39 d0                	cmp    %edx,%eax
+    1895:	72 11                	jb     18a8 <free+0x28>
+    1897:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1898:	39 c8                	cmp    %ecx,%eax
+    189a:	72 04                	jb     18a0 <free+0x20>
+    189c:	39 ca                	cmp    %ecx,%edx
+    189e:	72 10                	jb     18b0 <free+0x30>
+    18a0:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    18a2:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    18a4:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    18a6:	73 f0                	jae    1898 <free+0x18>
+    18a8:	39 ca                	cmp    %ecx,%edx
+    18aa:	72 04                	jb     18b0 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    18ac:	39 c8                	cmp    %ecx,%eax
+    18ae:	72 f0                	jb     18a0 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    18b0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    18b3:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    18b6:	39 cf                	cmp    %ecx,%edi
+    18b8:	74 1e                	je     18d8 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    18ba:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    18bd:	8b 48 04             	mov    0x4(%eax),%ecx
+    18c0:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    18c3:	39 f2                	cmp    %esi,%edx
+    18c5:	74 28                	je     18ef <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    18c7:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    18c9:	a3 20 1e 00 00       	mov    %eax,0x1e20
+}
+    18ce:	5b                   	pop    %ebx
+    18cf:	5e                   	pop    %esi
+    18d0:	5f                   	pop    %edi
+    18d1:	5d                   	pop    %ebp
+    18d2:	c3                   	ret    
+    18d3:	90                   	nop
+    18d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    18d8:	03 71 04             	add    0x4(%ecx),%esi
+    18db:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    18de:	8b 08                	mov    (%eax),%ecx
+    18e0:	8b 09                	mov    (%ecx),%ecx
+    18e2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    18e5:	8b 48 04             	mov    0x4(%eax),%ecx
+    18e8:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    18eb:	39 f2                	cmp    %esi,%edx
+    18ed:	75 d8                	jne    18c7 <free+0x47>
+    p->s.size += bp->s.size;
+    18ef:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    18f2:	a3 20 1e 00 00       	mov    %eax,0x1e20
+    p->s.size += bp->s.size;
+    18f7:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    18fa:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    18fd:	89 10                	mov    %edx,(%eax)
+}
+    18ff:	5b                   	pop    %ebx
+    1900:	5e                   	pop    %esi
+    1901:	5f                   	pop    %edi
+    1902:	5d                   	pop    %ebp
+    1903:	c3                   	ret    
+    1904:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    190a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001910 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1910:	55                   	push   %ebp
+    1911:	89 e5                	mov    %esp,%ebp
+    1913:	57                   	push   %edi
+    1914:	56                   	push   %esi
+    1915:	53                   	push   %ebx
+    1916:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1919:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    191c:	8b 1d 20 1e 00 00    	mov    0x1e20,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1922:	8d 48 07             	lea    0x7(%eax),%ecx
+    1925:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1928:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    192a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    192d:	0f 84 9b 00 00 00    	je     19ce <malloc+0xbe>
+    1933:	8b 13                	mov    (%ebx),%edx
+    1935:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    1938:	39 fe                	cmp    %edi,%esi
+    193a:	76 64                	jbe    19a0 <malloc+0x90>
+    193c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    1943:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    1948:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    194b:	eb 0e                	jmp    195b <malloc+0x4b>
+    194d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1950:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    1952:	8b 78 04             	mov    0x4(%eax),%edi
+    1955:	39 fe                	cmp    %edi,%esi
+    1957:	76 4f                	jbe    19a8 <malloc+0x98>
+    1959:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    195b:	3b 15 20 1e 00 00    	cmp    0x1e20,%edx
+    1961:	75 ed                	jne    1950 <malloc+0x40>
+  if(nu < 4096)
+    1963:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1966:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    196c:	bf 00 10 00 00       	mov    $0x1000,%edi
+    1971:	0f 43 fe             	cmovae %esi,%edi
+    1974:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    1977:	89 04 24             	mov    %eax,(%esp)
+    197a:	e8 3b fc ff ff       	call   15ba <sbrk>
+  if(p == (char*)-1)
+    197f:	83 f8 ff             	cmp    $0xffffffff,%eax
+    1982:	74 18                	je     199c <malloc+0x8c>
+  hp->s.size = nu;
+    1984:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    1987:	83 c0 08             	add    $0x8,%eax
+    198a:	89 04 24             	mov    %eax,(%esp)
+    198d:	e8 ee fe ff ff       	call   1880 <free>
+  return freep;
+    1992:	8b 15 20 1e 00 00    	mov    0x1e20,%edx
+      if((p = morecore(nunits)) == 0)
+    1998:	85 d2                	test   %edx,%edx
+    199a:	75 b4                	jne    1950 <malloc+0x40>
+        return 0;
+    199c:	31 c0                	xor    %eax,%eax
+    199e:	eb 20                	jmp    19c0 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    19a0:	89 d0                	mov    %edx,%eax
+    19a2:	89 da                	mov    %ebx,%edx
+    19a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    19a8:	39 fe                	cmp    %edi,%esi
+    19aa:	74 1c                	je     19c8 <malloc+0xb8>
+        p->s.size -= nunits;
+    19ac:	29 f7                	sub    %esi,%edi
+    19ae:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    19b1:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    19b4:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    19b7:	89 15 20 1e 00 00    	mov    %edx,0x1e20
+      return (void*)(p + 1);
+    19bd:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    19c0:	83 c4 1c             	add    $0x1c,%esp
+    19c3:	5b                   	pop    %ebx
+    19c4:	5e                   	pop    %esi
+    19c5:	5f                   	pop    %edi
+    19c6:	5d                   	pop    %ebp
+    19c7:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    19c8:	8b 08                	mov    (%eax),%ecx
+    19ca:	89 0a                	mov    %ecx,(%edx)
+    19cc:	eb e9                	jmp    19b7 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    19ce:	c7 05 20 1e 00 00 24 	movl   $0x1e24,0x1e20
+    19d5:	1e 00 00 
+    base.s.size = 0;
+    19d8:	ba 24 1e 00 00       	mov    $0x1e24,%edx
+    base.s.ptr = freep = prevp = &base;
+    19dd:	c7 05 24 1e 00 00 24 	movl   $0x1e24,0x1e24
+    19e4:	1e 00 00 
+    base.s.size = 0;
+    19e7:	c7 05 28 1e 00 00 00 	movl   $0x0,0x1e28
+    19ee:	00 00 00 
+    19f1:	e9 46 ff ff ff       	jmp    193c <malloc+0x2c>
+    19f6:	66 90                	xchg   %ax,%ax
+    19f8:	66 90                	xchg   %ax,%ax
+    19fa:	66 90                	xchg   %ax,%ax
+    19fc:	66 90                	xchg   %ax,%ax
+    19fe:	66 90                	xchg   %ax,%ax
+
+00001a00 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1a00:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1a01:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1a06:	89 e5                	mov    %esp,%ebp
+    1a08:	8b 55 08             	mov    0x8(%ebp),%edx
+    1a0b:	90                   	nop
+    1a0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1a10:	89 c8                	mov    %ecx,%eax
+    1a12:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1a15:	85 c0                	test   %eax,%eax
+    1a17:	75 f7                	jne    1a10 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1a19:	0f ae f0             	mfence 
+}
+    1a1c:	5d                   	pop    %ebp
+    1a1d:	c3                   	ret    
+    1a1e:	66 90                	xchg   %ax,%ax
+
+00001a20 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1a20:	55                   	push   %ebp
+    1a21:	89 e5                	mov    %esp,%ebp
+    1a23:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1a26:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1a29:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    1a2f:	5d                   	pop    %ebp
+    1a30:	c3                   	ret    
diff --git a/grep.c b/grep.c
index 4be3256..adc4835 100644
--- a/grep.c
+++ b/grep.c
@@ -43,24 +43,24 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     printf(2, "usage: grep pattern [file ...]\n");
-    exit(1);
+    exit();
   }
   pattern = argv[1];
 
   if(argc <= 2){
     grep(pattern, 0);
-    exit(2);
+    exit();
   }
 
   for(i = 2; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "grep: cannot open %s\n", argv[i]);
-      exit(3);
+      exit();
     }
     grep(pattern, fd);
     close(fd);
   }
-  exit(0);
+  exit();
 }
 
 // Regexp matcher from Kernighan & Pike,
diff --git a/grep.d b/grep.d
new file mode 100644
index 0000000..15fc65b
--- /dev/null
+++ b/grep.d
@@ -0,0 +1 @@
+grep.o: grep.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/grep.o b/grep.o
new file mode 100644
index 0000000..6698905
Binary files /dev/null and b/grep.o differ
diff --git a/grep.sym b/grep.sym
new file mode 100644
index 0000000..bee3097
--- /dev/null
+++ b/grep.sym
@@ -0,0 +1,67 @@
+00001000 .text
+00001a34 .rodata
+00001a84 .eh_frame
+00001e20 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 grep.c
+00000000 ulib.c
+00000000 printf.c
+000015f0 printint
+00001a71 digits.1359
+00000000 umalloc.c
+00001e20 freep
+00001e24 base
+00000000 uspinlock.c
+00001310 strcpy
+00001690 printf
+00001500 memmove
+00001120 matchhere
+0000157a mknod
+000015d2 shm_open
+00001420 gets
+000015b2 getpid
+00001200 grep
+00001910 malloc
+000015c2 sleep
+00001542 pipe
+00001552 write
+0000158a fstat
+00001562 kill
+000015a2 chdir
+0000156a exec
+0000153a wait
+0000154a read
+00001582 unlink
+00001a00 uacquire
+0000152a fork
+000015ba sbrk
+000015da shm_close
+000015ca uptime
+00001e04 __bss_start
+000013c0 memset
+00001000 main
+000010c0 matchstar
+00001340 strcmp
+000015aa dup
+00001e40 buf
+00001480 stat
+00001e04 _edata
+00002240 _end
+000011b0 match
+00001592 link
+00001532 exit
+000014d0 atoi
+00001390 strlen
+00001572 open
+000013e0 strchr
+0000159a mkdir
+0000155a close
+00001a20 urelease
+00001880 free
diff --git a/ide.d b/ide.d
new file mode 100644
index 0000000..21155b9
--- /dev/null
+++ b/ide.d
@@ -0,0 +1,2 @@
+ide.o: ide.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h proc.h x86.h traps.h spinlock.h sleeplock.h fs.h buf.h
diff --git a/ide.o b/ide.o
new file mode 100644
index 0000000..751c026
Binary files /dev/null and b/ide.o differ
diff --git a/init.asm b/init.asm
new file mode 100644
index 0000000..30a3d54
--- /dev/null
+++ b/init.asm
@@ -0,0 +1,1275 @@
+
+_init:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+
+char *argv[] = { "sh", 0 };
+
+int
+main(void)
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	53                   	push   %ebx
+    1004:	83 e4 f0             	and    $0xfffffff0,%esp
+    1007:	83 ec 10             	sub    $0x10,%esp
+  int pid, wpid;
+
+  if(open("console", O_RDWR) < 0){
+    100a:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+    1011:	00 
+    1012:	c7 04 24 31 18 00 00 	movl   $0x1831,(%esp)
+    1019:	e8 54 03 00 00       	call   1372 <open>
+    101e:	85 c0                	test   %eax,%eax
+    1020:	0f 88 ac 00 00 00    	js     10d2 <main+0xd2>
+    mknod("console", 1, 1);
+    open("console", O_RDWR);
+  }
+  dup(0);  // stdout
+    1026:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    102d:	e8 78 03 00 00       	call   13aa <dup>
+  dup(0);  // stderr
+    1032:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1039:	e8 6c 03 00 00       	call   13aa <dup>
+    103e:	66 90                	xchg   %ax,%ax
+
+  for(;;){
+    printf(1, "init: starting sh\n");
+    1040:	c7 44 24 04 39 18 00 	movl   $0x1839,0x4(%esp)
+    1047:	00 
+    1048:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    104f:	e8 3c 04 00 00       	call   1490 <printf>
+    pid = fork();
+    1054:	e8 d1 02 00 00       	call   132a <fork>
+    if(pid < 0){
+    1059:	85 c0                	test   %eax,%eax
+    pid = fork();
+    105b:	89 c3                	mov    %eax,%ebx
+    if(pid < 0){
+    105d:	78 2d                	js     108c <main+0x8c>
+    105f:	90                   	nop
+      printf(1, "init: fork failed\n");
+      exit();
+    }
+    if(pid == 0){
+    1060:	74 43                	je     10a5 <main+0xa5>
+    1062:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      exec("sh", argv);
+      printf(1, "init: exec sh failed\n");
+      exit();
+    }
+    while((wpid=wait()) >= 0 && wpid != pid)
+    1068:	e8 cd 02 00 00       	call   133a <wait>
+    106d:	85 c0                	test   %eax,%eax
+    106f:	90                   	nop
+    1070:	78 ce                	js     1040 <main+0x40>
+    1072:	39 d8                	cmp    %ebx,%eax
+    1074:	74 ca                	je     1040 <main+0x40>
+      printf(1, "zombie!\n");
+    1076:	c7 44 24 04 78 18 00 	movl   $0x1878,0x4(%esp)
+    107d:	00 
+    107e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1085:	e8 06 04 00 00       	call   1490 <printf>
+    108a:	eb dc                	jmp    1068 <main+0x68>
+      printf(1, "init: fork failed\n");
+    108c:	c7 44 24 04 4c 18 00 	movl   $0x184c,0x4(%esp)
+    1093:	00 
+    1094:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    109b:	e8 f0 03 00 00       	call   1490 <printf>
+      exit();
+    10a0:	e8 8d 02 00 00       	call   1332 <exit>
+      exec("sh", argv);
+    10a5:	c7 44 24 04 40 1b 00 	movl   $0x1b40,0x4(%esp)
+    10ac:	00 
+    10ad:	c7 04 24 5f 18 00 00 	movl   $0x185f,(%esp)
+    10b4:	e8 b1 02 00 00       	call   136a <exec>
+      printf(1, "init: exec sh failed\n");
+    10b9:	c7 44 24 04 62 18 00 	movl   $0x1862,0x4(%esp)
+    10c0:	00 
+    10c1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10c8:	e8 c3 03 00 00       	call   1490 <printf>
+      exit();
+    10cd:	e8 60 02 00 00       	call   1332 <exit>
+    mknod("console", 1, 1);
+    10d2:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    10d9:	00 
+    10da:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+    10e1:	00 
+    10e2:	c7 04 24 31 18 00 00 	movl   $0x1831,(%esp)
+    10e9:	e8 8c 02 00 00       	call   137a <mknod>
+    open("console", O_RDWR);
+    10ee:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+    10f5:	00 
+    10f6:	c7 04 24 31 18 00 00 	movl   $0x1831,(%esp)
+    10fd:	e8 70 02 00 00       	call   1372 <open>
+    1102:	e9 1f ff ff ff       	jmp    1026 <main+0x26>
+    1107:	66 90                	xchg   %ax,%ax
+    1109:	66 90                	xchg   %ax,%ax
+    110b:	66 90                	xchg   %ax,%ax
+    110d:	66 90                	xchg   %ax,%ax
+    110f:	90                   	nop
+
+00001110 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1110:	55                   	push   %ebp
+    1111:	89 e5                	mov    %esp,%ebp
+    1113:	8b 45 08             	mov    0x8(%ebp),%eax
+    1116:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1119:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    111a:	89 c2                	mov    %eax,%edx
+    111c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1120:	83 c1 01             	add    $0x1,%ecx
+    1123:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1127:	83 c2 01             	add    $0x1,%edx
+    112a:	84 db                	test   %bl,%bl
+    112c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    112f:	75 ef                	jne    1120 <strcpy+0x10>
+    ;
+  return os;
+}
+    1131:	5b                   	pop    %ebx
+    1132:	5d                   	pop    %ebp
+    1133:	c3                   	ret    
+    1134:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    113a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001140 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1140:	55                   	push   %ebp
+    1141:	89 e5                	mov    %esp,%ebp
+    1143:	8b 55 08             	mov    0x8(%ebp),%edx
+    1146:	53                   	push   %ebx
+    1147:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    114a:	0f b6 02             	movzbl (%edx),%eax
+    114d:	84 c0                	test   %al,%al
+    114f:	74 2d                	je     117e <strcmp+0x3e>
+    1151:	0f b6 19             	movzbl (%ecx),%ebx
+    1154:	38 d8                	cmp    %bl,%al
+    1156:	74 0e                	je     1166 <strcmp+0x26>
+    1158:	eb 2b                	jmp    1185 <strcmp+0x45>
+    115a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1160:	38 c8                	cmp    %cl,%al
+    1162:	75 15                	jne    1179 <strcmp+0x39>
+    p++, q++;
+    1164:	89 d9                	mov    %ebx,%ecx
+    1166:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    1169:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    116c:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    116f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    1173:	84 c0                	test   %al,%al
+    1175:	75 e9                	jne    1160 <strcmp+0x20>
+    1177:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    1179:	29 c8                	sub    %ecx,%eax
+}
+    117b:	5b                   	pop    %ebx
+    117c:	5d                   	pop    %ebp
+    117d:	c3                   	ret    
+    117e:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    1181:	31 c0                	xor    %eax,%eax
+    1183:	eb f4                	jmp    1179 <strcmp+0x39>
+    1185:	0f b6 cb             	movzbl %bl,%ecx
+    1188:	eb ef                	jmp    1179 <strcmp+0x39>
+    118a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001190 <strlen>:
+
+uint
+strlen(char *s)
+{
+    1190:	55                   	push   %ebp
+    1191:	89 e5                	mov    %esp,%ebp
+    1193:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    1196:	80 39 00             	cmpb   $0x0,(%ecx)
+    1199:	74 12                	je     11ad <strlen+0x1d>
+    119b:	31 d2                	xor    %edx,%edx
+    119d:	8d 76 00             	lea    0x0(%esi),%esi
+    11a0:	83 c2 01             	add    $0x1,%edx
+    11a3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    11a7:	89 d0                	mov    %edx,%eax
+    11a9:	75 f5                	jne    11a0 <strlen+0x10>
+    ;
+  return n;
+}
+    11ab:	5d                   	pop    %ebp
+    11ac:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    11ad:	31 c0                	xor    %eax,%eax
+}
+    11af:	5d                   	pop    %ebp
+    11b0:	c3                   	ret    
+    11b1:	eb 0d                	jmp    11c0 <memset>
+    11b3:	90                   	nop
+    11b4:	90                   	nop
+    11b5:	90                   	nop
+    11b6:	90                   	nop
+    11b7:	90                   	nop
+    11b8:	90                   	nop
+    11b9:	90                   	nop
+    11ba:	90                   	nop
+    11bb:	90                   	nop
+    11bc:	90                   	nop
+    11bd:	90                   	nop
+    11be:	90                   	nop
+    11bf:	90                   	nop
+
+000011c0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    11c0:	55                   	push   %ebp
+    11c1:	89 e5                	mov    %esp,%ebp
+    11c3:	8b 55 08             	mov    0x8(%ebp),%edx
+    11c6:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    11c7:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    11ca:	8b 45 0c             	mov    0xc(%ebp),%eax
+    11cd:	89 d7                	mov    %edx,%edi
+    11cf:	fc                   	cld    
+    11d0:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    11d2:	89 d0                	mov    %edx,%eax
+    11d4:	5f                   	pop    %edi
+    11d5:	5d                   	pop    %ebp
+    11d6:	c3                   	ret    
+    11d7:	89 f6                	mov    %esi,%esi
+    11d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+000011e0 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    11e0:	55                   	push   %ebp
+    11e1:	89 e5                	mov    %esp,%ebp
+    11e3:	8b 45 08             	mov    0x8(%ebp),%eax
+    11e6:	53                   	push   %ebx
+    11e7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    11ea:	0f b6 18             	movzbl (%eax),%ebx
+    11ed:	84 db                	test   %bl,%bl
+    11ef:	74 1d                	je     120e <strchr+0x2e>
+    if(*s == c)
+    11f1:	38 d3                	cmp    %dl,%bl
+    11f3:	89 d1                	mov    %edx,%ecx
+    11f5:	75 0d                	jne    1204 <strchr+0x24>
+    11f7:	eb 17                	jmp    1210 <strchr+0x30>
+    11f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1200:	38 ca                	cmp    %cl,%dl
+    1202:	74 0c                	je     1210 <strchr+0x30>
+  for(; *s; s++)
+    1204:	83 c0 01             	add    $0x1,%eax
+    1207:	0f b6 10             	movzbl (%eax),%edx
+    120a:	84 d2                	test   %dl,%dl
+    120c:	75 f2                	jne    1200 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    120e:	31 c0                	xor    %eax,%eax
+}
+    1210:	5b                   	pop    %ebx
+    1211:	5d                   	pop    %ebp
+    1212:	c3                   	ret    
+    1213:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001220 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1220:	55                   	push   %ebp
+    1221:	89 e5                	mov    %esp,%ebp
+    1223:	57                   	push   %edi
+    1224:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1225:	31 f6                	xor    %esi,%esi
+{
+    1227:	53                   	push   %ebx
+    1228:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    122b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    122e:	eb 31                	jmp    1261 <gets+0x41>
+    cc = read(0, &c, 1);
+    1230:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1237:	00 
+    1238:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    123c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1243:	e8 02 01 00 00       	call   134a <read>
+    if(cc < 1)
+    1248:	85 c0                	test   %eax,%eax
+    124a:	7e 1d                	jle    1269 <gets+0x49>
+      break;
+    buf[i++] = c;
+    124c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    1250:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    1252:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    1255:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    1257:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    125b:	74 0c                	je     1269 <gets+0x49>
+    125d:	3c 0a                	cmp    $0xa,%al
+    125f:	74 08                	je     1269 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    1261:	8d 5e 01             	lea    0x1(%esi),%ebx
+    1264:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    1267:	7c c7                	jl     1230 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    1269:	8b 45 08             	mov    0x8(%ebp),%eax
+    126c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    1270:	83 c4 2c             	add    $0x2c,%esp
+    1273:	5b                   	pop    %ebx
+    1274:	5e                   	pop    %esi
+    1275:	5f                   	pop    %edi
+    1276:	5d                   	pop    %ebp
+    1277:	c3                   	ret    
+    1278:	90                   	nop
+    1279:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001280 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    1280:	55                   	push   %ebp
+    1281:	89 e5                	mov    %esp,%ebp
+    1283:	56                   	push   %esi
+    1284:	53                   	push   %ebx
+    1285:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    1288:	8b 45 08             	mov    0x8(%ebp),%eax
+    128b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1292:	00 
+    1293:	89 04 24             	mov    %eax,(%esp)
+    1296:	e8 d7 00 00 00       	call   1372 <open>
+  if(fd < 0)
+    129b:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    129d:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    129f:	78 27                	js     12c8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    12a1:	8b 45 0c             	mov    0xc(%ebp),%eax
+    12a4:	89 1c 24             	mov    %ebx,(%esp)
+    12a7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    12ab:	e8 da 00 00 00       	call   138a <fstat>
+  close(fd);
+    12b0:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    12b3:	89 c6                	mov    %eax,%esi
+  close(fd);
+    12b5:	e8 a0 00 00 00       	call   135a <close>
+  return r;
+    12ba:	89 f0                	mov    %esi,%eax
+}
+    12bc:	83 c4 10             	add    $0x10,%esp
+    12bf:	5b                   	pop    %ebx
+    12c0:	5e                   	pop    %esi
+    12c1:	5d                   	pop    %ebp
+    12c2:	c3                   	ret    
+    12c3:	90                   	nop
+    12c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    12c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    12cd:	eb ed                	jmp    12bc <stat+0x3c>
+    12cf:	90                   	nop
+
+000012d0 <atoi>:
+
+int
+atoi(const char *s)
+{
+    12d0:	55                   	push   %ebp
+    12d1:	89 e5                	mov    %esp,%ebp
+    12d3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    12d6:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    12d7:	0f be 11             	movsbl (%ecx),%edx
+    12da:	8d 42 d0             	lea    -0x30(%edx),%eax
+    12dd:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    12df:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    12e4:	77 17                	ja     12fd <atoi+0x2d>
+    12e6:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    12e8:	83 c1 01             	add    $0x1,%ecx
+    12eb:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    12ee:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    12f2:	0f be 11             	movsbl (%ecx),%edx
+    12f5:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    12f8:	80 fb 09             	cmp    $0x9,%bl
+    12fb:	76 eb                	jbe    12e8 <atoi+0x18>
+  return n;
+}
+    12fd:	5b                   	pop    %ebx
+    12fe:	5d                   	pop    %ebp
+    12ff:	c3                   	ret    
+
+00001300 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1300:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1301:	31 d2                	xor    %edx,%edx
+{
+    1303:	89 e5                	mov    %esp,%ebp
+    1305:	56                   	push   %esi
+    1306:	8b 45 08             	mov    0x8(%ebp),%eax
+    1309:	53                   	push   %ebx
+    130a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    130d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1310:	85 db                	test   %ebx,%ebx
+    1312:	7e 12                	jle    1326 <memmove+0x26>
+    1314:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1318:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    131c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    131f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1322:	39 da                	cmp    %ebx,%edx
+    1324:	75 f2                	jne    1318 <memmove+0x18>
+  return vdst;
+}
+    1326:	5b                   	pop    %ebx
+    1327:	5e                   	pop    %esi
+    1328:	5d                   	pop    %ebp
+    1329:	c3                   	ret    
+
+0000132a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    132a:	b8 01 00 00 00       	mov    $0x1,%eax
+    132f:	cd 40                	int    $0x40
+    1331:	c3                   	ret    
+
+00001332 <exit>:
+SYSCALL(exit)
+    1332:	b8 02 00 00 00       	mov    $0x2,%eax
+    1337:	cd 40                	int    $0x40
+    1339:	c3                   	ret    
+
+0000133a <wait>:
+SYSCALL(wait)
+    133a:	b8 03 00 00 00       	mov    $0x3,%eax
+    133f:	cd 40                	int    $0x40
+    1341:	c3                   	ret    
+
+00001342 <pipe>:
+SYSCALL(pipe)
+    1342:	b8 04 00 00 00       	mov    $0x4,%eax
+    1347:	cd 40                	int    $0x40
+    1349:	c3                   	ret    
+
+0000134a <read>:
+SYSCALL(read)
+    134a:	b8 05 00 00 00       	mov    $0x5,%eax
+    134f:	cd 40                	int    $0x40
+    1351:	c3                   	ret    
+
+00001352 <write>:
+SYSCALL(write)
+    1352:	b8 10 00 00 00       	mov    $0x10,%eax
+    1357:	cd 40                	int    $0x40
+    1359:	c3                   	ret    
+
+0000135a <close>:
+SYSCALL(close)
+    135a:	b8 15 00 00 00       	mov    $0x15,%eax
+    135f:	cd 40                	int    $0x40
+    1361:	c3                   	ret    
+
+00001362 <kill>:
+SYSCALL(kill)
+    1362:	b8 06 00 00 00       	mov    $0x6,%eax
+    1367:	cd 40                	int    $0x40
+    1369:	c3                   	ret    
+
+0000136a <exec>:
+SYSCALL(exec)
+    136a:	b8 07 00 00 00       	mov    $0x7,%eax
+    136f:	cd 40                	int    $0x40
+    1371:	c3                   	ret    
+
+00001372 <open>:
+SYSCALL(open)
+    1372:	b8 0f 00 00 00       	mov    $0xf,%eax
+    1377:	cd 40                	int    $0x40
+    1379:	c3                   	ret    
+
+0000137a <mknod>:
+SYSCALL(mknod)
+    137a:	b8 11 00 00 00       	mov    $0x11,%eax
+    137f:	cd 40                	int    $0x40
+    1381:	c3                   	ret    
+
+00001382 <unlink>:
+SYSCALL(unlink)
+    1382:	b8 12 00 00 00       	mov    $0x12,%eax
+    1387:	cd 40                	int    $0x40
+    1389:	c3                   	ret    
+
+0000138a <fstat>:
+SYSCALL(fstat)
+    138a:	b8 08 00 00 00       	mov    $0x8,%eax
+    138f:	cd 40                	int    $0x40
+    1391:	c3                   	ret    
+
+00001392 <link>:
+SYSCALL(link)
+    1392:	b8 13 00 00 00       	mov    $0x13,%eax
+    1397:	cd 40                	int    $0x40
+    1399:	c3                   	ret    
+
+0000139a <mkdir>:
+SYSCALL(mkdir)
+    139a:	b8 14 00 00 00       	mov    $0x14,%eax
+    139f:	cd 40                	int    $0x40
+    13a1:	c3                   	ret    
+
+000013a2 <chdir>:
+SYSCALL(chdir)
+    13a2:	b8 09 00 00 00       	mov    $0x9,%eax
+    13a7:	cd 40                	int    $0x40
+    13a9:	c3                   	ret    
+
+000013aa <dup>:
+SYSCALL(dup)
+    13aa:	b8 0a 00 00 00       	mov    $0xa,%eax
+    13af:	cd 40                	int    $0x40
+    13b1:	c3                   	ret    
+
+000013b2 <getpid>:
+SYSCALL(getpid)
+    13b2:	b8 0b 00 00 00       	mov    $0xb,%eax
+    13b7:	cd 40                	int    $0x40
+    13b9:	c3                   	ret    
+
+000013ba <sbrk>:
+SYSCALL(sbrk)
+    13ba:	b8 0c 00 00 00       	mov    $0xc,%eax
+    13bf:	cd 40                	int    $0x40
+    13c1:	c3                   	ret    
+
+000013c2 <sleep>:
+SYSCALL(sleep)
+    13c2:	b8 0d 00 00 00       	mov    $0xd,%eax
+    13c7:	cd 40                	int    $0x40
+    13c9:	c3                   	ret    
+
+000013ca <uptime>:
+SYSCALL(uptime)
+    13ca:	b8 0e 00 00 00       	mov    $0xe,%eax
+    13cf:	cd 40                	int    $0x40
+    13d1:	c3                   	ret    
+
+000013d2 <shm_open>:
+SYSCALL(shm_open)
+    13d2:	b8 16 00 00 00       	mov    $0x16,%eax
+    13d7:	cd 40                	int    $0x40
+    13d9:	c3                   	ret    
+
+000013da <shm_close>:
+SYSCALL(shm_close)	
+    13da:	b8 17 00 00 00       	mov    $0x17,%eax
+    13df:	cd 40                	int    $0x40
+    13e1:	c3                   	ret    
+    13e2:	66 90                	xchg   %ax,%ax
+    13e4:	66 90                	xchg   %ax,%ax
+    13e6:	66 90                	xchg   %ax,%ax
+    13e8:	66 90                	xchg   %ax,%ax
+    13ea:	66 90                	xchg   %ax,%ax
+    13ec:	66 90                	xchg   %ax,%ax
+    13ee:	66 90                	xchg   %ax,%ax
+
+000013f0 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    13f0:	55                   	push   %ebp
+    13f1:	89 e5                	mov    %esp,%ebp
+    13f3:	57                   	push   %edi
+    13f4:	56                   	push   %esi
+    13f5:	89 c6                	mov    %eax,%esi
+    13f7:	53                   	push   %ebx
+    13f8:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    13fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    13fe:	85 db                	test   %ebx,%ebx
+    1400:	74 09                	je     140b <printint+0x1b>
+    1402:	89 d0                	mov    %edx,%eax
+    1404:	c1 e8 1f             	shr    $0x1f,%eax
+    1407:	84 c0                	test   %al,%al
+    1409:	75 75                	jne    1480 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    140b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    140d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1414:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1417:	31 ff                	xor    %edi,%edi
+    1419:	89 ce                	mov    %ecx,%esi
+    141b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    141e:	eb 02                	jmp    1422 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1420:	89 cf                	mov    %ecx,%edi
+    1422:	31 d2                	xor    %edx,%edx
+    1424:	f7 f6                	div    %esi
+    1426:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1429:	0f b6 92 88 18 00 00 	movzbl 0x1888(%edx),%edx
+  }while((x /= base) != 0);
+    1430:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1432:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1435:	75 e9                	jne    1420 <printint+0x30>
+  if(neg)
+    1437:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    143a:	89 c8                	mov    %ecx,%eax
+    143c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    143f:	85 d2                	test   %edx,%edx
+    1441:	74 08                	je     144b <printint+0x5b>
+    buf[i++] = '-';
+    1443:	8d 4f 02             	lea    0x2(%edi),%ecx
+    1446:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    144b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    144e:	66 90                	xchg   %ax,%ax
+    1450:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    1455:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    1458:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    145f:	00 
+    1460:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1464:	89 34 24             	mov    %esi,(%esp)
+    1467:	88 45 d7             	mov    %al,-0x29(%ebp)
+    146a:	e8 e3 fe ff ff       	call   1352 <write>
+  while(--i >= 0)
+    146f:	83 ff ff             	cmp    $0xffffffff,%edi
+    1472:	75 dc                	jne    1450 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    1474:	83 c4 4c             	add    $0x4c,%esp
+    1477:	5b                   	pop    %ebx
+    1478:	5e                   	pop    %esi
+    1479:	5f                   	pop    %edi
+    147a:	5d                   	pop    %ebp
+    147b:	c3                   	ret    
+    147c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    1480:	89 d0                	mov    %edx,%eax
+    1482:	f7 d8                	neg    %eax
+    neg = 1;
+    1484:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    148b:	eb 87                	jmp    1414 <printint+0x24>
+    148d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00001490 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    1490:	55                   	push   %ebp
+    1491:	89 e5                	mov    %esp,%ebp
+    1493:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    1494:	31 ff                	xor    %edi,%edi
+{
+    1496:	56                   	push   %esi
+    1497:	53                   	push   %ebx
+    1498:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    149b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    149e:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    14a1:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    14a4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    14a7:	0f b6 13             	movzbl (%ebx),%edx
+    14aa:	83 c3 01             	add    $0x1,%ebx
+    14ad:	84 d2                	test   %dl,%dl
+    14af:	75 39                	jne    14ea <printf+0x5a>
+    14b1:	e9 c2 00 00 00       	jmp    1578 <printf+0xe8>
+    14b6:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    14b8:	83 fa 25             	cmp    $0x25,%edx
+    14bb:	0f 84 bf 00 00 00    	je     1580 <printf+0xf0>
+  write(fd, &c, 1);
+    14c1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    14c4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14cb:	00 
+    14cc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14d0:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    14d3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    14d6:	e8 77 fe ff ff       	call   1352 <write>
+    14db:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    14de:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    14e2:	84 d2                	test   %dl,%dl
+    14e4:	0f 84 8e 00 00 00    	je     1578 <printf+0xe8>
+    if(state == 0){
+    14ea:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    14ec:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    14ef:	74 c7                	je     14b8 <printf+0x28>
+      }
+    } else if(state == '%'){
+    14f1:	83 ff 25             	cmp    $0x25,%edi
+    14f4:	75 e5                	jne    14db <printf+0x4b>
+      if(c == 'd'){
+    14f6:	83 fa 64             	cmp    $0x64,%edx
+    14f9:	0f 84 31 01 00 00    	je     1630 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    14ff:	25 f7 00 00 00       	and    $0xf7,%eax
+    1504:	83 f8 70             	cmp    $0x70,%eax
+    1507:	0f 84 83 00 00 00    	je     1590 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    150d:	83 fa 73             	cmp    $0x73,%edx
+    1510:	0f 84 a2 00 00 00    	je     15b8 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1516:	83 fa 63             	cmp    $0x63,%edx
+    1519:	0f 84 35 01 00 00    	je     1654 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    151f:	83 fa 25             	cmp    $0x25,%edx
+    1522:	0f 84 e0 00 00 00    	je     1608 <printf+0x178>
+  write(fd, &c, 1);
+    1528:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    152b:	83 c3 01             	add    $0x1,%ebx
+    152e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1535:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    1536:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    1538:	89 44 24 04          	mov    %eax,0x4(%esp)
+    153c:	89 34 24             	mov    %esi,(%esp)
+    153f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    1542:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    1546:	e8 07 fe ff ff       	call   1352 <write>
+        putc(fd, c);
+    154b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    154e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    1551:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1558:	00 
+    1559:	89 44 24 04          	mov    %eax,0x4(%esp)
+    155d:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    1560:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    1563:	e8 ea fd ff ff       	call   1352 <write>
+  for(i = 0; fmt[i]; i++){
+    1568:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    156c:	84 d2                	test   %dl,%dl
+    156e:	0f 85 76 ff ff ff    	jne    14ea <printf+0x5a>
+    1574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    1578:	83 c4 3c             	add    $0x3c,%esp
+    157b:	5b                   	pop    %ebx
+    157c:	5e                   	pop    %esi
+    157d:	5f                   	pop    %edi
+    157e:	5d                   	pop    %ebp
+    157f:	c3                   	ret    
+        state = '%';
+    1580:	bf 25 00 00 00       	mov    $0x25,%edi
+    1585:	e9 51 ff ff ff       	jmp    14db <printf+0x4b>
+    158a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    1590:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1593:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    1598:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    159a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    15a1:	8b 10                	mov    (%eax),%edx
+    15a3:	89 f0                	mov    %esi,%eax
+    15a5:	e8 46 fe ff ff       	call   13f0 <printint>
+        ap++;
+    15aa:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15ae:	e9 28 ff ff ff       	jmp    14db <printf+0x4b>
+    15b3:	90                   	nop
+    15b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    15b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    15bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    15bf:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    15c1:	b8 81 18 00 00       	mov    $0x1881,%eax
+    15c6:	85 ff                	test   %edi,%edi
+    15c8:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    15cb:	0f b6 07             	movzbl (%edi),%eax
+    15ce:	84 c0                	test   %al,%al
+    15d0:	74 2a                	je     15fc <printf+0x16c>
+    15d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    15d8:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    15db:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    15de:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    15e1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    15e8:	00 
+    15e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15ed:	89 34 24             	mov    %esi,(%esp)
+    15f0:	e8 5d fd ff ff       	call   1352 <write>
+        while(*s != 0){
+    15f5:	0f b6 07             	movzbl (%edi),%eax
+    15f8:	84 c0                	test   %al,%al
+    15fa:	75 dc                	jne    15d8 <printf+0x148>
+      state = 0;
+    15fc:	31 ff                	xor    %edi,%edi
+    15fe:	e9 d8 fe ff ff       	jmp    14db <printf+0x4b>
+    1603:	90                   	nop
+    1604:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1608:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    160b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    160d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1614:	00 
+    1615:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1619:	89 34 24             	mov    %esi,(%esp)
+    161c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1620:	e8 2d fd ff ff       	call   1352 <write>
+    1625:	e9 b1 fe ff ff       	jmp    14db <printf+0x4b>
+    162a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    1630:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1633:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    1638:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    163b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1642:	8b 10                	mov    (%eax),%edx
+    1644:	89 f0                	mov    %esi,%eax
+    1646:	e8 a5 fd ff ff       	call   13f0 <printint>
+        ap++;
+    164b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    164f:	e9 87 fe ff ff       	jmp    14db <printf+0x4b>
+        putc(fd, *ap);
+    1654:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    1657:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    1659:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    165b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1662:	00 
+    1663:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    1666:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    1669:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    166c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1670:	e8 dd fc ff ff       	call   1352 <write>
+        ap++;
+    1675:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    1679:	e9 5d fe ff ff       	jmp    14db <printf+0x4b>
+    167e:	66 90                	xchg   %ax,%ax
+
+00001680 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    1680:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1681:	a1 48 1b 00 00       	mov    0x1b48,%eax
+{
+    1686:	89 e5                	mov    %esp,%ebp
+    1688:	57                   	push   %edi
+    1689:	56                   	push   %esi
+    168a:	53                   	push   %ebx
+    168b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    168e:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    1690:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1693:	39 d0                	cmp    %edx,%eax
+    1695:	72 11                	jb     16a8 <free+0x28>
+    1697:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1698:	39 c8                	cmp    %ecx,%eax
+    169a:	72 04                	jb     16a0 <free+0x20>
+    169c:	39 ca                	cmp    %ecx,%edx
+    169e:	72 10                	jb     16b0 <free+0x30>
+    16a0:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16a2:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16a4:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16a6:	73 f0                	jae    1698 <free+0x18>
+    16a8:	39 ca                	cmp    %ecx,%edx
+    16aa:	72 04                	jb     16b0 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16ac:	39 c8                	cmp    %ecx,%eax
+    16ae:	72 f0                	jb     16a0 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    16b0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    16b3:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    16b6:	39 cf                	cmp    %ecx,%edi
+    16b8:	74 1e                	je     16d8 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    16ba:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    16bd:	8b 48 04             	mov    0x4(%eax),%ecx
+    16c0:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    16c3:	39 f2                	cmp    %esi,%edx
+    16c5:	74 28                	je     16ef <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    16c7:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    16c9:	a3 48 1b 00 00       	mov    %eax,0x1b48
+}
+    16ce:	5b                   	pop    %ebx
+    16cf:	5e                   	pop    %esi
+    16d0:	5f                   	pop    %edi
+    16d1:	5d                   	pop    %ebp
+    16d2:	c3                   	ret    
+    16d3:	90                   	nop
+    16d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    16d8:	03 71 04             	add    0x4(%ecx),%esi
+    16db:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    16de:	8b 08                	mov    (%eax),%ecx
+    16e0:	8b 09                	mov    (%ecx),%ecx
+    16e2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    16e5:	8b 48 04             	mov    0x4(%eax),%ecx
+    16e8:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    16eb:	39 f2                	cmp    %esi,%edx
+    16ed:	75 d8                	jne    16c7 <free+0x47>
+    p->s.size += bp->s.size;
+    16ef:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    16f2:	a3 48 1b 00 00       	mov    %eax,0x1b48
+    p->s.size += bp->s.size;
+    16f7:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    16fa:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    16fd:	89 10                	mov    %edx,(%eax)
+}
+    16ff:	5b                   	pop    %ebx
+    1700:	5e                   	pop    %esi
+    1701:	5f                   	pop    %edi
+    1702:	5d                   	pop    %ebp
+    1703:	c3                   	ret    
+    1704:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    170a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001710 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1710:	55                   	push   %ebp
+    1711:	89 e5                	mov    %esp,%ebp
+    1713:	57                   	push   %edi
+    1714:	56                   	push   %esi
+    1715:	53                   	push   %ebx
+    1716:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1719:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    171c:	8b 1d 48 1b 00 00    	mov    0x1b48,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1722:	8d 48 07             	lea    0x7(%eax),%ecx
+    1725:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1728:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    172a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    172d:	0f 84 9b 00 00 00    	je     17ce <malloc+0xbe>
+    1733:	8b 13                	mov    (%ebx),%edx
+    1735:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    1738:	39 fe                	cmp    %edi,%esi
+    173a:	76 64                	jbe    17a0 <malloc+0x90>
+    173c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    1743:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    1748:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    174b:	eb 0e                	jmp    175b <malloc+0x4b>
+    174d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1750:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    1752:	8b 78 04             	mov    0x4(%eax),%edi
+    1755:	39 fe                	cmp    %edi,%esi
+    1757:	76 4f                	jbe    17a8 <malloc+0x98>
+    1759:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    175b:	3b 15 48 1b 00 00    	cmp    0x1b48,%edx
+    1761:	75 ed                	jne    1750 <malloc+0x40>
+  if(nu < 4096)
+    1763:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1766:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    176c:	bf 00 10 00 00       	mov    $0x1000,%edi
+    1771:	0f 43 fe             	cmovae %esi,%edi
+    1774:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    1777:	89 04 24             	mov    %eax,(%esp)
+    177a:	e8 3b fc ff ff       	call   13ba <sbrk>
+  if(p == (char*)-1)
+    177f:	83 f8 ff             	cmp    $0xffffffff,%eax
+    1782:	74 18                	je     179c <malloc+0x8c>
+  hp->s.size = nu;
+    1784:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    1787:	83 c0 08             	add    $0x8,%eax
+    178a:	89 04 24             	mov    %eax,(%esp)
+    178d:	e8 ee fe ff ff       	call   1680 <free>
+  return freep;
+    1792:	8b 15 48 1b 00 00    	mov    0x1b48,%edx
+      if((p = morecore(nunits)) == 0)
+    1798:	85 d2                	test   %edx,%edx
+    179a:	75 b4                	jne    1750 <malloc+0x40>
+        return 0;
+    179c:	31 c0                	xor    %eax,%eax
+    179e:	eb 20                	jmp    17c0 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    17a0:	89 d0                	mov    %edx,%eax
+    17a2:	89 da                	mov    %ebx,%edx
+    17a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    17a8:	39 fe                	cmp    %edi,%esi
+    17aa:	74 1c                	je     17c8 <malloc+0xb8>
+        p->s.size -= nunits;
+    17ac:	29 f7                	sub    %esi,%edi
+    17ae:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    17b1:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    17b4:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    17b7:	89 15 48 1b 00 00    	mov    %edx,0x1b48
+      return (void*)(p + 1);
+    17bd:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    17c0:	83 c4 1c             	add    $0x1c,%esp
+    17c3:	5b                   	pop    %ebx
+    17c4:	5e                   	pop    %esi
+    17c5:	5f                   	pop    %edi
+    17c6:	5d                   	pop    %ebp
+    17c7:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    17c8:	8b 08                	mov    (%eax),%ecx
+    17ca:	89 0a                	mov    %ecx,(%edx)
+    17cc:	eb e9                	jmp    17b7 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    17ce:	c7 05 48 1b 00 00 4c 	movl   $0x1b4c,0x1b48
+    17d5:	1b 00 00 
+    base.s.size = 0;
+    17d8:	ba 4c 1b 00 00       	mov    $0x1b4c,%edx
+    base.s.ptr = freep = prevp = &base;
+    17dd:	c7 05 4c 1b 00 00 4c 	movl   $0x1b4c,0x1b4c
+    17e4:	1b 00 00 
+    base.s.size = 0;
+    17e7:	c7 05 50 1b 00 00 00 	movl   $0x0,0x1b50
+    17ee:	00 00 00 
+    17f1:	e9 46 ff ff ff       	jmp    173c <malloc+0x2c>
+    17f6:	66 90                	xchg   %ax,%ax
+    17f8:	66 90                	xchg   %ax,%ax
+    17fa:	66 90                	xchg   %ax,%ax
+    17fc:	66 90                	xchg   %ax,%ax
+    17fe:	66 90                	xchg   %ax,%ax
+
+00001800 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1800:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1801:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1806:	89 e5                	mov    %esp,%ebp
+    1808:	8b 55 08             	mov    0x8(%ebp),%edx
+    180b:	90                   	nop
+    180c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1810:	89 c8                	mov    %ecx,%eax
+    1812:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1815:	85 c0                	test   %eax,%eax
+    1817:	75 f7                	jne    1810 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1819:	0f ae f0             	mfence 
+}
+    181c:	5d                   	pop    %ebp
+    181d:	c3                   	ret    
+    181e:	66 90                	xchg   %ax,%ax
+
+00001820 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1820:	55                   	push   %ebp
+    1821:	89 e5                	mov    %esp,%ebp
+    1823:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1826:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1829:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    182f:	5d                   	pop    %ebp
+    1830:	c3                   	ret    
diff --git a/init.c b/init.c
index bc6547f..046b551 100644
--- a/init.c
+++ b/init.c
@@ -24,14 +24,14 @@ main(void)
     pid = fork();
     if(pid < 0){
       printf(1, "init: fork failed\n");
-      exit(2);
+      exit();
     }
     if(pid == 0){
       exec("sh", argv);
       printf(1, "init: exec sh failed\n");
-      exit(1);
+      exit();
     }
-    while((wpid=wait(NULL)) >= 0 && wpid != pid)
+    while((wpid=wait()) >= 0 && wpid != pid)
       printf(1, "zombie!\n");
   }
 }
diff --git a/init.d b/init.d
new file mode 100644
index 0000000..ee304c8
--- /dev/null
+++ b/init.d
@@ -0,0 +1 @@
+init.o: init.c /usr/include/stdc-predef.h types.h stat.h user.h fcntl.h
diff --git a/init.o b/init.o
new file mode 100644
index 0000000..8944bcf
Binary files /dev/null and b/init.o differ
diff --git a/init.sym b/init.sym
new file mode 100644
index 0000000..13cf85e
--- /dev/null
+++ b/init.sym
@@ -0,0 +1,64 @@
+00001000 .text
+00001831 .rodata
+0000189c .eh_frame
+00001b40 .data
+00001b48 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 init.c
+00000000 ulib.c
+00000000 printf.c
+000013f0 printint
+00001888 digits.1359
+00000000 umalloc.c
+00001b48 freep
+00001b4c base
+00000000 uspinlock.c
+00001110 strcpy
+00001490 printf
+00001b40 argv
+00001300 memmove
+0000137a mknod
+000013d2 shm_open
+00001220 gets
+000013b2 getpid
+00001710 malloc
+000013c2 sleep
+00001342 pipe
+00001352 write
+0000138a fstat
+00001362 kill
+000013a2 chdir
+0000136a exec
+0000133a wait
+0000134a read
+00001382 unlink
+00001800 uacquire
+0000132a fork
+000013ba sbrk
+000013da shm_close
+000013ca uptime
+00001b48 __bss_start
+000011c0 memset
+00001000 main
+00001140 strcmp
+000013aa dup
+00001280 stat
+00001b48 _edata
+00001b54 _end
+00001392 link
+00001332 exit
+000012d0 atoi
+00001190 strlen
+00001372 open
+000011e0 strchr
+0000139a mkdir
+0000135a close
+00001820 urelease
+00001680 free
diff --git a/initcode b/initcode
new file mode 100644
index 0000000..773d26c
Binary files /dev/null and b/initcode differ
diff --git a/initcode.asm b/initcode.asm
new file mode 100644
index 0000000..3d5dae2
--- /dev/null
+++ b/initcode.asm
@@ -0,0 +1,43 @@
+
+initcode.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <start>:
+
+
+# exec(init, argv)
+.globl start
+start:
+  pushl $argv
+   0:	68 24 00 00 00       	push   $0x24
+  pushl $init
+   5:	68 1c 00 00 00       	push   $0x1c
+  pushl $0  // where caller pc would be
+   a:	6a 00                	push   $0x0
+  movl $SYS_exec, %eax
+   c:	b8 07 00 00 00       	mov    $0x7,%eax
+  int $T_SYSCALL
+  11:	cd 40                	int    $0x40
+
+00000013 <exit>:
+
+# for(;;) exit();
+exit:
+  movl $SYS_exit, %eax
+  13:	b8 02 00 00 00       	mov    $0x2,%eax
+  int $T_SYSCALL
+  18:	cd 40                	int    $0x40
+  jmp exit
+  1a:	eb f7                	jmp    13 <exit>
+
+0000001c <init>:
+  1c:	2f                   	das    
+  1d:	69 6e 69 74 00 00 90 	imul   $0x90000074,0x69(%esi),%ebp
+
+00000024 <argv>:
+  24:	1c 00                	sbb    $0x0,%al
+  26:	00 00                	add    %al,(%eax)
+  28:	00 00                	add    %al,(%eax)
+	...
diff --git a/initcode.d b/initcode.d
new file mode 100644
index 0000000..ab1af4d
--- /dev/null
+++ b/initcode.d
@@ -0,0 +1 @@
+initcode.o: initcode.S syscall.h traps.h
diff --git a/initcode.o b/initcode.o
new file mode 100644
index 0000000..9105df8
Binary files /dev/null and b/initcode.o differ
diff --git a/initcode.out b/initcode.out
new file mode 100644
index 0000000..90fead8
Binary files /dev/null and b/initcode.out differ
diff --git a/ioapic.d b/ioapic.d
new file mode 100644
index 0000000..997e68a
--- /dev/null
+++ b/ioapic.d
@@ -0,0 +1 @@
+ioapic.o: ioapic.c /usr/include/stdc-predef.h types.h defs.h traps.h
diff --git a/ioapic.o b/ioapic.o
new file mode 100644
index 0000000..06b0b45
Binary files /dev/null and b/ioapic.o differ
diff --git a/kalloc.d b/kalloc.d
new file mode 100644
index 0000000..512c5db
--- /dev/null
+++ b/kalloc.d
@@ -0,0 +1,2 @@
+kalloc.o: kalloc.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h spinlock.h
diff --git a/kalloc.o b/kalloc.o
new file mode 100644
index 0000000..020978a
Binary files /dev/null and b/kalloc.o differ
diff --git a/kbd.d b/kbd.d
new file mode 100644
index 0000000..92532ba
--- /dev/null
+++ b/kbd.d
@@ -0,0 +1 @@
+kbd.o: kbd.c /usr/include/stdc-predef.h types.h x86.h defs.h kbd.h
diff --git a/kbd.o b/kbd.o
new file mode 100644
index 0000000..4be9216
Binary files /dev/null and b/kbd.o differ
diff --git a/kernel b/kernel
new file mode 100644
index 0000000..2eb8aad
Binary files /dev/null and b/kernel differ
diff --git a/kernel.asm b/kernel.asm
new file mode 100644
index 0000000..16ad337
--- /dev/null
+++ b/kernel.asm
@@ -0,0 +1,14907 @@
+
+kernel:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+80100000 <multiboot_header>:
+80100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
+80100006:	00 00                	add    %al,(%eax)
+80100008:	fe 4f 52             	decb   0x52(%edi)
+8010000b:	e4                   	.byte 0xe4
+
+8010000c <entry>:
+
+# Entering xv6 on boot processor, with paging off.
+.globl entry
+entry:
+  # Turn on page size extension for 4Mbyte pages
+  movl    %cr4, %eax
+8010000c:	0f 20 e0             	mov    %cr4,%eax
+  orl     $(CR4_PSE), %eax
+8010000f:	83 c8 10             	or     $0x10,%eax
+  movl    %eax, %cr4
+80100012:	0f 22 e0             	mov    %eax,%cr4
+  # Set page directory
+  movl    $(V2P_WO(entrypgdir)), %eax
+80100015:	b8 00 90 10 00       	mov    $0x109000,%eax
+  movl    %eax, %cr3
+8010001a:	0f 22 d8             	mov    %eax,%cr3
+  # Turn on paging.
+  movl    %cr0, %eax
+8010001d:	0f 20 c0             	mov    %cr0,%eax
+  orl     $(CR0_PG|CR0_WP), %eax
+80100020:	0d 00 00 01 80       	or     $0x80010000,%eax
+  movl    %eax, %cr0
+80100025:	0f 22 c0             	mov    %eax,%cr0
+
+  # Set up the stack pointer.
+  movl $(stack + KSTACKSIZE), %esp
+80100028:	bc c0 b5 10 80       	mov    $0x8010b5c0,%esp
+
+  # Jump to main(), and switch to executing at
+  # high addresses. The indirect call is needed because
+  # the assembler produces a PC-relative instruction
+  # for a direct jump.
+  mov $main, %eax
+8010002d:	b8 00 2e 10 80       	mov    $0x80102e00,%eax
+  jmp *%eax
+80100032:	ff e0                	jmp    *%eax
+80100034:	66 90                	xchg   %ax,%ax
+80100036:	66 90                	xchg   %ax,%ax
+80100038:	66 90                	xchg   %ax,%ax
+8010003a:	66 90                	xchg   %ax,%ax
+8010003c:	66 90                	xchg   %ax,%ax
+8010003e:	66 90                	xchg   %ax,%ax
+
+80100040 <binit>:
+  struct buf head;
+} bcache;
+
+void
+binit(void)
+{
+80100040:	55                   	push   %ebp
+80100041:	89 e5                	mov    %esp,%ebp
+80100043:	53                   	push   %ebx
+
+//PAGEBREAK!
+  // Create linked list of buffers
+  bcache.head.prev = &bcache.head;
+  bcache.head.next = &bcache.head;
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+80100044:	bb f4 b5 10 80       	mov    $0x8010b5f4,%ebx
+{
+80100049:	83 ec 14             	sub    $0x14,%esp
+  initlock(&bcache.lock, "bcache");
+8010004c:	c7 44 24 04 20 6d 10 	movl   $0x80106d20,0x4(%esp)
+80100053:	80 
+80100054:	c7 04 24 c0 b5 10 80 	movl   $0x8010b5c0,(%esp)
+8010005b:	e8 00 40 00 00       	call   80104060 <initlock>
+  bcache.head.next = &bcache.head;
+80100060:	ba bc fc 10 80       	mov    $0x8010fcbc,%edx
+  bcache.head.prev = &bcache.head;
+80100065:	c7 05 0c fd 10 80 bc 	movl   $0x8010fcbc,0x8010fd0c
+8010006c:	fc 10 80 
+  bcache.head.next = &bcache.head;
+8010006f:	c7 05 10 fd 10 80 bc 	movl   $0x8010fcbc,0x8010fd10
+80100076:	fc 10 80 
+80100079:	eb 09                	jmp    80100084 <binit+0x44>
+8010007b:	90                   	nop
+8010007c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80100080:	89 da                	mov    %ebx,%edx
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+80100082:	89 c3                	mov    %eax,%ebx
+80100084:	8d 43 0c             	lea    0xc(%ebx),%eax
+    b->next = bcache.head.next;
+80100087:	89 53 54             	mov    %edx,0x54(%ebx)
+    b->prev = &bcache.head;
+8010008a:	c7 43 50 bc fc 10 80 	movl   $0x8010fcbc,0x50(%ebx)
+    initsleeplock(&b->lock, "buffer");
+80100091:	89 04 24             	mov    %eax,(%esp)
+80100094:	c7 44 24 04 27 6d 10 	movl   $0x80106d27,0x4(%esp)
+8010009b:	80 
+8010009c:	e8 af 3e 00 00       	call   80103f50 <initsleeplock>
+    bcache.head.next->prev = b;
+801000a1:	a1 10 fd 10 80       	mov    0x8010fd10,%eax
+801000a6:	89 58 50             	mov    %ebx,0x50(%eax)
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+801000a9:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
+801000af:	3d bc fc 10 80       	cmp    $0x8010fcbc,%eax
+    bcache.head.next = b;
+801000b4:	89 1d 10 fd 10 80    	mov    %ebx,0x8010fd10
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+801000ba:	75 c4                	jne    80100080 <binit+0x40>
+  }
+}
+801000bc:	83 c4 14             	add    $0x14,%esp
+801000bf:	5b                   	pop    %ebx
+801000c0:	5d                   	pop    %ebp
+801000c1:	c3                   	ret    
+801000c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801000c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801000d0 <bread>:
+}
+
+// Return a locked buf with the contents of the indicated block.
+struct buf*
+bread(uint dev, uint blockno)
+{
+801000d0:	55                   	push   %ebp
+801000d1:	89 e5                	mov    %esp,%ebp
+801000d3:	57                   	push   %edi
+801000d4:	56                   	push   %esi
+801000d5:	53                   	push   %ebx
+801000d6:	83 ec 1c             	sub    $0x1c,%esp
+801000d9:	8b 75 08             	mov    0x8(%ebp),%esi
+  acquire(&bcache.lock);
+801000dc:	c7 04 24 c0 b5 10 80 	movl   $0x8010b5c0,(%esp)
+{
+801000e3:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  acquire(&bcache.lock);
+801000e6:	e8 65 40 00 00       	call   80104150 <acquire>
+  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+801000eb:	8b 1d 10 fd 10 80    	mov    0x8010fd10,%ebx
+801000f1:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
+801000f7:	75 12                	jne    8010010b <bread+0x3b>
+801000f9:	eb 25                	jmp    80100120 <bread+0x50>
+801000fb:	90                   	nop
+801000fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80100100:	8b 5b 54             	mov    0x54(%ebx),%ebx
+80100103:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
+80100109:	74 15                	je     80100120 <bread+0x50>
+    if(b->dev == dev && b->blockno == blockno){
+8010010b:	3b 73 04             	cmp    0x4(%ebx),%esi
+8010010e:	75 f0                	jne    80100100 <bread+0x30>
+80100110:	3b 7b 08             	cmp    0x8(%ebx),%edi
+80100113:	75 eb                	jne    80100100 <bread+0x30>
+      b->refcnt++;
+80100115:	83 43 4c 01          	addl   $0x1,0x4c(%ebx)
+80100119:	eb 3f                	jmp    8010015a <bread+0x8a>
+8010011b:	90                   	nop
+8010011c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+80100120:	8b 1d 0c fd 10 80    	mov    0x8010fd0c,%ebx
+80100126:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
+8010012c:	75 0d                	jne    8010013b <bread+0x6b>
+8010012e:	eb 58                	jmp    80100188 <bread+0xb8>
+80100130:	8b 5b 50             	mov    0x50(%ebx),%ebx
+80100133:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
+80100139:	74 4d                	je     80100188 <bread+0xb8>
+    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
+8010013b:	8b 43 4c             	mov    0x4c(%ebx),%eax
+8010013e:	85 c0                	test   %eax,%eax
+80100140:	75 ee                	jne    80100130 <bread+0x60>
+80100142:	f6 03 04             	testb  $0x4,(%ebx)
+80100145:	75 e9                	jne    80100130 <bread+0x60>
+      b->dev = dev;
+80100147:	89 73 04             	mov    %esi,0x4(%ebx)
+      b->blockno = blockno;
+8010014a:	89 7b 08             	mov    %edi,0x8(%ebx)
+      b->flags = 0;
+8010014d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+      b->refcnt = 1;
+80100153:	c7 43 4c 01 00 00 00 	movl   $0x1,0x4c(%ebx)
+      release(&bcache.lock);
+8010015a:	c7 04 24 c0 b5 10 80 	movl   $0x8010b5c0,(%esp)
+80100161:	e8 da 40 00 00       	call   80104240 <release>
+      acquiresleep(&b->lock);
+80100166:	8d 43 0c             	lea    0xc(%ebx),%eax
+80100169:	89 04 24             	mov    %eax,(%esp)
+8010016c:	e8 1f 3e 00 00       	call   80103f90 <acquiresleep>
+  struct buf *b;
+
+  b = bget(dev, blockno);
+  if((b->flags & B_VALID) == 0) {
+80100171:	f6 03 02             	testb  $0x2,(%ebx)
+80100174:	75 08                	jne    8010017e <bread+0xae>
+    iderw(b);
+80100176:	89 1c 24             	mov    %ebx,(%esp)
+80100179:	e8 b2 1f 00 00       	call   80102130 <iderw>
+  }
+  return b;
+}
+8010017e:	83 c4 1c             	add    $0x1c,%esp
+80100181:	89 d8                	mov    %ebx,%eax
+80100183:	5b                   	pop    %ebx
+80100184:	5e                   	pop    %esi
+80100185:	5f                   	pop    %edi
+80100186:	5d                   	pop    %ebp
+80100187:	c3                   	ret    
+  panic("bget: no buffers");
+80100188:	c7 04 24 2e 6d 10 80 	movl   $0x80106d2e,(%esp)
+8010018f:	e8 cc 01 00 00       	call   80100360 <panic>
+80100194:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+8010019a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+801001a0 <bwrite>:
+
+// Write b's contents to disk.  Must be locked.
+void
+bwrite(struct buf *b)
+{
+801001a0:	55                   	push   %ebp
+801001a1:	89 e5                	mov    %esp,%ebp
+801001a3:	53                   	push   %ebx
+801001a4:	83 ec 14             	sub    $0x14,%esp
+801001a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(!holdingsleep(&b->lock))
+801001aa:	8d 43 0c             	lea    0xc(%ebx),%eax
+801001ad:	89 04 24             	mov    %eax,(%esp)
+801001b0:	e8 7b 3e 00 00       	call   80104030 <holdingsleep>
+801001b5:	85 c0                	test   %eax,%eax
+801001b7:	74 10                	je     801001c9 <bwrite+0x29>
+    panic("bwrite");
+  b->flags |= B_DIRTY;
+801001b9:	83 0b 04             	orl    $0x4,(%ebx)
+  iderw(b);
+801001bc:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+801001bf:	83 c4 14             	add    $0x14,%esp
+801001c2:	5b                   	pop    %ebx
+801001c3:	5d                   	pop    %ebp
+  iderw(b);
+801001c4:	e9 67 1f 00 00       	jmp    80102130 <iderw>
+    panic("bwrite");
+801001c9:	c7 04 24 3f 6d 10 80 	movl   $0x80106d3f,(%esp)
+801001d0:	e8 8b 01 00 00       	call   80100360 <panic>
+801001d5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801001d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801001e0 <brelse>:
+
+// Release a locked buffer.
+// Move to the head of the MRU list.
+void
+brelse(struct buf *b)
+{
+801001e0:	55                   	push   %ebp
+801001e1:	89 e5                	mov    %esp,%ebp
+801001e3:	56                   	push   %esi
+801001e4:	53                   	push   %ebx
+801001e5:	83 ec 10             	sub    $0x10,%esp
+801001e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(!holdingsleep(&b->lock))
+801001eb:	8d 73 0c             	lea    0xc(%ebx),%esi
+801001ee:	89 34 24             	mov    %esi,(%esp)
+801001f1:	e8 3a 3e 00 00       	call   80104030 <holdingsleep>
+801001f6:	85 c0                	test   %eax,%eax
+801001f8:	74 5b                	je     80100255 <brelse+0x75>
+    panic("brelse");
+
+  releasesleep(&b->lock);
+801001fa:	89 34 24             	mov    %esi,(%esp)
+801001fd:	e8 ee 3d 00 00       	call   80103ff0 <releasesleep>
+
+  acquire(&bcache.lock);
+80100202:	c7 04 24 c0 b5 10 80 	movl   $0x8010b5c0,(%esp)
+80100209:	e8 42 3f 00 00       	call   80104150 <acquire>
+  b->refcnt--;
+  if (b->refcnt == 0) {
+8010020e:	83 6b 4c 01          	subl   $0x1,0x4c(%ebx)
+80100212:	75 2f                	jne    80100243 <brelse+0x63>
+    // no one is waiting for it.
+    b->next->prev = b->prev;
+80100214:	8b 43 54             	mov    0x54(%ebx),%eax
+80100217:	8b 53 50             	mov    0x50(%ebx),%edx
+8010021a:	89 50 50             	mov    %edx,0x50(%eax)
+    b->prev->next = b->next;
+8010021d:	8b 43 50             	mov    0x50(%ebx),%eax
+80100220:	8b 53 54             	mov    0x54(%ebx),%edx
+80100223:	89 50 54             	mov    %edx,0x54(%eax)
+    b->next = bcache.head.next;
+80100226:	a1 10 fd 10 80       	mov    0x8010fd10,%eax
+    b->prev = &bcache.head;
+8010022b:	c7 43 50 bc fc 10 80 	movl   $0x8010fcbc,0x50(%ebx)
+    b->next = bcache.head.next;
+80100232:	89 43 54             	mov    %eax,0x54(%ebx)
+    bcache.head.next->prev = b;
+80100235:	a1 10 fd 10 80       	mov    0x8010fd10,%eax
+8010023a:	89 58 50             	mov    %ebx,0x50(%eax)
+    bcache.head.next = b;
+8010023d:	89 1d 10 fd 10 80    	mov    %ebx,0x8010fd10
+  }
+  
+  release(&bcache.lock);
+80100243:	c7 45 08 c0 b5 10 80 	movl   $0x8010b5c0,0x8(%ebp)
+}
+8010024a:	83 c4 10             	add    $0x10,%esp
+8010024d:	5b                   	pop    %ebx
+8010024e:	5e                   	pop    %esi
+8010024f:	5d                   	pop    %ebp
+  release(&bcache.lock);
+80100250:	e9 eb 3f 00 00       	jmp    80104240 <release>
+    panic("brelse");
+80100255:	c7 04 24 46 6d 10 80 	movl   $0x80106d46,(%esp)
+8010025c:	e8 ff 00 00 00       	call   80100360 <panic>
+80100261:	66 90                	xchg   %ax,%ax
+80100263:	66 90                	xchg   %ax,%ax
+80100265:	66 90                	xchg   %ax,%ax
+80100267:	66 90                	xchg   %ax,%ax
+80100269:	66 90                	xchg   %ax,%ax
+8010026b:	66 90                	xchg   %ax,%ax
+8010026d:	66 90                	xchg   %ax,%ax
+8010026f:	90                   	nop
+
+80100270 <consoleread>:
+  }
+}
+
+int
+consoleread(struct inode *ip, char *dst, int n)
+{
+80100270:	55                   	push   %ebp
+80100271:	89 e5                	mov    %esp,%ebp
+80100273:	57                   	push   %edi
+80100274:	56                   	push   %esi
+80100275:	53                   	push   %ebx
+80100276:	83 ec 1c             	sub    $0x1c,%esp
+80100279:	8b 7d 08             	mov    0x8(%ebp),%edi
+8010027c:	8b 75 0c             	mov    0xc(%ebp),%esi
+  uint target;
+  int c;
+
+  iunlock(ip);
+8010027f:	89 3c 24             	mov    %edi,(%esp)
+80100282:	e8 19 15 00 00       	call   801017a0 <iunlock>
+  target = n;
+  acquire(&cons.lock);
+80100287:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+8010028e:	e8 bd 3e 00 00       	call   80104150 <acquire>
+  while(n > 0){
+80100293:	8b 55 10             	mov    0x10(%ebp),%edx
+80100296:	85 d2                	test   %edx,%edx
+80100298:	0f 8e bc 00 00 00    	jle    8010035a <consoleread+0xea>
+8010029e:	8b 5d 10             	mov    0x10(%ebp),%ebx
+801002a1:	eb 25                	jmp    801002c8 <consoleread+0x58>
+801002a3:	90                   	nop
+801002a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    while(input.r == input.w){
+      if(myproc()->killed){
+801002a8:	e8 03 34 00 00       	call   801036b0 <myproc>
+801002ad:	8b 40 24             	mov    0x24(%eax),%eax
+801002b0:	85 c0                	test   %eax,%eax
+801002b2:	75 74                	jne    80100328 <consoleread+0xb8>
+        release(&cons.lock);
+        ilock(ip);
+        return -1;
+      }
+      sleep(&input.r, &cons.lock);
+801002b4:	c7 44 24 04 20 a5 10 	movl   $0x8010a520,0x4(%esp)
+801002bb:	80 
+801002bc:	c7 04 24 a0 ff 10 80 	movl   $0x8010ffa0,(%esp)
+801002c3:	e8 48 39 00 00       	call   80103c10 <sleep>
+    while(input.r == input.w){
+801002c8:	a1 a0 ff 10 80       	mov    0x8010ffa0,%eax
+801002cd:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
+801002d3:	74 d3                	je     801002a8 <consoleread+0x38>
+    }
+    c = input.buf[input.r++ % INPUT_BUF];
+801002d5:	8d 50 01             	lea    0x1(%eax),%edx
+801002d8:	89 15 a0 ff 10 80    	mov    %edx,0x8010ffa0
+801002de:	89 c2                	mov    %eax,%edx
+801002e0:	83 e2 7f             	and    $0x7f,%edx
+801002e3:	0f b6 8a 20 ff 10 80 	movzbl -0x7fef00e0(%edx),%ecx
+801002ea:	0f be d1             	movsbl %cl,%edx
+    if(c == C('D')){  // EOF
+801002ed:	83 fa 04             	cmp    $0x4,%edx
+801002f0:	74 57                	je     80100349 <consoleread+0xd9>
+        // caller gets a 0-byte result.
+        input.r--;
+      }
+      break;
+    }
+    *dst++ = c;
+801002f2:	83 c6 01             	add    $0x1,%esi
+    --n;
+801002f5:	83 eb 01             	sub    $0x1,%ebx
+    if(c == '\n')
+801002f8:	83 fa 0a             	cmp    $0xa,%edx
+    *dst++ = c;
+801002fb:	88 4e ff             	mov    %cl,-0x1(%esi)
+    if(c == '\n')
+801002fe:	74 53                	je     80100353 <consoleread+0xe3>
+  while(n > 0){
+80100300:	85 db                	test   %ebx,%ebx
+80100302:	75 c4                	jne    801002c8 <consoleread+0x58>
+80100304:	8b 45 10             	mov    0x10(%ebp),%eax
+      break;
+  }
+  release(&cons.lock);
+80100307:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+8010030e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80100311:	e8 2a 3f 00 00       	call   80104240 <release>
+  ilock(ip);
+80100316:	89 3c 24             	mov    %edi,(%esp)
+80100319:	e8 a2 13 00 00       	call   801016c0 <ilock>
+8010031e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+
+  return target - n;
+80100321:	eb 1e                	jmp    80100341 <consoleread+0xd1>
+80100323:	90                   	nop
+80100324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        release(&cons.lock);
+80100328:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+8010032f:	e8 0c 3f 00 00       	call   80104240 <release>
+        ilock(ip);
+80100334:	89 3c 24             	mov    %edi,(%esp)
+80100337:	e8 84 13 00 00       	call   801016c0 <ilock>
+        return -1;
+8010033c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80100341:	83 c4 1c             	add    $0x1c,%esp
+80100344:	5b                   	pop    %ebx
+80100345:	5e                   	pop    %esi
+80100346:	5f                   	pop    %edi
+80100347:	5d                   	pop    %ebp
+80100348:	c3                   	ret    
+      if(n < target){
+80100349:	39 5d 10             	cmp    %ebx,0x10(%ebp)
+8010034c:	76 05                	jbe    80100353 <consoleread+0xe3>
+        input.r--;
+8010034e:	a3 a0 ff 10 80       	mov    %eax,0x8010ffa0
+80100353:	8b 45 10             	mov    0x10(%ebp),%eax
+80100356:	29 d8                	sub    %ebx,%eax
+80100358:	eb ad                	jmp    80100307 <consoleread+0x97>
+  while(n > 0){
+8010035a:	31 c0                	xor    %eax,%eax
+8010035c:	eb a9                	jmp    80100307 <consoleread+0x97>
+8010035e:	66 90                	xchg   %ax,%ax
+
+80100360 <panic>:
+{
+80100360:	55                   	push   %ebp
+80100361:	89 e5                	mov    %esp,%ebp
+80100363:	56                   	push   %esi
+80100364:	53                   	push   %ebx
+80100365:	83 ec 40             	sub    $0x40,%esp
+}
+
+static inline void
+cli(void)
+{
+  asm volatile("cli");
+80100368:	fa                   	cli    
+  cons.locking = 0;
+80100369:	c7 05 54 a5 10 80 00 	movl   $0x0,0x8010a554
+80100370:	00 00 00 
+  getcallerpcs(&s, pcs);
+80100373:	8d 5d d0             	lea    -0x30(%ebp),%ebx
+  cprintf("lapicid %d: panic: ", lapicid());
+80100376:	e8 f5 23 00 00       	call   80102770 <lapicid>
+8010037b:	8d 75 f8             	lea    -0x8(%ebp),%esi
+8010037e:	c7 04 24 4d 6d 10 80 	movl   $0x80106d4d,(%esp)
+80100385:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100389:	e8 c2 02 00 00       	call   80100650 <cprintf>
+  cprintf(s);
+8010038e:	8b 45 08             	mov    0x8(%ebp),%eax
+80100391:	89 04 24             	mov    %eax,(%esp)
+80100394:	e8 b7 02 00 00       	call   80100650 <cprintf>
+  cprintf("\n");
+80100399:	c7 04 24 9f 76 10 80 	movl   $0x8010769f,(%esp)
+801003a0:	e8 ab 02 00 00       	call   80100650 <cprintf>
+  getcallerpcs(&s, pcs);
+801003a5:	8d 45 08             	lea    0x8(%ebp),%eax
+801003a8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+801003ac:	89 04 24             	mov    %eax,(%esp)
+801003af:	e8 cc 3c 00 00       	call   80104080 <getcallerpcs>
+801003b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    cprintf(" %p", pcs[i]);
+801003b8:	8b 03                	mov    (%ebx),%eax
+801003ba:	83 c3 04             	add    $0x4,%ebx
+801003bd:	c7 04 24 61 6d 10 80 	movl   $0x80106d61,(%esp)
+801003c4:	89 44 24 04          	mov    %eax,0x4(%esp)
+801003c8:	e8 83 02 00 00       	call   80100650 <cprintf>
+  for(i=0; i<10; i++)
+801003cd:	39 f3                	cmp    %esi,%ebx
+801003cf:	75 e7                	jne    801003b8 <panic+0x58>
+  panicked = 1; // freeze other CPU
+801003d1:	c7 05 58 a5 10 80 01 	movl   $0x1,0x8010a558
+801003d8:	00 00 00 
+801003db:	eb fe                	jmp    801003db <panic+0x7b>
+801003dd:	8d 76 00             	lea    0x0(%esi),%esi
+
+801003e0 <consputc>:
+  if(panicked){
+801003e0:	8b 15 58 a5 10 80    	mov    0x8010a558,%edx
+801003e6:	85 d2                	test   %edx,%edx
+801003e8:	74 06                	je     801003f0 <consputc+0x10>
+801003ea:	fa                   	cli    
+801003eb:	eb fe                	jmp    801003eb <consputc+0xb>
+801003ed:	8d 76 00             	lea    0x0(%esi),%esi
+{
+801003f0:	55                   	push   %ebp
+801003f1:	89 e5                	mov    %esp,%ebp
+801003f3:	57                   	push   %edi
+801003f4:	56                   	push   %esi
+801003f5:	53                   	push   %ebx
+801003f6:	89 c3                	mov    %eax,%ebx
+801003f8:	83 ec 1c             	sub    $0x1c,%esp
+  if(c == BACKSPACE){
+801003fb:	3d 00 01 00 00       	cmp    $0x100,%eax
+80100400:	0f 84 ac 00 00 00    	je     801004b2 <consputc+0xd2>
+    uartputc(c);
+80100406:	89 04 24             	mov    %eax,(%esp)
+80100409:	e8 d2 53 00 00       	call   801057e0 <uartputc>
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+8010040e:	bf d4 03 00 00       	mov    $0x3d4,%edi
+80100413:	b8 0e 00 00 00       	mov    $0xe,%eax
+80100418:	89 fa                	mov    %edi,%edx
+8010041a:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+8010041b:	be d5 03 00 00       	mov    $0x3d5,%esi
+80100420:	89 f2                	mov    %esi,%edx
+80100422:	ec                   	in     (%dx),%al
+  pos = inb(CRTPORT+1) << 8;
+80100423:	0f b6 c8             	movzbl %al,%ecx
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80100426:	89 fa                	mov    %edi,%edx
+80100428:	c1 e1 08             	shl    $0x8,%ecx
+8010042b:	b8 0f 00 00 00       	mov    $0xf,%eax
+80100430:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80100431:	89 f2                	mov    %esi,%edx
+80100433:	ec                   	in     (%dx),%al
+  pos |= inb(CRTPORT+1);
+80100434:	0f b6 c0             	movzbl %al,%eax
+80100437:	09 c1                	or     %eax,%ecx
+  if(c == '\n')
+80100439:	83 fb 0a             	cmp    $0xa,%ebx
+8010043c:	0f 84 0d 01 00 00    	je     8010054f <consputc+0x16f>
+  else if(c == BACKSPACE){
+80100442:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
+80100448:	0f 84 e8 00 00 00    	je     80100536 <consputc+0x156>
+    crt[pos++] = (c&0xff) | 0x0700;  // black on white
+8010044e:	0f b6 db             	movzbl %bl,%ebx
+80100451:	80 cf 07             	or     $0x7,%bh
+80100454:	8d 79 01             	lea    0x1(%ecx),%edi
+80100457:	66 89 9c 09 00 80 0b 	mov    %bx,-0x7ff48000(%ecx,%ecx,1)
+8010045e:	80 
+  if(pos < 0 || pos > 25*80)
+8010045f:	81 ff d0 07 00 00    	cmp    $0x7d0,%edi
+80100465:	0f 87 bf 00 00 00    	ja     8010052a <consputc+0x14a>
+  if((pos/80) >= 24){  // Scroll up.
+8010046b:	81 ff 7f 07 00 00    	cmp    $0x77f,%edi
+80100471:	7f 68                	jg     801004db <consputc+0xfb>
+80100473:	89 f8                	mov    %edi,%eax
+80100475:	89 fb                	mov    %edi,%ebx
+80100477:	c1 e8 08             	shr    $0x8,%eax
+8010047a:	89 c6                	mov    %eax,%esi
+8010047c:	8d 8c 3f 00 80 0b 80 	lea    -0x7ff48000(%edi,%edi,1),%ecx
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80100483:	bf d4 03 00 00       	mov    $0x3d4,%edi
+80100488:	b8 0e 00 00 00       	mov    $0xe,%eax
+8010048d:	89 fa                	mov    %edi,%edx
+8010048f:	ee                   	out    %al,(%dx)
+80100490:	89 f0                	mov    %esi,%eax
+80100492:	b2 d5                	mov    $0xd5,%dl
+80100494:	ee                   	out    %al,(%dx)
+80100495:	b8 0f 00 00 00       	mov    $0xf,%eax
+8010049a:	89 fa                	mov    %edi,%edx
+8010049c:	ee                   	out    %al,(%dx)
+8010049d:	89 d8                	mov    %ebx,%eax
+8010049f:	b2 d5                	mov    $0xd5,%dl
+801004a1:	ee                   	out    %al,(%dx)
+  crt[pos] = ' ' | 0x0700;
+801004a2:	b8 20 07 00 00       	mov    $0x720,%eax
+801004a7:	66 89 01             	mov    %ax,(%ecx)
+}
+801004aa:	83 c4 1c             	add    $0x1c,%esp
+801004ad:	5b                   	pop    %ebx
+801004ae:	5e                   	pop    %esi
+801004af:	5f                   	pop    %edi
+801004b0:	5d                   	pop    %ebp
+801004b1:	c3                   	ret    
+    uartputc('\b'); uartputc(' '); uartputc('\b');
+801004b2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+801004b9:	e8 22 53 00 00       	call   801057e0 <uartputc>
+801004be:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+801004c5:	e8 16 53 00 00       	call   801057e0 <uartputc>
+801004ca:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+801004d1:	e8 0a 53 00 00       	call   801057e0 <uartputc>
+801004d6:	e9 33 ff ff ff       	jmp    8010040e <consputc+0x2e>
+    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+801004db:	c7 44 24 08 60 0e 00 	movl   $0xe60,0x8(%esp)
+801004e2:	00 
+    pos -= 80;
+801004e3:	8d 5f b0             	lea    -0x50(%edi),%ebx
+    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+801004e6:	c7 44 24 04 a0 80 0b 	movl   $0x800b80a0,0x4(%esp)
+801004ed:	80 
+    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+801004ee:	8d b4 1b 00 80 0b 80 	lea    -0x7ff48000(%ebx,%ebx,1),%esi
+    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+801004f5:	c7 04 24 00 80 0b 80 	movl   $0x800b8000,(%esp)
+801004fc:	e8 2f 3e 00 00       	call   80104330 <memmove>
+    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+80100501:	b8 d0 07 00 00       	mov    $0x7d0,%eax
+80100506:	29 f8                	sub    %edi,%eax
+80100508:	01 c0                	add    %eax,%eax
+8010050a:	89 34 24             	mov    %esi,(%esp)
+8010050d:	89 44 24 08          	mov    %eax,0x8(%esp)
+80100511:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80100518:	00 
+80100519:	e8 72 3d 00 00       	call   80104290 <memset>
+8010051e:	89 f1                	mov    %esi,%ecx
+80100520:	be 07 00 00 00       	mov    $0x7,%esi
+80100525:	e9 59 ff ff ff       	jmp    80100483 <consputc+0xa3>
+    panic("pos under/overflow");
+8010052a:	c7 04 24 65 6d 10 80 	movl   $0x80106d65,(%esp)
+80100531:	e8 2a fe ff ff       	call   80100360 <panic>
+    if(pos > 0) --pos;
+80100536:	85 c9                	test   %ecx,%ecx
+80100538:	8d 79 ff             	lea    -0x1(%ecx),%edi
+8010053b:	0f 85 1e ff ff ff    	jne    8010045f <consputc+0x7f>
+80100541:	b9 00 80 0b 80       	mov    $0x800b8000,%ecx
+80100546:	31 db                	xor    %ebx,%ebx
+80100548:	31 f6                	xor    %esi,%esi
+8010054a:	e9 34 ff ff ff       	jmp    80100483 <consputc+0xa3>
+    pos += 80 - pos%80;
+8010054f:	89 c8                	mov    %ecx,%eax
+80100551:	ba 67 66 66 66       	mov    $0x66666667,%edx
+80100556:	f7 ea                	imul   %edx
+80100558:	c1 ea 05             	shr    $0x5,%edx
+8010055b:	8d 04 92             	lea    (%edx,%edx,4),%eax
+8010055e:	c1 e0 04             	shl    $0x4,%eax
+80100561:	8d 78 50             	lea    0x50(%eax),%edi
+80100564:	e9 f6 fe ff ff       	jmp    8010045f <consputc+0x7f>
+80100569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80100570 <printint>:
+{
+80100570:	55                   	push   %ebp
+80100571:	89 e5                	mov    %esp,%ebp
+80100573:	57                   	push   %edi
+80100574:	56                   	push   %esi
+80100575:	89 d6                	mov    %edx,%esi
+80100577:	53                   	push   %ebx
+80100578:	83 ec 1c             	sub    $0x1c,%esp
+  if(sign && (sign = xx < 0))
+8010057b:	85 c9                	test   %ecx,%ecx
+8010057d:	74 61                	je     801005e0 <printint+0x70>
+8010057f:	85 c0                	test   %eax,%eax
+80100581:	79 5d                	jns    801005e0 <printint+0x70>
+    x = -xx;
+80100583:	f7 d8                	neg    %eax
+80100585:	bf 01 00 00 00       	mov    $0x1,%edi
+  i = 0;
+8010058a:	31 c9                	xor    %ecx,%ecx
+8010058c:	eb 04                	jmp    80100592 <printint+0x22>
+8010058e:	66 90                	xchg   %ax,%ax
+    buf[i++] = digits[x % base];
+80100590:	89 d9                	mov    %ebx,%ecx
+80100592:	31 d2                	xor    %edx,%edx
+80100594:	f7 f6                	div    %esi
+80100596:	8d 59 01             	lea    0x1(%ecx),%ebx
+80100599:	0f b6 92 90 6d 10 80 	movzbl -0x7fef9270(%edx),%edx
+  }while((x /= base) != 0);
+801005a0:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+801005a2:	88 54 1d d7          	mov    %dl,-0x29(%ebp,%ebx,1)
+  }while((x /= base) != 0);
+801005a6:	75 e8                	jne    80100590 <printint+0x20>
+  if(sign)
+801005a8:	85 ff                	test   %edi,%edi
+    buf[i++] = digits[x % base];
+801005aa:	89 d8                	mov    %ebx,%eax
+  if(sign)
+801005ac:	74 08                	je     801005b6 <printint+0x46>
+    buf[i++] = '-';
+801005ae:	8d 59 02             	lea    0x2(%ecx),%ebx
+801005b1:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+  while(--i >= 0)
+801005b6:	83 eb 01             	sub    $0x1,%ebx
+801005b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    consputc(buf[i]);
+801005c0:	0f be 44 1d d8       	movsbl -0x28(%ebp,%ebx,1),%eax
+  while(--i >= 0)
+801005c5:	83 eb 01             	sub    $0x1,%ebx
+    consputc(buf[i]);
+801005c8:	e8 13 fe ff ff       	call   801003e0 <consputc>
+  while(--i >= 0)
+801005cd:	83 fb ff             	cmp    $0xffffffff,%ebx
+801005d0:	75 ee                	jne    801005c0 <printint+0x50>
+}
+801005d2:	83 c4 1c             	add    $0x1c,%esp
+801005d5:	5b                   	pop    %ebx
+801005d6:	5e                   	pop    %esi
+801005d7:	5f                   	pop    %edi
+801005d8:	5d                   	pop    %ebp
+801005d9:	c3                   	ret    
+801005da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    x = xx;
+801005e0:	31 ff                	xor    %edi,%edi
+801005e2:	eb a6                	jmp    8010058a <printint+0x1a>
+801005e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+801005ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+801005f0 <consolewrite>:
+
+int
+consolewrite(struct inode *ip, char *buf, int n)
+{
+801005f0:	55                   	push   %ebp
+801005f1:	89 e5                	mov    %esp,%ebp
+801005f3:	57                   	push   %edi
+801005f4:	56                   	push   %esi
+801005f5:	53                   	push   %ebx
+801005f6:	83 ec 1c             	sub    $0x1c,%esp
+  int i;
+
+  iunlock(ip);
+801005f9:	8b 45 08             	mov    0x8(%ebp),%eax
+{
+801005fc:	8b 75 10             	mov    0x10(%ebp),%esi
+  iunlock(ip);
+801005ff:	89 04 24             	mov    %eax,(%esp)
+80100602:	e8 99 11 00 00       	call   801017a0 <iunlock>
+  acquire(&cons.lock);
+80100607:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+8010060e:	e8 3d 3b 00 00       	call   80104150 <acquire>
+80100613:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  for(i = 0; i < n; i++)
+80100616:	85 f6                	test   %esi,%esi
+80100618:	8d 1c 37             	lea    (%edi,%esi,1),%ebx
+8010061b:	7e 12                	jle    8010062f <consolewrite+0x3f>
+8010061d:	8d 76 00             	lea    0x0(%esi),%esi
+    consputc(buf[i] & 0xff);
+80100620:	0f b6 07             	movzbl (%edi),%eax
+80100623:	83 c7 01             	add    $0x1,%edi
+80100626:	e8 b5 fd ff ff       	call   801003e0 <consputc>
+  for(i = 0; i < n; i++)
+8010062b:	39 df                	cmp    %ebx,%edi
+8010062d:	75 f1                	jne    80100620 <consolewrite+0x30>
+  release(&cons.lock);
+8010062f:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+80100636:	e8 05 3c 00 00       	call   80104240 <release>
+  ilock(ip);
+8010063b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010063e:	89 04 24             	mov    %eax,(%esp)
+80100641:	e8 7a 10 00 00       	call   801016c0 <ilock>
+
+  return n;
+}
+80100646:	83 c4 1c             	add    $0x1c,%esp
+80100649:	89 f0                	mov    %esi,%eax
+8010064b:	5b                   	pop    %ebx
+8010064c:	5e                   	pop    %esi
+8010064d:	5f                   	pop    %edi
+8010064e:	5d                   	pop    %ebp
+8010064f:	c3                   	ret    
+
+80100650 <cprintf>:
+{
+80100650:	55                   	push   %ebp
+80100651:	89 e5                	mov    %esp,%ebp
+80100653:	57                   	push   %edi
+80100654:	56                   	push   %esi
+80100655:	53                   	push   %ebx
+80100656:	83 ec 1c             	sub    $0x1c,%esp
+  locking = cons.locking;
+80100659:	a1 54 a5 10 80       	mov    0x8010a554,%eax
+  if(locking)
+8010065e:	85 c0                	test   %eax,%eax
+  locking = cons.locking;
+80100660:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  if(locking)
+80100663:	0f 85 27 01 00 00    	jne    80100790 <cprintf+0x140>
+  if (fmt == 0)
+80100669:	8b 45 08             	mov    0x8(%ebp),%eax
+8010066c:	85 c0                	test   %eax,%eax
+8010066e:	89 c1                	mov    %eax,%ecx
+80100670:	0f 84 2b 01 00 00    	je     801007a1 <cprintf+0x151>
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+80100676:	0f b6 00             	movzbl (%eax),%eax
+80100679:	31 db                	xor    %ebx,%ebx
+8010067b:	89 cf                	mov    %ecx,%edi
+8010067d:	8d 75 0c             	lea    0xc(%ebp),%esi
+80100680:	85 c0                	test   %eax,%eax
+80100682:	75 4c                	jne    801006d0 <cprintf+0x80>
+80100684:	eb 5f                	jmp    801006e5 <cprintf+0x95>
+80100686:	66 90                	xchg   %ax,%ax
+    c = fmt[++i] & 0xff;
+80100688:	83 c3 01             	add    $0x1,%ebx
+8010068b:	0f b6 14 1f          	movzbl (%edi,%ebx,1),%edx
+    if(c == 0)
+8010068f:	85 d2                	test   %edx,%edx
+80100691:	74 52                	je     801006e5 <cprintf+0x95>
+    switch(c){
+80100693:	83 fa 70             	cmp    $0x70,%edx
+80100696:	74 72                	je     8010070a <cprintf+0xba>
+80100698:	7f 66                	jg     80100700 <cprintf+0xb0>
+8010069a:	83 fa 25             	cmp    $0x25,%edx
+8010069d:	8d 76 00             	lea    0x0(%esi),%esi
+801006a0:	0f 84 a2 00 00 00    	je     80100748 <cprintf+0xf8>
+801006a6:	83 fa 64             	cmp    $0x64,%edx
+801006a9:	75 7d                	jne    80100728 <cprintf+0xd8>
+      printint(*argp++, 10, 1);
+801006ab:	8d 46 04             	lea    0x4(%esi),%eax
+801006ae:	b9 01 00 00 00       	mov    $0x1,%ecx
+801006b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+801006b6:	8b 06                	mov    (%esi),%eax
+801006b8:	ba 0a 00 00 00       	mov    $0xa,%edx
+801006bd:	e8 ae fe ff ff       	call   80100570 <printint>
+801006c2:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+801006c5:	83 c3 01             	add    $0x1,%ebx
+801006c8:	0f b6 04 1f          	movzbl (%edi,%ebx,1),%eax
+801006cc:	85 c0                	test   %eax,%eax
+801006ce:	74 15                	je     801006e5 <cprintf+0x95>
+    if(c != '%'){
+801006d0:	83 f8 25             	cmp    $0x25,%eax
+801006d3:	74 b3                	je     80100688 <cprintf+0x38>
+      consputc(c);
+801006d5:	e8 06 fd ff ff       	call   801003e0 <consputc>
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+801006da:	83 c3 01             	add    $0x1,%ebx
+801006dd:	0f b6 04 1f          	movzbl (%edi,%ebx,1),%eax
+801006e1:	85 c0                	test   %eax,%eax
+801006e3:	75 eb                	jne    801006d0 <cprintf+0x80>
+  if(locking)
+801006e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801006e8:	85 c0                	test   %eax,%eax
+801006ea:	74 0c                	je     801006f8 <cprintf+0xa8>
+    release(&cons.lock);
+801006ec:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+801006f3:	e8 48 3b 00 00       	call   80104240 <release>
+}
+801006f8:	83 c4 1c             	add    $0x1c,%esp
+801006fb:	5b                   	pop    %ebx
+801006fc:	5e                   	pop    %esi
+801006fd:	5f                   	pop    %edi
+801006fe:	5d                   	pop    %ebp
+801006ff:	c3                   	ret    
+    switch(c){
+80100700:	83 fa 73             	cmp    $0x73,%edx
+80100703:	74 53                	je     80100758 <cprintf+0x108>
+80100705:	83 fa 78             	cmp    $0x78,%edx
+80100708:	75 1e                	jne    80100728 <cprintf+0xd8>
+      printint(*argp++, 16, 0);
+8010070a:	8d 46 04             	lea    0x4(%esi),%eax
+8010070d:	31 c9                	xor    %ecx,%ecx
+8010070f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80100712:	8b 06                	mov    (%esi),%eax
+80100714:	ba 10 00 00 00       	mov    $0x10,%edx
+80100719:	e8 52 fe ff ff       	call   80100570 <printint>
+8010071e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+      break;
+80100721:	eb a2                	jmp    801006c5 <cprintf+0x75>
+80100723:	90                   	nop
+80100724:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      consputc('%');
+80100728:	b8 25 00 00 00       	mov    $0x25,%eax
+8010072d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+80100730:	e8 ab fc ff ff       	call   801003e0 <consputc>
+      consputc(c);
+80100735:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80100738:	89 d0                	mov    %edx,%eax
+8010073a:	e8 a1 fc ff ff       	call   801003e0 <consputc>
+8010073f:	eb 99                	jmp    801006da <cprintf+0x8a>
+80100741:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      consputc('%');
+80100748:	b8 25 00 00 00       	mov    $0x25,%eax
+8010074d:	e8 8e fc ff ff       	call   801003e0 <consputc>
+      break;
+80100752:	e9 6e ff ff ff       	jmp    801006c5 <cprintf+0x75>
+80100757:	90                   	nop
+      if((s = (char*)*argp++) == 0)
+80100758:	8d 46 04             	lea    0x4(%esi),%eax
+8010075b:	8b 36                	mov    (%esi),%esi
+8010075d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        s = "(null)";
+80100760:	b8 78 6d 10 80       	mov    $0x80106d78,%eax
+80100765:	85 f6                	test   %esi,%esi
+80100767:	0f 44 f0             	cmove  %eax,%esi
+      for(; *s; s++)
+8010076a:	0f be 06             	movsbl (%esi),%eax
+8010076d:	84 c0                	test   %al,%al
+8010076f:	74 16                	je     80100787 <cprintf+0x137>
+80100771:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80100778:	83 c6 01             	add    $0x1,%esi
+        consputc(*s);
+8010077b:	e8 60 fc ff ff       	call   801003e0 <consputc>
+      for(; *s; s++)
+80100780:	0f be 06             	movsbl (%esi),%eax
+80100783:	84 c0                	test   %al,%al
+80100785:	75 f1                	jne    80100778 <cprintf+0x128>
+      if((s = (char*)*argp++) == 0)
+80100787:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+8010078a:	e9 36 ff ff ff       	jmp    801006c5 <cprintf+0x75>
+8010078f:	90                   	nop
+    acquire(&cons.lock);
+80100790:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+80100797:	e8 b4 39 00 00       	call   80104150 <acquire>
+8010079c:	e9 c8 fe ff ff       	jmp    80100669 <cprintf+0x19>
+    panic("null fmt");
+801007a1:	c7 04 24 7f 6d 10 80 	movl   $0x80106d7f,(%esp)
+801007a8:	e8 b3 fb ff ff       	call   80100360 <panic>
+801007ad:	8d 76 00             	lea    0x0(%esi),%esi
+
+801007b0 <consoleintr>:
+{
+801007b0:	55                   	push   %ebp
+801007b1:	89 e5                	mov    %esp,%ebp
+801007b3:	57                   	push   %edi
+801007b4:	56                   	push   %esi
+  int c, doprocdump = 0;
+801007b5:	31 f6                	xor    %esi,%esi
+{
+801007b7:	53                   	push   %ebx
+801007b8:	83 ec 1c             	sub    $0x1c,%esp
+801007bb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&cons.lock);
+801007be:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+801007c5:	e8 86 39 00 00       	call   80104150 <acquire>
+801007ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  while((c = getc()) >= 0){
+801007d0:	ff d3                	call   *%ebx
+801007d2:	85 c0                	test   %eax,%eax
+801007d4:	89 c7                	mov    %eax,%edi
+801007d6:	78 48                	js     80100820 <consoleintr+0x70>
+    switch(c){
+801007d8:	83 ff 10             	cmp    $0x10,%edi
+801007db:	0f 84 2f 01 00 00    	je     80100910 <consoleintr+0x160>
+801007e1:	7e 5d                	jle    80100840 <consoleintr+0x90>
+801007e3:	83 ff 15             	cmp    $0x15,%edi
+801007e6:	0f 84 d4 00 00 00    	je     801008c0 <consoleintr+0x110>
+801007ec:	83 ff 7f             	cmp    $0x7f,%edi
+801007ef:	90                   	nop
+801007f0:	75 53                	jne    80100845 <consoleintr+0x95>
+      if(input.e != input.w){
+801007f2:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+801007f7:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
+801007fd:	74 d1                	je     801007d0 <consoleintr+0x20>
+        input.e--;
+801007ff:	83 e8 01             	sub    $0x1,%eax
+80100802:	a3 a8 ff 10 80       	mov    %eax,0x8010ffa8
+        consputc(BACKSPACE);
+80100807:	b8 00 01 00 00       	mov    $0x100,%eax
+8010080c:	e8 cf fb ff ff       	call   801003e0 <consputc>
+  while((c = getc()) >= 0){
+80100811:	ff d3                	call   *%ebx
+80100813:	85 c0                	test   %eax,%eax
+80100815:	89 c7                	mov    %eax,%edi
+80100817:	79 bf                	jns    801007d8 <consoleintr+0x28>
+80100819:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  release(&cons.lock);
+80100820:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+80100827:	e8 14 3a 00 00       	call   80104240 <release>
+  if(doprocdump) {
+8010082c:	85 f6                	test   %esi,%esi
+8010082e:	0f 85 ec 00 00 00    	jne    80100920 <consoleintr+0x170>
+}
+80100834:	83 c4 1c             	add    $0x1c,%esp
+80100837:	5b                   	pop    %ebx
+80100838:	5e                   	pop    %esi
+80100839:	5f                   	pop    %edi
+8010083a:	5d                   	pop    %ebp
+8010083b:	c3                   	ret    
+8010083c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    switch(c){
+80100840:	83 ff 08             	cmp    $0x8,%edi
+80100843:	74 ad                	je     801007f2 <consoleintr+0x42>
+      if(c != 0 && input.e-input.r < INPUT_BUF){
+80100845:	85 ff                	test   %edi,%edi
+80100847:	74 87                	je     801007d0 <consoleintr+0x20>
+80100849:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+8010084e:	89 c2                	mov    %eax,%edx
+80100850:	2b 15 a0 ff 10 80    	sub    0x8010ffa0,%edx
+80100856:	83 fa 7f             	cmp    $0x7f,%edx
+80100859:	0f 87 71 ff ff ff    	ja     801007d0 <consoleintr+0x20>
+        input.buf[input.e++ % INPUT_BUF] = c;
+8010085f:	8d 50 01             	lea    0x1(%eax),%edx
+80100862:	83 e0 7f             	and    $0x7f,%eax
+        c = (c == '\r') ? '\n' : c;
+80100865:	83 ff 0d             	cmp    $0xd,%edi
+        input.buf[input.e++ % INPUT_BUF] = c;
+80100868:	89 15 a8 ff 10 80    	mov    %edx,0x8010ffa8
+        c = (c == '\r') ? '\n' : c;
+8010086e:	0f 84 b8 00 00 00    	je     8010092c <consoleintr+0x17c>
+        input.buf[input.e++ % INPUT_BUF] = c;
+80100874:	89 f9                	mov    %edi,%ecx
+80100876:	88 88 20 ff 10 80    	mov    %cl,-0x7fef00e0(%eax)
+        consputc(c);
+8010087c:	89 f8                	mov    %edi,%eax
+8010087e:	e8 5d fb ff ff       	call   801003e0 <consputc>
+        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
+80100883:	83 ff 04             	cmp    $0x4,%edi
+80100886:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+8010088b:	74 19                	je     801008a6 <consoleintr+0xf6>
+8010088d:	83 ff 0a             	cmp    $0xa,%edi
+80100890:	74 14                	je     801008a6 <consoleintr+0xf6>
+80100892:	8b 0d a0 ff 10 80    	mov    0x8010ffa0,%ecx
+80100898:	8d 91 80 00 00 00    	lea    0x80(%ecx),%edx
+8010089e:	39 d0                	cmp    %edx,%eax
+801008a0:	0f 85 2a ff ff ff    	jne    801007d0 <consoleintr+0x20>
+          wakeup(&input.r);
+801008a6:	c7 04 24 a0 ff 10 80 	movl   $0x8010ffa0,(%esp)
+          input.w = input.e;
+801008ad:	a3 a4 ff 10 80       	mov    %eax,0x8010ffa4
+          wakeup(&input.r);
+801008b2:	e8 e9 34 00 00       	call   80103da0 <wakeup>
+801008b7:	e9 14 ff ff ff       	jmp    801007d0 <consoleintr+0x20>
+801008bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      while(input.e != input.w &&
+801008c0:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+801008c5:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
+801008cb:	75 2b                	jne    801008f8 <consoleintr+0x148>
+801008cd:	e9 fe fe ff ff       	jmp    801007d0 <consoleintr+0x20>
+801008d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        input.e--;
+801008d8:	a3 a8 ff 10 80       	mov    %eax,0x8010ffa8
+        consputc(BACKSPACE);
+801008dd:	b8 00 01 00 00       	mov    $0x100,%eax
+801008e2:	e8 f9 fa ff ff       	call   801003e0 <consputc>
+      while(input.e != input.w &&
+801008e7:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+801008ec:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
+801008f2:	0f 84 d8 fe ff ff    	je     801007d0 <consoleintr+0x20>
+            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+801008f8:	83 e8 01             	sub    $0x1,%eax
+801008fb:	89 c2                	mov    %eax,%edx
+801008fd:	83 e2 7f             	and    $0x7f,%edx
+      while(input.e != input.w &&
+80100900:	80 ba 20 ff 10 80 0a 	cmpb   $0xa,-0x7fef00e0(%edx)
+80100907:	75 cf                	jne    801008d8 <consoleintr+0x128>
+80100909:	e9 c2 fe ff ff       	jmp    801007d0 <consoleintr+0x20>
+8010090e:	66 90                	xchg   %ax,%ax
+      doprocdump = 1;
+80100910:	be 01 00 00 00       	mov    $0x1,%esi
+80100915:	e9 b6 fe ff ff       	jmp    801007d0 <consoleintr+0x20>
+8010091a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+}
+80100920:	83 c4 1c             	add    $0x1c,%esp
+80100923:	5b                   	pop    %ebx
+80100924:	5e                   	pop    %esi
+80100925:	5f                   	pop    %edi
+80100926:	5d                   	pop    %ebp
+    procdump();  // now call procdump() wo. cons.lock held
+80100927:	e9 54 35 00 00       	jmp    80103e80 <procdump>
+        input.buf[input.e++ % INPUT_BUF] = c;
+8010092c:	c6 80 20 ff 10 80 0a 	movb   $0xa,-0x7fef00e0(%eax)
+        consputc(c);
+80100933:	b8 0a 00 00 00       	mov    $0xa,%eax
+80100938:	e8 a3 fa ff ff       	call   801003e0 <consputc>
+8010093d:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+80100942:	e9 5f ff ff ff       	jmp    801008a6 <consoleintr+0xf6>
+80100947:	89 f6                	mov    %esi,%esi
+80100949:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80100950 <consoleinit>:
+
+void
+consoleinit(void)
+{
+80100950:	55                   	push   %ebp
+80100951:	89 e5                	mov    %esp,%ebp
+80100953:	83 ec 18             	sub    $0x18,%esp
+  initlock(&cons.lock, "console");
+80100956:	c7 44 24 04 88 6d 10 	movl   $0x80106d88,0x4(%esp)
+8010095d:	80 
+8010095e:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+80100965:	e8 f6 36 00 00       	call   80104060 <initlock>
+
+  devsw[CONSOLE].write = consolewrite;
+  devsw[CONSOLE].read = consoleread;
+  cons.locking = 1;
+
+  ioapicenable(IRQ_KBD, 0);
+8010096a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80100971:	00 
+80100972:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  devsw[CONSOLE].write = consolewrite;
+80100979:	c7 05 6c 09 11 80 f0 	movl   $0x801005f0,0x8011096c
+80100980:	05 10 80 
+  devsw[CONSOLE].read = consoleread;
+80100983:	c7 05 68 09 11 80 70 	movl   $0x80100270,0x80110968
+8010098a:	02 10 80 
+  cons.locking = 1;
+8010098d:	c7 05 54 a5 10 80 01 	movl   $0x1,0x8010a554
+80100994:	00 00 00 
+  ioapicenable(IRQ_KBD, 0);
+80100997:	e8 24 19 00 00       	call   801022c0 <ioapicenable>
+}
+8010099c:	c9                   	leave  
+8010099d:	c3                   	ret    
+8010099e:	66 90                	xchg   %ax,%ax
+
+801009a0 <exec>:
+#include "x86.h"
+#include "elf.h"
+
+int
+exec(char *path, char **argv)
+{
+801009a0:	55                   	push   %ebp
+801009a1:	89 e5                	mov    %esp,%ebp
+801009a3:	57                   	push   %edi
+801009a4:	56                   	push   %esi
+801009a5:	53                   	push   %ebx
+801009a6:	81 ec 2c 01 00 00    	sub    $0x12c,%esp
+  uint argc, sz, sp, ustack[3+MAXARG+1];
+  struct elfhdr elf;
+  struct inode *ip;
+  struct proghdr ph;
+  pde_t *pgdir, *oldpgdir;
+  struct proc *curproc = myproc();
+801009ac:	e8 ff 2c 00 00       	call   801036b0 <myproc>
+801009b1:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
+
+  begin_op();
+801009b7:	e8 64 21 00 00       	call   80102b20 <begin_op>
+
+  if((ip = namei(path)) == 0){
+801009bc:	8b 45 08             	mov    0x8(%ebp),%eax
+801009bf:	89 04 24             	mov    %eax,(%esp)
+801009c2:	e8 49 15 00 00       	call   80101f10 <namei>
+801009c7:	85 c0                	test   %eax,%eax
+801009c9:	89 c3                	mov    %eax,%ebx
+801009cb:	0f 84 c2 01 00 00    	je     80100b93 <exec+0x1f3>
+    end_op();
+    cprintf("exec: fail\n");
+    return -1;
+  }
+  ilock(ip);
+801009d1:	89 04 24             	mov    %eax,(%esp)
+801009d4:	e8 e7 0c 00 00       	call   801016c0 <ilock>
+  pgdir = 0;
+
+  // Check ELF header
+  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
+801009d9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
+801009df:	c7 44 24 0c 34 00 00 	movl   $0x34,0xc(%esp)
+801009e6:	00 
+801009e7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+801009ee:	00 
+801009ef:	89 44 24 04          	mov    %eax,0x4(%esp)
+801009f3:	89 1c 24             	mov    %ebx,(%esp)
+801009f6:	e8 75 0f 00 00       	call   80101970 <readi>
+801009fb:	83 f8 34             	cmp    $0x34,%eax
+801009fe:	74 20                	je     80100a20 <exec+0x80>
+
+ bad:
+  if(pgdir)
+    freevm(pgdir);
+  if(ip){
+    iunlockput(ip);
+80100a00:	89 1c 24             	mov    %ebx,(%esp)
+80100a03:	e8 18 0f 00 00       	call   80101920 <iunlockput>
+    end_op();
+80100a08:	e8 83 21 00 00       	call   80102b90 <end_op>
+  }
+  return -1;
+80100a0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80100a12:	81 c4 2c 01 00 00    	add    $0x12c,%esp
+80100a18:	5b                   	pop    %ebx
+80100a19:	5e                   	pop    %esi
+80100a1a:	5f                   	pop    %edi
+80100a1b:	5d                   	pop    %ebp
+80100a1c:	c3                   	ret    
+80100a1d:	8d 76 00             	lea    0x0(%esi),%esi
+  if(elf.magic != ELF_MAGIC)
+80100a20:	81 bd 24 ff ff ff 7f 	cmpl   $0x464c457f,-0xdc(%ebp)
+80100a27:	45 4c 46 
+80100a2a:	75 d4                	jne    80100a00 <exec+0x60>
+  if((pgdir = setupkvm()) == 0)
+80100a2c:	e8 bf 5f 00 00       	call   801069f0 <setupkvm>
+80100a31:	85 c0                	test   %eax,%eax
+80100a33:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
+80100a39:	74 c5                	je     80100a00 <exec+0x60>
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+80100a3b:	66 83 bd 50 ff ff ff 	cmpw   $0x0,-0xb0(%ebp)
+80100a42:	00 
+80100a43:	8b b5 40 ff ff ff    	mov    -0xc0(%ebp),%esi
+  sz = 0;
+80100a49:	c7 85 ec fe ff ff 00 	movl   $0x0,-0x114(%ebp)
+80100a50:	00 00 00 
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+80100a53:	0f 84 da 00 00 00    	je     80100b33 <exec+0x193>
+80100a59:	31 ff                	xor    %edi,%edi
+80100a5b:	eb 18                	jmp    80100a75 <exec+0xd5>
+80100a5d:	8d 76 00             	lea    0x0(%esi),%esi
+80100a60:	0f b7 85 50 ff ff ff 	movzwl -0xb0(%ebp),%eax
+80100a67:	83 c7 01             	add    $0x1,%edi
+80100a6a:	83 c6 20             	add    $0x20,%esi
+80100a6d:	39 f8                	cmp    %edi,%eax
+80100a6f:	0f 8e be 00 00 00    	jle    80100b33 <exec+0x193>
+    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
+80100a75:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
+80100a7b:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
+80100a82:	00 
+80100a83:	89 74 24 08          	mov    %esi,0x8(%esp)
+80100a87:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100a8b:	89 1c 24             	mov    %ebx,(%esp)
+80100a8e:	e8 dd 0e 00 00       	call   80101970 <readi>
+80100a93:	83 f8 20             	cmp    $0x20,%eax
+80100a96:	0f 85 84 00 00 00    	jne    80100b20 <exec+0x180>
+    if(ph.type != ELF_PROG_LOAD)
+80100a9c:	83 bd 04 ff ff ff 01 	cmpl   $0x1,-0xfc(%ebp)
+80100aa3:	75 bb                	jne    80100a60 <exec+0xc0>
+    if(ph.memsz < ph.filesz)
+80100aa5:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
+80100aab:	3b 85 14 ff ff ff    	cmp    -0xec(%ebp),%eax
+80100ab1:	72 6d                	jb     80100b20 <exec+0x180>
+    if(ph.vaddr + ph.memsz < ph.vaddr)
+80100ab3:	03 85 0c ff ff ff    	add    -0xf4(%ebp),%eax
+80100ab9:	72 65                	jb     80100b20 <exec+0x180>
+    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+80100abb:	89 44 24 08          	mov    %eax,0x8(%esp)
+80100abf:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
+80100ac5:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100ac9:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100acf:	89 04 24             	mov    %eax,(%esp)
+80100ad2:	e8 79 5d 00 00       	call   80106850 <allocuvm>
+80100ad7:	85 c0                	test   %eax,%eax
+80100ad9:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
+80100adf:	74 3f                	je     80100b20 <exec+0x180>
+    if(ph.vaddr % PGSIZE != 0)
+80100ae1:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
+80100ae7:	a9 ff 0f 00 00       	test   $0xfff,%eax
+80100aec:	75 32                	jne    80100b20 <exec+0x180>
+    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+80100aee:	8b 95 14 ff ff ff    	mov    -0xec(%ebp),%edx
+80100af4:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100af8:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100afe:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+80100b02:	89 54 24 10          	mov    %edx,0x10(%esp)
+80100b06:	8b 95 08 ff ff ff    	mov    -0xf8(%ebp),%edx
+80100b0c:	89 04 24             	mov    %eax,(%esp)
+80100b0f:	89 54 24 0c          	mov    %edx,0xc(%esp)
+80100b13:	e8 78 5c 00 00       	call   80106790 <loaduvm>
+80100b18:	85 c0                	test   %eax,%eax
+80100b1a:	0f 89 40 ff ff ff    	jns    80100a60 <exec+0xc0>
+    freevm(pgdir);
+80100b20:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100b26:	89 04 24             	mov    %eax,(%esp)
+80100b29:	e8 42 5e 00 00       	call   80106970 <freevm>
+80100b2e:	e9 cd fe ff ff       	jmp    80100a00 <exec+0x60>
+  iunlockput(ip);
+80100b33:	89 1c 24             	mov    %ebx,(%esp)
+80100b36:	e8 e5 0d 00 00       	call   80101920 <iunlockput>
+80100b3b:	90                   	nop
+80100b3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  end_op();
+80100b40:	e8 4b 20 00 00       	call   80102b90 <end_op>
+  sz = PGROUNDUP(sz);
+80100b45:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
+80100b4b:	05 ff 0f 00 00       	add    $0xfff,%eax
+80100b50:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+80100b55:	8d 90 00 20 00 00    	lea    0x2000(%eax),%edx
+80100b5b:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100b5f:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100b65:	89 54 24 08          	mov    %edx,0x8(%esp)
+80100b69:	89 04 24             	mov    %eax,(%esp)
+80100b6c:	e8 df 5c 00 00       	call   80106850 <allocuvm>
+80100b71:	85 c0                	test   %eax,%eax
+80100b73:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
+80100b79:	75 33                	jne    80100bae <exec+0x20e>
+    freevm(pgdir);
+80100b7b:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100b81:	89 04 24             	mov    %eax,(%esp)
+80100b84:	e8 e7 5d 00 00       	call   80106970 <freevm>
+  return -1;
+80100b89:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80100b8e:	e9 7f fe ff ff       	jmp    80100a12 <exec+0x72>
+    end_op();
+80100b93:	e8 f8 1f 00 00       	call   80102b90 <end_op>
+    cprintf("exec: fail\n");
+80100b98:	c7 04 24 a1 6d 10 80 	movl   $0x80106da1,(%esp)
+80100b9f:	e8 ac fa ff ff       	call   80100650 <cprintf>
+    return -1;
+80100ba4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80100ba9:	e9 64 fe ff ff       	jmp    80100a12 <exec+0x72>
+  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+80100bae:	8b 9d e8 fe ff ff    	mov    -0x118(%ebp),%ebx
+80100bb4:	89 d8                	mov    %ebx,%eax
+80100bb6:	2d 00 20 00 00       	sub    $0x2000,%eax
+80100bbb:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100bbf:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100bc5:	89 04 24             	mov    %eax,(%esp)
+80100bc8:	e8 d3 5e 00 00       	call   80106aa0 <clearpteu>
+  for(argc = 0; argv[argc]; argc++) {
+80100bcd:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100bd0:	8b 00                	mov    (%eax),%eax
+80100bd2:	85 c0                	test   %eax,%eax
+80100bd4:	0f 84 59 01 00 00    	je     80100d33 <exec+0x393>
+80100bda:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+80100bdd:	31 d2                	xor    %edx,%edx
+80100bdf:	8d 71 04             	lea    0x4(%ecx),%esi
+80100be2:	89 cf                	mov    %ecx,%edi
+80100be4:	89 d1                	mov    %edx,%ecx
+80100be6:	89 f2                	mov    %esi,%edx
+80100be8:	89 fe                	mov    %edi,%esi
+80100bea:	89 cf                	mov    %ecx,%edi
+80100bec:	eb 0a                	jmp    80100bf8 <exec+0x258>
+80100bee:	66 90                	xchg   %ax,%ax
+80100bf0:	83 c2 04             	add    $0x4,%edx
+    if(argc >= MAXARG)
+80100bf3:	83 ff 20             	cmp    $0x20,%edi
+80100bf6:	74 83                	je     80100b7b <exec+0x1db>
+    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+80100bf8:	89 04 24             	mov    %eax,(%esp)
+80100bfb:	89 95 ec fe ff ff    	mov    %edx,-0x114(%ebp)
+80100c01:	e8 aa 38 00 00       	call   801044b0 <strlen>
+80100c06:	f7 d0                	not    %eax
+80100c08:	01 c3                	add    %eax,%ebx
+    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+80100c0a:	8b 06                	mov    (%esi),%eax
+    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+80100c0c:	83 e3 fc             	and    $0xfffffffc,%ebx
+    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+80100c0f:	89 04 24             	mov    %eax,(%esp)
+80100c12:	e8 99 38 00 00       	call   801044b0 <strlen>
+80100c17:	83 c0 01             	add    $0x1,%eax
+80100c1a:	89 44 24 0c          	mov    %eax,0xc(%esp)
+80100c1e:	8b 06                	mov    (%esi),%eax
+80100c20:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80100c24:	89 44 24 08          	mov    %eax,0x8(%esp)
+80100c28:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100c2e:	89 04 24             	mov    %eax,(%esp)
+80100c31:	e8 ca 5f 00 00       	call   80106c00 <copyout>
+80100c36:	85 c0                	test   %eax,%eax
+80100c38:	0f 88 3d ff ff ff    	js     80100b7b <exec+0x1db>
+  for(argc = 0; argv[argc]; argc++) {
+80100c3e:	8b 95 ec fe ff ff    	mov    -0x114(%ebp),%edx
+    ustack[3+argc] = sp;
+80100c44:	8d 8d 58 ff ff ff    	lea    -0xa8(%ebp),%ecx
+80100c4a:	89 9c bd 64 ff ff ff 	mov    %ebx,-0x9c(%ebp,%edi,4)
+  for(argc = 0; argv[argc]; argc++) {
+80100c51:	83 c7 01             	add    $0x1,%edi
+80100c54:	8b 02                	mov    (%edx),%eax
+80100c56:	89 d6                	mov    %edx,%esi
+80100c58:	85 c0                	test   %eax,%eax
+80100c5a:	75 94                	jne    80100bf0 <exec+0x250>
+80100c5c:	89 fa                	mov    %edi,%edx
+  ustack[3+argc] = 0;
+80100c5e:	c7 84 95 64 ff ff ff 	movl   $0x0,-0x9c(%ebp,%edx,4)
+80100c65:	00 00 00 00 
+  ustack[2] = sp - (argc+1)*4;  // argv pointer
+80100c69:	8d 04 95 04 00 00 00 	lea    0x4(,%edx,4),%eax
+  ustack[1] = argc;
+80100c70:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%ebp)
+  ustack[2] = sp - (argc+1)*4;  // argv pointer
+80100c76:	89 da                	mov    %ebx,%edx
+80100c78:	29 c2                	sub    %eax,%edx
+  sp -= (3+argc+1) * 4;
+80100c7a:	83 c0 0c             	add    $0xc,%eax
+80100c7d:	29 c3                	sub    %eax,%ebx
+  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+80100c7f:	89 44 24 0c          	mov    %eax,0xc(%esp)
+80100c83:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100c89:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+80100c8d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+  ustack[0] = 0xffffffff;  // fake return PC
+80100c91:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
+80100c98:	ff ff ff 
+  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+80100c9b:	89 04 24             	mov    %eax,(%esp)
+  ustack[2] = sp - (argc+1)*4;  // argv pointer
+80100c9e:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)
+  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+80100ca4:	e8 57 5f 00 00       	call   80106c00 <copyout>
+80100ca9:	85 c0                	test   %eax,%eax
+80100cab:	0f 88 ca fe ff ff    	js     80100b7b <exec+0x1db>
+  for(last=s=path; *s; s++)
+80100cb1:	8b 45 08             	mov    0x8(%ebp),%eax
+80100cb4:	0f b6 10             	movzbl (%eax),%edx
+80100cb7:	84 d2                	test   %dl,%dl
+80100cb9:	74 19                	je     80100cd4 <exec+0x334>
+80100cbb:	8b 4d 08             	mov    0x8(%ebp),%ecx
+80100cbe:	83 c0 01             	add    $0x1,%eax
+      last = s+1;
+80100cc1:	80 fa 2f             	cmp    $0x2f,%dl
+  for(last=s=path; *s; s++)
+80100cc4:	0f b6 10             	movzbl (%eax),%edx
+      last = s+1;
+80100cc7:	0f 44 c8             	cmove  %eax,%ecx
+80100cca:	83 c0 01             	add    $0x1,%eax
+  for(last=s=path; *s; s++)
+80100ccd:	84 d2                	test   %dl,%dl
+80100ccf:	75 f0                	jne    80100cc1 <exec+0x321>
+80100cd1:	89 4d 08             	mov    %ecx,0x8(%ebp)
+  safestrcpy(curproc->name, last, sizeof(curproc->name));
+80100cd4:	8b bd f4 fe ff ff    	mov    -0x10c(%ebp),%edi
+80100cda:	8b 45 08             	mov    0x8(%ebp),%eax
+80100cdd:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+80100ce4:	00 
+80100ce5:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100ce9:	89 f8                	mov    %edi,%eax
+80100ceb:	83 c0 6c             	add    $0x6c,%eax
+80100cee:	89 04 24             	mov    %eax,(%esp)
+80100cf1:	e8 7a 37 00 00       	call   80104470 <safestrcpy>
+  curproc->pgdir = pgdir;
+80100cf6:	8b 8d f0 fe ff ff    	mov    -0x110(%ebp),%ecx
+  oldpgdir = curproc->pgdir;
+80100cfc:	8b 77 04             	mov    0x4(%edi),%esi
+  curproc->tf->eip = elf.entry;  // main
+80100cff:	8b 47 18             	mov    0x18(%edi),%eax
+  curproc->pgdir = pgdir;
+80100d02:	89 4f 04             	mov    %ecx,0x4(%edi)
+  curproc->sz = sz;
+80100d05:	8b 8d e8 fe ff ff    	mov    -0x118(%ebp),%ecx
+80100d0b:	89 0f                	mov    %ecx,(%edi)
+  curproc->tf->eip = elf.entry;  // main
+80100d0d:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
+80100d13:	89 50 38             	mov    %edx,0x38(%eax)
+  curproc->tf->esp = sp;
+80100d16:	8b 47 18             	mov    0x18(%edi),%eax
+80100d19:	89 58 44             	mov    %ebx,0x44(%eax)
+  switchuvm(curproc);
+80100d1c:	89 3c 24             	mov    %edi,(%esp)
+80100d1f:	e8 cc 58 00 00       	call   801065f0 <switchuvm>
+  freevm(oldpgdir);
+80100d24:	89 34 24             	mov    %esi,(%esp)
+80100d27:	e8 44 5c 00 00       	call   80106970 <freevm>
+  return 0;
+80100d2c:	31 c0                	xor    %eax,%eax
+80100d2e:	e9 df fc ff ff       	jmp    80100a12 <exec+0x72>
+  for(argc = 0; argv[argc]; argc++) {
+80100d33:	8b 9d e8 fe ff ff    	mov    -0x118(%ebp),%ebx
+80100d39:	31 d2                	xor    %edx,%edx
+80100d3b:	8d 8d 58 ff ff ff    	lea    -0xa8(%ebp),%ecx
+80100d41:	e9 18 ff ff ff       	jmp    80100c5e <exec+0x2be>
+80100d46:	66 90                	xchg   %ax,%ax
+80100d48:	66 90                	xchg   %ax,%ax
+80100d4a:	66 90                	xchg   %ax,%ax
+80100d4c:	66 90                	xchg   %ax,%ax
+80100d4e:	66 90                	xchg   %ax,%ax
+
+80100d50 <fileinit>:
+  struct file file[NFILE];
+} ftable;
+
+void
+fileinit(void)
+{
+80100d50:	55                   	push   %ebp
+80100d51:	89 e5                	mov    %esp,%ebp
+80100d53:	83 ec 18             	sub    $0x18,%esp
+  initlock(&ftable.lock, "ftable");
+80100d56:	c7 44 24 04 ad 6d 10 	movl   $0x80106dad,0x4(%esp)
+80100d5d:	80 
+80100d5e:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+80100d65:	e8 f6 32 00 00       	call   80104060 <initlock>
+}
+80100d6a:	c9                   	leave  
+80100d6b:	c3                   	ret    
+80100d6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80100d70 <filealloc>:
+
+// Allocate a file structure.
+struct file*
+filealloc(void)
+{
+80100d70:	55                   	push   %ebp
+80100d71:	89 e5                	mov    %esp,%ebp
+80100d73:	53                   	push   %ebx
+  struct file *f;
+
+  acquire(&ftable.lock);
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+80100d74:	bb f4 ff 10 80       	mov    $0x8010fff4,%ebx
+{
+80100d79:	83 ec 14             	sub    $0x14,%esp
+  acquire(&ftable.lock);
+80100d7c:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+80100d83:	e8 c8 33 00 00       	call   80104150 <acquire>
+80100d88:	eb 11                	jmp    80100d9b <filealloc+0x2b>
+80100d8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+80100d90:	83 c3 18             	add    $0x18,%ebx
+80100d93:	81 fb 54 09 11 80    	cmp    $0x80110954,%ebx
+80100d99:	74 25                	je     80100dc0 <filealloc+0x50>
+    if(f->ref == 0){
+80100d9b:	8b 43 04             	mov    0x4(%ebx),%eax
+80100d9e:	85 c0                	test   %eax,%eax
+80100da0:	75 ee                	jne    80100d90 <filealloc+0x20>
+      f->ref = 1;
+      release(&ftable.lock);
+80100da2:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+      f->ref = 1;
+80100da9:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
+      release(&ftable.lock);
+80100db0:	e8 8b 34 00 00       	call   80104240 <release>
+      return f;
+    }
+  }
+  release(&ftable.lock);
+  return 0;
+}
+80100db5:	83 c4 14             	add    $0x14,%esp
+      return f;
+80100db8:	89 d8                	mov    %ebx,%eax
+}
+80100dba:	5b                   	pop    %ebx
+80100dbb:	5d                   	pop    %ebp
+80100dbc:	c3                   	ret    
+80100dbd:	8d 76 00             	lea    0x0(%esi),%esi
+  release(&ftable.lock);
+80100dc0:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+80100dc7:	e8 74 34 00 00       	call   80104240 <release>
+}
+80100dcc:	83 c4 14             	add    $0x14,%esp
+  return 0;
+80100dcf:	31 c0                	xor    %eax,%eax
+}
+80100dd1:	5b                   	pop    %ebx
+80100dd2:	5d                   	pop    %ebp
+80100dd3:	c3                   	ret    
+80100dd4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80100dda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+80100de0 <filedup>:
+
+// Increment ref count for file f.
+struct file*
+filedup(struct file *f)
+{
+80100de0:	55                   	push   %ebp
+80100de1:	89 e5                	mov    %esp,%ebp
+80100de3:	53                   	push   %ebx
+80100de4:	83 ec 14             	sub    $0x14,%esp
+80100de7:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&ftable.lock);
+80100dea:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+80100df1:	e8 5a 33 00 00       	call   80104150 <acquire>
+  if(f->ref < 1)
+80100df6:	8b 43 04             	mov    0x4(%ebx),%eax
+80100df9:	85 c0                	test   %eax,%eax
+80100dfb:	7e 1a                	jle    80100e17 <filedup+0x37>
+    panic("filedup");
+  f->ref++;
+80100dfd:	83 c0 01             	add    $0x1,%eax
+80100e00:	89 43 04             	mov    %eax,0x4(%ebx)
+  release(&ftable.lock);
+80100e03:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+80100e0a:	e8 31 34 00 00       	call   80104240 <release>
+  return f;
+}
+80100e0f:	83 c4 14             	add    $0x14,%esp
+80100e12:	89 d8                	mov    %ebx,%eax
+80100e14:	5b                   	pop    %ebx
+80100e15:	5d                   	pop    %ebp
+80100e16:	c3                   	ret    
+    panic("filedup");
+80100e17:	c7 04 24 b4 6d 10 80 	movl   $0x80106db4,(%esp)
+80100e1e:	e8 3d f5 ff ff       	call   80100360 <panic>
+80100e23:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80100e29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80100e30 <fileclose>:
+
+// Close file f.  (Decrement ref count, close when reaches 0.)
+void
+fileclose(struct file *f)
+{
+80100e30:	55                   	push   %ebp
+80100e31:	89 e5                	mov    %esp,%ebp
+80100e33:	57                   	push   %edi
+80100e34:	56                   	push   %esi
+80100e35:	53                   	push   %ebx
+80100e36:	83 ec 1c             	sub    $0x1c,%esp
+80100e39:	8b 7d 08             	mov    0x8(%ebp),%edi
+  struct file ff;
+
+  acquire(&ftable.lock);
+80100e3c:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+80100e43:	e8 08 33 00 00       	call   80104150 <acquire>
+  if(f->ref < 1)
+80100e48:	8b 57 04             	mov    0x4(%edi),%edx
+80100e4b:	85 d2                	test   %edx,%edx
+80100e4d:	0f 8e 89 00 00 00    	jle    80100edc <fileclose+0xac>
+    panic("fileclose");
+  if(--f->ref > 0){
+80100e53:	83 ea 01             	sub    $0x1,%edx
+80100e56:	85 d2                	test   %edx,%edx
+80100e58:	89 57 04             	mov    %edx,0x4(%edi)
+80100e5b:	74 13                	je     80100e70 <fileclose+0x40>
+    release(&ftable.lock);
+80100e5d:	c7 45 08 c0 ff 10 80 	movl   $0x8010ffc0,0x8(%ebp)
+  else if(ff.type == FD_INODE){
+    begin_op();
+    iput(ff.ip);
+    end_op();
+  }
+}
+80100e64:	83 c4 1c             	add    $0x1c,%esp
+80100e67:	5b                   	pop    %ebx
+80100e68:	5e                   	pop    %esi
+80100e69:	5f                   	pop    %edi
+80100e6a:	5d                   	pop    %ebp
+    release(&ftable.lock);
+80100e6b:	e9 d0 33 00 00       	jmp    80104240 <release>
+  ff = *f;
+80100e70:	0f b6 47 09          	movzbl 0x9(%edi),%eax
+80100e74:	8b 37                	mov    (%edi),%esi
+80100e76:	8b 5f 0c             	mov    0xc(%edi),%ebx
+  f->type = FD_NONE;
+80100e79:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
+  ff = *f;
+80100e7f:	88 45 e7             	mov    %al,-0x19(%ebp)
+80100e82:	8b 47 10             	mov    0x10(%edi),%eax
+  release(&ftable.lock);
+80100e85:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+  ff = *f;
+80100e8c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  release(&ftable.lock);
+80100e8f:	e8 ac 33 00 00       	call   80104240 <release>
+  if(ff.type == FD_PIPE)
+80100e94:	83 fe 01             	cmp    $0x1,%esi
+80100e97:	74 0f                	je     80100ea8 <fileclose+0x78>
+  else if(ff.type == FD_INODE){
+80100e99:	83 fe 02             	cmp    $0x2,%esi
+80100e9c:	74 22                	je     80100ec0 <fileclose+0x90>
+}
+80100e9e:	83 c4 1c             	add    $0x1c,%esp
+80100ea1:	5b                   	pop    %ebx
+80100ea2:	5e                   	pop    %esi
+80100ea3:	5f                   	pop    %edi
+80100ea4:	5d                   	pop    %ebp
+80100ea5:	c3                   	ret    
+80100ea6:	66 90                	xchg   %ax,%ax
+    pipeclose(ff.pipe, ff.writable);
+80100ea8:	0f be 75 e7          	movsbl -0x19(%ebp),%esi
+80100eac:	89 1c 24             	mov    %ebx,(%esp)
+80100eaf:	89 74 24 04          	mov    %esi,0x4(%esp)
+80100eb3:	e8 b8 23 00 00       	call   80103270 <pipeclose>
+80100eb8:	eb e4                	jmp    80100e9e <fileclose+0x6e>
+80100eba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    begin_op();
+80100ec0:	e8 5b 1c 00 00       	call   80102b20 <begin_op>
+    iput(ff.ip);
+80100ec5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80100ec8:	89 04 24             	mov    %eax,(%esp)
+80100ecb:	e8 10 09 00 00       	call   801017e0 <iput>
+}
+80100ed0:	83 c4 1c             	add    $0x1c,%esp
+80100ed3:	5b                   	pop    %ebx
+80100ed4:	5e                   	pop    %esi
+80100ed5:	5f                   	pop    %edi
+80100ed6:	5d                   	pop    %ebp
+    end_op();
+80100ed7:	e9 b4 1c 00 00       	jmp    80102b90 <end_op>
+    panic("fileclose");
+80100edc:	c7 04 24 bc 6d 10 80 	movl   $0x80106dbc,(%esp)
+80100ee3:	e8 78 f4 ff ff       	call   80100360 <panic>
+80100ee8:	90                   	nop
+80100ee9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80100ef0 <filestat>:
+
+// Get metadata about file f.
+int
+filestat(struct file *f, struct stat *st)
+{
+80100ef0:	55                   	push   %ebp
+80100ef1:	89 e5                	mov    %esp,%ebp
+80100ef3:	53                   	push   %ebx
+80100ef4:	83 ec 14             	sub    $0x14,%esp
+80100ef7:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(f->type == FD_INODE){
+80100efa:	83 3b 02             	cmpl   $0x2,(%ebx)
+80100efd:	75 31                	jne    80100f30 <filestat+0x40>
+    ilock(f->ip);
+80100eff:	8b 43 10             	mov    0x10(%ebx),%eax
+80100f02:	89 04 24             	mov    %eax,(%esp)
+80100f05:	e8 b6 07 00 00       	call   801016c0 <ilock>
+    stati(f->ip, st);
+80100f0a:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100f0d:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100f11:	8b 43 10             	mov    0x10(%ebx),%eax
+80100f14:	89 04 24             	mov    %eax,(%esp)
+80100f17:	e8 24 0a 00 00       	call   80101940 <stati>
+    iunlock(f->ip);
+80100f1c:	8b 43 10             	mov    0x10(%ebx),%eax
+80100f1f:	89 04 24             	mov    %eax,(%esp)
+80100f22:	e8 79 08 00 00       	call   801017a0 <iunlock>
+    return 0;
+  }
+  return -1;
+}
+80100f27:	83 c4 14             	add    $0x14,%esp
+    return 0;
+80100f2a:	31 c0                	xor    %eax,%eax
+}
+80100f2c:	5b                   	pop    %ebx
+80100f2d:	5d                   	pop    %ebp
+80100f2e:	c3                   	ret    
+80100f2f:	90                   	nop
+80100f30:	83 c4 14             	add    $0x14,%esp
+  return -1;
+80100f33:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80100f38:	5b                   	pop    %ebx
+80100f39:	5d                   	pop    %ebp
+80100f3a:	c3                   	ret    
+80100f3b:	90                   	nop
+80100f3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80100f40 <fileread>:
+
+// Read from file f.
+int
+fileread(struct file *f, char *addr, int n)
+{
+80100f40:	55                   	push   %ebp
+80100f41:	89 e5                	mov    %esp,%ebp
+80100f43:	57                   	push   %edi
+80100f44:	56                   	push   %esi
+80100f45:	53                   	push   %ebx
+80100f46:	83 ec 1c             	sub    $0x1c,%esp
+80100f49:	8b 5d 08             	mov    0x8(%ebp),%ebx
+80100f4c:	8b 75 0c             	mov    0xc(%ebp),%esi
+80100f4f:	8b 7d 10             	mov    0x10(%ebp),%edi
+  int r;
+
+  if(f->readable == 0)
+80100f52:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
+80100f56:	74 68                	je     80100fc0 <fileread+0x80>
+    return -1;
+  if(f->type == FD_PIPE)
+80100f58:	8b 03                	mov    (%ebx),%eax
+80100f5a:	83 f8 01             	cmp    $0x1,%eax
+80100f5d:	74 49                	je     80100fa8 <fileread+0x68>
+    return piperead(f->pipe, addr, n);
+  if(f->type == FD_INODE){
+80100f5f:	83 f8 02             	cmp    $0x2,%eax
+80100f62:	75 63                	jne    80100fc7 <fileread+0x87>
+    ilock(f->ip);
+80100f64:	8b 43 10             	mov    0x10(%ebx),%eax
+80100f67:	89 04 24             	mov    %eax,(%esp)
+80100f6a:	e8 51 07 00 00       	call   801016c0 <ilock>
+    if((r = readi(f->ip, addr, f->off, n)) > 0)
+80100f6f:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+80100f73:	8b 43 14             	mov    0x14(%ebx),%eax
+80100f76:	89 74 24 04          	mov    %esi,0x4(%esp)
+80100f7a:	89 44 24 08          	mov    %eax,0x8(%esp)
+80100f7e:	8b 43 10             	mov    0x10(%ebx),%eax
+80100f81:	89 04 24             	mov    %eax,(%esp)
+80100f84:	e8 e7 09 00 00       	call   80101970 <readi>
+80100f89:	85 c0                	test   %eax,%eax
+80100f8b:	89 c6                	mov    %eax,%esi
+80100f8d:	7e 03                	jle    80100f92 <fileread+0x52>
+      f->off += r;
+80100f8f:	01 43 14             	add    %eax,0x14(%ebx)
+    iunlock(f->ip);
+80100f92:	8b 43 10             	mov    0x10(%ebx),%eax
+80100f95:	89 04 24             	mov    %eax,(%esp)
+80100f98:	e8 03 08 00 00       	call   801017a0 <iunlock>
+    if((r = readi(f->ip, addr, f->off, n)) > 0)
+80100f9d:	89 f0                	mov    %esi,%eax
+    return r;
+  }
+  panic("fileread");
+}
+80100f9f:	83 c4 1c             	add    $0x1c,%esp
+80100fa2:	5b                   	pop    %ebx
+80100fa3:	5e                   	pop    %esi
+80100fa4:	5f                   	pop    %edi
+80100fa5:	5d                   	pop    %ebp
+80100fa6:	c3                   	ret    
+80100fa7:	90                   	nop
+    return piperead(f->pipe, addr, n);
+80100fa8:	8b 43 0c             	mov    0xc(%ebx),%eax
+80100fab:	89 45 08             	mov    %eax,0x8(%ebp)
+}
+80100fae:	83 c4 1c             	add    $0x1c,%esp
+80100fb1:	5b                   	pop    %ebx
+80100fb2:	5e                   	pop    %esi
+80100fb3:	5f                   	pop    %edi
+80100fb4:	5d                   	pop    %ebp
+    return piperead(f->pipe, addr, n);
+80100fb5:	e9 36 24 00 00       	jmp    801033f0 <piperead>
+80100fba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    return -1;
+80100fc0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80100fc5:	eb d8                	jmp    80100f9f <fileread+0x5f>
+  panic("fileread");
+80100fc7:	c7 04 24 c6 6d 10 80 	movl   $0x80106dc6,(%esp)
+80100fce:	e8 8d f3 ff ff       	call   80100360 <panic>
+80100fd3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80100fd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80100fe0 <filewrite>:
+
+//PAGEBREAK!
+// Write to file f.
+int
+filewrite(struct file *f, char *addr, int n)
+{
+80100fe0:	55                   	push   %ebp
+80100fe1:	89 e5                	mov    %esp,%ebp
+80100fe3:	57                   	push   %edi
+80100fe4:	56                   	push   %esi
+80100fe5:	53                   	push   %ebx
+80100fe6:	83 ec 2c             	sub    $0x2c,%esp
+80100fe9:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100fec:	8b 7d 08             	mov    0x8(%ebp),%edi
+80100fef:	89 45 dc             	mov    %eax,-0x24(%ebp)
+80100ff2:	8b 45 10             	mov    0x10(%ebp),%eax
+  int r;
+
+  if(f->writable == 0)
+80100ff5:	80 7f 09 00          	cmpb   $0x0,0x9(%edi)
+{
+80100ff9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(f->writable == 0)
+80100ffc:	0f 84 ae 00 00 00    	je     801010b0 <filewrite+0xd0>
+    return -1;
+  if(f->type == FD_PIPE)
+80101002:	8b 07                	mov    (%edi),%eax
+80101004:	83 f8 01             	cmp    $0x1,%eax
+80101007:	0f 84 c2 00 00 00    	je     801010cf <filewrite+0xef>
+    return pipewrite(f->pipe, addr, n);
+  if(f->type == FD_INODE){
+8010100d:	83 f8 02             	cmp    $0x2,%eax
+80101010:	0f 85 d7 00 00 00    	jne    801010ed <filewrite+0x10d>
+    // and 2 blocks of slop for non-aligned writes.
+    // this really belongs lower down, since writei()
+    // might be writing a device like the console.
+    int max = ((LOGSIZE-1-1-2) / 2) * 512;
+    int i = 0;
+    while(i < n){
+80101016:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80101019:	31 db                	xor    %ebx,%ebx
+8010101b:	85 c0                	test   %eax,%eax
+8010101d:	7f 31                	jg     80101050 <filewrite+0x70>
+8010101f:	e9 9c 00 00 00       	jmp    801010c0 <filewrite+0xe0>
+80101024:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+      begin_op();
+      ilock(f->ip);
+      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+        f->off += r;
+      iunlock(f->ip);
+80101028:	8b 4f 10             	mov    0x10(%edi),%ecx
+        f->off += r;
+8010102b:	01 47 14             	add    %eax,0x14(%edi)
+8010102e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+      iunlock(f->ip);
+80101031:	89 0c 24             	mov    %ecx,(%esp)
+80101034:	e8 67 07 00 00       	call   801017a0 <iunlock>
+      end_op();
+80101039:	e8 52 1b 00 00       	call   80102b90 <end_op>
+8010103e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+
+      if(r < 0)
+        break;
+      if(r != n1)
+80101041:	39 f0                	cmp    %esi,%eax
+80101043:	0f 85 98 00 00 00    	jne    801010e1 <filewrite+0x101>
+        panic("short filewrite");
+      i += r;
+80101049:	01 c3                	add    %eax,%ebx
+    while(i < n){
+8010104b:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
+8010104e:	7e 70                	jle    801010c0 <filewrite+0xe0>
+      int n1 = n - i;
+80101050:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+80101053:	b8 00 1a 00 00       	mov    $0x1a00,%eax
+80101058:	29 de                	sub    %ebx,%esi
+8010105a:	81 fe 00 1a 00 00    	cmp    $0x1a00,%esi
+80101060:	0f 4f f0             	cmovg  %eax,%esi
+      begin_op();
+80101063:	e8 b8 1a 00 00       	call   80102b20 <begin_op>
+      ilock(f->ip);
+80101068:	8b 47 10             	mov    0x10(%edi),%eax
+8010106b:	89 04 24             	mov    %eax,(%esp)
+8010106e:	e8 4d 06 00 00       	call   801016c0 <ilock>
+      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+80101073:	89 74 24 0c          	mov    %esi,0xc(%esp)
+80101077:	8b 47 14             	mov    0x14(%edi),%eax
+8010107a:	89 44 24 08          	mov    %eax,0x8(%esp)
+8010107e:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80101081:	01 d8                	add    %ebx,%eax
+80101083:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101087:	8b 47 10             	mov    0x10(%edi),%eax
+8010108a:	89 04 24             	mov    %eax,(%esp)
+8010108d:	e8 de 09 00 00       	call   80101a70 <writei>
+80101092:	85 c0                	test   %eax,%eax
+80101094:	7f 92                	jg     80101028 <filewrite+0x48>
+      iunlock(f->ip);
+80101096:	8b 4f 10             	mov    0x10(%edi),%ecx
+80101099:	89 45 e0             	mov    %eax,-0x20(%ebp)
+8010109c:	89 0c 24             	mov    %ecx,(%esp)
+8010109f:	e8 fc 06 00 00       	call   801017a0 <iunlock>
+      end_op();
+801010a4:	e8 e7 1a 00 00       	call   80102b90 <end_op>
+      if(r < 0)
+801010a9:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801010ac:	85 c0                	test   %eax,%eax
+801010ae:	74 91                	je     80101041 <filewrite+0x61>
+    }
+    return i == n ? n : -1;
+  }
+  panic("filewrite");
+}
+801010b0:	83 c4 2c             	add    $0x2c,%esp
+    return -1;
+801010b3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801010b8:	5b                   	pop    %ebx
+801010b9:	5e                   	pop    %esi
+801010ba:	5f                   	pop    %edi
+801010bb:	5d                   	pop    %ebp
+801010bc:	c3                   	ret    
+801010bd:	8d 76 00             	lea    0x0(%esi),%esi
+    return i == n ? n : -1;
+801010c0:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
+801010c3:	89 d8                	mov    %ebx,%eax
+801010c5:	75 e9                	jne    801010b0 <filewrite+0xd0>
+}
+801010c7:	83 c4 2c             	add    $0x2c,%esp
+801010ca:	5b                   	pop    %ebx
+801010cb:	5e                   	pop    %esi
+801010cc:	5f                   	pop    %edi
+801010cd:	5d                   	pop    %ebp
+801010ce:	c3                   	ret    
+    return pipewrite(f->pipe, addr, n);
+801010cf:	8b 47 0c             	mov    0xc(%edi),%eax
+801010d2:	89 45 08             	mov    %eax,0x8(%ebp)
+}
+801010d5:	83 c4 2c             	add    $0x2c,%esp
+801010d8:	5b                   	pop    %ebx
+801010d9:	5e                   	pop    %esi
+801010da:	5f                   	pop    %edi
+801010db:	5d                   	pop    %ebp
+    return pipewrite(f->pipe, addr, n);
+801010dc:	e9 1f 22 00 00       	jmp    80103300 <pipewrite>
+        panic("short filewrite");
+801010e1:	c7 04 24 cf 6d 10 80 	movl   $0x80106dcf,(%esp)
+801010e8:	e8 73 f2 ff ff       	call   80100360 <panic>
+  panic("filewrite");
+801010ed:	c7 04 24 d5 6d 10 80 	movl   $0x80106dd5,(%esp)
+801010f4:	e8 67 f2 ff ff       	call   80100360 <panic>
+801010f9:	66 90                	xchg   %ax,%ax
+801010fb:	66 90                	xchg   %ax,%ax
+801010fd:	66 90                	xchg   %ax,%ax
+801010ff:	90                   	nop
+
+80101100 <balloc>:
+// Blocks.
+
+// Allocate a zeroed disk block.
+static uint
+balloc(uint dev)
+{
+80101100:	55                   	push   %ebp
+80101101:	89 e5                	mov    %esp,%ebp
+80101103:	57                   	push   %edi
+80101104:	56                   	push   %esi
+80101105:	53                   	push   %ebx
+80101106:	83 ec 2c             	sub    $0x2c,%esp
+80101109:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  int b, bi, m;
+  struct buf *bp;
+
+  bp = 0;
+  for(b = 0; b < sb.size; b += BPB){
+8010110c:	a1 c0 09 11 80       	mov    0x801109c0,%eax
+80101111:	85 c0                	test   %eax,%eax
+80101113:	0f 84 8c 00 00 00    	je     801011a5 <balloc+0xa5>
+80101119:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+    bp = bread(dev, BBLOCK(b, sb));
+80101120:	8b 75 dc             	mov    -0x24(%ebp),%esi
+80101123:	89 f0                	mov    %esi,%eax
+80101125:	c1 f8 0c             	sar    $0xc,%eax
+80101128:	03 05 d8 09 11 80    	add    0x801109d8,%eax
+8010112e:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101132:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80101135:	89 04 24             	mov    %eax,(%esp)
+80101138:	e8 93 ef ff ff       	call   801000d0 <bread>
+8010113d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80101140:	a1 c0 09 11 80       	mov    0x801109c0,%eax
+80101145:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+80101148:	31 c0                	xor    %eax,%eax
+8010114a:	eb 33                	jmp    8010117f <balloc+0x7f>
+8010114c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      m = 1 << (bi % 8);
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+80101150:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+80101153:	89 c2                	mov    %eax,%edx
+      m = 1 << (bi % 8);
+80101155:	89 c1                	mov    %eax,%ecx
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+80101157:	c1 fa 03             	sar    $0x3,%edx
+      m = 1 << (bi % 8);
+8010115a:	83 e1 07             	and    $0x7,%ecx
+8010115d:	bf 01 00 00 00       	mov    $0x1,%edi
+80101162:	d3 e7                	shl    %cl,%edi
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+80101164:	0f b6 5c 13 5c       	movzbl 0x5c(%ebx,%edx,1),%ebx
+      m = 1 << (bi % 8);
+80101169:	89 f9                	mov    %edi,%ecx
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+8010116b:	0f b6 fb             	movzbl %bl,%edi
+8010116e:	85 cf                	test   %ecx,%edi
+80101170:	74 46                	je     801011b8 <balloc+0xb8>
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+80101172:	83 c0 01             	add    $0x1,%eax
+80101175:	83 c6 01             	add    $0x1,%esi
+80101178:	3d 00 10 00 00       	cmp    $0x1000,%eax
+8010117d:	74 05                	je     80101184 <balloc+0x84>
+8010117f:	3b 75 e0             	cmp    -0x20(%ebp),%esi
+80101182:	72 cc                	jb     80101150 <balloc+0x50>
+        brelse(bp);
+        bzero(dev, b + bi);
+        return b + bi;
+      }
+    }
+    brelse(bp);
+80101184:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80101187:	89 04 24             	mov    %eax,(%esp)
+8010118a:	e8 51 f0 ff ff       	call   801001e0 <brelse>
+  for(b = 0; b < sb.size; b += BPB){
+8010118f:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
+80101196:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80101199:	3b 05 c0 09 11 80    	cmp    0x801109c0,%eax
+8010119f:	0f 82 7b ff ff ff    	jb     80101120 <balloc+0x20>
+  }
+  panic("balloc: out of blocks");
+801011a5:	c7 04 24 df 6d 10 80 	movl   $0x80106ddf,(%esp)
+801011ac:	e8 af f1 ff ff       	call   80100360 <panic>
+801011b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        bp->data[bi/8] |= m;  // Mark block in use.
+801011b8:	09 d9                	or     %ebx,%ecx
+801011ba:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+801011bd:	88 4c 13 5c          	mov    %cl,0x5c(%ebx,%edx,1)
+        log_write(bp);
+801011c1:	89 1c 24             	mov    %ebx,(%esp)
+801011c4:	e8 f7 1a 00 00       	call   80102cc0 <log_write>
+        brelse(bp);
+801011c9:	89 1c 24             	mov    %ebx,(%esp)
+801011cc:	e8 0f f0 ff ff       	call   801001e0 <brelse>
+  bp = bread(dev, bno);
+801011d1:	8b 45 d8             	mov    -0x28(%ebp),%eax
+801011d4:	89 74 24 04          	mov    %esi,0x4(%esp)
+801011d8:	89 04 24             	mov    %eax,(%esp)
+801011db:	e8 f0 ee ff ff       	call   801000d0 <bread>
+  memset(bp->data, 0, BSIZE);
+801011e0:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+801011e7:	00 
+801011e8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+801011ef:	00 
+  bp = bread(dev, bno);
+801011f0:	89 c3                	mov    %eax,%ebx
+  memset(bp->data, 0, BSIZE);
+801011f2:	8d 40 5c             	lea    0x5c(%eax),%eax
+801011f5:	89 04 24             	mov    %eax,(%esp)
+801011f8:	e8 93 30 00 00       	call   80104290 <memset>
+  log_write(bp);
+801011fd:	89 1c 24             	mov    %ebx,(%esp)
+80101200:	e8 bb 1a 00 00       	call   80102cc0 <log_write>
+  brelse(bp);
+80101205:	89 1c 24             	mov    %ebx,(%esp)
+80101208:	e8 d3 ef ff ff       	call   801001e0 <brelse>
+}
+8010120d:	83 c4 2c             	add    $0x2c,%esp
+80101210:	89 f0                	mov    %esi,%eax
+80101212:	5b                   	pop    %ebx
+80101213:	5e                   	pop    %esi
+80101214:	5f                   	pop    %edi
+80101215:	5d                   	pop    %ebp
+80101216:	c3                   	ret    
+80101217:	89 f6                	mov    %esi,%esi
+80101219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80101220 <iget>:
+// Find the inode with number inum on device dev
+// and return the in-memory copy. Does not lock
+// the inode and does not read it from disk.
+static struct inode*
+iget(uint dev, uint inum)
+{
+80101220:	55                   	push   %ebp
+80101221:	89 e5                	mov    %esp,%ebp
+80101223:	57                   	push   %edi
+80101224:	89 c7                	mov    %eax,%edi
+80101226:	56                   	push   %esi
+  struct inode *ip, *empty;
+
+  acquire(&icache.lock);
+
+  // Is the inode already cached?
+  empty = 0;
+80101227:	31 f6                	xor    %esi,%esi
+{
+80101229:	53                   	push   %ebx
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+8010122a:	bb 14 0a 11 80       	mov    $0x80110a14,%ebx
+{
+8010122f:	83 ec 1c             	sub    $0x1c,%esp
+  acquire(&icache.lock);
+80101232:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+{
+80101239:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  acquire(&icache.lock);
+8010123c:	e8 0f 2f 00 00       	call   80104150 <acquire>
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+80101241:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80101244:	eb 14                	jmp    8010125a <iget+0x3a>
+80101246:	66 90                	xchg   %ax,%ax
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+      ip->ref++;
+      release(&icache.lock);
+      return ip;
+    }
+    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+80101248:	85 f6                	test   %esi,%esi
+8010124a:	74 3c                	je     80101288 <iget+0x68>
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+8010124c:	81 c3 90 00 00 00    	add    $0x90,%ebx
+80101252:	81 fb 34 26 11 80    	cmp    $0x80112634,%ebx
+80101258:	74 46                	je     801012a0 <iget+0x80>
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+8010125a:	8b 4b 08             	mov    0x8(%ebx),%ecx
+8010125d:	85 c9                	test   %ecx,%ecx
+8010125f:	7e e7                	jle    80101248 <iget+0x28>
+80101261:	39 3b                	cmp    %edi,(%ebx)
+80101263:	75 e3                	jne    80101248 <iget+0x28>
+80101265:	39 53 04             	cmp    %edx,0x4(%ebx)
+80101268:	75 de                	jne    80101248 <iget+0x28>
+      ip->ref++;
+8010126a:	83 c1 01             	add    $0x1,%ecx
+      return ip;
+8010126d:	89 de                	mov    %ebx,%esi
+      release(&icache.lock);
+8010126f:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+      ip->ref++;
+80101276:	89 4b 08             	mov    %ecx,0x8(%ebx)
+      release(&icache.lock);
+80101279:	e8 c2 2f 00 00       	call   80104240 <release>
+  ip->ref = 1;
+  ip->valid = 0;
+  release(&icache.lock);
+
+  return ip;
+}
+8010127e:	83 c4 1c             	add    $0x1c,%esp
+80101281:	89 f0                	mov    %esi,%eax
+80101283:	5b                   	pop    %ebx
+80101284:	5e                   	pop    %esi
+80101285:	5f                   	pop    %edi
+80101286:	5d                   	pop    %ebp
+80101287:	c3                   	ret    
+80101288:	85 c9                	test   %ecx,%ecx
+8010128a:	0f 44 f3             	cmove  %ebx,%esi
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+8010128d:	81 c3 90 00 00 00    	add    $0x90,%ebx
+80101293:	81 fb 34 26 11 80    	cmp    $0x80112634,%ebx
+80101299:	75 bf                	jne    8010125a <iget+0x3a>
+8010129b:	90                   	nop
+8010129c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  if(empty == 0)
+801012a0:	85 f6                	test   %esi,%esi
+801012a2:	74 29                	je     801012cd <iget+0xad>
+  ip->dev = dev;
+801012a4:	89 3e                	mov    %edi,(%esi)
+  ip->inum = inum;
+801012a6:	89 56 04             	mov    %edx,0x4(%esi)
+  ip->ref = 1;
+801012a9:	c7 46 08 01 00 00 00 	movl   $0x1,0x8(%esi)
+  ip->valid = 0;
+801012b0:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
+  release(&icache.lock);
+801012b7:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+801012be:	e8 7d 2f 00 00       	call   80104240 <release>
+}
+801012c3:	83 c4 1c             	add    $0x1c,%esp
+801012c6:	89 f0                	mov    %esi,%eax
+801012c8:	5b                   	pop    %ebx
+801012c9:	5e                   	pop    %esi
+801012ca:	5f                   	pop    %edi
+801012cb:	5d                   	pop    %ebp
+801012cc:	c3                   	ret    
+    panic("iget: no inodes");
+801012cd:	c7 04 24 f5 6d 10 80 	movl   $0x80106df5,(%esp)
+801012d4:	e8 87 f0 ff ff       	call   80100360 <panic>
+801012d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+801012e0 <bmap>:
+
+// Return the disk block address of the nth block in inode ip.
+// If there is no such block, bmap allocates one.
+static uint
+bmap(struct inode *ip, uint bn)
+{
+801012e0:	55                   	push   %ebp
+801012e1:	89 e5                	mov    %esp,%ebp
+801012e3:	57                   	push   %edi
+801012e4:	56                   	push   %esi
+801012e5:	53                   	push   %ebx
+801012e6:	89 c3                	mov    %eax,%ebx
+801012e8:	83 ec 1c             	sub    $0x1c,%esp
+  uint addr, *a;
+  struct buf *bp;
+
+  if(bn < NDIRECT){
+801012eb:	83 fa 0b             	cmp    $0xb,%edx
+801012ee:	77 18                	ja     80101308 <bmap+0x28>
+801012f0:	8d 34 90             	lea    (%eax,%edx,4),%esi
+    if((addr = ip->addrs[bn]) == 0)
+801012f3:	8b 46 5c             	mov    0x5c(%esi),%eax
+801012f6:	85 c0                	test   %eax,%eax
+801012f8:	74 66                	je     80101360 <bmap+0x80>
+    brelse(bp);
+    return addr;
+  }
+
+  panic("bmap: out of range");
+}
+801012fa:	83 c4 1c             	add    $0x1c,%esp
+801012fd:	5b                   	pop    %ebx
+801012fe:	5e                   	pop    %esi
+801012ff:	5f                   	pop    %edi
+80101300:	5d                   	pop    %ebp
+80101301:	c3                   	ret    
+80101302:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  bn -= NDIRECT;
+80101308:	8d 72 f4             	lea    -0xc(%edx),%esi
+  if(bn < NINDIRECT){
+8010130b:	83 fe 7f             	cmp    $0x7f,%esi
+8010130e:	77 77                	ja     80101387 <bmap+0xa7>
+    if((addr = ip->addrs[NDIRECT]) == 0)
+80101310:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
+80101316:	85 c0                	test   %eax,%eax
+80101318:	74 5e                	je     80101378 <bmap+0x98>
+    bp = bread(ip->dev, addr);
+8010131a:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010131e:	8b 03                	mov    (%ebx),%eax
+80101320:	89 04 24             	mov    %eax,(%esp)
+80101323:	e8 a8 ed ff ff       	call   801000d0 <bread>
+    if((addr = a[bn]) == 0){
+80101328:	8d 54 b0 5c          	lea    0x5c(%eax,%esi,4),%edx
+    bp = bread(ip->dev, addr);
+8010132c:	89 c7                	mov    %eax,%edi
+    if((addr = a[bn]) == 0){
+8010132e:	8b 32                	mov    (%edx),%esi
+80101330:	85 f6                	test   %esi,%esi
+80101332:	75 19                	jne    8010134d <bmap+0x6d>
+      a[bn] = addr = balloc(ip->dev);
+80101334:	8b 03                	mov    (%ebx),%eax
+80101336:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+80101339:	e8 c2 fd ff ff       	call   80101100 <balloc>
+8010133e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80101341:	89 02                	mov    %eax,(%edx)
+80101343:	89 c6                	mov    %eax,%esi
+      log_write(bp);
+80101345:	89 3c 24             	mov    %edi,(%esp)
+80101348:	e8 73 19 00 00       	call   80102cc0 <log_write>
+    brelse(bp);
+8010134d:	89 3c 24             	mov    %edi,(%esp)
+80101350:	e8 8b ee ff ff       	call   801001e0 <brelse>
+}
+80101355:	83 c4 1c             	add    $0x1c,%esp
+    brelse(bp);
+80101358:	89 f0                	mov    %esi,%eax
+}
+8010135a:	5b                   	pop    %ebx
+8010135b:	5e                   	pop    %esi
+8010135c:	5f                   	pop    %edi
+8010135d:	5d                   	pop    %ebp
+8010135e:	c3                   	ret    
+8010135f:	90                   	nop
+      ip->addrs[bn] = addr = balloc(ip->dev);
+80101360:	8b 03                	mov    (%ebx),%eax
+80101362:	e8 99 fd ff ff       	call   80101100 <balloc>
+80101367:	89 46 5c             	mov    %eax,0x5c(%esi)
+}
+8010136a:	83 c4 1c             	add    $0x1c,%esp
+8010136d:	5b                   	pop    %ebx
+8010136e:	5e                   	pop    %esi
+8010136f:	5f                   	pop    %edi
+80101370:	5d                   	pop    %ebp
+80101371:	c3                   	ret    
+80101372:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+80101378:	8b 03                	mov    (%ebx),%eax
+8010137a:	e8 81 fd ff ff       	call   80101100 <balloc>
+8010137f:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
+80101385:	eb 93                	jmp    8010131a <bmap+0x3a>
+  panic("bmap: out of range");
+80101387:	c7 04 24 05 6e 10 80 	movl   $0x80106e05,(%esp)
+8010138e:	e8 cd ef ff ff       	call   80100360 <panic>
+80101393:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80101399:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801013a0 <readsb>:
+{
+801013a0:	55                   	push   %ebp
+801013a1:	89 e5                	mov    %esp,%ebp
+801013a3:	56                   	push   %esi
+801013a4:	53                   	push   %ebx
+801013a5:	83 ec 10             	sub    $0x10,%esp
+  bp = bread(dev, 1);
+801013a8:	8b 45 08             	mov    0x8(%ebp),%eax
+801013ab:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+801013b2:	00 
+{
+801013b3:	8b 75 0c             	mov    0xc(%ebp),%esi
+  bp = bread(dev, 1);
+801013b6:	89 04 24             	mov    %eax,(%esp)
+801013b9:	e8 12 ed ff ff       	call   801000d0 <bread>
+  memmove(sb, bp->data, sizeof(*sb));
+801013be:	89 34 24             	mov    %esi,(%esp)
+801013c1:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
+801013c8:	00 
+  bp = bread(dev, 1);
+801013c9:	89 c3                	mov    %eax,%ebx
+  memmove(sb, bp->data, sizeof(*sb));
+801013cb:	8d 40 5c             	lea    0x5c(%eax),%eax
+801013ce:	89 44 24 04          	mov    %eax,0x4(%esp)
+801013d2:	e8 59 2f 00 00       	call   80104330 <memmove>
+  brelse(bp);
+801013d7:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+801013da:	83 c4 10             	add    $0x10,%esp
+801013dd:	5b                   	pop    %ebx
+801013de:	5e                   	pop    %esi
+801013df:	5d                   	pop    %ebp
+  brelse(bp);
+801013e0:	e9 fb ed ff ff       	jmp    801001e0 <brelse>
+801013e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801013e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801013f0 <bfree>:
+{
+801013f0:	55                   	push   %ebp
+801013f1:	89 e5                	mov    %esp,%ebp
+801013f3:	57                   	push   %edi
+801013f4:	89 d7                	mov    %edx,%edi
+801013f6:	56                   	push   %esi
+801013f7:	53                   	push   %ebx
+801013f8:	89 c3                	mov    %eax,%ebx
+801013fa:	83 ec 1c             	sub    $0x1c,%esp
+  readsb(dev, &sb);
+801013fd:	89 04 24             	mov    %eax,(%esp)
+80101400:	c7 44 24 04 c0 09 11 	movl   $0x801109c0,0x4(%esp)
+80101407:	80 
+80101408:	e8 93 ff ff ff       	call   801013a0 <readsb>
+  bp = bread(dev, BBLOCK(b, sb));
+8010140d:	89 fa                	mov    %edi,%edx
+8010140f:	c1 ea 0c             	shr    $0xc,%edx
+80101412:	03 15 d8 09 11 80    	add    0x801109d8,%edx
+80101418:	89 1c 24             	mov    %ebx,(%esp)
+  m = 1 << (bi % 8);
+8010141b:	bb 01 00 00 00       	mov    $0x1,%ebx
+  bp = bread(dev, BBLOCK(b, sb));
+80101420:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101424:	e8 a7 ec ff ff       	call   801000d0 <bread>
+  m = 1 << (bi % 8);
+80101429:	89 f9                	mov    %edi,%ecx
+  bi = b % BPB;
+8010142b:	81 e7 ff 0f 00 00    	and    $0xfff,%edi
+80101431:	89 fa                	mov    %edi,%edx
+  m = 1 << (bi % 8);
+80101433:	83 e1 07             	and    $0x7,%ecx
+  if((bp->data[bi/8] & m) == 0)
+80101436:	c1 fa 03             	sar    $0x3,%edx
+  m = 1 << (bi % 8);
+80101439:	d3 e3                	shl    %cl,%ebx
+  bp = bread(dev, BBLOCK(b, sb));
+8010143b:	89 c6                	mov    %eax,%esi
+  if((bp->data[bi/8] & m) == 0)
+8010143d:	0f b6 44 10 5c       	movzbl 0x5c(%eax,%edx,1),%eax
+80101442:	0f b6 c8             	movzbl %al,%ecx
+80101445:	85 d9                	test   %ebx,%ecx
+80101447:	74 20                	je     80101469 <bfree+0x79>
+  bp->data[bi/8] &= ~m;
+80101449:	f7 d3                	not    %ebx
+8010144b:	21 c3                	and    %eax,%ebx
+8010144d:	88 5c 16 5c          	mov    %bl,0x5c(%esi,%edx,1)
+  log_write(bp);
+80101451:	89 34 24             	mov    %esi,(%esp)
+80101454:	e8 67 18 00 00       	call   80102cc0 <log_write>
+  brelse(bp);
+80101459:	89 34 24             	mov    %esi,(%esp)
+8010145c:	e8 7f ed ff ff       	call   801001e0 <brelse>
+}
+80101461:	83 c4 1c             	add    $0x1c,%esp
+80101464:	5b                   	pop    %ebx
+80101465:	5e                   	pop    %esi
+80101466:	5f                   	pop    %edi
+80101467:	5d                   	pop    %ebp
+80101468:	c3                   	ret    
+    panic("freeing free block");
+80101469:	c7 04 24 18 6e 10 80 	movl   $0x80106e18,(%esp)
+80101470:	e8 eb ee ff ff       	call   80100360 <panic>
+80101475:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80101479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80101480 <iinit>:
+{
+80101480:	55                   	push   %ebp
+80101481:	89 e5                	mov    %esp,%ebp
+80101483:	53                   	push   %ebx
+80101484:	bb 20 0a 11 80       	mov    $0x80110a20,%ebx
+80101489:	83 ec 24             	sub    $0x24,%esp
+  initlock(&icache.lock, "icache");
+8010148c:	c7 44 24 04 2b 6e 10 	movl   $0x80106e2b,0x4(%esp)
+80101493:	80 
+80101494:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+8010149b:	e8 c0 2b 00 00       	call   80104060 <initlock>
+    initsleeplock(&icache.inode[i].lock, "inode");
+801014a0:	89 1c 24             	mov    %ebx,(%esp)
+801014a3:	81 c3 90 00 00 00    	add    $0x90,%ebx
+801014a9:	c7 44 24 04 32 6e 10 	movl   $0x80106e32,0x4(%esp)
+801014b0:	80 
+801014b1:	e8 9a 2a 00 00       	call   80103f50 <initsleeplock>
+  for(i = 0; i < NINODE; i++) {
+801014b6:	81 fb 40 26 11 80    	cmp    $0x80112640,%ebx
+801014bc:	75 e2                	jne    801014a0 <iinit+0x20>
+  readsb(dev, &sb);
+801014be:	8b 45 08             	mov    0x8(%ebp),%eax
+801014c1:	c7 44 24 04 c0 09 11 	movl   $0x801109c0,0x4(%esp)
+801014c8:	80 
+801014c9:	89 04 24             	mov    %eax,(%esp)
+801014cc:	e8 cf fe ff ff       	call   801013a0 <readsb>
+  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
+801014d1:	a1 d8 09 11 80       	mov    0x801109d8,%eax
+801014d6:	c7 04 24 98 6e 10 80 	movl   $0x80106e98,(%esp)
+801014dd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
+801014e1:	a1 d4 09 11 80       	mov    0x801109d4,%eax
+801014e6:	89 44 24 18          	mov    %eax,0x18(%esp)
+801014ea:	a1 d0 09 11 80       	mov    0x801109d0,%eax
+801014ef:	89 44 24 14          	mov    %eax,0x14(%esp)
+801014f3:	a1 cc 09 11 80       	mov    0x801109cc,%eax
+801014f8:	89 44 24 10          	mov    %eax,0x10(%esp)
+801014fc:	a1 c8 09 11 80       	mov    0x801109c8,%eax
+80101501:	89 44 24 0c          	mov    %eax,0xc(%esp)
+80101505:	a1 c4 09 11 80       	mov    0x801109c4,%eax
+8010150a:	89 44 24 08          	mov    %eax,0x8(%esp)
+8010150e:	a1 c0 09 11 80       	mov    0x801109c0,%eax
+80101513:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101517:	e8 34 f1 ff ff       	call   80100650 <cprintf>
+}
+8010151c:	83 c4 24             	add    $0x24,%esp
+8010151f:	5b                   	pop    %ebx
+80101520:	5d                   	pop    %ebp
+80101521:	c3                   	ret    
+80101522:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101529:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80101530 <ialloc>:
+{
+80101530:	55                   	push   %ebp
+80101531:	89 e5                	mov    %esp,%ebp
+80101533:	57                   	push   %edi
+80101534:	56                   	push   %esi
+80101535:	53                   	push   %ebx
+80101536:	83 ec 2c             	sub    $0x2c,%esp
+80101539:	8b 45 0c             	mov    0xc(%ebp),%eax
+  for(inum = 1; inum < sb.ninodes; inum++){
+8010153c:	83 3d c8 09 11 80 01 	cmpl   $0x1,0x801109c8
+{
+80101543:	8b 7d 08             	mov    0x8(%ebp),%edi
+80101546:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  for(inum = 1; inum < sb.ninodes; inum++){
+80101549:	0f 86 a2 00 00 00    	jbe    801015f1 <ialloc+0xc1>
+8010154f:	be 01 00 00 00       	mov    $0x1,%esi
+80101554:	bb 01 00 00 00       	mov    $0x1,%ebx
+80101559:	eb 1a                	jmp    80101575 <ialloc+0x45>
+8010155b:	90                   	nop
+8010155c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    brelse(bp);
+80101560:	89 14 24             	mov    %edx,(%esp)
+  for(inum = 1; inum < sb.ninodes; inum++){
+80101563:	83 c3 01             	add    $0x1,%ebx
+    brelse(bp);
+80101566:	e8 75 ec ff ff       	call   801001e0 <brelse>
+  for(inum = 1; inum < sb.ninodes; inum++){
+8010156b:	89 de                	mov    %ebx,%esi
+8010156d:	3b 1d c8 09 11 80    	cmp    0x801109c8,%ebx
+80101573:	73 7c                	jae    801015f1 <ialloc+0xc1>
+    bp = bread(dev, IBLOCK(inum, sb));
+80101575:	89 f0                	mov    %esi,%eax
+80101577:	c1 e8 03             	shr    $0x3,%eax
+8010157a:	03 05 d4 09 11 80    	add    0x801109d4,%eax
+80101580:	89 3c 24             	mov    %edi,(%esp)
+80101583:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101587:	e8 44 eb ff ff       	call   801000d0 <bread>
+8010158c:	89 c2                	mov    %eax,%edx
+    dip = (struct dinode*)bp->data + inum%IPB;
+8010158e:	89 f0                	mov    %esi,%eax
+80101590:	83 e0 07             	and    $0x7,%eax
+80101593:	c1 e0 06             	shl    $0x6,%eax
+80101596:	8d 4c 02 5c          	lea    0x5c(%edx,%eax,1),%ecx
+    if(dip->type == 0){  // a free inode
+8010159a:	66 83 39 00          	cmpw   $0x0,(%ecx)
+8010159e:	75 c0                	jne    80101560 <ialloc+0x30>
+      memset(dip, 0, sizeof(*dip));
+801015a0:	89 0c 24             	mov    %ecx,(%esp)
+801015a3:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
+801015aa:	00 
+801015ab:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+801015b2:	00 
+801015b3:	89 55 dc             	mov    %edx,-0x24(%ebp)
+801015b6:	89 4d e0             	mov    %ecx,-0x20(%ebp)
+801015b9:	e8 d2 2c 00 00       	call   80104290 <memset>
+      dip->type = type;
+801015be:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
+      log_write(bp);   // mark it allocated on the disk
+801015c2:	8b 55 dc             	mov    -0x24(%ebp),%edx
+      dip->type = type;
+801015c5:	8b 4d e0             	mov    -0x20(%ebp),%ecx
+      log_write(bp);   // mark it allocated on the disk
+801015c8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+      dip->type = type;
+801015cb:	66 89 01             	mov    %ax,(%ecx)
+      log_write(bp);   // mark it allocated on the disk
+801015ce:	89 14 24             	mov    %edx,(%esp)
+801015d1:	e8 ea 16 00 00       	call   80102cc0 <log_write>
+      brelse(bp);
+801015d6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+801015d9:	89 14 24             	mov    %edx,(%esp)
+801015dc:	e8 ff eb ff ff       	call   801001e0 <brelse>
+}
+801015e1:	83 c4 2c             	add    $0x2c,%esp
+      return iget(dev, inum);
+801015e4:	89 f2                	mov    %esi,%edx
+}
+801015e6:	5b                   	pop    %ebx
+      return iget(dev, inum);
+801015e7:	89 f8                	mov    %edi,%eax
+}
+801015e9:	5e                   	pop    %esi
+801015ea:	5f                   	pop    %edi
+801015eb:	5d                   	pop    %ebp
+      return iget(dev, inum);
+801015ec:	e9 2f fc ff ff       	jmp    80101220 <iget>
+  panic("ialloc: no inodes");
+801015f1:	c7 04 24 38 6e 10 80 	movl   $0x80106e38,(%esp)
+801015f8:	e8 63 ed ff ff       	call   80100360 <panic>
+801015fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+80101600 <iupdate>:
+{
+80101600:	55                   	push   %ebp
+80101601:	89 e5                	mov    %esp,%ebp
+80101603:	56                   	push   %esi
+80101604:	53                   	push   %ebx
+80101605:	83 ec 10             	sub    $0x10,%esp
+80101608:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+8010160b:	8b 43 04             	mov    0x4(%ebx),%eax
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+8010160e:	83 c3 5c             	add    $0x5c,%ebx
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+80101611:	c1 e8 03             	shr    $0x3,%eax
+80101614:	03 05 d4 09 11 80    	add    0x801109d4,%eax
+8010161a:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010161e:	8b 43 a4             	mov    -0x5c(%ebx),%eax
+80101621:	89 04 24             	mov    %eax,(%esp)
+80101624:	e8 a7 ea ff ff       	call   801000d0 <bread>
+  dip = (struct dinode*)bp->data + ip->inum%IPB;
+80101629:	8b 53 a8             	mov    -0x58(%ebx),%edx
+8010162c:	83 e2 07             	and    $0x7,%edx
+8010162f:	c1 e2 06             	shl    $0x6,%edx
+80101632:	8d 54 10 5c          	lea    0x5c(%eax,%edx,1),%edx
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+80101636:	89 c6                	mov    %eax,%esi
+  dip->type = ip->type;
+80101638:	0f b7 43 f4          	movzwl -0xc(%ebx),%eax
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+8010163c:	83 c2 0c             	add    $0xc,%edx
+  dip->type = ip->type;
+8010163f:	66 89 42 f4          	mov    %ax,-0xc(%edx)
+  dip->major = ip->major;
+80101643:	0f b7 43 f6          	movzwl -0xa(%ebx),%eax
+80101647:	66 89 42 f6          	mov    %ax,-0xa(%edx)
+  dip->minor = ip->minor;
+8010164b:	0f b7 43 f8          	movzwl -0x8(%ebx),%eax
+8010164f:	66 89 42 f8          	mov    %ax,-0x8(%edx)
+  dip->nlink = ip->nlink;
+80101653:	0f b7 43 fa          	movzwl -0x6(%ebx),%eax
+80101657:	66 89 42 fa          	mov    %ax,-0x6(%edx)
+  dip->size = ip->size;
+8010165b:	8b 43 fc             	mov    -0x4(%ebx),%eax
+8010165e:	89 42 fc             	mov    %eax,-0x4(%edx)
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+80101661:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80101665:	89 14 24             	mov    %edx,(%esp)
+80101668:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
+8010166f:	00 
+80101670:	e8 bb 2c 00 00       	call   80104330 <memmove>
+  log_write(bp);
+80101675:	89 34 24             	mov    %esi,(%esp)
+80101678:	e8 43 16 00 00       	call   80102cc0 <log_write>
+  brelse(bp);
+8010167d:	89 75 08             	mov    %esi,0x8(%ebp)
+}
+80101680:	83 c4 10             	add    $0x10,%esp
+80101683:	5b                   	pop    %ebx
+80101684:	5e                   	pop    %esi
+80101685:	5d                   	pop    %ebp
+  brelse(bp);
+80101686:	e9 55 eb ff ff       	jmp    801001e0 <brelse>
+8010168b:	90                   	nop
+8010168c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80101690 <idup>:
+{
+80101690:	55                   	push   %ebp
+80101691:	89 e5                	mov    %esp,%ebp
+80101693:	53                   	push   %ebx
+80101694:	83 ec 14             	sub    $0x14,%esp
+80101697:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&icache.lock);
+8010169a:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+801016a1:	e8 aa 2a 00 00       	call   80104150 <acquire>
+  ip->ref++;
+801016a6:	83 43 08 01          	addl   $0x1,0x8(%ebx)
+  release(&icache.lock);
+801016aa:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+801016b1:	e8 8a 2b 00 00       	call   80104240 <release>
+}
+801016b6:	83 c4 14             	add    $0x14,%esp
+801016b9:	89 d8                	mov    %ebx,%eax
+801016bb:	5b                   	pop    %ebx
+801016bc:	5d                   	pop    %ebp
+801016bd:	c3                   	ret    
+801016be:	66 90                	xchg   %ax,%ax
+
+801016c0 <ilock>:
+{
+801016c0:	55                   	push   %ebp
+801016c1:	89 e5                	mov    %esp,%ebp
+801016c3:	56                   	push   %esi
+801016c4:	53                   	push   %ebx
+801016c5:	83 ec 10             	sub    $0x10,%esp
+801016c8:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(ip == 0 || ip->ref < 1)
+801016cb:	85 db                	test   %ebx,%ebx
+801016cd:	0f 84 b3 00 00 00    	je     80101786 <ilock+0xc6>
+801016d3:	8b 53 08             	mov    0x8(%ebx),%edx
+801016d6:	85 d2                	test   %edx,%edx
+801016d8:	0f 8e a8 00 00 00    	jle    80101786 <ilock+0xc6>
+  acquiresleep(&ip->lock);
+801016de:	8d 43 0c             	lea    0xc(%ebx),%eax
+801016e1:	89 04 24             	mov    %eax,(%esp)
+801016e4:	e8 a7 28 00 00       	call   80103f90 <acquiresleep>
+  if(ip->valid == 0){
+801016e9:	8b 43 4c             	mov    0x4c(%ebx),%eax
+801016ec:	85 c0                	test   %eax,%eax
+801016ee:	74 08                	je     801016f8 <ilock+0x38>
+}
+801016f0:	83 c4 10             	add    $0x10,%esp
+801016f3:	5b                   	pop    %ebx
+801016f4:	5e                   	pop    %esi
+801016f5:	5d                   	pop    %ebp
+801016f6:	c3                   	ret    
+801016f7:	90                   	nop
+    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+801016f8:	8b 43 04             	mov    0x4(%ebx),%eax
+801016fb:	c1 e8 03             	shr    $0x3,%eax
+801016fe:	03 05 d4 09 11 80    	add    0x801109d4,%eax
+80101704:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101708:	8b 03                	mov    (%ebx),%eax
+8010170a:	89 04 24             	mov    %eax,(%esp)
+8010170d:	e8 be e9 ff ff       	call   801000d0 <bread>
+    dip = (struct dinode*)bp->data + ip->inum%IPB;
+80101712:	8b 53 04             	mov    0x4(%ebx),%edx
+80101715:	83 e2 07             	and    $0x7,%edx
+80101718:	c1 e2 06             	shl    $0x6,%edx
+8010171b:	8d 54 10 5c          	lea    0x5c(%eax,%edx,1),%edx
+    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+8010171f:	89 c6                	mov    %eax,%esi
+    ip->type = dip->type;
+80101721:	0f b7 02             	movzwl (%edx),%eax
+    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+80101724:	83 c2 0c             	add    $0xc,%edx
+    ip->type = dip->type;
+80101727:	66 89 43 50          	mov    %ax,0x50(%ebx)
+    ip->major = dip->major;
+8010172b:	0f b7 42 f6          	movzwl -0xa(%edx),%eax
+8010172f:	66 89 43 52          	mov    %ax,0x52(%ebx)
+    ip->minor = dip->minor;
+80101733:	0f b7 42 f8          	movzwl -0x8(%edx),%eax
+80101737:	66 89 43 54          	mov    %ax,0x54(%ebx)
+    ip->nlink = dip->nlink;
+8010173b:	0f b7 42 fa          	movzwl -0x6(%edx),%eax
+8010173f:	66 89 43 56          	mov    %ax,0x56(%ebx)
+    ip->size = dip->size;
+80101743:	8b 42 fc             	mov    -0x4(%edx),%eax
+80101746:	89 43 58             	mov    %eax,0x58(%ebx)
+    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+80101749:	8d 43 5c             	lea    0x5c(%ebx),%eax
+8010174c:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101750:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
+80101757:	00 
+80101758:	89 04 24             	mov    %eax,(%esp)
+8010175b:	e8 d0 2b 00 00       	call   80104330 <memmove>
+    brelse(bp);
+80101760:	89 34 24             	mov    %esi,(%esp)
+80101763:	e8 78 ea ff ff       	call   801001e0 <brelse>
+    if(ip->type == 0)
+80101768:	66 83 7b 50 00       	cmpw   $0x0,0x50(%ebx)
+    ip->valid = 1;
+8010176d:	c7 43 4c 01 00 00 00 	movl   $0x1,0x4c(%ebx)
+    if(ip->type == 0)
+80101774:	0f 85 76 ff ff ff    	jne    801016f0 <ilock+0x30>
+      panic("ilock: no type");
+8010177a:	c7 04 24 50 6e 10 80 	movl   $0x80106e50,(%esp)
+80101781:	e8 da eb ff ff       	call   80100360 <panic>
+    panic("ilock");
+80101786:	c7 04 24 4a 6e 10 80 	movl   $0x80106e4a,(%esp)
+8010178d:	e8 ce eb ff ff       	call   80100360 <panic>
+80101792:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101799:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801017a0 <iunlock>:
+{
+801017a0:	55                   	push   %ebp
+801017a1:	89 e5                	mov    %esp,%ebp
+801017a3:	56                   	push   %esi
+801017a4:	53                   	push   %ebx
+801017a5:	83 ec 10             	sub    $0x10,%esp
+801017a8:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+801017ab:	85 db                	test   %ebx,%ebx
+801017ad:	74 24                	je     801017d3 <iunlock+0x33>
+801017af:	8d 73 0c             	lea    0xc(%ebx),%esi
+801017b2:	89 34 24             	mov    %esi,(%esp)
+801017b5:	e8 76 28 00 00       	call   80104030 <holdingsleep>
+801017ba:	85 c0                	test   %eax,%eax
+801017bc:	74 15                	je     801017d3 <iunlock+0x33>
+801017be:	8b 43 08             	mov    0x8(%ebx),%eax
+801017c1:	85 c0                	test   %eax,%eax
+801017c3:	7e 0e                	jle    801017d3 <iunlock+0x33>
+  releasesleep(&ip->lock);
+801017c5:	89 75 08             	mov    %esi,0x8(%ebp)
+}
+801017c8:	83 c4 10             	add    $0x10,%esp
+801017cb:	5b                   	pop    %ebx
+801017cc:	5e                   	pop    %esi
+801017cd:	5d                   	pop    %ebp
+  releasesleep(&ip->lock);
+801017ce:	e9 1d 28 00 00       	jmp    80103ff0 <releasesleep>
+    panic("iunlock");
+801017d3:	c7 04 24 5f 6e 10 80 	movl   $0x80106e5f,(%esp)
+801017da:	e8 81 eb ff ff       	call   80100360 <panic>
+801017df:	90                   	nop
+
+801017e0 <iput>:
+{
+801017e0:	55                   	push   %ebp
+801017e1:	89 e5                	mov    %esp,%ebp
+801017e3:	57                   	push   %edi
+801017e4:	56                   	push   %esi
+801017e5:	53                   	push   %ebx
+801017e6:	83 ec 1c             	sub    $0x1c,%esp
+801017e9:	8b 75 08             	mov    0x8(%ebp),%esi
+  acquiresleep(&ip->lock);
+801017ec:	8d 7e 0c             	lea    0xc(%esi),%edi
+801017ef:	89 3c 24             	mov    %edi,(%esp)
+801017f2:	e8 99 27 00 00       	call   80103f90 <acquiresleep>
+  if(ip->valid && ip->nlink == 0){
+801017f7:	8b 56 4c             	mov    0x4c(%esi),%edx
+801017fa:	85 d2                	test   %edx,%edx
+801017fc:	74 07                	je     80101805 <iput+0x25>
+801017fe:	66 83 7e 56 00       	cmpw   $0x0,0x56(%esi)
+80101803:	74 2b                	je     80101830 <iput+0x50>
+  releasesleep(&ip->lock);
+80101805:	89 3c 24             	mov    %edi,(%esp)
+80101808:	e8 e3 27 00 00       	call   80103ff0 <releasesleep>
+  acquire(&icache.lock);
+8010180d:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+80101814:	e8 37 29 00 00       	call   80104150 <acquire>
+  ip->ref--;
+80101819:	83 6e 08 01          	subl   $0x1,0x8(%esi)
+  release(&icache.lock);
+8010181d:	c7 45 08 e0 09 11 80 	movl   $0x801109e0,0x8(%ebp)
+}
+80101824:	83 c4 1c             	add    $0x1c,%esp
+80101827:	5b                   	pop    %ebx
+80101828:	5e                   	pop    %esi
+80101829:	5f                   	pop    %edi
+8010182a:	5d                   	pop    %ebp
+  release(&icache.lock);
+8010182b:	e9 10 2a 00 00       	jmp    80104240 <release>
+    acquire(&icache.lock);
+80101830:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+80101837:	e8 14 29 00 00       	call   80104150 <acquire>
+    int r = ip->ref;
+8010183c:	8b 5e 08             	mov    0x8(%esi),%ebx
+    release(&icache.lock);
+8010183f:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+80101846:	e8 f5 29 00 00       	call   80104240 <release>
+    if(r == 1){
+8010184b:	83 fb 01             	cmp    $0x1,%ebx
+8010184e:	75 b5                	jne    80101805 <iput+0x25>
+80101850:	8d 4e 30             	lea    0x30(%esi),%ecx
+80101853:	89 f3                	mov    %esi,%ebx
+80101855:	89 7d e4             	mov    %edi,-0x1c(%ebp)
+80101858:	89 cf                	mov    %ecx,%edi
+8010185a:	eb 0b                	jmp    80101867 <iput+0x87>
+8010185c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80101860:	83 c3 04             	add    $0x4,%ebx
+{
+  int i, j;
+  struct buf *bp;
+  uint *a;
+
+  for(i = 0; i < NDIRECT; i++){
+80101863:	39 fb                	cmp    %edi,%ebx
+80101865:	74 19                	je     80101880 <iput+0xa0>
+    if(ip->addrs[i]){
+80101867:	8b 53 5c             	mov    0x5c(%ebx),%edx
+8010186a:	85 d2                	test   %edx,%edx
+8010186c:	74 f2                	je     80101860 <iput+0x80>
+      bfree(ip->dev, ip->addrs[i]);
+8010186e:	8b 06                	mov    (%esi),%eax
+80101870:	e8 7b fb ff ff       	call   801013f0 <bfree>
+      ip->addrs[i] = 0;
+80101875:	c7 43 5c 00 00 00 00 	movl   $0x0,0x5c(%ebx)
+8010187c:	eb e2                	jmp    80101860 <iput+0x80>
+8010187e:	66 90                	xchg   %ax,%ax
+    }
+  }
+
+  if(ip->addrs[NDIRECT]){
+80101880:	8b 86 8c 00 00 00    	mov    0x8c(%esi),%eax
+80101886:	8b 7d e4             	mov    -0x1c(%ebp),%edi
+80101889:	85 c0                	test   %eax,%eax
+8010188b:	75 2b                	jne    801018b8 <iput+0xd8>
+    brelse(bp);
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+    ip->addrs[NDIRECT] = 0;
+  }
+
+  ip->size = 0;
+8010188d:	c7 46 58 00 00 00 00 	movl   $0x0,0x58(%esi)
+  iupdate(ip);
+80101894:	89 34 24             	mov    %esi,(%esp)
+80101897:	e8 64 fd ff ff       	call   80101600 <iupdate>
+      ip->type = 0;
+8010189c:	31 c0                	xor    %eax,%eax
+8010189e:	66 89 46 50          	mov    %ax,0x50(%esi)
+      iupdate(ip);
+801018a2:	89 34 24             	mov    %esi,(%esp)
+801018a5:	e8 56 fd ff ff       	call   80101600 <iupdate>
+      ip->valid = 0;
+801018aa:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
+801018b1:	e9 4f ff ff ff       	jmp    80101805 <iput+0x25>
+801018b6:	66 90                	xchg   %ax,%ax
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+801018b8:	89 44 24 04          	mov    %eax,0x4(%esp)
+801018bc:	8b 06                	mov    (%esi),%eax
+    for(j = 0; j < NINDIRECT; j++){
+801018be:	31 db                	xor    %ebx,%ebx
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+801018c0:	89 04 24             	mov    %eax,(%esp)
+801018c3:	e8 08 e8 ff ff       	call   801000d0 <bread>
+    for(j = 0; j < NINDIRECT; j++){
+801018c8:	89 7d e0             	mov    %edi,-0x20(%ebp)
+    a = (uint*)bp->data;
+801018cb:	8d 48 5c             	lea    0x5c(%eax),%ecx
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+801018ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    for(j = 0; j < NINDIRECT; j++){
+801018d1:	89 cf                	mov    %ecx,%edi
+801018d3:	31 c0                	xor    %eax,%eax
+801018d5:	eb 0e                	jmp    801018e5 <iput+0x105>
+801018d7:	90                   	nop
+801018d8:	83 c3 01             	add    $0x1,%ebx
+801018db:	81 fb 80 00 00 00    	cmp    $0x80,%ebx
+801018e1:	89 d8                	mov    %ebx,%eax
+801018e3:	74 10                	je     801018f5 <iput+0x115>
+      if(a[j])
+801018e5:	8b 14 87             	mov    (%edi,%eax,4),%edx
+801018e8:	85 d2                	test   %edx,%edx
+801018ea:	74 ec                	je     801018d8 <iput+0xf8>
+        bfree(ip->dev, a[j]);
+801018ec:	8b 06                	mov    (%esi),%eax
+801018ee:	e8 fd fa ff ff       	call   801013f0 <bfree>
+801018f3:	eb e3                	jmp    801018d8 <iput+0xf8>
+    brelse(bp);
+801018f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+801018f8:	8b 7d e0             	mov    -0x20(%ebp),%edi
+801018fb:	89 04 24             	mov    %eax,(%esp)
+801018fe:	e8 dd e8 ff ff       	call   801001e0 <brelse>
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+80101903:	8b 96 8c 00 00 00    	mov    0x8c(%esi),%edx
+80101909:	8b 06                	mov    (%esi),%eax
+8010190b:	e8 e0 fa ff ff       	call   801013f0 <bfree>
+    ip->addrs[NDIRECT] = 0;
+80101910:	c7 86 8c 00 00 00 00 	movl   $0x0,0x8c(%esi)
+80101917:	00 00 00 
+8010191a:	e9 6e ff ff ff       	jmp    8010188d <iput+0xad>
+8010191f:	90                   	nop
+
+80101920 <iunlockput>:
+{
+80101920:	55                   	push   %ebp
+80101921:	89 e5                	mov    %esp,%ebp
+80101923:	53                   	push   %ebx
+80101924:	83 ec 14             	sub    $0x14,%esp
+80101927:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  iunlock(ip);
+8010192a:	89 1c 24             	mov    %ebx,(%esp)
+8010192d:	e8 6e fe ff ff       	call   801017a0 <iunlock>
+  iput(ip);
+80101932:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+80101935:	83 c4 14             	add    $0x14,%esp
+80101938:	5b                   	pop    %ebx
+80101939:	5d                   	pop    %ebp
+  iput(ip);
+8010193a:	e9 a1 fe ff ff       	jmp    801017e0 <iput>
+8010193f:	90                   	nop
+
+80101940 <stati>:
+
+// Copy stat information from inode.
+// Caller must hold ip->lock.
+void
+stati(struct inode *ip, struct stat *st)
+{
+80101940:	55                   	push   %ebp
+80101941:	89 e5                	mov    %esp,%ebp
+80101943:	8b 55 08             	mov    0x8(%ebp),%edx
+80101946:	8b 45 0c             	mov    0xc(%ebp),%eax
+  st->dev = ip->dev;
+80101949:	8b 0a                	mov    (%edx),%ecx
+8010194b:	89 48 04             	mov    %ecx,0x4(%eax)
+  st->ino = ip->inum;
+8010194e:	8b 4a 04             	mov    0x4(%edx),%ecx
+80101951:	89 48 08             	mov    %ecx,0x8(%eax)
+  st->type = ip->type;
+80101954:	0f b7 4a 50          	movzwl 0x50(%edx),%ecx
+80101958:	66 89 08             	mov    %cx,(%eax)
+  st->nlink = ip->nlink;
+8010195b:	0f b7 4a 56          	movzwl 0x56(%edx),%ecx
+8010195f:	66 89 48 0c          	mov    %cx,0xc(%eax)
+  st->size = ip->size;
+80101963:	8b 52 58             	mov    0x58(%edx),%edx
+80101966:	89 50 10             	mov    %edx,0x10(%eax)
+}
+80101969:	5d                   	pop    %ebp
+8010196a:	c3                   	ret    
+8010196b:	90                   	nop
+8010196c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80101970 <readi>:
+//PAGEBREAK!
+// Read data from inode.
+// Caller must hold ip->lock.
+int
+readi(struct inode *ip, char *dst, uint off, uint n)
+{
+80101970:	55                   	push   %ebp
+80101971:	89 e5                	mov    %esp,%ebp
+80101973:	57                   	push   %edi
+80101974:	56                   	push   %esi
+80101975:	53                   	push   %ebx
+80101976:	83 ec 2c             	sub    $0x2c,%esp
+80101979:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010197c:	8b 7d 08             	mov    0x8(%ebp),%edi
+8010197f:	8b 75 10             	mov    0x10(%ebp),%esi
+80101982:	89 45 e0             	mov    %eax,-0x20(%ebp)
+80101985:	8b 45 14             	mov    0x14(%ebp),%eax
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+80101988:	66 83 7f 50 03       	cmpw   $0x3,0x50(%edi)
+{
+8010198d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(ip->type == T_DEV){
+80101990:	0f 84 aa 00 00 00    	je     80101a40 <readi+0xd0>
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+      return -1;
+    return devsw[ip->major].read(ip, dst, n);
+  }
+
+  if(off > ip->size || off + n < off)
+80101996:	8b 47 58             	mov    0x58(%edi),%eax
+80101999:	39 f0                	cmp    %esi,%eax
+8010199b:	0f 82 c7 00 00 00    	jb     80101a68 <readi+0xf8>
+801019a1:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+801019a4:	89 da                	mov    %ebx,%edx
+801019a6:	01 f2                	add    %esi,%edx
+801019a8:	0f 82 ba 00 00 00    	jb     80101a68 <readi+0xf8>
+    return -1;
+  if(off + n > ip->size)
+    n = ip->size - off;
+801019ae:	89 c1                	mov    %eax,%ecx
+801019b0:	29 f1                	sub    %esi,%ecx
+801019b2:	39 d0                	cmp    %edx,%eax
+801019b4:	0f 43 cb             	cmovae %ebx,%ecx
+
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+801019b7:	31 c0                	xor    %eax,%eax
+801019b9:	85 c9                	test   %ecx,%ecx
+    n = ip->size - off;
+801019bb:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+801019be:	74 70                	je     80101a30 <readi+0xc0>
+801019c0:	89 7d d8             	mov    %edi,-0x28(%ebp)
+801019c3:	89 c7                	mov    %eax,%edi
+801019c5:	8d 76 00             	lea    0x0(%esi),%esi
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+801019c8:	8b 5d d8             	mov    -0x28(%ebp),%ebx
+801019cb:	89 f2                	mov    %esi,%edx
+801019cd:	c1 ea 09             	shr    $0x9,%edx
+801019d0:	89 d8                	mov    %ebx,%eax
+801019d2:	e8 09 f9 ff ff       	call   801012e0 <bmap>
+801019d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+801019db:	8b 03                	mov    (%ebx),%eax
+    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+80102c0d:	8b 04 9d cc 26 11 80 	mov    -0x7feed934(,%ebx,4),%eax
+  for (tail = 0; tail < log.lh.n; tail++) {
+80102c14:	83 c3 01             	add    $0x1,%ebx
+    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+80102c17:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102c1b:	a1 c4 26 11 80       	mov    0x801126c4,%eax
+80102c20:	89 04 24             	mov    %eax,(%esp)
+80102c23:	e8 a8 d4 ff ff       	call   801000d0 <bread>
+    memmove(to->data, from->data, BSIZE);
+80102c28:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+80102c2f:	00 
+    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+80102c30:	89 c7                	mov    %eax,%edi
+    memmove(to->data, from->data, BSIZE);
+80102c32:	8d 40 5c             	lea    0x5c(%eax),%eax
+80102c35:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102c39:	8d 46 5c             	lea    0x5c(%esi),%eax
+80102c3c:	89 04 24             	mov    %eax,(%esp)
+80102c3f:	e8 ec 16 00 00       	call   80104330 <memmove>
+    bwrite(to);  // write the log
+80102c44:	89 34 24             	mov    %esi,(%esp)
+80102c47:	e8 54 d5 ff ff       	call   801001a0 <bwrite>
+    brelse(from);
+80102c4c:	89 3c 24             	mov    %edi,(%esp)
+80102c4f:	e8 8c d5 ff ff       	call   801001e0 <brelse>
+    brelse(to);
+80102c54:	89 34 24             	mov    %esi,(%esp)
+80102c57:	e8 84 d5 ff ff       	call   801001e0 <brelse>
+  for (tail = 0; tail < log.lh.n; tail++) {
+80102c5c:	3b 1d c8 26 11 80    	cmp    0x801126c8,%ebx
+80102c62:	7c 8c                	jl     80102bf0 <end_op+0x60>
+    write_log();     // Write modified blocks from cache to log
+    write_head();    // Write header to disk -- the real commit
+80102c64:	e8 a7 fd ff ff       	call   80102a10 <write_head>
+    install_trans(); // Now install writes to home locations
+80102c69:	e8 02 fd ff ff       	call   80102970 <install_trans>
+    log.lh.n = 0;
+80102c6e:	c7 05 c8 26 11 80 00 	movl   $0x0,0x801126c8
+80102c75:	00 00 00 
+    write_head();    // Erase the transaction from the log
+80102c78:	e8 93 fd ff ff       	call   80102a10 <write_head>
+    acquire(&log.lock);
+80102c7d:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102c84:	e8 c7 14 00 00       	call   80104150 <acquire>
+    log.committing = 0;
+80102c89:	c7 05 c0 26 11 80 00 	movl   $0x0,0x801126c0
+80102c90:	00 00 00 
+    wakeup(&log);
+80102c93:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102c9a:	e8 01 11 00 00       	call   80103da0 <wakeup>
+    release(&log.lock);
+80102c9f:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102ca6:	e8 95 15 00 00       	call   80104240 <release>
+}
+80102cab:	83 c4 1c             	add    $0x1c,%esp
+80102cae:	5b                   	pop    %ebx
+80102caf:	5e                   	pop    %esi
+80102cb0:	5f                   	pop    %edi
+80102cb1:	5d                   	pop    %ebp
+80102cb2:	c3                   	ret    
+    panic("log.committing");
+80102cb3:	c7 04 24 c4 71 10 80 	movl   $0x801071c4,(%esp)
+80102cba:	e8 a1 d6 ff ff       	call   80100360 <panic>
+80102cbf:	90                   	nop
+
+80102cc0 <log_write>:
+//   modify bp->data[]
+//   log_write(bp)
+//   brelse(bp)
+void
+log_write(struct buf *b)
+{
+80102cc0:	55                   	push   %ebp
+80102cc1:	89 e5                	mov    %esp,%ebp
+80102cc3:	53                   	push   %ebx
+80102cc4:	83 ec 14             	sub    $0x14,%esp
+  int i;
+
+  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+80102cc7:	a1 c8 26 11 80       	mov    0x801126c8,%eax
+{
+80102ccc:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+80102ccf:	83 f8 1d             	cmp    $0x1d,%eax
+80102cd2:	0f 8f 98 00 00 00    	jg     80102d70 <log_write+0xb0>
+80102cd8:	8b 0d b8 26 11 80    	mov    0x801126b8,%ecx
+80102cde:	8d 51 ff             	lea    -0x1(%ecx),%edx
+80102ce1:	39 d0                	cmp    %edx,%eax
+80102ce3:	0f 8d 87 00 00 00    	jge    80102d70 <log_write+0xb0>
+    panic("too big a transaction");
+  if (log.outstanding < 1)
+80102ce9:	a1 bc 26 11 80       	mov    0x801126bc,%eax
+80102cee:	85 c0                	test   %eax,%eax
+80102cf0:	0f 8e 86 00 00 00    	jle    80102d7c <log_write+0xbc>
+    panic("log_write outside of trans");
+
+  acquire(&log.lock);
+80102cf6:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102cfd:	e8 4e 14 00 00       	call   80104150 <acquire>
+  for (i = 0; i < log.lh.n; i++) {
+80102d02:	8b 15 c8 26 11 80    	mov    0x801126c8,%edx
+80102d08:	83 fa 00             	cmp    $0x0,%edx
+80102d0b:	7e 54                	jle    80102d61 <log_write+0xa1>
+    if (log.lh.block[i] == b->blockno)   // log absorbtion
+80102d0d:	8b 4b 08             	mov    0x8(%ebx),%ecx
+  for (i = 0; i < log.lh.n; i++) {
+80102d10:	31 c0                	xor    %eax,%eax
+    if (log.lh.block[i] == b->blockno)   // log absorbtion
+80102d12:	39 0d cc 26 11 80    	cmp    %ecx,0x801126cc
+80102d18:	75 0f                	jne    80102d29 <log_write+0x69>
+80102d1a:	eb 3c                	jmp    80102d58 <log_write+0x98>
+80102d1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80102d20:	39 0c 85 cc 26 11 80 	cmp    %ecx,-0x7feed934(,%eax,4)
+80102d27:	74 2f                	je     80102d58 <log_write+0x98>
+  for (i = 0; i < log.lh.n; i++) {
+80102d29:	83 c0 01             	add    $0x1,%eax
+80102d2c:	39 d0                	cmp    %edx,%eax
+80102d2e:	75 f0                	jne    80102d20 <log_write+0x60>
+      break;
+  }
+  log.lh.block[i] = b->blockno;
+80102d30:	89 0c 95 cc 26 11 80 	mov    %ecx,-0x7feed934(,%edx,4)
+  if (i == log.lh.n)
+    log.lh.n++;
+80102d37:	83 c2 01             	add    $0x1,%edx
+80102d3a:	89 15 c8 26 11 80    	mov    %edx,0x801126c8
+  b->flags |= B_DIRTY; // prevent eviction
+80102d40:	83 0b 04             	orl    $0x4,(%ebx)
+  release(&log.lock);
+80102d43:	c7 45 08 80 26 11 80 	movl   $0x80112680,0x8(%ebp)
+}
+80102d4a:	83 c4 14             	add    $0x14,%esp
+80102d4d:	5b                   	pop    %ebx
+80102d4e:	5d                   	pop    %ebp
+  release(&log.lock);
+80102d4f:	e9 ec 14 00 00       	jmp    80104240 <release>
+80102d54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  log.lh.block[i] = b->blockno;
+80102d58:	89 0c 85 cc 26 11 80 	mov    %ecx,-0x7feed934(,%eax,4)
+80102d5f:	eb df                	jmp    80102d40 <log_write+0x80>
+80102d61:	8b 43 08             	mov    0x8(%ebx),%eax
+80102d64:	a3 cc 26 11 80       	mov    %eax,0x801126cc
+  if (i == log.lh.n)
+80102d69:	75 d5                	jne    80102d40 <log_write+0x80>
+80102d6b:	eb ca                	jmp    80102d37 <log_write+0x77>
+80102d6d:	8d 76 00             	lea    0x0(%esi),%esi
+    panic("too big a transaction");
+80102d70:	c7 04 24 d3 71 10 80 	movl   $0x801071d3,(%esp)
+80102d77:	e8 e4 d5 ff ff       	call   80100360 <panic>
+    panic("log_write outside of trans");
+80102d7c:	c7 04 24 e9 71 10 80 	movl   $0x801071e9,(%esp)
+80102d83:	e8 d8 d5 ff ff       	call   80100360 <panic>
+80102d88:	66 90                	xchg   %ax,%ax
+80102d8a:	66 90                	xchg   %ax,%ax
+80102d8c:	66 90                	xchg   %ax,%ax
+80102d8e:	66 90                	xchg   %ax,%ax
+
+80102d90 <mpmain>:
+}
+
+// Common CPU setup code.
+static void
+mpmain(void)
+{
+80102d90:	55                   	push   %ebp
+80102d91:	89 e5                	mov    %esp,%ebp
+80102d93:	53                   	push   %ebx
+80102d94:	83 ec 14             	sub    $0x14,%esp
+  cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
+80102d97:	e8 f4 08 00 00       	call   80103690 <cpuid>
+80102d9c:	89 c3                	mov    %eax,%ebx
+80102d9e:	e8 ed 08 00 00       	call   80103690 <cpuid>
+80102da3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+80102da7:	c7 04 24 04 72 10 80 	movl   $0x80107204,(%esp)
+80102dae:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102db2:	e8 99 d8 ff ff       	call   80100650 <cprintf>
+  idtinit();       // load idt register
+80102db7:	e8 54 27 00 00       	call   80105510 <idtinit>
+  xchg(&(mycpu()->started), 1); // tell startothers() we're up
+80102dbc:	e8 4f 08 00 00       	call   80103610 <mycpu>
+80102dc1:	89 c2                	mov    %eax,%edx
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+80102dc3:	b8 01 00 00 00       	mov    $0x1,%eax
+80102dc8:	f0 87 82 a0 00 00 00 	lock xchg %eax,0xa0(%edx)
+  scheduler();     // start running processes
+80102dcf:	e8 9c 0b 00 00       	call   80103970 <scheduler>
+80102dd4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80102dda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+80102de0 <mpenter>:
+{
+80102de0:	55                   	push   %ebp
+80102de1:	89 e5                	mov    %esp,%ebp
+80102de3:	83 ec 08             	sub    $0x8,%esp
+  switchkvm();
+80102de6:	e8 e5 37 00 00       	call   801065d0 <switchkvm>
+  seginit();
+80102deb:	e8 a0 36 00 00       	call   80106490 <seginit>
+  lapicinit();
+80102df0:	e8 8b f8 ff ff       	call   80102680 <lapicinit>
+  mpmain();
+80102df5:	e8 96 ff ff ff       	call   80102d90 <mpmain>
+80102dfa:	66 90                	xchg   %ax,%ax
+80102dfc:	66 90                	xchg   %ax,%ax
+80102dfe:	66 90                	xchg   %ax,%ax
+
+80102e00 <main>:
+{
+80102e00:	55                   	push   %ebp
+80102e01:	89 e5                	mov    %esp,%ebp
+80102e03:	53                   	push   %ebx
+  // The linker has placed the image of entryother.S in
+  // _binary_entryother_start.
+  code = P2V(0x7000);
+  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+
+  for(c = cpus; c < cpus+ncpu; c++){
+80102e04:	bb 80 27 11 80       	mov    $0x80112780,%ebx
+{
+80102e09:	83 e4 f0             	and    $0xfffffff0,%esp
+80102e0c:	83 ec 10             	sub    $0x10,%esp
+  kinit1(end, P2V(4*1024*1024)); // phys page allocator
+80102e0f:	c7 44 24 04 00 00 40 	movl   $0x80400000,0x4(%esp)
+80102e16:	80 
+80102e17:	c7 04 24 f4 57 11 80 	movl   $0x801157f4,(%esp)
+80102e1e:	e8 cd f5 ff ff       	call   801023f0 <kinit1>
+  kvmalloc();      // kernel page table
+80102e23:	e8 58 3c 00 00       	call   80106a80 <kvmalloc>
+  mpinit();        // detect other processors
+80102e28:	e8 73 01 00 00       	call   80102fa0 <mpinit>
+80102e2d:	8d 76 00             	lea    0x0(%esi),%esi
+  lapicinit();     // interrupt controller
+80102e30:	e8 4b f8 ff ff       	call   80102680 <lapicinit>
+  seginit();       // segment descriptors
+80102e35:	e8 56 36 00 00       	call   80106490 <seginit>
+  picinit();       // disable pic
+80102e3a:	e8 21 03 00 00       	call   80103160 <picinit>
+80102e3f:	90                   	nop
+  ioapicinit();    // another interrupt controller
+80102e40:	e8 cb f3 ff ff       	call   80102210 <ioapicinit>
+  consoleinit();   // console hardware
+80102e45:	e8 06 db ff ff       	call   80100950 <consoleinit>
+  uartinit();      // serial port
+80102e4a:	e8 e1 29 00 00       	call   80105830 <uartinit>
+80102e4f:	90                   	nop
+  pinit();         // process table
+80102e50:	e8 9b 07 00 00       	call   801035f0 <pinit>
+  shminit();       // shared memory
+80102e55:	e8 36 3e 00 00       	call   80106c90 <shminit>
+  tvinit();        // trap vectors
+80102e5a:	e8 11 26 00 00       	call   80105470 <tvinit>
+80102e5f:	90                   	nop
+  binit();         // buffer cache
+80102e60:	e8 db d1 ff ff       	call   80100040 <binit>
+  fileinit();      // file table
+80102e65:	e8 e6 de ff ff       	call   80100d50 <fileinit>
+  ideinit();       // disk 
+80102e6a:	e8 a1 f1 ff ff       	call   80102010 <ideinit>
+  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+80102e6f:	c7 44 24 08 8a 00 00 	movl   $0x8a,0x8(%esp)
+80102e76:	00 
+80102e77:	c7 44 24 04 8c a4 10 	movl   $0x8010a48c,0x4(%esp)
+80102e7e:	80 
+80102e7f:	c7 04 24 00 70 00 80 	movl   $0x80007000,(%esp)
+80102e86:	e8 a5 14 00 00       	call   80104330 <memmove>
+  for(c = cpus; c < cpus+ncpu; c++){
+80102e8b:	69 05 00 2d 11 80 b0 	imul   $0xb0,0x80112d00,%eax
+80102e92:	00 00 00 
+80102e95:	05 80 27 11 80       	add    $0x80112780,%eax
+80102e9a:	39 d8                	cmp    %ebx,%eax
+80102e9c:	76 65                	jbe    80102f03 <main+0x103>
+80102e9e:	66 90                	xchg   %ax,%ax
+    if(c == mycpu())  // We've started already.
+80102ea0:	e8 6b 07 00 00       	call   80103610 <mycpu>
+80102ea5:	39 d8                	cmp    %ebx,%eax
+80102ea7:	74 41                	je     80102eea <main+0xea>
+      continue;
+
+    // Tell entryother.S what stack to use, where to enter, and what
+    // pgdir to use. We cannot use kpgdir yet, because the AP processor
+    // is running in low  memory, so we use entrypgdir for the APs too.
+    stack = kalloc();
+80102ea9:	e8 02 f6 ff ff       	call   801024b0 <kalloc>
+    *(void**)(code-4) = stack + KSTACKSIZE;
+    *(void**)(code-8) = mpenter;
+80102eae:	c7 05 f8 6f 00 80 e0 	movl   $0x80102de0,0x80006ff8
+80102eb5:	2d 10 80 
+    *(int**)(code-12) = (void *) V2P(entrypgdir);
+80102eb8:	c7 05 f4 6f 00 80 00 	movl   $0x109000,0x80006ff4
+80102ebf:	90 10 00 
+    *(void**)(code-4) = stack + KSTACKSIZE;
+80102ec2:	05 00 10 00 00       	add    $0x1000,%eax
+80102ec7:	a3 fc 6f 00 80       	mov    %eax,0x80006ffc
+
+    lapicstartap(c->apicid, V2P(code));
+80102ecc:	0f b6 03             	movzbl (%ebx),%eax
+80102ecf:	c7 44 24 04 00 70 00 	movl   $0x7000,0x4(%esp)
+80102ed6:	00 
+80102ed7:	89 04 24             	mov    %eax,(%esp)
+80102eda:	e8 e1 f8 ff ff       	call   801027c0 <lapicstartap>
+80102edf:	90                   	nop
+
+    // wait for cpu to finish mpmain()
+    while(c->started == 0)
+80102ee0:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
+80102ee6:	85 c0                	test   %eax,%eax
+80102ee8:	74 f6                	je     80102ee0 <main+0xe0>
+  for(c = cpus; c < cpus+ncpu; c++){
+80102eea:	69 05 00 2d 11 80 b0 	imul   $0xb0,0x80112d00,%eax
+80102ef1:	00 00 00 
+80102ef4:	81 c3 b0 00 00 00    	add    $0xb0,%ebx
+80102efa:	05 80 27 11 80       	add    $0x80112780,%eax
+80102eff:	39 c3                	cmp    %eax,%ebx
+80102f01:	72 9d                	jb     80102ea0 <main+0xa0>
+  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+80102f03:	c7 44 24 04 00 00 00 	movl   $0x8e000000,0x4(%esp)
+80102f0a:	8e 
+80102f0b:	c7 04 24 00 00 40 80 	movl   $0x80400000,(%esp)
+80102f12:	e8 49 f5 ff ff       	call   80102460 <kinit2>
+  userinit();      // first user process
+80102f17:	e8 c4 07 00 00       	call   801036e0 <userinit>
+  mpmain();        // finish this processor's setup
+80102f1c:	e8 6f fe ff ff       	call   80102d90 <mpmain>
+80102f21:	66 90                	xchg   %ax,%ax
+80102f23:	66 90                	xchg   %ax,%ax
+80102f25:	66 90                	xchg   %ax,%ax
+80102f27:	66 90                	xchg   %ax,%ax
+80102f29:	66 90                	xchg   %ax,%ax
+80102f2b:	66 90                	xchg   %ax,%ax
+80102f2d:	66 90                	xchg   %ax,%ax
+80102f2f:	90                   	nop
+
+80102f30 <mpsearch1>:
+}
+
+// Look for an MP structure in the len bytes at addr.
+static struct mp*
+mpsearch1(uint a, int len)
+{
+80102f30:	55                   	push   %ebp
+80102f31:	89 e5                	mov    %esp,%ebp
+80102f33:	56                   	push   %esi
+  uchar *e, *p, *addr;
+
+  addr = P2V(a);
+80102f34:	8d b0 00 00 00 80    	lea    -0x80000000(%eax),%esi
+{
+80102f3a:	53                   	push   %ebx
+  e = addr+len;
+80102f3b:	8d 1c 16             	lea    (%esi,%edx,1),%ebx
+{
+80102f3e:	83 ec 10             	sub    $0x10,%esp
+  for(p = addr; p < e; p += sizeof(struct mp))
+80102f41:	39 de                	cmp    %ebx,%esi
+80102f43:	73 3c                	jae    80102f81 <mpsearch1+0x51>
+80102f45:	8d 76 00             	lea    0x0(%esi),%esi
+    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+80102f48:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
+80102f4f:	00 
+80102f50:	c7 44 24 04 18 72 10 	movl   $0x80107218,0x4(%esp)
+80102f57:	80 
+80102f58:	89 34 24             	mov    %esi,(%esp)
+80102f5b:	e8 80 13 00 00       	call   801042e0 <memcmp>
+80102f60:	85 c0                	test   %eax,%eax
+80102f62:	75 16                	jne    80102f7a <mpsearch1+0x4a>
+80102f64:	31 c9                	xor    %ecx,%ecx
+80102f66:	31 d2                	xor    %edx,%edx
+    sum += addr[i];
+80102f68:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
+  for(i=0; i<len; i++)
+80102f6c:	83 c2 01             	add    $0x1,%edx
+    sum += addr[i];
+80102f6f:	01 c1                	add    %eax,%ecx
+  for(i=0; i<len; i++)
+80102f71:	83 fa 10             	cmp    $0x10,%edx
+80102f74:	75 f2                	jne    80102f68 <mpsearch1+0x38>
+    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+80102f76:	84 c9                	test   %cl,%cl
+80102f78:	74 10                	je     80102f8a <mpsearch1+0x5a>
+  for(p = addr; p < e; p += sizeof(struct mp))
+80102f7a:	83 c6 10             	add    $0x10,%esi
+80102f7d:	39 f3                	cmp    %esi,%ebx
+80102f7f:	77 c7                	ja     80102f48 <mpsearch1+0x18>
+      return (struct mp*)p;
+  return 0;
+}
+80102f81:	83 c4 10             	add    $0x10,%esp
+  return 0;
+80102f84:	31 c0                	xor    %eax,%eax
+}
+80102f86:	5b                   	pop    %ebx
+80102f87:	5e                   	pop    %esi
+80102f88:	5d                   	pop    %ebp
+80102f89:	c3                   	ret    
+80102f8a:	83 c4 10             	add    $0x10,%esp
+80102f8d:	89 f0                	mov    %esi,%eax
+80102f8f:	5b                   	pop    %ebx
+80102f90:	5e                   	pop    %esi
+80102f91:	5d                   	pop    %ebp
+80102f92:	c3                   	ret    
+80102f93:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80102f99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80102fa0 <mpinit>:
+  return conf;
+}
+
+void
+mpinit(void)
+{
+80102fa0:	55                   	push   %ebp
+80102fa1:	89 e5                	mov    %esp,%ebp
+80102fa3:	57                   	push   %edi
+80102fa4:	56                   	push   %esi
+80102fa5:	53                   	push   %ebx
+80102fa6:	83 ec 1c             	sub    $0x1c,%esp
+  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
+80102fa9:	0f b6 05 0f 04 00 80 	movzbl 0x8000040f,%eax
+80102fb0:	0f b6 15 0e 04 00 80 	movzbl 0x8000040e,%edx
+80102fb7:	c1 e0 08             	shl    $0x8,%eax
+80102fba:	09 d0                	or     %edx,%eax
+80102fbc:	c1 e0 04             	shl    $0x4,%eax
+80102fbf:	85 c0                	test   %eax,%eax
+80102fc1:	75 1b                	jne    80102fde <mpinit+0x3e>
+    p = ((bda[0x14]<<8)|bda[0x13])*1024;
+80102fc3:	0f b6 05 14 04 00 80 	movzbl 0x80000414,%eax
+80102fca:	0f b6 15 13 04 00 80 	movzbl 0x80000413,%edx
+80102fd1:	c1 e0 08             	shl    $0x8,%eax
+80102fd4:	09 d0                	or     %edx,%eax
+80102fd6:	c1 e0 0a             	shl    $0xa,%eax
+    if((mp = mpsearch1(p-1024, 1024)))
+80102fd9:	2d 00 04 00 00       	sub    $0x400,%eax
+    if((mp = mpsearch1(p, 1024)))
+80102fde:	ba 00 04 00 00       	mov    $0x400,%edx
+80102fe3:	e8 48 ff ff ff       	call   80102f30 <mpsearch1>
+80102fe8:	85 c0                	test   %eax,%eax
+80102fea:	89 c7                	mov    %eax,%edi
+80102fec:	0f 84 22 01 00 00    	je     80103114 <mpinit+0x174>
+  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+80102ff2:	8b 77 04             	mov    0x4(%edi),%esi
+80102ff5:	85 f6                	test   %esi,%esi
+80102ff7:	0f 84 30 01 00 00    	je     8010312d <mpinit+0x18d>
+  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+80102ffd:	8d 86 00 00 00 80    	lea    -0x80000000(%esi),%eax
+  if(memcmp(conf, "PCMP", 4) != 0)
+80103003:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
+8010300a:	00 
+8010300b:	c7 44 24 04 1d 72 10 	movl   $0x8010721d,0x4(%esp)
+80103012:	80 
+80103013:	89 04 24             	mov    %eax,(%esp)
+  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+80103016:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(memcmp(conf, "PCMP", 4) != 0)
+80103019:	e8 c2 12 00 00       	call   801042e0 <memcmp>
+8010301e:	85 c0                	test   %eax,%eax
+80103020:	0f 85 07 01 00 00    	jne    8010312d <mpinit+0x18d>
+  if(conf->version != 1 && conf->version != 4)
+80103026:	0f b6 86 06 00 00 80 	movzbl -0x7ffffffa(%esi),%eax
+8010302d:	3c 04                	cmp    $0x4,%al
+8010302f:	0f 85 0b 01 00 00    	jne    80103140 <mpinit+0x1a0>
+  if(sum((uchar*)conf, conf->length) != 0)
+80103035:	0f b7 86 04 00 00 80 	movzwl -0x7ffffffc(%esi),%eax
+  for(i=0; i<len; i++)
+8010303c:	85 c0                	test   %eax,%eax
+8010303e:	74 21                	je     80103061 <mpinit+0xc1>
+  sum = 0;
+80103040:	31 c9                	xor    %ecx,%ecx
+  for(i=0; i<len; i++)
+80103042:	31 d2                	xor    %edx,%edx
+80103044:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    sum += addr[i];
+80103048:	0f b6 9c 16 00 00 00 	movzbl -0x80000000(%esi,%edx,1),%ebx
+8010304f:	80 
+  for(i=0; i<len; i++)
+80103050:	83 c2 01             	add    $0x1,%edx
+    sum += addr[i];
+80103053:	01 d9                	add    %ebx,%ecx
+  for(i=0; i<len; i++)
+80103055:	39 d0                	cmp    %edx,%eax
+80103057:	7f ef                	jg     80103048 <mpinit+0xa8>
+  if(sum((uchar*)conf, conf->length) != 0)
+80103059:	84 c9                	test   %cl,%cl
+8010305b:	0f 85 cc 00 00 00    	jne    8010312d <mpinit+0x18d>
+  struct mp *mp;
+  struct mpconf *conf;
+  struct mpproc *proc;
+  struct mpioapic *ioapic;
+
+  if((conf = mpconfig(&mp)) == 0)
+80103061:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80103064:	85 c0                	test   %eax,%eax
+80103066:	0f 84 c1 00 00 00    	je     8010312d <mpinit+0x18d>
+    panic("Expect to run on an SMP");
+  ismp = 1;
+  lapic = (uint*)conf->lapicaddr;
+8010306c:	8b 86 24 00 00 80    	mov    -0x7fffffdc(%esi),%eax
+  ismp = 1;
+80103072:	bb 01 00 00 00       	mov    $0x1,%ebx
+  lapic = (uint*)conf->lapicaddr;
+80103077:	a3 7c 26 11 80       	mov    %eax,0x8011267c
+  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+8010307c:	0f b7 96 04 00 00 80 	movzwl -0x7ffffffc(%esi),%edx
+80103083:	8d 86 2c 00 00 80    	lea    -0x7fffffd4(%esi),%eax
+80103089:	03 55 e4             	add    -0x1c(%ebp),%edx
+8010308c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80103090:	39 c2                	cmp    %eax,%edx
+80103092:	76 1b                	jbe    801030af <mpinit+0x10f>
+80103094:	0f b6 08             	movzbl (%eax),%ecx
+    switch(*p){
+80103097:	80 f9 04             	cmp    $0x4,%cl
+8010309a:	77 74                	ja     80103110 <mpinit+0x170>
+8010309c:	ff 24 8d 5c 72 10 80 	jmp    *-0x7fef8da4(,%ecx,4)
+801030a3:	90                   	nop
+801030a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      p += sizeof(struct mpioapic);
+      continue;
+    case MPBUS:
+    case MPIOINTR:
+    case MPLINTR:
+      p += 8;
+801030a8:	83 c0 08             	add    $0x8,%eax
+  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+801030ab:	39 c2                	cmp    %eax,%edx
+801030ad:	77 e5                	ja     80103094 <mpinit+0xf4>
+    default:
+      ismp = 0;
+      break;
+    }
+  }
+  if(!ismp)
+801030af:	85 db                	test   %ebx,%ebx
+801030b1:	0f 84 93 00 00 00    	je     8010314a <mpinit+0x1aa>
+    panic("Didn't find a suitable machine");
+
+  if(mp->imcrp){
+801030b7:	80 7f 0c 00          	cmpb   $0x0,0xc(%edi)
+801030bb:	74 12                	je     801030cf <mpinit+0x12f>
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801030bd:	ba 22 00 00 00       	mov    $0x22,%edx
+801030c2:	b8 70 00 00 00       	mov    $0x70,%eax
+801030c7:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801030c8:	b2 23                	mov    $0x23,%dl
+801030ca:	ec                   	in     (%dx),%al
+    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
+    // But it would on real hardware.
+    outb(0x22, 0x70);   // Select IMCR
+    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
+801030cb:	83 c8 01             	or     $0x1,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801030ce:	ee                   	out    %al,(%dx)
+  }
+}
+801030cf:	83 c4 1c             	add    $0x1c,%esp
+801030d2:	5b                   	pop    %ebx
+801030d3:	5e                   	pop    %esi
+801030d4:	5f                   	pop    %edi
+801030d5:	5d                   	pop    %ebp
+801030d6:	c3                   	ret    
+801030d7:	90                   	nop
+      if(ncpu < NCPU) {
+801030d8:	8b 35 00 2d 11 80    	mov    0x80112d00,%esi
+801030de:	83 fe 07             	cmp    $0x7,%esi
+801030e1:	7f 17                	jg     801030fa <mpinit+0x15a>
+        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+801030e3:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
+801030e7:	69 f6 b0 00 00 00    	imul   $0xb0,%esi,%esi
+        ncpu++;
+801030ed:	83 05 00 2d 11 80 01 	addl   $0x1,0x80112d00
+        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+801030f4:	88 8e 80 27 11 80    	mov    %cl,-0x7feed880(%esi)
+      p += sizeof(struct mpproc);
+801030fa:	83 c0 14             	add    $0x14,%eax
+      continue;
+801030fd:	eb 91                	jmp    80103090 <mpinit+0xf0>
+801030ff:	90                   	nop
+      ioapicid = ioapic->apicno;
+80103100:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
+      p += sizeof(struct mpioapic);
+80103104:	83 c0 08             	add    $0x8,%eax
+      ioapicid = ioapic->apicno;
+80103107:	88 0d 60 27 11 80    	mov    %cl,0x80112760
+      continue;
+8010310d:	eb 81                	jmp    80103090 <mpinit+0xf0>
+8010310f:	90                   	nop
+      ismp = 0;
+80103110:	31 db                	xor    %ebx,%ebx
+80103112:	eb 83                	jmp    80103097 <mpinit+0xf7>
+  return mpsearch1(0xF0000, 0x10000);
+80103114:	ba 00 00 01 00       	mov    $0x10000,%edx
+80103119:	b8 00 00 0f 00       	mov    $0xf0000,%eax
+8010311e:	e8 0d fe ff ff       	call   80102f30 <mpsearch1>
+  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+80103123:	85 c0                	test   %eax,%eax
+  return mpsearch1(0xF0000, 0x10000);
+80103125:	89 c7                	mov    %eax,%edi
+  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+80103127:	0f 85 c5 fe ff ff    	jne    80102ff2 <mpinit+0x52>
+    panic("Expect to run on an SMP");
+8010312d:	c7 04 24 22 72 10 80 	movl   $0x80107222,(%esp)
+80103134:	e8 27 d2 ff ff       	call   80100360 <panic>
+80103139:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  if(conf->version != 1 && conf->version != 4)
+80103140:	3c 01                	cmp    $0x1,%al
+80103142:	0f 84 ed fe ff ff    	je     80103035 <mpinit+0x95>
+80103148:	eb e3                	jmp    8010312d <mpinit+0x18d>
+    panic("Didn't find a suitable machine");
+8010314a:	c7 04 24 3c 72 10 80 	movl   $0x8010723c,(%esp)
+80103151:	e8 0a d2 ff ff       	call   80100360 <panic>
+80103156:	66 90                	xchg   %ax,%ax
+80103158:	66 90                	xchg   %ax,%ax
+8010315a:	66 90                	xchg   %ax,%ax
+8010315c:	66 90                	xchg   %ax,%ax
+8010315e:	66 90                	xchg   %ax,%ax
+
+80103160 <picinit>:
+#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
+
+// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
+void
+picinit(void)
+{
+80103160:	55                   	push   %ebp
+80103161:	ba 21 00 00 00       	mov    $0x21,%edx
+80103166:	89 e5                	mov    %esp,%ebp
+80103168:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010316d:	ee                   	out    %al,(%dx)
+8010316e:	b2 a1                	mov    $0xa1,%dl
+80103170:	ee                   	out    %al,(%dx)
+  // mask all interrupts
+  outb(IO_PIC1+1, 0xFF);
+  outb(IO_PIC2+1, 0xFF);
+}
+80103171:	5d                   	pop    %ebp
+80103172:	c3                   	ret    
+80103173:	66 90                	xchg   %ax,%ax
+80103175:	66 90                	xchg   %ax,%ax
+80103177:	66 90                	xchg   %ax,%ax
+80103179:	66 90                	xchg   %ax,%ax
+8010317b:	66 90                	xchg   %ax,%ax
+8010317d:	66 90                	xchg   %ax,%ax
+8010317f:	90                   	nop
+
+80103180 <pipealloc>:
+  int writeopen;  // write fd is still open
+};
+
+int
+pipealloc(struct file **f0, struct file **f1)
+{
+80103180:	55                   	push   %ebp
+80103181:	89 e5                	mov    %esp,%ebp
+80103183:	57                   	push   %edi
+80103184:	56                   	push   %esi
+80103185:	53                   	push   %ebx
+80103186:	83 ec 1c             	sub    $0x1c,%esp
+80103189:	8b 75 08             	mov    0x8(%ebp),%esi
+8010318c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  struct pipe *p;
+
+  p = 0;
+  *f0 = *f1 = 0;
+8010318f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+80103195:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
+  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
+8010319b:	e8 d0 db ff ff       	call   80100d70 <filealloc>
+801031a0:	85 c0                	test   %eax,%eax
+801031a2:	89 06                	mov    %eax,(%esi)
+801031a4:	0f 84 a4 00 00 00    	je     8010324e <pipealloc+0xce>
+801031aa:	e8 c1 db ff ff       	call   80100d70 <filealloc>
+801031af:	85 c0                	test   %eax,%eax
+801031b1:	89 03                	mov    %eax,(%ebx)
+801031b3:	0f 84 87 00 00 00    	je     80103240 <pipealloc+0xc0>
+    goto bad;
+  if((p = (struct pipe*)kalloc()) == 0)
+801031b9:	e8 f2 f2 ff ff       	call   801024b0 <kalloc>
+801031be:	85 c0                	test   %eax,%eax
+801031c0:	89 c7                	mov    %eax,%edi
+801031c2:	74 7c                	je     80103240 <pipealloc+0xc0>
+    goto bad;
+  p->readopen = 1;
+801031c4:	c7 80 3c 02 00 00 01 	movl   $0x1,0x23c(%eax)
+801031cb:	00 00 00 
+  p->writeopen = 1;
+801031ce:	c7 80 40 02 00 00 01 	movl   $0x1,0x240(%eax)
+801031d5:	00 00 00 
+  p->nwrite = 0;
+801031d8:	c7 80 38 02 00 00 00 	movl   $0x0,0x238(%eax)
+801031df:	00 00 00 
+  p->nread = 0;
+801031e2:	c7 80 34 02 00 00 00 	movl   $0x0,0x234(%eax)
+801031e9:	00 00 00 
+  initlock(&p->lock, "pipe");
+801031ec:	89 04 24             	mov    %eax,(%esp)
+801031ef:	c7 44 24 04 70 72 10 	movl   $0x80107270,0x4(%esp)
+801031f6:	80 
+801031f7:	e8 64 0e 00 00       	call   80104060 <initlock>
+  (*f0)->type = FD_PIPE;
+801031fc:	8b 06                	mov    (%esi),%eax
+801031fe:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+  (*f0)->readable = 1;
+80103204:	8b 06                	mov    (%esi),%eax
+80103206:	c6 40 08 01          	movb   $0x1,0x8(%eax)
+  (*f0)->writable = 0;
+8010320a:	8b 06                	mov    (%esi),%eax
+8010320c:	c6 40 09 00          	movb   $0x0,0x9(%eax)
+  (*f0)->pipe = p;
+80103210:	8b 06                	mov    (%esi),%eax
+80103212:	89 78 0c             	mov    %edi,0xc(%eax)
+  (*f1)->type = FD_PIPE;
+80103215:	8b 03                	mov    (%ebx),%eax
+80103217:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+  (*f1)->readable = 0;
+8010321d:	8b 03                	mov    (%ebx),%eax
+8010321f:	c6 40 08 00          	movb   $0x0,0x8(%eax)
+  (*f1)->writable = 1;
+80103223:	8b 03                	mov    (%ebx),%eax
+80103225:	c6 40 09 01          	movb   $0x1,0x9(%eax)
+  (*f1)->pipe = p;
+80103229:	8b 03                	mov    (%ebx),%eax
+  return 0;
+8010322b:	31 db                	xor    %ebx,%ebx
+  (*f1)->pipe = p;
+8010322d:	89 78 0c             	mov    %edi,0xc(%eax)
+  if(*f0)
+    fileclose(*f0);
+  if(*f1)
+    fileclose(*f1);
+  return -1;
+}
+80103230:	83 c4 1c             	add    $0x1c,%esp
+80103233:	89 d8                	mov    %ebx,%eax
+80103235:	5b                   	pop    %ebx
+80103236:	5e                   	pop    %esi
+80103237:	5f                   	pop    %edi
+80103238:	5d                   	pop    %ebp
+80103239:	c3                   	ret    
+8010323a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  if(*f0)
+80103240:	8b 06                	mov    (%esi),%eax
+80103242:	85 c0                	test   %eax,%eax
+80103244:	74 08                	je     8010324e <pipealloc+0xce>
+    fileclose(*f0);
+80103246:	89 04 24             	mov    %eax,(%esp)
+80103249:	e8 e2 db ff ff       	call   80100e30 <fileclose>
+  if(*f1)
+8010324e:	8b 03                	mov    (%ebx),%eax
+  return -1;
+80103250:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
+  if(*f1)
+80103255:	85 c0                	test   %eax,%eax
+80103257:	74 d7                	je     80103230 <pipealloc+0xb0>
+    fileclose(*f1);
+80103259:	89 04 24             	mov    %eax,(%esp)
+8010325c:	e8 cf db ff ff       	call   80100e30 <fileclose>
+}
+80103261:	83 c4 1c             	add    $0x1c,%esp
+80103264:	89 d8                	mov    %ebx,%eax
+80103266:	5b                   	pop    %ebx
+80103267:	5e                   	pop    %esi
+80103268:	5f                   	pop    %edi
+80103269:	5d                   	pop    %ebp
+8010326a:	c3                   	ret    
+8010326b:	90                   	nop
+8010326c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80103270 <pipeclose>:
+
+void
+pipeclose(struct pipe *p, int writable)
+{
+80103270:	55                   	push   %ebp
+80103271:	89 e5                	mov    %esp,%ebp
+80103273:	56                   	push   %esi
+80103274:	53                   	push   %ebx
+80103275:	83 ec 10             	sub    $0x10,%esp
+80103278:	8b 5d 08             	mov    0x8(%ebp),%ebx
+8010327b:	8b 75 0c             	mov    0xc(%ebp),%esi
+  acquire(&p->lock);
+8010327e:	89 1c 24             	mov    %ebx,(%esp)
+80103281:	e8 ca 0e 00 00       	call   80104150 <acquire>
+  if(writable){
+80103286:	85 f6                	test   %esi,%esi
+80103288:	74 3e                	je     801032c8 <pipeclose+0x58>
+    p->writeopen = 0;
+    wakeup(&p->nread);
+8010328a:	8d 83 34 02 00 00    	lea    0x234(%ebx),%eax
+    p->writeopen = 0;
+80103290:	c7 83 40 02 00 00 00 	movl   $0x0,0x240(%ebx)
+80103297:	00 00 00 
+    wakeup(&p->nread);
+8010329a:	89 04 24             	mov    %eax,(%esp)
+8010329d:	e8 fe 0a 00 00       	call   80103da0 <wakeup>
+  } else {
+    p->readopen = 0;
+    wakeup(&p->nwrite);
+  }
+  if(p->readopen == 0 && p->writeopen == 0){
+801032a2:	8b 93 3c 02 00 00    	mov    0x23c(%ebx),%edx
+801032a8:	85 d2                	test   %edx,%edx
+801032aa:	75 0a                	jne    801032b6 <pipeclose+0x46>
+801032ac:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
+801032b2:	85 c0                	test   %eax,%eax
+801032b4:	74 32                	je     801032e8 <pipeclose+0x78>
+    release(&p->lock);
+    kfree((char*)p);
+  } else
+    release(&p->lock);
+801032b6:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+801032b9:	83 c4 10             	add    $0x10,%esp
+801032bc:	5b                   	pop    %ebx
+801032bd:	5e                   	pop    %esi
+801032be:	5d                   	pop    %ebp
+    release(&p->lock);
+801032bf:	e9 7c 0f 00 00       	jmp    80104240 <release>
+801032c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    wakeup(&p->nwrite);
+801032c8:	8d 83 38 02 00 00    	lea    0x238(%ebx),%eax
+    p->readopen = 0;
+801032ce:	c7 83 3c 02 00 00 00 	movl   $0x0,0x23c(%ebx)
+801032d5:	00 00 00 
+    wakeup(&p->nwrite);
+801032d8:	89 04 24             	mov    %eax,(%esp)
+801032db:	e8 c0 0a 00 00       	call   80103da0 <wakeup>
+801032e0:	eb c0                	jmp    801032a2 <pipeclose+0x32>
+801032e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    release(&p->lock);
+801032e8:	89 1c 24             	mov    %ebx,(%esp)
+801032eb:	e8 50 0f 00 00       	call   80104240 <release>
+    kfree((char*)p);
+801032f0:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+801032f3:	83 c4 10             	add    $0x10,%esp
+801032f6:	5b                   	pop    %ebx
+801032f7:	5e                   	pop    %esi
+801032f8:	5d                   	pop    %ebp
+    kfree((char*)p);
+801032f9:	e9 02 f0 ff ff       	jmp    80102300 <kfree>
+801032fe:	66 90                	xchg   %ax,%ax
+
+80103300 <pipewrite>:
+
+//PAGEBREAK: 40
+int
+pipewrite(struct pipe *p, char *addr, int n)
+{
+80103300:	55                   	push   %ebp
+80103301:	89 e5                	mov    %esp,%ebp
+80103303:	57                   	push   %edi
+80103304:	56                   	push   %esi
+80103305:	53                   	push   %ebx
+80103306:	83 ec 1c             	sub    $0x1c,%esp
+80103309:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  int i;
+
+  acquire(&p->lock);
+8010330c:	89 1c 24             	mov    %ebx,(%esp)
+8010330f:	e8 3c 0e 00 00       	call   80104150 <acquire>
+  for(i = 0; i < n; i++){
+80103314:	8b 4d 10             	mov    0x10(%ebp),%ecx
+80103317:	85 c9                	test   %ecx,%ecx
+80103319:	0f 8e b2 00 00 00    	jle    801033d1 <pipewrite+0xd1>
+8010331f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+      if(p->readopen == 0 || myproc()->killed){
+        release(&p->lock);
+        return -1;
+      }
+      wakeup(&p->nread);
+80103322:	8d bb 34 02 00 00    	lea    0x234(%ebx),%edi
+80103328:	8b 83 38 02 00 00    	mov    0x238(%ebx),%eax
+      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+8010332e:	8d b3 38 02 00 00    	lea    0x238(%ebx),%esi
+80103334:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+80103337:	03 4d 10             	add    0x10(%ebp),%ecx
+8010333a:	89 4d e0             	mov    %ecx,-0x20(%ebp)
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+8010333d:	8b 8b 34 02 00 00    	mov    0x234(%ebx),%ecx
+80103343:	81 c1 00 02 00 00    	add    $0x200,%ecx
+80103349:	39 c8                	cmp    %ecx,%eax
+8010334b:	74 38                	je     80103385 <pipewrite+0x85>
+8010334d:	eb 55                	jmp    801033a4 <pipewrite+0xa4>
+8010334f:	90                   	nop
+      if(p->readopen == 0 || myproc()->killed){
+80103350:	e8 5b 03 00 00       	call   801036b0 <myproc>
+80103355:	8b 40 24             	mov    0x24(%eax),%eax
+80103358:	85 c0                	test   %eax,%eax
+8010335a:	75 33                	jne    8010338f <pipewrite+0x8f>
+      wakeup(&p->nread);
+8010335c:	89 3c 24             	mov    %edi,(%esp)
+8010335f:	e8 3c 0a 00 00       	call   80103da0 <wakeup>
+      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+80103364:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80103368:	89 34 24             	mov    %esi,(%esp)
+8010336b:	e8 a0 08 00 00       	call   80103c10 <sleep>
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+80103370:	8b 83 34 02 00 00    	mov    0x234(%ebx),%eax
+80103376:	8b 93 38 02 00 00    	mov    0x238(%ebx),%edx
+8010337c:	05 00 02 00 00       	add    $0x200,%eax
+80103381:	39 c2                	cmp    %eax,%edx
+80103383:	75 23                	jne    801033a8 <pipewrite+0xa8>
+      if(p->readopen == 0 || myproc()->killed){
+80103385:	8b 93 3c 02 00 00    	mov    0x23c(%ebx),%edx
+8010338b:	85 d2                	test   %edx,%edx
+8010338d:	75 c1                	jne    80103350 <pipewrite+0x50>
+        release(&p->lock);
+8010338f:	89 1c 24             	mov    %ebx,(%esp)
+80103392:	e8 a9 0e 00 00       	call   80104240 <release>
+        return -1;
+80103397:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+  }
+  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+  release(&p->lock);
+  return n;
+}
+8010339c:	83 c4 1c             	add    $0x1c,%esp
+8010339f:	5b                   	pop    %ebx
+801033a0:	5e                   	pop    %esi
+801033a1:	5f                   	pop    %edi
+801033a2:	5d                   	pop    %ebp
+801033a3:	c3                   	ret    
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+801033a4:	89 c2                	mov    %eax,%edx
+801033a6:	66 90                	xchg   %ax,%ax
+    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+801033a8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+801033ab:	8d 42 01             	lea    0x1(%edx),%eax
+801033ae:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
+801033b4:	89 83 38 02 00 00    	mov    %eax,0x238(%ebx)
+801033ba:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
+801033be:	0f b6 09             	movzbl (%ecx),%ecx
+801033c1:	88 4c 13 34          	mov    %cl,0x34(%ebx,%edx,1)
+  for(i = 0; i < n; i++){
+801033c5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+801033c8:	3b 4d e0             	cmp    -0x20(%ebp),%ecx
+801033cb:	0f 85 6c ff ff ff    	jne    8010333d <pipewrite+0x3d>
+  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+801033d1:	8d 83 34 02 00 00    	lea    0x234(%ebx),%eax
+801033d7:	89 04 24             	mov    %eax,(%esp)
+801033da:	e8 c1 09 00 00       	call   80103da0 <wakeup>
+  release(&p->lock);
+801033df:	89 1c 24             	mov    %ebx,(%esp)
+801033e2:	e8 59 0e 00 00       	call   80104240 <release>
+  return n;
+801033e7:	8b 45 10             	mov    0x10(%ebp),%eax
+801033ea:	eb b0                	jmp    8010339c <pipewrite+0x9c>
+801033ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+801033f0 <piperead>:
+
+int
+piperead(struct pipe *p, char *addr, int n)
+{
+801033f0:	55                   	push   %ebp
+801033f1:	89 e5                	mov    %esp,%ebp
+801033f3:	57                   	push   %edi
+801033f4:	56                   	push   %esi
+801033f5:	53                   	push   %ebx
+801033f6:	83 ec 1c             	sub    $0x1c,%esp
+801033f9:	8b 75 08             	mov    0x8(%ebp),%esi
+801033fc:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  int i;
+
+  acquire(&p->lock);
+801033ff:	89 34 24             	mov    %esi,(%esp)
+80103402:	e8 49 0d 00 00       	call   80104150 <acquire>
+  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+80103407:	8b 86 34 02 00 00    	mov    0x234(%esi),%eax
+8010340d:	3b 86 38 02 00 00    	cmp    0x238(%esi),%eax
+80103413:	75 5b                	jne    80103470 <piperead+0x80>
+80103415:	8b 9e 40 02 00 00    	mov    0x240(%esi),%ebx
+8010341b:	85 db                	test   %ebx,%ebx
+8010341d:	74 51                	je     80103470 <piperead+0x80>
+    if(myproc()->killed){
+      release(&p->lock);
+      return -1;
+    }
+    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+8010341f:	8d 9e 34 02 00 00    	lea    0x234(%esi),%ebx
+80103425:	eb 25                	jmp    8010344c <piperead+0x5c>
+80103427:	90                   	nop
+80103428:	89 74 24 04          	mov    %esi,0x4(%esp)
+8010342c:	89 1c 24             	mov    %ebx,(%esp)
+8010342f:	e8 dc 07 00 00       	call   80103c10 <sleep>
+  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+80103434:	8b 86 34 02 00 00    	mov    0x234(%esi),%eax
+8010343a:	3b 86 38 02 00 00    	cmp    0x238(%esi),%eax
+80103440:	75 2e                	jne    80103470 <piperead+0x80>
+80103442:	8b 96 40 02 00 00    	mov    0x240(%esi),%edx
+80103448:	85 d2                	test   %edx,%edx
+8010344a:	74 24                	je     80103470 <piperead+0x80>
+    if(myproc()->killed){
+8010344c:	e8 5f 02 00 00       	call   801036b0 <myproc>
+80103451:	8b 48 24             	mov    0x24(%eax),%ecx
+80103454:	85 c9                	test   %ecx,%ecx
+80103456:	74 d0                	je     80103428 <piperead+0x38>
+      release(&p->lock);
+80103458:	89 34 24             	mov    %esi,(%esp)
+8010345b:	e8 e0 0d 00 00       	call   80104240 <release>
+    addr[i] = p->data[p->nread++ % PIPESIZE];
+  }
+  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+  release(&p->lock);
+  return i;
+}
+80103460:	83 c4 1c             	add    $0x1c,%esp
+      return -1;
+80103463:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80103468:	5b                   	pop    %ebx
+80103469:	5e                   	pop    %esi
+8010346a:	5f                   	pop    %edi
+8010346b:	5d                   	pop    %ebp
+8010346c:	c3                   	ret    
+8010346d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+80103470:	8b 55 10             	mov    0x10(%ebp),%edx
+    if(p->nread == p->nwrite)
+80103473:	31 db                	xor    %ebx,%ebx
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+80103475:	85 d2                	test   %edx,%edx
+80103477:	7f 2b                	jg     801034a4 <piperead+0xb4>
+80103479:	eb 31                	jmp    801034ac <piperead+0xbc>
+8010347b:	90                   	nop
+8010347c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    addr[i] = p->data[p->nread++ % PIPESIZE];
+80103480:	8d 48 01             	lea    0x1(%eax),%ecx
+80103483:	25 ff 01 00 00       	and    $0x1ff,%eax
+80103488:	89 8e 34 02 00 00    	mov    %ecx,0x234(%esi)
+8010348e:	0f b6 44 06 34       	movzbl 0x34(%esi,%eax,1),%eax
+80103493:	88 04 1f             	mov    %al,(%edi,%ebx,1)
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+80103496:	83 c3 01             	add    $0x1,%ebx
+80103499:	3b 5d 10             	cmp    0x10(%ebp),%ebx
+8010349c:	74 0e                	je     801034ac <piperead+0xbc>
+    if(p->nread == p->nwrite)
+8010349e:	8b 86 34 02 00 00    	mov    0x234(%esi),%eax
+801034a4:	3b 86 38 02 00 00    	cmp    0x238(%esi),%eax
+801034aa:	75 d4                	jne    80103480 <piperead+0x90>
+  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+801034ac:	8d 86 38 02 00 00    	lea    0x238(%esi),%eax
+801034b2:	89 04 24             	mov    %eax,(%esp)
+801034b5:	e8 e6 08 00 00       	call   80103da0 <wakeup>
+  release(&p->lock);
+801034ba:	89 34 24             	mov    %esi,(%esp)
+801034bd:	e8 7e 0d 00 00       	call   80104240 <release>
+}
+801034c2:	83 c4 1c             	add    $0x1c,%esp
+  return i;
+801034c5:	89 d8                	mov    %ebx,%eax
+}
+801034c7:	5b                   	pop    %ebx
+801034c8:	5e                   	pop    %esi
+801034c9:	5f                   	pop    %edi
+801034ca:	5d                   	pop    %ebp
+801034cb:	c3                   	ret    
+801034cc:	66 90                	xchg   %ax,%ax
+801034ce:	66 90                	xchg   %ax,%ax
+
+801034d0 <allocproc>:
+// If found, change state to EMBRYO and initialize
+// state required to run in the kernel.
+// Otherwise return 0.
+static struct proc*
+allocproc(void)
+{
+801034d0:	55                   	push   %ebp
+801034d1:	89 e5                	mov    %esp,%ebp
+801034d3:	53                   	push   %ebx
+  struct proc *p;
+  char *sp;
+
+  acquire(&ptable.lock);
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+801034d4:	bb 54 2d 11 80       	mov    $0x80112d54,%ebx
+{
+801034d9:	83 ec 14             	sub    $0x14,%esp
+  acquire(&ptable.lock);
+801034dc:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+801034e3:	e8 68 0c 00 00       	call   80104150 <acquire>
+801034e8:	eb 11                	jmp    801034fb <allocproc+0x2b>
+801034ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+801034f0:	83 c3 7c             	add    $0x7c,%ebx
+801034f3:	81 fb 54 4c 11 80    	cmp    $0x80114c54,%ebx
+801034f9:	74 7d                	je     80103578 <allocproc+0xa8>
+    if(p->state == UNUSED)
+801034fb:	8b 43 0c             	mov    0xc(%ebx),%eax
+801034fe:	85 c0                	test   %eax,%eax
+80103500:	75 ee                	jne    801034f0 <allocproc+0x20>
+  release(&ptable.lock);
+  return 0;
+
+found:
+  p->state = EMBRYO;
+  p->pid = nextpid++;
+80103502:	a1 04 a0 10 80       	mov    0x8010a004,%eax
+
+  release(&ptable.lock);
+80103507:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+  p->state = EMBRYO;
+8010350e:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
+  p->pid = nextpid++;
+80103515:	8d 50 01             	lea    0x1(%eax),%edx
+80103518:	89 15 04 a0 10 80    	mov    %edx,0x8010a004
+8010351e:	89 43 10             	mov    %eax,0x10(%ebx)
+  release(&ptable.lock);
+80103521:	e8 1a 0d 00 00       	call   80104240 <release>
+
+  // Allocate kernel stack.
+  if((p->kstack = kalloc()) == 0){
+80103526:	e8 85 ef ff ff       	call   801024b0 <kalloc>
+8010352b:	85 c0                	test   %eax,%eax
+8010352d:	89 43 08             	mov    %eax,0x8(%ebx)
+80103530:	74 5a                	je     8010358c <allocproc+0xbc>
+    return 0;
+  }
+  sp = p->kstack + KSTACKSIZE;
+
+  // Leave room for trap frame.
+  sp -= sizeof *p->tf;
+80103532:	8d 90 b4 0f 00 00    	lea    0xfb4(%eax),%edx
+  // Set up new context to start executing at forkret,
+  // which returns to trapret.
+  sp -= 4;
+  *(uint*)sp = (uint)trapret;
+
+  sp -= sizeof *p->context;
+80103538:	05 9c 0f 00 00       	add    $0xf9c,%eax
+  sp -= sizeof *p->tf;
+8010353d:	89 53 18             	mov    %edx,0x18(%ebx)
+  *(uint*)sp = (uint)trapret;
+80103540:	c7 40 14 65 54 10 80 	movl   $0x80105465,0x14(%eax)
+  p->context = (struct context*)sp;
+  memset(p->context, 0, sizeof *p->context);
+80103547:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
+8010354e:	00 
+8010354f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80103556:	00 
+80103557:	89 04 24             	mov    %eax,(%esp)
+  p->context = (struct context*)sp;
+8010355a:	89 43 1c             	mov    %eax,0x1c(%ebx)
+  memset(p->context, 0, sizeof *p->context);
+8010355d:	e8 2e 0d 00 00       	call   80104290 <memset>
+  p->context->eip = (uint)forkret;
+80103562:	8b 43 1c             	mov    0x1c(%ebx),%eax
+80103565:	c7 40 10 a0 35 10 80 	movl   $0x801035a0,0x10(%eax)
+
+  return p;
+8010356c:	89 d8                	mov    %ebx,%eax
+}
+8010356e:	83 c4 14             	add    $0x14,%esp
+80103571:	5b                   	pop    %ebx
+80103572:	5d                   	pop    %ebp
+80103573:	c3                   	ret    
+80103574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  release(&ptable.lock);
+80103578:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+  }while((x /= base) != 0);
+    1350:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1352:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1355:	75 e9                	jne    1340 <printint+0x30>
+  if(neg)
+    1357:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    135a:	89 c8                	mov    %ecx,%eax
+    135c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    135f:	85 d2                	test   %edx,%edx
+    1361:	74 08                	je     136b <printint+0x5b>
+    buf[i++] = '-';
+    1363:	8d 4f 02             	lea    0x2(%edi),%ecx
+    1366:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    136b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    136e:	66 90                	xchg   %ax,%ax
+    1370:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    1375:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    1378:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    137f:	00 
+    1380:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1384:	89 34 24             	mov    %esi,(%esp)
+    1387:	88 45 d7             	mov    %al,-0x29(%ebp)
+    138a:	e8 e3 fe ff ff       	call   1272 <write>
+  while(--i >= 0)
+    138f:	83 ff ff             	cmp    $0xffffffff,%edi
+    1392:	75 dc                	jne    1370 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    1394:	83 c4 4c             	add    $0x4c,%esp
+    1397:	5b                   	pop    %ebx
+    1398:	5e                   	pop    %esi
+    1399:	5f                   	pop    %edi
+    139a:	5d                   	pop    %ebp
+    139b:	c3                   	ret    
+    139c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    13a0:	89 d0                	mov    %edx,%eax
+    13a2:	f7 d8                	neg    %eax
+    neg = 1;
+    13a4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    13ab:	eb 87                	jmp    1334 <printint+0x24>
+    13ad:	8d 76 00             	lea    0x0(%esi),%esi
+
+000013b0 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    13b0:	55                   	push   %ebp
+    13b1:	89 e5                	mov    %esp,%ebp
+    13b3:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    13b4:	31 ff                	xor    %edi,%edi
+{
+    13b6:	56                   	push   %esi
+    13b7:	53                   	push   %ebx
+    13b8:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    13bb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    13be:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    13c1:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    13c4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    13c7:	0f b6 13             	movzbl (%ebx),%edx
+    13ca:	83 c3 01             	add    $0x1,%ebx
+    13cd:	84 d2                	test   %dl,%dl
+    13cf:	75 39                	jne    140a <printf+0x5a>
+    13d1:	e9 c2 00 00 00       	jmp    1498 <printf+0xe8>
+    13d6:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    13d8:	83 fa 25             	cmp    $0x25,%edx
+    13db:	0f 84 bf 00 00 00    	je     14a0 <printf+0xf0>
+  write(fd, &c, 1);
+    13e1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    13e4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    13eb:	00 
+    13ec:	89 44 24 04          	mov    %eax,0x4(%esp)
+    13f0:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    13f3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    13f6:	e8 77 fe ff ff       	call   1272 <write>
+    13fb:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    13fe:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    1402:	84 d2                	test   %dl,%dl
+    1404:	0f 84 8e 00 00 00    	je     1498 <printf+0xe8>
+    if(state == 0){
+    140a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    140c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    140f:	74 c7                	je     13d8 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1411:	83 ff 25             	cmp    $0x25,%edi
+    1414:	75 e5                	jne    13fb <printf+0x4b>
+      if(c == 'd'){
+    1416:	83 fa 64             	cmp    $0x64,%edx
+    1419:	0f 84 31 01 00 00    	je     1550 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    141f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1424:	83 f8 70             	cmp    $0x70,%eax
+    1427:	0f 84 83 00 00 00    	je     14b0 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    142d:	83 fa 73             	cmp    $0x73,%edx
+    1430:	0f 84 a2 00 00 00    	je     14d8 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1436:	83 fa 63             	cmp    $0x63,%edx
+    1439:	0f 84 35 01 00 00    	je     1574 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    143f:	83 fa 25             	cmp    $0x25,%edx
+    1442:	0f 84 e0 00 00 00    	je     1528 <printf+0x178>
+  write(fd, &c, 1);
+    1448:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    144b:	83 c3 01             	add    $0x1,%ebx
+    144e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1455:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
