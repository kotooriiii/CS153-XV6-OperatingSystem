diff --git a/.cvsignore b/.cvsignore
deleted file mode 100644
index 081a43c..0000000
--- a/.cvsignore
+++ /dev/null
@@ -1,16 +0,0 @@
-*.asm
-*.d
-*.sym
-_*
-kernel
-user1
-userfs
-usertests
-xv6.img
-vectors.S
-bochsout.txt
-bootblock
-bootother
-bootother.out
-parport.out
-fmt
diff --git a/.dir-locals.el b/.dir-locals.el
deleted file mode 100644
index da72247..0000000
--- a/.dir-locals.el
+++ /dev/null
@@ -1,4 +0,0 @@
-((c-mode
-  (indent-tabs-mode . nil)
-  (c-file-style . "bsd")
-  (c-basic-offset . 2)))
diff --git a/.gdbinit.tmpl b/.gdbinit.tmpl
index f71681a..ac7a259 100644
--- a/.gdbinit.tmpl
+++ b/.gdbinit.tmpl
@@ -24,4 +24,4 @@ echo + target remote localhost:1234\n
 target remote localhost:1234
 
 echo + symbol-file kernel\n
-symbol-file kernel
+symbol-file kernel
\ No newline at end of file
diff --git a/.gitignore b/.gitignore
deleted file mode 100644
index 3e2c9de..0000000
--- a/.gitignore
+++ /dev/null
@@ -1,16 +0,0 @@
-*~
-_*
-*.o
-*.d
-*.asm
-*.sym
-*.img
-vectors.S
-bootblock
-entryother
-initcode
-initcode.out
-kernel
-kernelmemfs
-mkfs
-.gdbinit
diff --git a/LICENSE b/LICENSE
index 422c0cc..4ec362c 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,6 +1,6 @@
 The xv6 software is:
 
-Copyright (c) 2006-2018 Frans Kaashoek, Robert Morris, Russ Cox,
+Copyright (c) 2006-2017 Frans Kaashoek, Robert Morris, Russ Cox,
                         Massachusetts Institute of Technology
 
 Permission is hereby granted, free of charge, to any person obtaining
diff --git a/Makefile b/Makefile
index 04d74d5..2d2b9e4 100644
--- a/Makefile
+++ b/Makefile
@@ -27,6 +27,7 @@ OBJS = \
 	uart.o\
 	vectors.o\
 	vm.o\
+	shm.o\
 
 # Cross-compiling (e.g., on Mac OS X)
 # TOOLPREFIX = i386-jos-elf
@@ -77,20 +78,13 @@ LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
 CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+#CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
 LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
 
-# Disable PIE when possible (for Ubuntu 16.10 toolchain)
-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
-CFLAGS += -fno-pie -no-pie
-endif
-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
-CFLAGS += -fno-pie -nopie
-endif
-
-xv6.img: bootblock kernel
+xv6.img: bootblock kernel fs.img
 	dd if=/dev/zero of=xv6.img count=10000
 	dd if=bootblock of=xv6.img conv=notrunc
 	dd if=kernel of=xv6.img seek=1 conv=notrunc
@@ -141,19 +135,19 @@ tags: $(OBJS) entryother.S _init
 	etags *.S *.c
 
 vectors.S: vectors.pl
-	./vectors.pl > vectors.S
+	perl vectors.pl > vectors.S
 
-ULIB = ulib.o usys.o printf.o umalloc.o
+ULIB = ulib.o usys.o printf.o umalloc.o uspinlock.o
 
 _%: %.o $(ULIB)
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0x1000 -o $@ $^
 	$(OBJDUMP) -S $@ > $*.asm
 	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
 
 _forktest: forktest.o $(ULIB)
 	# forktest has less library code linked in - needs to be small
 	# in order to be able to max out the proc table.
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0x1000 -o _forktest forktest.o ulib.o usys.o
 	$(OBJDUMP) -S _forktest > forktest.asm
 
 mkfs: mkfs.c fs.h
@@ -181,7 +175,8 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
-	_lab1\
+	_shm_cnt\
+	_null\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -191,8 +186,8 @@ fs.img: mkfs README $(UPROGS)
 clean: 
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
 	*.o *.d *.asm *.sym vectors.S bootblock entryother \
-	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
-	xv6memfs.img mkfs .gdbinit \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs mkfs \
+	.gdbinit \
 	$(UPROGS)
 
 # make a printout
@@ -218,7 +213,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
@@ -251,7 +246,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
-	printf.c umalloc.c\
+	printf.c umalloc.c uspinlock.c shm_cnt.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
diff --git a/README b/README
index 923e0a4..b82e8d2 100644
--- a/README
+++ b/README
@@ -1,7 +1,3 @@
-NOTE: we have stopped maintaining the x86 version of xv6, and switched
-our efforts to the RISC-V version
-(https://github.com/mit-pdos/xv6-riscv.git)
-
 xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
 Version 6 (v6).  xv6 loosely follows the structure and style of v6,
 but is implemented for a modern x86-based multiprocessor using ANSI C.
@@ -10,7 +6,7 @@ ACKNOWLEDGMENTS
 
 xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
 to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
-2000)). See also https://pdos.csail.mit.edu/6.828/, which
+2000)). See also http://pdos.csail.mit.edu/6.828/2016/xv6.html, which
 provides pointers to on-line resources for v6.
 
 xv6 borrows code from the following sources:
@@ -24,28 +20,30 @@ locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
 Clements.
 
 We are also grateful for the bug reports and patches contributed by Silas
-Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,
-Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter
-Froehlich, Yakir Goaron,Shivam Handa, Bryan Henry, Jim Huang, Alexander
-Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller, Eddie Kohler, Austin
-Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi
-Merimovich, Mark Morrissey, mtasm, Joel Nider, Greg Price, Ayan Shafqat,
-Eldar Sehayek, Yongming Shen, Cam Tenny, tyfkda, Rafael Ubal, Warren
-Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
-Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang Wei.
+Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, Nelson Elhage,
+Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter Froehlich, Yakir Goaron,
+Shivam Handa, Bryan Henry, Jim Huang, Alexander Kapshuk, Anders Kaseorg,
+kehao95, Wolfgang Keller, Eddie Kohler, Austin Liew, Imbar Marinescu, Yandong
+Mao, Hitoshi Mitake, Carmi Merimovich, Joel Nider, Greg Price, Ayan Shafqat,
+Eldar Sehayek, Yongming Shen, Cam Tenny, Rafael Ubal, Warren Toomey, Stephen Tu,
+Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas Wolovick, Grant Wu, Jindong
+Zhang, Icenowy Zheng, and Zou Chang Wei.
 
 The code in the files that constitute xv6 is
-Copyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.
+Copyright 2006-2016 Frans Kaashoek, Robert Morris, and Russ Cox.
 
 ERROR REPORTS
 
-We don't process error reports (see note on top of this file).
+Please send errors and suggestions to Frans Kaashoek and Robert Morris
+(kaashoek,rtm@mit.edu). The main purpose of xv6 is as a teaching
+operating system for MIT's 6.828, so we are more interested in
+simplifications and clarifications than new features.
 
 BUILDING AND RUNNING XV6
 
 To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
 "make". On non-x86 or non-ELF machines (like OS X, even on x86), you
 will need to install a cross-compiler gcc suite capable of producing
-x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
+x86 ELF binaries. See http://pdos.csail.mit.edu/6.828/2016/tools.html.
 Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
-simulator and run "make qemu".
\ No newline at end of file
+simulator and run "make qemu".
diff --git a/_cat b/_cat
new file mode 100644
index 0000000..10a621a
Binary files /dev/null and b/_cat differ
diff --git a/_echo b/_echo
new file mode 100644
index 0000000..55b710a
Binary files /dev/null and b/_echo differ
diff --git a/_forktest b/_forktest
new file mode 100644
index 0000000..a7e3b54
Binary files /dev/null and b/_forktest differ
diff --git a/_grep b/_grep
new file mode 100644
index 0000000..b580d72
Binary files /dev/null and b/_grep differ
diff --git a/_init b/_init
new file mode 100644
index 0000000..a7a81a1
Binary files /dev/null and b/_init differ
diff --git a/_kill b/_kill
new file mode 100644
index 0000000..b210582
Binary files /dev/null and b/_kill differ
diff --git a/_ln b/_ln
new file mode 100644
index 0000000..504ed3e
Binary files /dev/null and b/_ln differ
diff --git a/_ls b/_ls
new file mode 100644
index 0000000..4389de6
Binary files /dev/null and b/_ls differ
diff --git a/_mkdir b/_mkdir
new file mode 100644
index 0000000..7d5c66a
Binary files /dev/null and b/_mkdir differ
diff --git a/_null b/_null
new file mode 100644
index 0000000..6da8488
Binary files /dev/null and b/_null differ
diff --git a/_rm b/_rm
new file mode 100644
index 0000000..6a5e4dc
Binary files /dev/null and b/_rm differ
diff --git a/_sh b/_sh
new file mode 100644
index 0000000..3a6a5aa
Binary files /dev/null and b/_sh differ
diff --git a/_shm_cnt b/_shm_cnt
new file mode 100644
index 0000000..f4387b1
Binary files /dev/null and b/_shm_cnt differ
diff --git a/_stressfs b/_stressfs
new file mode 100644
index 0000000..f9e3181
Binary files /dev/null and b/_stressfs differ
diff --git a/_usertests b/_usertests
new file mode 100644
index 0000000..a79892c
Binary files /dev/null and b/_usertests differ
diff --git a/_wc b/_wc
new file mode 100644
index 0000000..2bf9826
Binary files /dev/null and b/_wc differ
diff --git a/_zombie b/_zombie
new file mode 100644
index 0000000..02b2b50
Binary files /dev/null and b/_zombie differ
diff --git a/asm.h b/asm.h
index b8a7353..68210d7 100644
--- a/asm.h
+++ b/asm.h
@@ -14,5 +14,8 @@
                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
 
 #define STA_X     0x8       // Executable segment
+#define STA_E     0x4       // Expand down (non-executable segments)
+#define STA_C     0x4       // Conforming code segment (executable only)
 #define STA_W     0x2       // Writeable (non-executable segments)
 #define STA_R     0x2       // Readable (executable segments)
+#define STA_A     0x1       // Accessed
diff --git a/bio.d b/bio.d
new file mode 100644
index 0000000..b4bbd30
--- /dev/null
+++ b/bio.d
@@ -0,0 +1,2 @@
+bio.o: bio.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h \
+ sleeplock.h fs.h buf.h
diff --git a/bio.o b/bio.o
new file mode 100644
index 0000000..4800bd2
Binary files /dev/null and b/bio.o differ
diff --git a/bootasm.d b/bootasm.d
new file mode 100644
index 0000000..3b3dc19
--- /dev/null
+++ b/bootasm.d
@@ -0,0 +1 @@
+bootasm.o: bootasm.S asm.h memlayout.h mmu.h
diff --git a/bootasm.o b/bootasm.o
new file mode 100644
index 0000000..c475f1a
Binary files /dev/null and b/bootasm.o differ
diff --git a/bootblock b/bootblock
new file mode 100644
index 0000000..ff63c64
Binary files /dev/null and b/bootblock differ
diff --git a/bootblock.asm b/bootblock.asm
new file mode 100644
index 0000000..bf77419
--- /dev/null
+++ b/bootblock.asm
@@ -0,0 +1,353 @@
+
+bootblock.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00007c00 <start>:
+# with %cs=0 %ip=7c00.
+
+.code16                       # Assemble for 16-bit mode
+.globl start
+start:
+  cli                         # BIOS enabled interrupts; disable
+    7c00:	fa                   	cli    
+
+  # Zero data segment registers DS, ES, and SS.
+  xorw    %ax,%ax             # Set %ax to zero
+    7c01:	31 c0                	xor    %eax,%eax
+  movw    %ax,%ds             # -> Data Segment
+    7c03:	8e d8                	mov    %eax,%ds
+  movw    %ax,%es             # -> Extra Segment
+    7c05:	8e c0                	mov    %eax,%es
+  movw    %ax,%ss             # -> Stack Segment
+    7c07:	8e d0                	mov    %eax,%ss
+
+00007c09 <seta20.1>:
+
+  # Physical address line A20 is tied to zero so that the first PCs 
+  # with 2 MB would run software that assumed 1 MB.  Undo that.
+seta20.1:
+  inb     $0x64,%al               # Wait for not busy
+    7c09:	e4 64                	in     $0x64,%al
+  testb   $0x2,%al
+    7c0b:	a8 02                	test   $0x2,%al
+  jnz     seta20.1
+    7c0d:	75 fa                	jne    7c09 <seta20.1>
+
+  movb    $0xd1,%al               # 0xd1 -> port 0x64
+    7c0f:	b0 d1                	mov    $0xd1,%al
+  outb    %al,$0x64
+    7c11:	e6 64                	out    %al,$0x64
+
+00007c13 <seta20.2>:
+
+seta20.2:
+  inb     $0x64,%al               # Wait for not busy
+    7c13:	e4 64                	in     $0x64,%al
+  testb   $0x2,%al
+    7c15:	a8 02                	test   $0x2,%al
+  jnz     seta20.2
+    7c17:	75 fa                	jne    7c13 <seta20.2>
+
+  movb    $0xdf,%al               # 0xdf -> port 0x60
+    7c19:	b0 df                	mov    $0xdf,%al
+  outb    %al,$0x60
+    7c1b:	e6 60                	out    %al,$0x60
+
+  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+  # virtual addresses map directly to physical addresses so that the
+  # effective memory map doesn't change during the transition.
+  lgdt    gdtdesc
+    7c1d:	0f 01 16             	lgdtl  (%esi)
+    7c20:	78 7c                	js     7c9e <readsect+0xe>
+  movl    %cr0, %eax
+    7c22:	0f 20 c0             	mov    %cr0,%eax
+  orl     $CR0_PE, %eax
+    7c25:	66 83 c8 01          	or     $0x1,%ax
+  movl    %eax, %cr0
+    7c29:	0f 22 c0             	mov    %eax,%cr0
+
+//PAGEBREAK!
+  # Complete the transition to 32-bit protected mode by using a long jmp
+  # to reload %cs and %eip.  The segment descriptors are set up with no
+  # translation, so that the mapping is still the identity mapping.
+  ljmp    $(SEG_KCODE<<3), $start32
+    7c2c:	ea                   	.byte 0xea
+    7c2d:	31 7c 08 00          	xor    %edi,0x0(%eax,%ecx,1)
+
+00007c31 <start32>:
+
+.code32  # Tell assembler to generate 32-bit code now.
+start32:
+  # Set up the protected-mode data segment registers
+  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+    7c31:	66 b8 10 00          	mov    $0x10,%ax
+  movw    %ax, %ds                # -> DS: Data Segment
+    7c35:	8e d8                	mov    %eax,%ds
+  movw    %ax, %es                # -> ES: Extra Segment
+    7c37:	8e c0                	mov    %eax,%es
+  movw    %ax, %ss                # -> SS: Stack Segment
+    7c39:	8e d0                	mov    %eax,%ss
+  movw    $0, %ax                 # Zero segments not ready for use
+    7c3b:	66 b8 00 00          	mov    $0x0,%ax
+  movw    %ax, %fs                # -> FS
+    7c3f:	8e e0                	mov    %eax,%fs
+  movw    %ax, %gs                # -> GS
+    7c41:	8e e8                	mov    %eax,%gs
+
+  # Set up the stack pointer and call into C.
+  movl    $start, %esp
+    7c43:	bc 00 7c 00 00       	mov    $0x7c00,%esp
+  call    bootmain
+    7c48:	e8 e2 00 00 00       	call   7d2f <bootmain>
+
+  # If bootmain returns (it shouldn't), trigger a Bochs
+  # breakpoint if running under Bochs, then loop.
+  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
+    7c4d:	66 b8 00 8a          	mov    $0x8a00,%ax
+  movw    %ax, %dx
+    7c51:	66 89 c2             	mov    %ax,%dx
+  outw    %ax, %dx
+    7c54:	66 ef                	out    %ax,(%dx)
+  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
+    7c56:	66 b8 e0 8a          	mov    $0x8ae0,%ax
+  outw    %ax, %dx
+    7c5a:	66 ef                	out    %ax,(%dx)
+
+00007c5c <spin>:
+spin:
+  jmp     spin
+    7c5c:	eb fe                	jmp    7c5c <spin>
+    7c5e:	66 90                	xchg   %ax,%ax
+
+00007c60 <gdt>:
+	...
+    7c68:	ff                   	(bad)  
+    7c69:	ff 00                	incl   (%eax)
+    7c6b:	00 00                	add    %al,(%eax)
+    7c6d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
+    7c74:	00                   	.byte 0x0
+    7c75:	92                   	xchg   %eax,%edx
+    7c76:	cf                   	iret   
+	...
+
+00007c78 <gdtdesc>:
+    7c78:	17                   	pop    %ss
+    7c79:	00 60 7c             	add    %ah,0x7c(%eax)
+	...
+
+00007c7e <waitdisk>:
+  entry();
+}
+
+void
+waitdisk(void)
+{
+    7c7e:	55                   	push   %ebp
+    7c7f:	89 e5                	mov    %esp,%ebp
+static inline uchar
+inb(ushort port)
+{
+  uchar data;
+
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+    7c81:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7c86:	ec                   	in     (%dx),%al
+  // Wait for disk ready.
+  while((inb(0x1F7) & 0xC0) != 0x40)
+    7c87:	83 e0 c0             	and    $0xffffffc0,%eax
+    7c8a:	3c 40                	cmp    $0x40,%al
+    7c8c:	75 f8                	jne    7c86 <waitdisk+0x8>
+    ;
+}
+    7c8e:	5d                   	pop    %ebp
+    7c8f:	c3                   	ret    
+
+00007c90 <readsect>:
+
+// Read a single sector at offset into dst.
+void
+readsect(void *dst, uint offset)
+{
+    7c90:	55                   	push   %ebp
+    7c91:	89 e5                	mov    %esp,%ebp
+    7c93:	57                   	push   %edi
+    7c94:	53                   	push   %ebx
+    7c95:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  // Issue command.
+  waitdisk();
+    7c98:	e8 e1 ff ff ff       	call   7c7e <waitdisk>
+}
+
+static inline void
+outb(ushort port, uchar data)
+{
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+    7c9d:	ba f2 01 00 00       	mov    $0x1f2,%edx
+    7ca2:	b8 01 00 00 00       	mov    $0x1,%eax
+    7ca7:	ee                   	out    %al,(%dx)
+    7ca8:	b2 f3                	mov    $0xf3,%dl
+    7caa:	89 d8                	mov    %ebx,%eax
+    7cac:	ee                   	out    %al,(%dx)
+    7cad:	0f b6 c7             	movzbl %bh,%eax
+    7cb0:	b2 f4                	mov    $0xf4,%dl
+    7cb2:	ee                   	out    %al,(%dx)
+  outb(0x1F2, 1);   // count = 1
+  outb(0x1F3, offset);
+  outb(0x1F4, offset >> 8);
+  outb(0x1F5, offset >> 16);
+    7cb3:	89 d8                	mov    %ebx,%eax
+    7cb5:	c1 e8 10             	shr    $0x10,%eax
+    7cb8:	b2 f5                	mov    $0xf5,%dl
+    7cba:	ee                   	out    %al,(%dx)
+  outb(0x1F6, (offset >> 24) | 0xE0);
+    7cbb:	c1 eb 18             	shr    $0x18,%ebx
+    7cbe:	89 d8                	mov    %ebx,%eax
+    7cc0:	83 c8 e0             	or     $0xffffffe0,%eax
+    7cc3:	b2 f6                	mov    $0xf6,%dl
+    7cc5:	ee                   	out    %al,(%dx)
+    7cc6:	b2 f7                	mov    $0xf7,%dl
+    7cc8:	b8 20 00 00 00       	mov    $0x20,%eax
+    7ccd:	ee                   	out    %al,(%dx)
+  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
+
+  // Read data.
+  waitdisk();
+    7cce:	e8 ab ff ff ff       	call   7c7e <waitdisk>
+  asm volatile("cld; rep insl" :
+    7cd3:	8b 7d 08             	mov    0x8(%ebp),%edi
+    7cd6:	b9 80 00 00 00       	mov    $0x80,%ecx
+    7cdb:	ba f0 01 00 00       	mov    $0x1f0,%edx
+    7ce0:	fc                   	cld    
+    7ce1:	f3 6d                	rep insl (%dx),%es:(%edi)
+  insl(0x1F0, dst, SECTSIZE/4);
+}
+    7ce3:	5b                   	pop    %ebx
+    7ce4:	5f                   	pop    %edi
+    7ce5:	5d                   	pop    %ebp
+    7ce6:	c3                   	ret    
+
+00007ce7 <readseg>:
+
+// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
+// Might copy more than asked.
+void
+readseg(uchar* pa, uint count, uint offset)
+{
+    7ce7:	55                   	push   %ebp
+    7ce8:	89 e5                	mov    %esp,%ebp
+    7cea:	57                   	push   %edi
+    7ceb:	56                   	push   %esi
+    7cec:	53                   	push   %ebx
+    7ced:	83 ec 08             	sub    $0x8,%esp
+    7cf0:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    7cf3:	8b 75 10             	mov    0x10(%ebp),%esi
+  uchar* epa;
+
+  epa = pa + count;
+    7cf6:	89 df                	mov    %ebx,%edi
+    7cf8:	03 7d 0c             	add    0xc(%ebp),%edi
+
+  // Round down to sector boundary.
+  pa -= offset % SECTSIZE;
+    7cfb:	89 f0                	mov    %esi,%eax
+    7cfd:	25 ff 01 00 00       	and    $0x1ff,%eax
+    7d02:	29 c3                	sub    %eax,%ebx
+
+  // Translate from bytes to sectors; kernel starts at sector 1.
+  offset = (offset / SECTSIZE) + 1;
+    7d04:	c1 ee 09             	shr    $0x9,%esi
+    7d07:	83 c6 01             	add    $0x1,%esi
+
+  // If this is too slow, we could read lots of sectors at a time.
+  // We'd write more to memory than asked, but it doesn't matter --
+  // we load in increasing order.
+  for(; pa < epa; pa += SECTSIZE, offset++)
+    7d0a:	39 df                	cmp    %ebx,%edi
+    7d0c:	76 19                	jbe    7d27 <readseg+0x40>
+    readsect(pa, offset);
+    7d0e:	89 74 24 04          	mov    %esi,0x4(%esp)
+    7d12:	89 1c 24             	mov    %ebx,(%esp)
+    7d15:	e8 76 ff ff ff       	call   7c90 <readsect>
+  for(; pa < epa; pa += SECTSIZE, offset++)
+    7d1a:	81 c3 00 02 00 00    	add    $0x200,%ebx
+    7d20:	83 c6 01             	add    $0x1,%esi
+    7d23:	39 df                	cmp    %ebx,%edi
+    7d25:	77 e7                	ja     7d0e <readseg+0x27>
+}
+    7d27:	83 c4 08             	add    $0x8,%esp
+    7d2a:	5b                   	pop    %ebx
+    7d2b:	5e                   	pop    %esi
+    7d2c:	5f                   	pop    %edi
+    7d2d:	5d                   	pop    %ebp
+    7d2e:	c3                   	ret    
+
+00007d2f <bootmain>:
+{
+    7d2f:	55                   	push   %ebp
+    7d30:	89 e5                	mov    %esp,%ebp
+    7d32:	57                   	push   %edi
+    7d33:	56                   	push   %esi
+    7d34:	53                   	push   %ebx
+    7d35:	83 ec 1c             	sub    $0x1c,%esp
+  readseg((uchar*)elf, 4096, 0);
+    7d38:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+    7d3f:	00 
+    7d40:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+    7d47:	00 
+    7d48:	c7 04 24 00 00 01 00 	movl   $0x10000,(%esp)
+    7d4f:	e8 93 ff ff ff       	call   7ce7 <readseg>
+  if(elf->magic != ELF_MAGIC)
+    7d54:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
+    7d5b:	45 4c 46 
+    7d5e:	75 57                	jne    7db7 <bootmain+0x88>
+  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
+    7d60:	a1 1c 00 01 00       	mov    0x1001c,%eax
+    7d65:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx
+  eph = ph + elf->phnum;
+    7d6b:	0f b7 35 2c 00 01 00 	movzwl 0x1002c,%esi
+    7d72:	c1 e6 05             	shl    $0x5,%esi
+    7d75:	01 de                	add    %ebx,%esi
+  for(; ph < eph; ph++){
+    7d77:	39 f3                	cmp    %esi,%ebx
+    7d79:	73 36                	jae    7db1 <bootmain+0x82>
+    pa = (uchar*)ph->paddr;
+    7d7b:	8b 7b 0c             	mov    0xc(%ebx),%edi
+    readseg(pa, ph->filesz, ph->off);
+    7d7e:	8b 43 04             	mov    0x4(%ebx),%eax
+    7d81:	89 44 24 08          	mov    %eax,0x8(%esp)
+    7d85:	8b 43 10             	mov    0x10(%ebx),%eax
+    7d88:	89 44 24 04          	mov    %eax,0x4(%esp)
+    7d8c:	89 3c 24             	mov    %edi,(%esp)
+    7d8f:	e8 53 ff ff ff       	call   7ce7 <readseg>
+    if(ph->memsz > ph->filesz)
+    7d94:	8b 4b 14             	mov    0x14(%ebx),%ecx
+    7d97:	8b 43 10             	mov    0x10(%ebx),%eax
+    7d9a:	39 c1                	cmp    %eax,%ecx
+    7d9c:	76 0c                	jbe    7daa <bootmain+0x7b>
+      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
+    7d9e:	01 c7                	add    %eax,%edi
+    7da0:	29 c1                	sub    %eax,%ecx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    7da2:	b8 00 00 00 00       	mov    $0x0,%eax
+    7da7:	fc                   	cld    
+    7da8:	f3 aa                	rep stos %al,%es:(%edi)
+  for(; ph < eph; ph++){
+    7daa:	83 c3 20             	add    $0x20,%ebx
+    7dad:	39 de                	cmp    %ebx,%esi
+    7daf:	77 ca                	ja     7d7b <bootmain+0x4c>
+  entry();
+    7db1:	ff 15 18 00 01 00    	call   *0x10018
+}
+    7db7:	83 c4 1c             	add    $0x1c,%esp
+    7dba:	5b                   	pop    %ebx
+    7dbb:	5e                   	pop    %esi
+    7dbc:	5f                   	pop    %edi
+    7dbd:	5d                   	pop    %ebp
+    7dbe:	c3                   	ret    
diff --git a/bootblock.o b/bootblock.o
new file mode 100644
index 0000000..ef33621
Binary files /dev/null and b/bootblock.o differ
diff --git a/bootblockother.o b/bootblockother.o
new file mode 100644
index 0000000..4f97caa
Binary files /dev/null and b/bootblockother.o differ
diff --git a/bootmain.d b/bootmain.d
new file mode 100644
index 0000000..b32eaf5
--- /dev/null
+++ b/bootmain.d
@@ -0,0 +1 @@
+bootmain.o: bootmain.c types.h elf.h x86.h memlayout.h
diff --git a/bootmain.o b/bootmain.o
new file mode 100644
index 0000000..41aea09
Binary files /dev/null and b/bootmain.o differ
diff --git a/cat.asm b/cat.asm
new file mode 100644
index 0000000..1a0c1f9
--- /dev/null
+++ b/cat.asm
@@ -0,0 +1,1301 @@
+
+_cat:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+  }
+}
+
+int
+main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	57                   	push   %edi
+    1004:	56                   	push   %esi
+  int fd, i;
+
+  if(argc <= 1){
+    1005:	be 01 00 00 00       	mov    $0x1,%esi
+{
+    100a:	53                   	push   %ebx
+    100b:	83 e4 f0             	and    $0xfffffff0,%esp
+    100e:	83 ec 10             	sub    $0x10,%esp
+    1011:	8b 45 0c             	mov    0xc(%ebp),%eax
+  if(argc <= 1){
+    1014:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+    1018:	8d 58 04             	lea    0x4(%eax),%ebx
+    101b:	7e 5a                	jle    1077 <main+0x77>
+    101d:	8d 76 00             	lea    0x0(%esi),%esi
+    cat(0);
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+    if((fd = open(argv[i], 0)) < 0){
+    1020:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1027:	00 
+    1028:	8b 03                	mov    (%ebx),%eax
+    102a:	89 04 24             	mov    %eax,(%esp)
+    102d:	e8 50 03 00 00       	call   1382 <open>
+    1032:	85 c0                	test   %eax,%eax
+    1034:	89 c7                	mov    %eax,%edi
+    1036:	78 20                	js     1058 <main+0x58>
+      printf(1, "cat: cannot open %s\n", argv[i]);
+      exit();
+    }
+    cat(fd);
+    1038:	89 04 24             	mov    %eax,(%esp)
+  for(i = 1; i < argc; i++){
+    103b:	83 c6 01             	add    $0x1,%esi
+    103e:	83 c3 04             	add    $0x4,%ebx
+    cat(fd);
+    1041:	e8 4a 00 00 00       	call   1090 <cat>
+    close(fd);
+    1046:	89 3c 24             	mov    %edi,(%esp)
+    1049:	e8 1c 03 00 00       	call   136a <close>
+  for(i = 1; i < argc; i++){
+    104e:	3b 75 08             	cmp    0x8(%ebp),%esi
+    1051:	75 cd                	jne    1020 <main+0x20>
+  }
+  exit();
+    1053:	e8 ea 02 00 00       	call   1342 <exit>
+      printf(1, "cat: cannot open %s\n", argv[i]);
+    1058:	8b 03                	mov    (%ebx),%eax
+    105a:	c7 44 24 04 64 18 00 	movl   $0x1864,0x4(%esp)
+    1061:	00 
+    1062:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1069:	89 44 24 08          	mov    %eax,0x8(%esp)
+    106d:	e8 2e 04 00 00       	call   14a0 <printf>
+      exit();
+    1072:	e8 cb 02 00 00       	call   1342 <exit>
+    cat(0);
+    1077:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    107e:	e8 0d 00 00 00       	call   1090 <cat>
+    exit();
+    1083:	e8 ba 02 00 00       	call   1342 <exit>
+    1088:	66 90                	xchg   %ax,%ax
+    108a:	66 90                	xchg   %ax,%ax
+    108c:	66 90                	xchg   %ax,%ax
+    108e:	66 90                	xchg   %ax,%ax
+
+00001090 <cat>:
+{
+    1090:	55                   	push   %ebp
+    1091:	89 e5                	mov    %esp,%ebp
+    1093:	56                   	push   %esi
+    1094:	53                   	push   %ebx
+    1095:	83 ec 10             	sub    $0x10,%esp
+    1098:	8b 75 08             	mov    0x8(%ebp),%esi
+  while((n = read(fd, buf, sizeof(buf))) > 0) {
+    109b:	eb 1f                	jmp    10bc <cat+0x2c>
+    109d:	8d 76 00             	lea    0x0(%esi),%esi
+    if (write(1, buf, n) != n) {
+    10a0:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    10a4:	c7 44 24 04 a0 1b 00 	movl   $0x1ba0,0x4(%esp)
+    10ab:	00 
+    10ac:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10b3:	e8 aa 02 00 00       	call   1362 <write>
+    10b8:	39 d8                	cmp    %ebx,%eax
+    10ba:	75 28                	jne    10e4 <cat+0x54>
+  while((n = read(fd, buf, sizeof(buf))) > 0) {
+    10bc:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+    10c3:	00 
+    10c4:	c7 44 24 04 a0 1b 00 	movl   $0x1ba0,0x4(%esp)
+    10cb:	00 
+    10cc:	89 34 24             	mov    %esi,(%esp)
+    10cf:	e8 86 02 00 00       	call   135a <read>
+    10d4:	83 f8 00             	cmp    $0x0,%eax
+    10d7:	89 c3                	mov    %eax,%ebx
+    10d9:	7f c5                	jg     10a0 <cat+0x10>
+  if(n < 0){
+    10db:	75 20                	jne    10fd <cat+0x6d>
+}
+    10dd:	83 c4 10             	add    $0x10,%esp
+    10e0:	5b                   	pop    %ebx
+    10e1:	5e                   	pop    %esi
+    10e2:	5d                   	pop    %ebp
+    10e3:	c3                   	ret    
+      printf(1, "cat: write error\n");
+    10e4:	c7 44 24 04 41 18 00 	movl   $0x1841,0x4(%esp)
+    10eb:	00 
+    10ec:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10f3:	e8 a8 03 00 00       	call   14a0 <printf>
+      exit();
+    10f8:	e8 45 02 00 00       	call   1342 <exit>
+    printf(1, "cat: read error\n");
+    10fd:	c7 44 24 04 53 18 00 	movl   $0x1853,0x4(%esp)
+    1104:	00 
+    1105:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    110c:	e8 8f 03 00 00       	call   14a0 <printf>
+    exit();
+    1111:	e8 2c 02 00 00       	call   1342 <exit>
+    1116:	66 90                	xchg   %ax,%ax
+    1118:	66 90                	xchg   %ax,%ax
+    111a:	66 90                	xchg   %ax,%ax
+    111c:	66 90                	xchg   %ax,%ax
+    111e:	66 90                	xchg   %ax,%ax
+
+00001120 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1120:	55                   	push   %ebp
+    1121:	89 e5                	mov    %esp,%ebp
+    1123:	8b 45 08             	mov    0x8(%ebp),%eax
+    1126:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1129:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    112a:	89 c2                	mov    %eax,%edx
+    112c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1130:	83 c1 01             	add    $0x1,%ecx
+    1133:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1137:	83 c2 01             	add    $0x1,%edx
+    113a:	84 db                	test   %bl,%bl
+    113c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    113f:	75 ef                	jne    1130 <strcpy+0x10>
+    ;
+  return os;
+}
+    1141:	5b                   	pop    %ebx
+    1142:	5d                   	pop    %ebp
+    1143:	c3                   	ret    
+    1144:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    114a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001150 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1150:	55                   	push   %ebp
+    1151:	89 e5                	mov    %esp,%ebp
+    1153:	8b 55 08             	mov    0x8(%ebp),%edx
+    1156:	53                   	push   %ebx
+    1157:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    115a:	0f b6 02             	movzbl (%edx),%eax
+    115d:	84 c0                	test   %al,%al
+    115f:	74 2d                	je     118e <strcmp+0x3e>
+    1161:	0f b6 19             	movzbl (%ecx),%ebx
+    1164:	38 d8                	cmp    %bl,%al
+    1166:	74 0e                	je     1176 <strcmp+0x26>
+    1168:	eb 2b                	jmp    1195 <strcmp+0x45>
+    116a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1170:	38 c8                	cmp    %cl,%al
+    1172:	75 15                	jne    1189 <strcmp+0x39>
+    p++, q++;
+    1174:	89 d9                	mov    %ebx,%ecx
+    1176:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    1179:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    117c:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    117f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    1183:	84 c0                	test   %al,%al
+    1185:	75 e9                	jne    1170 <strcmp+0x20>
+    1187:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    1189:	29 c8                	sub    %ecx,%eax
+}
+    118b:	5b                   	pop    %ebx
+    118c:	5d                   	pop    %ebp
+    118d:	c3                   	ret    
+    118e:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    1191:	31 c0                	xor    %eax,%eax
+    1193:	eb f4                	jmp    1189 <strcmp+0x39>
+    1195:	0f b6 cb             	movzbl %bl,%ecx
+    1198:	eb ef                	jmp    1189 <strcmp+0x39>
+    119a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000011a0 <strlen>:
+
+uint
+strlen(char *s)
+{
+    11a0:	55                   	push   %ebp
+    11a1:	89 e5                	mov    %esp,%ebp
+    11a3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    11a6:	80 39 00             	cmpb   $0x0,(%ecx)
+    11a9:	74 12                	je     11bd <strlen+0x1d>
+    11ab:	31 d2                	xor    %edx,%edx
+    11ad:	8d 76 00             	lea    0x0(%esi),%esi
+    11b0:	83 c2 01             	add    $0x1,%edx
+    11b3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    11b7:	89 d0                	mov    %edx,%eax
+    11b9:	75 f5                	jne    11b0 <strlen+0x10>
+    ;
+  return n;
+}
+    11bb:	5d                   	pop    %ebp
+    11bc:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    11bd:	31 c0                	xor    %eax,%eax
+}
+    11bf:	5d                   	pop    %ebp
+    11c0:	c3                   	ret    
+    11c1:	eb 0d                	jmp    11d0 <memset>
+    11c3:	90                   	nop
+    11c4:	90                   	nop
+    11c5:	90                   	nop
+    11c6:	90                   	nop
+    11c7:	90                   	nop
+    11c8:	90                   	nop
+    11c9:	90                   	nop
+    11ca:	90                   	nop
+    11cb:	90                   	nop
+    11cc:	90                   	nop
+    11cd:	90                   	nop
+    11ce:	90                   	nop
+    11cf:	90                   	nop
+
+000011d0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    11d0:	55                   	push   %ebp
+    11d1:	89 e5                	mov    %esp,%ebp
+    11d3:	8b 55 08             	mov    0x8(%ebp),%edx
+    11d6:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    11d7:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    11da:	8b 45 0c             	mov    0xc(%ebp),%eax
+    11dd:	89 d7                	mov    %edx,%edi
+    11df:	fc                   	cld    
+    11e0:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    11e2:	89 d0                	mov    %edx,%eax
+    11e4:	5f                   	pop    %edi
+    11e5:	5d                   	pop    %ebp
+    11e6:	c3                   	ret    
+    11e7:	89 f6                	mov    %esi,%esi
+    11e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+000011f0 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    11f0:	55                   	push   %ebp
+    11f1:	89 e5                	mov    %esp,%ebp
+    11f3:	8b 45 08             	mov    0x8(%ebp),%eax
+    11f6:	53                   	push   %ebx
+    11f7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    11fa:	0f b6 18             	movzbl (%eax),%ebx
+    11fd:	84 db                	test   %bl,%bl
+    11ff:	74 1d                	je     121e <strchr+0x2e>
+    if(*s == c)
+    1201:	38 d3                	cmp    %dl,%bl
+    1203:	89 d1                	mov    %edx,%ecx
+    1205:	75 0d                	jne    1214 <strchr+0x24>
+    1207:	eb 17                	jmp    1220 <strchr+0x30>
+    1209:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1210:	38 ca                	cmp    %cl,%dl
+    1212:	74 0c                	je     1220 <strchr+0x30>
+  for(; *s; s++)
+    1214:	83 c0 01             	add    $0x1,%eax
+    1217:	0f b6 10             	movzbl (%eax),%edx
+    121a:	84 d2                	test   %dl,%dl
+    121c:	75 f2                	jne    1210 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    121e:	31 c0                	xor    %eax,%eax
+}
+    1220:	5b                   	pop    %ebx
+    1221:	5d                   	pop    %ebp
+    1222:	c3                   	ret    
+    1223:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1229:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001230 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1230:	55                   	push   %ebp
+    1231:	89 e5                	mov    %esp,%ebp
+    1233:	57                   	push   %edi
+    1234:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1235:	31 f6                	xor    %esi,%esi
+{
+    1237:	53                   	push   %ebx
+    1238:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    123b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    123e:	eb 31                	jmp    1271 <gets+0x41>
+    cc = read(0, &c, 1);
+    1240:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1247:	00 
+    1248:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    124c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1253:	e8 02 01 00 00       	call   135a <read>
+    if(cc < 1)
+    1258:	85 c0                	test   %eax,%eax
+    125a:	7e 1d                	jle    1279 <gets+0x49>
+      break;
+    buf[i++] = c;
+    125c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    1260:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    1262:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    1265:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    1267:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    126b:	74 0c                	je     1279 <gets+0x49>
+    126d:	3c 0a                	cmp    $0xa,%al
+    126f:	74 08                	je     1279 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    1271:	8d 5e 01             	lea    0x1(%esi),%ebx
+    1274:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    1277:	7c c7                	jl     1240 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    1279:	8b 45 08             	mov    0x8(%ebp),%eax
+    127c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    1280:	83 c4 2c             	add    $0x2c,%esp
+    1283:	5b                   	pop    %ebx
+    1284:	5e                   	pop    %esi
+    1285:	5f                   	pop    %edi
+    1286:	5d                   	pop    %ebp
+    1287:	c3                   	ret    
+    1288:	90                   	nop
+    1289:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001290 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    1290:	55                   	push   %ebp
+    1291:	89 e5                	mov    %esp,%ebp
+    1293:	56                   	push   %esi
+    1294:	53                   	push   %ebx
+    1295:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    1298:	8b 45 08             	mov    0x8(%ebp),%eax
+    129b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    12a2:	00 
+    12a3:	89 04 24             	mov    %eax,(%esp)
+    12a6:	e8 d7 00 00 00       	call   1382 <open>
+  if(fd < 0)
+    12ab:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    12ad:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    12af:	78 27                	js     12d8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    12b1:	8b 45 0c             	mov    0xc(%ebp),%eax
+    12b4:	89 1c 24             	mov    %ebx,(%esp)
+    12b7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    12bb:	e8 da 00 00 00       	call   139a <fstat>
+  close(fd);
+    12c0:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    12c3:	89 c6                	mov    %eax,%esi
+  close(fd);
+    12c5:	e8 a0 00 00 00       	call   136a <close>
+  return r;
+    12ca:	89 f0                	mov    %esi,%eax
+}
+    12cc:	83 c4 10             	add    $0x10,%esp
+    12cf:	5b                   	pop    %ebx
+    12d0:	5e                   	pop    %esi
+    12d1:	5d                   	pop    %ebp
+    12d2:	c3                   	ret    
+    12d3:	90                   	nop
+    12d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    12d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    12dd:	eb ed                	jmp    12cc <stat+0x3c>
+    12df:	90                   	nop
+
+000012e0 <atoi>:
+
+int
+atoi(const char *s)
+{
+    12e0:	55                   	push   %ebp
+    12e1:	89 e5                	mov    %esp,%ebp
+    12e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    12e6:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    12e7:	0f be 11             	movsbl (%ecx),%edx
+    12ea:	8d 42 d0             	lea    -0x30(%edx),%eax
+    12ed:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    12ef:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    12f4:	77 17                	ja     130d <atoi+0x2d>
+    12f6:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    12f8:	83 c1 01             	add    $0x1,%ecx
+    12fb:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    12fe:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1302:	0f be 11             	movsbl (%ecx),%edx
+    1305:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1308:	80 fb 09             	cmp    $0x9,%bl
+    130b:	76 eb                	jbe    12f8 <atoi+0x18>
+  return n;
+}
+    130d:	5b                   	pop    %ebx
+    130e:	5d                   	pop    %ebp
+    130f:	c3                   	ret    
+
+00001310 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1310:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1311:	31 d2                	xor    %edx,%edx
+{
+    1313:	89 e5                	mov    %esp,%ebp
+    1315:	56                   	push   %esi
+    1316:	8b 45 08             	mov    0x8(%ebp),%eax
+    1319:	53                   	push   %ebx
+    131a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    131d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1320:	85 db                	test   %ebx,%ebx
+    1322:	7e 12                	jle    1336 <memmove+0x26>
+    1324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1328:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    132c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    132f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1332:	39 da                	cmp    %ebx,%edx
+    1334:	75 f2                	jne    1328 <memmove+0x18>
+  return vdst;
+}
+    1336:	5b                   	pop    %ebx
+    1337:	5e                   	pop    %esi
+    1338:	5d                   	pop    %ebp
+    1339:	c3                   	ret    
+
+0000133a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    133a:	b8 01 00 00 00       	mov    $0x1,%eax
+    133f:	cd 40                	int    $0x40
+    1341:	c3                   	ret    
+
+00001342 <exit>:
+SYSCALL(exit)
+    1342:	b8 02 00 00 00       	mov    $0x2,%eax
+    1347:	cd 40                	int    $0x40
+    1349:	c3                   	ret    
+
+0000134a <wait>:
+SYSCALL(wait)
+    134a:	b8 03 00 00 00       	mov    $0x3,%eax
+    134f:	cd 40                	int    $0x40
+    1351:	c3                   	ret    
+
+00001352 <pipe>:
+SYSCALL(pipe)
+    1352:	b8 04 00 00 00       	mov    $0x4,%eax
+    1357:	cd 40                	int    $0x40
+    1359:	c3                   	ret    
+
+0000135a <read>:
+SYSCALL(read)
+    135a:	b8 05 00 00 00       	mov    $0x5,%eax
+    135f:	cd 40                	int    $0x40
+    1361:	c3                   	ret    
+
+00001362 <write>:
+SYSCALL(write)
+    1362:	b8 10 00 00 00       	mov    $0x10,%eax
+    1367:	cd 40                	int    $0x40
+    1369:	c3                   	ret    
+
+0000136a <close>:
+SYSCALL(close)
+    136a:	b8 15 00 00 00       	mov    $0x15,%eax
+    136f:	cd 40                	int    $0x40
+    1371:	c3                   	ret    
+
+00001372 <kill>:
+SYSCALL(kill)
+    1372:	b8 06 00 00 00       	mov    $0x6,%eax
+    1377:	cd 40                	int    $0x40
+    1379:	c3                   	ret    
+
+0000137a <exec>:
+SYSCALL(exec)
+    137a:	b8 07 00 00 00       	mov    $0x7,%eax
+    137f:	cd 40                	int    $0x40
+    1381:	c3                   	ret    
+
+00001382 <open>:
+SYSCALL(open)
+    1382:	b8 0f 00 00 00       	mov    $0xf,%eax
+    1387:	cd 40                	int    $0x40
+    1389:	c3                   	ret    
+
+0000138a <mknod>:
+SYSCALL(mknod)
+    138a:	b8 11 00 00 00       	mov    $0x11,%eax
+    138f:	cd 40                	int    $0x40
+    1391:	c3                   	ret    
+
+00001392 <unlink>:
+SYSCALL(unlink)
+    1392:	b8 12 00 00 00       	mov    $0x12,%eax
+    1397:	cd 40                	int    $0x40
+    1399:	c3                   	ret    
+
+0000139a <fstat>:
+SYSCALL(fstat)
+    139a:	b8 08 00 00 00       	mov    $0x8,%eax
+    139f:	cd 40                	int    $0x40
+    13a1:	c3                   	ret    
+
+000013a2 <link>:
+SYSCALL(link)
+    13a2:	b8 13 00 00 00       	mov    $0x13,%eax
+    13a7:	cd 40                	int    $0x40
+    13a9:	c3                   	ret    
+
+000013aa <mkdir>:
+SYSCALL(mkdir)
+    13aa:	b8 14 00 00 00       	mov    $0x14,%eax
+    13af:	cd 40                	int    $0x40
+    13b1:	c3                   	ret    
+
+000013b2 <chdir>:
+SYSCALL(chdir)
+    13b2:	b8 09 00 00 00       	mov    $0x9,%eax
+    13b7:	cd 40                	int    $0x40
+    13b9:	c3                   	ret    
+
+000013ba <dup>:
+SYSCALL(dup)
+    13ba:	b8 0a 00 00 00       	mov    $0xa,%eax
+    13bf:	cd 40                	int    $0x40
+    13c1:	c3                   	ret    
+
+000013c2 <getpid>:
+SYSCALL(getpid)
+    13c2:	b8 0b 00 00 00       	mov    $0xb,%eax
+    13c7:	cd 40                	int    $0x40
+    13c9:	c3                   	ret    
+
+000013ca <sbrk>:
+SYSCALL(sbrk)
+    13ca:	b8 0c 00 00 00       	mov    $0xc,%eax
+    13cf:	cd 40                	int    $0x40
+    13d1:	c3                   	ret    
+
+000013d2 <sleep>:
+SYSCALL(sleep)
+    13d2:	b8 0d 00 00 00       	mov    $0xd,%eax
+    13d7:	cd 40                	int    $0x40
+    13d9:	c3                   	ret    
+
+000013da <uptime>:
+SYSCALL(uptime)
+    13da:	b8 0e 00 00 00       	mov    $0xe,%eax
+    13df:	cd 40                	int    $0x40
+    13e1:	c3                   	ret    
+
+000013e2 <shm_open>:
+SYSCALL(shm_open)
+    13e2:	b8 16 00 00 00       	mov    $0x16,%eax
+    13e7:	cd 40                	int    $0x40
+    13e9:	c3                   	ret    
+
+000013ea <shm_close>:
+SYSCALL(shm_close)	
+    13ea:	b8 17 00 00 00       	mov    $0x17,%eax
+    13ef:	cd 40                	int    $0x40
+    13f1:	c3                   	ret    
+    13f2:	66 90                	xchg   %ax,%ax
+    13f4:	66 90                	xchg   %ax,%ax
+    13f6:	66 90                	xchg   %ax,%ax
+    13f8:	66 90                	xchg   %ax,%ax
+    13fa:	66 90                	xchg   %ax,%ax
+    13fc:	66 90                	xchg   %ax,%ax
+    13fe:	66 90                	xchg   %ax,%ax
+
+00001400 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1400:	55                   	push   %ebp
+    1401:	89 e5                	mov    %esp,%ebp
+    1403:	57                   	push   %edi
+    1404:	56                   	push   %esi
+    1405:	89 c6                	mov    %eax,%esi
+    1407:	53                   	push   %ebx
+    1408:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    140b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    140e:	85 db                	test   %ebx,%ebx
+    1410:	74 09                	je     141b <printint+0x1b>
+    1412:	89 d0                	mov    %edx,%eax
+    1414:	c1 e8 1f             	shr    $0x1f,%eax
+    1417:	84 c0                	test   %al,%al
+    1419:	75 75                	jne    1490 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    141b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    141d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1424:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1427:	31 ff                	xor    %edi,%edi
+    1429:	89 ce                	mov    %ecx,%esi
+    142b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    142e:	eb 02                	jmp    1432 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1430:	89 cf                	mov    %ecx,%edi
+    1432:	31 d2                	xor    %edx,%edx
+    1434:	f7 f6                	div    %esi
+    1436:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1439:	0f b6 92 80 18 00 00 	movzbl 0x1880(%edx),%edx
+  }while((x /= base) != 0);
+    1440:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1442:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1445:	75 e9                	jne    1430 <printint+0x30>
+  if(neg)
+    1447:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    144a:	89 c8                	mov    %ecx,%eax
+    144c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    144f:	85 d2                	test   %edx,%edx
+    1451:	74 08                	je     145b <printint+0x5b>
+    buf[i++] = '-';
+    1453:	8d 4f 02             	lea    0x2(%edi),%ecx
+    1456:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    145b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    145e:	66 90                	xchg   %ax,%ax
+    1460:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    1465:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    1468:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    146f:	00 
+    1470:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1474:	89 34 24             	mov    %esi,(%esp)
+    1477:	88 45 d7             	mov    %al,-0x29(%ebp)
+    147a:	e8 e3 fe ff ff       	call   1362 <write>
+  while(--i >= 0)
+    147f:	83 ff ff             	cmp    $0xffffffff,%edi
+    1482:	75 dc                	jne    1460 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    1484:	83 c4 4c             	add    $0x4c,%esp
+    1487:	5b                   	pop    %ebx
+    1488:	5e                   	pop    %esi
+    1489:	5f                   	pop    %edi
+    148a:	5d                   	pop    %ebp
+    148b:	c3                   	ret    
+    148c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    1490:	89 d0                	mov    %edx,%eax
+    1492:	f7 d8                	neg    %eax
+    neg = 1;
+    1494:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    149b:	eb 87                	jmp    1424 <printint+0x24>
+    149d:	8d 76 00             	lea    0x0(%esi),%esi
+
+000014a0 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    14a0:	55                   	push   %ebp
+    14a1:	89 e5                	mov    %esp,%ebp
+    14a3:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    14a4:	31 ff                	xor    %edi,%edi
+{
+    14a6:	56                   	push   %esi
+    14a7:	53                   	push   %ebx
+    14a8:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    14ab:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    14ae:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    14b1:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    14b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    14b7:	0f b6 13             	movzbl (%ebx),%edx
+    14ba:	83 c3 01             	add    $0x1,%ebx
+    14bd:	84 d2                	test   %dl,%dl
+    14bf:	75 39                	jne    14fa <printf+0x5a>
+    14c1:	e9 c2 00 00 00       	jmp    1588 <printf+0xe8>
+    14c6:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    14c8:	83 fa 25             	cmp    $0x25,%edx
+    14cb:	0f 84 bf 00 00 00    	je     1590 <printf+0xf0>
+  write(fd, &c, 1);
+    14d1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    14d4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14db:	00 
+    14dc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14e0:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    14e3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    14e6:	e8 77 fe ff ff       	call   1362 <write>
+    14eb:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    14ee:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    14f2:	84 d2                	test   %dl,%dl
+    14f4:	0f 84 8e 00 00 00    	je     1588 <printf+0xe8>
+    if(state == 0){
+    14fa:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    14fc:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    14ff:	74 c7                	je     14c8 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1501:	83 ff 25             	cmp    $0x25,%edi
+    1504:	75 e5                	jne    14eb <printf+0x4b>
+      if(c == 'd'){
+    1506:	83 fa 64             	cmp    $0x64,%edx
+    1509:	0f 84 31 01 00 00    	je     1640 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    150f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1514:	83 f8 70             	cmp    $0x70,%eax
+    1517:	0f 84 83 00 00 00    	je     15a0 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    151d:	83 fa 73             	cmp    $0x73,%edx
+    1520:	0f 84 a2 00 00 00    	je     15c8 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1526:	83 fa 63             	cmp    $0x63,%edx
+    1529:	0f 84 35 01 00 00    	je     1664 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    152f:	83 fa 25             	cmp    $0x25,%edx
+    1532:	0f 84 e0 00 00 00    	je     1618 <printf+0x178>
+  write(fd, &c, 1);
+    1538:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    153b:	83 c3 01             	add    $0x1,%ebx
+    153e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1545:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    1546:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    1548:	89 44 24 04          	mov    %eax,0x4(%esp)
+    154c:	89 34 24             	mov    %esi,(%esp)
+    154f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    1552:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    1556:	e8 07 fe ff ff       	call   1362 <write>
+        putc(fd, c);
+    155b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    155e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    1561:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1568:	00 
+    1569:	89 44 24 04          	mov    %eax,0x4(%esp)
+    156d:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    1570:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    1573:	e8 ea fd ff ff       	call   1362 <write>
+  for(i = 0; fmt[i]; i++){
+    1578:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    157c:	84 d2                	test   %dl,%dl
+    157e:	0f 85 76 ff ff ff    	jne    14fa <printf+0x5a>
+    1584:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    1588:	83 c4 3c             	add    $0x3c,%esp
+    158b:	5b                   	pop    %ebx
+    158c:	5e                   	pop    %esi
+    158d:	5f                   	pop    %edi
+    158e:	5d                   	pop    %ebp
+    158f:	c3                   	ret    
+        state = '%';
+    1590:	bf 25 00 00 00       	mov    $0x25,%edi
+    1595:	e9 51 ff ff ff       	jmp    14eb <printf+0x4b>
+    159a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    15a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    15a3:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    15a8:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    15aa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    15b1:	8b 10                	mov    (%eax),%edx
+    15b3:	89 f0                	mov    %esi,%eax
+    15b5:	e8 46 fe ff ff       	call   1400 <printint>
+        ap++;
+    15ba:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15be:	e9 28 ff ff ff       	jmp    14eb <printf+0x4b>
+    15c3:	90                   	nop
+    15c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    15c8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    15cb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    15cf:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    15d1:	b8 79 18 00 00       	mov    $0x1879,%eax
+    15d6:	85 ff                	test   %edi,%edi
+    15d8:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    15db:	0f b6 07             	movzbl (%edi),%eax
+    15de:	84 c0                	test   %al,%al
+    15e0:	74 2a                	je     160c <printf+0x16c>
+    15e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    15e8:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    15eb:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    15ee:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    15f1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    15f8:	00 
+    15f9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15fd:	89 34 24             	mov    %esi,(%esp)
+    1600:	e8 5d fd ff ff       	call   1362 <write>
+        while(*s != 0){
+    1605:	0f b6 07             	movzbl (%edi),%eax
+    1608:	84 c0                	test   %al,%al
+    160a:	75 dc                	jne    15e8 <printf+0x148>
+      state = 0;
+    160c:	31 ff                	xor    %edi,%edi
+    160e:	e9 d8 fe ff ff       	jmp    14eb <printf+0x4b>
+    1613:	90                   	nop
+    1614:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1618:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    161b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    161d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1624:	00 
+    1625:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1629:	89 34 24             	mov    %esi,(%esp)
+    162c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1630:	e8 2d fd ff ff       	call   1362 <write>
+    1635:	e9 b1 fe ff ff       	jmp    14eb <printf+0x4b>
+    163a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    1640:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1643:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    1648:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    164b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1652:	8b 10                	mov    (%eax),%edx
+    1654:	89 f0                	mov    %esi,%eax
+    1656:	e8 a5 fd ff ff       	call   1400 <printint>
+        ap++;
+    165b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    165f:	e9 87 fe ff ff       	jmp    14eb <printf+0x4b>
+        putc(fd, *ap);
+    1664:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    1667:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    1669:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    166b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1672:	00 
+    1673:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    1676:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    1679:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    167c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1680:	e8 dd fc ff ff       	call   1362 <write>
+        ap++;
+    1685:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    1689:	e9 5d fe ff ff       	jmp    14eb <printf+0x4b>
+    168e:	66 90                	xchg   %ax,%ax
+
+00001690 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    1690:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1691:	a1 80 1b 00 00       	mov    0x1b80,%eax
+{
+    1696:	89 e5                	mov    %esp,%ebp
+    1698:	57                   	push   %edi
+    1699:	56                   	push   %esi
+    169a:	53                   	push   %ebx
+    169b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    169e:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    16a0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16a3:	39 d0                	cmp    %edx,%eax
+    16a5:	72 11                	jb     16b8 <free+0x28>
+    16a7:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16a8:	39 c8                	cmp    %ecx,%eax
+    16aa:	72 04                	jb     16b0 <free+0x20>
+    16ac:	39 ca                	cmp    %ecx,%edx
+    16ae:	72 10                	jb     16c0 <free+0x30>
+    16b0:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16b2:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16b4:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16b6:	73 f0                	jae    16a8 <free+0x18>
+    16b8:	39 ca                	cmp    %ecx,%edx
+    16ba:	72 04                	jb     16c0 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16bc:	39 c8                	cmp    %ecx,%eax
+    16be:	72 f0                	jb     16b0 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    16c0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    16c3:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    16c6:	39 cf                	cmp    %ecx,%edi
+    16c8:	74 1e                	je     16e8 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    16ca:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    16cd:	8b 48 04             	mov    0x4(%eax),%ecx
+    16d0:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    16d3:	39 f2                	cmp    %esi,%edx
+    16d5:	74 28                	je     16ff <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    16d7:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    16d9:	a3 80 1b 00 00       	mov    %eax,0x1b80
+}
+    16de:	5b                   	pop    %ebx
+    16df:	5e                   	pop    %esi
+    16e0:	5f                   	pop    %edi
+    16e1:	5d                   	pop    %ebp
+    16e2:	c3                   	ret    
+    16e3:	90                   	nop
+    16e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    16e8:	03 71 04             	add    0x4(%ecx),%esi
+    16eb:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    16ee:	8b 08                	mov    (%eax),%ecx
+    16f0:	8b 09                	mov    (%ecx),%ecx
+    16f2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    16f5:	8b 48 04             	mov    0x4(%eax),%ecx
+    16f8:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    16fb:	39 f2                	cmp    %esi,%edx
+    16fd:	75 d8                	jne    16d7 <free+0x47>
+    p->s.size += bp->s.size;
+    16ff:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    1702:	a3 80 1b 00 00       	mov    %eax,0x1b80
+    p->s.size += bp->s.size;
+    1707:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    170a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    170d:	89 10                	mov    %edx,(%eax)
+}
+    170f:	5b                   	pop    %ebx
+    1710:	5e                   	pop    %esi
+    1711:	5f                   	pop    %edi
+    1712:	5d                   	pop    %ebp
+    1713:	c3                   	ret    
+    1714:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    171a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001720 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1720:	55                   	push   %ebp
+    1721:	89 e5                	mov    %esp,%ebp
+    1723:	57                   	push   %edi
+    1724:	56                   	push   %esi
+    1725:	53                   	push   %ebx
+    1726:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1729:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    172c:	8b 1d 80 1b 00 00    	mov    0x1b80,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1732:	8d 48 07             	lea    0x7(%eax),%ecx
+    1735:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1738:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    173a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    173d:	0f 84 9b 00 00 00    	je     17de <malloc+0xbe>
+    1743:	8b 13                	mov    (%ebx),%edx
+    1745:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    1748:	39 fe                	cmp    %edi,%esi
+    174a:	76 64                	jbe    17b0 <malloc+0x90>
+    174c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    1753:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    1758:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    175b:	eb 0e                	jmp    176b <malloc+0x4b>
+    175d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1760:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    1762:	8b 78 04             	mov    0x4(%eax),%edi
+    1765:	39 fe                	cmp    %edi,%esi
+    1767:	76 4f                	jbe    17b8 <malloc+0x98>
+    1769:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    176b:	3b 15 80 1b 00 00    	cmp    0x1b80,%edx
+    1771:	75 ed                	jne    1760 <malloc+0x40>
+  if(nu < 4096)
+    1773:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1776:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    177c:	bf 00 10 00 00       	mov    $0x1000,%edi
+    1781:	0f 43 fe             	cmovae %esi,%edi
+    1784:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    1787:	89 04 24             	mov    %eax,(%esp)
+    178a:	e8 3b fc ff ff       	call   13ca <sbrk>
+  if(p == (char*)-1)
+    178f:	83 f8 ff             	cmp    $0xffffffff,%eax
+    1792:	74 18                	je     17ac <malloc+0x8c>
+  hp->s.size = nu;
+    1794:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    1797:	83 c0 08             	add    $0x8,%eax
+    179a:	89 04 24             	mov    %eax,(%esp)
+    179d:	e8 ee fe ff ff       	call   1690 <free>
+  return freep;
+    17a2:	8b 15 80 1b 00 00    	mov    0x1b80,%edx
+      if((p = morecore(nunits)) == 0)
+    17a8:	85 d2                	test   %edx,%edx
+    17aa:	75 b4                	jne    1760 <malloc+0x40>
+        return 0;
+    17ac:	31 c0                	xor    %eax,%eax
+    17ae:	eb 20                	jmp    17d0 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    17b0:	89 d0                	mov    %edx,%eax
+    17b2:	89 da                	mov    %ebx,%edx
+    17b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    17b8:	39 fe                	cmp    %edi,%esi
+    17ba:	74 1c                	je     17d8 <malloc+0xb8>
+        p->s.size -= nunits;
+    17bc:	29 f7                	sub    %esi,%edi
+    17be:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    17c1:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    17c4:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    17c7:	89 15 80 1b 00 00    	mov    %edx,0x1b80
+      return (void*)(p + 1);
+    17cd:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    17d0:	83 c4 1c             	add    $0x1c,%esp
+    17d3:	5b                   	pop    %ebx
+    17d4:	5e                   	pop    %esi
+    17d5:	5f                   	pop    %edi
+    17d6:	5d                   	pop    %ebp
+    17d7:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    17d8:	8b 08                	mov    (%eax),%ecx
+    17da:	89 0a                	mov    %ecx,(%edx)
+    17dc:	eb e9                	jmp    17c7 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    17de:	c7 05 80 1b 00 00 84 	movl   $0x1b84,0x1b80
+    17e5:	1b 00 00 
+    base.s.size = 0;
+    17e8:	ba 84 1b 00 00       	mov    $0x1b84,%edx
+    base.s.ptr = freep = prevp = &base;
+    17ed:	c7 05 84 1b 00 00 84 	movl   $0x1b84,0x1b84
+    17f4:	1b 00 00 
+    base.s.size = 0;
+    17f7:	c7 05 88 1b 00 00 00 	movl   $0x0,0x1b88
+    17fe:	00 00 00 
+    1801:	e9 46 ff ff ff       	jmp    174c <malloc+0x2c>
+    1806:	66 90                	xchg   %ax,%ax
+    1808:	66 90                	xchg   %ax,%ax
+    180a:	66 90                	xchg   %ax,%ax
+    180c:	66 90                	xchg   %ax,%ax
+    180e:	66 90                	xchg   %ax,%ax
+
+00001810 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1810:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1811:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1816:	89 e5                	mov    %esp,%ebp
+    1818:	8b 55 08             	mov    0x8(%ebp),%edx
+    181b:	90                   	nop
+    181c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1820:	89 c8                	mov    %ecx,%eax
+    1822:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1825:	85 c0                	test   %eax,%eax
+    1827:	75 f7                	jne    1820 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1829:	0f ae f0             	mfence 
+}
+    182c:	5d                   	pop    %ebp
+    182d:	c3                   	ret    
+    182e:	66 90                	xchg   %ax,%ax
+
+00001830 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1830:	55                   	push   %ebp
+    1831:	89 e5                	mov    %esp,%ebp
+    1833:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1836:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1839:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    183f:	5d                   	pop    %ebp
+    1840:	c3                   	ret    
diff --git a/cat.c b/cat.c
index 68b1b8d..5ddc820 100644
--- a/cat.c
+++ b/cat.c
@@ -12,12 +12,12 @@ cat(int fd)
   while((n = read(fd, buf, sizeof(buf))) > 0) {
     if (write(1, buf, n) != n) {
       printf(1, "cat: write error\n");
-      exit(3);
+      exit();
     }
   }
   if(n < 0){
     printf(1, "cat: read error\n");
-    exit(4);
+    exit();
   }
 }
 
@@ -28,16 +28,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     cat(0);
-    exit(1);
+    exit();
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "cat: cannot open %s\n", argv[i]);
-      exit(2);
+      exit();
     }
     cat(fd);
     close(fd);
   }
-  exit(0);
+  exit();
 }
diff --git a/cat.d b/cat.d
new file mode 100644
index 0000000..8f55acc
--- /dev/null
+++ b/cat.d
@@ -0,0 +1 @@
+cat.o: cat.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/cat.o b/cat.o
new file mode 100644
index 0000000..1c152ce
Binary files /dev/null and b/cat.o differ
diff --git a/cat.sym b/cat.sym
new file mode 100644
index 0000000..8004974
--- /dev/null
+++ b/cat.sym
@@ -0,0 +1,64 @@
+00001000 .text
+00001841 .rodata
+00001894 .eh_frame
+00001b80 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 cat.c
+00000000 ulib.c
+00000000 printf.c
+00001400 printint
+00001880 digits.1359
+00000000 umalloc.c
+00001b80 freep
+00001b84 base
+00000000 uspinlock.c
+00001120 strcpy
+000014a0 printf
+00001310 memmove
+0000138a mknod
+000013e2 shm_open
+00001230 gets
+000013c2 getpid
+00001090 cat
+00001720 malloc
+000013d2 sleep
+00001352 pipe
+00001362 write
+0000139a fstat
+00001372 kill
+000013b2 chdir
+0000137a exec
+0000134a wait
+0000135a read
+00001392 unlink
+00001810 uacquire
+0000133a fork
+000013ca sbrk
+000013ea shm_close
+000013da uptime
+00001b6c __bss_start
+000011d0 memset
+00001000 main
+00001150 strcmp
+000013ba dup
+00001ba0 buf
+00001290 stat
+00001b6c _edata
+00001da0 _end
+000013a2 link
+00001342 exit
+000012e0 atoi
+000011a0 strlen
+00001382 open
+000011f0 strchr
+000013aa mkdir
+0000136a close
+00001830 urelease
+00001690 free
diff --git a/code.diff b/code.diff
index c889659..74fcd4b 100644
--- a/code.diff
+++ b/code.diff
@@ -1,2919 +1,16128 @@
+diff --git a/.cvsignore b/.cvsignore
+deleted file mode 100644
+index 081a43c..0000000
+--- a/.cvsignore
++++ /dev/null
+@@ -1,16 +0,0 @@
+-*.asm
+-*.d
+-*.sym
+-_*
+-kernel
+-user1
+-userfs
+-usertests
+-xv6.img
+-vectors.S
+-bochsout.txt
+-bootblock
+-bootother
+-bootother.out
+-parport.out
+-fmt
+diff --git a/.dir-locals.el b/.dir-locals.el
+deleted file mode 100644
+index da72247..0000000
+--- a/.dir-locals.el
++++ /dev/null
+@@ -1,4 +0,0 @@
+-((c-mode
+-  (indent-tabs-mode . nil)
+-  (c-file-style . "bsd")
+-  (c-basic-offset . 2)))
+diff --git a/.gdbinit.tmpl b/.gdbinit.tmpl
+index f71681a..ac7a259 100644
+--- a/.gdbinit.tmpl
++++ b/.gdbinit.tmpl
+@@ -24,4 +24,4 @@ echo + target remote localhost:1234\n
+ target remote localhost:1234
+ 
+ echo + symbol-file kernel\n
+-symbol-file kernel
++symbol-file kernel
+\ No newline at end of file
+diff --git a/.gitignore b/.gitignore
+deleted file mode 100644
+index 3e2c9de..0000000
+--- a/.gitignore
++++ /dev/null
+@@ -1,16 +0,0 @@
+-*~
+-_*
+-*.o
+-*.d
+-*.asm
+-*.sym
+-*.img
+-vectors.S
+-bootblock
+-entryother
+-initcode
+-initcode.out
+-kernel
+-kernelmemfs
+-mkfs
+-.gdbinit
+diff --git a/.idea/xv6.iml b/.idea/xv6.iml
+index 5aac3dd..771e54c 100644
+--- a/.idea/xv6.iml
++++ b/.idea/xv6.iml
+@@ -1,2 +1,2 @@
+ <?xml version="1.0" encoding="UTF-8"?>
+-<module classpath="External" external.linked.project.id="xv6" external.linked.project.path="C:\Users\Kotori\Desktop\Code Projects\School\xv6\xv6" external.root.project.path="$MODULE_DIR$" external.system.id="Makefile" type="CPP_MODULE" version="4" />
+\ No newline at end of file
++<module classpath="External" type="CPP_MODULE" version="4" />
+\ No newline at end of file
+diff --git a/BUGS b/BUGS
+deleted file mode 100644
+index 81d2220..0000000
+--- a/BUGS
++++ /dev/null
+@@ -1,7 +0,0 @@
+-formatting:
+-	need to fix PAGEBREAK mechanism
+-
+-sh:
+-	can't always runcmd in child -- breaks cd.
+-	maybe should hard-code PATH=/ ?
+-
+diff --git a/LICENSE b/LICENSE
+deleted file mode 100644
+index 422c0cc..0000000
+--- a/LICENSE
++++ /dev/null
+@@ -1,24 +0,0 @@
+-The xv6 software is:
+-
+-Copyright (c) 2006-2018 Frans Kaashoek, Robert Morris, Russ Cox,
+-                        Massachusetts Institute of Technology
+-
+-Permission is hereby granted, free of charge, to any person obtaining
+-a copy of this software and associated documentation files (the
+-"Software"), to deal in the Software without restriction, including
+-without limitation the rights to use, copy, modify, merge, publish,
+-distribute, sublicense, and/or sell copies of the Software, and to
+-permit persons to whom the Software is furnished to do so, subject to
+-the following conditions:
+-
+-The above copyright notice and this permission notice shall be
+-included in all copies or substantial portions of the Software.
+-
+-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-
 diff --git a/Makefile b/Makefile
-index 09d790c..04d74d5 100644
+deleted file mode 100644
+index 04d74d5..0000000
 --- a/Makefile
-+++ b/Makefile
-@@ -181,6 +181,7 @@ UPROGS=\
- 	_usertests\
- 	_wc\
- 	_zombie\
-+	_lab1\
- 
- fs.img: mkfs README $(UPROGS)
- 	./mkfs fs.img README $(UPROGS)
-diff --git a/cat.c b/cat.c
-index 5ddc820..68b1b8d 100644
---- a/cat.c
-+++ b/cat.c
-@@ -12,12 +12,12 @@ cat(int fd)
-   while((n = read(fd, buf, sizeof(buf))) > 0) {
-     if (write(1, buf, n) != n) {
-       printf(1, "cat: write error\n");
--      exit();
-+      exit(3);
-     }
-   }
-   if(n < 0){
-     printf(1, "cat: read error\n");
--    exit();
-+    exit(4);
-   }
- }
- 
-@@ -28,16 +28,16 @@ main(int argc, char *argv[])
- 
-   if(argc <= 1){
-     cat(0);
--    exit();
-+    exit(1);
-   }
- 
-   for(i = 1; i < argc; i++){
-     if((fd = open(argv[i], 0)) < 0){
-       printf(1, "cat: cannot open %s\n", argv[i]);
--      exit();
-+      exit(2);
-     }
-     cat(fd);
-     close(fd);
-   }
--  exit();
-+  exit(0);
- }
-diff --git a/cuth b/cuth
-old mode 100755
-new mode 100644
-diff --git a/defs.h b/defs.h
-index 82fb982..d1934ca 100644
---- a/defs.h
-+++ b/defs.h
-@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
- //PAGEBREAK: 16
- // proc.c
- int             cpuid(void);
--void            exit(void);
-+void            exit(int status);
- int             fork(void);
- int             growproc(int);
- int             kill(int);
-@@ -117,7 +117,8 @@ void            sched(void);
- void            setproc(struct proc*);
- void            sleep(void*, struct spinlock*);
- void            userinit(void);
--int             wait(void);
-+int             wait(int* status);
-+int             waitpid(int pid, int* status, int options);
- void            wakeup(void*);
- void            yield(void);
- 
-diff --git a/dot-bochsrc b/dot-bochsrc
-old mode 100755
-new mode 100644
-diff --git a/echo.c b/echo.c
-index 806dee0..eed68a0 100644
---- a/echo.c
-+++ b/echo.c
-@@ -9,5 +9,5 @@ main(int argc, char *argv[])
- 
-   for(i = 1; i < argc; i++)
-     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
--  exit();
-+  exit(0);
- }
-diff --git a/forktest.c b/forktest.c
-index 8bc984d..a4b35ed 100644
---- a/forktest.c
-+++ b/forktest.c
-@@ -25,24 +25,24 @@ forktest(void)
-     if(pid < 0)
-       break;
-     if(pid == 0)
--      exit();
-+      exit(4);
-   }
- 
-   if(n == N){
-     printf(1, "fork claimed to work N times!\n", N);
--    exit();
-+    exit(3);
-   }
- 
-   for(; n > 0; n--){
--    if(wait() < 0){
-+    if(wait(NULL) < 0){
-       printf(1, "wait stopped early\n");
--      exit();
-+      exit(2);
-     }
-   }
- 
--  if(wait() != -1){
-+  if(wait(NULL) != -1){
-     printf(1, "wait got too many\n");
--    exit();
-+    exit(1);
-   }
- 
-   printf(1, "fork test OK\n");
-@@ -52,5 +52,5 @@ int
- main(void)
- {
-   forktest();
--  exit();
-+  exit(0);
- }
-diff --git a/grep.c b/grep.c
-index adc4835..4be3256 100644
---- a/grep.c
-+++ b/grep.c
-@@ -43,24 +43,24 @@ main(int argc, char *argv[])
- 
-   if(argc <= 1){
-     printf(2, "usage: grep pattern [file ...]\n");
--    exit();
-+    exit(1);
-   }
-   pattern = argv[1];
- 
-   if(argc <= 2){
-     grep(pattern, 0);
--    exit();
-+    exit(2);
-   }
- 
-   for(i = 2; i < argc; i++){
-     if((fd = open(argv[i], 0)) < 0){
-       printf(1, "grep: cannot open %s\n", argv[i]);
--      exit();
-+      exit(3);
-     }
-     grep(pattern, fd);
-     close(fd);
-   }
--  exit();
-+  exit(0);
- }
- 
- // Regexp matcher from Kernighan & Pike,
-diff --git a/init.c b/init.c
-index 046b551..bc6547f 100644
---- a/init.c
-+++ b/init.c
-@@ -24,14 +24,14 @@ main(void)
-     pid = fork();
-     if(pid < 0){
-       printf(1, "init: fork failed\n");
--      exit();
-+      exit(2);
-     }
-     if(pid == 0){
-       exec("sh", argv);
-       printf(1, "init: exec sh failed\n");
--      exit();
-+      exit(1);
-     }
--    while((wpid=wait()) >= 0 && wpid != pid)
-+    while((wpid=wait(NULL)) >= 0 && wpid != pid)
-       printf(1, "zombie!\n");
-   }
- }
-diff --git a/kill.c b/kill.c
-index 364f6af..875916c 100644
---- a/kill.c
-+++ b/kill.c
-@@ -9,9 +9,9 @@ main(int argc, char **argv)
- 
-   if(argc < 2){
-     printf(2, "usage: kill pid...\n");
--    exit();
-+    exit(1);
-   }
-   for(i=1; i<argc; i++)
-     kill(atoi(argv[i]));
--  exit();
-+  exit(0);
- }
-diff --git a/lab1.c b/lab1.c
-index 89668ce..2192a52 100644
---- a/lab1.c
-+++ b/lab1.c
-@@ -25,7 +25,7 @@ int main(int argc, char **argv) {
-     if(pid > 0)
-     {
-         waitpid(pid, NULL, 0);
--        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);
-+        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
-         exit(0);
-     }
- 
-diff --git a/ln.c b/ln.c
-index cf8a64e..fb17c3b 100644
---- a/ln.c
-+++ b/ln.c
-@@ -7,9 +7,9 @@ main(int argc, char *argv[])
- {
-   if(argc != 3){
-     printf(2, "Usage: ln old new\n");
--    exit();
-+    exit(1);
-   }
-   if(link(argv[1], argv[2]) < 0)
-     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
--  exit();
-+  exit(0);
- }
-diff --git a/ls.c b/ls.c
-index 2862913..6bf943b 100644
---- a/ls.c
-+++ b/ls.c
-@@ -77,9 +77,9 @@ main(int argc, char *argv[])
- 
-   if(argc < 2){
-     ls(".");
--    exit();
-+    exit(1);
-   }
-   for(i=1; i<argc; i++)
-     ls(argv[i]);
--  exit();
-+  exit(0);
- }
-diff --git a/mkdir.c b/mkdir.c
-index 6e4c954..2d90781 100644
---- a/mkdir.c
-+++ b/mkdir.c
-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
- 
-   if(argc < 2){
-     printf(2, "Usage: mkdir files...\n");
--    exit();
-+    exit(1);
-   }
- 
-   for(i = 1; i < argc; i++){
-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
-     }
-   }
- 
--  exit();
-+  exit(0);
- }
-diff --git a/pr.pl b/pr.pl
-old mode 100755
-new mode 100644
-diff --git a/printpcs b/printpcs
-old mode 100755
-new mode 100644
-diff --git a/proc.c b/proc.c
-index 806b1b1..84b335f 100644
---- a/proc.c
-+++ b/proc.c
-@@ -1,3 +1,5 @@
-+#include <stddef.h>
-+
- #include "types.h"
- #include "defs.h"
- #include "param.h"
-@@ -8,61 +10,61 @@
- #include "spinlock.h"
- 
- struct {
--  struct spinlock lock;
--  struct proc proc[NPROC];
-+    struct spinlock lock;
-+    struct proc proc[NPROC];
- } ptable;
- 
- static struct proc *initproc;
- 
- int nextpid = 1;
-+
- extern void forkret(void);
-+
- extern void trapret(void);
- 
- static void wakeup1(void *chan);
- 
- void
--pinit(void)
--{
--  initlock(&ptable.lock, "ptable");
-+pinit(void) {
-+    initlock(&ptable.lock, "ptable");
- }
- 
- // Must be called with interrupts disabled
- int
- cpuid() {
--  return mycpu()-cpus;
-+    return mycpu() - cpus;
- }
- 
- // Must be called with interrupts disabled to avoid the caller being
- // rescheduled between reading lapicid and running through the loop.
--struct cpu*
--mycpu(void)
--{
--  int apicid, i;
--  
--  if(readeflags()&FL_IF)
--    panic("mycpu called with interrupts enabled\n");
--  
--  apicid = lapicid();
--  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
--  // a reverse map, or reserve a register to store &cpus[i].
--  for (i = 0; i < ncpu; ++i) {
--    if (cpus[i].apicid == apicid)
--      return &cpus[i];
--  }
--  panic("unknown apicid\n");
-+struct cpu *
-+mycpu(void) {
-+    int apicid, i;
-+
-+    if (readeflags() & FL_IF)
-+        panic("mycpu called with interrupts enabled\n");
-+
-+    apicid = lapicid();
-+    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
-+    // a reverse map, or reserve a register to store &cpus[i].
-+    for (i = 0; i < ncpu; ++i) {
-+        if (cpus[i].apicid == apicid)
-+            return &cpus[i];
-+    }
-+    panic("unknown apicid\n");
- }
- 
- // Disable interrupts so that we are not rescheduled
- // while reading proc from the cpu structure
--struct proc*
-+struct proc *
- myproc(void) {
--  struct cpu *c;
--  struct proc *p;
--  pushcli();
--  c = mycpu();
--  p = c->proc;
--  popcli();
--  return p;
-+    struct cpu *c;
-+    struct proc *p;
-+    pushcli();
-+    c = mycpu();
-+    p = c->proc;
-+    popcli();
-+    return p;
- }
- 
- //PAGEBREAK: 32
-@@ -70,245 +72,295 @@ myproc(void) {
- // If found, change state to EMBRYO and initialize
- // state required to run in the kernel.
- // Otherwise return 0.
--static struct proc*
--allocproc(void)
--{
--  struct proc *p;
--  char *sp;
-+static struct proc *
-+allocproc(void) {
-+    struct proc *p;
-+    char *sp;
- 
--  acquire(&ptable.lock);
-+    acquire(&ptable.lock);
- 
--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
--    if(p->state == UNUSED)
--      goto found;
-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-+        if (p->state == UNUSED)
-+            goto found;
- 
--  release(&ptable.lock);
--  return 0;
-+    release(&ptable.lock);
-+    return 0;
- 
--found:
--  p->state = EMBRYO;
--  p->pid = nextpid++;
-+    found:
-+    p->state = EMBRYO;
-+    p->pid = nextpid++;
- 
--  release(&ptable.lock);
-+    release(&ptable.lock);
- 
--  // Allocate kernel stack.
--  if((p->kstack = kalloc()) == 0){
--    p->state = UNUSED;
--    return 0;
--  }
--  sp = p->kstack + KSTACKSIZE;
-+    // Allocate kernel stack.
-+    if ((p->kstack = kalloc()) == 0) {
-+        p->state = UNUSED;
-+        return 0;
-+    }
-+    sp = p->kstack + KSTACKSIZE;
- 
--  // Leave room for trap frame.
--  sp -= sizeof *p->tf;
--  p->tf = (struct trapframe*)sp;
-+    // Leave room for trap frame.
-+    sp -= sizeof *p->tf;
-+    p->tf = (struct trapframe *) sp;
- 
--  // Set up new context to start executing at forkret,
--  // which returns to trapret.
--  sp -= 4;
--  *(uint*)sp = (uint)trapret;
-+    // Set up new context to start executing at forkret,
-+    // which returns to trapret.
-+    sp -= 4;
-+    *(uint *) sp = (uint) trapret;
- 
--  sp -= sizeof *p->context;
--  p->context = (struct context*)sp;
--  memset(p->context, 0, sizeof *p->context);
--  p->context->eip = (uint)forkret;
-+    sp -= sizeof *p->context;
-+    p->context = (struct context *) sp;
-+    memset(p->context, 0, sizeof *p->context);
-+    p->context->eip = (uint) forkret;
- 
--  return p;
-+    return p;
- }
- 
- //PAGEBREAK: 32
- // Set up first user process.
- void
--userinit(void)
--{
--  struct proc *p;
--  extern char _binary_initcode_start[], _binary_initcode_size[];
++++ /dev/null
+@@ -1,287 +0,0 @@
+-OBJS = \
+-	bio.o\
+-	console.o\
+-	exec.o\
+-	file.o\
+-	fs.o\
+-	ide.o\
+-	ioapic.o\
+-	kalloc.o\
+-	kbd.o\
+-	lapic.o\
+-	log.o\
+-	main.o\
+-	mp.o\
+-	picirq.o\
+-	pipe.o\
+-	proc.o\
+-	sleeplock.o\
+-	spinlock.o\
+-	string.o\
+-	swtch.o\
+-	syscall.o\
+-	sysfile.o\
+-	sysproc.o\
+-	trapasm.o\
+-	trap.o\
+-	uart.o\
+-	vectors.o\
+-	vm.o\
 -
--  p = allocproc();
--  
--  initproc = p;
--  if((p->pgdir = setupkvm()) == 0)
--    panic("userinit: out of memory?");
--  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
--  p->sz = PGSIZE;
--  memset(p->tf, 0, sizeof(*p->tf));
--  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
--  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
--  p->tf->es = p->tf->ds;
--  p->tf->ss = p->tf->ds;
--  p->tf->eflags = FL_IF;
--  p->tf->esp = PGSIZE;
--  p->tf->eip = 0;  // beginning of initcode.S
--
--  safestrcpy(p->name, "initcode", sizeof(p->name));
--  p->cwd = namei("/");
--
--  // this assignment to p->state lets other cores
--  // run this process. the acquire forces the above
--  // writes to be visible, and the lock is also needed
--  // because the assignment might not be atomic.
--  acquire(&ptable.lock);
--
--  p->state = RUNNABLE;
--
--  release(&ptable.lock);
-+userinit(void) {
-+    struct proc *p;
-+    extern char _binary_initcode_start[], _binary_initcode_size[];
-+
-+    p = allocproc();
-+
-+    initproc = p;
-+    if ((p->pgdir = setupkvm()) == 0)
-+        panic("userinit: out of memory?");
-+    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
-+    p->sz = PGSIZE;
-+    memset(p->tf, 0, sizeof(*p->tf));
-+    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
-+    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
-+    p->tf->es = p->tf->ds;
-+    p->tf->ss = p->tf->ds;
-+    p->tf->eflags = FL_IF;
-+    p->tf->esp = PGSIZE;
-+    p->tf->eip = 0;  // beginning of initcode.S
-+
-+    safestrcpy(p->name, "initcode", sizeof(p->name));
-+    p->cwd = namei("/");
-+
-+    // this assignment to p->state lets other cores
-+    // run this process. the acquire forces the above
-+    // writes to be visible, and the lock is also needed
-+    // because the assignment might not be atomic.
-+    acquire(&ptable.lock);
-+
-+    p->state = RUNNABLE;
-+
-+    release(&ptable.lock);
- }
- 
- // Grow current process's memory by n bytes.
- // Return 0 on success, -1 on failure.
- int
--growproc(int n)
--{
--  uint sz;
--  struct proc *curproc = myproc();
+-# Cross-compiling (e.g., on Mac OS X)
+-# TOOLPREFIX = i386-jos-elf
 -
--  sz = curproc->sz;
--  if(n > 0){
--    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
--      return -1;
--  } else if(n < 0){
--    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
--      return -1;
--  }
--  curproc->sz = sz;
--  switchuvm(curproc);
--  return 0;
-+growproc(int n) {
-+    uint sz;
-+    struct proc *curproc = myproc();
-+
-+    sz = curproc->sz;
-+    if (n > 0) {
-+        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
-+            return -1;
-+    } else if (n < 0) {
-+        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
-+            return -1;
-+    }
-+    curproc->sz = sz;
-+    switchuvm(curproc);
-+    return 0;
- }
- 
- // Create a new process copying p as the parent.
- // Sets up stack to return as if from system call.
- // Caller must set state of returned proc to RUNNABLE.
- int
--fork(void)
--{
--  int i, pid;
--  struct proc *np;
--  struct proc *curproc = myproc();
+-# Using native tools (e.g., on X86 Linux)
+-#TOOLPREFIX = 
 -
--  // Allocate process.
--  if((np = allocproc()) == 0){
--    return -1;
--  }
-+fork(void) {
-+    int i, pid;
-+    struct proc *np;
-+    struct proc *curproc = myproc();
-+
-+    // Allocate process.
-+    if ((np = allocproc()) == 0) {
-+        return -1;
-+    }
- 
--  // Copy process state from proc.
--  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
--    kfree(np->kstack);
--    np->kstack = 0;
--    np->state = UNUSED;
--    return -1;
--  }
--  np->sz = curproc->sz;
--  np->parent = curproc;
--  *np->tf = *curproc->tf;
-+    // Copy process state from proc.
-+    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
-+        kfree(np->kstack);
-+        np->kstack = 0;
-+        np->state = UNUSED;
-+        return -1;
-+    }
-+    np->sz = curproc->sz;
-+    np->parent = curproc;
-+    *np->tf = *curproc->tf;
- 
--  // Clear %eax so that fork returns 0 in the child.
--  np->tf->eax = 0;
-+    // Clear %eax so that fork returns 0 in the child.
-+    np->tf->eax = 0;
- 
--  for(i = 0; i < NOFILE; i++)
--    if(curproc->ofile[i])
--      np->ofile[i] = filedup(curproc->ofile[i]);
--  np->cwd = idup(curproc->cwd);
-+    for (i = 0; i < NOFILE; i++)
-+        if (curproc->ofile[i])
-+            np->ofile[i] = filedup(curproc->ofile[i]);
-+    np->cwd = idup(curproc->cwd);
- 
--  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
-+    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
- 
--  pid = np->pid;
-+    pid = np->pid;
- 
--  acquire(&ptable.lock);
-+    acquire(&ptable.lock);
- 
--  np->state = RUNNABLE;
-+    np->state = RUNNABLE;
- 
--  release(&ptable.lock);
-+    release(&ptable.lock);
- 
--  return pid;
-+    return pid;
- }
- 
- // Exit the current process.  Does not return.
- // An exited process remains in the zombie state
- // until its parent calls wait() to find out it exited.
- void
--exit(void)
--{
--  struct proc *curproc = myproc();
--  struct proc *p;
--  int fd;
+-# Try to infer the correct TOOLPREFIX if not set
+-ifndef TOOLPREFIX
+-TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+-	then echo 'i386-jos-elf-'; \
+-	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+-	then echo ''; \
+-	else echo "***" 1>&2; \
+-	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+-	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+-	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+-	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+-	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+-	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+-	echo "***" 1>&2; exit 1; fi)
+-endif
 -
--  if(curproc == initproc)
--    panic("init exiting");
+-# If the makefile can't find QEMU, specify its path here
+-# QEMU = qemu-system-i386
 -
--  // Close all open files.
--  for(fd = 0; fd < NOFILE; fd++){
--    if(curproc->ofile[fd]){
--      fileclose(curproc->ofile[fd]);
--      curproc->ofile[fd] = 0;
-+exit(int status) {
-+    struct proc *curproc = myproc();
-+    struct proc *p;
-+    int fd;
-+
-+    curproc->status = status;
-+
-+    if (curproc == initproc)
-+        panic("init exiting");
-+
-+    // Close all open files.
-+    for (fd = 0; fd < NOFILE; fd++) {
-+        if (curproc->ofile[fd]) {
-+            fileclose(curproc->ofile[fd]);
-+            curproc->ofile[fd] = 0;
-+        }
-     }
--  }
- 
--  begin_op();
--  iput(curproc->cwd);
--  end_op();
--  curproc->cwd = 0;
-+    begin_op();
-+    iput(curproc->cwd);
-+    end_op();
-+    curproc->cwd = 0;
- 
--  acquire(&ptable.lock);
-+    acquire(&ptable.lock);
- 
--  // Parent might be sleeping in wait().
--  wakeup1(curproc->parent);
-+    // Parent might be sleeping in wait().
-+    wakeup1(curproc->parent);
- 
--  // Pass abandoned children to init.
--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
--    if(p->parent == curproc){
--      p->parent = initproc;
--      if(p->state == ZOMBIE)
--        wakeup1(initproc);
-+    // Pass abandoned children to init.
-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-+        if (p->parent == curproc) {
-+            p->parent = initproc;
-+            if (p->state == ZOMBIE)
-+                wakeup1(initproc);
-+        }
-     }
--  }
- 
--  // Jump into the scheduler, never to return.
--  curproc->state = ZOMBIE;
--  sched();
--  panic("zombie exit");
-+    // Jump into the scheduler, never to return.
-+    curproc->state = ZOMBIE;
-+    sched();
-+    panic("zombie exit");
- }
- 
- // Wait for a child process to exit and return its pid.
- // Return -1 if this process has no children.
- int
--wait(void)
--{
--  struct proc *p;
--  int havekids, pid;
--  struct proc *curproc = myproc();
--  
--  acquire(&ptable.lock);
--  for(;;){
--    // Scan through table looking for exited children.
--    havekids = 0;
--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
--      if(p->parent != curproc)
--        continue;
--      havekids = 1;
--      if(p->state == ZOMBIE){
--        // Found one.
--        pid = p->pid;
--        kfree(p->kstack);
--        p->kstack = 0;
--        freevm(p->pgdir);
--        p->pid = 0;
--        p->parent = 0;
--        p->name[0] = 0;
--        p->killed = 0;
--        p->state = UNUSED;
--        release(&ptable.lock);
--        return pid;
--      }
--    }
-+wait(int *status) {
-+    struct proc *p;
-+    int havekids, pid;
-+    struct proc *curproc = myproc();
- 
--    // No point waiting if we don't have any children.
--    if(!havekids || curproc->killed){
--      release(&ptable.lock);
--      return -1;
-+    acquire(&ptable.lock);
-+    for (;;) {
-+        // Scan through table looking for exited children.
-+        havekids = 0;
-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-+            if (p->parent != curproc)
-+                continue;
-+            havekids = 1;
-+            if (p->state == ZOMBIE) {
-+                // Found one.
-+                pid = p->pid;
-+                kfree(p->kstack);
-+                p->kstack = 0;
-+                freevm(p->pgdir);
-+                p->pid = 0;
-+                p->parent = 0;
-+                p->name[0] = 0;
-+                p->killed = 0;
-+                p->state = UNUSED;
-+                release(&ptable.lock);
-+                if (status != NULL)
-+                    *status = p->status;
-+                return pid;
-+            }
-+        }
-+
-+        // No point waiting if we don't have any children.
-+        if (!havekids || curproc->killed) {
-+            release(&ptable.lock);
-+            return -1;
-+        }
-+
-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
-     }
-+}
- 
--    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
--    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
--  }
-+// Wait for a child process to exit and return its pid.
-+// Return -1 if this process has no children.
-+int
-+waitpid(int pidBeingSearchedFor, int *status, int options) {
-+    struct proc *p;
-+    int doesProcExist, pidFound;
-+    struct proc *curproc = myproc();
-+    acquire(&ptable.lock);
-+    for (;;) {
-+        // Scan through table looking for exited children.
-+        doesProcExist = 0;
-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-+//            if(p->parent != curproc)
-+//                continue;
-+
-+            if (p->pid != pidBeingSearchedFor)
-+                continue;
-+
-+            doesProcExist = 1;
-+            if (p->state == ZOMBIE) {
-+                // Found one.
-+                pidFound = p->pid;
-+                kfree(p->kstack);
-+                p->kstack = 0;
-+                freevm(p->pgdir);
-+                p->pid = 0;
-+                p->parent = 0;
-+                p->name[0] = 0;
-+                p->killed = 0;
-+                p->state = UNUSED;
-+                release(&ptable.lock);
-+                if (status != NULL)
-+                    *status = p->status;
-+                return pidFound;
-+            }
-+        }
-+
-+//        // No point waiting if we don't have any children.
-+//        if(!havekids || curproc->killed){
-+//            release(&ptable.lock);
-+//            return -1;
-+//        }
-+
-+        if (!doesProcExist || curproc->killed) {
-+            release(&ptable.lock);
-+            return -1;
-+        }
-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
-+    }
- }
- 
- //PAGEBREAK: 42
-@@ -320,39 +372,38 @@ wait(void)
- //  - eventually that process transfers control
- //      via swtch back to the scheduler.
- void
--scheduler(void)
--{
--  struct proc *p;
--  struct cpu *c = mycpu();
--  c->proc = 0;
--  
--  for(;;){
--    // Enable interrupts on this processor.
--    sti();
+-# Try to infer the correct QEMU
+-ifndef QEMU
+-QEMU = $(shell if which qemu > /dev/null; \
+-	then echo qemu; exit; \
+-	elif which qemu-system-i386 > /dev/null; \
+-	then echo qemu-system-i386; exit; \
+-	elif which qemu-system-x86_64 > /dev/null; \
+-	then echo qemu-system-x86_64; exit; \
+-	else \
+-	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+-	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+-	echo "***" 1>&2; \
+-	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+-	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+-	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+-	echo "***" 1>&2; exit 1)
+-endif
 -
--    // Loop over process table looking for process to run.
--    acquire(&ptable.lock);
--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
--      if(p->state != RUNNABLE)
--        continue;
+-CC = $(TOOLPREFIX)gcc
+-AS = $(TOOLPREFIX)gas
+-LD = $(TOOLPREFIX)ld
+-OBJCOPY = $(TOOLPREFIX)objcopy
+-OBJDUMP = $(TOOLPREFIX)objdump
+-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+-CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+-ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+-# FreeBSD ld wants ``elf_i386_fbsd''
+-LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
 -
--      // Switch to chosen process.  It is the process's job
--      // to release ptable.lock and then reacquire it
--      // before jumping back to us.
--      c->proc = p;
--      switchuvm(p);
--      p->state = RUNNING;
+-# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+-CFLAGS += -fno-pie -no-pie
+-endif
+-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+-CFLAGS += -fno-pie -nopie
+-endif
 -
--      swtch(&(c->scheduler), p->context);
--      switchkvm();
+-xv6.img: bootblock kernel
+-	dd if=/dev/zero of=xv6.img count=10000
+-	dd if=bootblock of=xv6.img conv=notrunc
+-	dd if=kernel of=xv6.img seek=1 conv=notrunc
 -
--      // Process is done running for now.
--      // It should have changed its p->state before coming back.
--      c->proc = 0;
--    }
--    release(&ptable.lock);
-+scheduler(void) {
-+    struct proc *p;
-+    struct cpu *c = mycpu();
-+    c->proc = 0;
-+
-+    for (;;) {
-+        // Enable interrupts on this processor.
-+        sti();
-+
-+        // Loop over process table looking for process to run.
-+        acquire(&ptable.lock);
-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-+            if (p->state != RUNNABLE)
-+                continue;
-+
-+            // Switch to chosen process.  It is the process's job
-+            // to release ptable.lock and then reacquire it
-+            // before jumping back to us.
-+            c->proc = p;
-+            switchuvm(p);
-+            p->state = RUNNING;
-+
-+            swtch(&(c->scheduler), p->context);
-+            switchkvm();
-+
-+            // Process is done running for now.
-+            // It should have changed its p->state before coming back.
-+            c->proc = 0;
-+        }
-+        release(&ptable.lock);
- 
--  }
-+    }
- }
- 
- // Enter scheduler.  Must hold only ptable.lock
-@@ -363,137 +414,130 @@ scheduler(void)
- // break in the few places where a lock is held but
- // there's no process.
- void
--sched(void)
--{
--  int intena;
--  struct proc *p = myproc();
--
--  if(!holding(&ptable.lock))
--    panic("sched ptable.lock");
--  if(mycpu()->ncli != 1)
--    panic("sched locks");
--  if(p->state == RUNNING)
--    panic("sched running");
--  if(readeflags()&FL_IF)
--    panic("sched interruptible");
--  intena = mycpu()->intena;
--  swtch(&p->context, mycpu()->scheduler);
--  mycpu()->intena = intena;
-+sched(void) {
-+    int intena;
-+    struct proc *p = myproc();
-+
-+    if (!holding(&ptable.lock))
-+        panic("sched ptable.lock");
-+    if (mycpu()->ncli != 1)
-+        panic("sched locks");
-+    if (p->state == RUNNING)
-+        panic("sched running");
-+    if (readeflags() & FL_IF)
-+        panic("sched interruptible");
-+    intena = mycpu()->intena;
-+    swtch(&p->context, mycpu()->scheduler);
-+    mycpu()->intena = intena;
- }
- 
- // Give up the CPU for one scheduling round.
- void
--yield(void)
--{
--  acquire(&ptable.lock);  //DOC: yieldlock
--  myproc()->state = RUNNABLE;
--  sched();
--  release(&ptable.lock);
-+yield(void) {
-+    acquire(&ptable.lock);  //DOC: yieldlock
-+    myproc()->state = RUNNABLE;
-+    sched();
-+    release(&ptable.lock);
- }
- 
- // A fork child's very first scheduling by scheduler()
- // will swtch here.  "Return" to user space.
- void
--forkret(void)
--{
--  static int first = 1;
--  // Still holding ptable.lock from scheduler.
--  release(&ptable.lock);
--
--  if (first) {
--    // Some initialization functions must be run in the context
--    // of a regular process (e.g., they call sleep), and thus cannot
--    // be run from main().
--    first = 0;
--    iinit(ROOTDEV);
--    initlog(ROOTDEV);
--  }
--
--  // Return to "caller", actually trapret (see allocproc).
-+forkret(void) {
-+    static int first = 1;
-+    // Still holding ptable.lock from scheduler.
-+    release(&ptable.lock);
-+
-+    if (first) {
-+        // Some initialization functions must be run in the context
-+        // of a regular process (e.g., they call sleep), and thus cannot
-+        // be run from main().
-+        first = 0;
-+        iinit(ROOTDEV);
-+        initlog(ROOTDEV);
-+    }
-+
-+    // Return to "caller", actually trapret (see allocproc).
- }
- 
- // Atomically release lock and sleep on chan.
- // Reacquires lock when awakened.
- void
--sleep(void *chan, struct spinlock *lk)
--{
--  struct proc *p = myproc();
--  
--  if(p == 0)
--    panic("sleep");
+-xv6memfs.img: bootblock kernelmemfs
+-	dd if=/dev/zero of=xv6memfs.img count=10000
+-	dd if=bootblock of=xv6memfs.img conv=notrunc
+-	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
 -
--  if(lk == 0)
--    panic("sleep without lk");
+-bootblock: bootasm.S bootmain.c
+-	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+-	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+-	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+-	$(OBJDUMP) -S bootblock.o > bootblock.asm
+-	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+-	./sign.pl bootblock
 -
--  // Must acquire ptable.lock in order to
--  // change p->state and then call sched.
--  // Once we hold ptable.lock, we can be
--  // guaranteed that we won't miss any wakeup
--  // (wakeup runs with ptable.lock locked),
--  // so it's okay to release lk.
--  if(lk != &ptable.lock){  //DOC: sleeplock0
--    acquire(&ptable.lock);  //DOC: sleeplock1
--    release(lk);
--  }
--  // Go to sleep.
--  p->chan = chan;
--  p->state = SLEEPING;
+-entryother: entryother.S
+-	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+-	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+-	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+-	$(OBJDUMP) -S bootblockother.o > entryother.asm
 -
--  sched();
+-initcode: initcode.S
+-	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+-	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+-	$(OBJCOPY) -S -O binary initcode.out initcode
+-	$(OBJDUMP) -S initcode.o > initcode.asm
 -
--  // Tidy up.
--  p->chan = 0;
+-kernel: $(OBJS) entry.o entryother initcode kernel.ld
+-	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+-	$(OBJDUMP) -S kernel > kernel.asm
+-	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
 -
--  // Reacquire original lock.
--  if(lk != &ptable.lock){  //DOC: sleeplock2
--    release(&ptable.lock);
--    acquire(lk);
--  }
-+sleep(void *chan, struct spinlock *lk) {
-+    struct proc *p = myproc();
-+
-+    if (p == 0)
-+        panic("sleep");
-+
-+    if (lk == 0)
-+        panic("sleep without lk");
-+
-+    // Must acquire ptable.lock in order to
-+    // change p->state and then call sched.
-+    // Once we hold ptable.lock, we can be
-+    // guaranteed that we won't miss any wakeup
-+    // (wakeup runs with ptable.lock locked),
-+    // so it's okay to release lk.
-+    if (lk != &ptable.lock) {  //DOC: sleeplock0
-+        acquire(&ptable.lock);  //DOC: sleeplock1
-+        release(lk);
-+    }
-+    // Go to sleep.
-+    p->chan = chan;
-+    p->state = SLEEPING;
-+
-+    sched();
-+
-+    // Tidy up.
-+    p->chan = 0;
-+
-+    // Reacquire original lock.
-+    if (lk != &ptable.lock) {  //DOC: sleeplock2
-+        release(&ptable.lock);
-+        acquire(lk);
-+    }
- }
- 
- //PAGEBREAK!
- // Wake up all processes sleeping on chan.
- // The ptable lock must be held.
- static void
--wakeup1(void *chan)
--{
--  struct proc *p;
-+wakeup1(void *chan) {
-+    struct proc *p;
- 
--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
--    if(p->state == SLEEPING && p->chan == chan)
--      p->state = RUNNABLE;
-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-+        if (p->state == SLEEPING && p->chan == chan)
-+            p->state = RUNNABLE;
- }
- 
- // Wake up all processes sleeping on chan.
- void
--wakeup(void *chan)
--{
--  acquire(&ptable.lock);
--  wakeup1(chan);
--  release(&ptable.lock);
-+wakeup(void *chan) {
-+    acquire(&ptable.lock);
-+    wakeup1(chan);
-+    release(&ptable.lock);
- }
- 
- // Kill the process with the given pid.
- // Process won't exit until it returns
- // to user space (see trap in trap.c).
- int
--kill(int pid)
--{
--  struct proc *p;
--
--  acquire(&ptable.lock);
--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
--    if(p->pid == pid){
--      p->killed = 1;
--      // Wake process from sleep if necessary.
--      if(p->state == SLEEPING)
--        p->state = RUNNABLE;
--      release(&ptable.lock);
--      return 0;
-+kill(int pid) {
-+    struct proc *p;
-+
-+    acquire(&ptable.lock);
-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-+        if (p->pid == pid) {
-+            p->killed = 1;
-+            // Wake process from sleep if necessary.
-+            if (p->state == SLEEPING)
-+                p->state = RUNNABLE;
-+            release(&ptable.lock);
-+            return 0;
-+        }
-     }
--  }
--  release(&ptable.lock);
--  return -1;
-+    release(&ptable.lock);
-+    return -1;
- }
- 
- //PAGEBREAK: 36
-@@ -501,34 +545,33 @@ kill(int pid)
- // Runs when user types ^P on console.
- // No lock to avoid wedging a stuck machine further.
- void
--procdump(void)
--{
--  static char *states[] = {
--  [UNUSED]    "unused",
--  [EMBRYO]    "embryo",
--  [SLEEPING]  "sleep ",
--  [RUNNABLE]  "runble",
--  [RUNNING]   "run   ",
--  [ZOMBIE]    "zombie"
--  };
--  int i;
--  struct proc *p;
--  char *state;
--  uint pc[10];
+-# kernelmemfs is a copy of kernel that maintains the
+-# disk image in memory instead of writing to a disk.
+-# This is not so useful for testing persistent storage or
+-# exploring disk buffering implementations, but it is
+-# great for testing the kernel on real hardware without
+-# needing a scratch disk.
+-MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+-kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+-	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+-	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+-	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
 -
--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
--    if(p->state == UNUSED)
+-tags: $(OBJS) entryother.S _init
+-	etags *.S *.c
+-
+-vectors.S: vectors.pl
+-	./vectors.pl > vectors.S
+-
+-ULIB = ulib.o usys.o printf.o umalloc.o
+-
+-_%: %.o $(ULIB)
+-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+-	$(OBJDUMP) -S $@ > $*.asm
+-	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+-
+-_forktest: forktest.o $(ULIB)
+-	# forktest has less library code linked in - needs to be small
+-	# in order to be able to max out the proc table.
+-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+-	$(OBJDUMP) -S _forktest > forktest.asm
+-
+-mkfs: mkfs.c fs.h
+-	gcc -Werror -Wall -o mkfs mkfs.c
+-
+-# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+-# that disk image changes after first build are persistent until clean.  More
+-# details:
+-# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+-.PRECIOUS: %.o
+-
+-UPROGS=\
+-	_cat\
+-	_echo\
+-	_forktest\
+-	_grep\
+-	_init\
+-	_kill\
+-	_ln\
+-	_ls\
+-	_mkdir\
+-	_rm\
+-	_sh\
+-	_stressfs\
+-	_usertests\
+-	_wc\
+-	_zombie\
+-	_lab1\
+-
+-fs.img: mkfs README $(UPROGS)
+-	./mkfs fs.img README $(UPROGS)
+-
+--include *.d
+-
+-clean: 
+-	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+-	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+-	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+-	xv6memfs.img mkfs .gdbinit \
+-	$(UPROGS)
+-
+-# make a printout
+-FILES = $(shell grep -v '^\#' runoff.list)
+-PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+-
+-xv6.pdf: $(PRINT)
+-	./runoff
+-	ls -l xv6.pdf
+-
+-print: xv6.pdf
+-
+-# run in emulators
+-
+-bochs : fs.img xv6.img
+-	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+-	bochs -q
+-
+-# try to generate a unique GDB port
+-GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+-# QEMU's gdb stub command line changed in 0.11
+-QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+-	then echo "-gdb tcp::$(GDBPORT)"; \
+-	else echo "-s -p $(GDBPORT)"; fi)
+-ifndef CPUS
+-CPUS := 2
+-endif
+-QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+-
+-qemu: fs.img xv6.img
+-	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+-
+-qemu-memfs: xv6memfs.img
+-	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+-
+-qemu-nox: fs.img xv6.img
+-	$(QEMU) -nographic $(QEMUOPTS)
+-
+-.gdbinit: .gdbinit.tmpl
+-	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+-
+-qemu-gdb: fs.img xv6.img .gdbinit
+-	@echo "*** Now run 'gdb'." 1>&2
+-	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+-
+-qemu-nox-gdb: fs.img xv6.img .gdbinit
+-	@echo "*** Now run 'gdb'." 1>&2
+-	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+-
+-# CUT HERE
+-# prepare dist for students
+-# after running make dist, probably want to
+-# rename it to rev0 or rev1 or so on and then
+-# check in that version.
+-
+-EXTRA=\
+-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+-	printf.c umalloc.c\
+-	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+-	.gdbinit.tmpl gdbutil\
+-
+-dist:
+-	rm -rf dist
+-	mkdir dist
+-	for i in $(FILES); \
+-	do \
+-		grep -v PAGEBREAK $$i >dist/$$i; \
+-	done
+-	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+-	echo >dist/runoff.spec
+-	cp $(EXTRA) dist
+-
+-dist-test:
+-	rm -rf dist
+-	make dist
+-	rm -rf dist-test
+-	mkdir dist-test
+-	cp dist/* dist-test
+-	cd dist-test; $(MAKE) print
+-	cd dist-test; $(MAKE) bochs || true
+-	cd dist-test; $(MAKE) qemu
+-
+-# update this rule (change rev#) when it is time to
+-# make a new revision.
+-tar:
+-	rm -rf /tmp/xv6
+-	mkdir -p /tmp/xv6
+-	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+-	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+-
+-.PHONY: dist-test dist
+diff --git a/Notes b/Notes
+deleted file mode 100644
+index 74c8aea..0000000
+--- a/Notes
++++ /dev/null
+@@ -1,123 +0,0 @@
+-bochs 2.2.6:
+-./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae --disable-reset-on-triple-fault
+-bochs CVS after 2.2.6:
+-./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae 
+-
+-bootmain.c doesn't work right if the ELF sections aren't
+-sector-aligned. so you can't use ld -N. and the sections may also need
+-to be non-zero length, only really matters for tiny "kernels".
+-
+-kernel loaded at 1 megabyte. stack same place that bootasm.S left it.
+-
+-kinit() should find real mem size
+-  and rescue useable memory below 1 meg
+-
+-no paging, no use of page table hardware, just segments
+-
+-no user area: no magic kernel stack mapping
+-  so no copying of kernel stack during fork
+-  though there is a kernel stack page for each process
+-
+-no kernel malloc(), just kalloc() for user core
+-
+-user pointers aren't valid in the kernel
+-
+-are interrupts turned on in the kernel? yes.
+-
+-pass curproc explicitly, or implicit from cpu #?
+-  e.g. argument to newproc()?
+-  hmm, you need a global curproc[cpu] for trap() &c
+-
+-no stack expansion
+-
+-test running out of memory, process slots
+-
+-we can't really use a separate stack segment, since stack addresses
+-need to work correctly as ordinary pointers. the same may be true of
+-data vs text. how can we have a gap between data and stack, so that
+-both can grow, without committing 4GB of physical memory? does this
+-mean we need paging?
+-
+-perhaps have fixed-size stack, put it in the data segment?
+-
+-oops, if kernel stack is in contiguous user phys mem, then moving
+-users' memory (e.g. to expand it) will wreck any pointers into the
+-kernel stack.
+-
+-do we need to set fs and gs? so user processes can't abuse them?
+-
+-setupsegs() may modify current segment table, is that legal?
+-
+-trap() ought to lgdt on return, since currently only done in swtch()
+-
+-protect hardware interrupt vectors from user INT instructions?
+-
+-test out-of-fd cases for creating pipe.
+-test pipe reader closes then write
+-test two readers, two writers.
+-test children being inherited by grandparent &c
+-
+-some sleep()s should be interruptible by kill()
+-
+-locks
+-  init_lock
+-    sequences CPU startup
+-  proc_table_lock
+-    also protects next_pid
+-  per-fd lock *just* protects count read-modify-write
+-    also maybe freeness?
+-  memory allocator
+-  printf
+-
+-in general, the table locks protect both free-ness and
+-  public variables of table elements
+-  in many cases you can use table elements w/o a lock
+-  e.g. if you are the process, or you are using an fd
+-
+-lock order
+-  per-pipe lock
+-  proc_table_lock fd_table_lock kalloc_lock
+-  console_lock
+-
+-do you have to be holding the mutex in order to call wakeup()? yes
+-
+-device interrupts don't clear FL_IF
+-  so a recursive timer interrupt is possible
+-
+-what does inode->busy mean?
+-  might be held across disk reads
+-  no-one is allowed to do anything to the inode
+-  protected by inode_table_lock
+-inode->count counts in-memory pointers to the struct
+-  prevents inode[] element from being re-used
+-  protected by inode_table_lock
+-
+-blocks and inodes have ad-hoc sleep-locks
+-  provide a single mechanism?
+-
+-kalloc() can return 0; do callers handle this right?
+-
+-test: one process unlinks a file while another links to it
+-test: one process opens a file while another deletes it
+-test: deadlock d/.. vs ../d, two processes.
+-test: dup() shared fd->off
+-test: does echo foo > x truncate x?
+-
+-sh: ioredirection incorrect now we have pipes
+-sh: chain of pipes won't work, also ugly that parent closes fdarray entries too
+-sh: dynamic memory allocation?
+-sh: should sh support ; () &
+-sh: stop stdin on ctrl-d (for cat > y)
+-
+-really should have bdwrite() for file content
+-  and make some inode updates async
+-  so soft updates make sense
+-
+-disk scheduling
+-echo foo > bar should truncate bar
+-  so O_CREATE should not truncate
+-  but O_TRUNC should
+-
+-make it work on a real machine
+-release before acquire at end of sleep?
+-check 2nd disk (i.e. if not in .bochsrc)
+diff --git a/README b/README
+deleted file mode 100644
+index 923e0a4..0000000
+--- a/README
++++ /dev/null
+@@ -1,51 +0,0 @@
+-NOTE: we have stopped maintaining the x86 version of xv6, and switched
+-our efforts to the RISC-V version
+-(https://github.com/mit-pdos/xv6-riscv.git)
+-
+-xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
+-Version 6 (v6).  xv6 loosely follows the structure and style of v6,
+-but is implemented for a modern x86-based multiprocessor using ANSI C.
+-
+-ACKNOWLEDGMENTS
+-
+-xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
+-to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
+-2000)). See also https://pdos.csail.mit.edu/6.828/, which
+-provides pointers to on-line resources for v6.
+-
+-xv6 borrows code from the following sources:
+-    JOS (asm.h, elf.h, mmu.h, bootasm.S, ide.c, console.c, and others)
+-    Plan 9 (entryother.S, mp.h, mp.c, lapic.c)
+-    FreeBSD (ioapic.c)
+-    NetBSD (console.c)
+-
+-The following people have made contributions: Russ Cox (context switching,
+-locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
+-Clements.
+-
+-We are also grateful for the bug reports and patches contributed by Silas
+-Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,
+-Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter
+-Froehlich, Yakir Goaron,Shivam Handa, Bryan Henry, Jim Huang, Alexander
+-Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller, Eddie Kohler, Austin
+-Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi
+-Merimovich, Mark Morrissey, mtasm, Joel Nider, Greg Price, Ayan Shafqat,
+-Eldar Sehayek, Yongming Shen, Cam Tenny, tyfkda, Rafael Ubal, Warren
+-Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
+-Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang Wei.
+-
+-The code in the files that constitute xv6 is
+-Copyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.
+-
+-ERROR REPORTS
+-
+-We don't process error reports (see note on top of this file).
+-
+-BUILDING AND RUNNING XV6
+-
+-To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
+-"make". On non-x86 or non-ELF machines (like OS X, even on x86), you
+-will need to install a cross-compiler gcc suite capable of producing
+-x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
+-Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
+-simulator and run "make qemu".
+\ No newline at end of file
+diff --git a/TRICKS b/TRICKS
+deleted file mode 100644
+index 8d1439f..0000000
+--- a/TRICKS
++++ /dev/null
+@@ -1,140 +0,0 @@
+-This file lists subtle things that might not be commented 
+-as well as they should be in the source code and that
+-might be worth pointing out in a longer explanation or in class.
+-
+----
+-
+-[2009/07/12: No longer relevant; forkret1 changed
+-and this is now cleaner.]
+-
+-forkret1 in trapasm.S is called with a tf argument.
+-In order to use it, forkret1 copies the tf pointer into
+-%esp and then jumps to trapret, which pops the 
+-register state out of the trap frame.  If an interrupt
+-came in between the mov tf, %esp and the iret that
+-goes back out to user space, the interrupt stack frame
+-would end up scribbling over the tf and whatever memory
+-lay under it.
+-
+-Why is this safe?  Because forkret1 is only called
+-the first time a process returns to user space, and
+-at that point, cp->tf is set to point to a trap frame
+-constructed at the top of cp's kernel stack.  So tf 
+-*is* a valid %esp that can hold interrupt state.
+-
+-If other tf's were used in forkret1, we could add
+-a cli before the mov tf, %esp.
+-
+----
+-
+-In pushcli, must cli() no matter what.  It is not safe to do
+-
+-  if(cpus[cpu()].ncli == 0)
+-    cli();
+-  cpus[cpu()].ncli++;
+-
+-because if interrupts are off then we might call cpu(), get
+-rescheduled to a different cpu, look at cpus[oldcpu].ncli,
+-and wrongly decide not to disable interrupts on the new cpu.
+-
+-Instead do 
+-
+-  cli();
+-  cpus[cpu()].ncli++;
+-
+-always.
+-
+----
+-
+-There is a (harmless) race in pushcli, which does
+-
+-	eflags = readeflags();
+-	cli();
+-	if(c->ncli++ == 0)
+-		c->intena = eflags & FL_IF;
+-
+-Consider a bottom-level pushcli.  
+-If interrupts are disabled already, then the right thing
+-happens: read_eflags finds that FL_IF is not set,
+-and intena = 0.  If interrupts are enabled, then
+-it is less clear that the right thing happens:
+-the readeflags can execute, then the process
+-can get preempted and rescheduled on another cpu,
+-and then once it starts running, perhaps with 
+-interrupts disabled (can happen since the scheduler
+-only enables interrupts once per scheduling loop,
+-not every time it schedules a process), it will 
+-incorrectly record that interrupts *were* enabled.
+-This doesn't matter, because if it was safe to be
+-running with interrupts enabled before the context
+-switch, it is still safe (and arguably more correct)
+-to run with them enabled after the context switch too.
+-
+-In fact it would be safe if scheduler always set
+-	c->intena = 1;
+-before calling swtch, and perhaps it should.
+-
+----
+-
+-The x86's processor-ordering memory model 
+-matches spin locks well, so no explicit memory
+-synchronization instructions are required in
+-acquire and release.  
+-
+-Consider two sequences of code on different CPUs:
+-
+-CPU0
+-A;
+-release(lk);
+-
+-and
+-
+-CPU1
+-acquire(lk);
+-B;
+-
+-We want to make sure that:
+-  - all reads in B see the effects of writes in A.
+-  - all reads in A do *not* see the effects of writes in B.
+- 
+-The x86 guarantees that writes in A will go out
+-to memory before the write of lk->locked = 0 in 
+-release(lk).  It further guarantees that CPU1 
+-will observe CPU0's write of lk->locked = 0 only
+-after observing the earlier writes by CPU0.
+-So any reads in B are guaranteed to observe the
+-effects of writes in A.
+-
+-According to the Intel manual behavior spec, the
+-second condition requires a serialization instruction
+-in release, to avoid reads in A happening after giving
+-up lk.  No Intel SMP processor in existence actually
+-moves reads down after writes, but the language in
+-the spec allows it.  There is no telling whether future
+-processors will need it.
+-
+----
+-
+-The code in fork needs to read np->pid before
+-setting np->state to RUNNABLE.  The following
+-is not a correct way to do this:
+-
+-	int
+-	fork(void)
+-	{
+-	  ...
+-	  np->state = RUNNABLE;
+-	  return np->pid; // oops
+-	}
+-
+-After setting np->state to RUNNABLE, some other CPU
+-might run the process, it might exit, and then it might
+-get reused for a different process (with a new pid), all
+-before the return statement.  So it's not safe to just
+-"return np->pid". Even saving a copy of np->pid before
+-setting np->state isn't safe, since the compiler is
+-allowed to re-order statements.
+-
+-The real code saves a copy of np->pid, then acquires a lock
+-around the write to np->state. The acquire() prevents the
+-compiler from re-ordering.
+diff --git a/asm.h b/asm.h
+deleted file mode 100644
+index b8a7353..0000000
+--- a/asm.h
++++ /dev/null
+@@ -1,18 +0,0 @@
+-//
+-// assembler macros to create x86 segments
+-//
+-
+-#define SEG_NULLASM                                             \
+-        .word 0, 0;                                             \
+-        .byte 0, 0, 0, 0
+-
+-// The 0xC0 means the limit is in 4096-byte units
+-// and (for executable segments) 32-bit mode.
+-#define SEG_ASM(type,base,lim)                                  \
+-        .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
+-        .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
+-                (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
+-
+-#define STA_X     0x8       // Executable segment
+-#define STA_W     0x2       // Writeable (non-executable segments)
+-#define STA_R     0x2       // Readable (executable segments)
+diff --git a/bio.c b/bio.c
+deleted file mode 100644
+index a45ff3e..0000000
+--- a/bio.c
++++ /dev/null
+@@ -1,144 +0,0 @@
+-// Buffer cache.
+-//
+-// The buffer cache is a linked list of buf structures holding
+-// cached copies of disk block contents.  Caching disk blocks
+-// in memory reduces the number of disk reads and also provides
+-// a synchronization point for disk blocks used by multiple processes.
+-//
+-// Interface:
+-// * To get a buffer for a particular disk block, call bread.
+-// * After changing buffer data, call bwrite to write it to disk.
+-// * When done with the buffer, call brelse.
+-// * Do not use the buffer after calling brelse.
+-// * Only one process at a time can use a buffer,
+-//     so do not keep them longer than necessary.
+-//
+-// The implementation uses two state flags internally:
+-// * B_VALID: the buffer data has been read from the disk.
+-// * B_DIRTY: the buffer data has been modified
+-//     and needs to be written to disk.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "buf.h"
+-
+-struct {
+-  struct spinlock lock;
+-  struct buf buf[NBUF];
+-
+-  // Linked list of all buffers, through prev/next.
+-  // head.next is most recently used.
+-  struct buf head;
+-} bcache;
+-
+-void
+-binit(void)
+-{
+-  struct buf *b;
+-
+-  initlock(&bcache.lock, "bcache");
+-
+-//PAGEBREAK!
+-  // Create linked list of buffers
+-  bcache.head.prev = &bcache.head;
+-  bcache.head.next = &bcache.head;
+-  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+-    b->next = bcache.head.next;
+-    b->prev = &bcache.head;
+-    initsleeplock(&b->lock, "buffer");
+-    bcache.head.next->prev = b;
+-    bcache.head.next = b;
+-  }
+-}
+-
+-// Look through buffer cache for block on device dev.
+-// If not found, allocate a buffer.
+-// In either case, return locked buffer.
+-static struct buf*
+-bget(uint dev, uint blockno)
+-{
+-  struct buf *b;
+-
+-  acquire(&bcache.lock);
+-
+-  // Is the block already cached?
+-  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+-    if(b->dev == dev && b->blockno == blockno){
+-      b->refcnt++;
+-      release(&bcache.lock);
+-      acquiresleep(&b->lock);
+-      return b;
+-    }
+-  }
+-
+-  // Not cached; recycle an unused buffer.
+-  // Even if refcnt==0, B_DIRTY indicates a buffer is in use
+-  // because log.c has modified it but not yet committed it.
+-  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+-    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
+-      b->dev = dev;
+-      b->blockno = blockno;
+-      b->flags = 0;
+-      b->refcnt = 1;
+-      release(&bcache.lock);
+-      acquiresleep(&b->lock);
+-      return b;
+-    }
+-  }
+-  panic("bget: no buffers");
+-}
+-
+-// Return a locked buf with the contents of the indicated block.
+-struct buf*
+-bread(uint dev, uint blockno)
+-{
+-  struct buf *b;
+-
+-  b = bget(dev, blockno);
+-  if((b->flags & B_VALID) == 0) {
+-    iderw(b);
+-  }
+-  return b;
+-}
+-
+-// Write b's contents to disk.  Must be locked.
+-void
+-bwrite(struct buf *b)
+-{
+-  if(!holdingsleep(&b->lock))
+-    panic("bwrite");
+-  b->flags |= B_DIRTY;
+-  iderw(b);
+-}
+-
+-// Release a locked buffer.
+-// Move to the head of the MRU list.
+-void
+-brelse(struct buf *b)
+-{
+-  if(!holdingsleep(&b->lock))
+-    panic("brelse");
+-
+-  releasesleep(&b->lock);
+-
+-  acquire(&bcache.lock);
+-  b->refcnt--;
+-  if (b->refcnt == 0) {
+-    // no one is waiting for it.
+-    b->next->prev = b->prev;
+-    b->prev->next = b->next;
+-    b->next = bcache.head.next;
+-    b->prev = &bcache.head;
+-    bcache.head.next->prev = b;
+-    bcache.head.next = b;
+-  }
+-  
+-  release(&bcache.lock);
+-}
+-//PAGEBREAK!
+-// Blank page.
+-
+diff --git a/bootasm.S b/bootasm.S
+deleted file mode 100644
+index 257867c..0000000
+--- a/bootasm.S
++++ /dev/null
+@@ -1,88 +0,0 @@
+-#include "asm.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-
+-# Start the first CPU: switch to 32-bit protected mode, jump into C.
+-# The BIOS loads this code from the first sector of the hard disk into
+-# memory at physical address 0x7c00 and starts executing in real mode
+-# with %cs=0 %ip=7c00.
+-
+-.code16                       # Assemble for 16-bit mode
+-.globl start
+-start:
+-  cli                         # BIOS enabled interrupts; disable
+-
+-  # Zero data segment registers DS, ES, and SS.
+-  xorw    %ax,%ax             # Set %ax to zero
+-  movw    %ax,%ds             # -> Data Segment
+-  movw    %ax,%es             # -> Extra Segment
+-  movw    %ax,%ss             # -> Stack Segment
+-
+-  # Physical address line A20 is tied to zero so that the first PCs 
+-  # with 2 MB would run software that assumed 1 MB.  Undo that.
+-seta20.1:
+-  inb     $0x64,%al               # Wait for not busy
+-  testb   $0x2,%al
+-  jnz     seta20.1
+-
+-  movb    $0xd1,%al               # 0xd1 -> port 0x64
+-  outb    %al,$0x64
+-
+-seta20.2:
+-  inb     $0x64,%al               # Wait for not busy
+-  testb   $0x2,%al
+-  jnz     seta20.2
+-
+-  movb    $0xdf,%al               # 0xdf -> port 0x60
+-  outb    %al,$0x60
+-
+-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+-  # virtual addresses map directly to physical addresses so that the
+-  # effective memory map doesn't change during the transition.
+-  lgdt    gdtdesc
+-  movl    %cr0, %eax
+-  orl     $CR0_PE, %eax
+-  movl    %eax, %cr0
+-
+-//PAGEBREAK!
+-  # Complete the transition to 32-bit protected mode by using a long jmp
+-  # to reload %cs and %eip.  The segment descriptors are set up with no
+-  # translation, so that the mapping is still the identity mapping.
+-  ljmp    $(SEG_KCODE<<3), $start32
+-
+-.code32  # Tell assembler to generate 32-bit code now.
+-start32:
+-  # Set up the protected-mode data segment registers
+-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+-  movw    %ax, %ds                # -> DS: Data Segment
+-  movw    %ax, %es                # -> ES: Extra Segment
+-  movw    %ax, %ss                # -> SS: Stack Segment
+-  movw    $0, %ax                 # Zero segments not ready for use
+-  movw    %ax, %fs                # -> FS
+-  movw    %ax, %gs                # -> GS
+-
+-  # Set up the stack pointer and call into C.
+-  movl    $start, %esp
+-  call    bootmain
+-
+-  # If bootmain returns (it shouldn't), trigger a Bochs
+-  # breakpoint if running under Bochs, then loop.
+-  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
+-  movw    %ax, %dx
+-  outw    %ax, %dx
+-  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
+-  outw    %ax, %dx
+-spin:
+-  jmp     spin
+-
+-# Bootstrap GDT
+-.p2align 2                                # force 4 byte alignment
+-gdt:
+-  SEG_NULLASM                             # null seg
+-  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg
+-  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg
+-
+-gdtdesc:
+-  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
+-  .long   gdt                             # address gdt
+-
+diff --git a/bootmain.c b/bootmain.c
+deleted file mode 100644
+index 1f20e5b..0000000
+--- a/bootmain.c
++++ /dev/null
+@@ -1,96 +0,0 @@
+-// Boot loader.
+-//
+-// Part of the boot block, along with bootasm.S, which calls bootmain().
+-// bootasm.S has put the processor into protected 32-bit mode.
+-// bootmain() loads an ELF kernel image from the disk starting at
+-// sector 1 and then jumps to the kernel entry routine.
+-
+-#include "types.h"
+-#include "elf.h"
+-#include "x86.h"
+-#include "memlayout.h"
+-
+-#define SECTSIZE  512
+-
+-void readseg(uchar*, uint, uint);
+-
+-void
+-bootmain(void)
+-{
+-  struct elfhdr *elf;
+-  struct proghdr *ph, *eph;
+-  void (*entry)(void);
+-  uchar* pa;
+-
+-  elf = (struct elfhdr*)0x10000;  // scratch space
+-
+-  // Read 1st page off disk
+-  readseg((uchar*)elf, 4096, 0);
+-
+-  // Is this an ELF executable?
+-  if(elf->magic != ELF_MAGIC)
+-    return;  // let bootasm.S handle error
+-
+-  // Load each program segment (ignores ph flags).
+-  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
+-  eph = ph + elf->phnum;
+-  for(; ph < eph; ph++){
+-    pa = (uchar*)ph->paddr;
+-    readseg(pa, ph->filesz, ph->off);
+-    if(ph->memsz > ph->filesz)
+-      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
+-  }
+-
+-  // Call the entry point from the ELF header.
+-  // Does not return!
+-  entry = (void(*)(void))(elf->entry);
+-  entry();
+-}
+-
+-void
+-waitdisk(void)
+-{
+-  // Wait for disk ready.
+-  while((inb(0x1F7) & 0xC0) != 0x40)
+-    ;
+-}
+-
+-// Read a single sector at offset into dst.
+-void
+-readsect(void *dst, uint offset)
+-{
+-  // Issue command.
+-  waitdisk();
+-  outb(0x1F2, 1);   // count = 1
+-  outb(0x1F3, offset);
+-  outb(0x1F4, offset >> 8);
+-  outb(0x1F5, offset >> 16);
+-  outb(0x1F6, (offset >> 24) | 0xE0);
+-  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
+-
+-  // Read data.
+-  waitdisk();
+-  insl(0x1F0, dst, SECTSIZE/4);
+-}
+-
+-// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
+-// Might copy more than asked.
+-void
+-readseg(uchar* pa, uint count, uint offset)
+-{
+-  uchar* epa;
+-
+-  epa = pa + count;
+-
+-  // Round down to sector boundary.
+-  pa -= offset % SECTSIZE;
+-
+-  // Translate from bytes to sectors; kernel starts at sector 1.
+-  offset = (offset / SECTSIZE) + 1;
+-
+-  // If this is too slow, we could read lots of sectors at a time.
+-  // We'd write more to memory than asked, but it doesn't matter --
+-  // we load in increasing order.
+-  for(; pa < epa; pa += SECTSIZE, offset++)
+-    readsect(pa, offset);
+-}
+diff --git a/buf.h b/buf.h
+deleted file mode 100644
+index 3266495..0000000
+--- a/buf.h
++++ /dev/null
+@@ -1,14 +0,0 @@
+-struct buf {
+-  int flags;
+-  uint dev;
+-  uint blockno;
+-  struct sleeplock lock;
+-  uint refcnt;
+-  struct buf *prev; // LRU cache list
+-  struct buf *next;
+-  struct buf *qnext; // disk queue
+-  uchar data[BSIZE];
+-};
+-#define B_VALID 0x2  // buffer has been read from disk
+-#define B_DIRTY 0x4  // buffer needs to be written to disk
+-
+diff --git a/cat.c b/cat.c
+deleted file mode 100644
+index 68b1b8d..0000000
+--- a/cat.c
++++ /dev/null
+@@ -1,43 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-char buf[512];
+-
+-void
+-cat(int fd)
+-{
+-  int n;
+-
+-  while((n = read(fd, buf, sizeof(buf))) > 0) {
+-    if (write(1, buf, n) != n) {
+-      printf(1, "cat: write error\n");
+-      exit(3);
+-    }
+-  }
+-  if(n < 0){
+-    printf(1, "cat: read error\n");
+-    exit(4);
+-  }
+-}
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int fd, i;
+-
+-  if(argc <= 1){
+-    cat(0);
+-    exit(1);
+-  }
+-
+-  for(i = 1; i < argc; i++){
+-    if((fd = open(argv[i], 0)) < 0){
+-      printf(1, "cat: cannot open %s\n", argv[i]);
+-      exit(2);
+-    }
+-    cat(fd);
+-    close(fd);
+-  }
+-  exit(0);
+-}
+diff --git a/code.diff b/code.diff
+deleted file mode 100644
+index c889659..0000000
+--- a/code.diff
++++ /dev/null
+@@ -1,2919 +0,0 @@
+-diff --git a/Makefile b/Makefile
+-index 09d790c..04d74d5 100644
+---- a/Makefile
+-+++ b/Makefile
+-@@ -181,6 +181,7 @@ UPROGS=\
+- 	_usertests\
+- 	_wc\
+- 	_zombie\
+-+	_lab1\
+- 
+- fs.img: mkfs README $(UPROGS)
+- 	./mkfs fs.img README $(UPROGS)
+-diff --git a/cat.c b/cat.c
+-index 5ddc820..68b1b8d 100644
+---- a/cat.c
+-+++ b/cat.c
+-@@ -12,12 +12,12 @@ cat(int fd)
+-   while((n = read(fd, buf, sizeof(buf))) > 0) {
+-     if (write(1, buf, n) != n) {
+-       printf(1, "cat: write error\n");
+--      exit();
+-+      exit(3);
+-     }
+-   }
+-   if(n < 0){
+-     printf(1, "cat: read error\n");
+--    exit();
+-+    exit(4);
+-   }
+- }
+- 
+-@@ -28,16 +28,16 @@ main(int argc, char *argv[])
+- 
+-   if(argc <= 1){
+-     cat(0);
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-     if((fd = open(argv[i], 0)) < 0){
+-       printf(1, "cat: cannot open %s\n", argv[i]);
+--      exit();
+-+      exit(2);
+-     }
+-     cat(fd);
+-     close(fd);
+-   }
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/cuth b/cuth
+-old mode 100755
+-new mode 100644
+-diff --git a/defs.h b/defs.h
+-index 82fb982..d1934ca 100644
+---- a/defs.h
+-+++ b/defs.h
+-@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
+- //PAGEBREAK: 16
+- // proc.c
+- int             cpuid(void);
+--void            exit(void);
+-+void            exit(int status);
+- int             fork(void);
+- int             growproc(int);
+- int             kill(int);
+-@@ -117,7 +117,8 @@ void            sched(void);
+- void            setproc(struct proc*);
+- void            sleep(void*, struct spinlock*);
+- void            userinit(void);
+--int             wait(void);
+-+int             wait(int* status);
+-+int             waitpid(int pid, int* status, int options);
+- void            wakeup(void*);
+- void            yield(void);
+- 
+-diff --git a/dot-bochsrc b/dot-bochsrc
+-old mode 100755
+-new mode 100644
+-diff --git a/echo.c b/echo.c
+-index 806dee0..eed68a0 100644
+---- a/echo.c
+-+++ b/echo.c
+-@@ -9,5 +9,5 @@ main(int argc, char *argv[])
+- 
+-   for(i = 1; i < argc; i++)
+-     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/forktest.c b/forktest.c
+-index 8bc984d..a4b35ed 100644
+---- a/forktest.c
+-+++ b/forktest.c
+-@@ -25,24 +25,24 @@ forktest(void)
+-     if(pid < 0)
+-       break;
+-     if(pid == 0)
+--      exit();
+-+      exit(4);
+-   }
+- 
+-   if(n == N){
+-     printf(1, "fork claimed to work N times!\n", N);
+--    exit();
+-+    exit(3);
+-   }
+- 
+-   for(; n > 0; n--){
+--    if(wait() < 0){
+-+    if(wait(NULL) < 0){
+-       printf(1, "wait stopped early\n");
+--      exit();
+-+      exit(2);
+-     }
+-   }
+- 
+--  if(wait() != -1){
+-+  if(wait(NULL) != -1){
+-     printf(1, "wait got too many\n");
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   printf(1, "fork test OK\n");
+-@@ -52,5 +52,5 @@ int
+- main(void)
+- {
+-   forktest();
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/grep.c b/grep.c
+-index adc4835..4be3256 100644
+---- a/grep.c
+-+++ b/grep.c
+-@@ -43,24 +43,24 @@ main(int argc, char *argv[])
+- 
+-   if(argc <= 1){
+-     printf(2, "usage: grep pattern [file ...]\n");
+--    exit();
+-+    exit(1);
+-   }
+-   pattern = argv[1];
+- 
+-   if(argc <= 2){
+-     grep(pattern, 0);
+--    exit();
+-+    exit(2);
+-   }
+- 
+-   for(i = 2; i < argc; i++){
+-     if((fd = open(argv[i], 0)) < 0){
+-       printf(1, "grep: cannot open %s\n", argv[i]);
+--      exit();
+-+      exit(3);
+-     }
+-     grep(pattern, fd);
+-     close(fd);
+-   }
+--  exit();
+-+  exit(0);
+- }
+- 
+- // Regexp matcher from Kernighan & Pike,
+-diff --git a/init.c b/init.c
+-index 046b551..bc6547f 100644
+---- a/init.c
+-+++ b/init.c
+-@@ -24,14 +24,14 @@ main(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "init: fork failed\n");
+--      exit();
+-+      exit(2);
+-     }
+-     if(pid == 0){
+-       exec("sh", argv);
+-       printf(1, "init: exec sh failed\n");
+--      exit();
+-+      exit(1);
+-     }
+--    while((wpid=wait()) >= 0 && wpid != pid)
+-+    while((wpid=wait(NULL)) >= 0 && wpid != pid)
+-       printf(1, "zombie!\n");
+-   }
+- }
+-diff --git a/kill.c b/kill.c
+-index 364f6af..875916c 100644
+---- a/kill.c
+-+++ b/kill.c
+-@@ -9,9 +9,9 @@ main(int argc, char **argv)
+- 
+-   if(argc < 2){
+-     printf(2, "usage: kill pid...\n");
+--    exit();
+-+    exit(1);
+-   }
+-   for(i=1; i<argc; i++)
+-     kill(atoi(argv[i]));
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/lab1.c b/lab1.c
+-index 89668ce..2192a52 100644
+---- a/lab1.c
+-+++ b/lab1.c
+-@@ -25,7 +25,7 @@ int main(int argc, char **argv) {
+-     if(pid > 0)
+-     {
+-         waitpid(pid, NULL, 0);
+--        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);
+-+        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
+-         exit(0);
+-     }
+- 
+-diff --git a/ln.c b/ln.c
+-index cf8a64e..fb17c3b 100644
+---- a/ln.c
+-+++ b/ln.c
+-@@ -7,9 +7,9 @@ main(int argc, char *argv[])
+- {
+-   if(argc != 3){
+-     printf(2, "Usage: ln old new\n");
+--    exit();
+-+    exit(1);
+-   }
+-   if(link(argv[1], argv[2]) < 0)
+-     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/ls.c b/ls.c
+-index 2862913..6bf943b 100644
+---- a/ls.c
+-+++ b/ls.c
+-@@ -77,9 +77,9 @@ main(int argc, char *argv[])
+- 
+-   if(argc < 2){
+-     ls(".");
+--    exit();
+-+    exit(1);
+-   }
+-   for(i=1; i<argc; i++)
+-     ls(argv[i]);
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/mkdir.c b/mkdir.c
+-index 6e4c954..2d90781 100644
+---- a/mkdir.c
+-+++ b/mkdir.c
+-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
+- 
+-   if(argc < 2){
+-     printf(2, "Usage: mkdir files...\n");
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
+-     }
+-   }
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/pr.pl b/pr.pl
+-old mode 100755
+-new mode 100644
+-diff --git a/printpcs b/printpcs
+-old mode 100755
+-new mode 100644
+-diff --git a/proc.c b/proc.c
+-index 806b1b1..84b335f 100644
+---- a/proc.c
+-+++ b/proc.c
+-@@ -1,3 +1,5 @@
+-+#include <stddef.h>
+-+
+- #include "types.h"
+- #include "defs.h"
+- #include "param.h"
+-@@ -8,61 +10,61 @@
+- #include "spinlock.h"
+- 
+- struct {
+--  struct spinlock lock;
+--  struct proc proc[NPROC];
+-+    struct spinlock lock;
+-+    struct proc proc[NPROC];
+- } ptable;
+- 
+- static struct proc *initproc;
+- 
+- int nextpid = 1;
+-+
+- extern void forkret(void);
+-+
+- extern void trapret(void);
+- 
+- static void wakeup1(void *chan);
+- 
+- void
+--pinit(void)
+--{
+--  initlock(&ptable.lock, "ptable");
+-+pinit(void) {
+-+    initlock(&ptable.lock, "ptable");
+- }
+- 
+- // Must be called with interrupts disabled
+- int
+- cpuid() {
+--  return mycpu()-cpus;
+-+    return mycpu() - cpus;
+- }
+- 
+- // Must be called with interrupts disabled to avoid the caller being
+- // rescheduled between reading lapicid and running through the loop.
+--struct cpu*
+--mycpu(void)
+--{
+--  int apicid, i;
+--  
+--  if(readeflags()&FL_IF)
+--    panic("mycpu called with interrupts enabled\n");
+--  
+--  apicid = lapicid();
+--  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+--  // a reverse map, or reserve a register to store &cpus[i].
+--  for (i = 0; i < ncpu; ++i) {
+--    if (cpus[i].apicid == apicid)
+--      return &cpus[i];
+--  }
+--  panic("unknown apicid\n");
+-+struct cpu *
+-+mycpu(void) {
+-+    int apicid, i;
+-+
+-+    if (readeflags() & FL_IF)
+-+        panic("mycpu called with interrupts enabled\n");
+-+
+-+    apicid = lapicid();
+-+    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+-+    // a reverse map, or reserve a register to store &cpus[i].
+-+    for (i = 0; i < ncpu; ++i) {
+-+        if (cpus[i].apicid == apicid)
+-+            return &cpus[i];
+-+    }
+-+    panic("unknown apicid\n");
+- }
+- 
+- // Disable interrupts so that we are not rescheduled
+- // while reading proc from the cpu structure
+--struct proc*
+-+struct proc *
+- myproc(void) {
+--  struct cpu *c;
+--  struct proc *p;
+--  pushcli();
+--  c = mycpu();
+--  p = c->proc;
+--  popcli();
+--  return p;
+-+    struct cpu *c;
+-+    struct proc *p;
+-+    pushcli();
+-+    c = mycpu();
+-+    p = c->proc;
+-+    popcli();
+-+    return p;
+- }
+- 
+- //PAGEBREAK: 32
+-@@ -70,245 +72,295 @@ myproc(void) {
+- // If found, change state to EMBRYO and initialize
+- // state required to run in the kernel.
+- // Otherwise return 0.
+--static struct proc*
+--allocproc(void)
+--{
+--  struct proc *p;
+--  char *sp;
+-+static struct proc *
+-+allocproc(void) {
+-+    struct proc *p;
+-+    char *sp;
+- 
+--  acquire(&ptable.lock);
+-+    acquire(&ptable.lock);
+- 
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+--    if(p->state == UNUSED)
+--      goto found;
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-+        if (p->state == UNUSED)
+-+            goto found;
+- 
+--  release(&ptable.lock);
+--  return 0;
+-+    release(&ptable.lock);
+-+    return 0;
+- 
+--found:
+--  p->state = EMBRYO;
+--  p->pid = nextpid++;
+-+    found:
+-+    p->state = EMBRYO;
+-+    p->pid = nextpid++;
+- 
+--  release(&ptable.lock);
+-+    release(&ptable.lock);
+- 
+--  // Allocate kernel stack.
+--  if((p->kstack = kalloc()) == 0){
+--    p->state = UNUSED;
+--    return 0;
+--  }
+--  sp = p->kstack + KSTACKSIZE;
+-+    // Allocate kernel stack.
+-+    if ((p->kstack = kalloc()) == 0) {
+-+        p->state = UNUSED;
+-+        return 0;
+-+    }
+-+    sp = p->kstack + KSTACKSIZE;
+- 
+--  // Leave room for trap frame.
+--  sp -= sizeof *p->tf;
+--  p->tf = (struct trapframe*)sp;
+-+    // Leave room for trap frame.
+-+    sp -= sizeof *p->tf;
+-+    p->tf = (struct trapframe *) sp;
+- 
+--  // Set up new context to start executing at forkret,
+--  // which returns to trapret.
+--  sp -= 4;
+--  *(uint*)sp = (uint)trapret;
+-+    // Set up new context to start executing at forkret,
+-+    // which returns to trapret.
+-+    sp -= 4;
+-+    *(uint *) sp = (uint) trapret;
+- 
+--  sp -= sizeof *p->context;
+--  p->context = (struct context*)sp;
+--  memset(p->context, 0, sizeof *p->context);
+--  p->context->eip = (uint)forkret;
+-+    sp -= sizeof *p->context;
+-+    p->context = (struct context *) sp;
+-+    memset(p->context, 0, sizeof *p->context);
+-+    p->context->eip = (uint) forkret;
+- 
+--  return p;
+-+    return p;
+- }
+- 
+- //PAGEBREAK: 32
+- // Set up first user process.
+- void
+--userinit(void)
+--{
+--  struct proc *p;
+--  extern char _binary_initcode_start[], _binary_initcode_size[];
+--
+--  p = allocproc();
+--  
+--  initproc = p;
+--  if((p->pgdir = setupkvm()) == 0)
+--    panic("userinit: out of memory?");
+--  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+--  p->sz = PGSIZE;
+--  memset(p->tf, 0, sizeof(*p->tf));
+--  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+--  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+--  p->tf->es = p->tf->ds;
+--  p->tf->ss = p->tf->ds;
+--  p->tf->eflags = FL_IF;
+--  p->tf->esp = PGSIZE;
+--  p->tf->eip = 0;  // beginning of initcode.S
+--
+--  safestrcpy(p->name, "initcode", sizeof(p->name));
+--  p->cwd = namei("/");
+--
+--  // this assignment to p->state lets other cores
+--  // run this process. the acquire forces the above
+--  // writes to be visible, and the lock is also needed
+--  // because the assignment might not be atomic.
+--  acquire(&ptable.lock);
+--
+--  p->state = RUNNABLE;
+--
+--  release(&ptable.lock);
+-+userinit(void) {
+-+    struct proc *p;
+-+    extern char _binary_initcode_start[], _binary_initcode_size[];
+-+
+-+    p = allocproc();
+-+
+-+    initproc = p;
+-+    if ((p->pgdir = setupkvm()) == 0)
+-+        panic("userinit: out of memory?");
+-+    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
+-+    p->sz = PGSIZE;
+-+    memset(p->tf, 0, sizeof(*p->tf));
+-+    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+-+    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+-+    p->tf->es = p->tf->ds;
+-+    p->tf->ss = p->tf->ds;
+-+    p->tf->eflags = FL_IF;
+-+    p->tf->esp = PGSIZE;
+-+    p->tf->eip = 0;  // beginning of initcode.S
+-+
+-+    safestrcpy(p->name, "initcode", sizeof(p->name));
+-+    p->cwd = namei("/");
+-+
+-+    // this assignment to p->state lets other cores
+-+    // run this process. the acquire forces the above
+-+    // writes to be visible, and the lock is also needed
+-+    // because the assignment might not be atomic.
+-+    acquire(&ptable.lock);
+-+
+-+    p->state = RUNNABLE;
+-+
+-+    release(&ptable.lock);
+- }
+- 
+- // Grow current process's memory by n bytes.
+- // Return 0 on success, -1 on failure.
+- int
+--growproc(int n)
+--{
+--  uint sz;
+--  struct proc *curproc = myproc();
+--
+--  sz = curproc->sz;
+--  if(n > 0){
+--    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+--      return -1;
+--  } else if(n < 0){
+--    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+--      return -1;
+--  }
+--  curproc->sz = sz;
+--  switchuvm(curproc);
+--  return 0;
+-+growproc(int n) {
+-+    uint sz;
+-+    struct proc *curproc = myproc();
+-+
+-+    sz = curproc->sz;
+-+    if (n > 0) {
+-+        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-+            return -1;
+-+    } else if (n < 0) {
+-+        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-+            return -1;
+-+    }
+-+    curproc->sz = sz;
+-+    switchuvm(curproc);
+-+    return 0;
+- }
+- 
+- // Create a new process copying p as the parent.
+- // Sets up stack to return as if from system call.
+- // Caller must set state of returned proc to RUNNABLE.
+- int
+--fork(void)
+--{
+--  int i, pid;
+--  struct proc *np;
+--  struct proc *curproc = myproc();
+--
+--  // Allocate process.
+--  if((np = allocproc()) == 0){
+--    return -1;
+--  }
+-+fork(void) {
+-+    int i, pid;
+-+    struct proc *np;
+-+    struct proc *curproc = myproc();
+-+
+-+    // Allocate process.
+-+    if ((np = allocproc()) == 0) {
+-+        return -1;
+-+    }
+- 
+--  // Copy process state from proc.
+--  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+--    kfree(np->kstack);
+--    np->kstack = 0;
+--    np->state = UNUSED;
+--    return -1;
+--  }
+--  np->sz = curproc->sz;
+--  np->parent = curproc;
+--  *np->tf = *curproc->tf;
+-+    // Copy process state from proc.
+-+    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
+-+        kfree(np->kstack);
+-+        np->kstack = 0;
+-+        np->state = UNUSED;
+-+        return -1;
+-+    }
+-+    np->sz = curproc->sz;
+-+    np->parent = curproc;
+-+    *np->tf = *curproc->tf;
+- 
+--  // Clear %eax so that fork returns 0 in the child.
+--  np->tf->eax = 0;
+-+    // Clear %eax so that fork returns 0 in the child.
+-+    np->tf->eax = 0;
+- 
+--  for(i = 0; i < NOFILE; i++)
+--    if(curproc->ofile[i])
+--      np->ofile[i] = filedup(curproc->ofile[i]);
+--  np->cwd = idup(curproc->cwd);
+-+    for (i = 0; i < NOFILE; i++)
+-+        if (curproc->ofile[i])
+-+            np->ofile[i] = filedup(curproc->ofile[i]);
+-+    np->cwd = idup(curproc->cwd);
+- 
+--  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+-+    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+- 
+--  pid = np->pid;
+-+    pid = np->pid;
+- 
+--  acquire(&ptable.lock);
+-+    acquire(&ptable.lock);
+- 
+--  np->state = RUNNABLE;
+-+    np->state = RUNNABLE;
+- 
+--  release(&ptable.lock);
+-+    release(&ptable.lock);
+- 
+--  return pid;
+-+    return pid;
+- }
+- 
+- // Exit the current process.  Does not return.
+- // An exited process remains in the zombie state
+- // until its parent calls wait() to find out it exited.
+- void
+--exit(void)
+--{
+--  struct proc *curproc = myproc();
+--  struct proc *p;
+--  int fd;
+--
+--  if(curproc == initproc)
+--    panic("init exiting");
+--
+--  // Close all open files.
+--  for(fd = 0; fd < NOFILE; fd++){
+--    if(curproc->ofile[fd]){
+--      fileclose(curproc->ofile[fd]);
+--      curproc->ofile[fd] = 0;
+-+exit(int status) {
+-+    struct proc *curproc = myproc();
+-+    struct proc *p;
+-+    int fd;
+-+
+-+    curproc->status = status;
+-+
+-+    if (curproc == initproc)
+-+        panic("init exiting");
+-+
+-+    // Close all open files.
+-+    for (fd = 0; fd < NOFILE; fd++) {
+-+        if (curproc->ofile[fd]) {
+-+            fileclose(curproc->ofile[fd]);
+-+            curproc->ofile[fd] = 0;
+-+        }
+-     }
+--  }
+- 
+--  begin_op();
+--  iput(curproc->cwd);
+--  end_op();
+--  curproc->cwd = 0;
+-+    begin_op();
+-+    iput(curproc->cwd);
+-+    end_op();
+-+    curproc->cwd = 0;
+- 
+--  acquire(&ptable.lock);
+-+    acquire(&ptable.lock);
+- 
+--  // Parent might be sleeping in wait().
+--  wakeup1(curproc->parent);
+-+    // Parent might be sleeping in wait().
+-+    wakeup1(curproc->parent);
+- 
+--  // Pass abandoned children to init.
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--    if(p->parent == curproc){
+--      p->parent = initproc;
+--      if(p->state == ZOMBIE)
+--        wakeup1(initproc);
+-+    // Pass abandoned children to init.
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+        if (p->parent == curproc) {
+-+            p->parent = initproc;
+-+            if (p->state == ZOMBIE)
+-+                wakeup1(initproc);
+-+        }
+-     }
+--  }
+- 
+--  // Jump into the scheduler, never to return.
+--  curproc->state = ZOMBIE;
+--  sched();
+--  panic("zombie exit");
+-+    // Jump into the scheduler, never to return.
+-+    curproc->state = ZOMBIE;
+-+    sched();
+-+    panic("zombie exit");
+- }
+- 
+- // Wait for a child process to exit and return its pid.
+- // Return -1 if this process has no children.
+- int
+--wait(void)
+--{
+--  struct proc *p;
+--  int havekids, pid;
+--  struct proc *curproc = myproc();
+--  
+--  acquire(&ptable.lock);
+--  for(;;){
+--    // Scan through table looking for exited children.
+--    havekids = 0;
+--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--      if(p->parent != curproc)
+--        continue;
+--      havekids = 1;
+--      if(p->state == ZOMBIE){
+--        // Found one.
+--        pid = p->pid;
+--        kfree(p->kstack);
+--        p->kstack = 0;
+--        freevm(p->pgdir);
+--        p->pid = 0;
+--        p->parent = 0;
+--        p->name[0] = 0;
+--        p->killed = 0;
+--        p->state = UNUSED;
+--        release(&ptable.lock);
+--        return pid;
+--      }
+--    }
+-+wait(int *status) {
+-+    struct proc *p;
+-+    int havekids, pid;
+-+    struct proc *curproc = myproc();
+- 
+--    // No point waiting if we don't have any children.
+--    if(!havekids || curproc->killed){
+--      release(&ptable.lock);
+--      return -1;
+-+    acquire(&ptable.lock);
+-+    for (;;) {
+-+        // Scan through table looking for exited children.
+-+        havekids = 0;
+-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+            if (p->parent != curproc)
+-+                continue;
+-+            havekids = 1;
+-+            if (p->state == ZOMBIE) {
+-+                // Found one.
+-+                pid = p->pid;
+-+                kfree(p->kstack);
+-+                p->kstack = 0;
+-+                freevm(p->pgdir);
+-+                p->pid = 0;
+-+                p->parent = 0;
+-+                p->name[0] = 0;
+-+                p->killed = 0;
+-+                p->state = UNUSED;
+-+                release(&ptable.lock);
+-+                if (status != NULL)
+-+                    *status = p->status;
+-+                return pid;
+-+            }
+-+        }
+-+
+-+        // No point waiting if we don't have any children.
+-+        if (!havekids || curproc->killed) {
+-+            release(&ptable.lock);
+-+            return -1;
+-+        }
+-+
+-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+-     }
+-+}
+- 
+--    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+--    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+--  }
+-+// Wait for a child process to exit and return its pid.
+-+// Return -1 if this process has no children.
+-+int
+-+waitpid(int pidBeingSearchedFor, int *status, int options) {
+-+    struct proc *p;
+-+    int doesProcExist, pidFound;
+-+    struct proc *curproc = myproc();
+-+    acquire(&ptable.lock);
+-+    for (;;) {
+-+        // Scan through table looking for exited children.
+-+        doesProcExist = 0;
+-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+//            if(p->parent != curproc)
+-+//                continue;
+-+
+-+            if (p->pid != pidBeingSearchedFor)
+-+                continue;
+-+
+-+            doesProcExist = 1;
+-+            if (p->state == ZOMBIE) {
+-+                // Found one.
+-+                pidFound = p->pid;
+-+                kfree(p->kstack);
+-+                p->kstack = 0;
+-+                freevm(p->pgdir);
+-+                p->pid = 0;
+-+                p->parent = 0;
+-+                p->name[0] = 0;
+-+                p->killed = 0;
+-+                p->state = UNUSED;
+-+                release(&ptable.lock);
+-+                if (status != NULL)
+-+                    *status = p->status;
+-+                return pidFound;
+-+            }
+-+        }
+-+
+-+//        // No point waiting if we don't have any children.
+-+//        if(!havekids || curproc->killed){
+-+//            release(&ptable.lock);
+-+//            return -1;
+-+//        }
+-+
+-+        if (!doesProcExist || curproc->killed) {
+-+            release(&ptable.lock);
+-+            return -1;
+-+        }
+-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+-+    }
+- }
+- 
+- //PAGEBREAK: 42
+-@@ -320,39 +372,38 @@ wait(void)
+- //  - eventually that process transfers control
+- //      via swtch back to the scheduler.
+- void
+--scheduler(void)
+--{
+--  struct proc *p;
+--  struct cpu *c = mycpu();
+--  c->proc = 0;
+--  
+--  for(;;){
+--    // Enable interrupts on this processor.
+--    sti();
+--
+--    // Loop over process table looking for process to run.
+--    acquire(&ptable.lock);
+--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--      if(p->state != RUNNABLE)
+--        continue;
+--
+--      // Switch to chosen process.  It is the process's job
+--      // to release ptable.lock and then reacquire it
+--      // before jumping back to us.
+--      c->proc = p;
+--      switchuvm(p);
+--      p->state = RUNNING;
+--
+--      swtch(&(c->scheduler), p->context);
+--      switchkvm();
+--
+--      // Process is done running for now.
+--      // It should have changed its p->state before coming back.
+--      c->proc = 0;
+--    }
+--    release(&ptable.lock);
+-+scheduler(void) {
+-+    struct proc *p;
+-+    struct cpu *c = mycpu();
+-+    c->proc = 0;
+-+
+-+    for (;;) {
+-+        // Enable interrupts on this processor.
+-+        sti();
+-+
+-+        // Loop over process table looking for process to run.
+-+        acquire(&ptable.lock);
+-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+            if (p->state != RUNNABLE)
+-+                continue;
+-+
+-+            // Switch to chosen process.  It is the process's job
+-+            // to release ptable.lock and then reacquire it
+-+            // before jumping back to us.
+-+            c->proc = p;
+-+            switchuvm(p);
+-+            p->state = RUNNING;
+-+
+-+            swtch(&(c->scheduler), p->context);
+-+            switchkvm();
+-+
+-+            // Process is done running for now.
+-+            // It should have changed its p->state before coming back.
+-+            c->proc = 0;
+-+        }
+-+        release(&ptable.lock);
+- 
+--  }
+-+    }
+- }
+- 
+- // Enter scheduler.  Must hold only ptable.lock
+-@@ -363,137 +414,130 @@ scheduler(void)
+- // break in the few places where a lock is held but
+- // there's no process.
+- void
+--sched(void)
+--{
+--  int intena;
+--  struct proc *p = myproc();
+--
+--  if(!holding(&ptable.lock))
+--    panic("sched ptable.lock");
+--  if(mycpu()->ncli != 1)
+--    panic("sched locks");
+--  if(p->state == RUNNING)
+--    panic("sched running");
+--  if(readeflags()&FL_IF)
+--    panic("sched interruptible");
+--  intena = mycpu()->intena;
+--  swtch(&p->context, mycpu()->scheduler);
+--  mycpu()->intena = intena;
+-+sched(void) {
+-+    int intena;
+-+    struct proc *p = myproc();
+-+
+-+    if (!holding(&ptable.lock))
+-+        panic("sched ptable.lock");
+-+    if (mycpu()->ncli != 1)
+-+        panic("sched locks");
+-+    if (p->state == RUNNING)
+-+        panic("sched running");
+-+    if (readeflags() & FL_IF)
+-+        panic("sched interruptible");
+-+    intena = mycpu()->intena;
+-+    swtch(&p->context, mycpu()->scheduler);
+-+    mycpu()->intena = intena;
+- }
+- 
+- // Give up the CPU for one scheduling round.
+- void
+--yield(void)
+--{
+--  acquire(&ptable.lock);  //DOC: yieldlock
+--  myproc()->state = RUNNABLE;
+--  sched();
+--  release(&ptable.lock);
+-+yield(void) {
+-+    acquire(&ptable.lock);  //DOC: yieldlock
+-+    myproc()->state = RUNNABLE;
+-+    sched();
+-+    release(&ptable.lock);
+- }
+- 
+- // A fork child's very first scheduling by scheduler()
+- // will swtch here.  "Return" to user space.
+- void
+--forkret(void)
+--{
+--  static int first = 1;
+--  // Still holding ptable.lock from scheduler.
+--  release(&ptable.lock);
+--
+--  if (first) {
+--    // Some initialization functions must be run in the context
+--    // of a regular process (e.g., they call sleep), and thus cannot
+--    // be run from main().
+--    first = 0;
+--    iinit(ROOTDEV);
+--    initlog(ROOTDEV);
+--  }
+--
+--  // Return to "caller", actually trapret (see allocproc).
+-+forkret(void) {
+-+    static int first = 1;
+-+    // Still holding ptable.lock from scheduler.
+-+    release(&ptable.lock);
+-+
+-+    if (first) {
+-+        // Some initialization functions must be run in the context
+-+        // of a regular process (e.g., they call sleep), and thus cannot
+-+        // be run from main().
+-+        first = 0;
+-+        iinit(ROOTDEV);
+-+        initlog(ROOTDEV);
+-+    }
+-+
+-+    // Return to "caller", actually trapret (see allocproc).
+- }
+- 
+- // Atomically release lock and sleep on chan.
+- // Reacquires lock when awakened.
+- void
+--sleep(void *chan, struct spinlock *lk)
+--{
+--  struct proc *p = myproc();
+--  
+--  if(p == 0)
+--    panic("sleep");
+--
+--  if(lk == 0)
+--    panic("sleep without lk");
+--
+--  // Must acquire ptable.lock in order to
+--  // change p->state and then call sched.
+--  // Once we hold ptable.lock, we can be
+--  // guaranteed that we won't miss any wakeup
+--  // (wakeup runs with ptable.lock locked),
+--  // so it's okay to release lk.
+--  if(lk != &ptable.lock){  //DOC: sleeplock0
+--    acquire(&ptable.lock);  //DOC: sleeplock1
+--    release(lk);
+--  }
+--  // Go to sleep.
+--  p->chan = chan;
+--  p->state = SLEEPING;
+--
+--  sched();
+--
+--  // Tidy up.
+--  p->chan = 0;
+--
+--  // Reacquire original lock.
+--  if(lk != &ptable.lock){  //DOC: sleeplock2
+--    release(&ptable.lock);
+--    acquire(lk);
+--  }
+-+sleep(void *chan, struct spinlock *lk) {
+-+    struct proc *p = myproc();
+-+
+-+    if (p == 0)
+-+        panic("sleep");
+-+
+-+    if (lk == 0)
+-+        panic("sleep without lk");
+-+
+-+    // Must acquire ptable.lock in order to
+-+    // change p->state and then call sched.
+-+    // Once we hold ptable.lock, we can be
+-+    // guaranteed that we won't miss any wakeup
+-+    // (wakeup runs with ptable.lock locked),
+-+    // so it's okay to release lk.
+-+    if (lk != &ptable.lock) {  //DOC: sleeplock0
+-+        acquire(&ptable.lock);  //DOC: sleeplock1
+-+        release(lk);
+-+    }
+-+    // Go to sleep.
+-+    p->chan = chan;
+-+    p->state = SLEEPING;
+-+
+-+    sched();
+-+
+-+    // Tidy up.
+-+    p->chan = 0;
+-+
+-+    // Reacquire original lock.
+-+    if (lk != &ptable.lock) {  //DOC: sleeplock2
+-+        release(&ptable.lock);
+-+        acquire(lk);
+-+    }
+- }
+- 
+- //PAGEBREAK!
+- // Wake up all processes sleeping on chan.
+- // The ptable lock must be held.
+- static void
+--wakeup1(void *chan)
+--{
+--  struct proc *p;
+-+wakeup1(void *chan) {
+-+    struct proc *p;
+- 
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+--    if(p->state == SLEEPING && p->chan == chan)
+--      p->state = RUNNABLE;
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-+        if (p->state == SLEEPING && p->chan == chan)
+-+            p->state = RUNNABLE;
+- }
+- 
+- // Wake up all processes sleeping on chan.
+- void
+--wakeup(void *chan)
+--{
+--  acquire(&ptable.lock);
+--  wakeup1(chan);
+--  release(&ptable.lock);
+-+wakeup(void *chan) {
+-+    acquire(&ptable.lock);
+-+    wakeup1(chan);
+-+    release(&ptable.lock);
+- }
+- 
+- // Kill the process with the given pid.
+- // Process won't exit until it returns
+- // to user space (see trap in trap.c).
+- int
+--kill(int pid)
+--{
+--  struct proc *p;
+--
+--  acquire(&ptable.lock);
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--    if(p->pid == pid){
+--      p->killed = 1;
+--      // Wake process from sleep if necessary.
+--      if(p->state == SLEEPING)
+--        p->state = RUNNABLE;
+--      release(&ptable.lock);
+--      return 0;
+-+kill(int pid) {
+-+    struct proc *p;
+-+
+-+    acquire(&ptable.lock);
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+        if (p->pid == pid) {
+-+            p->killed = 1;
+-+            // Wake process from sleep if necessary.
+-+            if (p->state == SLEEPING)
+-+                p->state = RUNNABLE;
+-+            release(&ptable.lock);
+-+            return 0;
+-+        }
+-     }
+--  }
+--  release(&ptable.lock);
+--  return -1;
+-+    release(&ptable.lock);
+-+    return -1;
+- }
+- 
+- //PAGEBREAK: 36
+-@@ -501,34 +545,33 @@ kill(int pid)
+- // Runs when user types ^P on console.
+- // No lock to avoid wedging a stuck machine further.
+- void
+--procdump(void)
+--{
+--  static char *states[] = {
+--  [UNUSED]    "unused",
+--  [EMBRYO]    "embryo",
+--  [SLEEPING]  "sleep ",
+--  [RUNNABLE]  "runble",
+--  [RUNNING]   "run   ",
+--  [ZOMBIE]    "zombie"
+--  };
+--  int i;
+--  struct proc *p;
+--  char *state;
+--  uint pc[10];
+--
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--    if(p->state == UNUSED)
+--      continue;
+--    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+--      state = states[p->state];
+--    else
+--      state = "???";
+--    cprintf("%d %s %s", p->pid, state, p->name);
+--    if(p->state == SLEEPING){
+--      getcallerpcs((uint*)p->context->ebp+2, pc);
+--      for(i=0; i<10 && pc[i] != 0; i++)
+--        cprintf(" %p", pc[i]);
+-+procdump(void) {
+-+    static char *states[] = {
+-+            [UNUSED]    "unused",
+-+            [EMBRYO]    "embryo",
+-+            [SLEEPING]  "sleep ",
+-+            [RUNNABLE]  "runble",
+-+            [RUNNING]   "run   ",
+-+            [ZOMBIE]    "zombie"
+-+    };
+-+    int i;
+-+    struct proc *p;
+-+    char *state;
+-+    uint pc[10];
+-+
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+        if (p->state == UNUSED)
+-+            continue;
+-+        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
+-+            state = states[p->state];
+-+        else
+-+            state = "???";
+-+        cprintf("%d %s %s", p->pid, state, p->name);
+-+        if (p->state == SLEEPING) {
+-+            getcallerpcs((uint *) p->context->ebp + 2, pc);
+-+            for (i = 0; i < 10 && pc[i] != 0; i++)
+-+                cprintf(" %p", pc[i]);
+-+        }
+-+        cprintf("\n");
+-     }
+--    cprintf("\n");
+--  }
+- }
+-diff --git a/proc.h b/proc.h
+-index 1647114..a06b921 100644
+---- a/proc.h
+-+++ b/proc.h
+-@@ -49,6 +49,7 @@ struct proc {
+-   struct file *ofile[NOFILE];  // Open files
+-   struct inode *cwd;           // Current directory
+-   char name[16];               // Process name (debugging)
+-+  int status;                  // Exit status
+- };
+- 
+- // Process memory is laid out contiguously, low addresses first:
+-diff --git a/rm.c b/rm.c
+-index 4fd33c8..1e6daec 100644
+---- a/rm.c
+-+++ b/rm.c
+-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
+- 
+-   if(argc < 2){
+-     printf(2, "Usage: rm files...\n");
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
+-     }
+-   }
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/runoff b/runoff
+-old mode 100755
+-new mode 100644
+-diff --git a/runoff1 b/runoff1
+-old mode 100755
+-new mode 100644
+-diff --git a/sh.c b/sh.c
+-index 054bab9..ca2ae37 100644
+---- a/sh.c
+-+++ b/sh.c
+-@@ -65,7 +65,7 @@ runcmd(struct cmd *cmd)
+-   struct redircmd *rcmd;
+- 
+-   if(cmd == 0)
+--    exit();
+-+    exit(1);
+- 
+-   switch(cmd->type){
+-   default:
+-@@ -74,7 +74,7 @@ runcmd(struct cmd *cmd)
+-   case EXEC:
+-     ecmd = (struct execcmd*)cmd;
+-     if(ecmd->argv[0] == 0)
+--      exit();
+-+      exit(2);
+-     exec(ecmd->argv[0], ecmd->argv);
+-     printf(2, "exec %s failed\n", ecmd->argv[0]);
+-     break;
+-@@ -84,7 +84,7 @@ runcmd(struct cmd *cmd)
+-     close(rcmd->fd);
+-     if(open(rcmd->file, rcmd->mode) < 0){
+-       printf(2, "open %s failed\n", rcmd->file);
+--      exit();
+-+      exit(6);
+-     }
+-     runcmd(rcmd->cmd);
+-     break;
+-@@ -93,7 +93,7 @@ runcmd(struct cmd *cmd)
+-     lcmd = (struct listcmd*)cmd;
+-     if(fork1() == 0)
+-       runcmd(lcmd->left);
+--    wait();
+-+    wait(NULL);
+-     runcmd(lcmd->right);
+-     break;
+- 
+-@@ -117,8 +117,8 @@ runcmd(struct cmd *cmd)
+-     }
+-     close(p[0]);
+-     close(p[1]);
+--    wait();
+--    wait();
+-+    wait(NULL);
+-+    wait(NULL);
+-     break;
+- 
+-   case BACK:
+-@@ -127,7 +127,7 @@ runcmd(struct cmd *cmd)
+-       runcmd(bcmd->cmd);
+-     break;
+-   }
+--  exit();
+-+  exit(3);
+- }
+- 
+- int
+-@@ -166,16 +166,16 @@ main(void)
+-     }
+-     if(fork1() == 0)
+-       runcmd(parsecmd(buf));
+--    wait();
+-+    wait(NULL);
+-   }
+--  exit();
+-+  exit(0);
+- }
+- 
+- void
+- panic(char *s)
+- {
+-   printf(2, "%s\n", s);
+--  exit();
+-+  exit(5);
+- }
+- 
+- int
+-diff --git a/show1 b/show1
+-old mode 100755
+-new mode 100644
+-diff --git a/sign.pl b/sign.pl
+-old mode 100755
+-new mode 100644
+-diff --git a/spinp b/spinp
+-old mode 100755
+-new mode 100644
+-diff --git a/stressfs.c b/stressfs.c
+-index c0a4743..46e0e66 100644
+---- a/stressfs.c
+-+++ b/stressfs.c
+-@@ -43,7 +43,7 @@ main(int argc, char *argv[])
+-     read(fd, data, sizeof(data));
+-   close(fd);
+- 
+--  wait();
+-+  wait(NULL);
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/syscall.c b/syscall.c
+-index ee85261..41a8c3c 100644
+---- a/syscall.c
+-+++ b/syscall.c
+-@@ -101,6 +101,7 @@ extern int sys_sbrk(void);
+- extern int sys_sleep(void);
+- extern int sys_unlink(void);
+- extern int sys_wait(void);
+-+extern int sys_waitpid(void);
+- extern int sys_write(void);
+- extern int sys_uptime(void);
+- 
+-@@ -108,6 +109,7 @@ static int (*syscalls[])(void) = {
+- [SYS_fork]    sys_fork,
+- [SYS_exit]    sys_exit,
+- [SYS_wait]    sys_wait,
+-+[SYS_waitpid] sys_waitpid,
+- [SYS_pipe]    sys_pipe,
+- [SYS_read]    sys_read,
+- [SYS_kill]    sys_kill,
+-diff --git a/syscall.h b/syscall.h
+-index bc5f356..374ff05 100644
+---- a/syscall.h
+-+++ b/syscall.h
+-@@ -1,22 +1,23 @@
+- // System call numbers
+--#define SYS_fork    1
+--#define SYS_exit    2
+--#define SYS_wait    3
+--#define SYS_pipe    4
+--#define SYS_read    5
+--#define SYS_kill    6
+--#define SYS_exec    7
+--#define SYS_fstat   8
+--#define SYS_chdir   9
+--#define SYS_dup    10
+--#define SYS_getpid 11
+--#define SYS_sbrk   12
+--#define SYS_sleep  13
+--#define SYS_uptime 14
+--#define SYS_open   15
+--#define SYS_write  16
+--#define SYS_mknod  17
+--#define SYS_unlink 18
+--#define SYS_link   19
+--#define SYS_mkdir  20
+--#define SYS_close  21
+-+#define SYS_fork     1
+-+#define SYS_exit     2
+-+#define SYS_wait     3
+-+#define SYS_pipe     4
+-+#define SYS_read     5
+-+#define SYS_kill     6
+-+#define SYS_exec     7
+-+#define SYS_fstat    8
+-+#define SYS_chdir    9
+-+#define SYS_dup     10
+-+#define SYS_getpid  11
+-+#define SYS_sbrk    12
+-+#define SYS_sleep   13
+-+#define SYS_uptime  14
+-+#define SYS_open    15
+-+#define SYS_write   16
+-+#define SYS_mknod   17
+-+#define SYS_unlink  18
+-+#define SYS_link    19
+-+#define SYS_mkdir   20
+-+#define SYS_close   21
+-+#define SYS_waitpid 22
+-\ No newline at end of file
+-diff --git a/sysproc.c b/sysproc.c
+-index 0686d29..ebccf84 100644
+---- a/sysproc.c
+-+++ b/sysproc.c
+-@@ -14,16 +14,22 @@ sys_fork(void)
+- }
+- 
+- int
+--sys_exit(void)
+-+sys_exit(int status)
+- {
+--  exit();
+-+  exit(status);
+-   return 0;  // not reached
+- }
+- 
+- int
+--sys_wait(void)
+-+sys_wait(int* status)
+- {
+--  return wait();
+-+  return wait(status);
+-+}
+-+
+-+int
+-+sys_waitpid(int pid, int* status, int options)
+-+{
+-+    return waitpid(pid, status, options);
+- }
+- 
+- int
+-diff --git a/trap.c b/trap.c
+-index 41c66eb..432ea5b 100644
+---- a/trap.c
+-+++ b/trap.c
+-@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
+- {
+-   if(tf->trapno == T_SYSCALL){
+-     if(myproc()->killed)
+--      exit();
+-+      exit(4);
+-     myproc()->tf = tf;
+-     syscall();
+-     if(myproc()->killed)
+--      exit();
+-+      exit(3);
+-     return;
+-   }
+- 
+-@@ -98,7 +98,7 @@ trap(struct trapframe *tf)
+-   // (If it is still executing in the kernel, let it keep running
+-   // until it gets to the regular system call return.)
+-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+--    exit();
+-+    exit(2);
+- 
+-   // Force process to give up CPU on clock tick.
+-   // If interrupts were on while locks held, would need to check nlock.
+-@@ -108,5 +108,5 @@ trap(struct trapframe *tf)
+- 
+-   // Check if the process has been killed since we yielded
+-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+--    exit();
+-+    exit(1);
+- }
+-diff --git a/user.h b/user.h
+-index 4f99c52..0931387 100644
+---- a/user.h
+-+++ b/user.h
+-@@ -1,10 +1,13 @@
+-+#include <stddef.h>
+-+
+- struct stat;
+- struct rtcdate;
+- 
+- // system calls
+- int fork(void);
+--int exit(void) __attribute__((noreturn));
+--int wait(void);
+-+int exit(int status) __attribute__((noreturn));
+-+int wait(int* status);
+-+int waitpid(int pid, int* status, int options);
+- int pipe(int*);
+- int write(int, const void*, int);
+- int read(int, void*, int);
+-diff --git a/usertests.c b/usertests.c
+-index a1e97e7..2c2c128 100644
+---- a/usertests.c
+-+++ b/usertests.c
+-@@ -21,19 +21,19 @@ iputtest(void)
+- 
+-   if(mkdir("iputdir") < 0){
+-     printf(stdout, "mkdir failed\n");
+--    exit();
+-+    exit(184);
+-   }
+-   if(chdir("iputdir") < 0){
+-     printf(stdout, "chdir iputdir failed\n");
+--    exit();
+-+    exit(183);
+-   }
+-   if(unlink("../iputdir") < 0){
+-     printf(stdout, "unlink ../iputdir failed\n");
+--    exit();
+-+    exit(182);
+-   }
+-   if(chdir("/") < 0){
+-     printf(stdout, "chdir / failed\n");
+--    exit();
+-+    exit(181);
+-   }
+-   printf(stdout, "iput test ok\n");
+- }
+-@@ -49,24 +49,24 @@ exitiputtest(void)
+-   pid = fork();
+-   if(pid < 0){
+-     printf(stdout, "fork failed\n");
+--    exit();
+-+    exit(180);
+-   }
+-   if(pid == 0){
+-     if(mkdir("iputdir") < 0){
+-       printf(stdout, "mkdir failed\n");
+--      exit();
+-+      exit(179);
+-     }
+-     if(chdir("iputdir") < 0){
+-       printf(stdout, "child chdir failed\n");
+--      exit();
+-+      exit(178);
+-     }
+-     if(unlink("../iputdir") < 0){
+-       printf(stdout, "unlink ../iputdir failed\n");
+--      exit();
+-+      exit(177);
+-     }
+--    exit();
+-+    exit(176);
+-   }
+--  wait();
+-+  wait(NULL);
+-   printf(stdout, "exitiput test ok\n");
+- }
+- 
+-@@ -89,27 +89,27 @@ openiputtest(void)
+-   printf(stdout, "openiput test\n");
+-   if(mkdir("oidir") < 0){
+-     printf(stdout, "mkdir oidir failed\n");
+--    exit();
+-+    exit(175);
+-   }
+-   pid = fork();
+-   if(pid < 0){
+-     printf(stdout, "fork failed\n");
+--    exit();
+-+    exit(174);
+-   }
+-   if(pid == 0){
+-     int fd = open("oidir", O_RDWR);
+-     if(fd >= 0){
+-       printf(stdout, "open directory for write succeeded\n");
+--      exit();
+-+      exit(0);
+-     }
+--    exit();
+-+    exit(172);
+-   }
+-   sleep(1);
+-   if(unlink("oidir") != 0){
+-     printf(stdout, "unlink failed\n");
+--    exit();
+-+    exit(171);
+-   }
+--  wait();
+-+  wait(NULL);
+-   printf(stdout, "openiput test ok\n");
+- }
+- 
+-@@ -124,13 +124,13 @@ opentest(void)
+-   fd = open("echo", 0);
+-   if(fd < 0){
+-     printf(stdout, "open echo failed!\n");
+--    exit();
+-+    exit(170);
+-   }
+-   close(fd);
+-   fd = open("doesnotexist", 0);
+-   if(fd >= 0){
+-     printf(stdout, "open doesnotexist succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   printf(stdout, "open test ok\n");
+- }
+-@@ -147,16 +147,16 @@ writetest(void)
+-     printf(stdout, "creat small succeeded; ok\n");
+-   } else {
+-     printf(stdout, "error: creat small failed!\n");
+--    exit();
+-+    exit(168);
+-   }
+-   for(i = 0; i < 100; i++){
+-     if(write(fd, "aaaaaaaaaa", 10) != 10){
+-       printf(stdout, "error: write aa %d new file failed\n", i);
+--      exit();
+-+      exit(167);
+-     }
+-     if(write(fd, "bbbbbbbbbb", 10) != 10){
+-       printf(stdout, "error: write bb %d new file failed\n", i);
+--      exit();
+-+      exit(166);
+-     }
+-   }
+-   printf(stdout, "writes ok\n");
+-@@ -166,20 +166,20 @@ writetest(void)
+-     printf(stdout, "open small succeeded ok\n");
+-   } else {
+-     printf(stdout, "error: open small failed!\n");
+--    exit();
+-+    exit(165);
+-   }
+-   i = read(fd, buf, 2000);
+-   if(i == 2000){
+-     printf(stdout, "read succeeded ok\n");
+-   } else {
+-     printf(stdout, "read failed\n");
+--    exit();
+-+    exit(164);
+-   }
+-   close(fd);
+- 
+-   if(unlink("small") < 0){
+-     printf(stdout, "unlink small failed\n");
+--    exit();
+-+    exit(163);
+-   }
+-   printf(stdout, "small file test ok\n");
+- }
+-@@ -194,14 +194,14 @@ writetest1(void)
+-   fd = open("big", O_CREATE|O_RDWR);
+-   if(fd < 0){
+-     printf(stdout, "error: creat big failed!\n");
+--    exit();
+-+    exit(162);
+-   }
+- 
+-   for(i = 0; i < MAXFILE; i++){
+-     ((int*)buf)[0] = i;
+-     if(write(fd, buf, 512) != 512){
+-       printf(stdout, "error: write big file failed\n", i);
+--      exit();
+-+      exit(161);
+-     }
+-   }
+- 
+-@@ -210,7 +210,7 @@ writetest1(void)
+-   fd = open("big", O_RDONLY);
+-   if(fd < 0){
+-     printf(stdout, "error: open big failed!\n");
+--    exit();
+-+    exit(160);
+-   }
+- 
+-   n = 0;
+-@@ -219,24 +219,24 @@ writetest1(void)
+-     if(i == 0){
+-       if(n == MAXFILE - 1){
+-         printf(stdout, "read only %d blocks from big", n);
+--        exit();
+-+        exit(159);
+-       }
+-       break;
+-     } else if(i != 512){
+-       printf(stdout, "read failed %d\n", i);
+--      exit();
+-+      exit(158);
+-     }
+-     if(((int*)buf)[0] != n){
+-       printf(stdout, "read content of block %d is %d\n",
+-              n, ((int*)buf)[0]);
+--      exit();
+-+      exit(157);
+-     }
+-     n++;
+-   }
+-   close(fd);
+-   if(unlink("big") < 0){
+-     printf(stdout, "unlink big failed\n");
+--    exit();
+-+    exit(156);
+-   }
+-   printf(stdout, "big files ok\n");
+- }
+-@@ -270,22 +270,22 @@ void dirtest(void)
+- 
+-   if(mkdir("dir0") < 0){
+-     printf(stdout, "mkdir failed\n");
+--    exit();
+-+    exit(155);
+-   }
+- 
+-   if(chdir("dir0") < 0){
+-     printf(stdout, "chdir dir0 failed\n");
+--    exit();
+-+    exit(154);
+-   }
+- 
+-   if(chdir("..") < 0){
+-     printf(stdout, "chdir .. failed\n");
+--    exit();
+-+    exit(153);
+-   }
+- 
+-   if(unlink("dir0") < 0){
+-     printf(stdout, "unlink dir0 failed\n");
+--    exit();
+-+    exit(152);
+-   }
+-   printf(stdout, "mkdir test ok\n");
+- }
+-@@ -296,7 +296,7 @@ exectest(void)
+-   printf(stdout, "exec test\n");
+-   if(exec("echo", echoargv) < 0){
+-     printf(stdout, "exec echo failed\n");
+--    exit();
+-+    exit(151);
+-   }
+- }
+- 
+-@@ -310,7 +310,7 @@ pipe1(void)
+- 
+-   if(pipe(fds) != 0){
+-     printf(1, "pipe() failed\n");
+--    exit();
+-+    exit(150);
+-   }
+-   pid = fork();
+-   seq = 0;
+-@@ -321,10 +321,10 @@ pipe1(void)
+-         buf[i] = seq++;
+-       if(write(fds[1], buf, 1033) != 1033){
+-         printf(1, "pipe1 oops 1\n");
+--        exit();
+-+        exit(149);
+-       }
+-     }
+--    exit();
+-+    exit(148);
+-   } else if(pid > 0){
+-     close(fds[1]);
+-     total = 0;
+-@@ -343,13 +343,13 @@ pipe1(void)
+-     }
+-     if(total != 5 * 1033){
+-       printf(1, "pipe1 oops 3 total %d\n", total);
+--      exit();
+-+      exit(147);
+-     }
+-     close(fds[0]);
+--    wait();
+-+    wait(NULL);
+-   } else {
+-     printf(1, "fork() failed\n");
+--    exit();
+-+    exit(146);
+-   }
+-   printf(1, "pipe1 ok\n");
+- }
+-@@ -394,9 +394,9 @@ preempt(void)
+-   kill(pid2);
+-   kill(pid3);
+-   printf(1, "wait... ");
+--  wait();
+--  wait();
+--  wait();
+-+  wait(NULL);
+-+  wait(NULL);
+-+  wait(NULL);
+-   printf(1, "preempt ok\n");
+- }
+- 
+-@@ -413,12 +413,12 @@ exitwait(void)
+-       return;
+-     }
+-     if(pid){
+--      if(wait() != pid){
+-+      if(wait(NULL) != pid){
+-         printf(1, "wait wrong pid\n");
+-         return;
+-       }
+-     } else {
+--      exit();
+-+      exit(145);
+-     }
+-   }
+-   printf(1, "exitwait ok\n");
+-@@ -447,13 +447,13 @@ mem(void)
+-     if(m1 == 0){
+-       printf(1, "couldn't allocate mem?!!\n");
+-       kill(ppid);
+--      exit();
+-+      exit(144);
+-     }
+-     free(m1);
+-     printf(1, "mem ok\n");
+--    exit();
+-+    exit(0);
+-   } else {
+--    wait();
+-+    wait(NULL);
+-   }
+- }
+- 
+-@@ -484,9 +484,9 @@ sharedfd(void)
+-     }
+-   }
+-   if(pid == 0)
+--    exit();
+-+    exit(142);
+-   else
+--    wait();
+-+    wait(NULL);
+-   close(fd);
+-   fd = open("sharedfd", 0);
+-   if(fd < 0){
+-@@ -508,7 +508,7 @@ sharedfd(void)
+-     printf(1, "sharedfd ok\n");
+-   } else {
+-     printf(1, "sharedfd oops %d %d\n", nc, np);
+--    exit();
+-+    exit(141);
+-   }
+- }
+- 
+-@@ -530,29 +530,29 @@ fourfiles(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "fork failed\n");
+--      exit();
+-+      exit(140);
+-     }
+- 
+-     if(pid == 0){
+-       fd = open(fname, O_CREATE | O_RDWR);
+-       if(fd < 0){
+-         printf(1, "create failed\n");
+--        exit();
+-+        exit(139);
+-       }
+- 
+-       memset(buf, '0'+pi, 512);
+-       for(i = 0; i < 12; i++){
+-         if((n = write(fd, buf, 500)) != 500){
+-           printf(1, "write failed %d\n", n);
+--          exit();
+-+          exit(138);
+-         }
+-       }
+--      exit();
+-+      exit(137);
+-     }
+-   }
+- 
+-   for(pi = 0; pi < 4; pi++){
+--    wait();
+-+    wait(NULL);
+-   }
+- 
+-   for(i = 0; i < 2; i++){
+-@@ -563,7 +563,7 @@ fourfiles(void)
+-       for(j = 0; j < n; j++){
+-         if(buf[j] != '0'+i){
+-           printf(1, "wrong char\n");
+--          exit();
+-+          exit(136);
+-         }
+-       }
+-       total += n;
+-@@ -571,7 +571,7 @@ fourfiles(void)
+-     close(fd);
+-     if(total != 12*500){
+-       printf(1, "wrong length %d\n", total);
+--      exit();
+-+      exit(135);
+-     }
+-     unlink(fname);
+-   }
+-@@ -593,7 +593,7 @@ createdelete(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "fork failed\n");
+--      exit();
+-+      exit(134);
+-     }
+- 
+-     if(pid == 0){
+-@@ -604,23 +604,23 @@ createdelete(void)
+-         fd = open(name, O_CREATE | O_RDWR);
+-         if(fd < 0){
+-           printf(1, "create failed\n");
+--          exit();
+-+          exit(133);
+-         }
+-         close(fd);
+-         if(i > 0 && (i % 2 ) == 0){
+-           name[1] = '0' + (i / 2);
+-           if(unlink(name) < 0){
+-             printf(1, "unlink failed\n");
+--            exit();
+-+            exit(132);
+-           }
+-         }
+-       }
+--      exit();
+-+      exit(131);
+-     }
+-   }
+- 
+-   for(pi = 0; pi < 4; pi++){
+--    wait();
+-+    wait(NULL);
+-   }
+- 
+-   name[0] = name[1] = name[2] = 0;
+-@@ -631,10 +631,10 @@ createdelete(void)
+-       fd = open(name, 0);
+-       if((i == 0 || i >= N/2) && fd < 0){
+-         printf(1, "oops createdelete %s didn't exist\n", name);
+--        exit();
+-+        exit(130);
+-       } else if((i >= 1 && i < N/2) && fd >= 0){
+-         printf(1, "oops createdelete %s did exist\n", name);
+--        exit();
+-+        exit(129);
+-       }
+-       if(fd >= 0)
+-         close(fd);
+-@@ -662,7 +662,7 @@ unlinkread(void)
+-   fd = open("unlinkread", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create unlinkread failed\n");
+--    exit();
+-+    exit(128);
+-   }
+-   write(fd, "hello", 5);
+-   close(fd);
+-@@ -670,11 +670,11 @@ unlinkread(void)
+-   fd = open("unlinkread", O_RDWR);
+-   if(fd < 0){
+-     printf(1, "open unlinkread failed\n");
+--    exit();
+-+    exit(127);
+-   }
+-   if(unlink("unlinkread") != 0){
+-     printf(1, "unlink unlinkread failed\n");
+--    exit();
+-+    exit(126);
+-   }
+- 
+-   fd1 = open("unlinkread", O_CREATE | O_RDWR);
+-@@ -683,15 +683,15 @@ unlinkread(void)
+- 
+-   if(read(fd, buf, sizeof(buf)) != 5){
+-     printf(1, "unlinkread read failed");
+--    exit();
+-+    exit(125);
+-   }
+-   if(buf[0] != 'h'){
+-     printf(1, "unlinkread wrong data\n");
+--    exit();
+-+    exit(124);
+-   }
+-   if(write(fd, buf, 10) != 10){
+-     printf(1, "unlinkread write failed\n");
+--    exit();
+-+    exit(123);
+-   }
+-   close(fd);
+-   unlink("unlinkread");
+-@@ -711,50 +711,50 @@ linktest(void)
+-   fd = open("lf1", O_CREATE|O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create lf1 failed\n");
+--    exit();
+-+    exit(122);
+-   }
+-   if(write(fd, "hello", 5) != 5){
+-     printf(1, "write lf1 failed\n");
+--    exit();
+-+    exit(121);
+-   }
+-   close(fd);
+- 
+-   if(link("lf1", "lf2") < 0){
+-     printf(1, "link lf1 lf2 failed\n");
+--    exit();
+-+    exit(120);
+-   }
+-   unlink("lf1");
+- 
+-   if(open("lf1", 0) >= 0){
+-     printf(1, "unlinked lf1 but it is still there!\n");
+--    exit();
+-+    exit(119);
+-   }
+- 
+-   fd = open("lf2", 0);
+-   if(fd < 0){
+-     printf(1, "open lf2 failed\n");
+--    exit();
+-+    exit(118);
+-   }
+-   if(read(fd, buf, sizeof(buf)) != 5){
+-     printf(1, "read lf2 failed\n");
+--    exit();
+-+    exit(117);
+-   }
+-   close(fd);
+- 
+-   if(link("lf2", "lf2") >= 0){
+-     printf(1, "link lf2 lf2 succeeded! oops\n");
+--    exit();
+-+    exit(116);
+-   }
+- 
+-   unlink("lf2");
+-   if(link("lf2", "lf1") >= 0){
+-     printf(1, "link non-existant succeeded! oops\n");
+--    exit();
+-+    exit(115);
+-   }
+- 
+-   if(link(".", "lf1") >= 0){
+-     printf(1, "link . lf1 succeeded! oops\n");
+--    exit();
+-+    exit(114);
+-   }
+- 
+-   printf(1, "linktest ok\n");
+-@@ -787,14 +787,14 @@ concreate(void)
+-       fd = open(file, O_CREATE | O_RDWR);
+-       if(fd < 0){
+-         printf(1, "concreate create %s failed\n", file);
+--        exit();
+-+        exit(113);
+-       }
+-       close(fd);
+-     }
+-     if(pid == 0)
+--      exit();
+-+      exit(112);
+-     else
+--      wait();
+-+      wait(NULL);
+-   }
+- 
+-   memset(fa, 0, sizeof(fa));
+-@@ -807,11 +807,11 @@ concreate(void)
+-       i = de.name[1] - '0';
+-       if(i < 0 || i >= sizeof(fa)){
+-         printf(1, "concreate weird file %s\n", de.name);
+--        exit();
+-+        exit(111);
+-       }
+-       if(fa[i]){
+-         printf(1, "concreate duplicate file %s\n", de.name);
+--        exit();
+-+        exit(110);
+-       }
+-       fa[i] = 1;
+-       n++;
+-@@ -821,7 +821,7 @@ concreate(void)
+- 
+-   if(n != 40){
+-     printf(1, "concreate not enough files in directory listing\n");
+--    exit();
+-+    exit(109);
+-   }
+- 
+-   for(i = 0; i < 40; i++){
+-@@ -829,7 +829,7 @@ concreate(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "fork failed\n");
+--      exit();
+-+      exit(108);
+-     }
+-     if(((i % 3) == 0 && pid == 0) ||
+-        ((i % 3) == 1 && pid != 0)){
+-@@ -844,9 +844,9 @@ concreate(void)
+-       unlink(file);
+-     }
+-     if(pid == 0)
+--      exit();
+-+      exit(107);
+-     else
+--      wait();
+-+      wait(NULL);
+-   }
+- 
+-   printf(1, "concreate ok\n");
+-@@ -865,7 +865,7 @@ linkunlink()
+-   pid = fork();
+-   if(pid < 0){
+-     printf(1, "fork failed\n");
+--    exit();
+-+    exit(106);
+-   }
+- 
+-   unsigned int x = (pid ? 1 : 97);
+-@@ -881,9 +881,9 @@ linkunlink()
+-   }
+- 
+-   if(pid)
+--    wait();
+-+    wait(NULL);
+-   else
+--    exit();
+-+    exit(105);
+- 
+-   printf(1, "linkunlink ok\n");
+- }
+-@@ -901,7 +901,7 @@ bigdir(void)
+-   fd = open("bd", O_CREATE);
+-   if(fd < 0){
+-     printf(1, "bigdir create failed\n");
+--    exit();
+-+    exit(104);
+-   }
+-   close(fd);
+- 
+-@@ -912,7 +912,7 @@ bigdir(void)
+-     name[3] = '\0';
+-     if(link("bd", name) != 0){
+-       printf(1, "bigdir link failed\n");
+--      exit();
+-+      exit(103);
+-     }
+-   }
+- 
+-@@ -924,7 +924,7 @@ bigdir(void)
+-     name[3] = '\0';
+-     if(unlink(name) != 0){
+-       printf(1, "bigdir unlink failed");
+--      exit();
+-+      exit(102);
+-     }
+-   }
+- 
+-@@ -941,31 +941,31 @@ subdir(void)
+-   unlink("ff");
+-   if(mkdir("dd") != 0){
+-     printf(1, "subdir mkdir dd failed\n");
+--    exit();
+-+    exit(101);
+-   }
+- 
+-   fd = open("dd/ff", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create dd/ff failed\n");
+--    exit();
+-+    exit(100);
+-   }
+-   write(fd, "ff", 2);
+-   close(fd);
+- 
+-   if(unlink("dd") >= 0){
+-     printf(1, "unlink dd (non-empty dir) succeeded!\n");
+--    exit();
+-+    exit(99);
+-   }
+- 
+-   if(mkdir("/dd/dd") != 0){
+-     printf(1, "subdir mkdir dd/dd failed\n");
+--    exit();
+-+    exit(98);
+-   }
+- 
+-   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create dd/dd/ff failed\n");
+--    exit();
+-+    exit(97);
+-   }
+-   write(fd, "FF", 2);
+-   close(fd);
+-@@ -973,142 +973,142 @@ subdir(void)
+-   fd = open("dd/dd/../ff", 0);
+-   if(fd < 0){
+-     printf(1, "open dd/dd/../ff failed\n");
+--    exit();
+-+    exit(96);
+-   }
+-   cc = read(fd, buf, sizeof(buf));
+-   if(cc != 2 || buf[0] != 'f'){
+-     printf(1, "dd/dd/../ff wrong content\n");
+--    exit();
+-+    exit(95);
+-   }
+-   close(fd);
+- 
+-   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+-     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+--    exit();
+-+    exit(94);
+-   }
+- 
+-   if(unlink("dd/dd/ff") != 0){
+-     printf(1, "unlink dd/dd/ff failed\n");
+--    exit();
+-+    exit(93);
+-   }
+-   if(open("dd/dd/ff", O_RDONLY) >= 0){
+-     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+--    exit();
+-+    exit(92);
+-   }
+- 
+-   if(chdir("dd") != 0){
+-     printf(1, "chdir dd failed\n");
+--    exit();
+-+    exit(91);
+-   }
+-   if(chdir("dd/../../dd") != 0){
+-     printf(1, "chdir dd/../../dd failed\n");
+--    exit();
+-+    exit(90);
+-   }
+-   if(chdir("dd/../../../dd") != 0){
+-     printf(1, "chdir dd/../../dd failed\n");
+--    exit();
+-+    exit(89);
+-   }
+-   if(chdir("./..") != 0){
+-     printf(1, "chdir ./.. failed\n");
+--    exit();
+-+    exit(88);
+-   }
+- 
+-   fd = open("dd/dd/ffff", 0);
+-   if(fd < 0){
+-     printf(1, "open dd/dd/ffff failed\n");
+--    exit();
+-+    exit(87);
+-   }
+-   if(read(fd, buf, sizeof(buf)) != 2){
+-     printf(1, "read dd/dd/ffff wrong len\n");
+--    exit();
+-+    exit(86);
+-   }
+-   close(fd);
+- 
+-   if(open("dd/dd/ff", O_RDONLY) >= 0){
+-     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+- 
+-   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+-     printf(1, "create dd/ff/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+-     printf(1, "create dd/xx/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd", O_CREATE) >= 0){
+-     printf(1, "create dd succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd", O_RDWR) >= 0){
+-     printf(1, "open dd rdwr succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd", O_WRONLY) >= 0){
+-     printf(1, "open dd wronly succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("dd/ff/ff", "dd/dd/xx") == 0){
+-     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("dd/xx/ff", "dd/dd/xx") == 0){
+-     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("dd/ff", "dd/dd/ffff") == 0){
+-     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dd/ff/ff") == 0){
+-     printf(1, "mkdir dd/ff/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dd/xx/ff") == 0){
+-     printf(1, "mkdir dd/xx/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dd/dd/ffff") == 0){
+-     printf(1, "mkdir dd/dd/ffff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dd/xx/ff") == 0){
+-     printf(1, "unlink dd/xx/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dd/ff/ff") == 0){
+-     printf(1, "unlink dd/ff/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(chdir("dd/ff") == 0){
+-     printf(1, "chdir dd/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(chdir("dd/xx") == 0){
+-     printf(1, "chdir dd/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+- 
+-   if(unlink("dd/dd/ffff") != 0){
+-     printf(1, "unlink dd/dd/ff failed\n");
+--    exit();
+-+    exit(68);
+-   }
+-   if(unlink("dd/ff") != 0){
+-     printf(1, "unlink dd/ff failed\n");
+--    exit();
+-+    exit(67);
+-   }
+-   if(unlink("dd") == 0){
+-     printf(1, "unlink non-empty dd succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dd/dd") < 0){
+-     printf(1, "unlink dd/dd failed\n");
+--    exit();
+-+    exit(65);
+-   }
+-   if(unlink("dd") < 0){
+-     printf(1, "unlink dd failed\n");
+--    exit();
+-+    exit(64);
+-   }
+- 
+-   printf(1, "subdir ok\n");
+-@@ -1127,14 +1127,14 @@ bigwrite(void)
+-     fd = open("bigwrite", O_CREATE | O_RDWR);
+-     if(fd < 0){
+-       printf(1, "cannot create bigwrite\n");
+--      exit();
+-+      exit(63);
+-     }
+-     int i;
+-     for(i = 0; i < 2; i++){
+-       int cc = write(fd, buf, sz);
+-       if(cc != sz){
+-         printf(1, "write(%d) ret %d\n", sz, cc);
+--        exit();
+-+        exit(62);
+-       }
+-     }
+-     close(fd);
+-@@ -1155,13 +1155,13 @@ bigfile(void)
+-   fd = open("bigfile", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "cannot create bigfile");
+--    exit();
+-+    exit(61);
+-   }
+-   for(i = 0; i < 20; i++){
+-     memset(buf, i, 600);
+-     if(write(fd, buf, 600) != 600){
+-       printf(1, "write bigfile failed\n");
+--      exit();
+-+      exit(60);
+-     }
+-   }
+-   close(fd);
+-@@ -1169,31 +1169,31 @@ bigfile(void)
+-   fd = open("bigfile", 0);
+-   if(fd < 0){
+-     printf(1, "cannot open bigfile\n");
+--    exit();
+-+    exit(59);
+-   }
+-   total = 0;
+-   for(i = 0; ; i++){
+-     cc = read(fd, buf, 300);
+-     if(cc < 0){
+-       printf(1, "read bigfile failed\n");
+--      exit();
+-+      exit(58);
+-     }
+-     if(cc == 0)
+-       break;
+-     if(cc != 300){
+-       printf(1, "short read bigfile\n");
+--      exit();
+-+      exit(57);
+-     }
+-     if(buf[0] != i/2 || buf[299] != i/2){
+-       printf(1, "read bigfile wrong data\n");
+--      exit();
+-+      exit(56);
+-     }
+-     total += cc;
+-   }
+-   close(fd);
+-   if(total != 20*600){
+-     printf(1, "read bigfile wrong total\n");
+--    exit();
+-+    exit(55);
+-   }
+-   unlink("bigfile");
+- 
+-@@ -1210,32 +1210,32 @@ fourteen(void)
+- 
+-   if(mkdir("12345678901234") != 0){
+-     printf(1, "mkdir 12345678901234 failed\n");
+--    exit();
+-+    exit(54);
+-   }
+-   if(mkdir("12345678901234/123456789012345") != 0){
+-     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+--    exit();
+-+    exit(53);
+-   }
+-   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+-   if(fd < 0){
+-     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+--    exit();
+-+    exit(52);
+-   }
+-   close(fd);
+-   fd = open("12345678901234/12345678901234/12345678901234", 0);
+-   if(fd < 0){
+-     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+--    exit();
+-+    exit(51);
+-   }
+-   close(fd);
+- 
+-   if(mkdir("12345678901234/12345678901234") == 0){
+-     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("123456789012345/12345678901234") == 0){
+-     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+- 
+-   printf(1, "fourteen ok\n");
+-@@ -1247,35 +1247,35 @@ rmdot(void)
+-   printf(1, "rmdot test\n");
+-   if(mkdir("dots") != 0){
+-     printf(1, "mkdir dots failed\n");
+--    exit();
+-+    exit(48);
+-   }
+-   if(chdir("dots") != 0){
+-     printf(1, "chdir dots failed\n");
+--    exit();
+-+    exit(47);
+-   }
+-   if(unlink(".") == 0){
+-     printf(1, "rm . worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("..") == 0){
+-     printf(1, "rm .. worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(chdir("/") != 0){
+-     printf(1, "chdir / failed\n");
+--    exit();
+-+    exit(44);
+-   }
+-   if(unlink("dots/.") == 0){
+-     printf(1, "unlink dots/. worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dots/..") == 0){
+-     printf(1, "unlink dots/.. worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dots") != 0){
+-     printf(1, "unlink dots failed!\n");
+--    exit();
+-+    exit(41);
+-   }
+-   printf(1, "rmdot ok\n");
+- }
+-@@ -1290,49 +1290,49 @@ dirfile(void)
+-   fd = open("dirfile", O_CREATE);
+-   if(fd < 0){
+-     printf(1, "create dirfile failed\n");
+--    exit();
+-+    exit(40);
+-   }
+-   close(fd);
+-   if(chdir("dirfile") == 0){
+-     printf(1, "chdir dirfile succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   fd = open("dirfile/xx", 0);
+-   if(fd >= 0){
+-     printf(1, "create dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   fd = open("dirfile/xx", O_CREATE);
+-   if(fd >= 0){
+-     printf(1, "create dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dirfile/xx") == 0){
+-     printf(1, "mkdir dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dirfile/xx") == 0){
+-     printf(1, "unlink dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("README", "dirfile/xx") == 0){
+-     printf(1, "link to dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dirfile") != 0){
+-     printf(1, "unlink dirfile failed!\n");
+--    exit();
+-+    exit(33);
+-   }
+- 
+-   fd = open(".", O_RDWR);
+-   if(fd >= 0){
+-     printf(1, "open . for writing succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   fd = open(".", 0);
+-   if(write(fd, "x", 1) > 0){
+-     printf(1, "write . succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   close(fd);
+- 
+-@@ -1351,11 +1351,11 @@ iref(void)
+-   for(i = 0; i < 50 + 1; i++){
+-     if(mkdir("irefd") != 0){
+-       printf(1, "mkdir irefd failed\n");
+--      exit();
+-+      exit(30);
+-     }
+-     if(chdir("irefd") != 0){
+-       printf(1, "chdir irefd failed\n");
+--      exit();
+-+      exit(29);
+-     }
+- 
+-     mkdir("");
+-@@ -1388,24 +1388,24 @@ forktest(void)
+-     if(pid < 0)
+-       break;
+-     if(pid == 0)
+--      exit();
+-+      exit(28);
+-   }
+- 
+-   if(n == 1000){
+-     printf(1, "fork claimed to work 1000 times!\n");
+--    exit();
+-+    exit(27);
+-   }
+- 
+-   for(; n > 0; n--){
+--    if(wait() < 0){
+-+    if(wait(NULL) < 0){
+-       printf(1, "wait stopped early\n");
+--      exit();
+-+      exit(26);
+-     }
+-   }
+- 
+--  if(wait() != -1){
+-+  if(wait(NULL) != -1){
+-     printf(1, "wait got too many\n");
+--    exit();
+-+    exit(25);
+-   }
+- 
+-   printf(1, "fork test OK\n");
+-@@ -1428,7 +1428,7 @@ sbrktest(void)
+-     b = sbrk(1);
+-     if(b != a){
+-       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+--      exit();
+-+      exit(24);
+-     }
+-     *b = 1;
+-     a = b + 1;
+-@@ -1436,17 +1436,17 @@ sbrktest(void)
+-   pid = fork();
+-   if(pid < 0){
+-     printf(stdout, "sbrk test fork failed\n");
+--    exit();
+-+    exit(23);
+-   }
+-   c = sbrk(1);
+-   c = sbrk(1);
+-   if(c != a + 1){
+-     printf(stdout, "sbrk test failed post-fork\n");
+--    exit();
+-+    exit(22);
+-   }
+-   if(pid == 0)
+--    exit();
+--  wait();
+-+    exit(21);
+-+  wait(NULL);
+- 
+-   // can one grow address space to something big?
+- #define BIG (100*1024*1024)
+-@@ -1455,7 +1455,7 @@ sbrktest(void)
+-   p = sbrk(amt);
+-   if (p != a) {
+-     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+--    exit();
+-+    exit(20);
+-   }
+-   lastaddr = (char*) (BIG-1);
+-   *lastaddr = 99;
+-@@ -1465,12 +1465,12 @@ sbrktest(void)
+-   c = sbrk(-4096);
+-   if(c == (char*)0xffffffff){
+-     printf(stdout, "sbrk could not deallocate\n");
+--    exit();
+-+    exit(19);
+-   }
+-   c = sbrk(0);
+-   if(c != a - 4096){
+-     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+--    exit();
+-+    exit(18);
+-   }
+- 
+-   // can one re-allocate that page?
+-@@ -1478,19 +1478,19 @@ sbrktest(void)
+-   c = sbrk(4096);
+-   if(c != a || sbrk(0) != a + 4096){
+-     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+--    exit();
+-+    exit(17);
+-   }
+-   if(*lastaddr == 99){
+-     // should be zero
+-     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+--    exit();
+-+    exit(16);
+-   }
+- 
+-   a = sbrk(0);
+-   c = sbrk(-(sbrk(0) - oldbrk));
+-   if(c != a){
+-     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+--    exit();
+-+    exit(15);
+-   }
+- 
+-   // can we read the kernel's memory?
+-@@ -1499,21 +1499,21 @@ sbrktest(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(stdout, "fork failed\n");
+--      exit();
+-+      exit(14);
+-     }
+-     if(pid == 0){
+-       printf(stdout, "oops could read %x = %x\n", a, *a);
+-       kill(ppid);
+--      exit();
+-+      exit(13);
+-     }
+--    wait();
+-+    wait(NULL);
+-   }
+- 
+-   // if we run the system out of memory, does it clean up the last
+-   // failed allocation?
+-   if(pipe(fds) != 0){
+-     printf(1, "pipe() failed\n");
+--    exit();
+-+    exit(12);
+-   }
+-   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+-     if((pids[i] = fork()) == 0){
+-@@ -1533,11 +1533,11 @@ sbrktest(void)
+-     if(pids[i] == -1)
+-       continue;
+-     kill(pids[i]);
+--    wait();
+-+    wait(NULL);
+-   }
+-   if(c == (char*)0xffffffff){
+-     printf(stdout, "failed sbrk leaked memory\n");
+--    exit();
+-+    exit(10);
+-   }
+- 
+-   if(sbrk(0) > oldbrk)
+-@@ -1572,17 +1572,17 @@ validatetest(void)
+-     if((pid = fork()) == 0){
+-       // try to crash the kernel by passing in a badly placed integer
+-       validateint((int*)p);
+--      exit();
+-+      exit(9);
+-     }
+-     sleep(0);
+-     sleep(0);
+-     kill(pid);
+--    wait();
+-+    wait(NULL);
+- 
+-     // try to crash the kernel by passing in a bad string pointer
+-     if(link("nosuchfile", (char*)p) != -1){
+-       printf(stdout, "link should not succeed\n");
+--      exit();
+-+      exit(8);
+-     }
+-   }
+- 
+-@@ -1600,7 +1600,7 @@ bsstest(void)
+-   for(i = 0; i < sizeof(uninit); i++){
+-     if(uninit[i] != '\0'){
+-       printf(stdout, "bss test failed\n");
+--      exit();
+-+      exit(7);
+-     }
+-   }
+-   printf(stdout, "bss test ok\n");
+-@@ -1627,16 +1627,16 @@ bigargtest(void)
+-     printf(stdout, "bigarg test ok\n");
+-     fd = open("bigarg-ok", O_CREATE);
+-     close(fd);
+--    exit();
+-+    exit(6);
+-   } else if(pid < 0){
+-     printf(stdout, "bigargtest: fork failed\n");
+--    exit();
+-+    exit(5);
+-   }
+--  wait();
+-+  wait(NULL);
+-   fd = open("bigarg-ok", 0);
+-   if(fd < 0){
+-     printf(stdout, "bigarg test failed!\n");
+--    exit();
+-+    exit(4);
+-   }
+-   close(fd);
+-   unlink("bigarg-ok");
+-@@ -1715,12 +1715,12 @@ uio()
+-     port = RTC_DATA;
+-     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+-     printf(1, "uio: uio succeeded; test FAILED\n");
+--    exit();
+-+    exit(3);
+-   } else if(pid < 0){
+-     printf (1, "fork failed\n");
+--    exit();
+-+    exit(2);
+-   }
+--  wait();
+-+  wait(NULL);
+-   printf(1, "uio test done\n");
+- }
+- 
+-@@ -1730,7 +1730,7 @@ void argptest()
+-   fd = open("init", O_RDONLY);
+-   if (fd < 0) {
+-     printf(2, "open failed\n");
+--    exit();
+-+    exit(1);
+-   }
+-   read(fd, sbrk(0) - 1, -1);
+-   close(fd);
+-@@ -1752,7 +1752,7 @@ main(int argc, char *argv[])
+- 
+-   if(open("usertests.ran", 0) >= 0){
+-     printf(1, "already ran user tests -- rebuild fs.img\n");
+--    exit();
+-+    exit(1);
+-   }
+-   close(open("usertests.ran", O_CREATE));
+- 
+-@@ -1799,5 +1799,5 @@ main(int argc, char *argv[])
+- 
+-   exectest();
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/usys.S b/usys.S
+-index 8bfd8a1..1687ed0 100644
+---- a/usys.S
+-+++ b/usys.S
+-@@ -11,6 +11,7 @@
+- SYSCALL(fork)
+- SYSCALL(exit)
+- SYSCALL(wait)
+-+SYSCALL(waitpid)
+- SYSCALL(pipe)
+- SYSCALL(read)
+- SYSCALL(write)
+-diff --git a/vectors.pl b/vectors.pl
+-old mode 100755
+-new mode 100644
+-diff --git a/wc.c b/wc.c
+-index d6a54df..08b93b6 100644
+---- a/wc.c
+-+++ b/wc.c
+-@@ -27,7 +27,7 @@ wc(int fd, char *name)
+-   }
+-   if(n < 0){
+-     printf(1, "wc: read error\n");
+--    exit();
+-+    exit(3);
+-   }
+-   printf(1, "%d %d %d %s\n", l, w, c, name);
+- }
+-@@ -39,16 +39,16 @@ main(int argc, char *argv[])
+- 
+-   if(argc <= 1){
+-     wc(0, "");
+--    exit();
+-+    exit(2);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-     if((fd = open(argv[i], 0)) < 0){
+-       printf(1, "wc: cannot open %s\n", argv[i]);
+--      exit();
+-+      exit(1);
+-     }
+-     wc(fd, argv[i]);
+-     close(fd);
+-   }
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/zombie.c b/zombie.c
+-index ee817da..c96b92d 100644
+---- a/zombie.c
+-+++ b/zombie.c
+-@@ -10,5 +10,5 @@ main(void)
+- {
+-   if(fork() > 0)
+-     sleep(5);  // Let child exit before parent.
+--  exit();
+-+  exit(0);
+- }
+diff --git a/console.c b/console.c
+deleted file mode 100644
+index a280d2b..0000000
+--- a/console.c
++++ /dev/null
+@@ -1,299 +0,0 @@
+-// Console input and output.
+-// Input is from the keyboard or serial port.
+-// Output is written to the screen and serial port.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "traps.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "file.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-
+-static void consputc(int);
+-
+-static int panicked = 0;
+-
+-static struct {
+-  struct spinlock lock;
+-  int locking;
+-} cons;
+-
+-static void
+-printint(int xx, int base, int sign)
+-{
+-  static char digits[] = "0123456789abcdef";
+-  char buf[16];
+-  int i;
+-  uint x;
+-
+-  if(sign && (sign = xx < 0))
+-    x = -xx;
+-  else
+-    x = xx;
+-
+-  i = 0;
+-  do{
+-    buf[i++] = digits[x % base];
+-  }while((x /= base) != 0);
+-
+-  if(sign)
+-    buf[i++] = '-';
+-
+-  while(--i >= 0)
+-    consputc(buf[i]);
+-}
+-//PAGEBREAK: 50
+-
+-// Print to the console. only understands %d, %x, %p, %s.
+-void
+-cprintf(char *fmt, ...)
+-{
+-  int i, c, locking;
+-  uint *argp;
+-  char *s;
+-
+-  locking = cons.locking;
+-  if(locking)
+-    acquire(&cons.lock);
+-
+-  if (fmt == 0)
+-    panic("null fmt");
+-
+-  argp = (uint*)(void*)(&fmt + 1);
+-  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+-    if(c != '%'){
+-      consputc(c);
 -      continue;
--    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
--      state = states[p->state];
--    else
--      state = "???";
--    cprintf("%d %s %s", p->pid, state, p->name);
--    if(p->state == SLEEPING){
--      getcallerpcs((uint*)p->context->ebp+2, pc);
--      for(i=0; i<10 && pc[i] != 0; i++)
--        cprintf(" %p", pc[i]);
-+procdump(void) {
-+    static char *states[] = {
-+            [UNUSED]    "unused",
-+            [EMBRYO]    "embryo",
-+            [SLEEPING]  "sleep ",
-+            [RUNNABLE]  "runble",
-+            [RUNNING]   "run   ",
-+            [ZOMBIE]    "zombie"
-+    };
-+    int i;
-+    struct proc *p;
-+    char *state;
-+    uint pc[10];
-+
-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-+        if (p->state == UNUSED)
-+            continue;
-+        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
-+            state = states[p->state];
-+        else
-+            state = "???";
-+        cprintf("%d %s %s", p->pid, state, p->name);
-+        if (p->state == SLEEPING) {
-+            getcallerpcs((uint *) p->context->ebp + 2, pc);
-+            for (i = 0; i < 10 && pc[i] != 0; i++)
-+                cprintf(" %p", pc[i]);
-+        }
-+        cprintf("\n");
-     }
--    cprintf("\n");
+-    }
+-    c = fmt[++i] & 0xff;
+-    if(c == 0)
+-      break;
+-    switch(c){
+-    case 'd':
+-      printint(*argp++, 10, 1);
+-      break;
+-    case 'x':
+-    case 'p':
+-      printint(*argp++, 16, 0);
+-      break;
+-    case 's':
+-      if((s = (char*)*argp++) == 0)
+-        s = "(null)";
+-      for(; *s; s++)
+-        consputc(*s);
+-      break;
+-    case '%':
+-      consputc('%');
+-      break;
+-    default:
+-      // Print unknown % sequence to draw attention.
+-      consputc('%');
+-      consputc(c);
+-      break;
+-    }
 -  }
- }
-diff --git a/proc.h b/proc.h
-index 1647114..a06b921 100644
---- a/proc.h
-+++ b/proc.h
-@@ -49,6 +49,7 @@ struct proc {
-   struct file *ofile[NOFILE];  // Open files
-   struct inode *cwd;           // Current directory
-   char name[16];               // Process name (debugging)
-+  int status;                  // Exit status
- };
- 
- // Process memory is laid out contiguously, low addresses first:
-diff --git a/rm.c b/rm.c
-index 4fd33c8..1e6daec 100644
---- a/rm.c
-+++ b/rm.c
-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
- 
-   if(argc < 2){
-     printf(2, "Usage: rm files...\n");
--    exit();
-+    exit(1);
-   }
- 
-   for(i = 1; i < argc; i++){
-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
-     }
-   }
- 
--  exit();
-+  exit(0);
- }
-diff --git a/runoff b/runoff
-old mode 100755
-new mode 100644
-diff --git a/runoff1 b/runoff1
-old mode 100755
-new mode 100644
-diff --git a/sh.c b/sh.c
-index 054bab9..ca2ae37 100644
---- a/sh.c
-+++ b/sh.c
-@@ -65,7 +65,7 @@ runcmd(struct cmd *cmd)
-   struct redircmd *rcmd;
- 
-   if(cmd == 0)
--    exit();
-+    exit(1);
- 
-   switch(cmd->type){
-   default:
-@@ -74,7 +74,7 @@ runcmd(struct cmd *cmd)
-   case EXEC:
-     ecmd = (struct execcmd*)cmd;
-     if(ecmd->argv[0] == 0)
--      exit();
-+      exit(2);
-     exec(ecmd->argv[0], ecmd->argv);
-     printf(2, "exec %s failed\n", ecmd->argv[0]);
-     break;
-@@ -84,7 +84,7 @@ runcmd(struct cmd *cmd)
-     close(rcmd->fd);
-     if(open(rcmd->file, rcmd->mode) < 0){
-       printf(2, "open %s failed\n", rcmd->file);
--      exit();
-+      exit(6);
-     }
-     runcmd(rcmd->cmd);
-     break;
-@@ -93,7 +93,7 @@ runcmd(struct cmd *cmd)
-     lcmd = (struct listcmd*)cmd;
-     if(fork1() == 0)
-       runcmd(lcmd->left);
--    wait();
-+    wait(NULL);
-     runcmd(lcmd->right);
-     break;
- 
-@@ -117,8 +117,8 @@ runcmd(struct cmd *cmd)
-     }
-     close(p[0]);
-     close(p[1]);
--    wait();
--    wait();
-+    wait(NULL);
-+    wait(NULL);
-     break;
- 
-   case BACK:
-@@ -127,7 +127,7 @@ runcmd(struct cmd *cmd)
-       runcmd(bcmd->cmd);
-     break;
-   }
--  exit();
-+  exit(3);
- }
- 
- int
-@@ -166,16 +166,16 @@ main(void)
-     }
-     if(fork1() == 0)
-       runcmd(parsecmd(buf));
--    wait();
-+    wait(NULL);
-   }
--  exit();
-+  exit(0);
- }
- 
- void
- panic(char *s)
- {
-   printf(2, "%s\n", s);
--  exit();
-+  exit(5);
- }
- 
- int
-diff --git a/show1 b/show1
-old mode 100755
-new mode 100644
-diff --git a/sign.pl b/sign.pl
-old mode 100755
-new mode 100644
-diff --git a/spinp b/spinp
-old mode 100755
-new mode 100644
-diff --git a/stressfs.c b/stressfs.c
-index c0a4743..46e0e66 100644
---- a/stressfs.c
-+++ b/stressfs.c
-@@ -43,7 +43,7 @@ main(int argc, char *argv[])
-     read(fd, data, sizeof(data));
-   close(fd);
- 
--  wait();
-+  wait(NULL);
- 
--  exit();
-+  exit(0);
- }
-diff --git a/syscall.c b/syscall.c
-index ee85261..41a8c3c 100644
---- a/syscall.c
-+++ b/syscall.c
-@@ -101,6 +101,7 @@ extern int sys_sbrk(void);
- extern int sys_sleep(void);
- extern int sys_unlink(void);
- extern int sys_wait(void);
-+extern int sys_waitpid(void);
- extern int sys_write(void);
- extern int sys_uptime(void);
- 
-@@ -108,6 +109,7 @@ static int (*syscalls[])(void) = {
- [SYS_fork]    sys_fork,
- [SYS_exit]    sys_exit,
- [SYS_wait]    sys_wait,
-+[SYS_waitpid] sys_waitpid,
- [SYS_pipe]    sys_pipe,
- [SYS_read]    sys_read,
- [SYS_kill]    sys_kill,
-diff --git a/syscall.h b/syscall.h
-index bc5f356..374ff05 100644
---- a/syscall.h
-+++ b/syscall.h
-@@ -1,22 +1,23 @@
- // System call numbers
--#define SYS_fork    1
--#define SYS_exit    2
--#define SYS_wait    3
--#define SYS_pipe    4
--#define SYS_read    5
--#define SYS_kill    6
--#define SYS_exec    7
--#define SYS_fstat   8
--#define SYS_chdir   9
--#define SYS_dup    10
--#define SYS_getpid 11
--#define SYS_sbrk   12
--#define SYS_sleep  13
--#define SYS_uptime 14
--#define SYS_open   15
--#define SYS_write  16
--#define SYS_mknod  17
--#define SYS_unlink 18
--#define SYS_link   19
--#define SYS_mkdir  20
--#define SYS_close  21
-+#define SYS_fork     1
-+#define SYS_exit     2
-+#define SYS_wait     3
-+#define SYS_pipe     4
-+#define SYS_read     5
-+#define SYS_kill     6
-+#define SYS_exec     7
-+#define SYS_fstat    8
-+#define SYS_chdir    9
-+#define SYS_dup     10
-+#define SYS_getpid  11
-+#define SYS_sbrk    12
-+#define SYS_sleep   13
-+#define SYS_uptime  14
-+#define SYS_open    15
-+#define SYS_write   16
-+#define SYS_mknod   17
-+#define SYS_unlink  18
-+#define SYS_link    19
-+#define SYS_mkdir   20
-+#define SYS_close   21
-+#define SYS_waitpid 22
-\ No newline at end of file
-diff --git a/sysproc.c b/sysproc.c
-index 0686d29..ebccf84 100644
---- a/sysproc.c
-+++ b/sysproc.c
-@@ -14,16 +14,22 @@ sys_fork(void)
- }
- 
- int
--sys_exit(void)
-+sys_exit(int status)
- {
--  exit();
-+  exit(status);
-   return 0;  // not reached
- }
- 
- int
--sys_wait(void)
-+sys_wait(int* status)
- {
--  return wait();
-+  return wait(status);
+-
+-  if(locking)
+-    release(&cons.lock);
+-}
+-
+-void
+-panic(char *s)
+-{
+-  int i;
+-  uint pcs[10];
+-
+-  cli();
+-  cons.locking = 0;
+-  // use lapiccpunum so that we can call panic from mycpu()
+-  cprintf("lapicid %d: panic: ", lapicid());
+-  cprintf(s);
+-  cprintf("\n");
+-  getcallerpcs(&s, pcs);
+-  for(i=0; i<10; i++)
+-    cprintf(" %p", pcs[i]);
+-  panicked = 1; // freeze other CPU
+-  for(;;)
+-    ;
+-}
+-
+-//PAGEBREAK: 50
+-#define BACKSPACE 0x100
+-#define CRTPORT 0x3d4
+-static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
+-
+-static void
+-cgaputc(int c)
+-{
+-  int pos;
+-
+-  // Cursor position: col + 80*row.
+-  outb(CRTPORT, 14);
+-  pos = inb(CRTPORT+1) << 8;
+-  outb(CRTPORT, 15);
+-  pos |= inb(CRTPORT+1);
+-
+-  if(c == '\n')
+-    pos += 80 - pos%80;
+-  else if(c == BACKSPACE){
+-    if(pos > 0) --pos;
+-  } else
+-    crt[pos++] = (c&0xff) | 0x0700;  // black on white
+-
+-  if(pos < 0 || pos > 25*80)
+-    panic("pos under/overflow");
+-
+-  if((pos/80) >= 24){  // Scroll up.
+-    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+-    pos -= 80;
+-    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+-  }
+-
+-  outb(CRTPORT, 14);
+-  outb(CRTPORT+1, pos>>8);
+-  outb(CRTPORT, 15);
+-  outb(CRTPORT+1, pos);
+-  crt[pos] = ' ' | 0x0700;
+-}
+-
+-void
+-consputc(int c)
+-{
+-  if(panicked){
+-    cli();
+-    for(;;)
+-      ;
+-  }
+-
+-  if(c == BACKSPACE){
+-    uartputc('\b'); uartputc(' '); uartputc('\b');
+-  } else
+-    uartputc(c);
+-  cgaputc(c);
+-}
+-
+-#define INPUT_BUF 128
+-struct {
+-  char buf[INPUT_BUF];
+-  uint r;  // Read index
+-  uint w;  // Write index
+-  uint e;  // Edit index
+-} input;
+-
+-#define C(x)  ((x)-'@')  // Control-x
+-
+-void
+-consoleintr(int (*getc)(void))
+-{
+-  int c, doprocdump = 0;
+-
+-  acquire(&cons.lock);
+-  while((c = getc()) >= 0){
+-    switch(c){
+-    case C('P'):  // Process listing.
+-      // procdump() locks cons.lock indirectly; invoke later
+-      doprocdump = 1;
+-      break;
+-    case C('U'):  // Kill line.
+-      while(input.e != input.w &&
+-            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+-        input.e--;
+-        consputc(BACKSPACE);
+-      }
+-      break;
+-    case C('H'): case '\x7f':  // Backspace
+-      if(input.e != input.w){
+-        input.e--;
+-        consputc(BACKSPACE);
+-      }
+-      break;
+-    default:
+-      if(c != 0 && input.e-input.r < INPUT_BUF){
+-        c = (c == '\r') ? '\n' : c;
+-        input.buf[input.e++ % INPUT_BUF] = c;
+-        consputc(c);
+-        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
+-          input.w = input.e;
+-          wakeup(&input.r);
+-        }
+-      }
+-      break;
+-    }
+-  }
+-  release(&cons.lock);
+-  if(doprocdump) {
+-    procdump();  // now call procdump() wo. cons.lock held
+-  }
+-}
+-
+-int
+-consoleread(struct inode *ip, char *dst, int n)
+-{
+-  uint target;
+-  int c;
+-
+-  iunlock(ip);
+-  target = n;
+-  acquire(&cons.lock);
+-  while(n > 0){
+-    while(input.r == input.w){
+-      if(myproc()->killed){
+-        release(&cons.lock);
+-        ilock(ip);
+-        return -1;
+-      }
+-      sleep(&input.r, &cons.lock);
+-    }
+-    c = input.buf[input.r++ % INPUT_BUF];
+-    if(c == C('D')){  // EOF
+-      if(n < target){
+-        // Save ^D for next time, to make sure
+-        // caller gets a 0-byte result.
+-        input.r--;
+-      }
+-      break;
+-    }
+-    *dst++ = c;
+-    --n;
+-    if(c == '\n')
+-      break;
+-  }
+-  release(&cons.lock);
+-  ilock(ip);
+-
+-  return target - n;
+-}
+-
+-int
+-consolewrite(struct inode *ip, char *buf, int n)
+-{
+-  int i;
+-
+-  iunlock(ip);
+-  acquire(&cons.lock);
+-  for(i = 0; i < n; i++)
+-    consputc(buf[i] & 0xff);
+-  release(&cons.lock);
+-  ilock(ip);
+-
+-  return n;
+-}
+-
+-void
+-consoleinit(void)
+-{
+-  initlock(&cons.lock, "console");
+-
+-  devsw[CONSOLE].write = consolewrite;
+-  devsw[CONSOLE].read = consoleread;
+-  cons.locking = 1;
+-
+-  ioapicenable(IRQ_KBD, 0);
+-}
+-
+diff --git a/cuth b/cuth
+deleted file mode 100644
+index cce8c0c..0000000
+--- a/cuth
++++ /dev/null
+@@ -1,48 +0,0 @@
+-#!/usr/bin/perl
+-
+-$| = 1;
+-
+-sub writefile($@){
+-	my ($file, @lines) = @_;
+-	
+-	sleep(1);
+-	open(F, ">$file") || die "open >$file: $!";
+-	print F @lines;
+-	close(F);
+-}
+-
+-# Cut out #include lines that don't contribute anything.
+-for($i=0; $i<@ARGV; $i++){
+-	$file = $ARGV[$i];
+-	if(!open(F, $file)){
+-		print STDERR "open $file: $!\n";
+-		next;
+-	}
+-	@lines = <F>;
+-	close(F);
+-	
+-	$obj = "$file.o";
+-	$obj =~ s/\.c\.o$/.o/;
+-	system("touch $file");
+-
+-	if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
+-		print STDERR "make $obj failed: $rv\n";
+-		next;
+-	}
+-
+-	system("cp $file =$file");
+-	for($j=@lines-1; $j>=0; $j--){
+-		if($lines[$j] =~ /^#include/){
+-			$old = $lines[$j];
+-			$lines[$j] = "/* CUT-H */\n";
+-			writefile($file, @lines);
+-			if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
+-				$lines[$j] = $old;
+-			}else{
+-				print STDERR "$file $old";
+-			}
+-		}
+-	}
+-	writefile($file, grep {!/CUT-H/} @lines);
+-	system("rm =$file");
+-}
+diff --git a/date.h b/date.h
+deleted file mode 100644
+index 94aec4b..0000000
+--- a/date.h
++++ /dev/null
+@@ -1,8 +0,0 @@
+-struct rtcdate {
+-  uint second;
+-  uint minute;
+-  uint hour;
+-  uint day;
+-  uint month;
+-  uint year;
+-};
+diff --git a/defs.h b/defs.h
+deleted file mode 100644
+index d1934ca..0000000
+--- a/defs.h
++++ /dev/null
+@@ -1,191 +0,0 @@
+-struct buf;
+-struct context;
+-struct file;
+-struct inode;
+-struct pipe;
+-struct proc;
+-struct rtcdate;
+-struct spinlock;
+-struct sleeplock;
+-struct stat;
+-struct superblock;
+-
+-// bio.c
+-void            binit(void);
+-struct buf*     bread(uint, uint);
+-void            brelse(struct buf*);
+-void            bwrite(struct buf*);
+-
+-// console.c
+-void            consoleinit(void);
+-void            cprintf(char*, ...);
+-void            consoleintr(int(*)(void));
+-void            panic(char*) __attribute__((noreturn));
+-
+-// exec.c
+-int             exec(char*, char**);
+-
+-// file.c
+-struct file*    filealloc(void);
+-void            fileclose(struct file*);
+-struct file*    filedup(struct file*);
+-void            fileinit(void);
+-int             fileread(struct file*, char*, int n);
+-int             filestat(struct file*, struct stat*);
+-int             filewrite(struct file*, char*, int n);
+-
+-// fs.c
+-void            readsb(int dev, struct superblock *sb);
+-int             dirlink(struct inode*, char*, uint);
+-struct inode*   dirlookup(struct inode*, char*, uint*);
+-struct inode*   ialloc(uint, short);
+-struct inode*   idup(struct inode*);
+-void            iinit(int dev);
+-void            ilock(struct inode*);
+-void            iput(struct inode*);
+-void            iunlock(struct inode*);
+-void            iunlockput(struct inode*);
+-void            iupdate(struct inode*);
+-int             namecmp(const char*, const char*);
+-struct inode*   namei(char*);
+-struct inode*   nameiparent(char*, char*);
+-int             readi(struct inode*, char*, uint, uint);
+-void            stati(struct inode*, struct stat*);
+-int             writei(struct inode*, char*, uint, uint);
+-
+-// ide.c
+-void            ideinit(void);
+-void            ideintr(void);
+-void            iderw(struct buf*);
+-
+-// ioapic.c
+-void            ioapicenable(int irq, int cpu);
+-extern uchar    ioapicid;
+-void            ioapicinit(void);
+-
+-// kalloc.c
+-char*           kalloc(void);
+-void            kfree(char*);
+-void            kinit1(void*, void*);
+-void            kinit2(void*, void*);
+-
+-// kbd.c
+-void            kbdintr(void);
+-
+-// lapic.c
+-void            cmostime(struct rtcdate *r);
+-int             lapicid(void);
+-extern volatile uint*    lapic;
+-void            lapiceoi(void);
+-void            lapicinit(void);
+-void            lapicstartap(uchar, uint);
+-void            microdelay(int);
+-
+-// log.c
+-void            initlog(int dev);
+-void            log_write(struct buf*);
+-void            begin_op();
+-void            end_op();
+-
+-// mp.c
+-extern int      ismp;
+-void            mpinit(void);
+-
+-// picirq.c
+-void            picenable(int);
+-void            picinit(void);
+-
+-// pipe.c
+-int             pipealloc(struct file**, struct file**);
+-void            pipeclose(struct pipe*, int);
+-int             piperead(struct pipe*, char*, int);
+-int             pipewrite(struct pipe*, char*, int);
+-
+-//PAGEBREAK: 16
+-// proc.c
+-int             cpuid(void);
+-void            exit(int status);
+-int             fork(void);
+-int             growproc(int);
+-int             kill(int);
+-struct cpu*     mycpu(void);
+-struct proc*    myproc();
+-void            pinit(void);
+-void            procdump(void);
+-void            scheduler(void) __attribute__((noreturn));
+-void            sched(void);
+-void            setproc(struct proc*);
+-void            sleep(void*, struct spinlock*);
+-void            userinit(void);
+-int             wait(int* status);
+-int             waitpid(int pid, int* status, int options);
+-void            wakeup(void*);
+-void            yield(void);
+-
+-// swtch.S
+-void            swtch(struct context**, struct context*);
+-
+-// spinlock.c
+-void            acquire(struct spinlock*);
+-void            getcallerpcs(void*, uint*);
+-int             holding(struct spinlock*);
+-void            initlock(struct spinlock*, char*);
+-void            release(struct spinlock*);
+-void            pushcli(void);
+-void            popcli(void);
+-
+-// sleeplock.c
+-void            acquiresleep(struct sleeplock*);
+-void            releasesleep(struct sleeplock*);
+-int             holdingsleep(struct sleeplock*);
+-void            initsleeplock(struct sleeplock*, char*);
+-
+-// string.c
+-int             memcmp(const void*, const void*, uint);
+-void*           memmove(void*, const void*, uint);
+-void*           memset(void*, int, uint);
+-char*           safestrcpy(char*, const char*, int);
+-int             strlen(const char*);
+-int             strncmp(const char*, const char*, uint);
+-char*           strncpy(char*, const char*, int);
+-
+-// syscall.c
+-int             argint(int, int*);
+-int             argptr(int, char**, int);
+-int             argstr(int, char**);
+-int             fetchint(uint, int*);
+-int             fetchstr(uint, char**);
+-void            syscall(void);
+-
+-// timer.c
+-void            timerinit(void);
+-
+-// trap.c
+-void            idtinit(void);
+-extern uint     ticks;
+-void            tvinit(void);
+-extern struct spinlock tickslock;
+-
+-// uart.c
+-void            uartinit(void);
+-void            uartintr(void);
+-void            uartputc(int);
+-
+-// vm.c
+-void            seginit(void);
+-void            kvmalloc(void);
+-pde_t*          setupkvm(void);
+-char*           uva2ka(pde_t*, char*);
+-int             allocuvm(pde_t*, uint, uint);
+-int             deallocuvm(pde_t*, uint, uint);
+-void            freevm(pde_t*);
+-void            inituvm(pde_t*, char*, uint);
+-int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
+-pde_t*          copyuvm(pde_t*, uint);
+-void            switchuvm(struct proc*);
+-void            switchkvm(void);
+-int             copyout(pde_t*, uint, void*, uint);
+-void            clearpteu(pde_t *pgdir, char *uva);
+-
+-// number of elements in fixed-size array
+-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+diff --git a/dot-bochsrc b/dot-bochsrc
+deleted file mode 100644
+index ba13db7..0000000
+--- a/dot-bochsrc
++++ /dev/null
+@@ -1,738 +0,0 @@
+-# You may now use double quotes around pathnames, in case
+-# your pathname includes spaces.
+-
+-#=======================================================================
+-# CONFIG_INTERFACE
+-#
+-# The configuration interface is a series of menus or dialog boxes that
+-# allows you to change all the settings that control Bochs's behavior.
+-# There are two choices of configuration interface: a text mode version
+-# called "textconfig" and a graphical version called "wx".  The text
+-# mode version uses stdin/stdout and is always compiled in.  The graphical
+-# version is only available when you use "--with-wx" on the configure 
+-# command.  If you do not write a config_interface line, Bochs will 
+-# choose a default for you.
+-#
+-# NOTE: if you use the "wx" configuration interface, you must also use
+-# the "wx" display library.
+-#=======================================================================
+-#config_interface: textconfig
+-#config_interface: wx
+-
+-#=======================================================================
+-# DISPLAY_LIBRARY
+-#
+-# The display library is the code that displays the Bochs VGA screen.  Bochs 
+-# has a selection of about 10 different display library implementations for 
+-# different platforms.  If you run configure with multiple --with-* options, 
+-# the display_library command lets you choose which one you want to run with.
+-# If you do not write a display_library line, Bochs will choose a default for
+-# you.
+-#
+-# The choices are: 
+-#   x              use X windows interface, cross platform
+-#   win32          use native win32 libraries
+-#   carbon         use Carbon library (for MacOS X)
+-#   beos           use native BeOS libraries
+-#   macintosh      use MacOS pre-10
+-#   amigaos        use native AmigaOS libraries
+-#   sdl            use SDL library, cross platform
+-#   svga           use SVGALIB library for Linux, allows graphics without X11
+-#   term           text only, uses curses/ncurses library, cross platform
+-#   rfb            provides an interface to AT&T's VNC viewer, cross platform
+-#   wx             use wxWidgets library, cross platform
+-#   nogui          no display at all
+-#
+-# NOTE: if you use the "wx" configuration interface, you must also use
+-# the "wx" display library.
+-#
+-# Specific options:
+-# Some display libraries now support specific option to control their
+-# behaviour. See the examples below for currently supported options.
+-#=======================================================================
+-#display_library: amigaos
+-#display_library: beos
+-#display_library: carbon
+-#display_library: macintosh
+-#display_library: nogui
+-#display_library: rfb, options="timeout=60" # time to wait for client
+-#display_library: sdl, options="fullscreen" # startup in fullscreen mode
+-#display_library: term
+-#display_library: win32, options="legacyF12" # use F12 to toggle mouse
+-#display_library: wx
+-#display_library: x
+-
+-#=======================================================================
+-# ROMIMAGE:
+-# The ROM BIOS controls what the PC does when it first powers on.
+-# Normally, you can use a precompiled BIOS in the source or binary
+-# distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded
+-# starting at address 0xf0000, and it is exactly 64k long.
+-# You can also use the environment variable $BXSHARE to specify the
+-# location of the BIOS.
+-# The usage of external large BIOS images (up to 512k) at memory top is
+-# now supported, but we still recommend to use the BIOS distributed with
+-# Bochs. Now the start address can be calculated from image size.
+-#=======================================================================
+-romimage: file=$BXSHARE/BIOS-bochs-latest
+-#romimage: file=mybios.bin, address=0xfff80000 # 512k at memory top
+-#romimage: file=mybios.bin # calculate start address from image size
+-
+-#=======================================================================
+-# CPU:
+-# This defines cpu-related parameters inside Bochs:
+-#
+-#  COUNT:
+-#  Set the number of processors when Bochs is compiled for SMP emulation.
+-#  Bochs currently supports up to 8 processors. If Bochs is compiled
+-#  without SMP support, it won't accept values different from 1.
+-#
+-#  IPS:
+-#  Emulated Instructions Per Second.  This is the number of IPS that bochs
+-#  is capable of running on your machine. You can recompile Bochs with
+-#  --enable-show-ips option enabled, to find your workstation's capability.
+-#  Measured IPS value will then be logged into your log file or status bar
+-#  (if supported by the gui).
+-#
+-#  IPS is used to calibrate many time-dependent events within the bochs 
+-#  simulation.  For example, changing IPS affects the frequency of VGA
+-#  updates, the duration of time before a key starts to autorepeat, and
+-#  the measurement of BogoMips and other benchmarks.
+-#
+-#  Examples:
+-#  Machine                                         Mips
+-# ________________________________________________________________
+-#  2.1Ghz Athlon XP with Linux 2.6/g++ 3.4         12 to 15 Mips
+-#  1.6Ghz Intel P4 with Win2000/g++ 3.3             5 to  7 Mips
+-#  650Mhz Athlon K-7 with Linux 2.4.4/egcs-2.91.66  2 to  2.5 Mips
+-#  400Mhz Pentium II with Linux 2.0.36/egcs-1.0.3   1 to  1.8 Mips
+-#=======================================================================
+-cpu: count=2, ips=10000000
+-
+-#=======================================================================
+-# MEGS
+-# Set the number of Megabytes of physical memory you want to emulate. 
+-# The default is 32MB, most OS's won't need more than that.
+-# The maximum amount of memory supported is 2048Mb.
+-#=======================================================================
+-#megs: 256
+-#megs: 128
+-#megs: 64
+-megs: 32
+-#megs: 16
+-#megs: 8
+-
+-#=======================================================================
+-# OPTROMIMAGE[1-4]:
+-# You may now load up to 4 optional ROM images. Be sure to use a 
+-# read-only area, typically between C8000 and EFFFF. These optional
+-# ROM images should not overwrite the rombios (located at
+-# F0000-FFFFF) and the videobios (located at C0000-C7FFF).
+-# Those ROM images will be initialized by the bios if they contain 
+-# the right signature (0x55AA) and a valid checksum.
+-# It can also be a convenient way to upload some arbitrary code/data
+-# in the simulation, that can be retrieved by the boot loader
+-#=======================================================================
+-#optromimage1: file=optionalrom.bin, address=0xd0000
+-#optromimage2: file=optionalrom.bin, address=0xd1000
+-#optromimage3: file=optionalrom.bin, address=0xd2000
+-#optromimage4: file=optionalrom.bin, address=0xd3000
+-
+-#optramimage1: file=/path/file1.img, address=0x0010000
+-#optramimage2: file=/path/file2.img, address=0x0020000
+-#optramimage3: file=/path/file3.img, address=0x0030000
+-#optramimage4: file=/path/file4.img, address=0x0040000
+-
+-#=======================================================================
+-# VGAROMIMAGE
+-# You now need to load a VGA ROM BIOS into C0000.
+-#=======================================================================
+-#vgaromimage: file=bios/VGABIOS-elpin-2.40
+-vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
+-#vgaromimage: file=bios/VGABIOS-lgpl-latest-cirrus
+-
+-#=======================================================================
+-# VGA:
+-# Here you can specify the display extension to be used. With the value
+-# 'none' you can use standard VGA with no extension. Other supported
+-# values are 'vbe' for Bochs VBE and 'cirrus' for Cirrus SVGA support.
+-#=======================================================================
+-#vga: extension=cirrus
+-#vga: extension=vbe
+-vga: extension=none
+-
+-#=======================================================================
+-# FLOPPYA:
+-# Point this to pathname of floppy image file or device
+-# This should be of a bootable floppy(image/device) if you're
+-# booting from 'a' (or 'floppy').
+-#
+-# You can set the initial status of the media to 'ejected' or 'inserted'.
+-#   floppya: 2_88=path, status=ejected             (2.88M 3.5" floppy)
+-#   floppya: 1_44=path, status=inserted            (1.44M 3.5" floppy)
+-#   floppya: 1_2=path, status=ejected              (1.2M  5.25" floppy)
+-#   floppya: 720k=path, status=inserted            (720K  3.5" floppy)
+-#   floppya: 360k=path, status=inserted            (360K  5.25" floppy)
+-#   floppya: 320k=path, status=inserted            (320K  5.25" floppy)
+-#   floppya: 180k=path, status=inserted            (180K  5.25" floppy)
+-#   floppya: 160k=path, status=inserted            (160K  5.25" floppy)
+-#   floppya: image=path, status=inserted           (guess type from image size)
+-#
+-# The path should be the name of a disk image file.  On Unix, you can use a raw
+-# device name such as /dev/fd0 on Linux.  On win32 platforms, use drive letters
+-# such as a: or b: as the path.  The parameter 'image' works with image files
+-# only. In that case the size must match one of the supported types.
+-#=======================================================================
+-floppya: 1_44=/dev/fd0, status=inserted
+-#floppya: image=../1.44, status=inserted
+-#floppya: 1_44=/dev/fd0H1440, status=inserted
+-#floppya: 1_2=../1_2, status=inserted
+-#floppya: 1_44=a:, status=inserted
+-#floppya: 1_44=a.img, status=inserted
+-#floppya: 1_44=/dev/rfd0a, status=inserted
+-
+-#=======================================================================
+-# FLOPPYB:
+-# See FLOPPYA above for syntax
+-#=======================================================================
+-#floppyb: 1_44=b:, status=inserted
+-floppyb: 1_44=b.img, status=inserted
+-
+-#=======================================================================
+-# ATA0, ATA1, ATA2, ATA3
+-# ATA controller for hard disks and cdroms
+-#
+-# ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
+-# 
+-# These options enables up to 4 ata channels. For each channel
+-# the two base io addresses and the irq must be specified.
+-# 
+-# ata0 and ata1 are enabled by default with the values shown below
+-#
+-# Examples:
+-#   ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
+-#   ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
+-#   ata2: enabled=1, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
+-#   ata3: enabled=1, ioaddr1=0x168, ioaddr2=0x360, irq=9
+-#=======================================================================
+-ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
+-ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
+-ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
+-ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9
+-
+-#=======================================================================
+-# ATA[0-3]-MASTER, ATA[0-3]-SLAVE
+-#
+-# This defines the type and characteristics of all attached ata devices:
+-#   type=       type of attached device [disk|cdrom] 
+-#   mode=       only valid for disks [flat|concat|external|dll|sparse|vmware3]
+-#   mode=       only valid for disks [undoable|growing|volatile]
+-#   path=       path of the image
+-#   cylinders=  only valid for disks
+-#   heads=      only valid for disks
+-#   spt=        only valid for disks
+-#   status=     only valid for cdroms [inserted|ejected]
+-#   biosdetect= type of biosdetection [none|auto], only for disks on ata0 [cmos]
+-#   translation=type of translation of the bios, only for disks [none|lba|large|rechs|auto]
+-#   model=      string returned by identify device command
+-#   journal=    optional filename of the redolog for undoable and volatile disks
+-#   
+-# Point this at a hard disk image file, cdrom iso file, or physical cdrom
+-# device.  To create a hard disk image, try running bximage.  It will help you
+-# choose the size and then suggest a line that works with it.
+-#
+-# In UNIX it may be possible to use a raw device as a Bochs hard disk, 
+-# but WE DON'T RECOMMEND IT.  In Windows there is no easy way.
+-#
+-# In windows, the drive letter + colon notation should be used for cdroms.
+-# Depending on versions of windows and drivers, you may only be able to 
+-# access the "first" cdrom in the system.  On MacOSX, use path="drive"
+-# to access the physical drive.
+-#
+-# The path is always mandatory. For flat hard disk images created with
+-# bximage geometry autodetection can be used (cylinders=0 -> cylinders are
+-# calculated using heads=16 and spt=63). For other hard disk images and modes
+-# the cylinders, heads, and spt are mandatory.
+-#
+-# Default values are:
+-#   mode=flat, biosdetect=auto, translation=auto, model="Generic 1234"
+-#
+-# The biosdetect option has currently no effect on the bios
+-#
+-# Examples:
+-#   ata0-master: type=disk, mode=flat, path=10M.sample, cylinders=306, heads=4, spt=17
+-#   ata0-slave:  type=disk, mode=flat, path=20M.sample, cylinders=615, heads=4, spt=17
+-#   ata1-master: type=disk, mode=flat, path=30M.sample, cylinders=615, heads=6, spt=17
+-#   ata1-slave:  type=disk, mode=flat, path=46M.sample, cylinders=940, heads=6, spt=17
+-#   ata2-master: type=disk, mode=flat, path=62M.sample, cylinders=940, heads=8, spt=17
+-#   ata2-slave:  type=disk, mode=flat, path=112M.sample, cylinders=900, heads=15, spt=17
+-#   ata3-master: type=disk, mode=flat, path=483M.sample, cylinders=1024, heads=15, spt=63
+-#   ata3-slave:  type=cdrom, path=iso.sample, status=inserted
+-#=======================================================================
+-ata0-master: type=disk, mode=flat, path="xv6.img", cylinders=100, heads=10, spt=10
+-ata0-slave: type=disk, mode=flat, path="fs.img", cylinders=1024, heads=1, spt=1
+-#ata0-slave: type=cdrom, path=D:, status=inserted
+-#ata0-slave: type=cdrom, path=/dev/cdrom, status=inserted
+-#ata0-slave: type=cdrom, path="drive", status=inserted
+-#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted 
+-
+-#=======================================================================
+-# BOOT:
+-# This defines the boot sequence. Now you can specify up to 3 boot drives.
+-# You can either boot from 'floppy', 'disk' or 'cdrom'
+-# legacy 'a' and 'c' are also supported
+-# Examples:
+-#   boot: floppy
+-#   boot: disk
+-#   boot: cdrom
+-#   boot: c
+-#   boot: a
+-#   boot: cdrom, floppy, disk
+-#=======================================================================
+-#boot: floppy
+-boot: disk
+-
+-#=======================================================================
+-# CLOCK:
+-# This defines the parameters of the clock inside Bochs:
+-#
+-#  SYNC:
+-#  TO BE COMPLETED (see Greg explanation in feature request #536329)
+-#
+-#  TIME0:
+-#  Specifies the start (boot) time of the virtual machine. Use a time 
+-#  value as returned by the time(2) system call. If no time0 value is 
+-#  set or if time0 equal to 1 (special case) or if time0 equal 'local', 
+-#  the simulation will be started at the current local host time.
+-#  If time0 equal to 2 (special case) or if time0 equal 'utc',
+-#  the simulation will be started at the current utc time.
+-#
+-# Syntax:
+-#  clock: sync=[none|slowdown|realtime|both], time0=[timeValue|local|utc]
+-#
+-# Example:
+-#   clock: sync=none,     time0=local       # Now (localtime)
+-#   clock: sync=slowdown, time0=315529200   # Tue Jan  1 00:00:00 1980
+-#   clock: sync=none,     time0=631148400   # Mon Jan  1 00:00:00 1990
+-#   clock: sync=realtime, time0=938581955   # Wed Sep 29 07:12:35 1999
+-#   clock: sync=realtime, time0=946681200   # Sat Jan  1 00:00:00 2000
+-#   clock: sync=none,     time0=1           # Now (localtime)
+-#   clock: sync=none,     time0=utc         # Now (utc/gmt)
+-# 
+-# Default value are sync=none, time0=local
+-#=======================================================================
+-#clock: sync=none, time0=local
+-
+-
+-#=======================================================================
+-# FLOPPY_BOOTSIG_CHECK: disabled=[0|1]
+-# Enables or disables the 0xaa55 signature check on boot floppies
+-# Defaults to disabled=0
+-# Examples:
+-#   floppy_bootsig_check: disabled=0
+-#   floppy_bootsig_check: disabled=1
+-#=======================================================================
+-#floppy_bootsig_check: disabled=1
+-floppy_bootsig_check: disabled=0
+-
+-#=======================================================================
+-# LOG:
+-# Give the path of the log file you'd like Bochs debug and misc. verbiage
+-# to be written to. If you don't use this option or set the filename to
+-# '-' the output is written to the console. If you really don't want it,
+-# make it "/dev/null" (Unix) or "nul" (win32). :^(
+-#
+-# Examples:
+-#   log: ./bochs.out
+-#   log: /dev/tty
+-#=======================================================================
+-#log: /dev/null
+-log: bochsout.txt
+-
+-#=======================================================================
+-# LOGPREFIX:
+-# This handles the format of the string prepended to each log line.
+-# You may use those special tokens :
+-#   %t : 11 decimal digits timer tick
+-#   %i : 8 hexadecimal digits of cpu current eip (ignored in SMP configuration)
+-#   %e : 1 character event type ('i'nfo, 'd'ebug, 'p'anic, 'e'rror)
+-#   %d : 5 characters string of the device, between brackets
+-# 
+-# Default : %t%e%d
+-# Examples:
+-#   logprefix: %t-%e-@%i-%d
+-#   logprefix: %i%e%d
+-#=======================================================================
+-#logprefix: %t%e%d
+-
+-#=======================================================================
+-# LOG CONTROLS
+-#
+-# Bochs now has four severity levels for event logging.
+-#   panic: cannot proceed.  If you choose to continue after a panic, 
+-#          don't be surprised if you get strange behavior or crashes.
+-#   error: something went wrong, but it is probably safe to continue the
+-#          simulation.
+-#   info: interesting or useful messages.
+-#   debug: messages useful only when debugging the code.  This may
+-#          spit out thousands per second.
+-#
+-# For events of each level, you can choose to crash, report, or ignore.
+-# TODO: allow choice based on the facility: e.g. crash on panics from
+-#       everything except the cdrom, and only report those.
+-#
+-# If you are experiencing many panics, it can be helpful to change
+-# the panic action to report instead of fatal.  However, be aware
+-# that anything executed after a panic is uncharted territory and can 
+-# cause bochs to become unstable.  The panic is a "graceful exit," so
+-# if you disable it you may get a spectacular disaster instead.
+-#=======================================================================
+-panic: action=ask
+-error: action=report
+-info: action=report
+-debug: action=ignore
+-#pass: action=fatal
+-
+-#=======================================================================
+-# DEBUGGER_LOG:
+-# Give the path of the log file you'd like Bochs to log debugger output.
+-# If you really don't want it, make it /dev/null or '-'. :^(
+-#
+-# Examples:
+-#   debugger_log: ./debugger.out
+-#=======================================================================
+-#debugger_log: /dev/null
+-#debugger_log: debugger.out
+-debugger_log: -
+-
+-#=======================================================================
+-# COM1, COM2, COM3, COM4:
+-# This defines a serial port (UART type 16550A). In the 'term' you can specify
+-# a device to use as com1. This can be a real serial line, or a pty.  To use
+-# a pty (under X/Unix), create two windows (xterms, usually).  One of them will
+-# run bochs, and the other will act as com1. Find out the tty the com1
+-# window using the `tty' command, and use that as the `dev' parameter.
+-# Then do `sleep 1000000' in the com1 window to keep the shell from
+-# messing with things, and run bochs in the other window.  Serial I/O to
+-# com1 (port 0x3f8) will all go to the other window.
+-# Other serial modes are 'null' (no input/output), 'file' (output to a file
+-# specified as the 'dev' parameter), 'raw' (use the real serial port - under
+-# construction for win32), 'mouse' (standard serial mouse - requires
+-# mouse option setting 'type=serial' or 'type=serial_wheel') and 'socket'
+-# (connect a networking socket).
+-#
+-# Examples:
+-#   com1: enabled=1, mode=null
+-#   com1: enabled=1, mode=mouse
+-#   com2: enabled=1, mode=file, dev=serial.out
+-#   com3: enabled=1, mode=raw, dev=com1
+-#   com3: enabled=1, mode=socket, dev=localhost:8888
+-#=======================================================================
+-#com1: enabled=1, mode=term, dev=/dev/ttyp9
+-
+-
+-#=======================================================================
+-# PARPORT1, PARPORT2:
+-# This defines a parallel (printer) port. When turned on and an output file is
+-# defined the emulated printer port sends characters printed by the guest OS
+-# into the output file. On some platforms a device filename can be used to
+-# send the data to the real parallel port (e.g. "/dev/lp0" on Linux, "lpt1" on
+-# win32 platforms).
+-#
+-# Examples:
+-#   parport1: enabled=1, file="parport.out"
+-#   parport2: enabled=1, file="/dev/lp0"
+-#   parport1: enabled=0
+-#=======================================================================
+-parport1: enabled=1, file="/dev/stdout"
+-
+-#=======================================================================
+-# SB16:
+-# This defines the SB16 sound emulation. It can have several of the
+-# following properties.
+-# All properties are in the format sb16: property=value
+-# midi: The filename is where the midi data is sent. This can be a
+-#       device or just a file if you want to record the midi data.
+-# midimode:
+-#      0=no data
+-#      1=output to device (system dependent. midi denotes the device driver)
+-#      2=SMF file output, including headers
+-#      3=output the midi data stream to the file (no midi headers and no
+-#        delta times, just command and data bytes)
+-# wave: This is the device/file where wave output is stored
+-# wavemode:
+-#      0=no data
+-#      1=output to device (system dependent. wave denotes the device driver)
+-#      2=VOC file output, incl. headers
+-#      3=output the raw wave stream to the file
+-# log:  The file to write the sb16 emulator messages to.
+-# loglevel:
+-#      0=no log
+-#      1=resource changes, midi program and bank changes
+-#      2=severe errors
+-#      3=all errors
+-#      4=all errors plus all port accesses
+-#      5=all errors and port accesses plus a lot of extra info
+-# dmatimer:
+-#      microseconds per second for a DMA cycle.  Make it smaller to fix
+-#      non-continuous sound.  750000 is usually a good value.  This needs a
+-#      reasonably correct setting for the IPS parameter of the CPU option.
+-#
+-# For an example look at the next line:
+-#=======================================================================
+-
+-#sb16: midimode=1, midi=/dev/midi00, wavemode=1, wave=/dev/dsp, loglevel=2, log=sb16.log, dmatimer=600000
+-
+-#=======================================================================
+-# VGA_UPDATE_INTERVAL:
+-# Video memory is scanned for updates and screen updated every so many
+-# virtual seconds.  The default is 40000, about 25Hz. Keep in mind that
+-# you must tweak the 'cpu: ips=N' directive to be as close to the number
+-# of emulated instructions-per-second your workstation can do, for this
+-# to be accurate.
+-#
+-# Examples:
+-#   vga_update_interval: 250000
+-#=======================================================================
+-vga_update_interval: 300000
+-
+-# using for Winstone '98 tests
+-#vga_update_interval:  100000
+-
+-#=======================================================================
+-# KEYBOARD_SERIAL_DELAY:
+-# Approximate time in microseconds that it takes one character to
+-# be transfered from the keyboard to controller over the serial path.
+-# Examples:
+-#   keyboard_serial_delay: 200
+-#=======================================================================
+-keyboard_serial_delay: 250
+-
+-#=======================================================================
+-# KEYBOARD_PASTE_DELAY:
+-# Approximate time in microseconds between attempts to paste
+-# characters to the keyboard controller. This leaves time for the
+-# guest os to deal with the flow of characters.  The ideal setting
+-# depends on how your operating system processes characters.  The
+-# default of 100000 usec (.1 seconds) was chosen because it works 
+-# consistently in Windows.
+-#
+-# If your OS is losing characters during a paste, increase the paste
+-# delay until it stops losing characters.
+-#
+-# Examples:
+-#   keyboard_paste_delay: 100000
+-#=======================================================================
+-keyboard_paste_delay: 100000
+-
+-#=======================================================================
+-# MOUSE: 
+-# This option prevents Bochs from creating mouse "events" unless a mouse
+-# is  enabled. The hardware emulation itself is not disabled by this.
+-# You can turn the mouse on by setting enabled to 1, or turn it off by
+-# setting enabled to 0. Unless you have a particular reason for enabling
+-# the mouse by default, it is recommended that you leave it off.
+-# You can also toggle the mouse usage at runtime (control key + middle
+-# mouse button on X11, SDL, wxWidgets and Win32).
+-# With the mouse type option you can select the type of mouse to emulate.
+-# The default value is 'ps2'. The other choices are 'imps2' (wheel mouse
+-# on PS/2), 'serial', 'serial_wheel' (one com port requires setting
+-# 'mode=mouse') and 'usb' (3-button mouse - one of the USB ports must be
+-# connected with the 'mouse' device - requires PCI and USB support).
+-#
+-# Examples:
+-#   mouse: enabled=1
+-#   mouse: enabled=1, type=imps2
+-#   mouse: enabled=1, type=serial
+-#   mouse: enabled=0
+-#=======================================================================
+-mouse: enabled=0
+-
+-#=======================================================================
+-# private_colormap: Request that the GUI create and use it's own
+-#                   non-shared colormap.  This colormap will be used
+-#                   when in the bochs window.  If not enabled, a
+-#                   shared colormap scheme may be used.  Not implemented
+-#                   on all GUI's.
+-#
+-# Examples:
+-#   private_colormap: enabled=1
+-#   private_colormap: enabled=0
+-#=======================================================================
+-private_colormap: enabled=0
+-
+-#=======================================================================
+-# fullscreen: ONLY IMPLEMENTED ON AMIGA
+-#             Request that Bochs occupy the entire screen instead of a 
+-#             window.
+-#
+-# Examples:
+-#   fullscreen: enabled=0
+-#   fullscreen: enabled=1
+-#=======================================================================
+-#fullscreen: enabled=0
+-#screenmode: name="sample"
+-
+-#=======================================================================
+-# ne2k: NE2000 compatible ethernet adapter
+-#
+-# Examples:
+-# ne2k: ioaddr=IOADDR, irq=IRQ, mac=MACADDR, ethmod=MODULE, ethdev=DEVICE, script=SCRIPT
+-#
+-# ioaddr, irq: You probably won't need to change ioaddr and irq, unless there
+-# are IRQ conflicts.
+-#
+-# mac: The MAC address MUST NOT match the address of any machine on the net.
+-# Also, the first byte must be an even number (bit 0 set means a multicast
+-# address), and you cannot use ff:ff:ff:ff:ff:ff because that's the broadcast
+-# address.  For the ethertap module, you must use fe:fd:00:00:00:01.  There may
+-# be other restrictions too.  To be safe, just use the b0:c4... address.
+-#
+-# ethdev: The ethdev value is the name of the network interface on your host
+-# platform.  On UNIX machines, you can get the name by running ifconfig.  On
+-# Windows machines, you must run niclist to get the name of the ethdev.
+-# Niclist source code is in misc/niclist.c and it is included in Windows 
+-# binary releases.
+-#
+-# script: The script value is optional, and is the name of a script that 
+-# is executed after bochs initialize the network interface. You can use 
+-# this script to configure this network interface, or enable masquerading.
+-# This is mainly useful for the tun/tap devices that only exist during
+-# Bochs execution. The network interface name is supplied to the script
+-# as first parameter
+-#
+-# If you don't want to make connections to any physical networks,
+-# you can use the following 'ethmod's to simulate a virtual network.
+-#   null: All packets are discarded, but logged to a few files.
+-#   arpback: ARP is simulated. Disabled by default.
+-#   vde:  Virtual Distributed Ethernet
+-#   vnet: ARP, ICMP-echo(ping), DHCP and read/write TFTP are simulated.
+-#         The virtual host uses 192.168.10.1.
+-#         DHCP assigns 192.168.10.2 to the guest.
+-#         TFTP uses the ethdev value for the root directory and doesn't
+-#         overwrite files.
+-#
+-#=======================================================================
+-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=fbsd, ethdev=en0 #macosx
+-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=fbsd, ethdev=xl0
+-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=linux, ethdev=eth0
+-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=win32, ethdev=MYCARD
+-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tap, ethdev=tap0
+-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tuntap, ethdev=/dev/net/tun0, script=./tunconfig
+-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=null, ethdev=eth0
+-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vde, ethdev="/tmp/vde.ctl"
+-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vnet, ethdev="c:/temp"
+-
+-#=======================================================================
+-# KEYBOARD_MAPPING:
+-# This enables a remap of a physical localized keyboard to a 
+-# virtualized us keyboard, as the PC architecture expects.
+-# If enabled, the keymap file must be specified.
+-# 
+-# Examples:
+-#   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
+-#=======================================================================
+-keyboard_mapping: enabled=0, map=
+-
+-#=======================================================================
+-# KEYBOARD_TYPE:
+-# Type of keyboard return by a "identify keyboard" command to the
+-# keyboard controler. It must be one of "xt", "at" or "mf".
+-# Defaults to "mf". It should be ok for almost everybody. A known
+-# exception is french macs, that do have a "at"-like keyboard.
+-#
+-# Examples:
+-#   keyboard_type: mf
+-#=======================================================================
+-#keyboard_type: mf
+-
+-#=======================================================================
+-# USER_SHORTCUT:
+-# This defines the keyboard shortcut to be sent when you press the "user"
+-# button in the headerbar. The shortcut string is a combination of maximum
+-# 3 key names (listed below) separated with a '-' character. The old-style
+-# syntax (without the '-') still works for the key combinations supported
+-# in Bochs 2.2.1.
+-# Valid key names:
+-# "alt", "bksl", "bksp", "ctrl", "del", "down", "end", "enter", "esc",
+-# "f1", ... "f12", "home", "ins", "left", "menu", "minus", "pgdwn", "pgup",
+-# "plus", "right", "shift", "space", "tab", "up", and "win".
+-#
+-# Example:
+-#   user_shortcut: keys=ctrl-alt-del
+-#=======================================================================
+-#user_shortcut: keys=ctrl-alt-del
+-
+-#=======================================================================
+-# I440FXSUPPORT:
+-# This option controls the presence of the i440FX PCI chipset. You can
+-# also specify the devices connected to PCI slots. Up to 5 slots are
+-# available now. These devices are currently supported: ne2k, pcivga,
+-# pcidev and pcipnic. If Bochs is compiled with Cirrus SVGA support
+-# you'll have the additional choice 'cirrus'.
+-#
+-# Example:
+-#   i440fxsupport: enabled=1, slot1=pcivga, slot2=ne2k
+-#=======================================================================
+-#i440fxsupport: enabled=1
+-
+-#=======================================================================
+-# USB1:
+-# This option controls the presence of the USB root hub which is a part
+-# of the i440FX PCI chipset. With the portX option you can connect devices
+-# to the hub (currently supported: 'mouse' and 'keypad'). If you connect
+-# the mouse to one of the ports and use the mouse option 'type=usb' you'll
+-# have a 3-button USB mouse.
+-#
+-# Example:
+-#   usb1: enabled=1, port1=mouse, port2=keypad
+-#=======================================================================
+-#usb1: enabled=1
+-
+-#=======================================================================
+-# CMOSIMAGE:
+-# This defines image file that can be loaded into the CMOS RAM at startup.
+-# The rtc_init parameter controls whether initialize the RTC with values stored
+-# in the image. By default the time0 argument given to the clock option is used.
+-# With 'rtc_init=image' the image is the source for the initial time.
+-#
+-# Example:
+-#   cmosimage: file=cmos.img, rtc_init=image
+-#=======================================================================
+-#cmosimage: file=cmos.img, rtc_init=time0
+-
+-#=======================================================================
+-# other stuff
+-#=======================================================================
+-#magic_break: enabled=1
+-#load32bitOSImage: os=nullkernel, path=../kernel.img, iolog=../vga_io.log
+-#load32bitOSImage: os=linux, path=../linux.img, iolog=../vga_io.log, initrd=../initrd.img
+-#text_snapshot_check: enable
+-
+-#-------------------------
+-# PCI host device mapping
+-#-------------------------
+-#pcidev: vendor=0x1234, device=0x5678
+-
+-#=======================================================================
+-# GDBSTUB:
+-# Enable GDB stub. See user documentation for details.
+-# Default value is enabled=0.
+-#=======================================================================
+-#gdbstub: enabled=0, port=1234, text_base=0, data_base=0, bss_base=0
+-
+-#=======================================================================
+-# IPS:
+-# The IPS directive is DEPRECATED. Use the parameter IPS of the CPU
+-# directive instead.
+-#=======================================================================
+-#ips: 10000000
+-
+-#=======================================================================
+-# for Macintosh, use the style of pathnames in the following
+-# examples.
+-#
+-# vgaromimage: :bios:VGABIOS-elpin-2.40
+-# romimage: file=:bios:BIOS-bochs-latest, address=0xf0000
+-# floppya: 1_44=[fd:], status=inserted
+-#=======================================================================
+diff --git a/echo.c b/echo.c
+deleted file mode 100644
+index eed68a0..0000000
+--- a/echo.c
++++ /dev/null
+@@ -1,13 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int i;
+-
+-  for(i = 1; i < argc; i++)
+-    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+-  exit(0);
+-}
+diff --git a/elf.h b/elf.h
+deleted file mode 100644
+index d16c967..0000000
+--- a/elf.h
++++ /dev/null
+@@ -1,42 +0,0 @@
+-// Format of an ELF executable file
+-
+-#define ELF_MAGIC 0x464C457FU  // "\x7FELF" in little endian
+-
+-// File header
+-struct elfhdr {
+-  uint magic;  // must equal ELF_MAGIC
+-  uchar elf[12];
+-  ushort type;
+-  ushort machine;
+-  uint version;
+-  uint entry;
+-  uint phoff;
+-  uint shoff;
+-  uint flags;
+-  ushort ehsize;
+-  ushort phentsize;
+-  ushort phnum;
+-  ushort shentsize;
+-  ushort shnum;
+-  ushort shstrndx;
+-};
+-
+-// Program section header
+-struct proghdr {
+-  uint type;
+-  uint off;
+-  uint vaddr;
+-  uint paddr;
+-  uint filesz;
+-  uint memsz;
+-  uint flags;
+-  uint align;
+-};
+-
+-// Values for Proghdr type
+-#define ELF_PROG_LOAD           1
+-
+-// Flag bits for Proghdr flags
+-#define ELF_PROG_FLAG_EXEC      1
+-#define ELF_PROG_FLAG_WRITE     2
+-#define ELF_PROG_FLAG_READ      4
+diff --git a/entry.S b/entry.S
+deleted file mode 100644
+index bc79bab..0000000
+--- a/entry.S
++++ /dev/null
+@@ -1,68 +0,0 @@
+-# The xv6 kernel starts executing in this file. This file is linked with
+-# the kernel C code, so it can refer to kernel symbols such as main().
+-# The boot block (bootasm.S and bootmain.c) jumps to entry below.
+-        
+-# Multiboot header, for multiboot boot loaders like GNU Grub.
+-# http://www.gnu.org/software/grub/manual/multiboot/multiboot.html
+-#
+-# Using GRUB 2, you can boot xv6 from a file stored in a
+-# Linux file system by copying kernel or kernelmemfs to /boot
+-# and then adding this menu entry:
+-#
+-# menuentry "xv6" {
+-# 	insmod ext2
+-# 	set root='(hd0,msdos1)'
+-# 	set kernel='/boot/kernel'
+-# 	echo "Loading ${kernel}..."
+-# 	multiboot ${kernel} ${kernel}
+-# 	boot
+-# }
+-
+-#include "asm.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "param.h"
+-
+-# Multiboot header.  Data to direct multiboot loader.
+-.p2align 2
+-.text
+-.globl multiboot_header
+-multiboot_header:
+-  #define magic 0x1badb002
+-  #define flags 0
+-  .long magic
+-  .long flags
+-  .long (-magic-flags)
+-
+-# By convention, the _start symbol specifies the ELF entry point.
+-# Since we haven't set up virtual memory yet, our entry point is
+-# the physical address of 'entry'.
+-.globl _start
+-_start = V2P_WO(entry)
+-
+-# Entering xv6 on boot processor, with paging off.
+-.globl entry
+-entry:
+-  # Turn on page size extension for 4Mbyte pages
+-  movl    %cr4, %eax
+-  orl     $(CR4_PSE), %eax
+-  movl    %eax, %cr4
+-  # Set page directory
+-  movl    $(V2P_WO(entrypgdir)), %eax
+-  movl    %eax, %cr3
+-  # Turn on paging.
+-  movl    %cr0, %eax
+-  orl     $(CR0_PG|CR0_WP), %eax
+-  movl    %eax, %cr0
+-
+-  # Set up the stack pointer.
+-  movl $(stack + KSTACKSIZE), %esp
+-
+-  # Jump to main(), and switch to executing at
+-  # high addresses. The indirect call is needed because
+-  # the assembler produces a PC-relative instruction
+-  # for a direct jump.
+-  mov $main, %eax
+-  jmp *%eax
+-
+-.comm stack, KSTACKSIZE
+diff --git a/entryother.S b/entryother.S
+deleted file mode 100644
+index a3b6dc2..0000000
+--- a/entryother.S
++++ /dev/null
+@@ -1,93 +0,0 @@
+-#include "asm.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-	
+-# Each non-boot CPU ("AP") is started up in response to a STARTUP
+-# IPI from the boot CPU.  Section B.4.2 of the Multi-Processor
+-# Specification says that the AP will start in real mode with CS:IP
+-# set to XY00:0000, where XY is an 8-bit value sent with the
+-# STARTUP. Thus this code must start at a 4096-byte boundary.
+-#
+-# Because this code sets DS to zero, it must sit
+-# at an address in the low 2^16 bytes.
+-#
+-# Startothers (in main.c) sends the STARTUPs one at a time.
+-# It copies this code (start) at 0x7000.  It puts the address of
+-# a newly allocated per-core stack in start-4,the address of the
+-# place to jump to (mpenter) in start-8, and the physical address
+-# of entrypgdir in start-12.
+-#
+-# This code combines elements of bootasm.S and entry.S.
+-
+-.code16           
+-.globl start
+-start:
+-  cli            
+-
+-  # Zero data segment registers DS, ES, and SS.
+-  xorw    %ax,%ax
+-  movw    %ax,%ds
+-  movw    %ax,%es
+-  movw    %ax,%ss
+-
+-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+-  # virtual addresses map directly to physical addresses so that the
+-  # effective memory map doesn't change during the transition.
+-  lgdt    gdtdesc
+-  movl    %cr0, %eax
+-  orl     $CR0_PE, %eax
+-  movl    %eax, %cr0
+-
+-  # Complete the transition to 32-bit protected mode by using a long jmp
+-  # to reload %cs and %eip.  The segment descriptors are set up with no
+-  # translation, so that the mapping is still the identity mapping.
+-  ljmpl    $(SEG_KCODE<<3), $(start32)
+-
+-//PAGEBREAK!
+-.code32  # Tell assembler to generate 32-bit code now.
+-start32:
+-  # Set up the protected-mode data segment registers
+-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+-  movw    %ax, %ds                # -> DS: Data Segment
+-  movw    %ax, %es                # -> ES: Extra Segment
+-  movw    %ax, %ss                # -> SS: Stack Segment
+-  movw    $0, %ax                 # Zero segments not ready for use
+-  movw    %ax, %fs                # -> FS
+-  movw    %ax, %gs                # -> GS
+-
+-  # Turn on page size extension for 4Mbyte pages
+-  movl    %cr4, %eax
+-  orl     $(CR4_PSE), %eax
+-  movl    %eax, %cr4
+-  # Use entrypgdir as our initial page table
+-  movl    (start-12), %eax
+-  movl    %eax, %cr3
+-  # Turn on paging.
+-  movl    %cr0, %eax
+-  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
+-  movl    %eax, %cr0
+-
+-  # Switch to the stack allocated by startothers()
+-  movl    (start-4), %esp
+-  # Call mpenter()
+-  call	 *(start-8)
+-
+-  movw    $0x8a00, %ax
+-  movw    %ax, %dx
+-  outw    %ax, %dx
+-  movw    $0x8ae0, %ax
+-  outw    %ax, %dx
+-spin:
+-  jmp     spin
+-
+-.p2align 2
+-gdt:
+-  SEG_NULLASM
+-  SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
+-  SEG_ASM(STA_W, 0, 0xffffffff)
+-
+-
+-gdtdesc:
+-  .word   (gdtdesc - gdt - 1)
+-  .long   gdt
+-
+diff --git a/exec.c b/exec.c
+deleted file mode 100644
+index b40134f..0000000
+--- a/exec.c
++++ /dev/null
+@@ -1,114 +0,0 @@
+-#include "types.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "defs.h"
+-#include "x86.h"
+-#include "elf.h"
+-
+-int
+-exec(char *path, char **argv)
+-{
+-  char *s, *last;
+-  int i, off;
+-  uint argc, sz, sp, ustack[3+MAXARG+1];
+-  struct elfhdr elf;
+-  struct inode *ip;
+-  struct proghdr ph;
+-  pde_t *pgdir, *oldpgdir;
+-  struct proc *curproc = myproc();
+-
+-  begin_op();
+-
+-  if((ip = namei(path)) == 0){
+-    end_op();
+-    cprintf("exec: fail\n");
+-    return -1;
+-  }
+-  ilock(ip);
+-  pgdir = 0;
+-
+-  // Check ELF header
+-  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
+-    goto bad;
+-  if(elf.magic != ELF_MAGIC)
+-    goto bad;
+-
+-  if((pgdir = setupkvm()) == 0)
+-    goto bad;
+-
+-  // Load program into memory.
+-  sz = 0;
+-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+-    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
+-      goto bad;
+-    if(ph.type != ELF_PROG_LOAD)
+-      continue;
+-    if(ph.memsz < ph.filesz)
+-      goto bad;
+-    if(ph.vaddr + ph.memsz < ph.vaddr)
+-      goto bad;
+-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+-      goto bad;
+-    if(ph.vaddr % PGSIZE != 0)
+-      goto bad;
+-    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+-      goto bad;
+-  }
+-  iunlockput(ip);
+-  end_op();
+-  ip = 0;
+-
+-  // Allocate two pages at the next page boundary.
+-  // Make the first inaccessible.  Use the second as the user stack.
+-  sz = PGROUNDUP(sz);
+-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+-    goto bad;
+-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+-  sp = sz;
+-
+-  // Push argument strings, prepare rest of stack in ustack.
+-  for(argc = 0; argv[argc]; argc++) {
+-    if(argc >= MAXARG)
+-      goto bad;
+-    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+-    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+-      goto bad;
+-    ustack[3+argc] = sp;
+-  }
+-  ustack[3+argc] = 0;
+-
+-  ustack[0] = 0xffffffff;  // fake return PC
+-  ustack[1] = argc;
+-  ustack[2] = sp - (argc+1)*4;  // argv pointer
+-
+-  sp -= (3+argc+1) * 4;
+-  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+-    goto bad;
+-
+-  // Save program name for debugging.
+-  for(last=s=path; *s; s++)
+-    if(*s == '/')
+-      last = s+1;
+-  safestrcpy(curproc->name, last, sizeof(curproc->name));
+-
+-  // Commit to the user image.
+-  oldpgdir = curproc->pgdir;
+-  curproc->pgdir = pgdir;
+-  curproc->sz = sz;
+-  curproc->tf->eip = elf.entry;  // main
+-  curproc->tf->esp = sp;
+-  switchuvm(curproc);
+-  freevm(oldpgdir);
+-  return 0;
+-
+- bad:
+-  if(pgdir)
+-    freevm(pgdir);
+-  if(ip){
+-    iunlockput(ip);
+-    end_op();
+-  }
+-  return -1;
+-}
+diff --git a/fcntl.h b/fcntl.h
+deleted file mode 100644
+index d565483..0000000
+--- a/fcntl.h
++++ /dev/null
+@@ -1,4 +0,0 @@
+-#define O_RDONLY  0x000
+-#define O_WRONLY  0x001
+-#define O_RDWR    0x002
+-#define O_CREATE  0x200
+diff --git a/file.c b/file.c
+deleted file mode 100644
+index 24b32c2..0000000
+--- a/file.c
++++ /dev/null
+@@ -1,157 +0,0 @@
+-//
+-// File descriptors
+-//
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "fs.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "file.h"
+-
+-struct devsw devsw[NDEV];
+-struct {
+-  struct spinlock lock;
+-  struct file file[NFILE];
+-} ftable;
+-
+-void
+-fileinit(void)
+-{
+-  initlock(&ftable.lock, "ftable");
+-}
+-
+-// Allocate a file structure.
+-struct file*
+-filealloc(void)
+-{
+-  struct file *f;
+-
+-  acquire(&ftable.lock);
+-  for(f = ftable.file; f < ftable.file + NFILE; f++){
+-    if(f->ref == 0){
+-      f->ref = 1;
+-      release(&ftable.lock);
+-      return f;
+-    }
+-  }
+-  release(&ftable.lock);
+-  return 0;
+-}
+-
+-// Increment ref count for file f.
+-struct file*
+-filedup(struct file *f)
+-{
+-  acquire(&ftable.lock);
+-  if(f->ref < 1)
+-    panic("filedup");
+-  f->ref++;
+-  release(&ftable.lock);
+-  return f;
+-}
+-
+-// Close file f.  (Decrement ref count, close when reaches 0.)
+-void
+-fileclose(struct file *f)
+-{
+-  struct file ff;
+-
+-  acquire(&ftable.lock);
+-  if(f->ref < 1)
+-    panic("fileclose");
+-  if(--f->ref > 0){
+-    release(&ftable.lock);
+-    return;
+-  }
+-  ff = *f;
+-  f->ref = 0;
+-  f->type = FD_NONE;
+-  release(&ftable.lock);
+-
+-  if(ff.type == FD_PIPE)
+-    pipeclose(ff.pipe, ff.writable);
+-  else if(ff.type == FD_INODE){
+-    begin_op();
+-    iput(ff.ip);
+-    end_op();
+-  }
+-}
+-
+-// Get metadata about file f.
+-int
+-filestat(struct file *f, struct stat *st)
+-{
+-  if(f->type == FD_INODE){
+-    ilock(f->ip);
+-    stati(f->ip, st);
+-    iunlock(f->ip);
+-    return 0;
+-  }
+-  return -1;
+-}
+-
+-// Read from file f.
+-int
+-fileread(struct file *f, char *addr, int n)
+-{
+-  int r;
+-
+-  if(f->readable == 0)
+-    return -1;
+-  if(f->type == FD_PIPE)
+-    return piperead(f->pipe, addr, n);
+-  if(f->type == FD_INODE){
+-    ilock(f->ip);
+-    if((r = readi(f->ip, addr, f->off, n)) > 0)
+-      f->off += r;
+-    iunlock(f->ip);
+-    return r;
+-  }
+-  panic("fileread");
+-}
+-
+-//PAGEBREAK!
+-// Write to file f.
+-int
+-filewrite(struct file *f, char *addr, int n)
+-{
+-  int r;
+-
+-  if(f->writable == 0)
+-    return -1;
+-  if(f->type == FD_PIPE)
+-    return pipewrite(f->pipe, addr, n);
+-  if(f->type == FD_INODE){
+-    // write a few blocks at a time to avoid exceeding
+-    // the maximum log transaction size, including
+-    // i-node, indirect block, allocation blocks,
+-    // and 2 blocks of slop for non-aligned writes.
+-    // this really belongs lower down, since writei()
+-    // might be writing a device like the console.
+-    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
+-    int i = 0;
+-    while(i < n){
+-      int n1 = n - i;
+-      if(n1 > max)
+-        n1 = max;
+-
+-      begin_op();
+-      ilock(f->ip);
+-      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+-        f->off += r;
+-      iunlock(f->ip);
+-      end_op();
+-
+-      if(r < 0)
+-        break;
+-      if(r != n1)
+-        panic("short filewrite");
+-      i += r;
+-    }
+-    return i == n ? n : -1;
+-  }
+-  panic("filewrite");
+-}
+-
+diff --git a/file.h b/file.h
+deleted file mode 100644
+index 0990c82..0000000
+--- a/file.h
++++ /dev/null
+@@ -1,37 +0,0 @@
+-struct file {
+-  enum { FD_NONE, FD_PIPE, FD_INODE } type;
+-  int ref; // reference count
+-  char readable;
+-  char writable;
+-  struct pipe *pipe;
+-  struct inode *ip;
+-  uint off;
+-};
+-
+-
+-// in-memory copy of an inode
+-struct inode {
+-  uint dev;           // Device number
+-  uint inum;          // Inode number
+-  int ref;            // Reference count
+-  struct sleeplock lock; // protects everything below here
+-  int valid;          // inode has been read from disk?
+-
+-  short type;         // copy of disk inode
+-  short major;
+-  short minor;
+-  short nlink;
+-  uint size;
+-  uint addrs[NDIRECT+1];
+-};
+-
+-// table mapping major device number to
+-// device functions
+-struct devsw {
+-  int (*read)(struct inode*, char*, int);
+-  int (*write)(struct inode*, char*, int);
+-};
+-
+-extern struct devsw devsw[];
+-
+-#define CONSOLE 1
+diff --git a/forktest.c b/forktest.c
+deleted file mode 100644
+index a4b35ed..0000000
+--- a/forktest.c
++++ /dev/null
+@@ -1,56 +0,0 @@
+-// Test that fork fails gracefully.
+-// Tiny executable so that the limit can be filling the proc table.
+-
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-#define N  1000
+-
+-void
+-printf(int fd, const char *s, ...)
+-{
+-  write(fd, s, strlen(s));
+-}
+-
+-void
+-forktest(void)
+-{
+-  int n, pid;
+-
+-  printf(1, "fork test\n");
+-
+-  for(n=0; n<N; n++){
+-    pid = fork();
+-    if(pid < 0)
+-      break;
+-    if(pid == 0)
+-      exit(4);
+-  }
+-
+-  if(n == N){
+-    printf(1, "fork claimed to work N times!\n", N);
+-    exit(3);
+-  }
+-
+-  for(; n > 0; n--){
+-    if(wait(NULL) < 0){
+-      printf(1, "wait stopped early\n");
+-      exit(2);
+-    }
+-  }
+-
+-  if(wait(NULL) != -1){
+-    printf(1, "wait got too many\n");
+-    exit(1);
+-  }
+-
+-  printf(1, "fork test OK\n");
+-}
+-
+-int
+-main(void)
+-{
+-  forktest();
+-  exit(0);
+-}
+diff --git a/fs.c b/fs.c
+deleted file mode 100644
+index f77275f..0000000
+--- a/fs.c
++++ /dev/null
+@@ -1,670 +0,0 @@
+-// File system implementation.  Five layers:
+-//   + Blocks: allocator for raw disk blocks.
+-//   + Log: crash recovery for multi-step updates.
+-//   + Files: inode allocator, reading, writing, metadata.
+-//   + Directories: inode with special contents (list of other inodes!)
+-//   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
+-//
+-// This file contains the low-level file system manipulation
+-// routines.  The (higher-level) system call implementations
+-// are in sysfile.c.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "stat.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "buf.h"
+-#include "file.h"
+-
+-#define min(a, b) ((a) < (b) ? (a) : (b))
+-static void itrunc(struct inode*);
+-// there should be one superblock per disk device, but we run with
+-// only one device
+-struct superblock sb; 
+-
+-// Read the super block.
+-void
+-readsb(int dev, struct superblock *sb)
+-{
+-  struct buf *bp;
+-
+-  bp = bread(dev, 1);
+-  memmove(sb, bp->data, sizeof(*sb));
+-  brelse(bp);
+-}
+-
+-// Zero a block.
+-static void
+-bzero(int dev, int bno)
+-{
+-  struct buf *bp;
+-
+-  bp = bread(dev, bno);
+-  memset(bp->data, 0, BSIZE);
+-  log_write(bp);
+-  brelse(bp);
+-}
+-
+-// Blocks.
+-
+-// Allocate a zeroed disk block.
+-static uint
+-balloc(uint dev)
+-{
+-  int b, bi, m;
+-  struct buf *bp;
+-
+-  bp = 0;
+-  for(b = 0; b < sb.size; b += BPB){
+-    bp = bread(dev, BBLOCK(b, sb));
+-    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+-      m = 1 << (bi % 8);
+-      if((bp->data[bi/8] & m) == 0){  // Is block free?
+-        bp->data[bi/8] |= m;  // Mark block in use.
+-        log_write(bp);
+-        brelse(bp);
+-        bzero(dev, b + bi);
+-        return b + bi;
+-      }
+-    }
+-    brelse(bp);
+-  }
+-  panic("balloc: out of blocks");
+-}
+-
+-// Free a disk block.
+-static void
+-bfree(int dev, uint b)
+-{
+-  struct buf *bp;
+-  int bi, m;
+-
+-  bp = bread(dev, BBLOCK(b, sb));
+-  bi = b % BPB;
+-  m = 1 << (bi % 8);
+-  if((bp->data[bi/8] & m) == 0)
+-    panic("freeing free block");
+-  bp->data[bi/8] &= ~m;
+-  log_write(bp);
+-  brelse(bp);
+-}
+-
+-// Inodes.
+-//
+-// An inode describes a single unnamed file.
+-// The inode disk structure holds metadata: the file's type,
+-// its size, the number of links referring to it, and the
+-// list of blocks holding the file's content.
+-//
+-// The inodes are laid out sequentially on disk at
+-// sb.startinode. Each inode has a number, indicating its
+-// position on the disk.
+-//
+-// The kernel keeps a cache of in-use inodes in memory
+-// to provide a place for synchronizing access
+-// to inodes used by multiple processes. The cached
+-// inodes include book-keeping information that is
+-// not stored on disk: ip->ref and ip->valid.
+-//
+-// An inode and its in-memory representation go through a
+-// sequence of states before they can be used by the
+-// rest of the file system code.
+-//
+-// * Allocation: an inode is allocated if its type (on disk)
+-//   is non-zero. ialloc() allocates, and iput() frees if
+-//   the reference and link counts have fallen to zero.
+-//
+-// * Referencing in cache: an entry in the inode cache
+-//   is free if ip->ref is zero. Otherwise ip->ref tracks
+-//   the number of in-memory pointers to the entry (open
+-//   files and current directories). iget() finds or
+-//   creates a cache entry and increments its ref; iput()
+-//   decrements ref.
+-//
+-// * Valid: the information (type, size, &c) in an inode
+-//   cache entry is only correct when ip->valid is 1.
+-//   ilock() reads the inode from
+-//   the disk and sets ip->valid, while iput() clears
+-//   ip->valid if ip->ref has fallen to zero.
+-//
+-// * Locked: file system code may only examine and modify
+-//   the information in an inode and its content if it
+-//   has first locked the inode.
+-//
+-// Thus a typical sequence is:
+-//   ip = iget(dev, inum)
+-//   ilock(ip)
+-//   ... examine and modify ip->xxx ...
+-//   iunlock(ip)
+-//   iput(ip)
+-//
+-// ilock() is separate from iget() so that system calls can
+-// get a long-term reference to an inode (as for an open file)
+-// and only lock it for short periods (e.g., in read()).
+-// The separation also helps avoid deadlock and races during
+-// pathname lookup. iget() increments ip->ref so that the inode
+-// stays cached and pointers to it remain valid.
+-//
+-// Many internal file system functions expect the caller to
+-// have locked the inodes involved; this lets callers create
+-// multi-step atomic operations.
+-//
+-// The icache.lock spin-lock protects the allocation of icache
+-// entries. Since ip->ref indicates whether an entry is free,
+-// and ip->dev and ip->inum indicate which i-node an entry
+-// holds, one must hold icache.lock while using any of those fields.
+-//
+-// An ip->lock sleep-lock protects all ip-> fields other than ref,
+-// dev, and inum.  One must hold ip->lock in order to
+-// read or write that inode's ip->valid, ip->size, ip->type, &c.
+-
+-struct {
+-  struct spinlock lock;
+-  struct inode inode[NINODE];
+-} icache;
+-
+-void
+-iinit(int dev)
+-{
+-  int i = 0;
+-  
+-  initlock(&icache.lock, "icache");
+-  for(i = 0; i < NINODE; i++) {
+-    initsleeplock(&icache.inode[i].lock, "inode");
+-  }
+-
+-  readsb(dev, &sb);
+-  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
+- inodestart %d bmap start %d\n", sb.size, sb.nblocks,
+-          sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
+-          sb.bmapstart);
+-}
+-
+-static struct inode* iget(uint dev, uint inum);
+-
+-//PAGEBREAK!
+-// Allocate an inode on device dev.
+-// Mark it as allocated by  giving it type type.
+-// Returns an unlocked but allocated and referenced inode.
+-struct inode*
+-ialloc(uint dev, short type)
+-{
+-  int inum;
+-  struct buf *bp;
+-  struct dinode *dip;
+-
+-  for(inum = 1; inum < sb.ninodes; inum++){
+-    bp = bread(dev, IBLOCK(inum, sb));
+-    dip = (struct dinode*)bp->data + inum%IPB;
+-    if(dip->type == 0){  // a free inode
+-      memset(dip, 0, sizeof(*dip));
+-      dip->type = type;
+-      log_write(bp);   // mark it allocated on the disk
+-      brelse(bp);
+-      return iget(dev, inum);
+-    }
+-    brelse(bp);
+-  }
+-  panic("ialloc: no inodes");
+-}
+-
+-// Copy a modified in-memory inode to disk.
+-// Must be called after every change to an ip->xxx field
+-// that lives on disk, since i-node cache is write-through.
+-// Caller must hold ip->lock.
+-void
+-iupdate(struct inode *ip)
+-{
+-  struct buf *bp;
+-  struct dinode *dip;
+-
+-  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+-  dip = (struct dinode*)bp->data + ip->inum%IPB;
+-  dip->type = ip->type;
+-  dip->major = ip->major;
+-  dip->minor = ip->minor;
+-  dip->nlink = ip->nlink;
+-  dip->size = ip->size;
+-  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+-  log_write(bp);
+-  brelse(bp);
+-}
+-
+-// Find the inode with number inum on device dev
+-// and return the in-memory copy. Does not lock
+-// the inode and does not read it from disk.
+-static struct inode*
+-iget(uint dev, uint inum)
+-{
+-  struct inode *ip, *empty;
+-
+-  acquire(&icache.lock);
+-
+-  // Is the inode already cached?
+-  empty = 0;
+-  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+-    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+-      ip->ref++;
+-      release(&icache.lock);
+-      return ip;
+-    }
+-    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+-      empty = ip;
+-  }
+-
+-  // Recycle an inode cache entry.
+-  if(empty == 0)
+-    panic("iget: no inodes");
+-
+-  ip = empty;
+-  ip->dev = dev;
+-  ip->inum = inum;
+-  ip->ref = 1;
+-  ip->valid = 0;
+-  release(&icache.lock);
+-
+-  return ip;
+-}
+-
+-// Increment reference count for ip.
+-// Returns ip to enable ip = idup(ip1) idiom.
+-struct inode*
+-idup(struct inode *ip)
+-{
+-  acquire(&icache.lock);
+-  ip->ref++;
+-  release(&icache.lock);
+-  return ip;
+-}
+-
+-// Lock the given inode.
+-// Reads the inode from disk if necessary.
+-void
+-ilock(struct inode *ip)
+-{
+-  struct buf *bp;
+-  struct dinode *dip;
+-
+-  if(ip == 0 || ip->ref < 1)
+-    panic("ilock");
+-
+-  acquiresleep(&ip->lock);
+-
+-  if(ip->valid == 0){
+-    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+-    dip = (struct dinode*)bp->data + ip->inum%IPB;
+-    ip->type = dip->type;
+-    ip->major = dip->major;
+-    ip->minor = dip->minor;
+-    ip->nlink = dip->nlink;
+-    ip->size = dip->size;
+-    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+-    brelse(bp);
+-    ip->valid = 1;
+-    if(ip->type == 0)
+-      panic("ilock: no type");
+-  }
+-}
+-
+-// Unlock the given inode.
+-void
+-iunlock(struct inode *ip)
+-{
+-  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+-    panic("iunlock");
+-
+-  releasesleep(&ip->lock);
+-}
+-
+-// Drop a reference to an in-memory inode.
+-// If that was the last reference, the inode cache entry can
+-// be recycled.
+-// If that was the last reference and the inode has no links
+-// to it, free the inode (and its content) on disk.
+-// All calls to iput() must be inside a transaction in
+-// case it has to free the inode.
+-void
+-iput(struct inode *ip)
+-{
+-  acquiresleep(&ip->lock);
+-  if(ip->valid && ip->nlink == 0){
+-    acquire(&icache.lock);
+-    int r = ip->ref;
+-    release(&icache.lock);
+-    if(r == 1){
+-      // inode has no links and no other references: truncate and free.
+-      itrunc(ip);
+-      ip->type = 0;
+-      iupdate(ip);
+-      ip->valid = 0;
+-    }
+-  }
+-  releasesleep(&ip->lock);
+-
+-  acquire(&icache.lock);
+-  ip->ref--;
+-  release(&icache.lock);
+-}
+-
+-// Common idiom: unlock, then put.
+-void
+-iunlockput(struct inode *ip)
+-{
+-  iunlock(ip);
+-  iput(ip);
+-}
+-
+-//PAGEBREAK!
+-// Inode content
+-//
+-// The content (data) associated with each inode is stored
+-// in blocks on the disk. The first NDIRECT block numbers
+-// are listed in ip->addrs[].  The next NINDIRECT blocks are
+-// listed in block ip->addrs[NDIRECT].
+-
+-// Return the disk block address of the nth block in inode ip.
+-// If there is no such block, bmap allocates one.
+-static uint
+-bmap(struct inode *ip, uint bn)
+-{
+-  uint addr, *a;
+-  struct buf *bp;
+-
+-  if(bn < NDIRECT){
+-    if((addr = ip->addrs[bn]) == 0)
+-      ip->addrs[bn] = addr = balloc(ip->dev);
+-    return addr;
+-  }
+-  bn -= NDIRECT;
+-
+-  if(bn < NINDIRECT){
+-    // Load indirect block, allocating if necessary.
+-    if((addr = ip->addrs[NDIRECT]) == 0)
+-      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+-    bp = bread(ip->dev, addr);
+-    a = (uint*)bp->data;
+-    if((addr = a[bn]) == 0){
+-      a[bn] = addr = balloc(ip->dev);
+-      log_write(bp);
+-    }
+-    brelse(bp);
+-    return addr;
+-  }
+-
+-  panic("bmap: out of range");
+-}
+-
+-// Truncate inode (discard contents).
+-// Only called when the inode has no links
+-// to it (no directory entries referring to it)
+-// and has no in-memory reference to it (is
+-// not an open file or current directory).
+-static void
+-itrunc(struct inode *ip)
+-{
+-  int i, j;
+-  struct buf *bp;
+-  uint *a;
+-
+-  for(i = 0; i < NDIRECT; i++){
+-    if(ip->addrs[i]){
+-      bfree(ip->dev, ip->addrs[i]);
+-      ip->addrs[i] = 0;
+-    }
+-  }
+-
+-  if(ip->addrs[NDIRECT]){
+-    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+-    a = (uint*)bp->data;
+-    for(j = 0; j < NINDIRECT; j++){
+-      if(a[j])
+-        bfree(ip->dev, a[j]);
+-    }
+-    brelse(bp);
+-    bfree(ip->dev, ip->addrs[NDIRECT]);
+-    ip->addrs[NDIRECT] = 0;
+-  }
+-
+-  ip->size = 0;
+-  iupdate(ip);
+-}
+-
+-// Copy stat information from inode.
+-// Caller must hold ip->lock.
+-void
+-stati(struct inode *ip, struct stat *st)
+-{
+-  st->dev = ip->dev;
+-  st->ino = ip->inum;
+-  st->type = ip->type;
+-  st->nlink = ip->nlink;
+-  st->size = ip->size;
+-}
+-
+-//PAGEBREAK!
+-// Read data from inode.
+-// Caller must hold ip->lock.
+-int
+-readi(struct inode *ip, char *dst, uint off, uint n)
+-{
+-  uint tot, m;
+-  struct buf *bp;
+-
+-  if(ip->type == T_DEV){
+-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+-      return -1;
+-    return devsw[ip->major].read(ip, dst, n);
+-  }
+-
+-  if(off > ip->size || off + n < off)
+-    return -1;
+-  if(off + n > ip->size)
+-    n = ip->size - off;
+-
+-  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+-    m = min(n - tot, BSIZE - off%BSIZE);
+-    memmove(dst, bp->data + off%BSIZE, m);
+-    brelse(bp);
+-  }
+-  return n;
+-}
+-
+-// PAGEBREAK!
+-// Write data to inode.
+-// Caller must hold ip->lock.
+-int
+-writei(struct inode *ip, char *src, uint off, uint n)
+-{
+-  uint tot, m;
+-  struct buf *bp;
+-
+-  if(ip->type == T_DEV){
+-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+-      return -1;
+-    return devsw[ip->major].write(ip, src, n);
+-  }
+-
+-  if(off > ip->size || off + n < off)
+-    return -1;
+-  if(off + n > MAXFILE*BSIZE)
+-    return -1;
+-
+-  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+-    m = min(n - tot, BSIZE - off%BSIZE);
+-    memmove(bp->data + off%BSIZE, src, m);
+-    log_write(bp);
+-    brelse(bp);
+-  }
+-
+-  if(n > 0 && off > ip->size){
+-    ip->size = off;
+-    iupdate(ip);
+-  }
+-  return n;
+-}
+-
+-//PAGEBREAK!
+-// Directories
+-
+-int
+-namecmp(const char *s, const char *t)
+-{
+-  return strncmp(s, t, DIRSIZ);
+-}
+-
+-// Look for a directory entry in a directory.
+-// If found, set *poff to byte offset of entry.
+-struct inode*
+-dirlookup(struct inode *dp, char *name, uint *poff)
+-{
+-  uint off, inum;
+-  struct dirent de;
+-
+-  if(dp->type != T_DIR)
+-    panic("dirlookup not DIR");
+-
+-  for(off = 0; off < dp->size; off += sizeof(de)){
+-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+-      panic("dirlookup read");
+-    if(de.inum == 0)
+-      continue;
+-    if(namecmp(name, de.name) == 0){
+-      // entry matches path element
+-      if(poff)
+-        *poff = off;
+-      inum = de.inum;
+-      return iget(dp->dev, inum);
+-    }
+-  }
+-
+-  return 0;
+-}
+-
+-// Write a new directory entry (name, inum) into the directory dp.
+-int
+-dirlink(struct inode *dp, char *name, uint inum)
+-{
+-  int off;
+-  struct dirent de;
+-  struct inode *ip;
+-
+-  // Check that name is not present.
+-  if((ip = dirlookup(dp, name, 0)) != 0){
+-    iput(ip);
+-    return -1;
+-  }
+-
+-  // Look for an empty dirent.
+-  for(off = 0; off < dp->size; off += sizeof(de)){
+-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+-      panic("dirlink read");
+-    if(de.inum == 0)
+-      break;
+-  }
+-
+-  strncpy(de.name, name, DIRSIZ);
+-  de.inum = inum;
+-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+-    panic("dirlink");
+-
+-  return 0;
+-}
+-
+-//PAGEBREAK!
+-// Paths
+-
+-// Copy the next path element from path into name.
+-// Return a pointer to the element following the copied one.
+-// The returned path has no leading slashes,
+-// so the caller can check *path=='\0' to see if the name is the last one.
+-// If no name to remove, return 0.
+-//
+-// Examples:
+-//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
+-//   skipelem("///a//bb", name) = "bb", setting name = "a"
+-//   skipelem("a", name) = "", setting name = "a"
+-//   skipelem("", name) = skipelem("////", name) = 0
+-//
+-static char*
+-skipelem(char *path, char *name)
+-{
+-  char *s;
+-  int len;
+-
+-  while(*path == '/')
+-    path++;
+-  if(*path == 0)
+-    return 0;
+-  s = path;
+-  while(*path != '/' && *path != 0)
+-    path++;
+-  len = path - s;
+-  if(len >= DIRSIZ)
+-    memmove(name, s, DIRSIZ);
+-  else {
+-    memmove(name, s, len);
+-    name[len] = 0;
+-  }
+-  while(*path == '/')
+-    path++;
+-  return path;
+-}
+-
+-// Look up and return the inode for a path name.
+-// If parent != 0, return the inode for the parent and copy the final
+-// path element into name, which must have room for DIRSIZ bytes.
+-// Must be called inside a transaction since it calls iput().
+-static struct inode*
+-namex(char *path, int nameiparent, char *name)
+-{
+-  struct inode *ip, *next;
+-
+-  if(*path == '/')
+-    ip = iget(ROOTDEV, ROOTINO);
+-  else
+-    ip = idup(myproc()->cwd);
+-
+-  while((path = skipelem(path, name)) != 0){
+-    ilock(ip);
+-    if(ip->type != T_DIR){
+-      iunlockput(ip);
+-      return 0;
+-    }
+-    if(nameiparent && *path == '\0'){
+-      // Stop one level early.
+-      iunlock(ip);
+-      return ip;
+-    }
+-    if((next = dirlookup(ip, name, 0)) == 0){
+-      iunlockput(ip);
+-      return 0;
+-    }
+-    iunlockput(ip);
+-    ip = next;
+-  }
+-  if(nameiparent){
+-    iput(ip);
+-    return 0;
+-  }
+-  return ip;
+-}
+-
+-struct inode*
+-namei(char *path)
+-{
+-  char name[DIRSIZ];
+-  return namex(path, 0, name);
+-}
+-
+-struct inode*
+-nameiparent(char *path, char *name)
+-{
+-  return namex(path, 1, name);
+-}
+diff --git a/fs.h b/fs.h
+deleted file mode 100644
+index 3214f1d..0000000
+--- a/fs.h
++++ /dev/null
+@@ -1,57 +0,0 @@
+-// On-disk file system format.
+-// Both the kernel and user programs use this header file.
+-
+-
+-#define ROOTINO 1  // root i-number
+-#define BSIZE 512  // block size
+-
+-// Disk layout:
+-// [ boot block | super block | log | inode blocks |
+-//                                          free bit map | data blocks]
+-//
+-// mkfs computes the super block and builds an initial file system. The
+-// super block describes the disk layout:
+-struct superblock {
+-  uint size;         // Size of file system image (blocks)
+-  uint nblocks;      // Number of data blocks
+-  uint ninodes;      // Number of inodes.
+-  uint nlog;         // Number of log blocks
+-  uint logstart;     // Block number of first log block
+-  uint inodestart;   // Block number of first inode block
+-  uint bmapstart;    // Block number of first free map block
+-};
+-
+-#define NDIRECT 12
+-#define NINDIRECT (BSIZE / sizeof(uint))
+-#define MAXFILE (NDIRECT + NINDIRECT)
+-
+-// On-disk inode structure
+-struct dinode {
+-  short type;           // File type
+-  short major;          // Major device number (T_DEV only)
+-  short minor;          // Minor device number (T_DEV only)
+-  short nlink;          // Number of links to inode in file system
+-  uint size;            // Size of file (bytes)
+-  uint addrs[NDIRECT+1];   // Data block addresses
+-};
+-
+-// Inodes per block.
+-#define IPB           (BSIZE / sizeof(struct dinode))
+-
+-// Block containing inode i
+-#define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
+-
+-// Bitmap bits per block
+-#define BPB           (BSIZE*8)
+-
+-// Block of free map containing bit for block b
+-#define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
+-
+-// Directory is a file containing a sequence of dirent structures.
+-#define DIRSIZ 14
+-
+-struct dirent {
+-  ushort inum;
+-  char name[DIRSIZ];
+-};
+-
+diff --git a/gdbutil b/gdbutil
+deleted file mode 100644
+index e0c362f..0000000
+--- a/gdbutil
++++ /dev/null
+@@ -1,291 +0,0 @@
+-# -*- gdb-script -*-
+-
+-# Utility functions to pretty-print x86 segment/interrupt descriptors.
+-# To load this file, run "source gdbutil" in gdb.
+-# printdesc and printdescs are the main entry points.
+-
+-# IA32 2007, Volume 3A, Table 3-2
+-set $STS_T16A = 0x1
+-set $STS_LDT  = 0x2
+-set $STS_T16B = 0x3
+-set $STS_CG16 = 0x4
+-set $STS_TG   = 0x5
+-set $STS_IG16 = 0x6
+-set $STS_TG16 = 0x7
+-set $STS_T32A = 0x9
+-set $STS_T32B = 0xB
+-set $STS_CG32 = 0xC
+-set $STS_IG32 = 0xE
+-set $STS_TG32 = 0xF
+-
+-define outputsts
+-  while 1
+-    if $arg0 == $STS_T16A
+-      echo STS_T16A
+-      loop_break
+-    end
+-    if $arg0 == $STS_LDT
+-      echo STS_LDT\ 
+-      loop_break
+-    end
+-    if $arg0 == $STS_T16B
+-      echo STS_T16B
+-      loop_break
+-    end
+-    if $arg0 == $STS_CG16
+-      echo STS_CG16
+-      loop_break
+-    end
+-    if $arg0 == $STS_TG
+-      echo STS_TG\ \ 
+-      loop_break
+-    end
+-    if $arg0 == $STS_IG16
+-      echo STS_IG16
+-      loop_break
+-    end
+-    if $arg0 == $STS_TG16
+-      echo STS_TG16
+-      loop_break
+-    end
+-    if $arg0 == $STS_T32A
+-      echo STS_T32A
+-      loop_break
+-    end
+-    if $arg0 == $STS_T32B
+-      echo STS_T32B
+-      loop_break
+-    end
+-    if $arg0 == $STS_CG32
+-      echo STS_CG32
+-      loop_break
+-    end
+-    if $arg0 == $STS_IG32
+-      echo STS_IG32
+-      loop_break
+-    end
+-    if $arg0 == $STS_TG32
+-      echo STS_TG32
+-      loop_break
+-    end
+-    echo Reserved
+-    loop_break
+-  end
+-end  
+-
+-# IA32 2007, Volume 3A, Table 3-1
+-set $STA_X = 0x8
+-set $STA_E = 0x4
+-set $STA_C = 0x4
+-set $STA_W = 0x2
+-set $STA_R = 0x2
+-set $STA_A = 0x1
+-
+-define outputsta
+-  if $arg0 & $STA_X
+-    # Code segment
+-    echo code
+-    if $arg0 & $STA_C
+-      echo |STA_C
+-    end
+-    if $arg0 & $STA_R
+-      echo |STA_R
+-    end
+-  else
+-    # Data segment
+-    echo data
+-    if $arg0 & $STA_E
+-      echo |STA_E
+-    end
+-    if $arg0 & $STA_W
+-      echo |STA_W
+-    end
+-  end
+-  if $arg0 & $STA_A
+-    echo |STA_A
+-  else
+-    printf "      "
+-  end
+-end
+-
+-# xv6-specific
+-set $SEG_KCODE = 1
+-set $SEG_KDATA = 2
+-set $SEG_KCPU  = 3
+-set $SEG_UCODE = 4
+-set $SEG_UDATA = 5
+-set $SEG_TSS   = 6
+-
+-define outputcs
+-  if ($arg0 & 4) == 0
+-    if $arg0 >> 3 == $SEG_KCODE
+-      printf "SEG_KCODE<<3"
+-    end
+-    if $arg0 >> 3 == $SEG_KDATA
+-      printf "SEG_KDATA<<3"
+-    end
+-    if $arg0 >> 3 == $SEG_KCPU
+-      printf "SEG_KCPU<<3"
+-    end
+-    if $arg0 >> 3 == $SEG_UCODE
+-      printf "SEG_UCODE<<3"
+-    end
+-    if $arg0 >> 3 == $SEG_UDATA
+-      printf "SEG_UDATA<<3"
+-    end
+-    if $arg0 >> 3 == $SEG_TSS
+-      printf "SEG_TSS<<3"
+-    end
+-    if ($arg0 >> 3 < 1) + ($arg0 >> 3 > 6)
+-      printf "GDT[%d]", $arg0 >> 3
+-    end
+-  else
+-    printf "LDT[%d]", $arg0 >> 3
+-  end
+-  if ($arg0 & 3) > 0
+-    printf "|"
+-    outputdpl ($arg0&3)
+-  end
+-end
+-
+-define outputdpl
+-  if $arg0 == 0
+-    printf "DPL_KERN"
+-  else
+-    if $arg0 == 3
+-      printf "DPL_USER"
+-    else
+-      printf "DPL%d", $arg0
+-    end
+-  end
+-end
+-
+-define printdesc
+-  if $argc != 1
+-    echo Usage: printdesc expr
+-  else
+-    _printdesc ((uint*)&($arg0))[0] ((uint*)&($arg0))[1]
+-    printf "\n"
+-  end
+-end
+-
+-document printdesc
+-Print an x86 segment or gate descriptor.
+-printdesc EXPR
+-EXPR must evaluate to a descriptor value.  It can be of any C type.
+-end
+-
+-define _printdesc
+-  _printdesc1 $arg0 $arg1 ($arg1>>15&1) ($arg1>>13&3) ($arg1>>12&1) ($arg1>>8&15)
+-end
+-
+-define _printdesc1
+-  # 2:P 3:DPL 4:S 5:Type
+-  if $arg2 == 0
+-    printf "P = 0 (Not present)"
+-  else
+-    printf "type = "
+-    if $arg4 == 0
+-      # System segment
+-      outputsts $arg5
+-      printf " (0x%x)    ", $arg5
+-      _printsysdesc $arg0 $arg1 $arg5
+-    else
+-      # Code/data segment
+-      outputsta $arg5
+-      printf "  "
+-      _printsegdesc $arg0 $arg1
+-    end
+-
+-    printf "  DPL = "
+-    outputdpl $arg3
+-    printf " (%d)", $arg3
+-  end
+-end
+-
+-define _printsysdesc
+-  # 2:Type
+-  # GDB's || is buggy
+-  if ($arg2 == $STS_TG) + (($arg2&7) == $STS_IG16) + (($arg2&7) == $STS_TG16)
+-    # Gate descriptor
+-    _printgate $arg2 ($arg0>>16) ($arg0&0xFFFF) ($arg1>>16)
+-  else
+-    # System segment descriptor
+-    _printsegdesc $arg0 $arg1
+-  end
+-end
+-
+-define _printgate
+-  # IA32 2007, Voume 3A, Figure 5-2
+-  # 0:Type 1:CS 2:Offset 15..0 3:Offset 31..16
+-  printf "CS = "
+-  outputcs $arg1
+-  printf " (%d)", $arg1
+-
+-  if (($arg0&7) == $STS_IG16) + (($arg0&7) == $STS_TG16)
+-    printf "  Offset = "
+-    output/a $arg3 << 16 | $arg2
+-  end
+-end
+-
+-define _printsegdesc
+-  # IA32 20007, Volume 3A, Figure 3-8 and Figure 4-1
+-  _printsegdesc1 ($arg0>>16) ($arg1&0xFF) ($arg1>>24) ($arg0&0xFFFF) ($arg1>>16&15) ($arg1>>23&1)
+-  if ($arg1>>12&1) == 1
+-    printf "  AVL = %d", $arg1>>20&1
+-    if ($arg1>>11&1) == 0
+-      # Data segment
+-      if ($arg1>>22&1) == 0
+-        printf "  B = small (0) "
+-      else
+-        printf "  B = big (1)   "
+-      end
+-    else
+-      # Code segment
+-      printf "  D = "
+-      if ($arg1>>22&1) == 0
+-        printf "16-bit (0)"
+-      else
+-        printf "32-bit (1)"
+-      end
+-    end
+-  end
+-end
+-
+-define _printsegdesc1
+-  # 0:Base 0..15  1:Base 16..23  2:Base 24..32  3:Limit 0..15  4:Limit 16..19  5:G
+-  printf "base = 0x%08x", $arg0 | ($arg1<<16) | ($arg2<<24)
+-  printf "  limit = 0x"
+-  if $arg5 == 0
+-    printf "%08x", $arg3 | ($arg4<<16)
+-  else
+-    printf "%08x", (($arg3 | ($arg4<<16)) << 12) | 0xFFF
+-  end
+-end
+-
+-define printdescs
+-  if $argc < 1 || $argc > 2
+-    echo Usage: printdescs expr [count]
+-  else
+-    if $argc == 1
+-      _printdescs ($arg0) (sizeof($arg0)/sizeof(($arg0)[0]))
+-    else
+-      _printdescs ($arg0) ($arg1)
+-    end
+-  end
+-end
+-
+-document printdescs
+-Print an array of x86 segment or gate descriptors.
+-printdescs EXPR [COUNT]
+-EXPR must evaluate to an array of descriptors.
+-end
+-
+-define _printdescs
+-  set $i = 0
+-  while $i < $arg1
+-    printf "[%d] ", $i
+-    printdesc $arg0[$i]
+-    set $i = $i + 1
+-  end
+-end
+diff --git a/grep.c b/grep.c
+deleted file mode 100644
+index 4be3256..0000000
+--- a/grep.c
++++ /dev/null
+@@ -1,107 +0,0 @@
+-// Simple grep.  Only supports ^ . * $ operators.
+-
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-char buf[1024];
+-int match(char*, char*);
+-
+-void
+-grep(char *pattern, int fd)
+-{
+-  int n, m;
+-  char *p, *q;
+-
+-  m = 0;
+-  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+-    m += n;
+-    buf[m] = '\0';
+-    p = buf;
+-    while((q = strchr(p, '\n')) != 0){
+-      *q = 0;
+-      if(match(pattern, p)){
+-        *q = '\n';
+-        write(1, p, q+1 - p);
+-      }
+-      p = q+1;
+-    }
+-    if(p == buf)
+-      m = 0;
+-    if(m > 0){
+-      m -= p - buf;
+-      memmove(buf, p, m);
+-    }
+-  }
+-}
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int fd, i;
+-  char *pattern;
+-
+-  if(argc <= 1){
+-    printf(2, "usage: grep pattern [file ...]\n");
+-    exit(1);
+-  }
+-  pattern = argv[1];
+-
+-  if(argc <= 2){
+-    grep(pattern, 0);
+-    exit(2);
+-  }
+-
+-  for(i = 2; i < argc; i++){
+-    if((fd = open(argv[i], 0)) < 0){
+-      printf(1, "grep: cannot open %s\n", argv[i]);
+-      exit(3);
+-    }
+-    grep(pattern, fd);
+-    close(fd);
+-  }
+-  exit(0);
+-}
+-
+-// Regexp matcher from Kernighan & Pike,
+-// The Practice of Programming, Chapter 9.
+-
+-int matchhere(char*, char*);
+-int matchstar(int, char*, char*);
+-
+-int
+-match(char *re, char *text)
+-{
+-  if(re[0] == '^')
+-    return matchhere(re+1, text);
+-  do{  // must look at empty string
+-    if(matchhere(re, text))
+-      return 1;
+-  }while(*text++ != '\0');
+-  return 0;
+-}
+-
+-// matchhere: search for re at beginning of text
+-int matchhere(char *re, char *text)
+-{
+-  if(re[0] == '\0')
+-    return 1;
+-  if(re[1] == '*')
+-    return matchstar(re[0], re+2, text);
+-  if(re[0] == '$' && re[1] == '\0')
+-    return *text == '\0';
+-  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+-    return matchhere(re+1, text+1);
+-  return 0;
+-}
+-
+-// matchstar: search for c*re at beginning of text
+-int matchstar(int c, char *re, char *text)
+-{
+-  do{  // a * matches zero or more instances
+-    if(matchhere(re, text))
+-      return 1;
+-  }while(*text!='\0' && (*text++==c || c=='.'));
+-  return 0;
+-}
+-
+diff --git a/ide.c b/ide.c
+deleted file mode 100644
+index b4c0b1f..0000000
+--- a/ide.c
++++ /dev/null
+@@ -1,168 +0,0 @@
+-// Simple PIO-based (non-DMA) IDE driver code.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-#include "traps.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "buf.h"
+-
+-#define SECTOR_SIZE   512
+-#define IDE_BSY       0x80
+-#define IDE_DRDY      0x40
+-#define IDE_DF        0x20
+-#define IDE_ERR       0x01
+-
+-#define IDE_CMD_READ  0x20
+-#define IDE_CMD_WRITE 0x30
+-#define IDE_CMD_RDMUL 0xc4
+-#define IDE_CMD_WRMUL 0xc5
+-
+-// idequeue points to the buf now being read/written to the disk.
+-// idequeue->qnext points to the next buf to be processed.
+-// You must hold idelock while manipulating queue.
+-
+-static struct spinlock idelock;
+-static struct buf *idequeue;
+-
+-static int havedisk1;
+-static void idestart(struct buf*);
+-
+-// Wait for IDE disk to become ready.
+-static int
+-idewait(int checkerr)
+-{
+-  int r;
+-
+-  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+-    ;
+-  if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
+-    return -1;
+-  return 0;
+-}
+-
+-void
+-ideinit(void)
+-{
+-  int i;
+-
+-  initlock(&idelock, "ide");
+-  ioapicenable(IRQ_IDE, ncpu - 1);
+-  idewait(0);
+-
+-  // Check if disk 1 is present
+-  outb(0x1f6, 0xe0 | (1<<4));
+-  for(i=0; i<1000; i++){
+-    if(inb(0x1f7) != 0){
+-      havedisk1 = 1;
+-      break;
+-    }
+-  }
+-
+-  // Switch back to disk 0.
+-  outb(0x1f6, 0xe0 | (0<<4));
+-}
+-
+-// Start the request for b.  Caller must hold idelock.
+-static void
+-idestart(struct buf *b)
+-{
+-  if(b == 0)
+-    panic("idestart");
+-  if(b->blockno >= FSSIZE)
+-    panic("incorrect blockno");
+-  int sector_per_block =  BSIZE/SECTOR_SIZE;
+-  int sector = b->blockno * sector_per_block;
+-  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
+-  int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
+-
+-  if (sector_per_block > 7) panic("idestart");
+-
+-  idewait(0);
+-  outb(0x3f6, 0);  // generate interrupt
+-  outb(0x1f2, sector_per_block);  // number of sectors
+-  outb(0x1f3, sector & 0xff);
+-  outb(0x1f4, (sector >> 8) & 0xff);
+-  outb(0x1f5, (sector >> 16) & 0xff);
+-  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
+-  if(b->flags & B_DIRTY){
+-    outb(0x1f7, write_cmd);
+-    outsl(0x1f0, b->data, BSIZE/4);
+-  } else {
+-    outb(0x1f7, read_cmd);
+-  }
+-}
+-
+-// Interrupt handler.
+-void
+-ideintr(void)
+-{
+-  struct buf *b;
+-
+-  // First queued buffer is the active request.
+-  acquire(&idelock);
+-
+-  if((b = idequeue) == 0){
+-    release(&idelock);
+-    return;
+-  }
+-  idequeue = b->qnext;
+-
+-  // Read data if needed.
+-  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
+-    insl(0x1f0, b->data, BSIZE/4);
+-
+-  // Wake process waiting for this buf.
+-  b->flags |= B_VALID;
+-  b->flags &= ~B_DIRTY;
+-  wakeup(b);
+-
+-  // Start disk on next buf in queue.
+-  if(idequeue != 0)
+-    idestart(idequeue);
+-
+-  release(&idelock);
+-}
+-
+-//PAGEBREAK!
+-// Sync buf with disk.
+-// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+-// Else if B_VALID is not set, read buf from disk, set B_VALID.
+-void
+-iderw(struct buf *b)
+-{
+-  struct buf **pp;
+-
+-  if(!holdingsleep(&b->lock))
+-    panic("iderw: buf not locked");
+-  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+-    panic("iderw: nothing to do");
+-  if(b->dev != 0 && !havedisk1)
+-    panic("iderw: ide disk 1 not present");
+-
+-  acquire(&idelock);  //DOC:acquire-lock
+-
+-  // Append b to idequeue.
+-  b->qnext = 0;
+-  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+-    ;
+-  *pp = b;
+-
+-  // Start disk if necessary.
+-  if(idequeue == b)
+-    idestart(b);
+-
+-  // Wait for request to finish.
+-  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+-    sleep(b, &idelock);
+-  }
+-
+-
+-  release(&idelock);
+-}
+diff --git a/init.c b/init.c
+deleted file mode 100644
+index bc6547f..0000000
+--- a/init.c
++++ /dev/null
+@@ -1,37 +0,0 @@
+-// init: The initial user-level program
+-
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-#include "fcntl.h"
+-
+-char *argv[] = { "sh", 0 };
+-
+-int
+-main(void)
+-{
+-  int pid, wpid;
+-
+-  if(open("console", O_RDWR) < 0){
+-    mknod("console", 1, 1);
+-    open("console", O_RDWR);
+-  }
+-  dup(0);  // stdout
+-  dup(0);  // stderr
+-
+-  for(;;){
+-    printf(1, "init: starting sh\n");
+-    pid = fork();
+-    if(pid < 0){
+-      printf(1, "init: fork failed\n");
+-      exit(2);
+-    }
+-    if(pid == 0){
+-      exec("sh", argv);
+-      printf(1, "init: exec sh failed\n");
+-      exit(1);
+-    }
+-    while((wpid=wait(NULL)) >= 0 && wpid != pid)
+-      printf(1, "zombie!\n");
+-  }
+-}
+diff --git a/initcode.S b/initcode.S
+deleted file mode 100644
+index 80ac5d8..0000000
+--- a/initcode.S
++++ /dev/null
+@@ -1,32 +0,0 @@
+-# Initial process execs /init.
+-# This code runs in user space.
+-
+-#include "syscall.h"
+-#include "traps.h"
+-
+-
+-# exec(init, argv)
+-.globl start
+-start:
+-  pushl $argv
+-  pushl $init
+-  pushl $0  // where caller pc would be
+-  movl $SYS_exec, %eax
+-  int $T_SYSCALL
+-
+-# for(;;) exit();
+-exit:
+-  movl $SYS_exit, %eax
+-  int $T_SYSCALL
+-  jmp exit
+-
+-# char init[] = "/init\0";
+-init:
+-  .string "/init\0"
+-
+-# char *argv[] = { init, 0 };
+-.p2align 2
+-argv:
+-  .long init
+-  .long 0
+-
+diff --git a/ioapic.c b/ioapic.c
+deleted file mode 100644
+index cb0f015..0000000
+--- a/ioapic.c
++++ /dev/null
+@@ -1,75 +0,0 @@
+-// The I/O APIC manages hardware interrupts for an SMP system.
+-// http://www.intel.com/design/chipsets/datashts/29056601.pdf
+-// See also picirq.c.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "traps.h"
+-
+-#define IOAPIC  0xFEC00000   // Default physical address of IO APIC
+-
+-#define REG_ID     0x00  // Register index: ID
+-#define REG_VER    0x01  // Register index: version
+-#define REG_TABLE  0x10  // Redirection table base
+-
+-// The redirection table starts at REG_TABLE and uses
+-// two registers to configure each interrupt.
+-// The first (low) register in a pair contains configuration bits.
+-// The second (high) register contains a bitmask telling which
+-// CPUs can serve that interrupt.
+-#define INT_DISABLED   0x00010000  // Interrupt disabled
+-#define INT_LEVEL      0x00008000  // Level-triggered (vs edge-)
+-#define INT_ACTIVELOW  0x00002000  // Active low (vs high)
+-#define INT_LOGICAL    0x00000800  // Destination is CPU id (vs APIC ID)
+-
+-volatile struct ioapic *ioapic;
+-
+-// IO APIC MMIO structure: write reg, then read or write data.
+-struct ioapic {
+-  uint reg;
+-  uint pad[3];
+-  uint data;
+-};
+-
+-static uint
+-ioapicread(int reg)
+-{
+-  ioapic->reg = reg;
+-  return ioapic->data;
+-}
+-
+-static void
+-ioapicwrite(int reg, uint data)
+-{
+-  ioapic->reg = reg;
+-  ioapic->data = data;
+-}
+-
+-void
+-ioapicinit(void)
+-{
+-  int i, id, maxintr;
+-
+-  ioapic = (volatile struct ioapic*)IOAPIC;
+-  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
+-  id = ioapicread(REG_ID) >> 24;
+-  if(id != ioapicid)
+-    cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
+-
+-  // Mark all interrupts edge-triggered, active high, disabled,
+-  // and not routed to any CPUs.
+-  for(i = 0; i <= maxintr; i++){
+-    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
+-    ioapicwrite(REG_TABLE+2*i+1, 0);
+-  }
+-}
+-
+-void
+-ioapicenable(int irq, int cpunum)
+-{
+-  // Mark interrupt edge-triggered, active high,
+-  // enabled, and routed to the given cpunum,
+-  // which happens to be that cpu's APIC ID.
+-  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
+-  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
+-}
+diff --git a/kalloc.c b/kalloc.c
+deleted file mode 100644
+index 14cd4f4..0000000
+--- a/kalloc.c
++++ /dev/null
+@@ -1,96 +0,0 @@
+-// Physical memory allocator, intended to allocate
+-// memory for user processes, kernel stacks, page table pages,
+-// and pipe buffers. Allocates 4096-byte pages.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "spinlock.h"
+-
+-void freerange(void *vstart, void *vend);
+-extern char end[]; // first address after kernel loaded from ELF file
+-                   // defined by the kernel linker script in kernel.ld
+-
+-struct run {
+-  struct run *next;
+-};
+-
+-struct {
+-  struct spinlock lock;
+-  int use_lock;
+-  struct run *freelist;
+-} kmem;
+-
+-// Initialization happens in two phases.
+-// 1. main() calls kinit1() while still using entrypgdir to place just
+-// the pages mapped by entrypgdir on free list.
+-// 2. main() calls kinit2() with the rest of the physical pages
+-// after installing a full page table that maps them on all cores.
+-void
+-kinit1(void *vstart, void *vend)
+-{
+-  initlock(&kmem.lock, "kmem");
+-  kmem.use_lock = 0;
+-  freerange(vstart, vend);
+-}
+-
+-void
+-kinit2(void *vstart, void *vend)
+-{
+-  freerange(vstart, vend);
+-  kmem.use_lock = 1;
+-}
+-
+-void
+-freerange(void *vstart, void *vend)
+-{
+-  char *p;
+-  p = (char*)PGROUNDUP((uint)vstart);
+-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+-    kfree(p);
+-}
+-//PAGEBREAK: 21
+-// Free the page of physical memory pointed at by v,
+-// which normally should have been returned by a
+-// call to kalloc().  (The exception is when
+-// initializing the allocator; see kinit above.)
+-void
+-kfree(char *v)
+-{
+-  struct run *r;
+-
+-  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
+-    panic("kfree");
+-
+-  // Fill with junk to catch dangling refs.
+-  memset(v, 1, PGSIZE);
+-
+-  if(kmem.use_lock)
+-    acquire(&kmem.lock);
+-  r = (struct run*)v;
+-  r->next = kmem.freelist;
+-  kmem.freelist = r;
+-  if(kmem.use_lock)
+-    release(&kmem.lock);
+-}
+-
+-// Allocate one 4096-byte page of physical memory.
+-// Returns a pointer that the kernel can use.
+-// Returns 0 if the memory cannot be allocated.
+-char*
+-kalloc(void)
+-{
+-  struct run *r;
+-
+-  if(kmem.use_lock)
+-    acquire(&kmem.lock);
+-  r = kmem.freelist;
+-  if(r)
+-    kmem.freelist = r->next;
+-  if(kmem.use_lock)
+-    release(&kmem.lock);
+-  return (char*)r;
+-}
+-
+diff --git a/kbd.c b/kbd.c
+deleted file mode 100644
+index 32c1463..0000000
+--- a/kbd.c
++++ /dev/null
+@@ -1,50 +0,0 @@
+-#include "types.h"
+-#include "x86.h"
+-#include "defs.h"
+-#include "kbd.h"
+-
+-int
+-kbdgetc(void)
+-{
+-  static uint shift;
+-  static uchar *charcode[4] = {
+-    normalmap, shiftmap, ctlmap, ctlmap
+-  };
+-  uint st, data, c;
+-
+-  st = inb(KBSTATP);
+-  if((st & KBS_DIB) == 0)
+-    return -1;
+-  data = inb(KBDATAP);
+-
+-  if(data == 0xE0){
+-    shift |= E0ESC;
+-    return 0;
+-  } else if(data & 0x80){
+-    // Key released
+-    data = (shift & E0ESC ? data : data & 0x7F);
+-    shift &= ~(shiftcode[data] | E0ESC);
+-    return 0;
+-  } else if(shift & E0ESC){
+-    // Last character was an E0 escape; or with 0x80
+-    data |= 0x80;
+-    shift &= ~E0ESC;
+-  }
+-
+-  shift |= shiftcode[data];
+-  shift ^= togglecode[data];
+-  c = charcode[shift & (CTL | SHIFT)][data];
+-  if(shift & CAPSLOCK){
+-    if('a' <= c && c <= 'z')
+-      c += 'A' - 'a';
+-    else if('A' <= c && c <= 'Z')
+-      c += 'a' - 'A';
+-  }
+-  return c;
+-}
+-
+-void
+-kbdintr(void)
+-{
+-  consoleintr(kbdgetc);
+-}
+diff --git a/kbd.h b/kbd.h
+deleted file mode 100644
+index babbd6e..0000000
+--- a/kbd.h
++++ /dev/null
+@@ -1,112 +0,0 @@
+-// PC keyboard interface constants
+-
+-#define KBSTATP         0x64    // kbd controller status port(I)
+-#define KBS_DIB         0x01    // kbd data in buffer
+-#define KBDATAP         0x60    // kbd data port(I)
+-
+-#define NO              0
+-
+-#define SHIFT           (1<<0)
+-#define CTL             (1<<1)
+-#define ALT             (1<<2)
+-
+-#define CAPSLOCK        (1<<3)
+-#define NUMLOCK         (1<<4)
+-#define SCROLLLOCK      (1<<5)
+-
+-#define E0ESC           (1<<6)
+-
+-// Special keycodes
+-#define KEY_HOME        0xE0
+-#define KEY_END         0xE1
+-#define KEY_UP          0xE2
+-#define KEY_DN          0xE3
+-#define KEY_LF          0xE4
+-#define KEY_RT          0xE5
+-#define KEY_PGUP        0xE6
+-#define KEY_PGDN        0xE7
+-#define KEY_INS         0xE8
+-#define KEY_DEL         0xE9
+-
+-// C('A') == Control-A
+-#define C(x) (x - '@')
+-
+-static uchar shiftcode[256] =
+-{
+-  [0x1D] CTL,
+-  [0x2A] SHIFT,
+-  [0x36] SHIFT,
+-  [0x38] ALT,
+-  [0x9D] CTL,
+-  [0xB8] ALT
+-};
+-
+-static uchar togglecode[256] =
+-{
+-  [0x3A] CAPSLOCK,
+-  [0x45] NUMLOCK,
+-  [0x46] SCROLLLOCK
+-};
+-
+-static uchar normalmap[256] =
+-{
+-  NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  // 0x00
+-  '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
+-  'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  // 0x10
+-  'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
+-  'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  // 0x20
+-  '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
+-  'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  // 0x30
+-  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+-  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
+-  [0x9C] '\n',      // KP_Enter
+-  [0xB5] '/',       // KP_Div
+-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
+-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
+-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
+-  [0x97] KEY_HOME,  [0xCF] KEY_END,
+-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
+-};
+-
+-static uchar shiftmap[256] =
+-{
+-  NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  // 0x00
+-  '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
+-  'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  // 0x10
+-  'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
+-  'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  // 0x20
+-  '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
+-  'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  // 0x30
+-  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+-  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
+-  [0x9C] '\n',      // KP_Enter
+-  [0xB5] '/',       // KP_Div
+-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
+-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
+-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
+-  [0x97] KEY_HOME,  [0xCF] KEY_END,
+-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
+-};
+-
+-static uchar ctlmap[256] =
+-{
+-  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+-  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+-  C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
+-  C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
+-  C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
+-  NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
+-  C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
+-  [0x9C] '\r',      // KP_Enter
+-  [0xB5] C('/'),    // KP_Div
+-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
+-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
+-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
+-  [0x97] KEY_HOME,  [0xCF] KEY_END,
+-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
+-};
+-
+diff --git a/kernel.ld b/kernel.ld
+deleted file mode 100644
+index 4e12e14..0000000
+--- a/kernel.ld
++++ /dev/null
+@@ -1,64 +0,0 @@
+-/* Simple linker script for the JOS kernel.
+-   See the GNU ld 'info' manual ("info ld") to learn the syntax. */
+-
+-OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+-OUTPUT_ARCH(i386)
+-ENTRY(_start)
+-
+-SECTIONS
+-{
+-	/* Link the kernel at this address: "." means the current address */
+-        /* Must be equal to KERNLINK */
+-	. = 0x80100000;
+-
+-	.text : AT(0x100000) {
+-		*(.text .stub .text.* .gnu.linkonce.t.*)
+-	}
+-
+-	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
+-
+-	.rodata : {
+-		*(.rodata .rodata.* .gnu.linkonce.r.*)
+-	}
+-
+-	/* Include debugging information in kernel memory */
+-	.stab : {
+-		PROVIDE(__STAB_BEGIN__ = .);
+-		*(.stab);
+-		PROVIDE(__STAB_END__ = .);
+-	}
+-
+-	.stabstr : {
+-		PROVIDE(__STABSTR_BEGIN__ = .);
+-		*(.stabstr);
+-		PROVIDE(__STABSTR_END__ = .);
+-	}
+-
+-	/* Adjust the address for the data segment to the next page */
+-	. = ALIGN(0x1000);
+-
+-	/* Conventionally, Unix linkers provide pseudo-symbols
+-	 * etext, edata, and end, at the end of the text, data, and bss.
+-	 * For the kernel mapping, we need the address at the beginning
+-	 * of the data section, but that's not one of the conventional
+-	 * symbols, because the convention started before there was a
+-	 * read-only rodata section between text and data. */
+-	PROVIDE(data = .);
+-
+-	/* The data segment */
+-	.data : {
+-		*(.data)
+-	}
+-
+-	PROVIDE(edata = .);
+-
+-	.bss : {
+-		*(.bss)
+-	}
+-
+-	PROVIDE(end = .);
+-
+-	/DISCARD/ : {
+-		*(.eh_frame .note.GNU-stack)
+-	}
+-}
+diff --git a/kill.c b/kill.c
+deleted file mode 100644
+index 875916c..0000000
+--- a/kill.c
++++ /dev/null
+@@ -1,17 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-int
+-main(int argc, char **argv)
+-{
+-  int i;
+-
+-  if(argc < 2){
+-    printf(2, "usage: kill pid...\n");
+-    exit(1);
+-  }
+-  for(i=1; i<argc; i++)
+-    kill(atoi(argv[i]));
+-  exit(0);
+-}
+diff --git a/lab1.c b/lab3.c
+similarity index 50%
+rename from lab1.c
+rename to lab3.c
+index 2192a52..7cf6b00 100644
+--- a/lab1.c
++++ b/lab3.c
+@@ -16,54 +16,11 @@
+ #include "types.h"
+ #include "user.h"
+ 
+-int main(int argc, char **argv) {
++int main(int argc, char *argv[]) {
+ 
+-    int pid;
++    int v = argc;
+ 
+-    pid = fork();
+-
+-    if(pid > 0)
+-    {
+-        waitpid(pid, NULL, 0);
+-        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
+-        exit(0);
+-    }
+-
+-
+-    pid = fork();
+-
+-    if(pid == 0)
+-    {
+-        printf(1, "I'm the child! PID: %d\n", pid);
+-    }
+-    else
+-    {
+-        printf(1, "I'm the parent! PID: %d\n", pid);
+-        waitpid(pid, NULL, 0);
+-
+-    }
+-
+-
+-    exit(0);
++    printf(1, "%d",sizeof(*argv) / sizeof(*argv[0]));
++    printf(1, "%p\n", &v);
++    exit();
+ }
+-//    printf(1, "Waitpid Demo Initializing...\n"); // fd=1 means standard output.
+-//
+-//    int defValue = -1;
+-//    int* status = &defValue;
+-//
+-//    int pid = fork();
+-//
+-//
+-//    if(pid > 0)
+-//    while(waitpid(pid, status, 0) == -1);
+-//
+-//    if(pid == 0)
+-//    {
+-//        printf(1, "hi im the child :)\n"); // fd=1 means standard output.
+-//        exit(0);
+-//    }
+-//
+-//    printf(1, "Exit status returned is: %d\n", *status); // fd=1 means standard output.
+-//
+-//    exit(0);
+-//}
+diff --git a/lab3p2.c b/lab3p2.c
+new file mode 100644
+index 0000000..f94207f
+--- /dev/null
++++ b/lab3p2.c
+@@ -0,0 +1,31 @@
++#include "types.h"
++#include "user.h"
++
++// Prevent this function from being optimized, which might give it closed form
++#pragma GCC push_options
++#pragma GCC optimize ("O0")
++static int
++recurse(int n)
++{
++    if(n == 0)
++        return 0;
++    return n + recurse(n - 1);
 +}
++#pragma GCC pop_options
 +
 +int
-+sys_waitpid(int pid, int* status, int options)
++main(int argc, char *argv[])
 +{
-+    return waitpid(pid, status, options);
- }
- 
- int
++    int n, m;
++
++    if(argc != 2){
++        printf(1, "Usage: %s levels\n", argv[0]);
++        exit();
++    }
++
++    n = atoi(argv[1]);
++    printf(1, "Lab 3: Recursing %d levels\n", n);
++    m = recurse(n);
++    printf(1, "Lab 3: Yielded a value of %d\n", m);
++    exit();
++}
+\ No newline at end of file
+diff --git a/lapic.c b/lapic.c
+deleted file mode 100644
+index b22bbd7..0000000
+--- a/lapic.c
++++ /dev/null
+@@ -1,229 +0,0 @@
+-// The local APIC manages internal (non-I/O) interrupts.
+-// See Chapter 8 & Appendix C of Intel processor manual volume 3.
+-
+-#include "param.h"
+-#include "types.h"
+-#include "defs.h"
+-#include "date.h"
+-#include "memlayout.h"
+-#include "traps.h"
+-#include "mmu.h"
+-#include "x86.h"
+-
+-// Local APIC registers, divided by 4 for use as uint[] indices.
+-#define ID      (0x0020/4)   // ID
+-#define VER     (0x0030/4)   // Version
+-#define TPR     (0x0080/4)   // Task Priority
+-#define EOI     (0x00B0/4)   // EOI
+-#define SVR     (0x00F0/4)   // Spurious Interrupt Vector
+-  #define ENABLE     0x00000100   // Unit Enable
+-#define ESR     (0x0280/4)   // Error Status
+-#define ICRLO   (0x0300/4)   // Interrupt Command
+-  #define INIT       0x00000500   // INIT/RESET
+-  #define STARTUP    0x00000600   // Startup IPI
+-  #define DELIVS     0x00001000   // Delivery status
+-  #define ASSERT     0x00004000   // Assert interrupt (vs deassert)
+-  #define DEASSERT   0x00000000
+-  #define LEVEL      0x00008000   // Level triggered
+-  #define BCAST      0x00080000   // Send to all APICs, including self.
+-  #define BUSY       0x00001000
+-  #define FIXED      0x00000000
+-#define ICRHI   (0x0310/4)   // Interrupt Command [63:32]
+-#define TIMER   (0x0320/4)   // Local Vector Table 0 (TIMER)
+-  #define X1         0x0000000B   // divide counts by 1
+-  #define PERIODIC   0x00020000   // Periodic
+-#define PCINT   (0x0340/4)   // Performance Counter LVT
+-#define LINT0   (0x0350/4)   // Local Vector Table 1 (LINT0)
+-#define LINT1   (0x0360/4)   // Local Vector Table 2 (LINT1)
+-#define ERROR   (0x0370/4)   // Local Vector Table 3 (ERROR)
+-  #define MASKED     0x00010000   // Interrupt masked
+-#define TICR    (0x0380/4)   // Timer Initial Count
+-#define TCCR    (0x0390/4)   // Timer Current Count
+-#define TDCR    (0x03E0/4)   // Timer Divide Configuration
+-
+-volatile uint *lapic;  // Initialized in mp.c
+-
+-//PAGEBREAK!
+-static void
+-lapicw(int index, int value)
+-{
+-  lapic[index] = value;
+-  lapic[ID];  // wait for write to finish, by reading
+-}
+-
+-void
+-lapicinit(void)
+-{
+-  if(!lapic)
+-    return;
+-
+-  // Enable local APIC; set spurious interrupt vector.
+-  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
+-
+-  // The timer repeatedly counts down at bus frequency
+-  // from lapic[TICR] and then issues an interrupt.
+-  // If xv6 cared more about precise timekeeping,
+-  // TICR would be calibrated using an external time source.
+-  lapicw(TDCR, X1);
+-  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
+-  lapicw(TICR, 10000000);
+-
+-  // Disable logical interrupt lines.
+-  lapicw(LINT0, MASKED);
+-  lapicw(LINT1, MASKED);
+-
+-  // Disable performance counter overflow interrupts
+-  // on machines that provide that interrupt entry.
+-  if(((lapic[VER]>>16) & 0xFF) >= 4)
+-    lapicw(PCINT, MASKED);
+-
+-  // Map error interrupt to IRQ_ERROR.
+-  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
+-
+-  // Clear error status register (requires back-to-back writes).
+-  lapicw(ESR, 0);
+-  lapicw(ESR, 0);
+-
+-  // Ack any outstanding interrupts.
+-  lapicw(EOI, 0);
+-
+-  // Send an Init Level De-Assert to synchronise arbitration ID's.
+-  lapicw(ICRHI, 0);
+-  lapicw(ICRLO, BCAST | INIT | LEVEL);
+-  while(lapic[ICRLO] & DELIVS)
+-    ;
+-
+-  // Enable interrupts on the APIC (but not on the processor).
+-  lapicw(TPR, 0);
+-}
+-
+-int
+-lapicid(void)
+-{
+-  if (!lapic)
+-    return 0;
+-  return lapic[ID] >> 24;
+-}
+-
+-// Acknowledge interrupt.
+-void
+-lapiceoi(void)
+-{
+-  if(lapic)
+-    lapicw(EOI, 0);
+-}
+-
+-// Spin for a given number of microseconds.
+-// On real hardware would want to tune this dynamically.
+-void
+-microdelay(int us)
+-{
+-}
+-
+-#define CMOS_PORT    0x70
+-#define CMOS_RETURN  0x71
+-
+-// Start additional processor running entry code at addr.
+-// See Appendix B of MultiProcessor Specification.
+-void
+-lapicstartap(uchar apicid, uint addr)
+-{
+-  int i;
+-  ushort *wrv;
+-
+-  // "The BSP must initialize CMOS shutdown code to 0AH
+-  // and the warm reset vector (DWORD based at 40:67) to point at
+-  // the AP startup code prior to the [universal startup algorithm]."
+-  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
+-  outb(CMOS_PORT+1, 0x0A);
+-  wrv = (ushort*)P2V((0x40<<4 | 0x67));  // Warm reset vector
+-  wrv[0] = 0;
+-  wrv[1] = addr >> 4;
+-
+-  // "Universal startup algorithm."
+-  // Send INIT (level-triggered) interrupt to reset other CPU.
+-  lapicw(ICRHI, apicid<<24);
+-  lapicw(ICRLO, INIT | LEVEL | ASSERT);
+-  microdelay(200);
+-  lapicw(ICRLO, INIT | LEVEL);
+-  microdelay(100);    // should be 10ms, but too slow in Bochs!
+-
+-  // Send startup IPI (twice!) to enter code.
+-  // Regular hardware is supposed to only accept a STARTUP
+-  // when it is in the halted state due to an INIT.  So the second
+-  // should be ignored, but it is part of the official Intel algorithm.
+-  // Bochs complains about the second one.  Too bad for Bochs.
+-  for(i = 0; i < 2; i++){
+-    lapicw(ICRHI, apicid<<24);
+-    lapicw(ICRLO, STARTUP | (addr>>12));
+-    microdelay(200);
+-  }
+-}
+-
+-#define CMOS_STATA   0x0a
+-#define CMOS_STATB   0x0b
+-#define CMOS_UIP    (1 << 7)        // RTC update in progress
+-
+-#define SECS    0x00
+-#define MINS    0x02
+-#define HOURS   0x04
+-#define DAY     0x07
+-#define MONTH   0x08
+-#define YEAR    0x09
+-
+-static uint
+-cmos_read(uint reg)
+-{
+-  outb(CMOS_PORT,  reg);
+-  microdelay(200);
+-
+-  return inb(CMOS_RETURN);
+-}
+-
+-static void
+-fill_rtcdate(struct rtcdate *r)
+-{
+-  r->second = cmos_read(SECS);
+-  r->minute = cmos_read(MINS);
+-  r->hour   = cmos_read(HOURS);
+-  r->day    = cmos_read(DAY);
+-  r->month  = cmos_read(MONTH);
+-  r->year   = cmos_read(YEAR);
+-}
+-
+-// qemu seems to use 24-hour GWT and the values are BCD encoded
+-void
+-cmostime(struct rtcdate *r)
+-{
+-  struct rtcdate t1, t2;
+-  int sb, bcd;
+-
+-  sb = cmos_read(CMOS_STATB);
+-
+-  bcd = (sb & (1 << 2)) == 0;
+-
+-  // make sure CMOS doesn't modify time while we read it
+-  for(;;) {
+-    fill_rtcdate(&t1);
+-    if(cmos_read(CMOS_STATA) & CMOS_UIP)
+-        continue;
+-    fill_rtcdate(&t2);
+-    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
+-      break;
+-  }
+-
+-  // convert
+-  if(bcd) {
+-#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
+-    CONV(second);
+-    CONV(minute);
+-    CONV(hour  );
+-    CONV(day   );
+-    CONV(month );
+-    CONV(year  );
+-#undef     CONV
+-  }
+-
+-  *r = t1;
+-  r->year += 2000;
+-}
+diff --git a/ln.c b/ln.c
+deleted file mode 100644
+index fb17c3b..0000000
+--- a/ln.c
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  if(argc != 3){
+-    printf(2, "Usage: ln old new\n");
+-    exit(1);
+-  }
+-  if(link(argv[1], argv[2]) < 0)
+-    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+-  exit(0);
+-}
+diff --git a/log.c b/log.c
+deleted file mode 100644
+index a64c0f6..0000000
+--- a/log.c
++++ /dev/null
+@@ -1,234 +0,0 @@
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "buf.h"
+-
+-// Simple logging that allows concurrent FS system calls.
+-//
+-// A log transaction contains the updates of multiple FS system
+-// calls. The logging system only commits when there are
+-// no FS system calls active. Thus there is never
+-// any reasoning required about whether a commit might
+-// write an uncommitted system call's updates to disk.
+-//
+-// A system call should call begin_op()/end_op() to mark
+-// its start and end. Usually begin_op() just increments
+-// the count of in-progress FS system calls and returns.
+-// But if it thinks the log is close to running out, it
+-// sleeps until the last outstanding end_op() commits.
+-//
+-// The log is a physical re-do log containing disk blocks.
+-// The on-disk log format:
+-//   header block, containing block #s for block A, B, C, ...
+-//   block A
+-//   block B
+-//   block C
+-//   ...
+-// Log appends are synchronous.
+-
+-// Contents of the header block, used for both the on-disk header block
+-// and to keep track in memory of logged block# before commit.
+-struct logheader {
+-  int n;
+-  int block[LOGSIZE];
+-};
+-
+-struct log {
+-  struct spinlock lock;
+-  int start;
+-  int size;
+-  int outstanding; // how many FS sys calls are executing.
+-  int committing;  // in commit(), please wait.
+-  int dev;
+-  struct logheader lh;
+-};
+-struct log log;
+-
+-static void recover_from_log(void);
+-static void commit();
+-
+-void
+-initlog(int dev)
+-{
+-  if (sizeof(struct logheader) >= BSIZE)
+-    panic("initlog: too big logheader");
+-
+-  struct superblock sb;
+-  initlock(&log.lock, "log");
+-  readsb(dev, &sb);
+-  log.start = sb.logstart;
+-  log.size = sb.nlog;
+-  log.dev = dev;
+-  recover_from_log();
+-}
+-
+-// Copy committed blocks from log to their home location
+-static void
+-install_trans(void)
+-{
+-  int tail;
+-
+-  for (tail = 0; tail < log.lh.n; tail++) {
+-    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
+-    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+-    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+-    bwrite(dbuf);  // write dst to disk
+-    brelse(lbuf);
+-    brelse(dbuf);
+-  }
+-}
+-
+-// Read the log header from disk into the in-memory log header
+-static void
+-read_head(void)
+-{
+-  struct buf *buf = bread(log.dev, log.start);
+-  struct logheader *lh = (struct logheader *) (buf->data);
+-  int i;
+-  log.lh.n = lh->n;
+-  for (i = 0; i < log.lh.n; i++) {
+-    log.lh.block[i] = lh->block[i];
+-  }
+-  brelse(buf);
+-}
+-
+-// Write in-memory log header to disk.
+-// This is the true point at which the
+-// current transaction commits.
+-static void
+-write_head(void)
+-{
+-  struct buf *buf = bread(log.dev, log.start);
+-  struct logheader *hb = (struct logheader *) (buf->data);
+-  int i;
+-  hb->n = log.lh.n;
+-  for (i = 0; i < log.lh.n; i++) {
+-    hb->block[i] = log.lh.block[i];
+-  }
+-  bwrite(buf);
+-  brelse(buf);
+-}
+-
+-static void
+-recover_from_log(void)
+-{
+-  read_head();
+-  install_trans(); // if committed, copy from log to disk
+-  log.lh.n = 0;
+-  write_head(); // clear the log
+-}
+-
+-// called at the start of each FS system call.
+-void
+-begin_op(void)
+-{
+-  acquire(&log.lock);
+-  while(1){
+-    if(log.committing){
+-      sleep(&log, &log.lock);
+-    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
+-      // this op might exhaust log space; wait for commit.
+-      sleep(&log, &log.lock);
+-    } else {
+-      log.outstanding += 1;
+-      release(&log.lock);
+-      break;
+-    }
+-  }
+-}
+-
+-// called at the end of each FS system call.
+-// commits if this was the last outstanding operation.
+-void
+-end_op(void)
+-{
+-  int do_commit = 0;
+-
+-  acquire(&log.lock);
+-  log.outstanding -= 1;
+-  if(log.committing)
+-    panic("log.committing");
+-  if(log.outstanding == 0){
+-    do_commit = 1;
+-    log.committing = 1;
+-  } else {
+-    // begin_op() may be waiting for log space,
+-    // and decrementing log.outstanding has decreased
+-    // the amount of reserved space.
+-    wakeup(&log);
+-  }
+-  release(&log.lock);
+-
+-  if(do_commit){
+-    // call commit w/o holding locks, since not allowed
+-    // to sleep with locks.
+-    commit();
+-    acquire(&log.lock);
+-    log.committing = 0;
+-    wakeup(&log);
+-    release(&log.lock);
+-  }
+-}
+-
+-// Copy modified blocks from cache to log.
+-static void
+-write_log(void)
+-{
+-  int tail;
+-
+-  for (tail = 0; tail < log.lh.n; tail++) {
+-    struct buf *to = bread(log.dev, log.start+tail+1); // log block
+-    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+-    memmove(to->data, from->data, BSIZE);
+-    bwrite(to);  // write the log
+-    brelse(from);
+-    brelse(to);
+-  }
+-}
+-
+-static void
+-commit()
+-{
+-  if (log.lh.n > 0) {
+-    write_log();     // Write modified blocks from cache to log
+-    write_head();    // Write header to disk -- the real commit
+-    install_trans(); // Now install writes to home locations
+-    log.lh.n = 0;
+-    write_head();    // Erase the transaction from the log
+-  }
+-}
+-
+-// Caller has modified b->data and is done with the buffer.
+-// Record the block number and pin in the cache with B_DIRTY.
+-// commit()/write_log() will do the disk write.
+-//
+-// log_write() replaces bwrite(); a typical use is:
+-//   bp = bread(...)
+-//   modify bp->data[]
+-//   log_write(bp)
+-//   brelse(bp)
+-void
+-log_write(struct buf *b)
+-{
+-  int i;
+-
+-  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+-    panic("too big a transaction");
+-  if (log.outstanding < 1)
+-    panic("log_write outside of trans");
+-
+-  acquire(&log.lock);
+-  for (i = 0; i < log.lh.n; i++) {
+-    if (log.lh.block[i] == b->blockno)   // log absorbtion
+-      break;
+-  }
+-  log.lh.block[i] = b->blockno;
+-  if (i == log.lh.n)
+-    log.lh.n++;
+-  b->flags |= B_DIRTY; // prevent eviction
+-  release(&log.lock);
+-}
+-
+diff --git a/ls.c b/ls.c
+deleted file mode 100644
+index 6bf943b..0000000
+--- a/ls.c
++++ /dev/null
+@@ -1,85 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-#include "fs.h"
+-
+-char*
+-fmtname(char *path)
+-{
+-  static char buf[DIRSIZ+1];
+-  char *p;
+-
+-  // Find first character after last slash.
+-  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+-    ;
+-  p++;
+-
+-  // Return blank-padded name.
+-  if(strlen(p) >= DIRSIZ)
+-    return p;
+-  memmove(buf, p, strlen(p));
+-  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+-  return buf;
+-}
+-
+-void
+-ls(char *path)
+-{
+-  char buf[512], *p;
+-  int fd;
+-  struct dirent de;
+-  struct stat st;
+-
+-  if((fd = open(path, 0)) < 0){
+-    printf(2, "ls: cannot open %s\n", path);
+-    return;
+-  }
+-
+-  if(fstat(fd, &st) < 0){
+-    printf(2, "ls: cannot stat %s\n", path);
+-    close(fd);
+-    return;
+-  }
+-
+-  switch(st.type){
+-  case T_FILE:
+-    printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
+-    break;
+-
+-  case T_DIR:
+-    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+-      printf(1, "ls: path too long\n");
+-      break;
+-    }
+-    strcpy(buf, path);
+-    p = buf+strlen(buf);
+-    *p++ = '/';
+-    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+-      if(de.inum == 0)
+-        continue;
+-      memmove(p, de.name, DIRSIZ);
+-      p[DIRSIZ] = 0;
+-      if(stat(buf, &st) < 0){
+-        printf(1, "ls: cannot stat %s\n", buf);
+-        continue;
+-      }
+-      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
+-    }
+-    break;
+-  }
+-  close(fd);
+-}
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int i;
+-
+-  if(argc < 2){
+-    ls(".");
+-    exit(1);
+-  }
+-  for(i=1; i<argc; i++)
+-    ls(argv[i]);
+-  exit(0);
+-}
+diff --git a/main.c b/main.c
+deleted file mode 100644
+index 9924e64..0000000
+--- a/main.c
++++ /dev/null
+@@ -1,116 +0,0 @@
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-
+-static void startothers(void);
+-static void mpmain(void)  __attribute__((noreturn));
+-extern pde_t *kpgdir;
+-extern char end[]; // first address after kernel loaded from ELF file
+-
+-// Bootstrap processor starts running C code here.
+-// Allocate a real stack and switch to it, first
+-// doing some setup required for memory allocator to work.
+-int
+-main(void)
+-{
+-  kinit1(end, P2V(4*1024*1024)); // phys page allocator
+-  kvmalloc();      // kernel page table
+-  mpinit();        // detect other processors
+-  lapicinit();     // interrupt controller
+-  seginit();       // segment descriptors
+-  picinit();       // disable pic
+-  ioapicinit();    // another interrupt controller
+-  consoleinit();   // console hardware
+-  uartinit();      // serial port
+-  pinit();         // process table
+-  tvinit();        // trap vectors
+-  binit();         // buffer cache
+-  fileinit();      // file table
+-  ideinit();       // disk 
+-  startothers();   // start other processors
+-  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+-  userinit();      // first user process
+-  mpmain();        // finish this processor's setup
+-}
+-
+-// Other CPUs jump here from entryother.S.
+-static void
+-mpenter(void)
+-{
+-  switchkvm();
+-  seginit();
+-  lapicinit();
+-  mpmain();
+-}
+-
+-// Common CPU setup code.
+-static void
+-mpmain(void)
+-{
+-  cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
+-  idtinit();       // load idt register
+-  xchg(&(mycpu()->started), 1); // tell startothers() we're up
+-  scheduler();     // start running processes
+-}
+-
+-pde_t entrypgdir[];  // For entry.S
+-
+-// Start the non-boot (AP) processors.
+-static void
+-startothers(void)
+-{
+-  extern uchar _binary_entryother_start[], _binary_entryother_size[];
+-  uchar *code;
+-  struct cpu *c;
+-  char *stack;
+-
+-  // Write entry code to unused memory at 0x7000.
+-  // The linker has placed the image of entryother.S in
+-  // _binary_entryother_start.
+-  code = P2V(0x7000);
+-  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+-
+-  for(c = cpus; c < cpus+ncpu; c++){
+-    if(c == mycpu())  // We've started already.
+-      continue;
+-
+-    // Tell entryother.S what stack to use, where to enter, and what
+-    // pgdir to use. We cannot use kpgdir yet, because the AP processor
+-    // is running in low  memory, so we use entrypgdir for the APs too.
+-    stack = kalloc();
+-    *(void**)(code-4) = stack + KSTACKSIZE;
+-    *(void(**)(void))(code-8) = mpenter;
+-    *(int**)(code-12) = (void *) V2P(entrypgdir);
+-
+-    lapicstartap(c->apicid, V2P(code));
+-
+-    // wait for cpu to finish mpmain()
+-    while(c->started == 0)
+-      ;
+-  }
+-}
+-
+-// The boot page table used in entry.S and entryother.S.
+-// Page directories (and page tables) must start on page boundaries,
+-// hence the __aligned__ attribute.
+-// PTE_PS in a page directory entry enables 4Mbyte pages.
+-
+-__attribute__((__aligned__(PGSIZE)))
+-pde_t entrypgdir[NPDENTRIES] = {
+-  // Map VA's [0, 4MB) to PA's [0, 4MB)
+-  [0] = (0) | PTE_P | PTE_W | PTE_PS,
+-  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
+-  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
+-};
+-
+-//PAGEBREAK!
+-// Blank page.
+-//PAGEBREAK!
+-// Blank page.
+-//PAGEBREAK!
+-// Blank page.
+-
+diff --git a/memide.c b/memide.c
+deleted file mode 100644
+index ba267ac..0000000
+--- a/memide.c
++++ /dev/null
+@@ -1,60 +0,0 @@
+-// Fake IDE disk; stores blocks in memory.
+-// Useful for running kernel without scratch disk.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-#include "traps.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "buf.h"
+-
+-extern uchar _binary_fs_img_start[], _binary_fs_img_size[];
+-
+-static int disksize;
+-static uchar *memdisk;
+-
+-void
+-ideinit(void)
+-{
+-  memdisk = _binary_fs_img_start;
+-  disksize = (uint)_binary_fs_img_size/BSIZE;
+-}
+-
+-// Interrupt handler.
+-void
+-ideintr(void)
+-{
+-  // no-op
+-}
+-
+-// Sync buf with disk.
+-// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+-// Else if B_VALID is not set, read buf from disk, set B_VALID.
+-void
+-iderw(struct buf *b)
+-{
+-  uchar *p;
+-
+-  if(!holdingsleep(&b->lock))
+-    panic("iderw: buf not locked");
+-  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+-    panic("iderw: nothing to do");
+-  if(b->dev != 1)
+-    panic("iderw: request not for disk 1");
+-  if(b->blockno >= disksize)
+-    panic("iderw: block out of range");
+-
+-  p = memdisk + b->blockno*BSIZE;
+-
+-  if(b->flags & B_DIRTY){
+-    b->flags &= ~B_DIRTY;
+-    memmove(p, b->data, BSIZE);
+-  } else
+-    memmove(b->data, p, BSIZE);
+-  b->flags |= B_VALID;
+-}
+diff --git a/memlayout.h b/memlayout.h
+deleted file mode 100644
+index d1615f7..0000000
+--- a/memlayout.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-// Memory layout
+-
+-#define EXTMEM  0x100000            // Start of extended memory
+-#define PHYSTOP 0xE000000           // Top physical memory
+-#define DEVSPACE 0xFE000000         // Other devices are at high addresses
+-
+-// Key addresses for address space layout (see kmap in vm.c for layout)
+-#define KERNBASE 0x80000000         // First kernel virtual address
+-#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
+-
+-#define V2P(a) (((uint) (a)) - KERNBASE)
+-#define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
+-
+-#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
+-#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts
+diff --git a/mkdir.c b/mkdir.c
+deleted file mode 100644
+index 2d90781..0000000
+--- a/mkdir.c
++++ /dev/null
+@@ -1,23 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int i;
+-
+-  if(argc < 2){
+-    printf(2, "Usage: mkdir files...\n");
+-    exit(1);
+-  }
+-
+-  for(i = 1; i < argc; i++){
+-    if(mkdir(argv[i]) < 0){
+-      printf(2, "mkdir: %s failed to create\n", argv[i]);
+-      break;
+-    }
+-  }
+-
+-  exit(0);
+-}
+diff --git a/mkfs.c b/mkfs.c
+deleted file mode 100644
+index 8e011a7..0000000
+--- a/mkfs.c
++++ /dev/null
+@@ -1,297 +0,0 @@
+-#include <stdio.h>
+-#include <unistd.h>
+-#include <stdlib.h>
+-#include <string.h>
+-#include <fcntl.h>
+-#include <assert.h>
+-
+-#define stat xv6_stat  // avoid clash with host struct stat
+-#include "types.h"
+-#include "fs.h"
+-#include "stat.h"
+-#include "param.h"
+-
+-#ifndef static_assert
+-#define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0)
+-#endif
+-
+-#define NINODES 200
+-
+-// Disk layout:
+-// [ boot block | sb block | log | inode blocks | free bit map | data blocks ]
+-
+-int nbitmap = FSSIZE/(BSIZE*8) + 1;
+-int ninodeblocks = NINODES / IPB + 1;
+-int nlog = LOGSIZE;
+-int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
+-int nblocks;  // Number of data blocks
+-
+-int fsfd;
+-struct superblock sb;
+-char zeroes[BSIZE];
+-uint freeinode = 1;
+-uint freeblock;
+-
+-
+-void balloc(int);
+-void wsect(uint, void*);
+-void winode(uint, struct dinode*);
+-void rinode(uint inum, struct dinode *ip);
+-void rsect(uint sec, void *buf);
+-uint ialloc(ushort type);
+-void iappend(uint inum, void *p, int n);
+-
+-// convert to intel byte order
+-ushort
+-xshort(ushort x)
+-{
+-  ushort y;
+-  uchar *a = (uchar*)&y;
+-  a[0] = x;
+-  a[1] = x >> 8;
+-  return y;
+-}
+-
+-uint
+-xint(uint x)
+-{
+-  uint y;
+-  uchar *a = (uchar*)&y;
+-  a[0] = x;
+-  a[1] = x >> 8;
+-  a[2] = x >> 16;
+-  a[3] = x >> 24;
+-  return y;
+-}
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int i, cc, fd;
+-  uint rootino, inum, off;
+-  struct dirent de;
+-  char buf[BSIZE];
+-  struct dinode din;
+-
+-
+-  static_assert(sizeof(int) == 4, "Integers must be 4 bytes!");
+-
+-  if(argc < 2){
+-    fprintf(stderr, "Usage: mkfs fs.img files...\n");
+-    exit(1);
+-  }
+-
+-  assert((BSIZE % sizeof(struct dinode)) == 0);
+-  assert((BSIZE % sizeof(struct dirent)) == 0);
+-
+-  fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);
+-  if(fsfd < 0){
+-    perror(argv[1]);
+-    exit(1);
+-  }
+-
+-  // 1 fs block = 1 disk sector
+-  nmeta = 2 + nlog + ninodeblocks + nbitmap;
+-  nblocks = FSSIZE - nmeta;
+-
+-  sb.size = xint(FSSIZE);
+-  sb.nblocks = xint(nblocks);
+-  sb.ninodes = xint(NINODES);
+-  sb.nlog = xint(nlog);
+-  sb.logstart = xint(2);
+-  sb.inodestart = xint(2+nlog);
+-  sb.bmapstart = xint(2+nlog+ninodeblocks);
+-
+-  printf("nmeta %d (boot, super, log blocks %u inode blocks %u, bitmap blocks %u) blocks %d total %d\n",
+-         nmeta, nlog, ninodeblocks, nbitmap, nblocks, FSSIZE);
+-
+-  freeblock = nmeta;     // the first free block that we can allocate
+-
+-  for(i = 0; i < FSSIZE; i++)
+-    wsect(i, zeroes);
+-
+-  memset(buf, 0, sizeof(buf));
+-  memmove(buf, &sb, sizeof(sb));
+-  wsect(1, buf);
+-
+-  rootino = ialloc(T_DIR);
+-  assert(rootino == ROOTINO);
+-
+-  bzero(&de, sizeof(de));
+-  de.inum = xshort(rootino);
+-  strcpy(de.name, ".");
+-  iappend(rootino, &de, sizeof(de));
+-
+-  bzero(&de, sizeof(de));
+-  de.inum = xshort(rootino);
+-  strcpy(de.name, "..");
+-  iappend(rootino, &de, sizeof(de));
+-
+-  for(i = 2; i < argc; i++){
+-    assert(index(argv[i], '/') == 0);
+-
+-    if((fd = open(argv[i], 0)) < 0){
+-      perror(argv[i]);
+-      exit(1);
+-    }
+-
+-    // Skip leading _ in name when writing to file system.
+-    // The binaries are named _rm, _cat, etc. to keep the
+-    // build operating system from trying to execute them
+-    // in place of system binaries like rm and cat.
+-    if(argv[i][0] == '_')
+-      ++argv[i];
+-
+-    inum = ialloc(T_FILE);
+-
+-    bzero(&de, sizeof(de));
+-    de.inum = xshort(inum);
+-    strncpy(de.name, argv[i], DIRSIZ);
+-    iappend(rootino, &de, sizeof(de));
+-
+-    while((cc = read(fd, buf, sizeof(buf))) > 0)
+-      iappend(inum, buf, cc);
+-
+-    close(fd);
+-  }
+-
+-  // fix size of root inode dir
+-  rinode(rootino, &din);
+-  off = xint(din.size);
+-  off = ((off/BSIZE) + 1) * BSIZE;
+-  din.size = xint(off);
+-  winode(rootino, &din);
+-
+-  balloc(freeblock);
+-
+-  exit(0);
+-}
+-
+-void
+-wsect(uint sec, void *buf)
+-{
+-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
+-    perror("lseek");
+-    exit(1);
+-  }
+-  if(write(fsfd, buf, BSIZE) != BSIZE){
+-    perror("write");
+-    exit(1);
+-  }
+-}
+-
+-void
+-winode(uint inum, struct dinode *ip)
+-{
+-  char buf[BSIZE];
+-  uint bn;
+-  struct dinode *dip;
+-
+-  bn = IBLOCK(inum, sb);
+-  rsect(bn, buf);
+-  dip = ((struct dinode*)buf) + (inum % IPB);
+-  *dip = *ip;
+-  wsect(bn, buf);
+-}
+-
+-void
+-rinode(uint inum, struct dinode *ip)
+-{
+-  char buf[BSIZE];
+-  uint bn;
+-  struct dinode *dip;
+-
+-  bn = IBLOCK(inum, sb);
+-  rsect(bn, buf);
+-  dip = ((struct dinode*)buf) + (inum % IPB);
+-  *ip = *dip;
+-}
+-
+-void
+-rsect(uint sec, void *buf)
+-{
+-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
+-    perror("lseek");
+-    exit(1);
+-  }
+-  if(read(fsfd, buf, BSIZE) != BSIZE){
+-    perror("read");
+-    exit(1);
+-  }
+-}
+-
+-uint
+-ialloc(ushort type)
+-{
+-  uint inum = freeinode++;
+-  struct dinode din;
+-
+-  bzero(&din, sizeof(din));
+-  din.type = xshort(type);
+-  din.nlink = xshort(1);
+-  din.size = xint(0);
+-  winode(inum, &din);
+-  return inum;
+-}
+-
+-void
+-balloc(int used)
+-{
+-  uchar buf[BSIZE];
+-  int i;
+-
+-  printf("balloc: first %d blocks have been allocated\n", used);
+-  assert(used < BSIZE*8);
+-  bzero(buf, BSIZE);
+-  for(i = 0; i < used; i++){
+-    buf[i/8] = buf[i/8] | (0x1 << (i%8));
+-  }
+-  printf("balloc: write bitmap block at sector %d\n", sb.bmapstart);
+-  wsect(sb.bmapstart, buf);
+-}
+-
+-#define min(a, b) ((a) < (b) ? (a) : (b))
+-
+-void
+-iappend(uint inum, void *xp, int n)
+-{
+-  char *p = (char*)xp;
+-  uint fbn, off, n1;
+-  struct dinode din;
+-  char buf[BSIZE];
+-  uint indirect[NINDIRECT];
+-  uint x;
+-
+-  rinode(inum, &din);
+-  off = xint(din.size);
+-  // printf("append inum %d at off %d sz %d\n", inum, off, n);
+-  while(n > 0){
+-    fbn = off / BSIZE;
+-    assert(fbn < MAXFILE);
+-    if(fbn < NDIRECT){
+-      if(xint(din.addrs[fbn]) == 0){
+-        din.addrs[fbn] = xint(freeblock++);
+-      }
+-      x = xint(din.addrs[fbn]);
+-    } else {
+-      if(xint(din.addrs[NDIRECT]) == 0){
+-        din.addrs[NDIRECT] = xint(freeblock++);
+-      }
+-      rsect(xint(din.addrs[NDIRECT]), (char*)indirect);
+-      if(indirect[fbn - NDIRECT] == 0){
+-        indirect[fbn - NDIRECT] = xint(freeblock++);
+-        wsect(xint(din.addrs[NDIRECT]), (char*)indirect);
+-      }
+-      x = xint(indirect[fbn-NDIRECT]);
+-    }
+-    n1 = min(n, (fbn + 1) * BSIZE - off);
+-    rsect(x, buf);
+-    bcopy(p, buf + off - (fbn * BSIZE), n1);
+-    wsect(x, buf);
+-    n -= n1;
+-    off += n1;
+-    p += n1;
+-  }
+-  din.size = xint(off);
+-  winode(inum, &din);
+-}
+diff --git a/mmu.h b/mmu.h
+deleted file mode 100644
+index a82d8e2..0000000
+--- a/mmu.h
++++ /dev/null
+@@ -1,181 +0,0 @@
+-// This file contains definitions for the
+-// x86 memory management unit (MMU).
+-
+-// Eflags register
+-#define FL_IF           0x00000200      // Interrupt Enable
+-
+-// Control Register flags
+-#define CR0_PE          0x00000001      // Protection Enable
+-#define CR0_WP          0x00010000      // Write Protect
+-#define CR0_PG          0x80000000      // Paging
+-
+-#define CR4_PSE         0x00000010      // Page size extension
+-
+-// various segment selectors.
+-#define SEG_KCODE 1  // kernel code
+-#define SEG_KDATA 2  // kernel data+stack
+-#define SEG_UCODE 3  // user code
+-#define SEG_UDATA 4  // user data+stack
+-#define SEG_TSS   5  // this process's task state
+-
+-// cpu->gdt[NSEGS] holds the above segments.
+-#define NSEGS     6
+-
+-#ifndef __ASSEMBLER__
+-// Segment Descriptor
+-struct segdesc {
+-  uint lim_15_0 : 16;  // Low bits of segment limit
+-  uint base_15_0 : 16; // Low bits of segment base address
+-  uint base_23_16 : 8; // Middle bits of segment base address
+-  uint type : 4;       // Segment type (see STS_ constants)
+-  uint s : 1;          // 0 = system, 1 = application
+-  uint dpl : 2;        // Descriptor Privilege Level
+-  uint p : 1;          // Present
+-  uint lim_19_16 : 4;  // High bits of segment limit
+-  uint avl : 1;        // Unused (available for software use)
+-  uint rsv1 : 1;       // Reserved
+-  uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
+-  uint g : 1;          // Granularity: limit scaled by 4K when set
+-  uint base_31_24 : 8; // High bits of segment base address
+-};
+-
+-// Normal segment
+-#define SEG(type, base, lim, dpl) (struct segdesc)    \
+-{ ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
+-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
+-  (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
+-#define SEG16(type, base, lim, dpl) (struct segdesc)  \
+-{ (lim) & 0xffff, (uint)(base) & 0xffff,              \
+-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
+-  (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
+-#endif
+-
+-#define DPL_USER    0x3     // User DPL
+-
+-// Application segment type bits
+-#define STA_X       0x8     // Executable segment
+-#define STA_W       0x2     // Writeable (non-executable segments)
+-#define STA_R       0x2     // Readable (executable segments)
+-
+-// System segment type bits
+-#define STS_T32A    0x9     // Available 32-bit TSS
+-#define STS_IG32    0xE     // 32-bit Interrupt Gate
+-#define STS_TG32    0xF     // 32-bit Trap Gate
+-
+-// A virtual address 'la' has a three-part structure as follows:
+-//
+-// +--------10------+-------10-------+---------12----------+
+-// | Page Directory |   Page Table   | Offset within Page  |
+-// |      Index     |      Index     |                     |
+-// +----------------+----------------+---------------------+
+-//  \--- PDX(va) --/ \--- PTX(va) --/
+-
+-// page directory index
+-#define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
+-
+-// page table index
+-#define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
+-
+-// construct virtual address from indexes and offset
+-#define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
+-
+-// Page directory and page table constants.
+-#define NPDENTRIES      1024    // # directory entries per page directory
+-#define NPTENTRIES      1024    // # PTEs per page table
+-#define PGSIZE          4096    // bytes mapped by a page
+-
+-#define PTXSHIFT        12      // offset of PTX in a linear address
+-#define PDXSHIFT        22      // offset of PDX in a linear address
+-
+-#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
+-#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
+-
+-// Page table/directory entry flags.
+-#define PTE_P           0x001   // Present
+-#define PTE_W           0x002   // Writeable
+-#define PTE_U           0x004   // User
+-#define PTE_PS          0x080   // Page Size
+-
+-// Address in page table or page directory entry
+-#define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
+-#define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
+-
+-#ifndef __ASSEMBLER__
+-typedef uint pte_t;
+-
+-// Task state segment format
+-struct taskstate {
+-  uint link;         // Old ts selector
+-  uint esp0;         // Stack pointers and segment selectors
+-  ushort ss0;        //   after an increase in privilege level
+-  ushort padding1;
+-  uint *esp1;
+-  ushort ss1;
+-  ushort padding2;
+-  uint *esp2;
+-  ushort ss2;
+-  ushort padding3;
+-  void *cr3;         // Page directory base
+-  uint *eip;         // Saved state from last task switch
+-  uint eflags;
+-  uint eax;          // More saved state (registers)
+-  uint ecx;
+-  uint edx;
+-  uint ebx;
+-  uint *esp;
+-  uint *ebp;
+-  uint esi;
+-  uint edi;
+-  ushort es;         // Even more saved state (segment selectors)
+-  ushort padding4;
+-  ushort cs;
+-  ushort padding5;
+-  ushort ss;
+-  ushort padding6;
+-  ushort ds;
+-  ushort padding7;
+-  ushort fs;
+-  ushort padding8;
+-  ushort gs;
+-  ushort padding9;
+-  ushort ldt;
+-  ushort padding10;
+-  ushort t;          // Trap on task switch
+-  ushort iomb;       // I/O map base address
+-};
+-
+-// Gate descriptors for interrupts and traps
+-struct gatedesc {
+-  uint off_15_0 : 16;   // low 16 bits of offset in segment
+-  uint cs : 16;         // code segment selector
+-  uint args : 5;        // # args, 0 for interrupt/trap gates
+-  uint rsv1 : 3;        // reserved(should be zero I guess)
+-  uint type : 4;        // type(STS_{IG32,TG32})
+-  uint s : 1;           // must be 0 (system)
+-  uint dpl : 2;         // descriptor(meaning new) privilege level
+-  uint p : 1;           // Present
+-  uint off_31_16 : 16;  // high bits of offset in segment
+-};
+-
+-// Set up a normal interrupt/trap gate descriptor.
+-// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
+-//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
+-// - sel: Code segment selector for interrupt/trap handler
+-// - off: Offset in code segment for interrupt/trap handler
+-// - dpl: Descriptor Privilege Level -
+-//        the privilege level required for software to invoke
+-//        this interrupt/trap gate explicitly using an int instruction.
+-#define SETGATE(gate, istrap, sel, off, d)                \
+-{                                                         \
+-  (gate).off_15_0 = (uint)(off) & 0xffff;                \
+-  (gate).cs = (sel);                                      \
+-  (gate).args = 0;                                        \
+-  (gate).rsv1 = 0;                                        \
+-  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
+-  (gate).s = 0;                                           \
+-  (gate).dpl = (d);                                       \
+-  (gate).p = 1;                                           \
+-  (gate).off_31_16 = (uint)(off) >> 16;                  \
+-}
+-
+-#endif
+diff --git a/mp.c b/mp.c
+deleted file mode 100644
+index 79bb0ad..0000000
+--- a/mp.c
++++ /dev/null
+@@ -1,139 +0,0 @@
+-// Multiprocessor support
+-// Search memory for MP description structures.
+-// http://developer.intel.com/design/pentium/datashts/24201606.pdf
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mp.h"
+-#include "x86.h"
+-#include "mmu.h"
+-#include "proc.h"
+-
+-struct cpu cpus[NCPU];
+-int ncpu;
+-uchar ioapicid;
+-
+-static uchar
+-sum(uchar *addr, int len)
+-{
+-  int i, sum;
+-
+-  sum = 0;
+-  for(i=0; i<len; i++)
+-    sum += addr[i];
+-  return sum;
+-}
+-
+-// Look for an MP structure in the len bytes at addr.
+-static struct mp*
+-mpsearch1(uint a, int len)
+-{
+-  uchar *e, *p, *addr;
+-
+-  addr = P2V(a);
+-  e = addr+len;
+-  for(p = addr; p < e; p += sizeof(struct mp))
+-    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+-      return (struct mp*)p;
+-  return 0;
+-}
+-
+-// Search for the MP Floating Pointer Structure, which according to the
+-// spec is in one of the following three locations:
+-// 1) in the first KB of the EBDA;
+-// 2) in the last KB of system base memory;
+-// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
+-static struct mp*
+-mpsearch(void)
+-{
+-  uchar *bda;
+-  uint p;
+-  struct mp *mp;
+-
+-  bda = (uchar *) P2V(0x400);
+-  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
+-    if((mp = mpsearch1(p, 1024)))
+-      return mp;
+-  } else {
+-    p = ((bda[0x14]<<8)|bda[0x13])*1024;
+-    if((mp = mpsearch1(p-1024, 1024)))
+-      return mp;
+-  }
+-  return mpsearch1(0xF0000, 0x10000);
+-}
+-
+-// Search for an MP configuration table.  For now,
+-// don't accept the default configurations (physaddr == 0).
+-// Check for correct signature, calculate the checksum and,
+-// if correct, check the version.
+-// To do: check extended table checksum.
+-static struct mpconf*
+-mpconfig(struct mp **pmp)
+-{
+-  struct mpconf *conf;
+-  struct mp *mp;
+-
+-  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+-    return 0;
+-  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+-  if(memcmp(conf, "PCMP", 4) != 0)
+-    return 0;
+-  if(conf->version != 1 && conf->version != 4)
+-    return 0;
+-  if(sum((uchar*)conf, conf->length) != 0)
+-    return 0;
+-  *pmp = mp;
+-  return conf;
+-}
+-
+-void
+-mpinit(void)
+-{
+-  uchar *p, *e;
+-  int ismp;
+-  struct mp *mp;
+-  struct mpconf *conf;
+-  struct mpproc *proc;
+-  struct mpioapic *ioapic;
+-
+-  if((conf = mpconfig(&mp)) == 0)
+-    panic("Expect to run on an SMP");
+-  ismp = 1;
+-  lapic = (uint*)conf->lapicaddr;
+-  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+-    switch(*p){
+-    case MPPROC:
+-      proc = (struct mpproc*)p;
+-      if(ncpu < NCPU) {
+-        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+-        ncpu++;
+-      }
+-      p += sizeof(struct mpproc);
+-      continue;
+-    case MPIOAPIC:
+-      ioapic = (struct mpioapic*)p;
+-      ioapicid = ioapic->apicno;
+-      p += sizeof(struct mpioapic);
+-      continue;
+-    case MPBUS:
+-    case MPIOINTR:
+-    case MPLINTR:
+-      p += 8;
+-      continue;
+-    default:
+-      ismp = 0;
+-      break;
+-    }
+-  }
+-  if(!ismp)
+-    panic("Didn't find a suitable machine");
+-
+-  if(mp->imcrp){
+-    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
+-    // But it would on real hardware.
+-    outb(0x22, 0x70);   // Select IMCR
+-    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
+-  }
+-}
+diff --git a/mp.h b/mp.h
+deleted file mode 100644
+index 4d17283..0000000
+--- a/mp.h
++++ /dev/null
+@@ -1,56 +0,0 @@
+-// See MultiProcessor Specification Version 1.[14]
+-
+-struct mp {             // floating pointer
+-  uchar signature[4];           // "_MP_"
+-  void *physaddr;               // phys addr of MP config table
+-  uchar length;                 // 1
+-  uchar specrev;                // [14]
+-  uchar checksum;               // all bytes must add up to 0
+-  uchar type;                   // MP system config type
+-  uchar imcrp;
+-  uchar reserved[3];
+-};
+-
+-struct mpconf {         // configuration table header
+-  uchar signature[4];           // "PCMP"
+-  ushort length;                // total table length
+-  uchar version;                // [14]
+-  uchar checksum;               // all bytes must add up to 0
+-  uchar product[20];            // product id
+-  uint *oemtable;               // OEM table pointer
+-  ushort oemlength;             // OEM table length
+-  ushort entry;                 // entry count
+-  uint *lapicaddr;              // address of local APIC
+-  ushort xlength;               // extended table length
+-  uchar xchecksum;              // extended table checksum
+-  uchar reserved;
+-};
+-
+-struct mpproc {         // processor table entry
+-  uchar type;                   // entry type (0)
+-  uchar apicid;                 // local APIC id
+-  uchar version;                // local APIC verison
+-  uchar flags;                  // CPU flags
+-    #define MPBOOT 0x02           // This proc is the bootstrap processor.
+-  uchar signature[4];           // CPU signature
+-  uint feature;                 // feature flags from CPUID instruction
+-  uchar reserved[8];
+-};
+-
+-struct mpioapic {       // I/O APIC table entry
+-  uchar type;                   // entry type (2)
+-  uchar apicno;                 // I/O APIC id
+-  uchar version;                // I/O APIC version
+-  uchar flags;                  // I/O APIC flags
+-  uint *addr;                  // I/O APIC address
+-};
+-
+-// Table entry types
+-#define MPPROC    0x00  // One per processor
+-#define MPBUS     0x01  // One per bus
+-#define MPIOAPIC  0x02  // One per I/O APIC
+-#define MPIOINTR  0x03  // One per bus interrupt source
+-#define MPLINTR   0x04  // One per system interrupt source
+-
+-//PAGEBREAK!
+-// Blank page.
+diff --git a/param.h b/param.h
+deleted file mode 100644
+index a7e90ef..0000000
+--- a/param.h
++++ /dev/null
+@@ -1,14 +0,0 @@
+-#define NPROC        64  // maximum number of processes
+-#define KSTACKSIZE 4096  // size of per-process kernel stack
+-#define NCPU          8  // maximum number of CPUs
+-#define NOFILE       16  // open files per process
+-#define NFILE       100  // open files per system
+-#define NINODE       50  // maximum number of active i-nodes
+-#define NDEV         10  // maximum major device number
+-#define ROOTDEV       1  // device number of file system root disk
+-#define MAXARG       32  // max exec arguments
+-#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
+-#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
+-#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
+-#define FSSIZE       1000  // size of file system in blocks
+-
+diff --git a/picirq.c b/picirq.c
+deleted file mode 100644
+index e26957f..0000000
+--- a/picirq.c
++++ /dev/null
+@@ -1,19 +0,0 @@
+-#include "types.h"
+-#include "x86.h"
+-#include "traps.h"
+-
+-// I/O Addresses of the two programmable interrupt controllers
+-#define IO_PIC1         0x20    // Master (IRQs 0-7)
+-#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
+-
+-// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
+-void
+-picinit(void)
+-{
+-  // mask all interrupts
+-  outb(IO_PIC1+1, 0xFF);
+-  outb(IO_PIC2+1, 0xFF);
+-}
+-
+-//PAGEBREAK!
+-// Blank page.
+diff --git a/pipe.c b/pipe.c
+deleted file mode 100644
+index e9abe7f..0000000
+--- a/pipe.c
++++ /dev/null
+@@ -1,121 +0,0 @@
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "fs.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "file.h"
+-
+-#define PIPESIZE 512
+-
+-struct pipe {
+-  struct spinlock lock;
+-  char data[PIPESIZE];
+-  uint nread;     // number of bytes read
+-  uint nwrite;    // number of bytes written
+-  int readopen;   // read fd is still open
+-  int writeopen;  // write fd is still open
+-};
+-
+-int
+-pipealloc(struct file **f0, struct file **f1)
+-{
+-  struct pipe *p;
+-
+-  p = 0;
+-  *f0 = *f1 = 0;
+-  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
+-    goto bad;
+-  if((p = (struct pipe*)kalloc()) == 0)
+-    goto bad;
+-  p->readopen = 1;
+-  p->writeopen = 1;
+-  p->nwrite = 0;
+-  p->nread = 0;
+-  initlock(&p->lock, "pipe");
+-  (*f0)->type = FD_PIPE;
+-  (*f0)->readable = 1;
+-  (*f0)->writable = 0;
+-  (*f0)->pipe = p;
+-  (*f1)->type = FD_PIPE;
+-  (*f1)->readable = 0;
+-  (*f1)->writable = 1;
+-  (*f1)->pipe = p;
+-  return 0;
+-
+-//PAGEBREAK: 20
+- bad:
+-  if(p)
+-    kfree((char*)p);
+-  if(*f0)
+-    fileclose(*f0);
+-  if(*f1)
+-    fileclose(*f1);
+-  return -1;
+-}
+-
+-void
+-pipeclose(struct pipe *p, int writable)
+-{
+-  acquire(&p->lock);
+-  if(writable){
+-    p->writeopen = 0;
+-    wakeup(&p->nread);
+-  } else {
+-    p->readopen = 0;
+-    wakeup(&p->nwrite);
+-  }
+-  if(p->readopen == 0 && p->writeopen == 0){
+-    release(&p->lock);
+-    kfree((char*)p);
+-  } else
+-    release(&p->lock);
+-}
+-
+-//PAGEBREAK: 40
+-int
+-pipewrite(struct pipe *p, char *addr, int n)
+-{
+-  int i;
+-
+-  acquire(&p->lock);
+-  for(i = 0; i < n; i++){
+-    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+-      if(p->readopen == 0 || myproc()->killed){
+-        release(&p->lock);
+-        return -1;
+-      }
+-      wakeup(&p->nread);
+-      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+-    }
+-    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+-  }
+-  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+-  release(&p->lock);
+-  return n;
+-}
+-
+-int
+-piperead(struct pipe *p, char *addr, int n)
+-{
+-  int i;
+-
+-  acquire(&p->lock);
+-  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+-    if(myproc()->killed){
+-      release(&p->lock);
+-      return -1;
+-    }
+-    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+-  }
+-  for(i = 0; i < n; i++){  //DOC: piperead-copy
+-    if(p->nread == p->nwrite)
+-      break;
+-    addr[i] = p->data[p->nread++ % PIPESIZE];
+-  }
+-  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+-  release(&p->lock);
+-  return i;
+-}
+diff --git a/pr.pl b/pr.pl
+deleted file mode 100644
+index 46905bd..0000000
+--- a/pr.pl
++++ /dev/null
+@@ -1,36 +0,0 @@
+-#!/usr/bin/perl
+-
+-use POSIX qw(strftime);
+-
+-if($ARGV[0] eq "-h"){
+-	shift @ARGV;
+-	$h = $ARGV[0];
+-	shift @ARGV;
+-}else{
+-	$h = $ARGV[0];
+-}
+-
+-$page = 0;
+-$now = strftime "%b %e %H:%M %Y", localtime;
+-
+-@lines = <>;
+-for($i=0; $i<@lines; $i+=50){
+-	print "\n\n";
+-	++$page;
+-	print "$now  $h  Page $page\n";
+-	print "\n\n";
+-	for($j=$i; $j<@lines && $j<$i +50; $j++){
+-		$lines[$j] =~ s!//DOC.*!!;
+-		print $lines[$j];
+-	}
+-	for(; $j<$i+50; $j++){
+-		print "\n";
+-	}
+-	$sheet = "";
+-	if($lines[$i] =~ /^([0-9][0-9])[0-9][0-9] /){
+-		$sheet = "Sheet $1";
+-	}
+-	print "\n\n";
+-	print "$sheet\n";
+-	print "\n\n";
+-}
+diff --git a/printf.c b/printf.c
+deleted file mode 100644
+index b3298aa..0000000
+--- a/printf.c
++++ /dev/null
+@@ -1,85 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-static void
+-putc(int fd, char c)
+-{
+-  write(fd, &c, 1);
+-}
+-
+-static void
+-printint(int fd, int xx, int base, int sgn)
+-{
+-  static char digits[] = "0123456789ABCDEF";
+-  char buf[16];
+-  int i, neg;
+-  uint x;
+-
+-  neg = 0;
+-  if(sgn && xx < 0){
+-    neg = 1;
+-    x = -xx;
+-  } else {
+-    x = xx;
+-  }
+-
+-  i = 0;
+-  do{
+-    buf[i++] = digits[x % base];
+-  }while((x /= base) != 0);
+-  if(neg)
+-    buf[i++] = '-';
+-
+-  while(--i >= 0)
+-    putc(fd, buf[i]);
+-}
+-
+-// Print to the given fd. Only understands %d, %x, %p, %s.
+-void
+-printf(int fd, const char *fmt, ...)
+-{
+-  char *s;
+-  int c, i, state;
+-  uint *ap;
+-
+-  state = 0;
+-  ap = (uint*)(void*)&fmt + 1;
+-  for(i = 0; fmt[i]; i++){
+-    c = fmt[i] & 0xff;
+-    if(state == 0){
+-      if(c == '%'){
+-        state = '%';
+-      } else {
+-        putc(fd, c);
+-      }
+-    } else if(state == '%'){
+-      if(c == 'd'){
+-        printint(fd, *ap, 10, 1);
+-        ap++;
+-      } else if(c == 'x' || c == 'p'){
+-        printint(fd, *ap, 16, 0);
+-        ap++;
+-      } else if(c == 's'){
+-        s = (char*)*ap;
+-        ap++;
+-        if(s == 0)
+-          s = "(null)";
+-        while(*s != 0){
+-          putc(fd, *s);
+-          s++;
+-        }
+-      } else if(c == 'c'){
+-        putc(fd, *ap);
+-        ap++;
+-      } else if(c == '%'){
+-        putc(fd, c);
+-      } else {
+-        // Unknown % sequence.  Print it to draw attention.
+-        putc(fd, '%');
+-        putc(fd, c);
+-      }
+-      state = 0;
+-    }
+-  }
+-}
+diff --git a/printpcs b/printpcs
+deleted file mode 100644
+index 81d039b..0000000
+--- a/printpcs
++++ /dev/null
+@@ -1,14 +0,0 @@
+-#!/bin/sh
+-
+-# Decode the symbols from a panic EIP list
+-
+-# Find a working addr2line
+-for p in i386-jos-elf-addr2line addr2line; do
+-    if which $p 2>&1 >/dev/null && \
+-       $p -h 2>&1 | grep -q '\belf32-i386\b'; then
+-        break
+-    fi
+-done
+-
+-# Enable as much pretty-printing as this addr2line can do
+-$p $($p -h | grep ' -[aipsf] ' | awk '{print $1}') -e kernel "$@"
+diff --git a/proc.c b/proc.c
+deleted file mode 100644
+index 84b335f..0000000
+--- a/proc.c
++++ /dev/null
+@@ -1,577 +0,0 @@
+-#include <stddef.h>
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "x86.h"
+-#include "proc.h"
+-#include "spinlock.h"
+-
+-struct {
+-    struct spinlock lock;
+-    struct proc proc[NPROC];
+-} ptable;
+-
+-static struct proc *initproc;
+-
+-int nextpid = 1;
+-
+-extern void forkret(void);
+-
+-extern void trapret(void);
+-
+-static void wakeup1(void *chan);
+-
+-void
+-pinit(void) {
+-    initlock(&ptable.lock, "ptable");
+-}
+-
+-// Must be called with interrupts disabled
+-int
+-cpuid() {
+-    return mycpu() - cpus;
+-}
+-
+-// Must be called with interrupts disabled to avoid the caller being
+-// rescheduled between reading lapicid and running through the loop.
+-struct cpu *
+-mycpu(void) {
+-    int apicid, i;
+-
+-    if (readeflags() & FL_IF)
+-        panic("mycpu called with interrupts enabled\n");
+-
+-    apicid = lapicid();
+-    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+-    // a reverse map, or reserve a register to store &cpus[i].
+-    for (i = 0; i < ncpu; ++i) {
+-        if (cpus[i].apicid == apicid)
+-            return &cpus[i];
+-    }
+-    panic("unknown apicid\n");
+-}
+-
+-// Disable interrupts so that we are not rescheduled
+-// while reading proc from the cpu structure
+-struct proc *
+-myproc(void) {
+-    struct cpu *c;
+-    struct proc *p;
+-    pushcli();
+-    c = mycpu();
+-    p = c->proc;
+-    popcli();
+-    return p;
+-}
+-
+-//PAGEBREAK: 32
+-// Look in the process table for an UNUSED proc.
+-// If found, change state to EMBRYO and initialize
+-// state required to run in the kernel.
+-// Otherwise return 0.
+-static struct proc *
+-allocproc(void) {
+-    struct proc *p;
+-    char *sp;
+-
+-    acquire(&ptable.lock);
+-
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-        if (p->state == UNUSED)
+-            goto found;
+-
+-    release(&ptable.lock);
+-    return 0;
+-
+-    found:
+-    p->state = EMBRYO;
+-    p->pid = nextpid++;
+-
+-    release(&ptable.lock);
+-
+-    // Allocate kernel stack.
+-    if ((p->kstack = kalloc()) == 0) {
+-        p->state = UNUSED;
+-        return 0;
+-    }
+-    sp = p->kstack + KSTACKSIZE;
+-
+-    // Leave room for trap frame.
+-    sp -= sizeof *p->tf;
+-    p->tf = (struct trapframe *) sp;
+-
+-    // Set up new context to start executing at forkret,
+-    // which returns to trapret.
+-    sp -= 4;
+-    *(uint *) sp = (uint) trapret;
+-
+-    sp -= sizeof *p->context;
+-    p->context = (struct context *) sp;
+-    memset(p->context, 0, sizeof *p->context);
+-    p->context->eip = (uint) forkret;
+-
+-    return p;
+-}
+-
+-//PAGEBREAK: 32
+-// Set up first user process.
+-void
+-userinit(void) {
+-    struct proc *p;
+-    extern char _binary_initcode_start[], _binary_initcode_size[];
+-
+-    p = allocproc();
+-
+-    initproc = p;
+-    if ((p->pgdir = setupkvm()) == 0)
+-        panic("userinit: out of memory?");
+-    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
+-    p->sz = PGSIZE;
+-    memset(p->tf, 0, sizeof(*p->tf));
+-    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+-    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+-    p->tf->es = p->tf->ds;
+-    p->tf->ss = p->tf->ds;
+-    p->tf->eflags = FL_IF;
+-    p->tf->esp = PGSIZE;
+-    p->tf->eip = 0;  // beginning of initcode.S
+-
+-    safestrcpy(p->name, "initcode", sizeof(p->name));
+-    p->cwd = namei("/");
+-
+-    // this assignment to p->state lets other cores
+-    // run this process. the acquire forces the above
+-    // writes to be visible, and the lock is also needed
+-    // because the assignment might not be atomic.
+-    acquire(&ptable.lock);
+-
+-    p->state = RUNNABLE;
+-
+-    release(&ptable.lock);
+-}
+-
+-// Grow current process's memory by n bytes.
+-// Return 0 on success, -1 on failure.
+-int
+-growproc(int n) {
+-    uint sz;
+-    struct proc *curproc = myproc();
+-
+-    sz = curproc->sz;
+-    if (n > 0) {
+-        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-            return -1;
+-    } else if (n < 0) {
+-        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-            return -1;
+-    }
+-    curproc->sz = sz;
+-    switchuvm(curproc);
+-    return 0;
+-}
+-
+-// Create a new process copying p as the parent.
+-// Sets up stack to return as if from system call.
+-// Caller must set state of returned proc to RUNNABLE.
+-int
+-fork(void) {
+-    int i, pid;
+-    struct proc *np;
+-    struct proc *curproc = myproc();
+-
+-    // Allocate process.
+-    if ((np = allocproc()) == 0) {
+-        return -1;
+-    }
+-
+-    // Copy process state from proc.
+-    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
+-        kfree(np->kstack);
+-        np->kstack = 0;
+-        np->state = UNUSED;
+-        return -1;
+-    }
+-    np->sz = curproc->sz;
+-    np->parent = curproc;
+-    *np->tf = *curproc->tf;
+-
+-    // Clear %eax so that fork returns 0 in the child.
+-    np->tf->eax = 0;
+-
+-    for (i = 0; i < NOFILE; i++)
+-        if (curproc->ofile[i])
+-            np->ofile[i] = filedup(curproc->ofile[i]);
+-    np->cwd = idup(curproc->cwd);
+-
+-    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+-
+-    pid = np->pid;
+-
+-    acquire(&ptable.lock);
+-
+-    np->state = RUNNABLE;
+-
+-    release(&ptable.lock);
+-
+-    return pid;
+-}
+-
+-// Exit the current process.  Does not return.
+-// An exited process remains in the zombie state
+-// until its parent calls wait() to find out it exited.
+-void
+-exit(int status) {
+-    struct proc *curproc = myproc();
+-    struct proc *p;
+-    int fd;
+-
+-    curproc->status = status;
+-
+-    if (curproc == initproc)
+-        panic("init exiting");
+-
+-    // Close all open files.
+-    for (fd = 0; fd < NOFILE; fd++) {
+-        if (curproc->ofile[fd]) {
+-            fileclose(curproc->ofile[fd]);
+-            curproc->ofile[fd] = 0;
+-        }
+-    }
+-
+-    begin_op();
+-    iput(curproc->cwd);
+-    end_op();
+-    curproc->cwd = 0;
+-
+-    acquire(&ptable.lock);
+-
+-    // Parent might be sleeping in wait().
+-    wakeup1(curproc->parent);
+-
+-    // Pass abandoned children to init.
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-        if (p->parent == curproc) {
+-            p->parent = initproc;
+-            if (p->state == ZOMBIE)
+-                wakeup1(initproc);
+-        }
+-    }
+-
+-    // Jump into the scheduler, never to return.
+-    curproc->state = ZOMBIE;
+-    sched();
+-    panic("zombie exit");
+-}
+-
+-// Wait for a child process to exit and return its pid.
+-// Return -1 if this process has no children.
+-int
+-wait(int *status) {
+-    struct proc *p;
+-    int havekids, pid;
+-    struct proc *curproc = myproc();
+-
+-    acquire(&ptable.lock);
+-    for (;;) {
+-        // Scan through table looking for exited children.
+-        havekids = 0;
+-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-            if (p->parent != curproc)
+-                continue;
+-            havekids = 1;
+-            if (p->state == ZOMBIE) {
+-                // Found one.
+-                pid = p->pid;
+-                kfree(p->kstack);
+-                p->kstack = 0;
+-                freevm(p->pgdir);
+-                p->pid = 0;
+-                p->parent = 0;
+-                p->name[0] = 0;
+-                p->killed = 0;
+-                p->state = UNUSED;
+-                release(&ptable.lock);
+-                if (status != NULL)
+-                    *status = p->status;
+-                return pid;
+-            }
+-        }
+-
+-        // No point waiting if we don't have any children.
+-        if (!havekids || curproc->killed) {
+-            release(&ptable.lock);
+-            return -1;
+-        }
+-
+-        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+-    }
+-}
+-
+-// Wait for a child process to exit and return its pid.
+-// Return -1 if this process has no children.
+-int
+-waitpid(int pidBeingSearchedFor, int *status, int options) {
+-    struct proc *p;
+-    int doesProcExist, pidFound;
+-    struct proc *curproc = myproc();
+-    acquire(&ptable.lock);
+-    for (;;) {
+-        // Scan through table looking for exited children.
+-        doesProcExist = 0;
+-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-//            if(p->parent != curproc)
+-//                continue;
+-
+-            if (p->pid != pidBeingSearchedFor)
+-                continue;
+-
+-            doesProcExist = 1;
+-            if (p->state == ZOMBIE) {
+-                // Found one.
+-                pidFound = p->pid;
+-                kfree(p->kstack);
+-                p->kstack = 0;
+-                freevm(p->pgdir);
+-                p->pid = 0;
+-                p->parent = 0;
+-                p->name[0] = 0;
+-                p->killed = 0;
+-                p->state = UNUSED;
+-                release(&ptable.lock);
+-                if (status != NULL)
+-                    *status = p->status;
+-                return pidFound;
+-            }
+-        }
+-
+-//        // No point waiting if we don't have any children.
+-//        if(!havekids || curproc->killed){
+-//            release(&ptable.lock);
+-//            return -1;
+-//        }
+-
+-        if (!doesProcExist || curproc->killed) {
+-            release(&ptable.lock);
+-            return -1;
+-        }
+-        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+-    }
+-}
+-
+-//PAGEBREAK: 42
+-// Per-CPU process scheduler.
+-// Each CPU calls scheduler() after setting itself up.
+-// Scheduler never returns.  It loops, doing:
+-//  - choose a process to run
+-//  - swtch to start running that process
+-//  - eventually that process transfers control
+-//      via swtch back to the scheduler.
+-void
+-scheduler(void) {
+-    struct proc *p;
+-    struct cpu *c = mycpu();
+-    c->proc = 0;
+-
+-    for (;;) {
+-        // Enable interrupts on this processor.
+-        sti();
+-
+-        // Loop over process table looking for process to run.
+-        acquire(&ptable.lock);
+-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-            if (p->state != RUNNABLE)
+-                continue;
+-
+-            // Switch to chosen process.  It is the process's job
+-            // to release ptable.lock and then reacquire it
+-            // before jumping back to us.
+-            c->proc = p;
+-            switchuvm(p);
+-            p->state = RUNNING;
+-
+-            swtch(&(c->scheduler), p->context);
+-            switchkvm();
+-
+-            // Process is done running for now.
+-            // It should have changed its p->state before coming back.
+-            c->proc = 0;
+-        }
+-        release(&ptable.lock);
+-
+-    }
+-}
+-
+-// Enter scheduler.  Must hold only ptable.lock
+-// and have changed proc->state. Saves and restores
+-// intena because intena is a property of this
+-// kernel thread, not this CPU. It should
+-// be proc->intena and proc->ncli, but that would
+-// break in the few places where a lock is held but
+-// there's no process.
+-void
+-sched(void) {
+-    int intena;
+-    struct proc *p = myproc();
+-
+-    if (!holding(&ptable.lock))
+-        panic("sched ptable.lock");
+-    if (mycpu()->ncli != 1)
+-        panic("sched locks");
+-    if (p->state == RUNNING)
+-        panic("sched running");
+-    if (readeflags() & FL_IF)
+-        panic("sched interruptible");
+-    intena = mycpu()->intena;
+-    swtch(&p->context, mycpu()->scheduler);
+-    mycpu()->intena = intena;
+-}
+-
+-// Give up the CPU for one scheduling round.
+-void
+-yield(void) {
+-    acquire(&ptable.lock);  //DOC: yieldlock
+-    myproc()->state = RUNNABLE;
+-    sched();
+-    release(&ptable.lock);
+-}
+-
+-// A fork child's very first scheduling by scheduler()
+-// will swtch here.  "Return" to user space.
+-void
+-forkret(void) {
+-    static int first = 1;
+-    // Still holding ptable.lock from scheduler.
+-    release(&ptable.lock);
+-
+-    if (first) {
+-        // Some initialization functions must be run in the context
+-        // of a regular process (e.g., they call sleep), and thus cannot
+-        // be run from main().
+-        first = 0;
+-        iinit(ROOTDEV);
+-        initlog(ROOTDEV);
+-    }
+-
+-    // Return to "caller", actually trapret (see allocproc).
+-}
+-
+-// Atomically release lock and sleep on chan.
+-// Reacquires lock when awakened.
+-void
+-sleep(void *chan, struct spinlock *lk) {
+-    struct proc *p = myproc();
+-
+-    if (p == 0)
+-        panic("sleep");
+-
+-    if (lk == 0)
+-        panic("sleep without lk");
+-
+-    // Must acquire ptable.lock in order to
+-    // change p->state and then call sched.
+-    // Once we hold ptable.lock, we can be
+-    // guaranteed that we won't miss any wakeup
+-    // (wakeup runs with ptable.lock locked),
+-    // so it's okay to release lk.
+-    if (lk != &ptable.lock) {  //DOC: sleeplock0
+-        acquire(&ptable.lock);  //DOC: sleeplock1
+-        release(lk);
+-    }
+-    // Go to sleep.
+-    p->chan = chan;
+-    p->state = SLEEPING;
+-
+-    sched();
+-
+-    // Tidy up.
+-    p->chan = 0;
+-
+-    // Reacquire original lock.
+-    if (lk != &ptable.lock) {  //DOC: sleeplock2
+-        release(&ptable.lock);
+-        acquire(lk);
+-    }
+-}
+-
+-//PAGEBREAK!
+-// Wake up all processes sleeping on chan.
+-// The ptable lock must be held.
+-static void
+-wakeup1(void *chan) {
+-    struct proc *p;
+-
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-        if (p->state == SLEEPING && p->chan == chan)
+-            p->state = RUNNABLE;
+-}
+-
+-// Wake up all processes sleeping on chan.
+-void
+-wakeup(void *chan) {
+-    acquire(&ptable.lock);
+-    wakeup1(chan);
+-    release(&ptable.lock);
+-}
+-
+-// Kill the process with the given pid.
+-// Process won't exit until it returns
+-// to user space (see trap in trap.c).
+-int
+-kill(int pid) {
+-    struct proc *p;
+-
+-    acquire(&ptable.lock);
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-        if (p->pid == pid) {
+-            p->killed = 1;
+-            // Wake process from sleep if necessary.
+-            if (p->state == SLEEPING)
+-                p->state = RUNNABLE;
+-            release(&ptable.lock);
+-            return 0;
+-        }
+-    }
+-    release(&ptable.lock);
+-    return -1;
+-}
+-
+-//PAGEBREAK: 36
+-// Print a process listing to console.  For debugging.
+-// Runs when user types ^P on console.
+-// No lock to avoid wedging a stuck machine further.
+-void
+-procdump(void) {
+-    static char *states[] = {
+-            [UNUSED]    "unused",
+-            [EMBRYO]    "embryo",
+-            [SLEEPING]  "sleep ",
+-            [RUNNABLE]  "runble",
+-            [RUNNING]   "run   ",
+-            [ZOMBIE]    "zombie"
+-    };
+-    int i;
+-    struct proc *p;
+-    char *state;
+-    uint pc[10];
+-
+-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-        if (p->state == UNUSED)
+-            continue;
+-        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
+-            state = states[p->state];
+-        else
+-            state = "???";
+-        cprintf("%d %s %s", p->pid, state, p->name);
+-        if (p->state == SLEEPING) {
+-            getcallerpcs((uint *) p->context->ebp + 2, pc);
+-            for (i = 0; i < 10 && pc[i] != 0; i++)
+-                cprintf(" %p", pc[i]);
+-        }
+-        cprintf("\n");
+-    }
+-}
+diff --git a/proc.h b/proc.h
+deleted file mode 100644
+index a06b921..0000000
+--- a/proc.h
++++ /dev/null
+@@ -1,59 +0,0 @@
+-// Per-CPU state
+-struct cpu {
+-  uchar apicid;                // Local APIC ID
+-  struct context *scheduler;   // swtch() here to enter scheduler
+-  struct taskstate ts;         // Used by x86 to find stack for interrupt
+-  struct segdesc gdt[NSEGS];   // x86 global descriptor table
+-  volatile uint started;       // Has the CPU started?
+-  int ncli;                    // Depth of pushcli nesting.
+-  int intena;                  // Were interrupts enabled before pushcli?
+-  struct proc *proc;           // The process running on this cpu or null
+-};
+-
+-extern struct cpu cpus[NCPU];
+-extern int ncpu;
+-
+-//PAGEBREAK: 17
+-// Saved registers for kernel context switches.
+-// Don't need to save all the segment registers (%cs, etc),
+-// because they are constant across kernel contexts.
+-// Don't need to save %eax, %ecx, %edx, because the
+-// x86 convention is that the caller has saved them.
+-// Contexts are stored at the bottom of the stack they
+-// describe; the stack pointer is the address of the context.
+-// The layout of the context matches the layout of the stack in swtch.S
+-// at the "Switch stacks" comment. Switch doesn't save eip explicitly,
+-// but it is on the stack and allocproc() manipulates it.
+-struct context {
+-  uint edi;
+-  uint esi;
+-  uint ebx;
+-  uint ebp;
+-  uint eip;
+-};
+-
+-enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+-
+-// Per-process state
+-struct proc {
+-  uint sz;                     // Size of process memory (bytes)
+-  pde_t* pgdir;                // Page table
+-  char *kstack;                // Bottom of kernel stack for this process
+-  enum procstate state;        // Process state
+-  int pid;                     // Process ID
+-  struct proc *parent;         // Parent process
+-  struct trapframe *tf;        // Trap frame for current syscall
+-  struct context *context;     // swtch() here to run process
+-  void *chan;                  // If non-zero, sleeping on chan
+-  int killed;                  // If non-zero, have been killed
+-  struct file *ofile[NOFILE];  // Open files
+-  struct inode *cwd;           // Current directory
+-  char name[16];               // Process name (debugging)
+-  int status;                  // Exit status
+-};
+-
+-// Process memory is laid out contiguously, low addresses first:
+-//   text
+-//   original data and bss
+-//   fixed-size stack
+-//   expandable heap
+diff --git a/rm.c b/rm.c
+deleted file mode 100644
+index 1e6daec..0000000
+--- a/rm.c
++++ /dev/null
+@@ -1,23 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int i;
+-
+-  if(argc < 2){
+-    printf(2, "Usage: rm files...\n");
+-    exit(1);
+-  }
+-
+-  for(i = 1; i < argc; i++){
+-    if(unlink(argv[i]) < 0){
+-      printf(2, "rm: %s failed to delete\n", argv[i]);
+-      break;
+-    }
+-  }
+-
+-  exit(0);
+-}
+diff --git a/runoff b/runoff
+deleted file mode 100644
+index be362d0..0000000
+--- a/runoff
++++ /dev/null
+@@ -1,246 +0,0 @@
+-#!/bin/sh
+-
+-echo This script takes a minute to run.  Be patient. 1>&2
+-
+-LC_CTYPE=C export LC_CTYPE
+-
+-# pad stdin to multiple of 120 lines
+-pad()
+-{
+-	awk '{print} END{for(; NR%120!=0; NR++) print ""}'
+-}
+-
+-# create formatted (numbered) files
+-mkdir -p fmt
+-rm -f fmt/*
+-cp README fmt
+-echo > fmt/blank
+-files=`grep -v '^#' runoff.list | awk '{print $1}'`
+-n=99
+-for i in $files
+-do
+-	./runoff1 -n $n $i >fmt/$i
+-	nn=`tail -1 fmt/$i | sed 's/ .*//; s/^0*//'`
+-	if [ "x$nn" != x ]; then
+-		n=$nn
+-	fi
+-done
+-
+-# create table of contents
+-cat toc.hdr >fmt/toc
+-pr -e8 -t runoff.list | awk '
+-/^[a-z0-9]/ {
+-	s=$0
+-	f="fmt/"$1
+-	getline<f
+-	close(f)
+-	n=$1
+-	printf("%02d %s\n", n/100, s);
+-	printf("TOC: %04d %s\n", n, s) >"fmt/tocdata"
+-	next
+-}
+-{
+-	print
+-}' | pr -3 -t >>fmt/toc
+-cat toc.ftr >>fmt/toc
+-
+-# check for bad alignments
+-perl -e '
+-	$leftwarn = 0;
+-	while(<>){
+-		chomp;
+-		s!#.*!!;
+-		s!\s+! !g;
+-		s! +$!!;
+-		next if /^$/;
+-		
+-		if(/TOC: (\d+) (.*)/){
+-			$toc{$2} = $1;
+-			next;
+-		}
+-		
+-		if(/sheet1: (left|right)$/){
+-			print STDERR "assuming that sheet 1 is a $1 page.  double-check!\n";
+-			$left = $1 eq "left" ? "13579" : "02468";
+-			$right = $1 eq "left" ? "02468" : "13579";
+-			next;
+-		}
+-		
+-		if(/even: (.*)/){
+-			$file = $1;
+-			if(!defined($toc{$file})){
+-				print STDERR "Have no toc for $file\n";
+-				next;
+-			}
+-			if($toc{$file} =~ /^\d\d[^0]/){
+-				print STDERR "$file does not start on a fresh page.\n";
+-			}
+-			next;
+-		}
+-		
+-		if(/odd: (.*)/){
+-			$file = $1;
+-			if(!defined($toc{$file})){
+-				print STDERR "Have no toc for $file\n";
+-				next;
+-			}
+-			if($toc{$file} !~ /^\d\d5/){
+-				print STDERR "$file does not start on a second half page.\n";
+-			}
+-			next;
+-		}
+-		
+-		if(/(left|right): (.*)/){
+-			$what = $1;
+-			$file = $2;
+-			if(!defined($toc{$file})){
+-				print STDERR "Have no toc for $file\n";
+-				next;
+-			}
+-			if($what eq "left" && !($toc{$file} =~ /^\d[$left][05]/)){
+-				print STDERR "$file does not start on a left page [$toc{$file}]\n";
+-			}
+-			# why does this not work if I inline $x in the if?
+-			$x = ($toc{$file} =~ /^\d[$right][05]/);
+-			if($what eq "right" && !$x){
+-				print STDERR "$file does not start on a right page [$toc{$file}] [$x]\n";
+-			}
+-			next;
+-		}
+-		
+-		print STDERR "Unknown spec: $_\n";
+-	}
+-' fmt/tocdata runoff.spec
+-
+-# make definition list
+-cd fmt
+-perl -e '
+-	while(<>) {
+-		chomp;
+-
+-		s!//.*!!;
+-		s!/\*([^*]|[*][^/])*\*/!!g;
+-		s!\s! !g;
+-		s! +$!!;
+-
+-		# look for declarations like char* x;
+-		if (/^[0-9]+ typedef .* u(int|short|long|char);/) {
+-			next;
+-		}
+-		if (/^[0-9]+ extern/) {
+-			next;
+-		}
+-		if (/^[0-9]+ struct [a-zA-Z0-9_]+;/) {
+-			next;
+-		}
+-		if (/^([0-9]+) #define +([A-za-z0-9_]+) +?\(.*/) {
+-			print "$1 $2\n"
+-		}
+-		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+) +([^ ]+)/) {
+-			print "$1 $2 $3\n";
+-		}
+-		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+)/) {
+-			print "$1 $2\n";
+-		}
+-		
+-		if(/^^([0-9]+) \.globl ([a-zA-Z0-9_]+)/){
+-			$isglobl{$2} = 1;
+-		}
+-		if(/^^([0-9]+) ([a-zA-Z0-9_]+):$/ && $isglobl{$2}){
+-			print "$1 $2\n";
+-		}
+-		
+-		if (/\(/) {
+-			next;
+-		}
+-
+-		if (/^([0-9]+) (((static|struct|extern|union|enum) +)*([A-Za-z0-9_]+))( .*)? +([A-Za-z_][A-Za-z0-9_]*)(,|;|=| =)/) {
+-			print "$1 $7\n";
+-		}
+-		
+-		elsif(/^([0-9]+) (enum|struct|union) +([A-Za-z0-9_]+) +{/){ 
+-			print "$1 $3\n";
+-		}
+-		# TODO: enum members
+-	}
+-' $files >defs
+-
+-(for i in $files
+-do
+-	case "$i" in
+-	*.S)
+-		cat $i | sed 's;#.*;;; s;//.*;;;'
+-		;;
+-	*)
+-		cat $i | sed 's;//.*;;; s;"([^"\\]|\\.)*";;;'
+-	esac
+-done
+-) >alltext
+-
+-perl -n -e 'print if s/^([0-9]+ [a-zA-Z0-9_]+)\(.*$/\1/;' alltext |
+-	egrep -v ' (STUB|usage|main|if|for)$' >>defs
+-#perl -n -e 'print if s/^([0-9]+) STUB\(([a-zA-Z0-9_]+)\)$/\1 \2/;' alltext \
+-#	>>defs
+-(
+->s.defs
+-
+-# make reference list
+-for i in `awk '{print $2}' defs | sort -f | uniq`
+-do
+-	defs=`egrep '^[0-9]+ '$i'( |$)' defs | awk '{print $1}'`
+-	echo $i $defs >>s.defs
+-	uses=`egrep -h '([^a-zA-Z_0-9])'$i'($|[^a-zA-Z_0-9])' alltext | awk '{print $1}'`
+-	if [ "x$defs" != "x$uses" ]; then
+-		echo $i $defs
+-		echo $uses |fmt -29 | sed 's/^/    /'
+-#	else
+-#		echo $i defined but not used >&2
+-	fi
+-done
+-) >refs
+-
+-# build defs list
+-awk '
+-{
+-	printf("%04d %s\n", $2, $1);
+-	for(i=3; i<=NF; i++)
+-		printf("%04d    \" \n", $i);
+-}
+-' s.defs > t.defs
+-
+-# format the whole thing
+-(
+-	../pr.pl README
+-	../pr.pl -h "table of contents" toc
+-	# pr -t -2 t.defs | ../pr.pl -h "definitions" | pad
+-	pr -t -l50 -2 refs | ../pr.pl -h "cross-references" | pad
+-	# pr.pl -h "definitions" -2 t.defs | pad
+-	# pr.pl -h "cross-references" -2 refs | pad
+-	../pr.pl blank  # make sheet 1 start on left page
+-	../pr.pl blank
+-	for i in $files
+-	do
+-		../pr.pl -h "xv6/$i" $i
+-	done
+-) | mpage -m50t50b -o -bLetter -T -t -2 -FCourier -L60 >all.ps
+-grep Pages: all.ps
+-
+-# if we have the nice font, use it
+-nicefont=LucidaSans-Typewriter83
+-if [ ! -f ../$nicefont ]
+-then
+-	if git cat-file blob font:$nicefont > ../$nicefont~; then
+-		mv ../$nicefont~ ../$nicefont
+-	fi
+-fi
+-if [ -f ../$nicefont ]
+-then
+-	echo nicefont
+-	(sed 1q all.ps; cat ../$nicefont; sed "1d; s/Courier/$nicefont/" all.ps) >allf.ps
+-else
+-	echo ugly font!
+-	cp all.ps allf.ps
+-fi
+-ps2pdf allf.ps ../xv6.pdf
+-# cd ..
+-# pdftops xv6.pdf xv6.ps
+diff --git a/runoff.list b/runoff.list
+deleted file mode 100644
+index 2df9b81..0000000
+--- a/runoff.list
++++ /dev/null
+@@ -1,80 +0,0 @@
+-# basic headers
+-types.h
+-param.h
+-memlayout.h
+-defs.h
+-x86.h
+-asm.h
+-mmu.h
+-elf.h
+-date.h
+-
+-# entering xv6
+-entry.S
+-entryother.S
+-main.c
+-
+-# locks
+-spinlock.h
+-spinlock.c
+-
+-# processes
+-vm.c
+-proc.h
+-proc.c
+-swtch.S
+-kalloc.c
+-
+-# system calls
+-traps.h
+-vectors.pl
+-trapasm.S
+-trap.c
+-syscall.h
+-syscall.c
+-sysproc.c
+-
+-# file system
+-buf.h
+-sleeplock.h
+-fcntl.h
+-stat.h
+-fs.h
+-file.h
+-ide.c
+-bio.c
+-sleeplock.c
+-log.c
+-fs.c
+-file.c
+-sysfile.c
+-exec.c
+-
+-# pipes
+-pipe.c
+-
+-# string operations
+-string.c
+-
+-# low-level hardware
+-mp.h
+-mp.c
+-lapic.c
+-ioapic.c
+-kbd.h
+-kbd.c
+-console.c
+-uart.c
+-
+-# user-level
+-initcode.S
+-usys.S
+-init.c
+-sh.c
+-
+-# bootloader
+-bootasm.S
+-bootmain.c
+-
+-# link
+-kernel.ld
+diff --git a/runoff.spec b/runoff.spec
+deleted file mode 100644
+index 9247948..0000000
+--- a/runoff.spec
++++ /dev/null
+@@ -1,102 +0,0 @@
+-# Is sheet 01 (after the TOC) a left sheet or a right sheet?
+-sheet1: left
+-
+-# "left" and "right" specify which page of a two-page spread a file
+-# must start on.  "left" means that a file must start on the first of
+-# the two pages.  "right" means it must start on the second of the two
+-# pages.  The file may start in either column.
+-#
+-# "even" and "odd" specify which column a file must start on.  "even"
+-# means it must start in the left of the two columns (00).  "odd" means it
+-# must start in the right of the two columns (50).
+-#
+-# You'd think these would be the other way around.
+-
+-# types.h either
+-# param.h either
+-# defs.h either
+-# x86.h either
+-# asm.h either
+-# mmu.h either
+-# elf.h either
+-# mp.h either
+-
+-even: entry.S  # mild preference
+-even: entryother.S  # mild preference
+-even: main.c
+-# mp.c don't care at all
+-# even: initcode.S
+-# odd: init.c
+-
+-left: spinlock.h
+-even: spinlock.h
+-
+-# This gets struct proc and allocproc on the same spread
+-left: proc.h
+-even: proc.h
+-
+-# goal is to have two action-packed 2-page spreads,
+-# one with
+-#     userinit growproc fork exit wait
+-# and another with
+-#     scheduler sched yield forkret sleep wakeup1 wakeup
+-right: proc.c   # VERY important
+-even: proc.c   # VERY important
+-
+-# A few more action packed spreads
+-# page table creation and process loading
+-#     walkpgdir mappages setupkvm switch[ku]vm inituvm (loaduvm)
+-# process memory management
+-#     allocuvm deallocuvm freevm
+-left: vm.c
+-
+-even: kalloc.c  # mild preference
+-
+-# syscall.h either
+-# trapasm.S either
+-# traps.h either
+-# even: trap.c
+-# vectors.pl either
+-# syscall.c either
+-# sysproc.c either
+-
+-# buf.h either
+-# dev.h either
+-# fcntl.h either
+-# stat.h either
+-# file.h either
+-# fs.h either
+-# fsvar.h either
+-# left: ide.c # mild preference
+-even: ide.c
+-# odd: bio.c
+-
+-# log.c fits nicely in a spread
+-even: log.c
+-left: log.c
+-
+-# with fs.c starting on 2nd column of a left page, we get these 2-page spreads:
+-#	ialloc iupdate iget idup ilock iunlock iput iunlockput
+-#	bmap itrunc stati readi writei
+-#	namecmp dirlookup dirlink skipelem namex namei
+-#	fileinit filealloc filedup fileclose filestat fileread filewrite
+-# starting on 2nd column of a right page is not terrible either
+-odd: fs.c   # VERY important
+-left: fs.c  # mild preference
+-# file.c either
+-# exec.c either
+-# sysfile.c either
+-
+-# Mild preference, but makes spreads of mp.c, lapic.c, and ioapic.c+picirq.c
+-even: mp.c
+-left: mp.c
+-
+-# even: pipe.c  # mild preference
+-# string.c either
+-# left: kbd.h  # mild preference
+-even: kbd.h
+-even: console.c
+-odd: sh.c
+-
+-even: bootasm.S   # mild preference
+-even: bootmain.c  # mild preference
+diff --git a/runoff1 b/runoff1
+deleted file mode 100644
+index 532f844..0000000
+--- a/runoff1
++++ /dev/null
+@@ -1,108 +0,0 @@
+-#!/usr/bin/perl
+-
+-$n = 0;
+-$v = 0;
+-if($ARGV[0] eq "-v") {
+-	$v = 1;
+-	shift @ARGV;
+-}
+-if($ARGV[0] eq "-n") {
+-	$n = $ARGV[1];
+-	shift @ARGV;
+-	shift @ARGV;
+-}
+-$n = int(($n+49)/50)*50 - 1;
+-
+-$file = $ARGV[0];
+-@lines = <>;
+-$linenum = 0;
+-foreach (@lines) {
+-	$linenum++;
+-	chomp;
+-	s/\s+$//;
+-	if(length() >= 75){
+-		print STDERR "$file:$linenum: line too long\n";
+-	}
+-}
+-@outlines = ();
+-$nextout = 0;
+-
+-for($i=0; $i<@lines; ){
+-	# Skip leading blank lines.
+-	$i++ while $i<@lines && $lines[$i] =~ /^$/;
+-	last if $i>=@lines;
+-
+-	# If the rest of the file fits, use the whole thing.
+-	if(@lines <= $i+50 && !grep { /PAGEBREAK/ } @lines){
+-		$breakbefore = @lines;
+-	}else{
+-		# Find a good next page break;
+-		# Hope for end of function.
+-		# but settle for a blank line (but not first blank line
+-		# in function, which comes after variable declarations).
+-		$breakbefore = $i;
+-		$lastblank = $i;
+-		$sawbrace = 0;
+-		$breaksize = 15;  # 15 lines to get to function
+-		for($j=$i; $j<$i+50 && $j < @lines; $j++){
+-			if($lines[$j] =~ /PAGEBREAK!/){
+-				$lines[$j] = "";
+-				$breakbefore = $j;
+-				$breaksize = 100;
+-				last;
+-			}
+-			if($lines[$j] =~ /PAGEBREAK:\s*([0-9]+)/){
+-				$breaksize = $1;
+-				$breakbefore = $j;
+-				$lines[$j] = "";
+-			}
+-			if($lines[$j] =~ /^};?$/){
+-				$breakbefore = $j+1;
+-				$breaksize = 15;
+-			}
+-			if($lines[$j] =~ /^{$/){
+-				$sawbrace = 1;
+-			}
+-			if($lines[$j] =~ /^$/){
+-				if($sawbrace){
+-					$sawbrace = 0;
+-				}else{
+-					$lastblank = $j;
+-				}
+-			}
+-		}
+-		if($j<@lines && $lines[$j] =~ /^$/){
+-			$lastblank = $j;
+-		}
+-
+-		# If we are not putting enough on a page, try a blank line.
+-		if($breakbefore - $i < 50 - $breaksize && $lastblank > $breakbefore && $lastblank >= $i+50 - 5){
+-			if($v){
+-				print STDERR "breakbefore $breakbefore i $i breaksize $breaksize\n";
+-			}
+-			$breakbefore = $lastblank;
+-			$breaksize = 5;  # only 5 lines to get to blank line
+-		}
+-
+-		# If we are not putting enough on a page, force a full page.
+-		if($breakbefore - $i < 50 - $breaksize && $breakbefore != @lines){
+-			$breakbefore = $i + 50;
+-			$breakbefore = @lines if @lines < $breakbefore;
+-		}
+-
+-		if($breakbefore < $i+2){
+-			$breakbefore = $i+2;
+-		}
+-	}
+-
+-	# Emit the page.
+-	$i50 = $i + 50;
+-	for(; $i<$breakbefore; $i++){
+-		printf "%04d %s\n", ++$n, $lines[$i];
+-	}
+-
+-	# Finish page
+-	for($j=$i; $j<$i50; $j++){
+-		printf "%04d \n", ++$n;
+-	}
+-}
+diff --git a/sh.c b/sh.c
+deleted file mode 100644
+index ca2ae37..0000000
+--- a/sh.c
++++ /dev/null
+@@ -1,493 +0,0 @@
+-// Shell.
+-
+-#include "types.h"
+-#include "user.h"
+-#include "fcntl.h"
+-
+-// Parsed command representation
+-#define EXEC  1
+-#define REDIR 2
+-#define PIPE  3
+-#define LIST  4
+-#define BACK  5
+-
+-#define MAXARGS 10
+-
+-struct cmd {
+-  int type;
+-};
+-
+-struct execcmd {
+-  int type;
+-  char *argv[MAXARGS];
+-  char *eargv[MAXARGS];
+-};
+-
+-struct redircmd {
+-  int type;
+-  struct cmd *cmd;
+-  char *file;
+-  char *efile;
+-  int mode;
+-  int fd;
+-};
+-
+-struct pipecmd {
+-  int type;
+-  struct cmd *left;
+-  struct cmd *right;
+-};
+-
+-struct listcmd {
+-  int type;
+-  struct cmd *left;
+-  struct cmd *right;
+-};
+-
+-struct backcmd {
+-  int type;
+-  struct cmd *cmd;
+-};
+-
+-int fork1(void);  // Fork but panics on failure.
+-void panic(char*);
+-struct cmd *parsecmd(char*);
+-
+-// Execute cmd.  Never returns.
+-void
+-runcmd(struct cmd *cmd)
+-{
+-  int p[2];
+-  struct backcmd *bcmd;
+-  struct execcmd *ecmd;
+-  struct listcmd *lcmd;
+-  struct pipecmd *pcmd;
+-  struct redircmd *rcmd;
+-
+-  if(cmd == 0)
+-    exit(1);
+-
+-  switch(cmd->type){
+-  default:
+-    panic("runcmd");
+-
+-  case EXEC:
+-    ecmd = (struct execcmd*)cmd;
+-    if(ecmd->argv[0] == 0)
+-      exit(2);
+-    exec(ecmd->argv[0], ecmd->argv);
+-    printf(2, "exec %s failed\n", ecmd->argv[0]);
+-    break;
+-
+-  case REDIR:
+-    rcmd = (struct redircmd*)cmd;
+-    close(rcmd->fd);
+-    if(open(rcmd->file, rcmd->mode) < 0){
+-      printf(2, "open %s failed\n", rcmd->file);
+-      exit(6);
+-    }
+-    runcmd(rcmd->cmd);
+-    break;
+-
+-  case LIST:
+-    lcmd = (struct listcmd*)cmd;
+-    if(fork1() == 0)
+-      runcmd(lcmd->left);
+-    wait(NULL);
+-    runcmd(lcmd->right);
+-    break;
+-
+-  case PIPE:
+-    pcmd = (struct pipecmd*)cmd;
+-    if(pipe(p) < 0)
+-      panic("pipe");
+-    if(fork1() == 0){
+-      close(1);
+-      dup(p[1]);
+-      close(p[0]);
+-      close(p[1]);
+-      runcmd(pcmd->left);
+-    }
+-    if(fork1() == 0){
+-      close(0);
+-      dup(p[0]);
+-      close(p[0]);
+-      close(p[1]);
+-      runcmd(pcmd->right);
+-    }
+-    close(p[0]);
+-    close(p[1]);
+-    wait(NULL);
+-    wait(NULL);
+-    break;
+-
+-  case BACK:
+-    bcmd = (struct backcmd*)cmd;
+-    if(fork1() == 0)
+-      runcmd(bcmd->cmd);
+-    break;
+-  }
+-  exit(3);
+-}
+-
+-int
+-getcmd(char *buf, int nbuf)
+-{
+-  printf(2, "$ ");
+-  memset(buf, 0, nbuf);
+-  gets(buf, nbuf);
+-  if(buf[0] == 0) // EOF
+-    return -1;
+-  return 0;
+-}
+-
+-int
+-main(void)
+-{
+-  static char buf[100];
+-  int fd;
+-
+-  // Ensure that three file descriptors are open.
+-  while((fd = open("console", O_RDWR)) >= 0){
+-    if(fd >= 3){
+-      close(fd);
+-      break;
+-    }
+-  }
+-
+-  // Read and run input commands.
+-  while(getcmd(buf, sizeof(buf)) >= 0){
+-    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+-      // Chdir must be called by the parent, not the child.
+-      buf[strlen(buf)-1] = 0;  // chop \n
+-      if(chdir(buf+3) < 0)
+-        printf(2, "cannot cd %s\n", buf+3);
+-      continue;
+-    }
+-    if(fork1() == 0)
+-      runcmd(parsecmd(buf));
+-    wait(NULL);
+-  }
+-  exit(0);
+-}
+-
+-void
+-panic(char *s)
+-{
+-  printf(2, "%s\n", s);
+-  exit(5);
+-}
+-
+-int
+-fork1(void)
+-{
+-  int pid;
+-
+-  pid = fork();
+-  if(pid == -1)
+-    panic("fork");
+-  return pid;
+-}
+-
+-//PAGEBREAK!
+-// Constructors
+-
+-struct cmd*
+-execcmd(void)
+-{
+-  struct execcmd *cmd;
+-
+-  cmd = malloc(sizeof(*cmd));
+-  memset(cmd, 0, sizeof(*cmd));
+-  cmd->type = EXEC;
+-  return (struct cmd*)cmd;
+-}
+-
+-struct cmd*
+-redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
+-{
+-  struct redircmd *cmd;
+-
+-  cmd = malloc(sizeof(*cmd));
+-  memset(cmd, 0, sizeof(*cmd));
+-  cmd->type = REDIR;
+-  cmd->cmd = subcmd;
+-  cmd->file = file;
+-  cmd->efile = efile;
+-  cmd->mode = mode;
+-  cmd->fd = fd;
+-  return (struct cmd*)cmd;
+-}
+-
+-struct cmd*
+-pipecmd(struct cmd *left, struct cmd *right)
+-{
+-  struct pipecmd *cmd;
+-
+-  cmd = malloc(sizeof(*cmd));
+-  memset(cmd, 0, sizeof(*cmd));
+-  cmd->type = PIPE;
+-  cmd->left = left;
+-  cmd->right = right;
+-  return (struct cmd*)cmd;
+-}
+-
+-struct cmd*
+-listcmd(struct cmd *left, struct cmd *right)
+-{
+-  struct listcmd *cmd;
+-
+-  cmd = malloc(sizeof(*cmd));
+-  memset(cmd, 0, sizeof(*cmd));
+-  cmd->type = LIST;
+-  cmd->left = left;
+-  cmd->right = right;
+-  return (struct cmd*)cmd;
+-}
+-
+-struct cmd*
+-backcmd(struct cmd *subcmd)
+-{
+-  struct backcmd *cmd;
+-
+-  cmd = malloc(sizeof(*cmd));
+-  memset(cmd, 0, sizeof(*cmd));
+-  cmd->type = BACK;
+-  cmd->cmd = subcmd;
+-  return (struct cmd*)cmd;
+-}
+-//PAGEBREAK!
+-// Parsing
+-
+-char whitespace[] = " \t\r\n\v";
+-char symbols[] = "<|>&;()";
+-
+-int
+-gettoken(char **ps, char *es, char **q, char **eq)
+-{
+-  char *s;
+-  int ret;
+-
+-  s = *ps;
+-  while(s < es && strchr(whitespace, *s))
+-    s++;
+-  if(q)
+-    *q = s;
+-  ret = *s;
+-  switch(*s){
+-  case 0:
+-    break;
+-  case '|':
+-  case '(':
+-  case ')':
+-  case ';':
+-  case '&':
+-  case '<':
+-    s++;
+-    break;
+-  case '>':
+-    s++;
+-    if(*s == '>'){
+-      ret = '+';
+-      s++;
+-    }
+-    break;
+-  default:
+-    ret = 'a';
+-    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+-      s++;
+-    break;
+-  }
+-  if(eq)
+-    *eq = s;
+-
+-  while(s < es && strchr(whitespace, *s))
+-    s++;
+-  *ps = s;
+-  return ret;
+-}
+-
+-int
+-peek(char **ps, char *es, char *toks)
+-{
+-  char *s;
+-
+-  s = *ps;
+-  while(s < es && strchr(whitespace, *s))
+-    s++;
+-  *ps = s;
+-  return *s && strchr(toks, *s);
+-}
+-
+-struct cmd *parseline(char**, char*);
+-struct cmd *parsepipe(char**, char*);
+-struct cmd *parseexec(char**, char*);
+-struct cmd *nulterminate(struct cmd*);
+-
+-struct cmd*
+-parsecmd(char *s)
+-{
+-  char *es;
+-  struct cmd *cmd;
+-
+-  es = s + strlen(s);
+-  cmd = parseline(&s, es);
+-  peek(&s, es, "");
+-  if(s != es){
+-    printf(2, "leftovers: %s\n", s);
+-    panic("syntax");
+-  }
+-  nulterminate(cmd);
+-  return cmd;
+-}
+-
+-struct cmd*
+-parseline(char **ps, char *es)
+-{
+-  struct cmd *cmd;
+-
+-  cmd = parsepipe(ps, es);
+-  while(peek(ps, es, "&")){
+-    gettoken(ps, es, 0, 0);
+-    cmd = backcmd(cmd);
+-  }
+-  if(peek(ps, es, ";")){
+-    gettoken(ps, es, 0, 0);
+-    cmd = listcmd(cmd, parseline(ps, es));
+-  }
+-  return cmd;
+-}
+-
+-struct cmd*
+-parsepipe(char **ps, char *es)
+-{
+-  struct cmd *cmd;
+-
+-  cmd = parseexec(ps, es);
+-  if(peek(ps, es, "|")){
+-    gettoken(ps, es, 0, 0);
+-    cmd = pipecmd(cmd, parsepipe(ps, es));
+-  }
+-  return cmd;
+-}
+-
+-struct cmd*
+-parseredirs(struct cmd *cmd, char **ps, char *es)
+-{
+-  int tok;
+-  char *q, *eq;
+-
+-  while(peek(ps, es, "<>")){
+-    tok = gettoken(ps, es, 0, 0);
+-    if(gettoken(ps, es, &q, &eq) != 'a')
+-      panic("missing file for redirection");
+-    switch(tok){
+-    case '<':
+-      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
+-      break;
+-    case '>':
+-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+-      break;
+-    case '+':  // >>
+-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+-      break;
+-    }
+-  }
+-  return cmd;
+-}
+-
+-struct cmd*
+-parseblock(char **ps, char *es)
+-{
+-  struct cmd *cmd;
+-
+-  if(!peek(ps, es, "("))
+-    panic("parseblock");
+-  gettoken(ps, es, 0, 0);
+-  cmd = parseline(ps, es);
+-  if(!peek(ps, es, ")"))
+-    panic("syntax - missing )");
+-  gettoken(ps, es, 0, 0);
+-  cmd = parseredirs(cmd, ps, es);
+-  return cmd;
+-}
+-
+-struct cmd*
+-parseexec(char **ps, char *es)
+-{
+-  char *q, *eq;
+-  int tok, argc;
+-  struct execcmd *cmd;
+-  struct cmd *ret;
+-
+-  if(peek(ps, es, "("))
+-    return parseblock(ps, es);
+-
+-  ret = execcmd();
+-  cmd = (struct execcmd*)ret;
+-
+-  argc = 0;
+-  ret = parseredirs(ret, ps, es);
+-  while(!peek(ps, es, "|)&;")){
+-    if((tok=gettoken(ps, es, &q, &eq)) == 0)
+-      break;
+-    if(tok != 'a')
+-      panic("syntax");
+-    cmd->argv[argc] = q;
+-    cmd->eargv[argc] = eq;
+-    argc++;
+-    if(argc >= MAXARGS)
+-      panic("too many args");
+-    ret = parseredirs(ret, ps, es);
+-  }
+-  cmd->argv[argc] = 0;
+-  cmd->eargv[argc] = 0;
+-  return ret;
+-}
+-
+-// NUL-terminate all the counted strings.
+-struct cmd*
+-nulterminate(struct cmd *cmd)
+-{
+-  int i;
+-  struct backcmd *bcmd;
+-  struct execcmd *ecmd;
+-  struct listcmd *lcmd;
+-  struct pipecmd *pcmd;
+-  struct redircmd *rcmd;
+-
+-  if(cmd == 0)
+-    return 0;
+-
+-  switch(cmd->type){
+-  case EXEC:
+-    ecmd = (struct execcmd*)cmd;
+-    for(i=0; ecmd->argv[i]; i++)
+-      *ecmd->eargv[i] = 0;
+-    break;
+-
+-  case REDIR:
+-    rcmd = (struct redircmd*)cmd;
+-    nulterminate(rcmd->cmd);
+-    *rcmd->efile = 0;
+-    break;
+-
+-  case PIPE:
+-    pcmd = (struct pipecmd*)cmd;
+-    nulterminate(pcmd->left);
+-    nulterminate(pcmd->right);
+-    break;
+-
+-  case LIST:
+-    lcmd = (struct listcmd*)cmd;
+-    nulterminate(lcmd->left);
+-    nulterminate(lcmd->right);
+-    break;
+-
+-  case BACK:
+-    bcmd = (struct backcmd*)cmd;
+-    nulterminate(bcmd->cmd);
+-    break;
+-  }
+-  return cmd;
+-}
+diff --git a/show1 b/show1
+deleted file mode 100644
+index e0d3d83..0000000
+--- a/show1
++++ /dev/null
+@@ -1,3 +0,0 @@
+-#!/bin/sh
+-
+-runoff1 "$@" | pr.pl -h "xv6/$@" | mpage -m50t50b -o -bLetter -T -t -2 -FLucidaSans-Typewriter83 -L60 >x.ps; gv --swap x.ps
+diff --git a/sign.pl b/sign.pl
+deleted file mode 100644
+index d793035..0000000
+--- a/sign.pl
++++ /dev/null
+@@ -1,19 +0,0 @@
+-#!/usr/bin/perl
+-
+-open(SIG, $ARGV[0]) || die "open $ARGV[0]: $!";
+-
+-$n = sysread(SIG, $buf, 1000);
+-
+-if($n > 510){
+-  print STDERR "boot block too large: $n bytes (max 510)\n";
+-  exit 1;
+-}
+-
+-print STDERR "boot block is $n bytes (max 510)\n";
+-
+-$buf .= "\0" x (510-$n);
+-$buf .= "\x55\xAA";
+-
+-open(SIG, ">$ARGV[0]") || die "open >$ARGV[0]: $!";
+-print SIG $buf;
+-close SIG;
+diff --git a/sleep1.p b/sleep1.p
+deleted file mode 100644
+index af69772..0000000
+--- a/sleep1.p
++++ /dev/null
+@@ -1,134 +0,0 @@
+-/*
+-This file defines a Promela model for xv6's
+-acquire, release, sleep, and wakeup, along with
+-a model of a simple producer/consumer queue.
+-
+-To run:
+-	spinp sleep1.p
+-
+-(You may need to install Spin, available at http://spinroot.com/.)
+-
+-After a successful run spin prints something like:
+-
+-	unreached in proctype consumer
+-		(0 of 37 states)
+-	unreached in proctype producer
+-		(0 of 23 states)
+-
+-After an unsuccessful run, the spinp script prints
+-an execution trace that causes a deadlock.
+-
+-The safe body of producer reads:
+-
+-		acquire(lk);
+-		x = value; value = x + 1; x = 0;
+-		wakeup(0);
+-		release(lk);
+-		i = i + 1;
+-
+-If this is changed to:
+-
+-		x = value; value = x + 1; x = 0;
+-		acquire(lk);
+-		wakeup(0);
+-		release(lk);
+-		i = i + 1;
+-
+-then a deadlock can happen, because the non-atomic
+-increment of value conflicts with the non-atomic 
+-decrement in consumer, causing value to have a bad value.
+-Try this.
+-
+-If it is changed to:
+-
+-		acquire(lk);
+-		x = value; value = x + 1; x = 0;
+-		release(lk);
+-		wakeup(0);
+-		i = i + 1;
+-
+-then nothing bad happens: it is okay to wakeup after release
+-instead of before, although it seems morally wrong.
+-*/
+-
+-#define ITER 4
+-#define N 2
+-
+-bit lk;
+-byte value;
+-bit sleeping[N];
+-
+-inline acquire(x)
+-{
+-	atomic { x == 0; x = 1 }
+-}
+-
+-inline release(x)
+-{
+-	assert x==1;
+-	x = 0
+-}
+-
+-inline sleep(cond, lk)
+-{
+-	assert !sleeping[_pid];
+-	if
+-	:: cond ->
+-		skip
+-	:: else ->
+-		atomic { release(lk); sleeping[_pid] = 1 };
+-		sleeping[_pid] == 0;
+-		acquire(lk)
+-	fi
+-}
+-
+-inline wakeup()
+-{
+-	w = 0;
+-	do
+-	:: w < N ->
+-		sleeping[w] = 0;
+-		w = w + 1
+-	:: else ->
+-		break
+-	od
+-}
+-
+-active[N] proctype consumer()
+-{
+-	byte i, x;
+-	
+-	i = 0;
+-	do
+-	:: i < ITER ->
+-		acquire(lk);
+-		sleep(value > 0, lk);
+-		x = value; value = x - 1; x = 0;
+-		release(lk);
+-		i = i + 1;
+-	:: else ->
+-		break
+-	od;
+-	i = 0;
+-	skip
+-}
+-
+-active[N] proctype producer()
+-{
+-	byte i, x, w;
+-	
+-	i = 0;
+-	do
+-	:: i < ITER ->
+-		acquire(lk);
+-		x = value; value = x + 1; x = 0;
+-		release(lk);
+-		wakeup();
+-		i = i + 1;
+-	:: else ->
+-		break
+-	od;
+-	i = 0;
+-	skip	
+-}
+-
+diff --git a/sleeplock.c b/sleeplock.c
+deleted file mode 100644
+index e0750ea..0000000
+--- a/sleeplock.c
++++ /dev/null
+@@ -1,56 +0,0 @@
+-// Sleeping locks
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "x86.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-
+-void
+-initsleeplock(struct sleeplock *lk, char *name)
+-{
+-  initlock(&lk->lk, "sleep lock");
+-  lk->name = name;
+-  lk->locked = 0;
+-  lk->pid = 0;
+-}
+-
+-void
+-acquiresleep(struct sleeplock *lk)
+-{
+-  acquire(&lk->lk);
+-  while (lk->locked) {
+-    sleep(lk, &lk->lk);
+-  }
+-  lk->locked = 1;
+-  lk->pid = myproc()->pid;
+-  release(&lk->lk);
+-}
+-
+-void
+-releasesleep(struct sleeplock *lk)
+-{
+-  acquire(&lk->lk);
+-  lk->locked = 0;
+-  lk->pid = 0;
+-  wakeup(lk);
+-  release(&lk->lk);
+-}
+-
+-int
+-holdingsleep(struct sleeplock *lk)
+-{
+-  int r;
+-  
+-  acquire(&lk->lk);
+-  r = lk->locked && (lk->pid == myproc()->pid);
+-  release(&lk->lk);
+-  return r;
+-}
+-
+-
+-
+diff --git a/sleeplock.h b/sleeplock.h
+deleted file mode 100644
+index 110e6f3..0000000
+--- a/sleeplock.h
++++ /dev/null
+@@ -1,10 +0,0 @@
+-// Long-term locks for processes
+-struct sleeplock {
+-  uint locked;       // Is the lock held?
+-  struct spinlock lk; // spinlock protecting this sleep lock
+-  
+-  // For debugging:
+-  char *name;        // Name of lock.
+-  int pid;           // Process holding lock
+-};
+-
+diff --git a/spinlock.c b/spinlock.c
+deleted file mode 100644
+index 4020186..0000000
+--- a/spinlock.c
++++ /dev/null
+@@ -1,126 +0,0 @@
+-// Mutual exclusion spin locks.
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "x86.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "spinlock.h"
+-
+-void
+-initlock(struct spinlock *lk, char *name)
+-{
+-  lk->name = name;
+-  lk->locked = 0;
+-  lk->cpu = 0;
+-}
+-
+-// Acquire the lock.
+-// Loops (spins) until the lock is acquired.
+-// Holding a lock for a long time may cause
+-// other CPUs to waste time spinning to acquire it.
+-void
+-acquire(struct spinlock *lk)
+-{
+-  pushcli(); // disable interrupts to avoid deadlock.
+-  if(holding(lk))
+-    panic("acquire");
+-
+-  // The xchg is atomic.
+-  while(xchg(&lk->locked, 1) != 0)
+-    ;
+-
+-  // Tell the C compiler and the processor to not move loads or stores
+-  // past this point, to ensure that the critical section's memory
+-  // references happen after the lock is acquired.
+-  __sync_synchronize();
+-
+-  // Record info about lock acquisition for debugging.
+-  lk->cpu = mycpu();
+-  getcallerpcs(&lk, lk->pcs);
+-}
+-
+-// Release the lock.
+-void
+-release(struct spinlock *lk)
+-{
+-  if(!holding(lk))
+-    panic("release");
+-
+-  lk->pcs[0] = 0;
+-  lk->cpu = 0;
+-
+-  // Tell the C compiler and the processor to not move loads or stores
+-  // past this point, to ensure that all the stores in the critical
+-  // section are visible to other cores before the lock is released.
+-  // Both the C compiler and the hardware may re-order loads and
+-  // stores; __sync_synchronize() tells them both not to.
+-  __sync_synchronize();
+-
+-  // Release the lock, equivalent to lk->locked = 0.
+-  // This code can't use a C assignment, since it might
+-  // not be atomic. A real OS would use C atomics here.
+-  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+-
+-  popcli();
+-}
+-
+-// Record the current call stack in pcs[] by following the %ebp chain.
+-void
+-getcallerpcs(void *v, uint pcs[])
+-{
+-  uint *ebp;
+-  int i;
+-
+-  ebp = (uint*)v - 2;
+-  for(i = 0; i < 10; i++){
+-    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+-      break;
+-    pcs[i] = ebp[1];     // saved %eip
+-    ebp = (uint*)ebp[0]; // saved %ebp
+-  }
+-  for(; i < 10; i++)
+-    pcs[i] = 0;
+-}
+-
+-// Check whether this cpu is holding the lock.
+-int
+-holding(struct spinlock *lock)
+-{
+-  int r;
+-  pushcli();
+-  r = lock->locked && lock->cpu == mycpu();
+-  popcli();
+-  return r;
+-}
+-
+-
+-// Pushcli/popcli are like cli/sti except that they are matched:
+-// it takes two popcli to undo two pushcli.  Also, if interrupts
+-// are off, then pushcli, popcli leaves them off.
+-
+-void
+-pushcli(void)
+-{
+-  int eflags;
+-
+-  eflags = readeflags();
+-  cli();
+-  if(mycpu()->ncli == 0)
+-    mycpu()->intena = eflags & FL_IF;
+-  mycpu()->ncli += 1;
+-}
+-
+-void
+-popcli(void)
+-{
+-  if(readeflags()&FL_IF)
+-    panic("popcli - interruptible");
+-  if(--mycpu()->ncli < 0)
+-    panic("popcli");
+-  if(mycpu()->ncli == 0 && mycpu()->intena)
+-    sti();
+-}
+-
+diff --git a/spinlock.h b/spinlock.h
+deleted file mode 100644
+index 0a9d8e2..0000000
+--- a/spinlock.h
++++ /dev/null
+@@ -1,11 +0,0 @@
+-// Mutual exclusion lock.
+-struct spinlock {
+-  uint locked;       // Is the lock held?
+-
+-  // For debugging:
+-  char *name;        // Name of lock.
+-  struct cpu *cpu;   // The cpu holding the lock.
+-  uint pcs[10];      // The call stack (an array of program counters)
+-                     // that locked the lock.
+-};
+-
+diff --git a/spinp b/spinp
+deleted file mode 100644
+index db9614b..0000000
+--- a/spinp
++++ /dev/null
+@@ -1,16 +0,0 @@
+-#!/bin/sh
+-
+-if [ $# != 1 ] || [ ! -f "$1" ]; then
+-	echo 'usage: spinp file.p' 1>&2
+-	exit 1
+-fi
+-
+-rm -f $1.trail
+-spin -a $1 || exit 1
+-cc -DSAFETY -DREACH -DMEMLIM=500 -o pan pan.c
+-pan -i
+-rm pan.* pan
+-if [ -f $1.trail ]; then
+-	spin -t -p $1
+-fi
+-
+diff --git a/stat.h b/stat.h
+deleted file mode 100644
+index 8a80933..0000000
+--- a/stat.h
++++ /dev/null
+@@ -1,11 +0,0 @@
+-#define T_DIR  1   // Directory
+-#define T_FILE 2   // File
+-#define T_DEV  3   // Device
+-
+-struct stat {
+-  short type;  // Type of file
+-  int dev;     // File system's disk device
+-  uint ino;    // Inode number
+-  short nlink; // Number of links to file
+-  uint size;   // Size of file in bytes
+-};
+diff --git a/stressfs.c b/stressfs.c
+deleted file mode 100644
+index 46e0e66..0000000
+--- a/stressfs.c
++++ /dev/null
+@@ -1,49 +0,0 @@
+-// Demonstrate that moving the "acquire" in iderw after the loop that
+-// appends to the idequeue results in a race.
+-
+-// For this to work, you should also add a spin within iderw's
+-// idequeue traversal loop.  Adding the following demonstrated a panic
+-// after about 5 runs of stressfs in QEMU on a 2.1GHz CPU:
+-//    for (i = 0; i < 40000; i++)
+-//      asm volatile("");
+-
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-#include "fs.h"
+-#include "fcntl.h"
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int fd, i;
+-  char path[] = "stressfs0";
+-  char data[512];
+-
+-  printf(1, "stressfs starting\n");
+-  memset(data, 'a', sizeof(data));
+-
+-  for(i = 0; i < 4; i++)
+-    if(fork() > 0)
+-      break;
+-
+-  printf(1, "write %d\n", i);
+-
+-  path[8] += i;
+-  fd = open(path, O_CREATE | O_RDWR);
+-  for(i = 0; i < 20; i++)
+-//    printf(fd, "%d\n", i);
+-    write(fd, data, sizeof(data));
+-  close(fd);
+-
+-  printf(1, "read\n");
+-
+-  fd = open(path, O_RDONLY);
+-  for (i = 0; i < 20; i++)
+-    read(fd, data, sizeof(data));
+-  close(fd);
+-
+-  wait(NULL);
+-
+-  exit(0);
+-}
+diff --git a/string.c b/string.c
+deleted file mode 100644
+index a7cc61f..0000000
+--- a/string.c
++++ /dev/null
+@@ -1,105 +0,0 @@
+-#include "types.h"
+-#include "x86.h"
+-
+-void*
+-memset(void *dst, int c, uint n)
+-{
+-  if ((int)dst%4 == 0 && n%4 == 0){
+-    c &= 0xFF;
+-    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
+-  } else
+-    stosb(dst, c, n);
+-  return dst;
+-}
+-
+-int
+-memcmp(const void *v1, const void *v2, uint n)
+-{
+-  const uchar *s1, *s2;
+-
+-  s1 = v1;
+-  s2 = v2;
+-  while(n-- > 0){
+-    if(*s1 != *s2)
+-      return *s1 - *s2;
+-    s1++, s2++;
+-  }
+-
+-  return 0;
+-}
+-
+-void*
+-memmove(void *dst, const void *src, uint n)
+-{
+-  const char *s;
+-  char *d;
+-
+-  s = src;
+-  d = dst;
+-  if(s < d && s + n > d){
+-    s += n;
+-    d += n;
+-    while(n-- > 0)
+-      *--d = *--s;
+-  } else
+-    while(n-- > 0)
+-      *d++ = *s++;
+-
+-  return dst;
+-}
+-
+-// memcpy exists to placate GCC.  Use memmove.
+-void*
+-memcpy(void *dst, const void *src, uint n)
+-{
+-  return memmove(dst, src, n);
+-}
+-
+-int
+-strncmp(const char *p, const char *q, uint n)
+-{
+-  while(n > 0 && *p && *p == *q)
+-    n--, p++, q++;
+-  if(n == 0)
+-    return 0;
+-  return (uchar)*p - (uchar)*q;
+-}
+-
+-char*
+-strncpy(char *s, const char *t, int n)
+-{
+-  char *os;
+-
+-  os = s;
+-  while(n-- > 0 && (*s++ = *t++) != 0)
+-    ;
+-  while(n-- > 0)
+-    *s++ = 0;
+-  return os;
+-}
+-
+-// Like strncpy but guaranteed to NUL-terminate.
+-char*
+-safestrcpy(char *s, const char *t, int n)
+-{
+-  char *os;
+-
+-  os = s;
+-  if(n <= 0)
+-    return os;
+-  while(--n > 0 && (*s++ = *t++) != 0)
+-    ;
+-  *s = 0;
+-  return os;
+-}
+-
+-int
+-strlen(const char *s)
+-{
+-  int n;
+-
+-  for(n = 0; s[n]; n++)
+-    ;
+-  return n;
+-}
+-
+diff --git a/swtch.S b/swtch.S
+deleted file mode 100644
+index 63a7dcc..0000000
+--- a/swtch.S
++++ /dev/null
+@@ -1,29 +0,0 @@
+-# Context switch
+-#
+-#   void swtch(struct context **old, struct context *new);
+-# 
+-# Save the current registers on the stack, creating
+-# a struct context, and save its address in *old.
+-# Switch stacks to new and pop previously-saved registers.
+-
+-.globl swtch
+-swtch:
+-  movl 4(%esp), %eax
+-  movl 8(%esp), %edx
+-
+-  # Save old callee-saved registers
+-  pushl %ebp
+-  pushl %ebx
+-  pushl %esi
+-  pushl %edi
+-
+-  # Switch stacks
+-  movl %esp, (%eax)
+-  movl %edx, %esp
+-
+-  # Load new callee-saved registers
+-  popl %edi
+-  popl %esi
+-  popl %ebx
+-  popl %ebp
+-  ret
+diff --git a/syscall.c b/syscall.c
+deleted file mode 100644
+index 41a8c3c..0000000
+--- a/syscall.c
++++ /dev/null
+@@ -1,147 +0,0 @@
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-#include "syscall.h"
+-
+-// User code makes a system call with INT T_SYSCALL.
+-// System call number in %eax.
+-// Arguments on the stack, from the user call to the C
+-// library system call function. The saved user %esp points
+-// to a saved program counter, and then the first argument.
+-
+-// Fetch the int at addr from the current process.
+-int
+-fetchint(uint addr, int *ip)
+-{
+-  struct proc *curproc = myproc();
+-
+-  if(addr >= curproc->sz || addr+4 > curproc->sz)
+-    return -1;
+-  *ip = *(int*)(addr);
+-  return 0;
+-}
+-
+-// Fetch the nul-terminated string at addr from the current process.
+-// Doesn't actually copy the string - just sets *pp to point at it.
+-// Returns length of string, not including nul.
+-int
+-fetchstr(uint addr, char **pp)
+-{
+-  char *s, *ep;
+-  struct proc *curproc = myproc();
+-
+-  if(addr >= curproc->sz)
+-    return -1;
+-  *pp = (char*)addr;
+-  ep = (char*)curproc->sz;
+-  for(s = *pp; s < ep; s++){
+-    if(*s == 0)
+-      return s - *pp;
+-  }
+-  return -1;
+-}
+-
+-// Fetch the nth 32-bit system call argument.
+-int
+-argint(int n, int *ip)
+-{
+-  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+-}
+-
+-// Fetch the nth word-sized system call argument as a pointer
+-// to a block of memory of size bytes.  Check that the pointer
+-// lies within the process address space.
+-int
+-argptr(int n, char **pp, int size)
+-{
+-  int i;
+-  struct proc *curproc = myproc();
+- 
+-  if(argint(n, &i) < 0)
+-    return -1;
+-  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+-    return -1;
+-  *pp = (char*)i;
+-  return 0;
+-}
+-
+-// Fetch the nth word-sized system call argument as a string pointer.
+-// Check that the pointer is valid and the string is nul-terminated.
+-// (There is no shared writable memory, so the string can't change
+-// between this check and being used by the kernel.)
+-int
+-argstr(int n, char **pp)
+-{
+-  int addr;
+-  if(argint(n, &addr) < 0)
+-    return -1;
+-  return fetchstr(addr, pp);
+-}
+-
+-extern int sys_chdir(void);
+-extern int sys_close(void);
+-extern int sys_dup(void);
+-extern int sys_exec(void);
+-extern int sys_exit(void);
+-extern int sys_fork(void);
+-extern int sys_fstat(void);
+-extern int sys_getpid(void);
+-extern int sys_kill(void);
+-extern int sys_link(void);
+-extern int sys_mkdir(void);
+-extern int sys_mknod(void);
+-extern int sys_open(void);
+-extern int sys_pipe(void);
+-extern int sys_read(void);
+-extern int sys_sbrk(void);
+-extern int sys_sleep(void);
+-extern int sys_unlink(void);
+-extern int sys_wait(void);
+-extern int sys_waitpid(void);
+-extern int sys_write(void);
+-extern int sys_uptime(void);
+-
+-static int (*syscalls[])(void) = {
+-[SYS_fork]    sys_fork,
+-[SYS_exit]    sys_exit,
+-[SYS_wait]    sys_wait,
+-[SYS_waitpid] sys_waitpid,
+-[SYS_pipe]    sys_pipe,
+-[SYS_read]    sys_read,
+-[SYS_kill]    sys_kill,
+-[SYS_exec]    sys_exec,
+-[SYS_fstat]   sys_fstat,
+-[SYS_chdir]   sys_chdir,
+-[SYS_dup]     sys_dup,
+-[SYS_getpid]  sys_getpid,
+-[SYS_sbrk]    sys_sbrk,
+-[SYS_sleep]   sys_sleep,
+-[SYS_uptime]  sys_uptime,
+-[SYS_open]    sys_open,
+-[SYS_write]   sys_write,
+-[SYS_mknod]   sys_mknod,
+-[SYS_unlink]  sys_unlink,
+-[SYS_link]    sys_link,
+-[SYS_mkdir]   sys_mkdir,
+-[SYS_close]   sys_close,
+-};
+-
+-void
+-syscall(void)
+-{
+-  int num;
+-  struct proc *curproc = myproc();
+-
+-  num = curproc->tf->eax;
+-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+-    curproc->tf->eax = syscalls[num]();
+-  } else {
+-    cprintf("%d %s: unknown sys call %d\n",
+-            curproc->pid, curproc->name, num);
+-    curproc->tf->eax = -1;
+-  }
+-}
+diff --git a/syscall.h b/syscall.h
+deleted file mode 100644
+index 374ff05..0000000
+--- a/syscall.h
++++ /dev/null
+@@ -1,23 +0,0 @@
+-// System call numbers
+-#define SYS_fork     1
+-#define SYS_exit     2
+-#define SYS_wait     3
+-#define SYS_pipe     4
+-#define SYS_read     5
+-#define SYS_kill     6
+-#define SYS_exec     7
+-#define SYS_fstat    8
+-#define SYS_chdir    9
+-#define SYS_dup     10
+-#define SYS_getpid  11
+-#define SYS_sbrk    12
+-#define SYS_sleep   13
+-#define SYS_uptime  14
+-#define SYS_open    15
+-#define SYS_write   16
+-#define SYS_mknod   17
+-#define SYS_unlink  18
+-#define SYS_link    19
+-#define SYS_mkdir   20
+-#define SYS_close   21
+-#define SYS_waitpid 22
+\ No newline at end of file
+diff --git a/sysfile.c b/sysfile.c
+deleted file mode 100644
+index bfe61b7..0000000
+--- a/sysfile.c
++++ /dev/null
+@@ -1,444 +0,0 @@
+-//
+-// File-system system calls.
+-// Mostly argument checking, since we don't trust
+-// user code, and calls into file.c and fs.c.
+-//
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "stat.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "fs.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "file.h"
+-#include "fcntl.h"
+-
+-// Fetch the nth word-sized system call argument as a file descriptor
+-// and return both the descriptor and the corresponding struct file.
+-static int
+-argfd(int n, int *pfd, struct file **pf)
+-{
+-  int fd;
+-  struct file *f;
+-
+-  if(argint(n, &fd) < 0)
+-    return -1;
+-  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+-    return -1;
+-  if(pfd)
+-    *pfd = fd;
+-  if(pf)
+-    *pf = f;
+-  return 0;
+-}
+-
+-// Allocate a file descriptor for the given file.
+-// Takes over file reference from caller on success.
+-static int
+-fdalloc(struct file *f)
+-{
+-  int fd;
+-  struct proc *curproc = myproc();
+-
+-  for(fd = 0; fd < NOFILE; fd++){
+-    if(curproc->ofile[fd] == 0){
+-      curproc->ofile[fd] = f;
+-      return fd;
+-    }
+-  }
+-  return -1;
+-}
+-
+-int
+-sys_dup(void)
+-{
+-  struct file *f;
+-  int fd;
+-
+-  if(argfd(0, 0, &f) < 0)
+-    return -1;
+-  if((fd=fdalloc(f)) < 0)
+-    return -1;
+-  filedup(f);
+-  return fd;
+-}
+-
+-int
+-sys_read(void)
+-{
+-  struct file *f;
+-  int n;
+-  char *p;
+-
+-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+-    return -1;
+-  return fileread(f, p, n);
+-}
+-
+-int
+-sys_write(void)
+-{
+-  struct file *f;
+-  int n;
+-  char *p;
+-
+-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+-    return -1;
+-  return filewrite(f, p, n);
+-}
+-
+-int
+-sys_close(void)
+-{
+-  int fd;
+-  struct file *f;
+-
+-  if(argfd(0, &fd, &f) < 0)
+-    return -1;
+-  myproc()->ofile[fd] = 0;
+-  fileclose(f);
+-  return 0;
+-}
+-
+-int
+-sys_fstat(void)
+-{
+-  struct file *f;
+-  struct stat *st;
+-
+-  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+-    return -1;
+-  return filestat(f, st);
+-}
+-
+-// Create the path new as a link to the same inode as old.
+-int
+-sys_link(void)
+-{
+-  char name[DIRSIZ], *new, *old;
+-  struct inode *dp, *ip;
+-
+-  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
+-    return -1;
+-
+-  begin_op();
+-  if((ip = namei(old)) == 0){
+-    end_op();
+-    return -1;
+-  }
+-
+-  ilock(ip);
+-  if(ip->type == T_DIR){
+-    iunlockput(ip);
+-    end_op();
+-    return -1;
+-  }
+-
+-  ip->nlink++;
+-  iupdate(ip);
+-  iunlock(ip);
+-
+-  if((dp = nameiparent(new, name)) == 0)
+-    goto bad;
+-  ilock(dp);
+-  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+-    iunlockput(dp);
+-    goto bad;
+-  }
+-  iunlockput(dp);
+-  iput(ip);
+-
+-  end_op();
+-
+-  return 0;
+-
+-bad:
+-  ilock(ip);
+-  ip->nlink--;
+-  iupdate(ip);
+-  iunlockput(ip);
+-  end_op();
+-  return -1;
+-}
+-
+-// Is the directory dp empty except for "." and ".." ?
+-static int
+-isdirempty(struct inode *dp)
+-{
+-  int off;
+-  struct dirent de;
+-
+-  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+-      panic("isdirempty: readi");
+-    if(de.inum != 0)
+-      return 0;
+-  }
+-  return 1;
+-}
+-
+-//PAGEBREAK!
+-int
+-sys_unlink(void)
+-{
+-  struct inode *ip, *dp;
+-  struct dirent de;
+-  char name[DIRSIZ], *path;
+-  uint off;
+-
+-  if(argstr(0, &path) < 0)
+-    return -1;
+-
+-  begin_op();
+-  if((dp = nameiparent(path, name)) == 0){
+-    end_op();
+-    return -1;
+-  }
+-
+-  ilock(dp);
+-
+-  // Cannot unlink "." or "..".
+-  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+-    goto bad;
+-
+-  if((ip = dirlookup(dp, name, &off)) == 0)
+-    goto bad;
+-  ilock(ip);
+-
+-  if(ip->nlink < 1)
+-    panic("unlink: nlink < 1");
+-  if(ip->type == T_DIR && !isdirempty(ip)){
+-    iunlockput(ip);
+-    goto bad;
+-  }
+-
+-  memset(&de, 0, sizeof(de));
+-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+-    panic("unlink: writei");
+-  if(ip->type == T_DIR){
+-    dp->nlink--;
+-    iupdate(dp);
+-  }
+-  iunlockput(dp);
+-
+-  ip->nlink--;
+-  iupdate(ip);
+-  iunlockput(ip);
+-
+-  end_op();
+-
+-  return 0;
+-
+-bad:
+-  iunlockput(dp);
+-  end_op();
+-  return -1;
+-}
+-
+-static struct inode*
+-create(char *path, short type, short major, short minor)
+-{
+-  struct inode *ip, *dp;
+-  char name[DIRSIZ];
+-
+-  if((dp = nameiparent(path, name)) == 0)
+-    return 0;
+-  ilock(dp);
+-
+-  if((ip = dirlookup(dp, name, 0)) != 0){
+-    iunlockput(dp);
+-    ilock(ip);
+-    if(type == T_FILE && ip->type == T_FILE)
+-      return ip;
+-    iunlockput(ip);
+-    return 0;
+-  }
+-
+-  if((ip = ialloc(dp->dev, type)) == 0)
+-    panic("create: ialloc");
+-
+-  ilock(ip);
+-  ip->major = major;
+-  ip->minor = minor;
+-  ip->nlink = 1;
+-  iupdate(ip);
+-
+-  if(type == T_DIR){  // Create . and .. entries.
+-    dp->nlink++;  // for ".."
+-    iupdate(dp);
+-    // No ip->nlink++ for ".": avoid cyclic ref count.
+-    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+-      panic("create dots");
+-  }
+-
+-  if(dirlink(dp, name, ip->inum) < 0)
+-    panic("create: dirlink");
+-
+-  iunlockput(dp);
+-
+-  return ip;
+-}
+-
+-int
+-sys_open(void)
+-{
+-  char *path;
+-  int fd, omode;
+-  struct file *f;
+-  struct inode *ip;
+-
+-  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
+-    return -1;
+-
+-  begin_op();
+-
+-  if(omode & O_CREATE){
+-    ip = create(path, T_FILE, 0, 0);
+-    if(ip == 0){
+-      end_op();
+-      return -1;
+-    }
+-  } else {
+-    if((ip = namei(path)) == 0){
+-      end_op();
+-      return -1;
+-    }
+-    ilock(ip);
+-    if(ip->type == T_DIR && omode != O_RDONLY){
+-      iunlockput(ip);
+-      end_op();
+-      return -1;
+-    }
+-  }
+-
+-  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
+-    if(f)
+-      fileclose(f);
+-    iunlockput(ip);
+-    end_op();
+-    return -1;
+-  }
+-  iunlock(ip);
+-  end_op();
+-
+-  f->type = FD_INODE;
+-  f->ip = ip;
+-  f->off = 0;
+-  f->readable = !(omode & O_WRONLY);
+-  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+-  return fd;
+-}
+-
+-int
+-sys_mkdir(void)
+-{
+-  char *path;
+-  struct inode *ip;
+-
+-  begin_op();
+-  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
+-    end_op();
+-    return -1;
+-  }
+-  iunlockput(ip);
+-  end_op();
+-  return 0;
+-}
+-
+-int
+-sys_mknod(void)
+-{
+-  struct inode *ip;
+-  char *path;
+-  int major, minor;
+-
+-  begin_op();
+-  if((argstr(0, &path)) < 0 ||
+-     argint(1, &major) < 0 ||
+-     argint(2, &minor) < 0 ||
+-     (ip = create(path, T_DEV, major, minor)) == 0){
+-    end_op();
+-    return -1;
+-  }
+-  iunlockput(ip);
+-  end_op();
+-  return 0;
+-}
+-
+-int
+-sys_chdir(void)
+-{
+-  char *path;
+-  struct inode *ip;
+-  struct proc *curproc = myproc();
+-  
+-  begin_op();
+-  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
+-    end_op();
+-    return -1;
+-  }
+-  ilock(ip);
+-  if(ip->type != T_DIR){
+-    iunlockput(ip);
+-    end_op();
+-    return -1;
+-  }
+-  iunlock(ip);
+-  iput(curproc->cwd);
+-  end_op();
+-  curproc->cwd = ip;
+-  return 0;
+-}
+-
+-int
+-sys_exec(void)
+-{
+-  char *path, *argv[MAXARG];
+-  int i;
+-  uint uargv, uarg;
+-
+-  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
+-    return -1;
+-  }
+-  memset(argv, 0, sizeof(argv));
+-  for(i=0;; i++){
+-    if(i >= NELEM(argv))
+-      return -1;
+-    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
+-      return -1;
+-    if(uarg == 0){
+-      argv[i] = 0;
+-      break;
+-    }
+-    if(fetchstr(uarg, &argv[i]) < 0)
+-      return -1;
+-  }
+-  return exec(path, argv);
+-}
+-
+-int
+-sys_pipe(void)
+-{
+-  int *fd;
+-  struct file *rf, *wf;
+-  int fd0, fd1;
+-
+-  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
+-    return -1;
+-  if(pipealloc(&rf, &wf) < 0)
+-    return -1;
+-  fd0 = -1;
+-  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
+-    if(fd0 >= 0)
+-      myproc()->ofile[fd0] = 0;
+-    fileclose(rf);
+-    fileclose(wf);
+-    return -1;
+-  }
+-  fd[0] = fd0;
+-  fd[1] = fd1;
+-  return 0;
+-}
+diff --git a/sysproc.c b/sysproc.c
+deleted file mode 100644
+index ebccf84..0000000
+--- a/sysproc.c
++++ /dev/null
+@@ -1,97 +0,0 @@
+-#include "types.h"
+-#include "x86.h"
+-#include "defs.h"
+-#include "date.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-
+-int
+-sys_fork(void)
+-{
+-  return fork();
+-}
+-
+-int
+-sys_exit(int status)
+-{
+-  exit(status);
+-  return 0;  // not reached
+-}
+-
+-int
+-sys_wait(int* status)
+-{
+-  return wait(status);
+-}
+-
+-int
+-sys_waitpid(int pid, int* status, int options)
+-{
+-    return waitpid(pid, status, options);
+-}
+-
+-int
+-sys_kill(void)
+-{
+-  int pid;
+-
+-  if(argint(0, &pid) < 0)
+-    return -1;
+-  return kill(pid);
+-}
+-
+-int
+-sys_getpid(void)
+-{
+-  return myproc()->pid;
+-}
+-
+-int
+-sys_sbrk(void)
+-{
+-  int addr;
+-  int n;
+-
+-  if(argint(0, &n) < 0)
+-    return -1;
+-  addr = myproc()->sz;
+-  if(growproc(n) < 0)
+-    return -1;
+-  return addr;
+-}
+-
+-int
+-sys_sleep(void)
+-{
+-  int n;
+-  uint ticks0;
+-
+-  if(argint(0, &n) < 0)
+-    return -1;
+-  acquire(&tickslock);
+-  ticks0 = ticks;
+-  while(ticks - ticks0 < n){
+-    if(myproc()->killed){
+-      release(&tickslock);
+-      return -1;
+-    }
+-    sleep(&ticks, &tickslock);
+-  }
+-  release(&tickslock);
+-  return 0;
+-}
+-
+-// return how many clock tick interrupts have occurred
+-// since start.
+-int
+-sys_uptime(void)
+-{
+-  uint xticks;
+-
+-  acquire(&tickslock);
+-  xticks = ticks;
+-  release(&tickslock);
+-  return xticks;
+-}
+diff --git a/toc.ftr b/toc.ftr
+deleted file mode 100644
+index 0061c1d..0000000
+--- a/toc.ftr
++++ /dev/null
+@@ -1,13 +0,0 @@
+-
+-
+-The source listing is preceded by a cross-reference that lists every defined 
+-constant, struct, global variable, and function in xv6.  Each entry gives,
+-on the same line as the name, the line number (or, in a few cases, numbers)
+-where the name is defined.  Successive lines in an entry list the line
+-numbers where the name is used.  For example, this entry:
+-
+-    swtch 2658
+-        0374 2428 2466 2657 2658
+-
+-indicates that swtch is defined on line 2658 and is mentioned on five lines
+-on sheets 03, 24, and 26.
+diff --git a/toc.hdr b/toc.hdr
+deleted file mode 100644
+index 3698d81..0000000
+--- a/toc.hdr
++++ /dev/null
+@@ -1,6 +0,0 @@
+-The numbers to the left of the file names in the table are sheet numbers.
+-The source code has been printed in a double column format with fifty
+-lines per column, giving one hundred lines per sheet (or page).
+-Thus there is a convenient relationship between line numbers and sheet numbers.
+-
+-
 diff --git a/trap.c b/trap.c
-index 41c66eb..432ea5b 100644
+deleted file mode 100644
+index 432ea5b..0000000
 --- a/trap.c
-+++ b/trap.c
-@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
- {
-   if(tf->trapno == T_SYSCALL){
-     if(myproc()->killed)
--      exit();
-+      exit(4);
-     myproc()->tf = tf;
-     syscall();
-     if(myproc()->killed)
--      exit();
-+      exit(3);
-     return;
-   }
- 
-@@ -98,7 +98,7 @@ trap(struct trapframe *tf)
-   // (If it is still executing in the kernel, let it keep running
-   // until it gets to the regular system call return.)
-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
--    exit();
-+    exit(2);
- 
-   // Force process to give up CPU on clock tick.
-   // If interrupts were on while locks held, would need to check nlock.
-@@ -108,5 +108,5 @@ trap(struct trapframe *tf)
- 
-   // Check if the process has been killed since we yielded
-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
--    exit();
-+    exit(1);
- }
++++ /dev/null
+@@ -1,112 +0,0 @@
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-#include "traps.h"
+-#include "spinlock.h"
+-
+-// Interrupt descriptor table (shared by all CPUs).
+-struct gatedesc idt[256];
+-extern uint vectors[];  // in vectors.S: array of 256 entry pointers
+-struct spinlock tickslock;
+-uint ticks;
+-
+-void
+-tvinit(void)
+-{
+-  int i;
+-
+-  for(i = 0; i < 256; i++)
+-    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
+-  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+-
+-  initlock(&tickslock, "time");
+-}
+-
+-void
+-idtinit(void)
+-{
+-  lidt(idt, sizeof(idt));
+-}
+-
+-//PAGEBREAK: 41
+-void
+-trap(struct trapframe *tf)
+-{
+-  if(tf->trapno == T_SYSCALL){
+-    if(myproc()->killed)
+-      exit(4);
+-    myproc()->tf = tf;
+-    syscall();
+-    if(myproc()->killed)
+-      exit(3);
+-    return;
+-  }
+-
+-  switch(tf->trapno){
+-  case T_IRQ0 + IRQ_TIMER:
+-    if(cpuid() == 0){
+-      acquire(&tickslock);
+-      ticks++;
+-      wakeup(&ticks);
+-      release(&tickslock);
+-    }
+-    lapiceoi();
+-    break;
+-  case T_IRQ0 + IRQ_IDE:
+-    ideintr();
+-    lapiceoi();
+-    break;
+-  case T_IRQ0 + IRQ_IDE+1:
+-    // Bochs generates spurious IDE1 interrupts.
+-    break;
+-  case T_IRQ0 + IRQ_KBD:
+-    kbdintr();
+-    lapiceoi();
+-    break;
+-  case T_IRQ0 + IRQ_COM1:
+-    uartintr();
+-    lapiceoi();
+-    break;
+-  case T_IRQ0 + 7:
+-  case T_IRQ0 + IRQ_SPURIOUS:
+-    cprintf("cpu%d: spurious interrupt at %x:%x\n",
+-            cpuid(), tf->cs, tf->eip);
+-    lapiceoi();
+-    break;
+-
+-  //PAGEBREAK: 13
+-  default:
+-    if(myproc() == 0 || (tf->cs&3) == 0){
+-      // In kernel, it must be our mistake.
+-      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+-              tf->trapno, cpuid(), tf->eip, rcr2());
+-      panic("trap");
+-    }
+-    // In user space, assume process misbehaved.
+-    cprintf("pid %d %s: trap %d err %d on cpu %d "
+-            "eip 0x%x addr 0x%x--kill proc\n",
+-            myproc()->pid, myproc()->name, tf->trapno,
+-            tf->err, cpuid(), tf->eip, rcr2());
+-    myproc()->killed = 1;
+-  }
+-
+-  // Force process exit if it has been killed and is in user space.
+-  // (If it is still executing in the kernel, let it keep running
+-  // until it gets to the regular system call return.)
+-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+-    exit(2);
+-
+-  // Force process to give up CPU on clock tick.
+-  // If interrupts were on while locks held, would need to check nlock.
+-  if(myproc() && myproc()->state == RUNNING &&
+-     tf->trapno == T_IRQ0+IRQ_TIMER)
+-    yield();
+-
+-  // Check if the process has been killed since we yielded
+-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+-    exit(1);
+-}
+diff --git a/trapasm.S b/trapasm.S
+deleted file mode 100644
+index da8aefc..0000000
+--- a/trapasm.S
++++ /dev/null
+@@ -1,32 +0,0 @@
+-#include "mmu.h"
+-
+-  # vectors.S sends all traps here.
+-.globl alltraps
+-alltraps:
+-  # Build trap frame.
+-  pushl %ds
+-  pushl %es
+-  pushl %fs
+-  pushl %gs
+-  pushal
+-  
+-  # Set up data segments.
+-  movw $(SEG_KDATA<<3), %ax
+-  movw %ax, %ds
+-  movw %ax, %es
+-
+-  # Call trap(tf), where tf=%esp
+-  pushl %esp
+-  call trap
+-  addl $4, %esp
+-
+-  # Return falls through to trapret...
+-.globl trapret
+-trapret:
+-  popal
+-  popl %gs
+-  popl %fs
+-  popl %es
+-  popl %ds
+-  addl $0x8, %esp  # trapno and errcode
+-  iret
+diff --git a/traps.h b/traps.h
+deleted file mode 100644
+index 0bd1fd8..0000000
+--- a/traps.h
++++ /dev/null
+@@ -1,38 +0,0 @@
+-// x86 trap and interrupt constants.
+-
+-// Processor-defined:
+-#define T_DIVIDE         0      // divide error
+-#define T_DEBUG          1      // debug exception
+-#define T_NMI            2      // non-maskable interrupt
+-#define T_BRKPT          3      // breakpoint
+-#define T_OFLOW          4      // overflow
+-#define T_BOUND          5      // bounds check
+-#define T_ILLOP          6      // illegal opcode
+-#define T_DEVICE         7      // device not available
+-#define T_DBLFLT         8      // double fault
+-// #define T_COPROC      9      // reserved (not used since 486)
+-#define T_TSS           10      // invalid task switch segment
+-#define T_SEGNP         11      // segment not present
+-#define T_STACK         12      // stack exception
+-#define T_GPFLT         13      // general protection fault
+-#define T_PGFLT         14      // page fault
+-// #define T_RES        15      // reserved
+-#define T_FPERR         16      // floating point error
+-#define T_ALIGN         17      // aligment check
+-#define T_MCHK          18      // machine check
+-#define T_SIMDERR       19      // SIMD floating point error
+-
+-// These are arbitrarily chosen, but with care not to overlap
+-// processor defined exceptions or interrupt vectors.
+-#define T_SYSCALL       64      // system call
+-#define T_DEFAULT      500      // catchall
+-
+-#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ
+-
+-#define IRQ_TIMER        0
+-#define IRQ_KBD          1
+-#define IRQ_COM1         4
+-#define IRQ_IDE         14
+-#define IRQ_ERROR       19
+-#define IRQ_SPURIOUS    31
+-
+diff --git a/types.h b/types.h
+deleted file mode 100644
+index e4adf64..0000000
+--- a/types.h
++++ /dev/null
+@@ -1,4 +0,0 @@
+-typedef unsigned int   uint;
+-typedef unsigned short ushort;
+-typedef unsigned char  uchar;
+-typedef uint pde_t;
+diff --git a/uart.c b/uart.c
+deleted file mode 100644
+index b8946da..0000000
+--- a/uart.c
++++ /dev/null
+@@ -1,77 +0,0 @@
+-// Intel 8250 serial port (UART).
+-
+-#include "types.h"
+-#include "defs.h"
+-#include "param.h"
+-#include "traps.h"
+-#include "spinlock.h"
+-#include "sleeplock.h"
+-#include "fs.h"
+-#include "file.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "x86.h"
+-
+-#define COM1    0x3f8
+-
+-static int uart;    // is there a uart?
+-
+-void
+-uartinit(void)
+-{
+-  char *p;
+-
+-  // Turn off the FIFO
+-  outb(COM1+2, 0);
+-
+-  // 9600 baud, 8 data bits, 1 stop bit, parity off.
+-  outb(COM1+3, 0x80);    // Unlock divisor
+-  outb(COM1+0, 115200/9600);
+-  outb(COM1+1, 0);
+-  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
+-  outb(COM1+4, 0);
+-  outb(COM1+1, 0x01);    // Enable receive interrupts.
+-
+-  // If status is 0xFF, no serial port.
+-  if(inb(COM1+5) == 0xFF)
+-    return;
+-  uart = 1;
+-
+-  // Acknowledge pre-existing interrupt conditions;
+-  // enable interrupts.
+-  inb(COM1+2);
+-  inb(COM1+0);
+-  ioapicenable(IRQ_COM1, 0);
+-
+-  // Announce that we're here.
+-  for(p="xv6...\n"; *p; p++)
+-    uartputc(*p);
+-}
+-
+-void
+-uartputc(int c)
+-{
+-  int i;
+-
+-  if(!uart)
+-    return;
+-  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
+-    microdelay(10);
+-  outb(COM1+0, c);
+-}
+-
+-static int
+-uartgetc(void)
+-{
+-  if(!uart)
+-    return -1;
+-  if(!(inb(COM1+5) & 0x01))
+-    return -1;
+-  return inb(COM1+0);
+-}
+-
+-void
+-uartintr(void)
+-{
+-  consoleintr(uartgetc);
+-}
+diff --git a/ulib.c b/ulib.c
+deleted file mode 100644
+index 8e1e1a2..0000000
+--- a/ulib.c
++++ /dev/null
+@@ -1,106 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "fcntl.h"
+-#include "user.h"
+-#include "x86.h"
+-
+-char*
+-strcpy(char *s, const char *t)
+-{
+-  char *os;
+-
+-  os = s;
+-  while((*s++ = *t++) != 0)
+-    ;
+-  return os;
+-}
+-
+-int
+-strcmp(const char *p, const char *q)
+-{
+-  while(*p && *p == *q)
+-    p++, q++;
+-  return (uchar)*p - (uchar)*q;
+-}
+-
+-uint
+-strlen(const char *s)
+-{
+-  int n;
+-
+-  for(n = 0; s[n]; n++)
+-    ;
+-  return n;
+-}
+-
+-void*
+-memset(void *dst, int c, uint n)
+-{
+-  stosb(dst, c, n);
+-  return dst;
+-}
+-
+-char*
+-strchr(const char *s, char c)
+-{
+-  for(; *s; s++)
+-    if(*s == c)
+-      return (char*)s;
+-  return 0;
+-}
+-
+-char*
+-gets(char *buf, int max)
+-{
+-  int i, cc;
+-  char c;
+-
+-  for(i=0; i+1 < max; ){
+-    cc = read(0, &c, 1);
+-    if(cc < 1)
+-      break;
+-    buf[i++] = c;
+-    if(c == '\n' || c == '\r')
+-      break;
+-  }
+-  buf[i] = '\0';
+-  return buf;
+-}
+-
+-int
+-stat(const char *n, struct stat *st)
+-{
+-  int fd;
+-  int r;
+-
+-  fd = open(n, O_RDONLY);
+-  if(fd < 0)
+-    return -1;
+-  r = fstat(fd, st);
+-  close(fd);
+-  return r;
+-}
+-
+-int
+-atoi(const char *s)
+-{
+-  int n;
+-
+-  n = 0;
+-  while('0' <= *s && *s <= '9')
+-    n = n*10 + *s++ - '0';
+-  return n;
+-}
+-
+-void*
+-memmove(void *vdst, const void *vsrc, int n)
+-{
+-  char *dst;
+-  const char *src;
+-
+-  dst = vdst;
+-  src = vsrc;
+-  while(n-- > 0)
+-    *dst++ = *src++;
+-  return vdst;
+-}
+diff --git a/umalloc.c b/umalloc.c
+deleted file mode 100644
+index a7e7d2c..0000000
+--- a/umalloc.c
++++ /dev/null
+@@ -1,90 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-#include "param.h"
+-
+-// Memory allocator by Kernighan and Ritchie,
+-// The C programming Language, 2nd ed.  Section 8.7.
+-
+-typedef long Align;
+-
+-union header {
+-  struct {
+-    union header *ptr;
+-    uint size;
+-  } s;
+-  Align x;
+-};
+-
+-typedef union header Header;
+-
+-static Header base;
+-static Header *freep;
+-
+-void
+-free(void *ap)
+-{
+-  Header *bp, *p;
+-
+-  bp = (Header*)ap - 1;
+-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+-      break;
+-  if(bp + bp->s.size == p->s.ptr){
+-    bp->s.size += p->s.ptr->s.size;
+-    bp->s.ptr = p->s.ptr->s.ptr;
+-  } else
+-    bp->s.ptr = p->s.ptr;
+-  if(p + p->s.size == bp){
+-    p->s.size += bp->s.size;
+-    p->s.ptr = bp->s.ptr;
+-  } else
+-    p->s.ptr = bp;
+-  freep = p;
+-}
+-
+-static Header*
+-morecore(uint nu)
+-{
+-  char *p;
+-  Header *hp;
+-
+-  if(nu < 4096)
+-    nu = 4096;
+-  p = sbrk(nu * sizeof(Header));
+-  if(p == (char*)-1)
+-    return 0;
+-  hp = (Header*)p;
+-  hp->s.size = nu;
+-  free((void*)(hp + 1));
+-  return freep;
+-}
+-
+-void*
+-malloc(uint nbytes)
+-{
+-  Header *p, *prevp;
+-  uint nunits;
+-
+-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+-  if((prevp = freep) == 0){
+-    base.s.ptr = freep = prevp = &base;
+-    base.s.size = 0;
+-  }
+-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+-    if(p->s.size >= nunits){
+-      if(p->s.size == nunits)
+-        prevp->s.ptr = p->s.ptr;
+-      else {
+-        p->s.size -= nunits;
+-        p += p->s.size;
+-        p->s.size = nunits;
+-      }
+-      freep = prevp;
+-      return (void*)(p + 1);
+-    }
+-    if(p == freep)
+-      if((p = morecore(nunits)) == 0)
+-        return 0;
+-  }
+-}
 diff --git a/user.h b/user.h
-index 4f99c52..0931387 100644
+deleted file mode 100644
+index 0931387..0000000
 --- a/user.h
-+++ b/user.h
-@@ -1,10 +1,13 @@
-+#include <stddef.h>
-+
- struct stat;
- struct rtcdate;
- 
- // system calls
- int fork(void);
--int exit(void) __attribute__((noreturn));
--int wait(void);
-+int exit(int status) __attribute__((noreturn));
-+int wait(int* status);
-+int waitpid(int pid, int* status, int options);
- int pipe(int*);
- int write(int, const void*, int);
- int read(int, void*, int);
++++ /dev/null
+@@ -1,42 +0,0 @@
+-#include <stddef.h>
+-
+-struct stat;
+-struct rtcdate;
+-
+-// system calls
+-int fork(void);
+-int exit(int status) __attribute__((noreturn));
+-int wait(int* status);
+-int waitpid(int pid, int* status, int options);
+-int pipe(int*);
+-int write(int, const void*, int);
+-int read(int, void*, int);
+-int close(int);
+-int kill(int);
+-int exec(char*, char**);
+-int open(const char*, int);
+-int mknod(const char*, short, short);
+-int unlink(const char*);
+-int fstat(int fd, struct stat*);
+-int link(const char*, const char*);
+-int mkdir(const char*);
+-int chdir(const char*);
+-int dup(int);
+-int getpid(void);
+-char* sbrk(int);
+-int sleep(int);
+-int uptime(void);
+-
+-// ulib.c
+-int stat(const char*, struct stat*);
+-char* strcpy(char*, const char*);
+-void *memmove(void*, const void*, int);
+-char* strchr(const char*, char c);
+-int strcmp(const char*, const char*);
+-void printf(int, const char*, ...);
+-char* gets(char*, int max);
+-uint strlen(const char*);
+-void* memset(void*, int, uint);
+-void* malloc(uint);
+-void free(void*);
+-int atoi(const char*);
 diff --git a/usertests.c b/usertests.c
-index a1e97e7..2c2c128 100644
+deleted file mode 100644
+index 2c2c128..0000000
 --- a/usertests.c
-+++ b/usertests.c
-@@ -21,19 +21,19 @@ iputtest(void)
- 
-   if(mkdir("iputdir") < 0){
-     printf(stdout, "mkdir failed\n");
--    exit();
-+    exit(184);
-   }
-   if(chdir("iputdir") < 0){
-     printf(stdout, "chdir iputdir failed\n");
--    exit();
-+    exit(183);
-   }
-   if(unlink("../iputdir") < 0){
-     printf(stdout, "unlink ../iputdir failed\n");
--    exit();
-+    exit(182);
-   }
-   if(chdir("/") < 0){
-     printf(stdout, "chdir / failed\n");
--    exit();
-+    exit(181);
-   }
-   printf(stdout, "iput test ok\n");
- }
-@@ -49,24 +49,24 @@ exitiputtest(void)
-   pid = fork();
-   if(pid < 0){
-     printf(stdout, "fork failed\n");
--    exit();
-+    exit(180);
-   }
-   if(pid == 0){
-     if(mkdir("iputdir") < 0){
-       printf(stdout, "mkdir failed\n");
--      exit();
-+      exit(179);
-     }
-     if(chdir("iputdir") < 0){
-       printf(stdout, "child chdir failed\n");
--      exit();
-+      exit(178);
-     }
-     if(unlink("../iputdir") < 0){
-       printf(stdout, "unlink ../iputdir failed\n");
--      exit();
-+      exit(177);
-     }
--    exit();
-+    exit(176);
-   }
--  wait();
-+  wait(NULL);
-   printf(stdout, "exitiput test ok\n");
- }
- 
-@@ -89,27 +89,27 @@ openiputtest(void)
-   printf(stdout, "openiput test\n");
-   if(mkdir("oidir") < 0){
-     printf(stdout, "mkdir oidir failed\n");
--    exit();
-+    exit(175);
-   }
-   pid = fork();
-   if(pid < 0){
-     printf(stdout, "fork failed\n");
--    exit();
-+    exit(174);
-   }
-   if(pid == 0){
-     int fd = open("oidir", O_RDWR);
-     if(fd >= 0){
-       printf(stdout, "open directory for write succeeded\n");
--      exit();
-+      exit(0);
-     }
--    exit();
-+    exit(172);
-   }
-   sleep(1);
-   if(unlink("oidir") != 0){
-     printf(stdout, "unlink failed\n");
--    exit();
-+    exit(171);
-   }
--  wait();
-+  wait(NULL);
-   printf(stdout, "openiput test ok\n");
- }
- 
-@@ -124,13 +124,13 @@ opentest(void)
-   fd = open("echo", 0);
-   if(fd < 0){
-     printf(stdout, "open echo failed!\n");
--    exit();
-+    exit(170);
-   }
-   close(fd);
-   fd = open("doesnotexist", 0);
-   if(fd >= 0){
-     printf(stdout, "open doesnotexist succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   printf(stdout, "open test ok\n");
- }
-@@ -147,16 +147,16 @@ writetest(void)
-     printf(stdout, "creat small succeeded; ok\n");
-   } else {
-     printf(stdout, "error: creat small failed!\n");
--    exit();
-+    exit(168);
-   }
-   for(i = 0; i < 100; i++){
-     if(write(fd, "aaaaaaaaaa", 10) != 10){
-       printf(stdout, "error: write aa %d new file failed\n", i);
--      exit();
-+      exit(167);
-     }
-     if(write(fd, "bbbbbbbbbb", 10) != 10){
-       printf(stdout, "error: write bb %d new file failed\n", i);
--      exit();
-+      exit(166);
-     }
-   }
-   printf(stdout, "writes ok\n");
-@@ -166,20 +166,20 @@ writetest(void)
-     printf(stdout, "open small succeeded ok\n");
-   } else {
-     printf(stdout, "error: open small failed!\n");
--    exit();
-+    exit(165);
-   }
-   i = read(fd, buf, 2000);
-   if(i == 2000){
-     printf(stdout, "read succeeded ok\n");
-   } else {
-     printf(stdout, "read failed\n");
--    exit();
-+    exit(164);
-   }
-   close(fd);
- 
-   if(unlink("small") < 0){
-     printf(stdout, "unlink small failed\n");
--    exit();
-+    exit(163);
-   }
-   printf(stdout, "small file test ok\n");
- }
-@@ -194,14 +194,14 @@ writetest1(void)
-   fd = open("big", O_CREATE|O_RDWR);
-   if(fd < 0){
-     printf(stdout, "error: creat big failed!\n");
--    exit();
-+    exit(162);
-   }
- 
-   for(i = 0; i < MAXFILE; i++){
-     ((int*)buf)[0] = i;
-     if(write(fd, buf, 512) != 512){
-       printf(stdout, "error: write big file failed\n", i);
--      exit();
-+      exit(161);
-     }
-   }
- 
-@@ -210,7 +210,7 @@ writetest1(void)
-   fd = open("big", O_RDONLY);
-   if(fd < 0){
-     printf(stdout, "error: open big failed!\n");
--    exit();
-+    exit(160);
-   }
- 
-   n = 0;
-@@ -219,24 +219,24 @@ writetest1(void)
-     if(i == 0){
-       if(n == MAXFILE - 1){
-         printf(stdout, "read only %d blocks from big", n);
--        exit();
-+        exit(159);
-       }
-       break;
-     } else if(i != 512){
-       printf(stdout, "read failed %d\n", i);
--      exit();
-+      exit(158);
-     }
-     if(((int*)buf)[0] != n){
-       printf(stdout, "read content of block %d is %d\n",
-              n, ((int*)buf)[0]);
--      exit();
-+      exit(157);
-     }
-     n++;
-   }
-   close(fd);
-   if(unlink("big") < 0){
-     printf(stdout, "unlink big failed\n");
--    exit();
-+    exit(156);
-   }
-   printf(stdout, "big files ok\n");
- }
-@@ -270,22 +270,22 @@ void dirtest(void)
- 
-   if(mkdir("dir0") < 0){
-     printf(stdout, "mkdir failed\n");
--    exit();
-+    exit(155);
-   }
- 
-   if(chdir("dir0") < 0){
-     printf(stdout, "chdir dir0 failed\n");
--    exit();
-+    exit(154);
-   }
- 
-   if(chdir("..") < 0){
-     printf(stdout, "chdir .. failed\n");
--    exit();
-+    exit(153);
-   }
- 
-   if(unlink("dir0") < 0){
-     printf(stdout, "unlink dir0 failed\n");
--    exit();
-+    exit(152);
-   }
-   printf(stdout, "mkdir test ok\n");
- }
-@@ -296,7 +296,7 @@ exectest(void)
-   printf(stdout, "exec test\n");
-   if(exec("echo", echoargv) < 0){
-     printf(stdout, "exec echo failed\n");
--    exit();
-+    exit(151);
-   }
- }
- 
-@@ -310,7 +310,7 @@ pipe1(void)
- 
-   if(pipe(fds) != 0){
-     printf(1, "pipe() failed\n");
--    exit();
-+    exit(150);
-   }
-   pid = fork();
-   seq = 0;
-@@ -321,10 +321,10 @@ pipe1(void)
-         buf[i] = seq++;
-       if(write(fds[1], buf, 1033) != 1033){
-         printf(1, "pipe1 oops 1\n");
--        exit();
-+        exit(149);
-       }
-     }
--    exit();
-+    exit(148);
-   } else if(pid > 0){
-     close(fds[1]);
-     total = 0;
-@@ -343,13 +343,13 @@ pipe1(void)
-     }
-     if(total != 5 * 1033){
-       printf(1, "pipe1 oops 3 total %d\n", total);
--      exit();
-+      exit(147);
-     }
-     close(fds[0]);
--    wait();
-+    wait(NULL);
-   } else {
-     printf(1, "fork() failed\n");
--    exit();
-+    exit(146);
-   }
-   printf(1, "pipe1 ok\n");
- }
-@@ -394,9 +394,9 @@ preempt(void)
-   kill(pid2);
-   kill(pid3);
-   printf(1, "wait... ");
--  wait();
--  wait();
--  wait();
-+  wait(NULL);
-+  wait(NULL);
-+  wait(NULL);
-   printf(1, "preempt ok\n");
- }
- 
-@@ -413,12 +413,12 @@ exitwait(void)
-       return;
-     }
-     if(pid){
--      if(wait() != pid){
-+      if(wait(NULL) != pid){
-         printf(1, "wait wrong pid\n");
-         return;
-       }
-     } else {
--      exit();
-+      exit(145);
-     }
-   }
-   printf(1, "exitwait ok\n");
-@@ -447,13 +447,13 @@ mem(void)
-     if(m1 == 0){
-       printf(1, "couldn't allocate mem?!!\n");
-       kill(ppid);
--      exit();
-+      exit(144);
-     }
-     free(m1);
-     printf(1, "mem ok\n");
--    exit();
-+    exit(0);
-   } else {
--    wait();
-+    wait(NULL);
-   }
- }
- 
-@@ -484,9 +484,9 @@ sharedfd(void)
-     }
-   }
-   if(pid == 0)
--    exit();
-+    exit(142);
-   else
--    wait();
-+    wait(NULL);
-   close(fd);
-   fd = open("sharedfd", 0);
-   if(fd < 0){
-@@ -508,7 +508,7 @@ sharedfd(void)
-     printf(1, "sharedfd ok\n");
-   } else {
-     printf(1, "sharedfd oops %d %d\n", nc, np);
--    exit();
-+    exit(141);
-   }
- }
- 
-@@ -530,29 +530,29 @@ fourfiles(void)
-     pid = fork();
-     if(pid < 0){
-       printf(1, "fork failed\n");
--      exit();
-+      exit(140);
-     }
- 
-     if(pid == 0){
-       fd = open(fname, O_CREATE | O_RDWR);
-       if(fd < 0){
-         printf(1, "create failed\n");
--        exit();
-+        exit(139);
-       }
- 
-       memset(buf, '0'+pi, 512);
-       for(i = 0; i < 12; i++){
-         if((n = write(fd, buf, 500)) != 500){
-           printf(1, "write failed %d\n", n);
--          exit();
-+          exit(138);
-         }
-       }
--      exit();
-+      exit(137);
-     }
-   }
- 
-   for(pi = 0; pi < 4; pi++){
--    wait();
-+    wait(NULL);
-   }
- 
-   for(i = 0; i < 2; i++){
-@@ -563,7 +563,7 @@ fourfiles(void)
-       for(j = 0; j < n; j++){
-         if(buf[j] != '0'+i){
-           printf(1, "wrong char\n");
--          exit();
-+          exit(136);
-         }
-       }
-       total += n;
-@@ -571,7 +571,7 @@ fourfiles(void)
-     close(fd);
-     if(total != 12*500){
-       printf(1, "wrong length %d\n", total);
--      exit();
-+      exit(135);
-     }
-     unlink(fname);
-   }
-@@ -593,7 +593,7 @@ createdelete(void)
-     pid = fork();
-     if(pid < 0){
-       printf(1, "fork failed\n");
--      exit();
-+      exit(134);
-     }
- 
-     if(pid == 0){
-@@ -604,23 +604,23 @@ createdelete(void)
-         fd = open(name, O_CREATE | O_RDWR);
-         if(fd < 0){
-           printf(1, "create failed\n");
--          exit();
-+          exit(133);
-         }
-         close(fd);
-         if(i > 0 && (i % 2 ) == 0){
-           name[1] = '0' + (i / 2);
-           if(unlink(name) < 0){
-             printf(1, "unlink failed\n");
--            exit();
-+            exit(132);
-           }
-         }
-       }
--      exit();
-+      exit(131);
-     }
-   }
- 
-   for(pi = 0; pi < 4; pi++){
--    wait();
-+    wait(NULL);
-   }
- 
-   name[0] = name[1] = name[2] = 0;
-@@ -631,10 +631,10 @@ createdelete(void)
-       fd = open(name, 0);
-       if((i == 0 || i >= N/2) && fd < 0){
-         printf(1, "oops createdelete %s didn't exist\n", name);
--        exit();
-+        exit(130);
-       } else if((i >= 1 && i < N/2) && fd >= 0){
-         printf(1, "oops createdelete %s did exist\n", name);
--        exit();
-+        exit(129);
-       }
-       if(fd >= 0)
-         close(fd);
-@@ -662,7 +662,7 @@ unlinkread(void)
-   fd = open("unlinkread", O_CREATE | O_RDWR);
-   if(fd < 0){
-     printf(1, "create unlinkread failed\n");
--    exit();
-+    exit(128);
-   }
-   write(fd, "hello", 5);
-   close(fd);
-@@ -670,11 +670,11 @@ unlinkread(void)
-   fd = open("unlinkread", O_RDWR);
-   if(fd < 0){
-     printf(1, "open unlinkread failed\n");
--    exit();
-+    exit(127);
-   }
-   if(unlink("unlinkread") != 0){
-     printf(1, "unlink unlinkread failed\n");
--    exit();
-+    exit(126);
-   }
- 
-   fd1 = open("unlinkread", O_CREATE | O_RDWR);
-@@ -683,15 +683,15 @@ unlinkread(void)
- 
-   if(read(fd, buf, sizeof(buf)) != 5){
-     printf(1, "unlinkread read failed");
--    exit();
-+    exit(125);
-   }
-   if(buf[0] != 'h'){
-     printf(1, "unlinkread wrong data\n");
--    exit();
-+    exit(124);
-   }
-   if(write(fd, buf, 10) != 10){
-     printf(1, "unlinkread write failed\n");
--    exit();
-+    exit(123);
-   }
-   close(fd);
-   unlink("unlinkread");
-@@ -711,50 +711,50 @@ linktest(void)
-   fd = open("lf1", O_CREATE|O_RDWR);
-   if(fd < 0){
-     printf(1, "create lf1 failed\n");
--    exit();
-+    exit(122);
-   }
-   if(write(fd, "hello", 5) != 5){
-     printf(1, "write lf1 failed\n");
--    exit();
-+    exit(121);
-   }
-   close(fd);
- 
-   if(link("lf1", "lf2") < 0){
-     printf(1, "link lf1 lf2 failed\n");
--    exit();
-+    exit(120);
-   }
-   unlink("lf1");
- 
-   if(open("lf1", 0) >= 0){
-     printf(1, "unlinked lf1 but it is still there!\n");
--    exit();
-+    exit(119);
-   }
- 
-   fd = open("lf2", 0);
-   if(fd < 0){
-     printf(1, "open lf2 failed\n");
--    exit();
-+    exit(118);
-   }
-   if(read(fd, buf, sizeof(buf)) != 5){
-     printf(1, "read lf2 failed\n");
--    exit();
-+    exit(117);
-   }
-   close(fd);
- 
-   if(link("lf2", "lf2") >= 0){
-     printf(1, "link lf2 lf2 succeeded! oops\n");
--    exit();
-+    exit(116);
-   }
- 
-   unlink("lf2");
-   if(link("lf2", "lf1") >= 0){
-     printf(1, "link non-existant succeeded! oops\n");
--    exit();
-+    exit(115);
-   }
- 
-   if(link(".", "lf1") >= 0){
-     printf(1, "link . lf1 succeeded! oops\n");
--    exit();
-+    exit(114);
-   }
- 
-   printf(1, "linktest ok\n");
-@@ -787,14 +787,14 @@ concreate(void)
-       fd = open(file, O_CREATE | O_RDWR);
-       if(fd < 0){
-         printf(1, "concreate create %s failed\n", file);
--        exit();
-+        exit(113);
-       }
-       close(fd);
-     }
-     if(pid == 0)
--      exit();
-+      exit(112);
-     else
--      wait();
-+      wait(NULL);
-   }
- 
-   memset(fa, 0, sizeof(fa));
-@@ -807,11 +807,11 @@ concreate(void)
-       i = de.name[1] - '0';
-       if(i < 0 || i >= sizeof(fa)){
-         printf(1, "concreate weird file %s\n", de.name);
--        exit();
-+        exit(111);
-       }
-       if(fa[i]){
-         printf(1, "concreate duplicate file %s\n", de.name);
--        exit();
-+        exit(110);
-       }
-       fa[i] = 1;
-       n++;
-@@ -821,7 +821,7 @@ concreate(void)
- 
-   if(n != 40){
-     printf(1, "concreate not enough files in directory listing\n");
--    exit();
-+    exit(109);
-   }
- 
-   for(i = 0; i < 40; i++){
-@@ -829,7 +829,7 @@ concreate(void)
-     pid = fork();
-     if(pid < 0){
-       printf(1, "fork failed\n");
--      exit();
-+      exit(108);
-     }
-     if(((i % 3) == 0 && pid == 0) ||
-        ((i % 3) == 1 && pid != 0)){
-@@ -844,9 +844,9 @@ concreate(void)
-       unlink(file);
-     }
-     if(pid == 0)
--      exit();
-+      exit(107);
-     else
--      wait();
-+      wait(NULL);
-   }
- 
-   printf(1, "concreate ok\n");
-@@ -865,7 +865,7 @@ linkunlink()
-   pid = fork();
-   if(pid < 0){
-     printf(1, "fork failed\n");
--    exit();
-+    exit(106);
-   }
- 
-   unsigned int x = (pid ? 1 : 97);
-@@ -881,9 +881,9 @@ linkunlink()
-   }
- 
-   if(pid)
--    wait();
-+    wait(NULL);
-   else
--    exit();
-+    exit(105);
- 
-   printf(1, "linkunlink ok\n");
- }
-@@ -901,7 +901,7 @@ bigdir(void)
-   fd = open("bd", O_CREATE);
-   if(fd < 0){
-     printf(1, "bigdir create failed\n");
--    exit();
-+    exit(104);
-   }
-   close(fd);
- 
-@@ -912,7 +912,7 @@ bigdir(void)
-     name[3] = '\0';
-     if(link("bd", name) != 0){
-       printf(1, "bigdir link failed\n");
--      exit();
-+      exit(103);
-     }
-   }
- 
-@@ -924,7 +924,7 @@ bigdir(void)
-     name[3] = '\0';
-     if(unlink(name) != 0){
-       printf(1, "bigdir unlink failed");
--      exit();
-+      exit(102);
-     }
-   }
- 
-@@ -941,31 +941,31 @@ subdir(void)
-   unlink("ff");
-   if(mkdir("dd") != 0){
-     printf(1, "subdir mkdir dd failed\n");
--    exit();
-+    exit(101);
-   }
- 
-   fd = open("dd/ff", O_CREATE | O_RDWR);
-   if(fd < 0){
-     printf(1, "create dd/ff failed\n");
--    exit();
-+    exit(100);
-   }
-   write(fd, "ff", 2);
-   close(fd);
- 
-   if(unlink("dd") >= 0){
-     printf(1, "unlink dd (non-empty dir) succeeded!\n");
--    exit();
-+    exit(99);
-   }
- 
-   if(mkdir("/dd/dd") != 0){
-     printf(1, "subdir mkdir dd/dd failed\n");
--    exit();
-+    exit(98);
-   }
- 
-   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
-   if(fd < 0){
-     printf(1, "create dd/dd/ff failed\n");
--    exit();
-+    exit(97);
-   }
-   write(fd, "FF", 2);
-   close(fd);
-@@ -973,142 +973,142 @@ subdir(void)
-   fd = open("dd/dd/../ff", 0);
-   if(fd < 0){
-     printf(1, "open dd/dd/../ff failed\n");
--    exit();
-+    exit(96);
-   }
-   cc = read(fd, buf, sizeof(buf));
-   if(cc != 2 || buf[0] != 'f'){
-     printf(1, "dd/dd/../ff wrong content\n");
--    exit();
-+    exit(95);
-   }
-   close(fd);
- 
-   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
-     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
--    exit();
-+    exit(94);
-   }
- 
-   if(unlink("dd/dd/ff") != 0){
-     printf(1, "unlink dd/dd/ff failed\n");
--    exit();
-+    exit(93);
-   }
-   if(open("dd/dd/ff", O_RDONLY) >= 0){
-     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
--    exit();
-+    exit(92);
-   }
- 
-   if(chdir("dd") != 0){
-     printf(1, "chdir dd failed\n");
--    exit();
-+    exit(91);
-   }
-   if(chdir("dd/../../dd") != 0){
-     printf(1, "chdir dd/../../dd failed\n");
--    exit();
-+    exit(90);
-   }
-   if(chdir("dd/../../../dd") != 0){
-     printf(1, "chdir dd/../../dd failed\n");
--    exit();
-+    exit(89);
-   }
-   if(chdir("./..") != 0){
-     printf(1, "chdir ./.. failed\n");
--    exit();
-+    exit(88);
-   }
- 
-   fd = open("dd/dd/ffff", 0);
-   if(fd < 0){
-     printf(1, "open dd/dd/ffff failed\n");
--    exit();
-+    exit(87);
-   }
-   if(read(fd, buf, sizeof(buf)) != 2){
-     printf(1, "read dd/dd/ffff wrong len\n");
--    exit();
-+    exit(86);
-   }
-   close(fd);
- 
-   if(open("dd/dd/ff", O_RDONLY) >= 0){
-     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
- 
-   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
-     printf(1, "create dd/ff/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
-     printf(1, "create dd/xx/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(open("dd", O_CREATE) >= 0){
-     printf(1, "create dd succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(open("dd", O_RDWR) >= 0){
-     printf(1, "open dd rdwr succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(open("dd", O_WRONLY) >= 0){
-     printf(1, "open dd wronly succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(link("dd/ff/ff", "dd/dd/xx") == 0){
-     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(link("dd/xx/ff", "dd/dd/xx") == 0){
-     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(link("dd/ff", "dd/dd/ffff") == 0){
-     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(mkdir("dd/ff/ff") == 0){
-     printf(1, "mkdir dd/ff/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(mkdir("dd/xx/ff") == 0){
-     printf(1, "mkdir dd/xx/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(mkdir("dd/dd/ffff") == 0){
-     printf(1, "mkdir dd/dd/ffff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dd/xx/ff") == 0){
-     printf(1, "unlink dd/xx/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dd/ff/ff") == 0){
-     printf(1, "unlink dd/ff/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(chdir("dd/ff") == 0){
-     printf(1, "chdir dd/ff succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(chdir("dd/xx") == 0){
-     printf(1, "chdir dd/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
- 
-   if(unlink("dd/dd/ffff") != 0){
-     printf(1, "unlink dd/dd/ff failed\n");
--    exit();
-+    exit(68);
-   }
-   if(unlink("dd/ff") != 0){
-     printf(1, "unlink dd/ff failed\n");
--    exit();
-+    exit(67);
-   }
-   if(unlink("dd") == 0){
-     printf(1, "unlink non-empty dd succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dd/dd") < 0){
-     printf(1, "unlink dd/dd failed\n");
--    exit();
-+    exit(65);
-   }
-   if(unlink("dd") < 0){
-     printf(1, "unlink dd failed\n");
--    exit();
-+    exit(64);
-   }
- 
-   printf(1, "subdir ok\n");
-@@ -1127,14 +1127,14 @@ bigwrite(void)
-     fd = open("bigwrite", O_CREATE | O_RDWR);
-     if(fd < 0){
-       printf(1, "cannot create bigwrite\n");
--      exit();
-+      exit(63);
-     }
-     int i;
-     for(i = 0; i < 2; i++){
-       int cc = write(fd, buf, sz);
-       if(cc != sz){
-         printf(1, "write(%d) ret %d\n", sz, cc);
--        exit();
-+        exit(62);
-       }
-     }
-     close(fd);
-@@ -1155,13 +1155,13 @@ bigfile(void)
-   fd = open("bigfile", O_CREATE | O_RDWR);
-   if(fd < 0){
-     printf(1, "cannot create bigfile");
--    exit();
-+    exit(61);
-   }
-   for(i = 0; i < 20; i++){
-     memset(buf, i, 600);
-     if(write(fd, buf, 600) != 600){
-       printf(1, "write bigfile failed\n");
--      exit();
-+      exit(60);
-     }
-   }
-   close(fd);
-@@ -1169,31 +1169,31 @@ bigfile(void)
-   fd = open("bigfile", 0);
-   if(fd < 0){
-     printf(1, "cannot open bigfile\n");
--    exit();
-+    exit(59);
-   }
-   total = 0;
-   for(i = 0; ; i++){
-     cc = read(fd, buf, 300);
-     if(cc < 0){
-       printf(1, "read bigfile failed\n");
--      exit();
-+      exit(58);
-     }
-     if(cc == 0)
-       break;
-     if(cc != 300){
-       printf(1, "short read bigfile\n");
--      exit();
-+      exit(57);
-     }
-     if(buf[0] != i/2 || buf[299] != i/2){
-       printf(1, "read bigfile wrong data\n");
--      exit();
-+      exit(56);
-     }
-     total += cc;
-   }
-   close(fd);
-   if(total != 20*600){
-     printf(1, "read bigfile wrong total\n");
--    exit();
-+    exit(55);
-   }
-   unlink("bigfile");
- 
-@@ -1210,32 +1210,32 @@ fourteen(void)
- 
-   if(mkdir("12345678901234") != 0){
-     printf(1, "mkdir 12345678901234 failed\n");
--    exit();
-+    exit(54);
-   }
-   if(mkdir("12345678901234/123456789012345") != 0){
-     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
--    exit();
-+    exit(53);
-   }
-   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
-   if(fd < 0){
-     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
--    exit();
-+    exit(52);
-   }
-   close(fd);
-   fd = open("12345678901234/12345678901234/12345678901234", 0);
-   if(fd < 0){
-     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
--    exit();
-+    exit(51);
-   }
-   close(fd);
- 
-   if(mkdir("12345678901234/12345678901234") == 0){
-     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(mkdir("123456789012345/12345678901234") == 0){
-     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
--    exit();
-+    exit(0);
-   }
- 
-   printf(1, "fourteen ok\n");
-@@ -1247,35 +1247,35 @@ rmdot(void)
-   printf(1, "rmdot test\n");
-   if(mkdir("dots") != 0){
-     printf(1, "mkdir dots failed\n");
--    exit();
-+    exit(48);
-   }
-   if(chdir("dots") != 0){
-     printf(1, "chdir dots failed\n");
--    exit();
-+    exit(47);
-   }
-   if(unlink(".") == 0){
-     printf(1, "rm . worked!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("..") == 0){
-     printf(1, "rm .. worked!\n");
--    exit();
-+    exit(0);
-   }
-   if(chdir("/") != 0){
-     printf(1, "chdir / failed\n");
--    exit();
-+    exit(44);
-   }
-   if(unlink("dots/.") == 0){
-     printf(1, "unlink dots/. worked!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dots/..") == 0){
-     printf(1, "unlink dots/.. worked!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dots") != 0){
-     printf(1, "unlink dots failed!\n");
--    exit();
-+    exit(41);
-   }
-   printf(1, "rmdot ok\n");
- }
-@@ -1290,49 +1290,49 @@ dirfile(void)
-   fd = open("dirfile", O_CREATE);
-   if(fd < 0){
-     printf(1, "create dirfile failed\n");
--    exit();
-+    exit(40);
-   }
-   close(fd);
-   if(chdir("dirfile") == 0){
-     printf(1, "chdir dirfile succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   fd = open("dirfile/xx", 0);
-   if(fd >= 0){
-     printf(1, "create dirfile/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   fd = open("dirfile/xx", O_CREATE);
-   if(fd >= 0){
-     printf(1, "create dirfile/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(mkdir("dirfile/xx") == 0){
-     printf(1, "mkdir dirfile/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dirfile/xx") == 0){
-     printf(1, "unlink dirfile/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(link("README", "dirfile/xx") == 0){
-     printf(1, "link to dirfile/xx succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   if(unlink("dirfile") != 0){
-     printf(1, "unlink dirfile failed!\n");
--    exit();
-+    exit(33);
-   }
- 
-   fd = open(".", O_RDWR);
-   if(fd >= 0){
-     printf(1, "open . for writing succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   fd = open(".", 0);
-   if(write(fd, "x", 1) > 0){
-     printf(1, "write . succeeded!\n");
--    exit();
-+    exit(0);
-   }
-   close(fd);
- 
-@@ -1351,11 +1351,11 @@ iref(void)
-   for(i = 0; i < 50 + 1; i++){
-     if(mkdir("irefd") != 0){
-       printf(1, "mkdir irefd failed\n");
--      exit();
-+      exit(30);
-     }
-     if(chdir("irefd") != 0){
-       printf(1, "chdir irefd failed\n");
--      exit();
-+      exit(29);
-     }
- 
-     mkdir("");
-@@ -1388,24 +1388,24 @@ forktest(void)
-     if(pid < 0)
-       break;
-     if(pid == 0)
--      exit();
-+      exit(28);
-   }
- 
-   if(n == 1000){
-     printf(1, "fork claimed to work 1000 times!\n");
--    exit();
-+    exit(27);
-   }
- 
-   for(; n > 0; n--){
--    if(wait() < 0){
-+    if(wait(NULL) < 0){
-       printf(1, "wait stopped early\n");
--      exit();
-+      exit(26);
-     }
-   }
- 
--  if(wait() != -1){
-+  if(wait(NULL) != -1){
-     printf(1, "wait got too many\n");
--    exit();
-+    exit(25);
-   }
- 
-   printf(1, "fork test OK\n");
-@@ -1428,7 +1428,7 @@ sbrktest(void)
-     b = sbrk(1);
-     if(b != a){
-       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
--      exit();
-+      exit(24);
-     }
-     *b = 1;
-     a = b + 1;
-@@ -1436,17 +1436,17 @@ sbrktest(void)
-   pid = fork();
-   if(pid < 0){
-     printf(stdout, "sbrk test fork failed\n");
--    exit();
-+    exit(23);
-   }
-   c = sbrk(1);
-   c = sbrk(1);
-   if(c != a + 1){
-     printf(stdout, "sbrk test failed post-fork\n");
--    exit();
-+    exit(22);
-   }
-   if(pid == 0)
--    exit();
--  wait();
-+    exit(21);
-+  wait(NULL);
- 
-   // can one grow address space to something big?
- #define BIG (100*1024*1024)
-@@ -1455,7 +1455,7 @@ sbrktest(void)
-   p = sbrk(amt);
-   if (p != a) {
-     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
--    exit();
-+    exit(20);
-   }
-   lastaddr = (char*) (BIG-1);
-   *lastaddr = 99;
-@@ -1465,12 +1465,12 @@ sbrktest(void)
-   c = sbrk(-4096);
-   if(c == (char*)0xffffffff){
-     printf(stdout, "sbrk could not deallocate\n");
--    exit();
-+    exit(19);
-   }
-   c = sbrk(0);
-   if(c != a - 4096){
-     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
--    exit();
-+    exit(18);
-   }
- 
-   // can one re-allocate that page?
-@@ -1478,19 +1478,19 @@ sbrktest(void)
-   c = sbrk(4096);
-   if(c != a || sbrk(0) != a + 4096){
-     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
--    exit();
-+    exit(17);
-   }
-   if(*lastaddr == 99){
-     // should be zero
-     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
--    exit();
-+    exit(16);
-   }
- 
-   a = sbrk(0);
-   c = sbrk(-(sbrk(0) - oldbrk));
-   if(c != a){
-     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
--    exit();
-+    exit(15);
-   }
- 
-   // can we read the kernel's memory?
-@@ -1499,21 +1499,21 @@ sbrktest(void)
-     pid = fork();
-     if(pid < 0){
-       printf(stdout, "fork failed\n");
--      exit();
-+      exit(14);
-     }
-     if(pid == 0){
-       printf(stdout, "oops could read %x = %x\n", a, *a);
-       kill(ppid);
--      exit();
-+      exit(13);
-     }
--    wait();
-+    wait(NULL);
-   }
- 
-   // if we run the system out of memory, does it clean up the last
-   // failed allocation?
-   if(pipe(fds) != 0){
-     printf(1, "pipe() failed\n");
--    exit();
-+    exit(12);
-   }
-   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-     if((pids[i] = fork()) == 0){
-@@ -1533,11 +1533,11 @@ sbrktest(void)
-     if(pids[i] == -1)
-       continue;
-     kill(pids[i]);
--    wait();
-+    wait(NULL);
-   }
-   if(c == (char*)0xffffffff){
-     printf(stdout, "failed sbrk leaked memory\n");
--    exit();
-+    exit(10);
-   }
- 
-   if(sbrk(0) > oldbrk)
-@@ -1572,17 +1572,17 @@ validatetest(void)
-     if((pid = fork()) == 0){
-       // try to crash the kernel by passing in a badly placed integer
-       validateint((int*)p);
--      exit();
-+      exit(9);
-     }
-     sleep(0);
-     sleep(0);
-     kill(pid);
--    wait();
-+    wait(NULL);
- 
-     // try to crash the kernel by passing in a bad string pointer
-     if(link("nosuchfile", (char*)p) != -1){
-       printf(stdout, "link should not succeed\n");
--      exit();
-+      exit(8);
-     }
-   }
- 
-@@ -1600,7 +1600,7 @@ bsstest(void)
-   for(i = 0; i < sizeof(uninit); i++){
-     if(uninit[i] != '\0'){
-       printf(stdout, "bss test failed\n");
--      exit();
-+      exit(7);
-     }
-   }
-   printf(stdout, "bss test ok\n");
-@@ -1627,16 +1627,16 @@ bigargtest(void)
-     printf(stdout, "bigarg test ok\n");
-     fd = open("bigarg-ok", O_CREATE);
-     close(fd);
--    exit();
-+    exit(6);
-   } else if(pid < 0){
-     printf(stdout, "bigargtest: fork failed\n");
--    exit();
-+    exit(5);
-   }
--  wait();
-+  wait(NULL);
-   fd = open("bigarg-ok", 0);
-   if(fd < 0){
-     printf(stdout, "bigarg test failed!\n");
--    exit();
-+    exit(4);
-   }
-   close(fd);
-   unlink("bigarg-ok");
-@@ -1715,12 +1715,12 @@ uio()
-     port = RTC_DATA;
-     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
-     printf(1, "uio: uio succeeded; test FAILED\n");
--    exit();
-+    exit(3);
-   } else if(pid < 0){
-     printf (1, "fork failed\n");
--    exit();
-+    exit(2);
-   }
--  wait();
-+  wait(NULL);
-   printf(1, "uio test done\n");
- }
- 
-@@ -1730,7 +1730,7 @@ void argptest()
-   fd = open("init", O_RDONLY);
-   if (fd < 0) {
-     printf(2, "open failed\n");
--    exit();
-+    exit(1);
-   }
-   read(fd, sbrk(0) - 1, -1);
-   close(fd);
-@@ -1752,7 +1752,7 @@ main(int argc, char *argv[])
- 
-   if(open("usertests.ran", 0) >= 0){
-     printf(1, "already ran user tests -- rebuild fs.img\n");
--    exit();
-+    exit(1);
-   }
-   close(open("usertests.ran", O_CREATE));
- 
-@@ -1799,5 +1799,5 @@ main(int argc, char *argv[])
- 
-   exectest();
- 
--  exit();
-+  exit(0);
- }
++++ /dev/null
+@@ -1,1803 +0,0 @@
+-#include "param.h"
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-#include "fs.h"
+-#include "fcntl.h"
+-#include "syscall.h"
+-#include "traps.h"
+-#include "memlayout.h"
+-
+-char buf[8192];
+-char name[3];
+-char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };
+-int stdout = 1;
+-
+-// does chdir() call iput(p->cwd) in a transaction?
+-void
+-iputtest(void)
+-{
+-  printf(stdout, "iput test\n");
+-
+-  if(mkdir("iputdir") < 0){
+-    printf(stdout, "mkdir failed\n");
+-    exit(184);
+-  }
+-  if(chdir("iputdir") < 0){
+-    printf(stdout, "chdir iputdir failed\n");
+-    exit(183);
+-  }
+-  if(unlink("../iputdir") < 0){
+-    printf(stdout, "unlink ../iputdir failed\n");
+-    exit(182);
+-  }
+-  if(chdir("/") < 0){
+-    printf(stdout, "chdir / failed\n");
+-    exit(181);
+-  }
+-  printf(stdout, "iput test ok\n");
+-}
+-
+-// does exit() call iput(p->cwd) in a transaction?
+-void
+-exitiputtest(void)
+-{
+-  int pid;
+-
+-  printf(stdout, "exitiput test\n");
+-
+-  pid = fork();
+-  if(pid < 0){
+-    printf(stdout, "fork failed\n");
+-    exit(180);
+-  }
+-  if(pid == 0){
+-    if(mkdir("iputdir") < 0){
+-      printf(stdout, "mkdir failed\n");
+-      exit(179);
+-    }
+-    if(chdir("iputdir") < 0){
+-      printf(stdout, "child chdir failed\n");
+-      exit(178);
+-    }
+-    if(unlink("../iputdir") < 0){
+-      printf(stdout, "unlink ../iputdir failed\n");
+-      exit(177);
+-    }
+-    exit(176);
+-  }
+-  wait(NULL);
+-  printf(stdout, "exitiput test ok\n");
+-}
+-
+-// does the error path in open() for attempt to write a
+-// directory call iput() in a transaction?
+-// needs a hacked kernel that pauses just after the namei()
+-// call in sys_open():
+-//    if((ip = namei(path)) == 0)
+-//      return -1;
+-//    {
+-//      int i;
+-//      for(i = 0; i < 10000; i++)
+-//        yield();
+-//    }
+-void
+-openiputtest(void)
+-{
+-  int pid;
+-
+-  printf(stdout, "openiput test\n");
+-  if(mkdir("oidir") < 0){
+-    printf(stdout, "mkdir oidir failed\n");
+-    exit(175);
+-  }
+-  pid = fork();
+-  if(pid < 0){
+-    printf(stdout, "fork failed\n");
+-    exit(174);
+-  }
+-  if(pid == 0){
+-    int fd = open("oidir", O_RDWR);
+-    if(fd >= 0){
+-      printf(stdout, "open directory for write succeeded\n");
+-      exit(0);
+-    }
+-    exit(172);
+-  }
+-  sleep(1);
+-  if(unlink("oidir") != 0){
+-    printf(stdout, "unlink failed\n");
+-    exit(171);
+-  }
+-  wait(NULL);
+-  printf(stdout, "openiput test ok\n");
+-}
+-
+-// simple file system tests
+-
+-void
+-opentest(void)
+-{
+-  int fd;
+-
+-  printf(stdout, "open test\n");
+-  fd = open("echo", 0);
+-  if(fd < 0){
+-    printf(stdout, "open echo failed!\n");
+-    exit(170);
+-  }
+-  close(fd);
+-  fd = open("doesnotexist", 0);
+-  if(fd >= 0){
+-    printf(stdout, "open doesnotexist succeeded!\n");
+-    exit(0);
+-  }
+-  printf(stdout, "open test ok\n");
+-}
+-
+-void
+-writetest(void)
+-{
+-  int fd;
+-  int i;
+-
+-  printf(stdout, "small file test\n");
+-  fd = open("small", O_CREATE|O_RDWR);
+-  if(fd >= 0){
+-    printf(stdout, "creat small succeeded; ok\n");
+-  } else {
+-    printf(stdout, "error: creat small failed!\n");
+-    exit(168);
+-  }
+-  for(i = 0; i < 100; i++){
+-    if(write(fd, "aaaaaaaaaa", 10) != 10){
+-      printf(stdout, "error: write aa %d new file failed\n", i);
+-      exit(167);
+-    }
+-    if(write(fd, "bbbbbbbbbb", 10) != 10){
+-      printf(stdout, "error: write bb %d new file failed\n", i);
+-      exit(166);
+-    }
+-  }
+-  printf(stdout, "writes ok\n");
+-  close(fd);
+-  fd = open("small", O_RDONLY);
+-  if(fd >= 0){
+-    printf(stdout, "open small succeeded ok\n");
+-  } else {
+-    printf(stdout, "error: open small failed!\n");
+-    exit(165);
+-  }
+-  i = read(fd, buf, 2000);
+-  if(i == 2000){
+-    printf(stdout, "read succeeded ok\n");
+-  } else {
+-    printf(stdout, "read failed\n");
+-    exit(164);
+-  }
+-  close(fd);
+-
+-  if(unlink("small") < 0){
+-    printf(stdout, "unlink small failed\n");
+-    exit(163);
+-  }
+-  printf(stdout, "small file test ok\n");
+-}
+-
+-void
+-writetest1(void)
+-{
+-  int i, fd, n;
+-
+-  printf(stdout, "big files test\n");
+-
+-  fd = open("big", O_CREATE|O_RDWR);
+-  if(fd < 0){
+-    printf(stdout, "error: creat big failed!\n");
+-    exit(162);
+-  }
+-
+-  for(i = 0; i < MAXFILE; i++){
+-    ((int*)buf)[0] = i;
+-    if(write(fd, buf, 512) != 512){
+-      printf(stdout, "error: write big file failed\n", i);
+-      exit(161);
+-    }
+-  }
+-
+-  close(fd);
+-
+-  fd = open("big", O_RDONLY);
+-  if(fd < 0){
+-    printf(stdout, "error: open big failed!\n");
+-    exit(160);
+-  }
+-
+-  n = 0;
+-  for(;;){
+-    i = read(fd, buf, 512);
+-    if(i == 0){
+-      if(n == MAXFILE - 1){
+-        printf(stdout, "read only %d blocks from big", n);
+-        exit(159);
+-      }
+-      break;
+-    } else if(i != 512){
+-      printf(stdout, "read failed %d\n", i);
+-      exit(158);
+-    }
+-    if(((int*)buf)[0] != n){
+-      printf(stdout, "read content of block %d is %d\n",
+-             n, ((int*)buf)[0]);
+-      exit(157);
+-    }
+-    n++;
+-  }
+-  close(fd);
+-  if(unlink("big") < 0){
+-    printf(stdout, "unlink big failed\n");
+-    exit(156);
+-  }
+-  printf(stdout, "big files ok\n");
+-}
+-
+-void
+-createtest(void)
+-{
+-  int i, fd;
+-
+-  printf(stdout, "many creates, followed by unlink test\n");
+-
+-  name[0] = 'a';
+-  name[2] = '\0';
+-  for(i = 0; i < 52; i++){
+-    name[1] = '0' + i;
+-    fd = open(name, O_CREATE|O_RDWR);
+-    close(fd);
+-  }
+-  name[0] = 'a';
+-  name[2] = '\0';
+-  for(i = 0; i < 52; i++){
+-    name[1] = '0' + i;
+-    unlink(name);
+-  }
+-  printf(stdout, "many creates, followed by unlink; ok\n");
+-}
+-
+-void dirtest(void)
+-{
+-  printf(stdout, "mkdir test\n");
+-
+-  if(mkdir("dir0") < 0){
+-    printf(stdout, "mkdir failed\n");
+-    exit(155);
+-  }
+-
+-  if(chdir("dir0") < 0){
+-    printf(stdout, "chdir dir0 failed\n");
+-    exit(154);
+-  }
+-
+-  if(chdir("..") < 0){
+-    printf(stdout, "chdir .. failed\n");
+-    exit(153);
+-  }
+-
+-  if(unlink("dir0") < 0){
+-    printf(stdout, "unlink dir0 failed\n");
+-    exit(152);
+-  }
+-  printf(stdout, "mkdir test ok\n");
+-}
+-
+-void
+-exectest(void)
+-{
+-  printf(stdout, "exec test\n");
+-  if(exec("echo", echoargv) < 0){
+-    printf(stdout, "exec echo failed\n");
+-    exit(151);
+-  }
+-}
+-
+-// simple fork and pipe read/write
+-
+-void
+-pipe1(void)
+-{
+-  int fds[2], pid;
+-  int seq, i, n, cc, total;
+-
+-  if(pipe(fds) != 0){
+-    printf(1, "pipe() failed\n");
+-    exit(150);
+-  }
+-  pid = fork();
+-  seq = 0;
+-  if(pid == 0){
+-    close(fds[0]);
+-    for(n = 0; n < 5; n++){
+-      for(i = 0; i < 1033; i++)
+-        buf[i] = seq++;
+-      if(write(fds[1], buf, 1033) != 1033){
+-        printf(1, "pipe1 oops 1\n");
+-        exit(149);
+-      }
+-    }
+-    exit(148);
+-  } else if(pid > 0){
+-    close(fds[1]);
+-    total = 0;
+-    cc = 1;
+-    while((n = read(fds[0], buf, cc)) > 0){
+-      for(i = 0; i < n; i++){
+-        if((buf[i] & 0xff) != (seq++ & 0xff)){
+-          printf(1, "pipe1 oops 2\n");
+-          return;
+-        }
+-      }
+-      total += n;
+-      cc = cc * 2;
+-      if(cc > sizeof(buf))
+-        cc = sizeof(buf);
+-    }
+-    if(total != 5 * 1033){
+-      printf(1, "pipe1 oops 3 total %d\n", total);
+-      exit(147);
+-    }
+-    close(fds[0]);
+-    wait(NULL);
+-  } else {
+-    printf(1, "fork() failed\n");
+-    exit(146);
+-  }
+-  printf(1, "pipe1 ok\n");
+-}
+-
+-// meant to be run w/ at most two CPUs
+-void
+-preempt(void)
+-{
+-  int pid1, pid2, pid3;
+-  int pfds[2];
+-
+-  printf(1, "preempt: ");
+-  pid1 = fork();
+-  if(pid1 == 0)
+-    for(;;)
+-      ;
+-
+-  pid2 = fork();
+-  if(pid2 == 0)
+-    for(;;)
+-      ;
+-
+-  pipe(pfds);
+-  pid3 = fork();
+-  if(pid3 == 0){
+-    close(pfds[0]);
+-    if(write(pfds[1], "x", 1) != 1)
+-      printf(1, "preempt write error");
+-    close(pfds[1]);
+-    for(;;)
+-      ;
+-  }
+-
+-  close(pfds[1]);
+-  if(read(pfds[0], buf, sizeof(buf)) != 1){
+-    printf(1, "preempt read error");
+-    return;
+-  }
+-  close(pfds[0]);
+-  printf(1, "kill... ");
+-  kill(pid1);
+-  kill(pid2);
+-  kill(pid3);
+-  printf(1, "wait... ");
+-  wait(NULL);
+-  wait(NULL);
+-  wait(NULL);
+-  printf(1, "preempt ok\n");
+-}
+-
+-// try to find any races between exit and wait
+-void
+-exitwait(void)
+-{
+-  int i, pid;
+-
+-  for(i = 0; i < 100; i++){
+-    pid = fork();
+-    if(pid < 0){
+-      printf(1, "fork failed\n");
+-      return;
+-    }
+-    if(pid){
+-      if(wait(NULL) != pid){
+-        printf(1, "wait wrong pid\n");
+-        return;
+-      }
+-    } else {
+-      exit(145);
+-    }
+-  }
+-  printf(1, "exitwait ok\n");
+-}
+-
+-void
+-mem(void)
+-{
+-  void *m1, *m2;
+-  int pid, ppid;
+-
+-  printf(1, "mem test\n");
+-  ppid = getpid();
+-  if((pid = fork()) == 0){
+-    m1 = 0;
+-    while((m2 = malloc(10001)) != 0){
+-      *(char**)m2 = m1;
+-      m1 = m2;
+-    }
+-    while(m1){
+-      m2 = *(char**)m1;
+-      free(m1);
+-      m1 = m2;
+-    }
+-    m1 = malloc(1024*20);
+-    if(m1 == 0){
+-      printf(1, "couldn't allocate mem?!!\n");
+-      kill(ppid);
+-      exit(144);
+-    }
+-    free(m1);
+-    printf(1, "mem ok\n");
+-    exit(0);
+-  } else {
+-    wait(NULL);
+-  }
+-}
+-
+-// More file system tests
+-
+-// two processes write to the same file descriptor
+-// is the offset shared? does inode locking work?
+-void
+-sharedfd(void)
+-{
+-  int fd, pid, i, n, nc, np;
+-  char buf[10];
+-
+-  printf(1, "sharedfd test\n");
+-
+-  unlink("sharedfd");
+-  fd = open("sharedfd", O_CREATE|O_RDWR);
+-  if(fd < 0){
+-    printf(1, "fstests: cannot open sharedfd for writing");
+-    return;
+-  }
+-  pid = fork();
+-  memset(buf, pid==0?'c':'p', sizeof(buf));
+-  for(i = 0; i < 1000; i++){
+-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+-      printf(1, "fstests: write sharedfd failed\n");
+-      break;
+-    }
+-  }
+-  if(pid == 0)
+-    exit(142);
+-  else
+-    wait(NULL);
+-  close(fd);
+-  fd = open("sharedfd", 0);
+-  if(fd < 0){
+-    printf(1, "fstests: cannot open sharedfd for reading\n");
+-    return;
+-  }
+-  nc = np = 0;
+-  while((n = read(fd, buf, sizeof(buf))) > 0){
+-    for(i = 0; i < sizeof(buf); i++){
+-      if(buf[i] == 'c')
+-        nc++;
+-      if(buf[i] == 'p')
+-        np++;
+-    }
+-  }
+-  close(fd);
+-  unlink("sharedfd");
+-  if(nc == 10000 && np == 10000){
+-    printf(1, "sharedfd ok\n");
+-  } else {
+-    printf(1, "sharedfd oops %d %d\n", nc, np);
+-    exit(141);
+-  }
+-}
+-
+-// four processes write different files at the same
+-// time, to test block allocation.
+-void
+-fourfiles(void)
+-{
+-  int fd, pid, i, j, n, total, pi;
+-  char *names[] = { "f0", "f1", "f2", "f3" };
+-  char *fname;
+-
+-  printf(1, "fourfiles test\n");
+-
+-  for(pi = 0; pi < 4; pi++){
+-    fname = names[pi];
+-    unlink(fname);
+-
+-    pid = fork();
+-    if(pid < 0){
+-      printf(1, "fork failed\n");
+-      exit(140);
+-    }
+-
+-    if(pid == 0){
+-      fd = open(fname, O_CREATE | O_RDWR);
+-      if(fd < 0){
+-        printf(1, "create failed\n");
+-        exit(139);
+-      }
+-
+-      memset(buf, '0'+pi, 512);
+-      for(i = 0; i < 12; i++){
+-        if((n = write(fd, buf, 500)) != 500){
+-          printf(1, "write failed %d\n", n);
+-          exit(138);
+-        }
+-      }
+-      exit(137);
+-    }
+-  }
+-
+-  for(pi = 0; pi < 4; pi++){
+-    wait(NULL);
+-  }
+-
+-  for(i = 0; i < 2; i++){
+-    fname = names[i];
+-    fd = open(fname, 0);
+-    total = 0;
+-    while((n = read(fd, buf, sizeof(buf))) > 0){
+-      for(j = 0; j < n; j++){
+-        if(buf[j] != '0'+i){
+-          printf(1, "wrong char\n");
+-          exit(136);
+-        }
+-      }
+-      total += n;
+-    }
+-    close(fd);
+-    if(total != 12*500){
+-      printf(1, "wrong length %d\n", total);
+-      exit(135);
+-    }
+-    unlink(fname);
+-  }
+-
+-  printf(1, "fourfiles ok\n");
+-}
+-
+-// four processes create and delete different files in same directory
+-void
+-createdelete(void)
+-{
+-  enum { N = 20 };
+-  int pid, i, fd, pi;
+-  char name[32];
+-
+-  printf(1, "createdelete test\n");
+-
+-  for(pi = 0; pi < 4; pi++){
+-    pid = fork();
+-    if(pid < 0){
+-      printf(1, "fork failed\n");
+-      exit(134);
+-    }
+-
+-    if(pid == 0){
+-      name[0] = 'p' + pi;
+-      name[2] = '\0';
+-      for(i = 0; i < N; i++){
+-        name[1] = '0' + i;
+-        fd = open(name, O_CREATE | O_RDWR);
+-        if(fd < 0){
+-          printf(1, "create failed\n");
+-          exit(133);
+-        }
+-        close(fd);
+-        if(i > 0 && (i % 2 ) == 0){
+-          name[1] = '0' + (i / 2);
+-          if(unlink(name) < 0){
+-            printf(1, "unlink failed\n");
+-            exit(132);
+-          }
+-        }
+-      }
+-      exit(131);
+-    }
+-  }
+-
+-  for(pi = 0; pi < 4; pi++){
+-    wait(NULL);
+-  }
+-
+-  name[0] = name[1] = name[2] = 0;
+-  for(i = 0; i < N; i++){
+-    for(pi = 0; pi < 4; pi++){
+-      name[0] = 'p' + pi;
+-      name[1] = '0' + i;
+-      fd = open(name, 0);
+-      if((i == 0 || i >= N/2) && fd < 0){
+-        printf(1, "oops createdelete %s didn't exist\n", name);
+-        exit(130);
+-      } else if((i >= 1 && i < N/2) && fd >= 0){
+-        printf(1, "oops createdelete %s did exist\n", name);
+-        exit(129);
+-      }
+-      if(fd >= 0)
+-        close(fd);
+-    }
+-  }
+-
+-  for(i = 0; i < N; i++){
+-    for(pi = 0; pi < 4; pi++){
+-      name[0] = 'p' + i;
+-      name[1] = '0' + i;
+-      unlink(name);
+-    }
+-  }
+-
+-  printf(1, "createdelete ok\n");
+-}
+-
+-// can I unlink a file and still read it?
+-void
+-unlinkread(void)
+-{
+-  int fd, fd1;
+-
+-  printf(1, "unlinkread test\n");
+-  fd = open("unlinkread", O_CREATE | O_RDWR);
+-  if(fd < 0){
+-    printf(1, "create unlinkread failed\n");
+-    exit(128);
+-  }
+-  write(fd, "hello", 5);
+-  close(fd);
+-
+-  fd = open("unlinkread", O_RDWR);
+-  if(fd < 0){
+-    printf(1, "open unlinkread failed\n");
+-    exit(127);
+-  }
+-  if(unlink("unlinkread") != 0){
+-    printf(1, "unlink unlinkread failed\n");
+-    exit(126);
+-  }
+-
+-  fd1 = open("unlinkread", O_CREATE | O_RDWR);
+-  write(fd1, "yyy", 3);
+-  close(fd1);
+-
+-  if(read(fd, buf, sizeof(buf)) != 5){
+-    printf(1, "unlinkread read failed");
+-    exit(125);
+-  }
+-  if(buf[0] != 'h'){
+-    printf(1, "unlinkread wrong data\n");
+-    exit(124);
+-  }
+-  if(write(fd, buf, 10) != 10){
+-    printf(1, "unlinkread write failed\n");
+-    exit(123);
+-  }
+-  close(fd);
+-  unlink("unlinkread");
+-  printf(1, "unlinkread ok\n");
+-}
+-
+-void
+-linktest(void)
+-{
+-  int fd;
+-
+-  printf(1, "linktest\n");
+-
+-  unlink("lf1");
+-  unlink("lf2");
+-
+-  fd = open("lf1", O_CREATE|O_RDWR);
+-  if(fd < 0){
+-    printf(1, "create lf1 failed\n");
+-    exit(122);
+-  }
+-  if(write(fd, "hello", 5) != 5){
+-    printf(1, "write lf1 failed\n");
+-    exit(121);
+-  }
+-  close(fd);
+-
+-  if(link("lf1", "lf2") < 0){
+-    printf(1, "link lf1 lf2 failed\n");
+-    exit(120);
+-  }
+-  unlink("lf1");
+-
+-  if(open("lf1", 0) >= 0){
+-    printf(1, "unlinked lf1 but it is still there!\n");
+-    exit(119);
+-  }
+-
+-  fd = open("lf2", 0);
+-  if(fd < 0){
+-    printf(1, "open lf2 failed\n");
+-    exit(118);
+-  }
+-  if(read(fd, buf, sizeof(buf)) != 5){
+-    printf(1, "read lf2 failed\n");
+-    exit(117);
+-  }
+-  close(fd);
+-
+-  if(link("lf2", "lf2") >= 0){
+-    printf(1, "link lf2 lf2 succeeded! oops\n");
+-    exit(116);
+-  }
+-
+-  unlink("lf2");
+-  if(link("lf2", "lf1") >= 0){
+-    printf(1, "link non-existant succeeded! oops\n");
+-    exit(115);
+-  }
+-
+-  if(link(".", "lf1") >= 0){
+-    printf(1, "link . lf1 succeeded! oops\n");
+-    exit(114);
+-  }
+-
+-  printf(1, "linktest ok\n");
+-}
+-
+-// test concurrent create/link/unlink of the same file
+-void
+-concreate(void)
+-{
+-  char file[3];
+-  int i, pid, n, fd;
+-  char fa[40];
+-  struct {
+-    ushort inum;
+-    char name[14];
+-  } de;
+-
+-  printf(1, "concreate test\n");
+-  file[0] = 'C';
+-  file[2] = '\0';
+-  for(i = 0; i < 40; i++){
+-    file[1] = '0' + i;
+-    unlink(file);
+-    pid = fork();
+-    if(pid && (i % 3) == 1){
+-      link("C0", file);
+-    } else if(pid == 0 && (i % 5) == 1){
+-      link("C0", file);
+-    } else {
+-      fd = open(file, O_CREATE | O_RDWR);
+-      if(fd < 0){
+-        printf(1, "concreate create %s failed\n", file);
+-        exit(113);
+-      }
+-      close(fd);
+-    }
+-    if(pid == 0)
+-      exit(112);
+-    else
+-      wait(NULL);
+-  }
+-
+-  memset(fa, 0, sizeof(fa));
+-  fd = open(".", 0);
+-  n = 0;
+-  while(read(fd, &de, sizeof(de)) > 0){
+-    if(de.inum == 0)
+-      continue;
+-    if(de.name[0] == 'C' && de.name[2] == '\0'){
+-      i = de.name[1] - '0';
+-      if(i < 0 || i >= sizeof(fa)){
+-        printf(1, "concreate weird file %s\n", de.name);
+-        exit(111);
+-      }
+-      if(fa[i]){
+-        printf(1, "concreate duplicate file %s\n", de.name);
+-        exit(110);
+-      }
+-      fa[i] = 1;
+-      n++;
+-    }
+-  }
+-  close(fd);
+-
+-  if(n != 40){
+-    printf(1, "concreate not enough files in directory listing\n");
+-    exit(109);
+-  }
+-
+-  for(i = 0; i < 40; i++){
+-    file[1] = '0' + i;
+-    pid = fork();
+-    if(pid < 0){
+-      printf(1, "fork failed\n");
+-      exit(108);
+-    }
+-    if(((i % 3) == 0 && pid == 0) ||
+-       ((i % 3) == 1 && pid != 0)){
+-      close(open(file, 0));
+-      close(open(file, 0));
+-      close(open(file, 0));
+-      close(open(file, 0));
+-    } else {
+-      unlink(file);
+-      unlink(file);
+-      unlink(file);
+-      unlink(file);
+-    }
+-    if(pid == 0)
+-      exit(107);
+-    else
+-      wait(NULL);
+-  }
+-
+-  printf(1, "concreate ok\n");
+-}
+-
+-// another concurrent link/unlink/create test,
+-// to look for deadlocks.
+-void
+-linkunlink()
+-{
+-  int pid, i;
+-
+-  printf(1, "linkunlink test\n");
+-
+-  unlink("x");
+-  pid = fork();
+-  if(pid < 0){
+-    printf(1, "fork failed\n");
+-    exit(106);
+-  }
+-
+-  unsigned int x = (pid ? 1 : 97);
+-  for(i = 0; i < 100; i++){
+-    x = x * 1103515245 + 12345;
+-    if((x % 3) == 0){
+-      close(open("x", O_RDWR | O_CREATE));
+-    } else if((x % 3) == 1){
+-      link("cat", "x");
+-    } else {
+-      unlink("x");
+-    }
+-  }
+-
+-  if(pid)
+-    wait(NULL);
+-  else
+-    exit(105);
+-
+-  printf(1, "linkunlink ok\n");
+-}
+-
+-// directory that uses indirect blocks
+-void
+-bigdir(void)
+-{
+-  int i, fd;
+-  char name[10];
+-
+-  printf(1, "bigdir test\n");
+-  unlink("bd");
+-
+-  fd = open("bd", O_CREATE);
+-  if(fd < 0){
+-    printf(1, "bigdir create failed\n");
+-    exit(104);
+-  }
+-  close(fd);
+-
+-  for(i = 0; i < 500; i++){
+-    name[0] = 'x';
+-    name[1] = '0' + (i / 64);
+-    name[2] = '0' + (i % 64);
+-    name[3] = '\0';
+-    if(link("bd", name) != 0){
+-      printf(1, "bigdir link failed\n");
+-      exit(103);
+-    }
+-  }
+-
+-  unlink("bd");
+-  for(i = 0; i < 500; i++){
+-    name[0] = 'x';
+-    name[1] = '0' + (i / 64);
+-    name[2] = '0' + (i % 64);
+-    name[3] = '\0';
+-    if(unlink(name) != 0){
+-      printf(1, "bigdir unlink failed");
+-      exit(102);
+-    }
+-  }
+-
+-  printf(1, "bigdir ok\n");
+-}
+-
+-void
+-subdir(void)
+-{
+-  int fd, cc;
+-
+-  printf(1, "subdir test\n");
+-
+-  unlink("ff");
+-  if(mkdir("dd") != 0){
+-    printf(1, "subdir mkdir dd failed\n");
+-    exit(101);
+-  }
+-
+-  fd = open("dd/ff", O_CREATE | O_RDWR);
+-  if(fd < 0){
+-    printf(1, "create dd/ff failed\n");
+-    exit(100);
+-  }
+-  write(fd, "ff", 2);
+-  close(fd);
+-
+-  if(unlink("dd") >= 0){
+-    printf(1, "unlink dd (non-empty dir) succeeded!\n");
+-    exit(99);
+-  }
+-
+-  if(mkdir("/dd/dd") != 0){
+-    printf(1, "subdir mkdir dd/dd failed\n");
+-    exit(98);
+-  }
+-
+-  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+-  if(fd < 0){
+-    printf(1, "create dd/dd/ff failed\n");
+-    exit(97);
+-  }
+-  write(fd, "FF", 2);
+-  close(fd);
+-
+-  fd = open("dd/dd/../ff", 0);
+-  if(fd < 0){
+-    printf(1, "open dd/dd/../ff failed\n");
+-    exit(96);
+-  }
+-  cc = read(fd, buf, sizeof(buf));
+-  if(cc != 2 || buf[0] != 'f'){
+-    printf(1, "dd/dd/../ff wrong content\n");
+-    exit(95);
+-  }
+-  close(fd);
+-
+-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+-    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+-    exit(94);
+-  }
+-
+-  if(unlink("dd/dd/ff") != 0){
+-    printf(1, "unlink dd/dd/ff failed\n");
+-    exit(93);
+-  }
+-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+-    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+-    exit(92);
+-  }
+-
+-  if(chdir("dd") != 0){
+-    printf(1, "chdir dd failed\n");
+-    exit(91);
+-  }
+-  if(chdir("dd/../../dd") != 0){
+-    printf(1, "chdir dd/../../dd failed\n");
+-    exit(90);
+-  }
+-  if(chdir("dd/../../../dd") != 0){
+-    printf(1, "chdir dd/../../dd failed\n");
+-    exit(89);
+-  }
+-  if(chdir("./..") != 0){
+-    printf(1, "chdir ./.. failed\n");
+-    exit(88);
+-  }
+-
+-  fd = open("dd/dd/ffff", 0);
+-  if(fd < 0){
+-    printf(1, "open dd/dd/ffff failed\n");
+-    exit(87);
+-  }
+-  if(read(fd, buf, sizeof(buf)) != 2){
+-    printf(1, "read dd/dd/ffff wrong len\n");
+-    exit(86);
+-  }
+-  close(fd);
+-
+-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+-    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+-    exit(0);
+-  }
+-
+-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+-    printf(1, "create dd/ff/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+-    printf(1, "create dd/xx/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(open("dd", O_CREATE) >= 0){
+-    printf(1, "create dd succeeded!\n");
+-    exit(0);
+-  }
+-  if(open("dd", O_RDWR) >= 0){
+-    printf(1, "open dd rdwr succeeded!\n");
+-    exit(0);
+-  }
+-  if(open("dd", O_WRONLY) >= 0){
+-    printf(1, "open dd wronly succeeded!\n");
+-    exit(0);
+-  }
+-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+-    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+-    exit(0);
+-  }
+-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+-    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+-    exit(0);
+-  }
+-  if(link("dd/ff", "dd/dd/ffff") == 0){
+-    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+-    exit(0);
+-  }
+-  if(mkdir("dd/ff/ff") == 0){
+-    printf(1, "mkdir dd/ff/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(mkdir("dd/xx/ff") == 0){
+-    printf(1, "mkdir dd/xx/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(mkdir("dd/dd/ffff") == 0){
+-    printf(1, "mkdir dd/dd/ffff succeeded!\n");
+-    exit(0);
+-  }
+-  if(unlink("dd/xx/ff") == 0){
+-    printf(1, "unlink dd/xx/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(unlink("dd/ff/ff") == 0){
+-    printf(1, "unlink dd/ff/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(chdir("dd/ff") == 0){
+-    printf(1, "chdir dd/ff succeeded!\n");
+-    exit(0);
+-  }
+-  if(chdir("dd/xx") == 0){
+-    printf(1, "chdir dd/xx succeeded!\n");
+-    exit(0);
+-  }
+-
+-  if(unlink("dd/dd/ffff") != 0){
+-    printf(1, "unlink dd/dd/ff failed\n");
+-    exit(68);
+-  }
+-  if(unlink("dd/ff") != 0){
+-    printf(1, "unlink dd/ff failed\n");
+-    exit(67);
+-  }
+-  if(unlink("dd") == 0){
+-    printf(1, "unlink non-empty dd succeeded!\n");
+-    exit(0);
+-  }
+-  if(unlink("dd/dd") < 0){
+-    printf(1, "unlink dd/dd failed\n");
+-    exit(65);
+-  }
+-  if(unlink("dd") < 0){
+-    printf(1, "unlink dd failed\n");
+-    exit(64);
+-  }
+-
+-  printf(1, "subdir ok\n");
+-}
+-
+-// test writes that are larger than the log.
+-void
+-bigwrite(void)
+-{
+-  int fd, sz;
+-
+-  printf(1, "bigwrite test\n");
+-
+-  unlink("bigwrite");
+-  for(sz = 499; sz < 12*512; sz += 471){
+-    fd = open("bigwrite", O_CREATE | O_RDWR);
+-    if(fd < 0){
+-      printf(1, "cannot create bigwrite\n");
+-      exit(63);
+-    }
+-    int i;
+-    for(i = 0; i < 2; i++){
+-      int cc = write(fd, buf, sz);
+-      if(cc != sz){
+-        printf(1, "write(%d) ret %d\n", sz, cc);
+-        exit(62);
+-      }
+-    }
+-    close(fd);
+-    unlink("bigwrite");
+-  }
+-
+-  printf(1, "bigwrite ok\n");
+-}
+-
+-void
+-bigfile(void)
+-{
+-  int fd, i, total, cc;
+-
+-  printf(1, "bigfile test\n");
+-
+-  unlink("bigfile");
+-  fd = open("bigfile", O_CREATE | O_RDWR);
+-  if(fd < 0){
+-    printf(1, "cannot create bigfile");
+-    exit(61);
+-  }
+-  for(i = 0; i < 20; i++){
+-    memset(buf, i, 600);
+-    if(write(fd, buf, 600) != 600){
+-      printf(1, "write bigfile failed\n");
+-      exit(60);
+-    }
+-  }
+-  close(fd);
+-
+-  fd = open("bigfile", 0);
+-  if(fd < 0){
+-    printf(1, "cannot open bigfile\n");
+-    exit(59);
+-  }
+-  total = 0;
+-  for(i = 0; ; i++){
+-    cc = read(fd, buf, 300);
+-    if(cc < 0){
+-      printf(1, "read bigfile failed\n");
+-      exit(58);
+-    }
+-    if(cc == 0)
+-      break;
+-    if(cc != 300){
+-      printf(1, "short read bigfile\n");
+-      exit(57);
+-    }
+-    if(buf[0] != i/2 || buf[299] != i/2){
+-      printf(1, "read bigfile wrong data\n");
+-      exit(56);
+-    }
+-    total += cc;
+-  }
+-  close(fd);
+-  if(total != 20*600){
+-    printf(1, "read bigfile wrong total\n");
+-    exit(55);
+-  }
+-  unlink("bigfile");
+-
+-  printf(1, "bigfile test ok\n");
+-}
+-
+-void
+-fourteen(void)
+-{
+-  int fd;
+-
+-  // DIRSIZ is 14.
+-  printf(1, "fourteen test\n");
+-
+-  if(mkdir("12345678901234") != 0){
+-    printf(1, "mkdir 12345678901234 failed\n");
+-    exit(54);
+-  }
+-  if(mkdir("12345678901234/123456789012345") != 0){
+-    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+-    exit(53);
+-  }
+-  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+-  if(fd < 0){
+-    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+-    exit(52);
+-  }
+-  close(fd);
+-  fd = open("12345678901234/12345678901234/12345678901234", 0);
+-  if(fd < 0){
+-    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+-    exit(51);
+-  }
+-  close(fd);
+-
+-  if(mkdir("12345678901234/12345678901234") == 0){
+-    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+-    exit(0);
+-  }
+-  if(mkdir("123456789012345/12345678901234") == 0){
+-    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+-    exit(0);
+-  }
+-
+-  printf(1, "fourteen ok\n");
+-}
+-
+-void
+-rmdot(void)
+-{
+-  printf(1, "rmdot test\n");
+-  if(mkdir("dots") != 0){
+-    printf(1, "mkdir dots failed\n");
+-    exit(48);
+-  }
+-  if(chdir("dots") != 0){
+-    printf(1, "chdir dots failed\n");
+-    exit(47);
+-  }
+-  if(unlink(".") == 0){
+-    printf(1, "rm . worked!\n");
+-    exit(0);
+-  }
+-  if(unlink("..") == 0){
+-    printf(1, "rm .. worked!\n");
+-    exit(0);
+-  }
+-  if(chdir("/") != 0){
+-    printf(1, "chdir / failed\n");
+-    exit(44);
+-  }
+-  if(unlink("dots/.") == 0){
+-    printf(1, "unlink dots/. worked!\n");
+-    exit(0);
+-  }
+-  if(unlink("dots/..") == 0){
+-    printf(1, "unlink dots/.. worked!\n");
+-    exit(0);
+-  }
+-  if(unlink("dots") != 0){
+-    printf(1, "unlink dots failed!\n");
+-    exit(41);
+-  }
+-  printf(1, "rmdot ok\n");
+-}
+-
+-void
+-dirfile(void)
+-{
+-  int fd;
+-
+-  printf(1, "dir vs file\n");
+-
+-  fd = open("dirfile", O_CREATE);
+-  if(fd < 0){
+-    printf(1, "create dirfile failed\n");
+-    exit(40);
+-  }
+-  close(fd);
+-  if(chdir("dirfile") == 0){
+-    printf(1, "chdir dirfile succeeded!\n");
+-    exit(0);
+-  }
+-  fd = open("dirfile/xx", 0);
+-  if(fd >= 0){
+-    printf(1, "create dirfile/xx succeeded!\n");
+-    exit(0);
+-  }
+-  fd = open("dirfile/xx", O_CREATE);
+-  if(fd >= 0){
+-    printf(1, "create dirfile/xx succeeded!\n");
+-    exit(0);
+-  }
+-  if(mkdir("dirfile/xx") == 0){
+-    printf(1, "mkdir dirfile/xx succeeded!\n");
+-    exit(0);
+-  }
+-  if(unlink("dirfile/xx") == 0){
+-    printf(1, "unlink dirfile/xx succeeded!\n");
+-    exit(0);
+-  }
+-  if(link("README", "dirfile/xx") == 0){
+-    printf(1, "link to dirfile/xx succeeded!\n");
+-    exit(0);
+-  }
+-  if(unlink("dirfile") != 0){
+-    printf(1, "unlink dirfile failed!\n");
+-    exit(33);
+-  }
+-
+-  fd = open(".", O_RDWR);
+-  if(fd >= 0){
+-    printf(1, "open . for writing succeeded!\n");
+-    exit(0);
+-  }
+-  fd = open(".", 0);
+-  if(write(fd, "x", 1) > 0){
+-    printf(1, "write . succeeded!\n");
+-    exit(0);
+-  }
+-  close(fd);
+-
+-  printf(1, "dir vs file OK\n");
+-}
+-
+-// test that iput() is called at the end of _namei()
+-void
+-iref(void)
+-{
+-  int i, fd;
+-
+-  printf(1, "empty file name\n");
+-
+-  // the 50 is NINODE
+-  for(i = 0; i < 50 + 1; i++){
+-    if(mkdir("irefd") != 0){
+-      printf(1, "mkdir irefd failed\n");
+-      exit(30);
+-    }
+-    if(chdir("irefd") != 0){
+-      printf(1, "chdir irefd failed\n");
+-      exit(29);
+-    }
+-
+-    mkdir("");
+-    link("README", "");
+-    fd = open("", O_CREATE);
+-    if(fd >= 0)
+-      close(fd);
+-    fd = open("xx", O_CREATE);
+-    if(fd >= 0)
+-      close(fd);
+-    unlink("xx");
+-  }
+-
+-  chdir("/");
+-  printf(1, "empty file name OK\n");
+-}
+-
+-// test that fork fails gracefully
+-// the forktest binary also does this, but it runs out of proc entries first.
+-// inside the bigger usertests binary, we run out of memory first.
+-void
+-forktest(void)
+-{
+-  int n, pid;
+-
+-  printf(1, "fork test\n");
+-
+-  for(n=0; n<1000; n++){
+-    pid = fork();
+-    if(pid < 0)
+-      break;
+-    if(pid == 0)
+-      exit(28);
+-  }
+-
+-  if(n == 1000){
+-    printf(1, "fork claimed to work 1000 times!\n");
+-    exit(27);
+-  }
+-
+-  for(; n > 0; n--){
+-    if(wait(NULL) < 0){
+-      printf(1, "wait stopped early\n");
+-      exit(26);
+-    }
+-  }
+-
+-  if(wait(NULL) != -1){
+-    printf(1, "wait got too many\n");
+-    exit(25);
+-  }
+-
+-  printf(1, "fork test OK\n");
+-}
+-
+-void
+-sbrktest(void)
+-{
+-  int fds[2], pid, pids[10], ppid;
+-  char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
+-  uint amt;
+-
+-  printf(stdout, "sbrk test\n");
+-  oldbrk = sbrk(0);
+-
+-  // can one sbrk() less than a page?
+-  a = sbrk(0);
+-  int i;
+-  for(i = 0; i < 5000; i++){
+-    b = sbrk(1);
+-    if(b != a){
+-      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+-      exit(24);
+-    }
+-    *b = 1;
+-    a = b + 1;
+-  }
+-  pid = fork();
+-  if(pid < 0){
+-    printf(stdout, "sbrk test fork failed\n");
+-    exit(23);
+-  }
+-  c = sbrk(1);
+-  c = sbrk(1);
+-  if(c != a + 1){
+-    printf(stdout, "sbrk test failed post-fork\n");
+-    exit(22);
+-  }
+-  if(pid == 0)
+-    exit(21);
+-  wait(NULL);
+-
+-  // can one grow address space to something big?
+-#define BIG (100*1024*1024)
+-  a = sbrk(0);
+-  amt = (BIG) - (uint)a;
+-  p = sbrk(amt);
+-  if (p != a) {
+-    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+-    exit(20);
+-  }
+-  lastaddr = (char*) (BIG-1);
+-  *lastaddr = 99;
+-
+-  // can one de-allocate?
+-  a = sbrk(0);
+-  c = sbrk(-4096);
+-  if(c == (char*)0xffffffff){
+-    printf(stdout, "sbrk could not deallocate\n");
+-    exit(19);
+-  }
+-  c = sbrk(0);
+-  if(c != a - 4096){
+-    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+-    exit(18);
+-  }
+-
+-  // can one re-allocate that page?
+-  a = sbrk(0);
+-  c = sbrk(4096);
+-  if(c != a || sbrk(0) != a + 4096){
+-    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+-    exit(17);
+-  }
+-  if(*lastaddr == 99){
+-    // should be zero
+-    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+-    exit(16);
+-  }
+-
+-  a = sbrk(0);
+-  c = sbrk(-(sbrk(0) - oldbrk));
+-  if(c != a){
+-    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+-    exit(15);
+-  }
+-
+-  // can we read the kernel's memory?
+-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+-    ppid = getpid();
+-    pid = fork();
+-    if(pid < 0){
+-      printf(stdout, "fork failed\n");
+-      exit(14);
+-    }
+-    if(pid == 0){
+-      printf(stdout, "oops could read %x = %x\n", a, *a);
+-      kill(ppid);
+-      exit(13);
+-    }
+-    wait(NULL);
+-  }
+-
+-  // if we run the system out of memory, does it clean up the last
+-  // failed allocation?
+-  if(pipe(fds) != 0){
+-    printf(1, "pipe() failed\n");
+-    exit(12);
+-  }
+-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+-    if((pids[i] = fork()) == 0){
+-      // allocate a lot of memory
+-      sbrk(BIG - (uint)sbrk(0));
+-      write(fds[1], "x", 1);
+-      // sit around until killed
+-      for(;;) sleep(1000);
+-    }
+-    if(pids[i] != -1)
+-      read(fds[0], &scratch, 1);
+-  }
+-  // if those failed allocations freed up the pages they did allocate,
+-  // we'll be able to allocate here
+-  c = sbrk(4096);
+-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+-    if(pids[i] == -1)
+-      continue;
+-    kill(pids[i]);
+-    wait(NULL);
+-  }
+-  if(c == (char*)0xffffffff){
+-    printf(stdout, "failed sbrk leaked memory\n");
+-    exit(10);
+-  }
+-
+-  if(sbrk(0) > oldbrk)
+-    sbrk(-(sbrk(0) - oldbrk));
+-
+-  printf(stdout, "sbrk test OK\n");
+-}
+-
+-void
+-validateint(int *p)
+-{
+-  int res;
+-  asm("mov %%esp, %%ebx\n\t"
+-      "mov %3, %%esp\n\t"
+-      "int %2\n\t"
+-      "mov %%ebx, %%esp" :
+-      "=a" (res) :
+-      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
+-      "ebx");
+-}
+-
+-void
+-validatetest(void)
+-{
+-  int hi, pid;
+-  uint p;
+-
+-  printf(stdout, "validate test\n");
+-  hi = 1100*1024;
+-
+-  for(p = 0; p <= (uint)hi; p += 4096){
+-    if((pid = fork()) == 0){
+-      // try to crash the kernel by passing in a badly placed integer
+-      validateint((int*)p);
+-      exit(9);
+-    }
+-    sleep(0);
+-    sleep(0);
+-    kill(pid);
+-    wait(NULL);
+-
+-    // try to crash the kernel by passing in a bad string pointer
+-    if(link("nosuchfile", (char*)p) != -1){
+-      printf(stdout, "link should not succeed\n");
+-      exit(8);
+-    }
+-  }
+-
+-  printf(stdout, "validate ok\n");
+-}
+-
+-// does unintialized data start out zero?
+-char uninit[10000];
+-void
+-bsstest(void)
+-{
+-  int i;
+-
+-  printf(stdout, "bss test\n");
+-  for(i = 0; i < sizeof(uninit); i++){
+-    if(uninit[i] != '\0'){
+-      printf(stdout, "bss test failed\n");
+-      exit(7);
+-    }
+-  }
+-  printf(stdout, "bss test ok\n");
+-}
+-
+-// does exec return an error if the arguments
+-// are larger than a page? or does it write
+-// below the stack and wreck the instructions/data?
+-void
+-bigargtest(void)
+-{
+-  int pid, fd;
+-
+-  unlink("bigarg-ok");
+-  pid = fork();
+-  if(pid == 0){
+-    static char *args[MAXARG];
+-    int i;
+-    for(i = 0; i < MAXARG-1; i++)
+-      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
+-    args[MAXARG-1] = 0;
+-    printf(stdout, "bigarg test\n");
+-    exec("echo", args);
+-    printf(stdout, "bigarg test ok\n");
+-    fd = open("bigarg-ok", O_CREATE);
+-    close(fd);
+-    exit(6);
+-  } else if(pid < 0){
+-    printf(stdout, "bigargtest: fork failed\n");
+-    exit(5);
+-  }
+-  wait(NULL);
+-  fd = open("bigarg-ok", 0);
+-  if(fd < 0){
+-    printf(stdout, "bigarg test failed!\n");
+-    exit(4);
+-  }
+-  close(fd);
+-  unlink("bigarg-ok");
+-}
+-
+-// what happens when the file system runs out of blocks?
+-// answer: balloc panics, so this test is not useful.
+-void
+-fsfull()
+-{
+-  int nfiles;
+-  int fsblocks = 0;
+-
+-  printf(1, "fsfull test\n");
+-
+-  for(nfiles = 0; ; nfiles++){
+-    char name[64];
+-    name[0] = 'f';
+-    name[1] = '0' + nfiles / 1000;
+-    name[2] = '0' + (nfiles % 1000) / 100;
+-    name[3] = '0' + (nfiles % 100) / 10;
+-    name[4] = '0' + (nfiles % 10);
+-    name[5] = '\0';
+-    printf(1, "writing %s\n", name);
+-    int fd = open(name, O_CREATE|O_RDWR);
+-    if(fd < 0){
+-      printf(1, "open %s failed\n", name);
+-      break;
+-    }
+-    int total = 0;
+-    while(1){
+-      int cc = write(fd, buf, 512);
+-      if(cc < 512)
+-        break;
+-      total += cc;
+-      fsblocks++;
+-    }
+-    printf(1, "wrote %d bytes\n", total);
+-    close(fd);
+-    if(total == 0)
+-      break;
+-  }
+-
+-  while(nfiles >= 0){
+-    char name[64];
+-    name[0] = 'f';
+-    name[1] = '0' + nfiles / 1000;
+-    name[2] = '0' + (nfiles % 1000) / 100;
+-    name[3] = '0' + (nfiles % 100) / 10;
+-    name[4] = '0' + (nfiles % 10);
+-    name[5] = '\0';
+-    unlink(name);
+-    nfiles--;
+-  }
+-
+-  printf(1, "fsfull test finished\n");
+-}
+-
+-void
+-uio()
+-{
+-  #define RTC_ADDR 0x70
+-  #define RTC_DATA 0x71
+-
+-  ushort port = 0;
+-  uchar val = 0;
+-  int pid;
+-
+-  printf(1, "uio test\n");
+-  pid = fork();
+-  if(pid == 0){
+-    port = RTC_ADDR;
+-    val = 0x09;  /* year */
+-    /* http://wiki.osdev.org/Inline_Assembly/Examples */
+-    asm volatile("outb %0,%1"::"a"(val), "d" (port));
+-    port = RTC_DATA;
+-    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+-    printf(1, "uio: uio succeeded; test FAILED\n");
+-    exit(3);
+-  } else if(pid < 0){
+-    printf (1, "fork failed\n");
+-    exit(2);
+-  }
+-  wait(NULL);
+-  printf(1, "uio test done\n");
+-}
+-
+-void argptest()
+-{
+-  int fd;
+-  fd = open("init", O_RDONLY);
+-  if (fd < 0) {
+-    printf(2, "open failed\n");
+-    exit(1);
+-  }
+-  read(fd, sbrk(0) - 1, -1);
+-  close(fd);
+-  printf(1, "arg test passed\n");
+-}
+-
+-unsigned long randstate = 1;
+-unsigned int
+-rand()
+-{
+-  randstate = randstate * 1664525 + 1013904223;
+-  return randstate;
+-}
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  printf(1, "usertests starting\n");
+-
+-  if(open("usertests.ran", 0) >= 0){
+-    printf(1, "already ran user tests -- rebuild fs.img\n");
+-    exit(1);
+-  }
+-  close(open("usertests.ran", O_CREATE));
+-
+-  argptest();
+-  createdelete();
+-  linkunlink();
+-  concreate();
+-  fourfiles();
+-  sharedfd();
+-
+-  bigargtest();
+-  bigwrite();
+-  bigargtest();
+-  bsstest();
+-  sbrktest();
+-  validatetest();
+-
+-  opentest();
+-  writetest();
+-  writetest1();
+-  createtest();
+-
+-  openiputtest();
+-  exitiputtest();
+-  iputtest();
+-
+-  mem();
+-  pipe1();
+-  preempt();
+-  exitwait();
+-
+-  rmdot();
+-  fourteen();
+-  bigfile();
+-  subdir();
+-  linktest();
+-  unlinkread();
+-  dirfile();
+-  iref();
+-  forktest();
+-  bigdir(); // slow
+-
+-  uio();
+-
+-  exectest();
+-
+-  exit(0);
+-}
 diff --git a/usys.S b/usys.S
-index 8bfd8a1..1687ed0 100644
+deleted file mode 100644
+index 1687ed0..0000000
 --- a/usys.S
-+++ b/usys.S
-@@ -11,6 +11,7 @@
- SYSCALL(fork)
- SYSCALL(exit)
- SYSCALL(wait)
-+SYSCALL(waitpid)
- SYSCALL(pipe)
- SYSCALL(read)
- SYSCALL(write)
++++ /dev/null
+@@ -1,32 +0,0 @@
+-#include "syscall.h"
+-#include "traps.h"
+-
+-#define SYSCALL(name) \
+-  .globl name; \
+-  name: \
+-    movl $SYS_ ## name, %eax; \
+-    int $T_SYSCALL; \
+-    ret
+-
+-SYSCALL(fork)
+-SYSCALL(exit)
+-SYSCALL(wait)
+-SYSCALL(waitpid)
+-SYSCALL(pipe)
+-SYSCALL(read)
+-SYSCALL(write)
+-SYSCALL(close)
+-SYSCALL(kill)
+-SYSCALL(exec)
+-SYSCALL(open)
+-SYSCALL(mknod)
+-SYSCALL(unlink)
+-SYSCALL(fstat)
+-SYSCALL(link)
+-SYSCALL(mkdir)
+-SYSCALL(chdir)
+-SYSCALL(dup)
+-SYSCALL(getpid)
+-SYSCALL(sbrk)
+-SYSCALL(sleep)
+-SYSCALL(uptime)
 diff --git a/vectors.pl b/vectors.pl
-old mode 100755
-new mode 100644
+deleted file mode 100644
+index 57b49dd..0000000
+--- a/vectors.pl
++++ /dev/null
+@@ -1,47 +0,0 @@
+-#!/usr/bin/perl -w
+-
+-# Generate vectors.S, the trap/interrupt entry points.
+-# There has to be one entry point per interrupt number
+-# since otherwise there's no way for trap() to discover
+-# the interrupt number.
+-
+-print "# generated by vectors.pl - do not edit\n";
+-print "# handlers\n";
+-print ".globl alltraps\n";
+-for(my $i = 0; $i < 256; $i++){
+-    print ".globl vector$i\n";
+-    print "vector$i:\n";
+-    if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
+-        print "  pushl \$0\n";
+-    }
+-    print "  pushl \$$i\n";
+-    print "  jmp alltraps\n";
+-}
+-
+-print "\n# vector table\n";
+-print ".data\n";
+-print ".globl vectors\n";
+-print "vectors:\n";
+-for(my $i = 0; $i < 256; $i++){
+-    print "  .long vector$i\n";
+-}
+-
+-# sample output:
+-#   # handlers
+-#   .globl alltraps
+-#   .globl vector0
+-#   vector0:
+-#     pushl $0
+-#     pushl $0
+-#     jmp alltraps
+-#   ...
+-#   
+-#   # vector table
+-#   .data
+-#   .globl vectors
+-#   vectors:
+-#     .long vector0
+-#     .long vector1
+-#     .long vector2
+-#   ...
+-
+diff --git a/vm.c b/vm.c
+deleted file mode 100644
+index 7134cff..0000000
+--- a/vm.c
++++ /dev/null
+@@ -1,394 +0,0 @@
+-#include "param.h"
+-#include "types.h"
+-#include "defs.h"
+-#include "x86.h"
+-#include "memlayout.h"
+-#include "mmu.h"
+-#include "proc.h"
+-#include "elf.h"
+-
+-extern char data[];  // defined by kernel.ld
+-pde_t *kpgdir;  // for use in scheduler()
+-
+-// Set up CPU's kernel segment descriptors.
+-// Run once on entry on each CPU.
+-void
+-seginit(void)
+-{
+-  struct cpu *c;
+-
+-  // Map "logical" addresses to virtual addresses using identity map.
+-  // Cannot share a CODE descriptor for both kernel and user
+-  // because it would have to have DPL_USR, but the CPU forbids
+-  // an interrupt from CPL=0 to DPL=3.
+-  c = &cpus[cpuid()];
+-  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+-  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+-  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+-  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+-  lgdt(c->gdt, sizeof(c->gdt));
+-}
+-
+-// Return the address of the PTE in page table pgdir
+-// that corresponds to virtual address va.  If alloc!=0,
+-// create any required page table pages.
+-static pte_t *
+-walkpgdir(pde_t *pgdir, const void *va, int alloc)
+-{
+-  pde_t *pde;
+-  pte_t *pgtab;
+-
+-  pde = &pgdir[PDX(va)];
+-  if(*pde & PTE_P){
+-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+-  } else {
+-    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+-      return 0;
+-    // Make sure all those PTE_P bits are zero.
+-    memset(pgtab, 0, PGSIZE);
+-    // The permissions here are overly generous, but they can
+-    // be further restricted by the permissions in the page table
+-    // entries, if necessary.
+-    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+-  }
+-  return &pgtab[PTX(va)];
+-}
+-
+-// Create PTEs for virtual addresses starting at va that refer to
+-// physical addresses starting at pa. va and size might not
+-// be page-aligned.
+-static int
+-mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
+-{
+-  char *a, *last;
+-  pte_t *pte;
+-
+-  a = (char*)PGROUNDDOWN((uint)va);
+-  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+-  for(;;){
+-    if((pte = walkpgdir(pgdir, a, 1)) == 0)
+-      return -1;
+-    if(*pte & PTE_P)
+-      panic("remap");
+-    *pte = pa | perm | PTE_P;
+-    if(a == last)
+-      break;
+-    a += PGSIZE;
+-    pa += PGSIZE;
+-  }
+-  return 0;
+-}
+-
+-// There is one page table per process, plus one that's used when
+-// a CPU is not running any process (kpgdir). The kernel uses the
+-// current process's page table during system calls and interrupts;
+-// page protection bits prevent user code from using the kernel's
+-// mappings.
+-//
+-// setupkvm() and exec() set up every page table like this:
+-//
+-//   0..KERNBASE: user memory (text+data+stack+heap), mapped to
+-//                phys memory allocated by the kernel
+-//   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)
+-//   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)
+-//                for the kernel's instructions and r/o data
+-//   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,
+-//                                  rw data + free physical memory
+-//   0xfe000000..0: mapped direct (devices such as ioapic)
+-//
+-// The kernel allocates physical memory for its heap and for user memory
+-// between V2P(end) and the end of physical memory (PHYSTOP)
+-// (directly addressable from end..P2V(PHYSTOP)).
+-
+-// This table defines the kernel's mappings, which are present in
+-// every process's page table.
+-static struct kmap {
+-  void *virt;
+-  uint phys_start;
+-  uint phys_end;
+-  int perm;
+-} kmap[] = {
+- { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
+- { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
+- { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
+- { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
+-};
+-
+-// Set up kernel part of a page table.
+-pde_t*
+-setupkvm(void)
+-{
+-  pde_t *pgdir;
+-  struct kmap *k;
+-
+-  if((pgdir = (pde_t*)kalloc()) == 0)
+-    return 0;
+-  memset(pgdir, 0, PGSIZE);
+-  if (P2V(PHYSTOP) > (void*)DEVSPACE)
+-    panic("PHYSTOP too high");
+-  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+-    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+-                (uint)k->phys_start, k->perm) < 0) {
+-      freevm(pgdir);
+-      return 0;
+-    }
+-  return pgdir;
+-}
+-
+-// Allocate one page table for the machine for the kernel address
+-// space for scheduler processes.
+-void
+-kvmalloc(void)
+-{
+-  kpgdir = setupkvm();
+-  switchkvm();
+-}
+-
+-// Switch h/w page table register to the kernel-only page table,
+-// for when no process is running.
+-void
+-switchkvm(void)
+-{
+-  lcr3(V2P(kpgdir));   // switch to the kernel page table
+-}
+-
+-// Switch TSS and h/w page table to correspond to process p.
+-void
+-switchuvm(struct proc *p)
+-{
+-  if(p == 0)
+-    panic("switchuvm: no process");
+-  if(p->kstack == 0)
+-    panic("switchuvm: no kstack");
+-  if(p->pgdir == 0)
+-    panic("switchuvm: no pgdir");
+-
+-  pushcli();
+-  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
+-                                sizeof(mycpu()->ts)-1, 0);
+-  mycpu()->gdt[SEG_TSS].s = 0;
+-  mycpu()->ts.ss0 = SEG_KDATA << 3;
+-  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+-  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
+-  // forbids I/O instructions (e.g., inb and outb) from user space
+-  mycpu()->ts.iomb = (ushort) 0xFFFF;
+-  ltr(SEG_TSS << 3);
+-  lcr3(V2P(p->pgdir));  // switch to process's address space
+-  popcli();
+-}
+-
+-// Load the initcode into address 0 of pgdir.
+-// sz must be less than a page.
+-void
+-inituvm(pde_t *pgdir, char *init, uint sz)
+-{
+-  char *mem;
+-
+-  if(sz >= PGSIZE)
+-    panic("inituvm: more than a page");
+-  mem = kalloc();
+-  memset(mem, 0, PGSIZE);
+-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
+-  memmove(mem, init, sz);
+-}
+-
+-// Load a program segment into pgdir.  addr must be page-aligned
+-// and the pages from addr to addr+sz must already be mapped.
+-int
+-loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
+-{
+-  uint i, pa, n;
+-  pte_t *pte;
+-
+-  if((uint) addr % PGSIZE != 0)
+-    panic("loaduvm: addr must be page aligned");
+-  for(i = 0; i < sz; i += PGSIZE){
+-    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
+-      panic("loaduvm: address should exist");
+-    pa = PTE_ADDR(*pte);
+-    if(sz - i < PGSIZE)
+-      n = sz - i;
+-    else
+-      n = PGSIZE;
+-    if(readi(ip, P2V(pa), offset+i, n) != n)
+-      return -1;
+-  }
+-  return 0;
+-}
+-
+-// Allocate page tables and physical memory to grow process from oldsz to
+-// newsz, which need not be page aligned.  Returns new size or 0 on error.
+-int
+-allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+-{
+-  char *mem;
+-  uint a;
+-
+-  if(newsz >= KERNBASE)
+-    return 0;
+-  if(newsz < oldsz)
+-    return oldsz;
+-
+-  a = PGROUNDUP(oldsz);
+-  for(; a < newsz; a += PGSIZE){
+-    mem = kalloc();
+-    if(mem == 0){
+-      cprintf("allocuvm out of memory\n");
+-      deallocuvm(pgdir, newsz, oldsz);
+-      return 0;
+-    }
+-    memset(mem, 0, PGSIZE);
+-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
+-      cprintf("allocuvm out of memory (2)\n");
+-      deallocuvm(pgdir, newsz, oldsz);
+-      kfree(mem);
+-      return 0;
+-    }
+-  }
+-  return newsz;
+-}
+-
+-// Deallocate user pages to bring the process size from oldsz to
+-// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+-// need to be less than oldsz.  oldsz can be larger than the actual
+-// process size.  Returns the new process size.
+-int
+-deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+-{
+-  pte_t *pte;
+-  uint a, pa;
+-
+-  if(newsz >= oldsz)
+-    return oldsz;
+-
+-  a = PGROUNDUP(newsz);
+-  for(; a  < oldsz; a += PGSIZE){
+-    pte = walkpgdir(pgdir, (char*)a, 0);
+-    if(!pte)
+-      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+-    else if((*pte & PTE_P) != 0){
+-      pa = PTE_ADDR(*pte);
+-      if(pa == 0)
+-        panic("kfree");
+-      char *v = P2V(pa);
+-      kfree(v);
+-      *pte = 0;
+-    }
+-  }
+-  return newsz;
+-}
+-
+-// Free a page table and all the physical memory pages
+-// in the user part.
+-void
+-freevm(pde_t *pgdir)
+-{
+-  uint i;
+-
+-  if(pgdir == 0)
+-    panic("freevm: no pgdir");
+-  deallocuvm(pgdir, KERNBASE, 0);
+-  for(i = 0; i < NPDENTRIES; i++){
+-    if(pgdir[i] & PTE_P){
+-      char * v = P2V(PTE_ADDR(pgdir[i]));
+-      kfree(v);
+-    }
+-  }
+-  kfree((char*)pgdir);
+-}
+-
+-// Clear PTE_U on a page. Used to create an inaccessible
+-// page beneath the user stack.
+-void
+-clearpteu(pde_t *pgdir, char *uva)
+-{
+-  pte_t *pte;
+-
+-  pte = walkpgdir(pgdir, uva, 0);
+-  if(pte == 0)
+-    panic("clearpteu");
+-  *pte &= ~PTE_U;
+-}
+-
+-// Given a parent process's page table, create a copy
+-// of it for a child.
+-pde_t*
+-copyuvm(pde_t *pgdir, uint sz)
+-{
+-  pde_t *d;
+-  pte_t *pte;
+-  uint pa, i, flags;
+-  char *mem;
+-
+-  if((d = setupkvm()) == 0)
+-    return 0;
+-  for(i = 0; i < sz; i += PGSIZE){
+-    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+-      panic("copyuvm: pte should exist");
+-    if(!(*pte & PTE_P))
+-      panic("copyuvm: page not present");
+-    pa = PTE_ADDR(*pte);
+-    flags = PTE_FLAGS(*pte);
+-    if((mem = kalloc()) == 0)
+-      goto bad;
+-    memmove(mem, (char*)P2V(pa), PGSIZE);
+-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
+-      kfree(mem);
+-      goto bad;
+-    }
+-  }
+-  return d;
+-
+-bad:
+-  freevm(d);
+-  return 0;
+-}
+-
+-//PAGEBREAK!
+-// Map user virtual address to kernel address.
+-char*
+-uva2ka(pde_t *pgdir, char *uva)
+-{
+-  pte_t *pte;
+-
+-  pte = walkpgdir(pgdir, uva, 0);
+-  if((*pte & PTE_P) == 0)
+-    return 0;
+-  if((*pte & PTE_U) == 0)
+-    return 0;
+-  return (char*)P2V(PTE_ADDR(*pte));
+-}
+-
+-// Copy len bytes from p to user address va in page table pgdir.
+-// Most useful when pgdir is not the current page table.
+-// uva2ka ensures this only works for PTE_U pages.
+-int
+-copyout(pde_t *pgdir, uint va, void *p, uint len)
+-{
+-  char *buf, *pa0;
+-  uint n, va0;
+-
+-  buf = (char*)p;
+-  while(len > 0){
+-    va0 = (uint)PGROUNDDOWN(va);
+-    pa0 = uva2ka(pgdir, (char*)va0);
+-    if(pa0 == 0)
+-      return -1;
+-    n = PGSIZE - (va - va0);
+-    if(n > len)
+-      n = len;
+-    memmove(pa0 + (va - va0), buf, n);
+-    len -= n;
+-    buf += n;
+-    va = va0 + PGSIZE;
+-  }
+-  return 0;
+-}
+-
+-//PAGEBREAK!
+-// Blank page.
+-//PAGEBREAK!
+-// Blank page.
+-//PAGEBREAK!
+-// Blank page.
+-
 diff --git a/wc.c b/wc.c
-index d6a54df..08b93b6 100644
+deleted file mode 100644
+index 08b93b6..0000000
 --- a/wc.c
-+++ b/wc.c
-@@ -27,7 +27,7 @@ wc(int fd, char *name)
-   }
-   if(n < 0){
-     printf(1, "wc: read error\n");
--    exit();
-+    exit(3);
-   }
-   printf(1, "%d %d %d %s\n", l, w, c, name);
- }
-@@ -39,16 +39,16 @@ main(int argc, char *argv[])
- 
-   if(argc <= 1){
-     wc(0, "");
--    exit();
-+    exit(2);
-   }
- 
-   for(i = 1; i < argc; i++){
-     if((fd = open(argv[i], 0)) < 0){
-       printf(1, "wc: cannot open %s\n", argv[i]);
--      exit();
-+      exit(1);
-     }
-     wc(fd, argv[i]);
-     close(fd);
-   }
--  exit();
-+  exit(0);
- }
++++ /dev/null
+@@ -1,54 +0,0 @@
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-char buf[512];
+-
+-void
+-wc(int fd, char *name)
+-{
+-  int i, n;
+-  int l, w, c, inword;
+-
+-  l = w = c = 0;
+-  inword = 0;
+-  while((n = read(fd, buf, sizeof(buf))) > 0){
+-    for(i=0; i<n; i++){
+-      c++;
+-      if(buf[i] == '\n')
+-        l++;
+-      if(strchr(" \r\t\n\v", buf[i]))
+-        inword = 0;
+-      else if(!inword){
+-        w++;
+-        inword = 1;
+-      }
+-    }
+-  }
+-  if(n < 0){
+-    printf(1, "wc: read error\n");
+-    exit(3);
+-  }
+-  printf(1, "%d %d %d %s\n", l, w, c, name);
+-}
+-
+-int
+-main(int argc, char *argv[])
+-{
+-  int fd, i;
+-
+-  if(argc <= 1){
+-    wc(0, "");
+-    exit(2);
+-  }
+-
+-  for(i = 1; i < argc; i++){
+-    if((fd = open(argv[i], 0)) < 0){
+-      printf(1, "wc: cannot open %s\n", argv[i]);
+-      exit(1);
+-    }
+-    wc(fd, argv[i]);
+-    close(fd);
+-  }
+-  exit(0);
+-}
+diff --git a/x86.h b/x86.h
+deleted file mode 100644
+index 07312a5..0000000
+--- a/x86.h
++++ /dev/null
+@@ -1,183 +0,0 @@
+-// Routines to let C code use special x86 instructions.
+-
+-static inline uchar
+-inb(ushort port)
+-{
+-  uchar data;
+-
+-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+-  return data;
+-}
+-
+-static inline void
+-insl(int port, void *addr, int cnt)
+-{
+-  asm volatile("cld; rep insl" :
+-               "=D" (addr), "=c" (cnt) :
+-               "d" (port), "0" (addr), "1" (cnt) :
+-               "memory", "cc");
+-}
+-
+-static inline void
+-outb(ushort port, uchar data)
+-{
+-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+-}
+-
+-static inline void
+-outw(ushort port, ushort data)
+-{
+-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+-}
+-
+-static inline void
+-outsl(int port, const void *addr, int cnt)
+-{
+-  asm volatile("cld; rep outsl" :
+-               "=S" (addr), "=c" (cnt) :
+-               "d" (port), "0" (addr), "1" (cnt) :
+-               "cc");
+-}
+-
+-static inline void
+-stosb(void *addr, int data, int cnt)
+-{
+-  asm volatile("cld; rep stosb" :
+-               "=D" (addr), "=c" (cnt) :
+-               "0" (addr), "1" (cnt), "a" (data) :
+-               "memory", "cc");
+-}
+-
+-static inline void
+-stosl(void *addr, int data, int cnt)
+-{
+-  asm volatile("cld; rep stosl" :
+-               "=D" (addr), "=c" (cnt) :
+-               "0" (addr), "1" (cnt), "a" (data) :
+-               "memory", "cc");
+-}
+-
+-struct segdesc;
+-
+-static inline void
+-lgdt(struct segdesc *p, int size)
+-{
+-  volatile ushort pd[3];
+-
+-  pd[0] = size-1;
+-  pd[1] = (uint)p;
+-  pd[2] = (uint)p >> 16;
+-
+-  asm volatile("lgdt (%0)" : : "r" (pd));
+-}
+-
+-struct gatedesc;
+-
+-static inline void
+-lidt(struct gatedesc *p, int size)
+-{
+-  volatile ushort pd[3];
+-
+-  pd[0] = size-1;
+-  pd[1] = (uint)p;
+-  pd[2] = (uint)p >> 16;
+-
+-  asm volatile("lidt (%0)" : : "r" (pd));
+-}
+-
+-static inline void
+-ltr(ushort sel)
+-{
+-  asm volatile("ltr %0" : : "r" (sel));
+-}
+-
+-static inline uint
+-readeflags(void)
+-{
+-  uint eflags;
+-  asm volatile("pushfl; popl %0" : "=r" (eflags));
+-  return eflags;
+-}
+-
+-static inline void
+-loadgs(ushort v)
+-{
+-  asm volatile("movw %0, %%gs" : : "r" (v));
+-}
+-
+-static inline void
+-cli(void)
+-{
+-  asm volatile("cli");
+-}
+-
+-static inline void
+-sti(void)
+-{
+-  asm volatile("sti");
+-}
+-
+-static inline uint
+-xchg(volatile uint *addr, uint newval)
+-{
+-  uint result;
+-
+-  // The + in "+m" denotes a read-modify-write operand.
+-  asm volatile("lock; xchgl %0, %1" :
+-               "+m" (*addr), "=a" (result) :
+-               "1" (newval) :
+-               "cc");
+-  return result;
+-}
+-
+-static inline uint
+-rcr2(void)
+-{
+-  uint val;
+-  asm volatile("movl %%cr2,%0" : "=r" (val));
+-  return val;
+-}
+-
+-static inline void
+-lcr3(uint val)
+-{
+-  asm volatile("movl %0,%%cr3" : : "r" (val));
+-}
+-
+-//PAGEBREAK: 36
+-// Layout of the trap frame built on the stack by the
+-// hardware and by trapasm.S, and passed to trap().
+-struct trapframe {
+-  // registers as pushed by pusha
+-  uint edi;
+-  uint esi;
+-  uint ebp;
+-  uint oesp;      // useless & ignored
+-  uint ebx;
+-  uint edx;
+-  uint ecx;
+-  uint eax;
+-
+-  // rest of trap frame
+-  ushort gs;
+-  ushort padding1;
+-  ushort fs;
+-  ushort padding2;
+-  ushort es;
+-  ushort padding3;
+-  ushort ds;
+-  ushort padding4;
+-  uint trapno;
+-
+-  // below here defined by x86 hardware
+-  uint err;
+-  uint eip;
+-  ushort cs;
+-  ushort padding5;
+-  uint eflags;
+-
+-  // below here only when crossing rings, such as from user to kernel
+-  uint esp;
+-  ushort ss;
+-  ushort padding6;
+-};
 diff --git a/zombie.c b/zombie.c
-index ee817da..c96b92d 100644
+deleted file mode 100644
+index c96b92d..0000000
 --- a/zombie.c
-+++ b/zombie.c
-@@ -10,5 +10,5 @@ main(void)
- {
-   if(fork() > 0)
-     sleep(5);  // Let child exit before parent.
--  exit();
-+  exit(0);
- }
++++ /dev/null
+@@ -1,14 +0,0 @@
+-// Create a zombie process that
+-// must be reparented at exit.
+-
+-#include "types.h"
+-#include "stat.h"
+-#include "user.h"
+-
+-int
+-main(void)
+-{
+-  if(fork() > 0)
+-    sleep(5);  // Let child exit before parent.
+-  exit(0);
+-}
diff --git a/code2.diff b/code2.diff
new file mode 100644
index 0000000..0b9fe02
--- /dev/null
+++ b/code2.diff
@@ -0,0 +1,37044 @@
+diff --git a/.cvsignore b/.cvsignore
+deleted file mode 100644
+index 081a43c..0000000
+--- a/.cvsignore
++++ /dev/null
+@@ -1,16 +0,0 @@
+-*.asm
+-*.d
+-*.sym
+-_*
+-kernel
+-user1
+-userfs
+-usertests
+-xv6.img
+-vectors.S
+-bochsout.txt
+-bootblock
+-bootother
+-bootother.out
+-parport.out
+-fmt
+diff --git a/.dir-locals.el b/.dir-locals.el
+deleted file mode 100644
+index da72247..0000000
+--- a/.dir-locals.el
++++ /dev/null
+@@ -1,4 +0,0 @@
+-((c-mode
+-  (indent-tabs-mode . nil)
+-  (c-file-style . "bsd")
+-  (c-basic-offset . 2)))
+diff --git a/.gdbinit.tmpl b/.gdbinit.tmpl
+index f71681a..ac7a259 100644
+--- a/.gdbinit.tmpl
++++ b/.gdbinit.tmpl
+@@ -24,4 +24,4 @@ echo + target remote localhost:1234\n
+ target remote localhost:1234
+ 
+ echo + symbol-file kernel\n
+-symbol-file kernel
++symbol-file kernel
+\ No newline at end of file
+diff --git a/.gitignore b/.gitignore
+deleted file mode 100644
+index 3e2c9de..0000000
+--- a/.gitignore
++++ /dev/null
+@@ -1,16 +0,0 @@
+-*~
+-_*
+-*.o
+-*.d
+-*.asm
+-*.sym
+-*.img
+-vectors.S
+-bootblock
+-entryother
+-initcode
+-initcode.out
+-kernel
+-kernelmemfs
+-mkfs
+-.gdbinit
+diff --git a/.idea/xv6.iml b/.idea/xv6.iml
+index 5aac3dd..771e54c 100644
+--- a/.idea/xv6.iml
++++ b/.idea/xv6.iml
+@@ -1,2 +1,2 @@
+ <?xml version="1.0" encoding="UTF-8"?>
+-<module classpath="External" external.linked.project.id="xv6" external.linked.project.path="C:\Users\Kotori\Desktop\Code Projects\School\xv6\xv6" external.root.project.path="$MODULE_DIR$" external.system.id="Makefile" type="CPP_MODULE" version="4" />
+\ No newline at end of file
++<module classpath="External" type="CPP_MODULE" version="4" />
+\ No newline at end of file
+diff --git a/LICENSE b/LICENSE
+index 422c0cc..4ec362c 100644
+--- a/LICENSE
++++ b/LICENSE
+@@ -1,6 +1,6 @@
+ The xv6 software is:
+ 
+-Copyright (c) 2006-2018 Frans Kaashoek, Robert Morris, Russ Cox,
++Copyright (c) 2006-2017 Frans Kaashoek, Robert Morris, Russ Cox,
+                         Massachusetts Institute of Technology
+ 
+ Permission is hereby granted, free of charge, to any person obtaining
+diff --git a/Makefile b/Makefile
+index 04d74d5..be7fd50 100644
+--- a/Makefile
++++ b/Makefile
+@@ -27,6 +27,7 @@ OBJS = \
+ 	uart.o\
+ 	vectors.o\
+ 	vm.o\
++	shm.o\
+ 
+ # Cross-compiling (e.g., on Mac OS X)
+ # TOOLPREFIX = i386-jos-elf
+@@ -77,20 +78,13 @@ LD = $(TOOLPREFIX)ld
+ OBJCOPY = $(TOOLPREFIX)objcopy
+ OBJDUMP = $(TOOLPREFIX)objdump
+ CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
++#CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
+ CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+ # FreeBSD ld wants ``elf_i386_fbsd''
+ LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+ 
+-# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+-CFLAGS += -fno-pie -no-pie
+-endif
+-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+-CFLAGS += -fno-pie -nopie
+-endif
+-
+-xv6.img: bootblock kernel
++xv6.img: bootblock kernel fs.img
+ 	dd if=/dev/zero of=xv6.img count=10000
+ 	dd if=bootblock of=xv6.img conv=notrunc
+ 	dd if=kernel of=xv6.img seek=1 conv=notrunc
+@@ -141,19 +135,19 @@ tags: $(OBJS) entryother.S _init
+ 	etags *.S *.c
+ 
+ vectors.S: vectors.pl
+-	./vectors.pl > vectors.S
++	perl vectors.pl > vectors.S
+ 
+-ULIB = ulib.o usys.o printf.o umalloc.o
++ULIB = ulib.o usys.o printf.o umalloc.o uspinlock.o
+ 
+ _%: %.o $(ULIB)
+-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
++	$(LD) $(LDFLAGS) -N -e main -Ttext 0x1000 -o $@ $^
+ 	$(OBJDUMP) -S $@ > $*.asm
+ 	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+ 
+ _forktest: forktest.o $(ULIB)
+ 	# forktest has less library code linked in - needs to be small
+ 	# in order to be able to max out the proc table.
+-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
++	$(LD) $(LDFLAGS) -N -e main -Ttext 0x1000 -o _forktest forktest.o ulib.o usys.o
+ 	$(OBJDUMP) -S _forktest > forktest.asm
+ 
+ mkfs: mkfs.c fs.h
+@@ -181,7 +175,10 @@ UPROGS=\
+ 	_usertests\
+ 	_wc\
+ 	_zombie\
+-	_lab1\
++	_shm_cnt\
++	_null\
++	_lab3\
++	_lab3p2\
+ 
+ fs.img: mkfs README $(UPROGS)
+ 	./mkfs fs.img README $(UPROGS)
+@@ -191,8 +188,8 @@ fs.img: mkfs README $(UPROGS)
+ clean: 
+ 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+ 	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+-	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+-	xv6memfs.img mkfs .gdbinit \
++	initcode initcode.out kernel xv6.img fs.img kernelmemfs mkfs \
++	.gdbinit \
+ 	$(UPROGS)
+ 
+ # make a printout
+@@ -218,7 +215,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+ 	then echo "-gdb tcp::$(GDBPORT)"; \
+ 	else echo "-s -p $(GDBPORT)"; fi)
+ ifndef CPUS
+-CPUS := 2
++CPUS := 1
+ endif
+ QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+ 
+@@ -251,7 +248,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
+ EXTRA=\
+ 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+ 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+-	printf.c umalloc.c\
++	printf.c umalloc.c uspinlock.c shm_cnt.c\
+ 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+ 	.gdbinit.tmpl gdbutil\
+ 
+diff --git a/README b/README
+index 923e0a4..b82e8d2 100644
+--- a/README
++++ b/README
+@@ -1,7 +1,3 @@
+-NOTE: we have stopped maintaining the x86 version of xv6, and switched
+-our efforts to the RISC-V version
+-(https://github.com/mit-pdos/xv6-riscv.git)
+-
+ xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
+ Version 6 (v6).  xv6 loosely follows the structure and style of v6,
+ but is implemented for a modern x86-based multiprocessor using ANSI C.
+@@ -10,7 +6,7 @@ ACKNOWLEDGMENTS
+ 
+ xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
+ to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
+-2000)). See also https://pdos.csail.mit.edu/6.828/, which
++2000)). See also http://pdos.csail.mit.edu/6.828/2016/xv6.html, which
+ provides pointers to on-line resources for v6.
+ 
+ xv6 borrows code from the following sources:
+@@ -24,28 +20,30 @@ locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
+ Clements.
+ 
+ We are also grateful for the bug reports and patches contributed by Silas
+-Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,
+-Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter
+-Froehlich, Yakir Goaron,Shivam Handa, Bryan Henry, Jim Huang, Alexander
+-Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller, Eddie Kohler, Austin
+-Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi
+-Merimovich, Mark Morrissey, mtasm, Joel Nider, Greg Price, Ayan Shafqat,
+-Eldar Sehayek, Yongming Shen, Cam Tenny, tyfkda, Rafael Ubal, Warren
+-Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
+-Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang Wei.
++Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, Nelson Elhage,
++Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter Froehlich, Yakir Goaron,
++Shivam Handa, Bryan Henry, Jim Huang, Alexander Kapshuk, Anders Kaseorg,
++kehao95, Wolfgang Keller, Eddie Kohler, Austin Liew, Imbar Marinescu, Yandong
++Mao, Hitoshi Mitake, Carmi Merimovich, Joel Nider, Greg Price, Ayan Shafqat,
++Eldar Sehayek, Yongming Shen, Cam Tenny, Rafael Ubal, Warren Toomey, Stephen Tu,
++Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas Wolovick, Grant Wu, Jindong
++Zhang, Icenowy Zheng, and Zou Chang Wei.
+ 
+ The code in the files that constitute xv6 is
+-Copyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.
++Copyright 2006-2016 Frans Kaashoek, Robert Morris, and Russ Cox.
+ 
+ ERROR REPORTS
+ 
+-We don't process error reports (see note on top of this file).
++Please send errors and suggestions to Frans Kaashoek and Robert Morris
++(kaashoek,rtm@mit.edu). The main purpose of xv6 is as a teaching
++operating system for MIT's 6.828, so we are more interested in
++simplifications and clarifications than new features.
+ 
+ BUILDING AND RUNNING XV6
+ 
+ To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
+ "make". On non-x86 or non-ELF machines (like OS X, even on x86), you
+ will need to install a cross-compiler gcc suite capable of producing
+-x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
++x86 ELF binaries. See http://pdos.csail.mit.edu/6.828/2016/tools.html.
+ Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
+-simulator and run "make qemu".
+\ No newline at end of file
++simulator and run "make qemu".
+diff --git a/_cat b/_cat
+new file mode 100644
+index 0000000..cfaa8f4
+Binary files /dev/null and b/_cat differ
+diff --git a/_echo b/_echo
+new file mode 100644
+index 0000000..4442637
+Binary files /dev/null and b/_echo differ
+diff --git a/_forktest b/_forktest
+new file mode 100644
+index 0000000..8542b3c
+Binary files /dev/null and b/_forktest differ
+diff --git a/_grep b/_grep
+new file mode 100644
+index 0000000..facda7a
+Binary files /dev/null and b/_grep differ
+diff --git a/_init b/_init
+new file mode 100644
+index 0000000..395d671
+Binary files /dev/null and b/_init differ
+diff --git a/_kill b/_kill
+new file mode 100644
+index 0000000..edfedd8
+Binary files /dev/null and b/_kill differ
+diff --git a/_ln b/_ln
+new file mode 100644
+index 0000000..e9f132b
+Binary files /dev/null and b/_ln differ
+diff --git a/_ls b/_ls
+new file mode 100644
+index 0000000..9c5bda8
+Binary files /dev/null and b/_ls differ
+diff --git a/_mkdir b/_mkdir
+new file mode 100644
+index 0000000..c420bc8
+Binary files /dev/null and b/_mkdir differ
+diff --git a/_null b/_null
+new file mode 100644
+index 0000000..02f3d6d
+Binary files /dev/null and b/_null differ
+diff --git a/_rm b/_rm
+new file mode 100644
+index 0000000..208c5ca
+Binary files /dev/null and b/_rm differ
+diff --git a/_sh b/_sh
+new file mode 100644
+index 0000000..17e639e
+Binary files /dev/null and b/_sh differ
+diff --git a/_shm_cnt b/_shm_cnt
+new file mode 100644
+index 0000000..a0ac31e
+Binary files /dev/null and b/_shm_cnt differ
+diff --git a/_stressfs b/_stressfs
+new file mode 100644
+index 0000000..26a491c
+Binary files /dev/null and b/_stressfs differ
+diff --git a/_usertests b/_usertests
+new file mode 100644
+index 0000000..d6ed5f9
+Binary files /dev/null and b/_usertests differ
+diff --git a/_wc b/_wc
+new file mode 100644
+index 0000000..6d1738a
+Binary files /dev/null and b/_wc differ
+diff --git a/_zombie b/_zombie
+new file mode 100644
+index 0000000..8f081ce
+Binary files /dev/null and b/_zombie differ
+diff --git a/asm.h b/asm.h
+index b8a7353..68210d7 100644
+--- a/asm.h
++++ b/asm.h
+@@ -14,5 +14,8 @@
+                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
+ 
+ #define STA_X     0x8       // Executable segment
++#define STA_E     0x4       // Expand down (non-executable segments)
++#define STA_C     0x4       // Conforming code segment (executable only)
+ #define STA_W     0x2       // Writeable (non-executable segments)
+ #define STA_R     0x2       // Readable (executable segments)
++#define STA_A     0x1       // Accessed
+diff --git a/bio.d b/bio.d
+new file mode 100644
+index 0000000..b4bbd30
+--- /dev/null
++++ b/bio.d
+@@ -0,0 +1,2 @@
++bio.o: bio.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h \
++ sleeplock.h fs.h buf.h
+diff --git a/bio.o b/bio.o
+new file mode 100644
+index 0000000..ffb2b32
+Binary files /dev/null and b/bio.o differ
+diff --git a/bootasm.d b/bootasm.d
+new file mode 100644
+index 0000000..3b3dc19
+--- /dev/null
++++ b/bootasm.d
+@@ -0,0 +1 @@
++bootasm.o: bootasm.S asm.h memlayout.h mmu.h
+diff --git a/bootasm.o b/bootasm.o
+new file mode 100644
+index 0000000..f960dd1
+Binary files /dev/null and b/bootasm.o differ
+diff --git a/bootblock b/bootblock
+new file mode 100644
+index 0000000..ff63c64
+Binary files /dev/null and b/bootblock differ
+diff --git a/bootblock.asm b/bootblock.asm
+new file mode 100644
+index 0000000..bf77419
+--- /dev/null
++++ b/bootblock.asm
+@@ -0,0 +1,353 @@
++
++bootblock.o:     file format elf32-i386
++
++
++Disassembly of section .text:
++
++00007c00 <start>:
++# with %cs=0 %ip=7c00.
++
++.code16                       # Assemble for 16-bit mode
++.globl start
++start:
++  cli                         # BIOS enabled interrupts; disable
++    7c00:	fa                   	cli    
++
++  # Zero data segment registers DS, ES, and SS.
++  xorw    %ax,%ax             # Set %ax to zero
++    7c01:	31 c0                	xor    %eax,%eax
++  movw    %ax,%ds             # -> Data Segment
++    7c03:	8e d8                	mov    %eax,%ds
++  movw    %ax,%es             # -> Extra Segment
++    7c05:	8e c0                	mov    %eax,%es
++  movw    %ax,%ss             # -> Stack Segment
++    7c07:	8e d0                	mov    %eax,%ss
++
++00007c09 <seta20.1>:
++
++  # Physical address line A20 is tied to zero so that the first PCs 
++  # with 2 MB would run software that assumed 1 MB.  Undo that.
++seta20.1:
++  inb     $0x64,%al               # Wait for not busy
++    7c09:	e4 64                	in     $0x64,%al
++  testb   $0x2,%al
++    7c0b:	a8 02                	test   $0x2,%al
++  jnz     seta20.1
++    7c0d:	75 fa                	jne    7c09 <seta20.1>
++
++  movb    $0xd1,%al               # 0xd1 -> port 0x64
++    7c0f:	b0 d1                	mov    $0xd1,%al
++  outb    %al,$0x64
++    7c11:	e6 64                	out    %al,$0x64
++
++00007c13 <seta20.2>:
++
++seta20.2:
++  inb     $0x64,%al               # Wait for not busy
++    7c13:	e4 64                	in     $0x64,%al
++  testb   $0x2,%al
++    7c15:	a8 02                	test   $0x2,%al
++  jnz     seta20.2
++    7c17:	75 fa                	jne    7c13 <seta20.2>
++
++  movb    $0xdf,%al               # 0xdf -> port 0x60
++    7c19:	b0 df                	mov    $0xdf,%al
++  outb    %al,$0x60
++    7c1b:	e6 60                	out    %al,$0x60
++
++  # Switch from real to protected mode.  Use a bootstrap GDT that makes
++  # virtual addresses map directly to physical addresses so that the
++  # effective memory map doesn't change during the transition.
++  lgdt    gdtdesc
++    7c1d:	0f 01 16             	lgdtl  (%esi)
++    7c20:	78 7c                	js     7c9e <readsect+0xe>
++  movl    %cr0, %eax
++    7c22:	0f 20 c0             	mov    %cr0,%eax
++  orl     $CR0_PE, %eax
++    7c25:	66 83 c8 01          	or     $0x1,%ax
++  movl    %eax, %cr0
++    7c29:	0f 22 c0             	mov    %eax,%cr0
++
++//PAGEBREAK!
++  # Complete the transition to 32-bit protected mode by using a long jmp
++  # to reload %cs and %eip.  The segment descriptors are set up with no
++  # translation, so that the mapping is still the identity mapping.
++  ljmp    $(SEG_KCODE<<3), $start32
++    7c2c:	ea                   	.byte 0xea
++    7c2d:	31 7c 08 00          	xor    %edi,0x0(%eax,%ecx,1)
++
++00007c31 <start32>:
++
++.code32  # Tell assembler to generate 32-bit code now.
++start32:
++  # Set up the protected-mode data segment registers
++  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
++    7c31:	66 b8 10 00          	mov    $0x10,%ax
++  movw    %ax, %ds                # -> DS: Data Segment
++    7c35:	8e d8                	mov    %eax,%ds
++  movw    %ax, %es                # -> ES: Extra Segment
++    7c37:	8e c0                	mov    %eax,%es
++  movw    %ax, %ss                # -> SS: Stack Segment
++    7c39:	8e d0                	mov    %eax,%ss
++  movw    $0, %ax                 # Zero segments not ready for use
++    7c3b:	66 b8 00 00          	mov    $0x0,%ax
++  movw    %ax, %fs                # -> FS
++    7c3f:	8e e0                	mov    %eax,%fs
++  movw    %ax, %gs                # -> GS
++    7c41:	8e e8                	mov    %eax,%gs
++
++  # Set up the stack pointer and call into C.
++  movl    $start, %esp
++    7c43:	bc 00 7c 00 00       	mov    $0x7c00,%esp
++  call    bootmain
++    7c48:	e8 e2 00 00 00       	call   7d2f <bootmain>
++
++  # If bootmain returns (it shouldn't), trigger a Bochs
++  # breakpoint if running under Bochs, then loop.
++  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
++    7c4d:	66 b8 00 8a          	mov    $0x8a00,%ax
++  movw    %ax, %dx
++    7c51:	66 89 c2             	mov    %ax,%dx
++  outw    %ax, %dx
++    7c54:	66 ef                	out    %ax,(%dx)
++  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
++    7c56:	66 b8 e0 8a          	mov    $0x8ae0,%ax
++  outw    %ax, %dx
++    7c5a:	66 ef                	out    %ax,(%dx)
++
++00007c5c <spin>:
++spin:
++  jmp     spin
++    7c5c:	eb fe                	jmp    7c5c <spin>
++    7c5e:	66 90                	xchg   %ax,%ax
++
++00007c60 <gdt>:
++	...
++    7c68:	ff                   	(bad)  
++    7c69:	ff 00                	incl   (%eax)
++    7c6b:	00 00                	add    %al,(%eax)
++    7c6d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
++    7c74:	00                   	.byte 0x0
++    7c75:	92                   	xchg   %eax,%edx
++    7c76:	cf                   	iret   
++	...
++
++00007c78 <gdtdesc>:
++    7c78:	17                   	pop    %ss
++    7c79:	00 60 7c             	add    %ah,0x7c(%eax)
++	...
++
++00007c7e <waitdisk>:
++  entry();
++}
++
++void
++waitdisk(void)
++{
++    7c7e:	55                   	push   %ebp
++    7c7f:	89 e5                	mov    %esp,%ebp
++static inline uchar
++inb(ushort port)
++{
++  uchar data;
++
++  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
++    7c81:	ba f7 01 00 00       	mov    $0x1f7,%edx
++    7c86:	ec                   	in     (%dx),%al
++  // Wait for disk ready.
++  while((inb(0x1F7) & 0xC0) != 0x40)
++    7c87:	83 e0 c0             	and    $0xffffffc0,%eax
++    7c8a:	3c 40                	cmp    $0x40,%al
++    7c8c:	75 f8                	jne    7c86 <waitdisk+0x8>
++    ;
++}
++    7c8e:	5d                   	pop    %ebp
++    7c8f:	c3                   	ret    
++
++00007c90 <readsect>:
++
++// Read a single sector at offset into dst.
++void
++readsect(void *dst, uint offset)
++{
++    7c90:	55                   	push   %ebp
++    7c91:	89 e5                	mov    %esp,%ebp
++    7c93:	57                   	push   %edi
++    7c94:	53                   	push   %ebx
++    7c95:	8b 5d 0c             	mov    0xc(%ebp),%ebx
++  // Issue command.
++  waitdisk();
++    7c98:	e8 e1 ff ff ff       	call   7c7e <waitdisk>
++}
++
++static inline void
++outb(ushort port, uchar data)
++{
++  asm volatile("out %0,%1" : : "a" (data), "d" (port));
++    7c9d:	ba f2 01 00 00       	mov    $0x1f2,%edx
++    7ca2:	b8 01 00 00 00       	mov    $0x1,%eax
++    7ca7:	ee                   	out    %al,(%dx)
++    7ca8:	b2 f3                	mov    $0xf3,%dl
++    7caa:	89 d8                	mov    %ebx,%eax
++    7cac:	ee                   	out    %al,(%dx)
++    7cad:	0f b6 c7             	movzbl %bh,%eax
++    7cb0:	b2 f4                	mov    $0xf4,%dl
++    7cb2:	ee                   	out    %al,(%dx)
++  outb(0x1F2, 1);   // count = 1
++  outb(0x1F3, offset);
++  outb(0x1F4, offset >> 8);
++  outb(0x1F5, offset >> 16);
++    7cb3:	89 d8                	mov    %ebx,%eax
++    7cb5:	c1 e8 10             	shr    $0x10,%eax
++    7cb8:	b2 f5                	mov    $0xf5,%dl
++    7cba:	ee                   	out    %al,(%dx)
++  outb(0x1F6, (offset >> 24) | 0xE0);
++    7cbb:	c1 eb 18             	shr    $0x18,%ebx
++    7cbe:	89 d8                	mov    %ebx,%eax
++    7cc0:	83 c8 e0             	or     $0xffffffe0,%eax
++    7cc3:	b2 f6                	mov    $0xf6,%dl
++    7cc5:	ee                   	out    %al,(%dx)
++    7cc6:	b2 f7                	mov    $0xf7,%dl
++    7cc8:	b8 20 00 00 00       	mov    $0x20,%eax
++    7ccd:	ee                   	out    %al,(%dx)
++  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
++
++  // Read data.
++  waitdisk();
++    7cce:	e8 ab ff ff ff       	call   7c7e <waitdisk>
++  asm volatile("cld; rep insl" :
++    7cd3:	8b 7d 08             	mov    0x8(%ebp),%edi
++    7cd6:	b9 80 00 00 00       	mov    $0x80,%ecx
++    7cdb:	ba f0 01 00 00       	mov    $0x1f0,%edx
++    7ce0:	fc                   	cld    
++    7ce1:	f3 6d                	rep insl (%dx),%es:(%edi)
++  insl(0x1F0, dst, SECTSIZE/4);
++}
++    7ce3:	5b                   	pop    %ebx
++    7ce4:	5f                   	pop    %edi
++    7ce5:	5d                   	pop    %ebp
++    7ce6:	c3                   	ret    
++
++00007ce7 <readseg>:
++
++// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
++// Might copy more than asked.
++void
++readseg(uchar* pa, uint count, uint offset)
++{
++    7ce7:	55                   	push   %ebp
++    7ce8:	89 e5                	mov    %esp,%ebp
++    7cea:	57                   	push   %edi
++    7ceb:	56                   	push   %esi
++    7cec:	53                   	push   %ebx
++    7ced:	83 ec 08             	sub    $0x8,%esp
++    7cf0:	8b 5d 08             	mov    0x8(%ebp),%ebx
++    7cf3:	8b 75 10             	mov    0x10(%ebp),%esi
++  uchar* epa;
++
++  epa = pa + count;
++    7cf6:	89 df                	mov    %ebx,%edi
++    7cf8:	03 7d 0c             	add    0xc(%ebp),%edi
++
++  // Round down to sector boundary.
++  pa -= offset % SECTSIZE;
++    7cfb:	89 f0                	mov    %esi,%eax
++    7cfd:	25 ff 01 00 00       	and    $0x1ff,%eax
++    7d02:	29 c3                	sub    %eax,%ebx
++
++  // Translate from bytes to sectors; kernel starts at sector 1.
++  offset = (offset / SECTSIZE) + 1;
++    7d04:	c1 ee 09             	shr    $0x9,%esi
++    7d07:	83 c6 01             	add    $0x1,%esi
++
++  // If this is too slow, we could read lots of sectors at a time.
++  // We'd write more to memory than asked, but it doesn't matter --
++  // we load in increasing order.
++  for(; pa < epa; pa += SECTSIZE, offset++)
++    7d0a:	39 df                	cmp    %ebx,%edi
++    7d0c:	76 19                	jbe    7d27 <readseg+0x40>
++    readsect(pa, offset);
++    7d0e:	89 74 24 04          	mov    %esi,0x4(%esp)
++    7d12:	89 1c 24             	mov    %ebx,(%esp)
++    7d15:	e8 76 ff ff ff       	call   7c90 <readsect>
++  for(; pa < epa; pa += SECTSIZE, offset++)
++    7d1a:	81 c3 00 02 00 00    	add    $0x200,%ebx
++    7d20:	83 c6 01             	add    $0x1,%esi
++    7d23:	39 df                	cmp    %ebx,%edi
++    7d25:	77 e7                	ja     7d0e <readseg+0x27>
++}
++    7d27:	83 c4 08             	add    $0x8,%esp
++    7d2a:	5b                   	pop    %ebx
++    7d2b:	5e                   	pop    %esi
++    7d2c:	5f                   	pop    %edi
++    7d2d:	5d                   	pop    %ebp
++    7d2e:	c3                   	ret    
++
++00007d2f <bootmain>:
++{
++    7d2f:	55                   	push   %ebp
++    7d30:	89 e5                	mov    %esp,%ebp
++    7d32:	57                   	push   %edi
++    7d33:	56                   	push   %esi
++    7d34:	53                   	push   %ebx
++    7d35:	83 ec 1c             	sub    $0x1c,%esp
++  readseg((uchar*)elf, 4096, 0);
++    7d38:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
++    7d3f:	00 
++    7d40:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
++    7d47:	00 
++    7d48:	c7 04 24 00 00 01 00 	movl   $0x10000,(%esp)
++    7d4f:	e8 93 ff ff ff       	call   7ce7 <readseg>
++  if(elf->magic != ELF_MAGIC)
++    7d54:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
++    7d5b:	45 4c 46 
++    7d5e:	75 57                	jne    7db7 <bootmain+0x88>
++  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
++    7d60:	a1 1c 00 01 00       	mov    0x1001c,%eax
++    7d65:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx
++  eph = ph + elf->phnum;
++    7d6b:	0f b7 35 2c 00 01 00 	movzwl 0x1002c,%esi
++    7d72:	c1 e6 05             	shl    $0x5,%esi
++    7d75:	01 de                	add    %ebx,%esi
++  for(; ph < eph; ph++){
++    7d77:	39 f3                	cmp    %esi,%ebx
++    7d79:	73 36                	jae    7db1 <bootmain+0x82>
++    pa = (uchar*)ph->paddr;
++    7d7b:	8b 7b 0c             	mov    0xc(%ebx),%edi
++    readseg(pa, ph->filesz, ph->off);
++    7d7e:	8b 43 04             	mov    0x4(%ebx),%eax
++    7d81:	89 44 24 08          	mov    %eax,0x8(%esp)
++    7d85:	8b 43 10             	mov    0x10(%ebx),%eax
++    7d88:	89 44 24 04          	mov    %eax,0x4(%esp)
++    7d8c:	89 3c 24             	mov    %edi,(%esp)
++    7d8f:	e8 53 ff ff ff       	call   7ce7 <readseg>
++    if(ph->memsz > ph->filesz)
++    7d94:	8b 4b 14             	mov    0x14(%ebx),%ecx
++    7d97:	8b 43 10             	mov    0x10(%ebx),%eax
++    7d9a:	39 c1                	cmp    %eax,%ecx
++    7d9c:	76 0c                	jbe    7daa <bootmain+0x7b>
++      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
++    7d9e:	01 c7                	add    %eax,%edi
++    7da0:	29 c1                	sub    %eax,%ecx
++}
++
++static inline void
++stosb(void *addr, int data, int cnt)
++{
++  asm volatile("cld; rep stosb" :
++    7da2:	b8 00 00 00 00       	mov    $0x0,%eax
++    7da7:	fc                   	cld    
++    7da8:	f3 aa                	rep stos %al,%es:(%edi)
++  for(; ph < eph; ph++){
++    7daa:	83 c3 20             	add    $0x20,%ebx
++    7dad:	39 de                	cmp    %ebx,%esi
++    7daf:	77 ca                	ja     7d7b <bootmain+0x4c>
++  entry();
++    7db1:	ff 15 18 00 01 00    	call   *0x10018
++}
++    7db7:	83 c4 1c             	add    $0x1c,%esp
++    7dba:	5b                   	pop    %ebx
++    7dbb:	5e                   	pop    %esi
++    7dbc:	5f                   	pop    %edi
++    7dbd:	5d                   	pop    %ebp
++    7dbe:	c3                   	ret    
+diff --git a/bootblock.o b/bootblock.o
+new file mode 100644
+index 0000000..13736fc
+Binary files /dev/null and b/bootblock.o differ
+diff --git a/bootblockother.o b/bootblockother.o
+new file mode 100644
+index 0000000..1eab171
+Binary files /dev/null and b/bootblockother.o differ
+diff --git a/bootmain.d b/bootmain.d
+new file mode 100644
+index 0000000..b32eaf5
+--- /dev/null
++++ b/bootmain.d
+@@ -0,0 +1 @@
++bootmain.o: bootmain.c types.h elf.h x86.h memlayout.h
+diff --git a/bootmain.o b/bootmain.o
+new file mode 100644
+index 0000000..0bded56
+Binary files /dev/null and b/bootmain.o differ
+diff --git a/cat.asm b/cat.asm
+new file mode 100644
+index 0000000..1a0c1f9
+--- /dev/null
++++ b/cat.asm
+@@ -0,0 +1,1301 @@
++
++_cat:     file format elf32-i386
++
++
++Disassembly of section .text:
++
++00001000 <main>:
++  }
++}
++
++int
++main(int argc, char *argv[])
++{
++    1000:	55                   	push   %ebp
++    1001:	89 e5                	mov    %esp,%ebp
++    1003:	57                   	push   %edi
++    1004:	56                   	push   %esi
++  int fd, i;
++
++  if(argc <= 1){
++    1005:	be 01 00 00 00       	mov    $0x1,%esi
++{
++    100a:	53                   	push   %ebx
++    100b:	83 e4 f0             	and    $0xfffffff0,%esp
++    100e:	83 ec 10             	sub    $0x10,%esp
++    1011:	8b 45 0c             	mov    0xc(%ebp),%eax
++  if(argc <= 1){
++    1014:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
++    1018:	8d 58 04             	lea    0x4(%eax),%ebx
++    101b:	7e 5a                	jle    1077 <main+0x77>
++    101d:	8d 76 00             	lea    0x0(%esi),%esi
++    cat(0);
++    exit();
++  }
++
++  for(i = 1; i < argc; i++){
++    if((fd = open(argv[i], 0)) < 0){
++    1020:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
++    1027:	00 
++    1028:	8b 03                	mov    (%ebx),%eax
++    102a:	89 04 24             	mov    %eax,(%esp)
++    102d:	e8 50 03 00 00       	call   1382 <open>
++    1032:	85 c0                	test   %eax,%eax
++    1034:	89 c7                	mov    %eax,%edi
++    1036:	78 20                	js     1058 <main+0x58>
++      printf(1, "cat: cannot open %s\n", argv[i]);
++      exit();
++    }
++    cat(fd);
++    1038:	89 04 24             	mov    %eax,(%esp)
++  for(i = 1; i < argc; i++){
++    103b:	83 c6 01             	add    $0x1,%esi
++    103e:	83 c3 04             	add    $0x4,%ebx
++    cat(fd);
++    1041:	e8 4a 00 00 00       	call   1090 <cat>
++    close(fd);
++    1046:	89 3c 24             	mov    %edi,(%esp)
++    1049:	e8 1c 03 00 00       	call   136a <close>
++  for(i = 1; i < argc; i++){
++    104e:	3b 75 08             	cmp    0x8(%ebp),%esi
++    1051:	75 cd                	jne    1020 <main+0x20>
++  }
++  exit();
++    1053:	e8 ea 02 00 00       	call   1342 <exit>
++      printf(1, "cat: cannot open %s\n", argv[i]);
++    1058:	8b 03                	mov    (%ebx),%eax
++    105a:	c7 44 24 04 64 18 00 	movl   $0x1864,0x4(%esp)
++    1061:	00 
++    1062:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    1069:	89 44 24 08          	mov    %eax,0x8(%esp)
++    106d:	e8 2e 04 00 00       	call   14a0 <printf>
++      exit();
++    1072:	e8 cb 02 00 00       	call   1342 <exit>
++    cat(0);
++    1077:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
++    107e:	e8 0d 00 00 00       	call   1090 <cat>
++    exit();
++    1083:	e8 ba 02 00 00       	call   1342 <exit>
++    1088:	66 90                	xchg   %ax,%ax
++    108a:	66 90                	xchg   %ax,%ax
++    108c:	66 90                	xchg   %ax,%ax
++    108e:	66 90                	xchg   %ax,%ax
++
++00001090 <cat>:
++{
++    1090:	55                   	push   %ebp
++    1091:	89 e5                	mov    %esp,%ebp
++    1093:	56                   	push   %esi
++    1094:	53                   	push   %ebx
++    1095:	83 ec 10             	sub    $0x10,%esp
++    1098:	8b 75 08             	mov    0x8(%ebp),%esi
++  while((n = read(fd, buf, sizeof(buf))) > 0) {
++    109b:	eb 1f                	jmp    10bc <cat+0x2c>
++    109d:	8d 76 00             	lea    0x0(%esi),%esi
++    if (write(1, buf, n) != n) {
++    10a0:	89 5c 24 08          	mov    %ebx,0x8(%esp)
++    10a4:	c7 44 24 04 a0 1b 00 	movl   $0x1ba0,0x4(%esp)
++    10ab:	00 
++    10ac:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    10b3:	e8 aa 02 00 00       	call   1362 <write>
++    10b8:	39 d8                	cmp    %ebx,%eax
++    10ba:	75 28                	jne    10e4 <cat+0x54>
++  while((n = read(fd, buf, sizeof(buf))) > 0) {
++    10bc:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
++    10c3:	00 
++    10c4:	c7 44 24 04 a0 1b 00 	movl   $0x1ba0,0x4(%esp)
++    10cb:	00 
++    10cc:	89 34 24             	mov    %esi,(%esp)
++    10cf:	e8 86 02 00 00       	call   135a <read>
++    10d4:	83 f8 00             	cmp    $0x0,%eax
++    10d7:	89 c3                	mov    %eax,%ebx
++    10d9:	7f c5                	jg     10a0 <cat+0x10>
++  if(n < 0){
++    10db:	75 20                	jne    10fd <cat+0x6d>
++}
++    10dd:	83 c4 10             	add    $0x10,%esp
++    10e0:	5b                   	pop    %ebx
++    10e1:	5e                   	pop    %esi
++    10e2:	5d                   	pop    %ebp
++    10e3:	c3                   	ret    
++      printf(1, "cat: write error\n");
++    10e4:	c7 44 24 04 41 18 00 	movl   $0x1841,0x4(%esp)
++    10eb:	00 
++    10ec:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    10f3:	e8 a8 03 00 00       	call   14a0 <printf>
++      exit();
++    10f8:	e8 45 02 00 00       	call   1342 <exit>
++    printf(1, "cat: read error\n");
++    10fd:	c7 44 24 04 53 18 00 	movl   $0x1853,0x4(%esp)
++    1104:	00 
++    1105:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    110c:	e8 8f 03 00 00       	call   14a0 <printf>
++    exit();
++    1111:	e8 2c 02 00 00       	call   1342 <exit>
++    1116:	66 90                	xchg   %ax,%ax
++    1118:	66 90                	xchg   %ax,%ax
++    111a:	66 90                	xchg   %ax,%ax
++    111c:	66 90                	xchg   %ax,%ax
++    111e:	66 90                	xchg   %ax,%ax
++
++00001120 <strcpy>:
++#include "user.h"
++#include "x86.h"
++
++char*
++strcpy(char *s, char *t)
++{
++    1120:	55                   	push   %ebp
++    1121:	89 e5                	mov    %esp,%ebp
++    1123:	8b 45 08             	mov    0x8(%ebp),%eax
++    1126:	8b 4d 0c             	mov    0xc(%ebp),%ecx
++    1129:	53                   	push   %ebx
++  char *os;
++
++  os = s;
++  while((*s++ = *t++) != 0)
++    112a:	89 c2                	mov    %eax,%edx
++    112c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    1130:	83 c1 01             	add    $0x1,%ecx
++    1133:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
++    1137:	83 c2 01             	add    $0x1,%edx
++    113a:	84 db                	test   %bl,%bl
++    113c:	88 5a ff             	mov    %bl,-0x1(%edx)
++    113f:	75 ef                	jne    1130 <strcpy+0x10>
++    ;
++  return os;
++}
++    1141:	5b                   	pop    %ebx
++    1142:	5d                   	pop    %ebp
++    1143:	c3                   	ret    
++    1144:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    114a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
++
++00001150 <strcmp>:
++
++int
++strcmp(const char *p, const char *q)
++{
++    1150:	55                   	push   %ebp
++    1151:	89 e5                	mov    %esp,%ebp
++    1153:	8b 55 08             	mov    0x8(%ebp),%edx
++    1156:	53                   	push   %ebx
++    1157:	8b 4d 0c             	mov    0xc(%ebp),%ecx
++  while(*p && *p == *q)
++    115a:	0f b6 02             	movzbl (%edx),%eax
++    115d:	84 c0                	test   %al,%al
++    115f:	74 2d                	je     118e <strcmp+0x3e>
++    1161:	0f b6 19             	movzbl (%ecx),%ebx
++    1164:	38 d8                	cmp    %bl,%al
++    1166:	74 0e                	je     1176 <strcmp+0x26>
++    1168:	eb 2b                	jmp    1195 <strcmp+0x45>
++    116a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    1170:	38 c8                	cmp    %cl,%al
++    1172:	75 15                	jne    1189 <strcmp+0x39>
++    p++, q++;
++    1174:	89 d9                	mov    %ebx,%ecx
++    1176:	83 c2 01             	add    $0x1,%edx
++  while(*p && *p == *q)
++    1179:	0f b6 02             	movzbl (%edx),%eax
++    p++, q++;
++    117c:	8d 59 01             	lea    0x1(%ecx),%ebx
++  while(*p && *p == *q)
++    117f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
++    1183:	84 c0                	test   %al,%al
++    1185:	75 e9                	jne    1170 <strcmp+0x20>
++    1187:	31 c0                	xor    %eax,%eax
++  return (uchar)*p - (uchar)*q;
++    1189:	29 c8                	sub    %ecx,%eax
++}
++    118b:	5b                   	pop    %ebx
++    118c:	5d                   	pop    %ebp
++    118d:	c3                   	ret    
++    118e:	0f b6 09             	movzbl (%ecx),%ecx
++  while(*p && *p == *q)
++    1191:	31 c0                	xor    %eax,%eax
++    1193:	eb f4                	jmp    1189 <strcmp+0x39>
++    1195:	0f b6 cb             	movzbl %bl,%ecx
++    1198:	eb ef                	jmp    1189 <strcmp+0x39>
++    119a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++
++000011a0 <strlen>:
++
++uint
++strlen(char *s)
++{
++    11a0:	55                   	push   %ebp
++    11a1:	89 e5                	mov    %esp,%ebp
++    11a3:	8b 4d 08             	mov    0x8(%ebp),%ecx
++  int n;
++
++  for(n = 0; s[n]; n++)
++    11a6:	80 39 00             	cmpb   $0x0,(%ecx)
++    11a9:	74 12                	je     11bd <strlen+0x1d>
++    11ab:	31 d2                	xor    %edx,%edx
++    11ad:	8d 76 00             	lea    0x0(%esi),%esi
++    11b0:	83 c2 01             	add    $0x1,%edx
++    11b3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
++    11b7:	89 d0                	mov    %edx,%eax
++    11b9:	75 f5                	jne    11b0 <strlen+0x10>
++    ;
++  return n;
++}
++    11bb:	5d                   	pop    %ebp
++    11bc:	c3                   	ret    
++  for(n = 0; s[n]; n++)
++    11bd:	31 c0                	xor    %eax,%eax
++}
++    11bf:	5d                   	pop    %ebp
++    11c0:	c3                   	ret    
++    11c1:	eb 0d                	jmp    11d0 <memset>
++    11c3:	90                   	nop
++    11c4:	90                   	nop
++    11c5:	90                   	nop
++    11c6:	90                   	nop
++    11c7:	90                   	nop
++    11c8:	90                   	nop
++    11c9:	90                   	nop
++    11ca:	90                   	nop
++    11cb:	90                   	nop
++    11cc:	90                   	nop
++    11cd:	90                   	nop
++    11ce:	90                   	nop
++    11cf:	90                   	nop
++
++000011d0 <memset>:
++
++void*
++memset(void *dst, int c, uint n)
++{
++    11d0:	55                   	push   %ebp
++    11d1:	89 e5                	mov    %esp,%ebp
++    11d3:	8b 55 08             	mov    0x8(%ebp),%edx
++    11d6:	57                   	push   %edi
++}
++
++static inline void
++stosb(void *addr, int data, int cnt)
++{
++  asm volatile("cld; rep stosb" :
++    11d7:	8b 4d 10             	mov    0x10(%ebp),%ecx
++    11da:	8b 45 0c             	mov    0xc(%ebp),%eax
++    11dd:	89 d7                	mov    %edx,%edi
++    11df:	fc                   	cld    
++    11e0:	f3 aa                	rep stos %al,%es:(%edi)
++  stosb(dst, c, n);
++  return dst;
++}
++    11e2:	89 d0                	mov    %edx,%eax
++    11e4:	5f                   	pop    %edi
++    11e5:	5d                   	pop    %ebp
++    11e6:	c3                   	ret    
++    11e7:	89 f6                	mov    %esi,%esi
++    11e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++000011f0 <strchr>:
++
++char*
++strchr(const char *s, char c)
++{
++    11f0:	55                   	push   %ebp
++    11f1:	89 e5                	mov    %esp,%ebp
++    11f3:	8b 45 08             	mov    0x8(%ebp),%eax
++    11f6:	53                   	push   %ebx
++    11f7:	8b 55 0c             	mov    0xc(%ebp),%edx
++  for(; *s; s++)
++    11fa:	0f b6 18             	movzbl (%eax),%ebx
++    11fd:	84 db                	test   %bl,%bl
++    11ff:	74 1d                	je     121e <strchr+0x2e>
++    if(*s == c)
++    1201:	38 d3                	cmp    %dl,%bl
++    1203:	89 d1                	mov    %edx,%ecx
++    1205:	75 0d                	jne    1214 <strchr+0x24>
++    1207:	eb 17                	jmp    1220 <strchr+0x30>
++    1209:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++    1210:	38 ca                	cmp    %cl,%dl
++    1212:	74 0c                	je     1220 <strchr+0x30>
++  for(; *s; s++)
++    1214:	83 c0 01             	add    $0x1,%eax
++    1217:	0f b6 10             	movzbl (%eax),%edx
++    121a:	84 d2                	test   %dl,%dl
++    121c:	75 f2                	jne    1210 <strchr+0x20>
++      return (char*)s;
++  return 0;
++    121e:	31 c0                	xor    %eax,%eax
++}
++    1220:	5b                   	pop    %ebx
++    1221:	5d                   	pop    %ebp
++    1222:	c3                   	ret    
++    1223:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    1229:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++00001230 <gets>:
++
++char*
++gets(char *buf, int max)
++{
++    1230:	55                   	push   %ebp
++    1231:	89 e5                	mov    %esp,%ebp
++    1233:	57                   	push   %edi
++    1234:	56                   	push   %esi
++  int i, cc;
++  char c;
++
++  for(i=0; i+1 < max; ){
++    1235:	31 f6                	xor    %esi,%esi
++{
++    1237:	53                   	push   %ebx
++    1238:	83 ec 2c             	sub    $0x2c,%esp
++    cc = read(0, &c, 1);
++    123b:	8d 7d e7             	lea    -0x19(%ebp),%edi
++  for(i=0; i+1 < max; ){
++    123e:	eb 31                	jmp    1271 <gets+0x41>
++    cc = read(0, &c, 1);
++    1240:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1247:	00 
++    1248:	89 7c 24 04          	mov    %edi,0x4(%esp)
++    124c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
++    1253:	e8 02 01 00 00       	call   135a <read>
++    if(cc < 1)
++    1258:	85 c0                	test   %eax,%eax
++    125a:	7e 1d                	jle    1279 <gets+0x49>
++      break;
++    buf[i++] = c;
++    125c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
++  for(i=0; i+1 < max; ){
++    1260:	89 de                	mov    %ebx,%esi
++    buf[i++] = c;
++    1262:	8b 55 08             	mov    0x8(%ebp),%edx
++    if(c == '\n' || c == '\r')
++    1265:	3c 0d                	cmp    $0xd,%al
++    buf[i++] = c;
++    1267:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
++    if(c == '\n' || c == '\r')
++    126b:	74 0c                	je     1279 <gets+0x49>
++    126d:	3c 0a                	cmp    $0xa,%al
++    126f:	74 08                	je     1279 <gets+0x49>
++  for(i=0; i+1 < max; ){
++    1271:	8d 5e 01             	lea    0x1(%esi),%ebx
++    1274:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
++    1277:	7c c7                	jl     1240 <gets+0x10>
++      break;
++  }
++  buf[i] = '\0';
++    1279:	8b 45 08             	mov    0x8(%ebp),%eax
++    127c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
++  return buf;
++}
++    1280:	83 c4 2c             	add    $0x2c,%esp
++    1283:	5b                   	pop    %ebx
++    1284:	5e                   	pop    %esi
++    1285:	5f                   	pop    %edi
++    1286:	5d                   	pop    %ebp
++    1287:	c3                   	ret    
++    1288:	90                   	nop
++    1289:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++
++00001290 <stat>:
++
++int
++stat(char *n, struct stat *st)
++{
++    1290:	55                   	push   %ebp
++    1291:	89 e5                	mov    %esp,%ebp
++    1293:	56                   	push   %esi
++    1294:	53                   	push   %ebx
++    1295:	83 ec 10             	sub    $0x10,%esp
++  int fd;
++  int r;
++
++  fd = open(n, O_RDONLY);
++    1298:	8b 45 08             	mov    0x8(%ebp),%eax
++    129b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
++    12a2:	00 
++    12a3:	89 04 24             	mov    %eax,(%esp)
++    12a6:	e8 d7 00 00 00       	call   1382 <open>
++  if(fd < 0)
++    12ab:	85 c0                	test   %eax,%eax
++  fd = open(n, O_RDONLY);
++    12ad:	89 c3                	mov    %eax,%ebx
++  if(fd < 0)
++    12af:	78 27                	js     12d8 <stat+0x48>
++    return -1;
++  r = fstat(fd, st);
++    12b1:	8b 45 0c             	mov    0xc(%ebp),%eax
++    12b4:	89 1c 24             	mov    %ebx,(%esp)
++    12b7:	89 44 24 04          	mov    %eax,0x4(%esp)
++    12bb:	e8 da 00 00 00       	call   139a <fstat>
++  close(fd);
++    12c0:	89 1c 24             	mov    %ebx,(%esp)
++  r = fstat(fd, st);
++    12c3:	89 c6                	mov    %eax,%esi
++  close(fd);
++    12c5:	e8 a0 00 00 00       	call   136a <close>
++  return r;
++    12ca:	89 f0                	mov    %esi,%eax
++}
++    12cc:	83 c4 10             	add    $0x10,%esp
++    12cf:	5b                   	pop    %ebx
++    12d0:	5e                   	pop    %esi
++    12d1:	5d                   	pop    %ebp
++    12d2:	c3                   	ret    
++    12d3:	90                   	nop
++    12d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    return -1;
++    12d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++    12dd:	eb ed                	jmp    12cc <stat+0x3c>
++    12df:	90                   	nop
++
++000012e0 <atoi>:
++
++int
++atoi(const char *s)
++{
++    12e0:	55                   	push   %ebp
++    12e1:	89 e5                	mov    %esp,%ebp
++    12e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
++    12e6:	53                   	push   %ebx
++  int n;
++
++  n = 0;
++  while('0' <= *s && *s <= '9')
++    12e7:	0f be 11             	movsbl (%ecx),%edx
++    12ea:	8d 42 d0             	lea    -0x30(%edx),%eax
++    12ed:	3c 09                	cmp    $0x9,%al
++  n = 0;
++    12ef:	b8 00 00 00 00       	mov    $0x0,%eax
++  while('0' <= *s && *s <= '9')
++    12f4:	77 17                	ja     130d <atoi+0x2d>
++    12f6:	66 90                	xchg   %ax,%ax
++    n = n*10 + *s++ - '0';
++    12f8:	83 c1 01             	add    $0x1,%ecx
++    12fb:	8d 04 80             	lea    (%eax,%eax,4),%eax
++    12fe:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
++  while('0' <= *s && *s <= '9')
++    1302:	0f be 11             	movsbl (%ecx),%edx
++    1305:	8d 5a d0             	lea    -0x30(%edx),%ebx
++    1308:	80 fb 09             	cmp    $0x9,%bl
++    130b:	76 eb                	jbe    12f8 <atoi+0x18>
++  return n;
++}
++    130d:	5b                   	pop    %ebx
++    130e:	5d                   	pop    %ebp
++    130f:	c3                   	ret    
++
++00001310 <memmove>:
++
++void*
++memmove(void *vdst, void *vsrc, int n)
++{
++    1310:	55                   	push   %ebp
++  char *dst, *src;
++
++  dst = vdst;
++  src = vsrc;
++  while(n-- > 0)
++    1311:	31 d2                	xor    %edx,%edx
++{
++    1313:	89 e5                	mov    %esp,%ebp
++    1315:	56                   	push   %esi
++    1316:	8b 45 08             	mov    0x8(%ebp),%eax
++    1319:	53                   	push   %ebx
++    131a:	8b 5d 10             	mov    0x10(%ebp),%ebx
++    131d:	8b 75 0c             	mov    0xc(%ebp),%esi
++  while(n-- > 0)
++    1320:	85 db                	test   %ebx,%ebx
++    1322:	7e 12                	jle    1336 <memmove+0x26>
++    1324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    *dst++ = *src++;
++    1328:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
++    132c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
++    132f:	83 c2 01             	add    $0x1,%edx
++  while(n-- > 0)
++    1332:	39 da                	cmp    %ebx,%edx
++    1334:	75 f2                	jne    1328 <memmove+0x18>
++  return vdst;
++}
++    1336:	5b                   	pop    %ebx
++    1337:	5e                   	pop    %esi
++    1338:	5d                   	pop    %ebp
++    1339:	c3                   	ret    
++
++0000133a <fork>:
++  name: \
++    movl $SYS_ ## name, %eax; \
++    int $T_SYSCALL; \
++    ret
++
++SYSCALL(fork)
++    133a:	b8 01 00 00 00       	mov    $0x1,%eax
++    133f:	cd 40                	int    $0x40
++    1341:	c3                   	ret    
++
++00001342 <exit>:
++SYSCALL(exit)
++    1342:	b8 02 00 00 00       	mov    $0x2,%eax
++    1347:	cd 40                	int    $0x40
++    1349:	c3                   	ret    
++
++0000134a <wait>:
++SYSCALL(wait)
++    134a:	b8 03 00 00 00       	mov    $0x3,%eax
++    134f:	cd 40                	int    $0x40
++    1351:	c3                   	ret    
++
++00001352 <pipe>:
++SYSCALL(pipe)
++    1352:	b8 04 00 00 00       	mov    $0x4,%eax
++    1357:	cd 40                	int    $0x40
++    1359:	c3                   	ret    
++
++0000135a <read>:
++SYSCALL(read)
++    135a:	b8 05 00 00 00       	mov    $0x5,%eax
++    135f:	cd 40                	int    $0x40
++    1361:	c3                   	ret    
++
++00001362 <write>:
++SYSCALL(write)
++    1362:	b8 10 00 00 00       	mov    $0x10,%eax
++    1367:	cd 40                	int    $0x40
++    1369:	c3                   	ret    
++
++0000136a <close>:
++SYSCALL(close)
++    136a:	b8 15 00 00 00       	mov    $0x15,%eax
++    136f:	cd 40                	int    $0x40
++    1371:	c3                   	ret    
++
++00001372 <kill>:
++SYSCALL(kill)
++    1372:	b8 06 00 00 00       	mov    $0x6,%eax
++    1377:	cd 40                	int    $0x40
++    1379:	c3                   	ret    
++
++0000137a <exec>:
++SYSCALL(exec)
++    137a:	b8 07 00 00 00       	mov    $0x7,%eax
++    137f:	cd 40                	int    $0x40
++    1381:	c3                   	ret    
++
++00001382 <open>:
++SYSCALL(open)
++    1382:	b8 0f 00 00 00       	mov    $0xf,%eax
++    1387:	cd 40                	int    $0x40
++    1389:	c3                   	ret    
++
++0000138a <mknod>:
++SYSCALL(mknod)
++    138a:	b8 11 00 00 00       	mov    $0x11,%eax
++    138f:	cd 40                	int    $0x40
++    1391:	c3                   	ret    
++
++00001392 <unlink>:
++SYSCALL(unlink)
++    1392:	b8 12 00 00 00       	mov    $0x12,%eax
++    1397:	cd 40                	int    $0x40
++    1399:	c3                   	ret    
++
++0000139a <fstat>:
++SYSCALL(fstat)
++    139a:	b8 08 00 00 00       	mov    $0x8,%eax
++    139f:	cd 40                	int    $0x40
++    13a1:	c3                   	ret    
++
++000013a2 <link>:
++SYSCALL(link)
++    13a2:	b8 13 00 00 00       	mov    $0x13,%eax
++    13a7:	cd 40                	int    $0x40
++    13a9:	c3                   	ret    
++
++000013aa <mkdir>:
++SYSCALL(mkdir)
++    13aa:	b8 14 00 00 00       	mov    $0x14,%eax
++    13af:	cd 40                	int    $0x40
++    13b1:	c3                   	ret    
++
++000013b2 <chdir>:
++SYSCALL(chdir)
++    13b2:	b8 09 00 00 00       	mov    $0x9,%eax
++    13b7:	cd 40                	int    $0x40
++    13b9:	c3                   	ret    
++
++000013ba <dup>:
++SYSCALL(dup)
++    13ba:	b8 0a 00 00 00       	mov    $0xa,%eax
++    13bf:	cd 40                	int    $0x40
++    13c1:	c3                   	ret    
++
++000013c2 <getpid>:
++SYSCALL(getpid)
++    13c2:	b8 0b 00 00 00       	mov    $0xb,%eax
++    13c7:	cd 40                	int    $0x40
++    13c9:	c3                   	ret    
++
++000013ca <sbrk>:
++SYSCALL(sbrk)
++    13ca:	b8 0c 00 00 00       	mov    $0xc,%eax
++    13cf:	cd 40                	int    $0x40
++    13d1:	c3                   	ret    
++
++000013d2 <sleep>:
++SYSCALL(sleep)
++    13d2:	b8 0d 00 00 00       	mov    $0xd,%eax
++    13d7:	cd 40                	int    $0x40
++    13d9:	c3                   	ret    
++
++000013da <uptime>:
++SYSCALL(uptime)
++    13da:	b8 0e 00 00 00       	mov    $0xe,%eax
++    13df:	cd 40                	int    $0x40
++    13e1:	c3                   	ret    
++
++000013e2 <shm_open>:
++SYSCALL(shm_open)
++    13e2:	b8 16 00 00 00       	mov    $0x16,%eax
++    13e7:	cd 40                	int    $0x40
++    13e9:	c3                   	ret    
++
++000013ea <shm_close>:
++SYSCALL(shm_close)	
++    13ea:	b8 17 00 00 00       	mov    $0x17,%eax
++    13ef:	cd 40                	int    $0x40
++    13f1:	c3                   	ret    
++    13f2:	66 90                	xchg   %ax,%ax
++    13f4:	66 90                	xchg   %ax,%ax
++    13f6:	66 90                	xchg   %ax,%ax
++    13f8:	66 90                	xchg   %ax,%ax
++    13fa:	66 90                	xchg   %ax,%ax
++    13fc:	66 90                	xchg   %ax,%ax
++    13fe:	66 90                	xchg   %ax,%ax
++
++00001400 <printint>:
++  write(fd, &c, 1);
++}
++
++static void
++printint(int fd, int xx, int base, int sgn)
++{
++    1400:	55                   	push   %ebp
++    1401:	89 e5                	mov    %esp,%ebp
++    1403:	57                   	push   %edi
++    1404:	56                   	push   %esi
++    1405:	89 c6                	mov    %eax,%esi
++    1407:	53                   	push   %ebx
++    1408:	83 ec 4c             	sub    $0x4c,%esp
++  char buf[16];
++  int i, neg;
++  uint x;
++
++  neg = 0;
++  if(sgn && xx < 0){
++    140b:	8b 5d 08             	mov    0x8(%ebp),%ebx
++    140e:	85 db                	test   %ebx,%ebx
++    1410:	74 09                	je     141b <printint+0x1b>
++    1412:	89 d0                	mov    %edx,%eax
++    1414:	c1 e8 1f             	shr    $0x1f,%eax
++    1417:	84 c0                	test   %al,%al
++    1419:	75 75                	jne    1490 <printint+0x90>
++    neg = 1;
++    x = -xx;
++  } else {
++    x = xx;
++    141b:	89 d0                	mov    %edx,%eax
++  neg = 0;
++    141d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
++    1424:	89 75 c0             	mov    %esi,-0x40(%ebp)
++  }
++
++  i = 0;
++    1427:	31 ff                	xor    %edi,%edi
++    1429:	89 ce                	mov    %ecx,%esi
++    142b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
++    142e:	eb 02                	jmp    1432 <printint+0x32>
++  do{
++    buf[i++] = digits[x % base];
++    1430:	89 cf                	mov    %ecx,%edi
++    1432:	31 d2                	xor    %edx,%edx
++    1434:	f7 f6                	div    %esi
++    1436:	8d 4f 01             	lea    0x1(%edi),%ecx
++    1439:	0f b6 92 80 18 00 00 	movzbl 0x1880(%edx),%edx
++  }while((x /= base) != 0);
++    1440:	85 c0                	test   %eax,%eax
++    buf[i++] = digits[x % base];
++    1442:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
++  }while((x /= base) != 0);
++    1445:	75 e9                	jne    1430 <printint+0x30>
++  if(neg)
++    1447:	8b 55 c4             	mov    -0x3c(%ebp),%edx
++    buf[i++] = digits[x % base];
++    144a:	89 c8                	mov    %ecx,%eax
++    144c:	8b 75 c0             	mov    -0x40(%ebp),%esi
++  if(neg)
++    144f:	85 d2                	test   %edx,%edx
++    1451:	74 08                	je     145b <printint+0x5b>
++    buf[i++] = '-';
++    1453:	8d 4f 02             	lea    0x2(%edi),%ecx
++    1456:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
++
++  while(--i >= 0)
++    145b:	8d 79 ff             	lea    -0x1(%ecx),%edi
++    145e:	66 90                	xchg   %ax,%ax
++    1460:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
++    1465:	83 ef 01             	sub    $0x1,%edi
++  write(fd, &c, 1);
++    1468:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    146f:	00 
++    1470:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++    1474:	89 34 24             	mov    %esi,(%esp)
++    1477:	88 45 d7             	mov    %al,-0x29(%ebp)
++    147a:	e8 e3 fe ff ff       	call   1362 <write>
++  while(--i >= 0)
++    147f:	83 ff ff             	cmp    $0xffffffff,%edi
++    1482:	75 dc                	jne    1460 <printint+0x60>
++    putc(fd, buf[i]);
++}
++    1484:	83 c4 4c             	add    $0x4c,%esp
++    1487:	5b                   	pop    %ebx
++    1488:	5e                   	pop    %esi
++    1489:	5f                   	pop    %edi
++    148a:	5d                   	pop    %ebp
++    148b:	c3                   	ret    
++    148c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    x = -xx;
++    1490:	89 d0                	mov    %edx,%eax
++    1492:	f7 d8                	neg    %eax
++    neg = 1;
++    1494:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
++    149b:	eb 87                	jmp    1424 <printint+0x24>
++    149d:	8d 76 00             	lea    0x0(%esi),%esi
++
++000014a0 <printf>:
++
++// Print to the given fd. Only understands %d, %x, %p, %s.
++void
++printf(int fd, char *fmt, ...)
++{
++    14a0:	55                   	push   %ebp
++    14a1:	89 e5                	mov    %esp,%ebp
++    14a3:	57                   	push   %edi
++  char *s;
++  int c, i, state;
++  uint *ap;
++
++  state = 0;
++    14a4:	31 ff                	xor    %edi,%edi
++{
++    14a6:	56                   	push   %esi
++    14a7:	53                   	push   %ebx
++    14a8:	83 ec 3c             	sub    $0x3c,%esp
++  ap = (uint*)(void*)&fmt + 1;
++  for(i = 0; fmt[i]; i++){
++    14ab:	8b 5d 0c             	mov    0xc(%ebp),%ebx
++  ap = (uint*)(void*)&fmt + 1;
++    14ae:	8d 45 10             	lea    0x10(%ebp),%eax
++{
++    14b1:	8b 75 08             	mov    0x8(%ebp),%esi
++  ap = (uint*)(void*)&fmt + 1;
++    14b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
++  for(i = 0; fmt[i]; i++){
++    14b7:	0f b6 13             	movzbl (%ebx),%edx
++    14ba:	83 c3 01             	add    $0x1,%ebx
++    14bd:	84 d2                	test   %dl,%dl
++    14bf:	75 39                	jne    14fa <printf+0x5a>
++    14c1:	e9 c2 00 00 00       	jmp    1588 <printf+0xe8>
++    14c6:	66 90                	xchg   %ax,%ax
++    c = fmt[i] & 0xff;
++    if(state == 0){
++      if(c == '%'){
++    14c8:	83 fa 25             	cmp    $0x25,%edx
++    14cb:	0f 84 bf 00 00 00    	je     1590 <printf+0xf0>
++  write(fd, &c, 1);
++    14d1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
++    14d4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    14db:	00 
++    14dc:	89 44 24 04          	mov    %eax,0x4(%esp)
++    14e0:	89 34 24             	mov    %esi,(%esp)
++        state = '%';
++      } else {
++        putc(fd, c);
++    14e3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
++  write(fd, &c, 1);
++    14e6:	e8 77 fe ff ff       	call   1362 <write>
++    14eb:	83 c3 01             	add    $0x1,%ebx
++  for(i = 0; fmt[i]; i++){
++    14ee:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
++    14f2:	84 d2                	test   %dl,%dl
++    14f4:	0f 84 8e 00 00 00    	je     1588 <printf+0xe8>
++    if(state == 0){
++    14fa:	85 ff                	test   %edi,%edi
++    c = fmt[i] & 0xff;
++    14fc:	0f be c2             	movsbl %dl,%eax
++    if(state == 0){
++    14ff:	74 c7                	je     14c8 <printf+0x28>
++      }
++    } else if(state == '%'){
++    1501:	83 ff 25             	cmp    $0x25,%edi
++    1504:	75 e5                	jne    14eb <printf+0x4b>
++      if(c == 'd'){
++    1506:	83 fa 64             	cmp    $0x64,%edx
++    1509:	0f 84 31 01 00 00    	je     1640 <printf+0x1a0>
++        printint(fd, *ap, 10, 1);
++        ap++;
++      } else if(c == 'x' || c == 'p'){
++    150f:	25 f7 00 00 00       	and    $0xf7,%eax
++    1514:	83 f8 70             	cmp    $0x70,%eax
++    1517:	0f 84 83 00 00 00    	je     15a0 <printf+0x100>
++        printint(fd, *ap, 16, 0);
++        ap++;
++      } else if(c == 's'){
++    151d:	83 fa 73             	cmp    $0x73,%edx
++    1520:	0f 84 a2 00 00 00    	je     15c8 <printf+0x128>
++          s = "(null)";
++        while(*s != 0){
++          putc(fd, *s);
++          s++;
++        }
++      } else if(c == 'c'){
++    1526:	83 fa 63             	cmp    $0x63,%edx
++    1529:	0f 84 35 01 00 00    	je     1664 <printf+0x1c4>
++        putc(fd, *ap);
++        ap++;
++      } else if(c == '%'){
++    152f:	83 fa 25             	cmp    $0x25,%edx
++    1532:	0f 84 e0 00 00 00    	je     1618 <printf+0x178>
++  write(fd, &c, 1);
++    1538:	8d 45 e6             	lea    -0x1a(%ebp),%eax
++    153b:	83 c3 01             	add    $0x1,%ebx
++    153e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1545:	00 
++      } else {
++        // Unknown % sequence.  Print it to draw attention.
++        putc(fd, '%');
++        putc(fd, c);
++      }
++      state = 0;
++    1546:	31 ff                	xor    %edi,%edi
++  write(fd, &c, 1);
++    1548:	89 44 24 04          	mov    %eax,0x4(%esp)
++    154c:	89 34 24             	mov    %esi,(%esp)
++    154f:	89 55 d0             	mov    %edx,-0x30(%ebp)
++    1552:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
++    1556:	e8 07 fe ff ff       	call   1362 <write>
++        putc(fd, c);
++    155b:	8b 55 d0             	mov    -0x30(%ebp),%edx
++  write(fd, &c, 1);
++    155e:	8d 45 e7             	lea    -0x19(%ebp),%eax
++    1561:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1568:	00 
++    1569:	89 44 24 04          	mov    %eax,0x4(%esp)
++    156d:	89 34 24             	mov    %esi,(%esp)
++        putc(fd, c);
++    1570:	88 55 e7             	mov    %dl,-0x19(%ebp)
++  write(fd, &c, 1);
++    1573:	e8 ea fd ff ff       	call   1362 <write>
++  for(i = 0; fmt[i]; i++){
++    1578:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
++    157c:	84 d2                	test   %dl,%dl
++    157e:	0f 85 76 ff ff ff    	jne    14fa <printf+0x5a>
++    1584:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    }
++  }
++}
++    1588:	83 c4 3c             	add    $0x3c,%esp
++    158b:	5b                   	pop    %ebx
++    158c:	5e                   	pop    %esi
++    158d:	5f                   	pop    %edi
++    158e:	5d                   	pop    %ebp
++    158f:	c3                   	ret    
++        state = '%';
++    1590:	bf 25 00 00 00       	mov    $0x25,%edi
++    1595:	e9 51 ff ff ff       	jmp    14eb <printf+0x4b>
++    159a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++        printint(fd, *ap, 16, 0);
++    15a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++    15a3:	b9 10 00 00 00       	mov    $0x10,%ecx
++      state = 0;
++    15a8:	31 ff                	xor    %edi,%edi
++        printint(fd, *ap, 16, 0);
++    15aa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
++    15b1:	8b 10                	mov    (%eax),%edx
++    15b3:	89 f0                	mov    %esi,%eax
++    15b5:	e8 46 fe ff ff       	call   1400 <printint>
++        ap++;
++    15ba:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++    15be:	e9 28 ff ff ff       	jmp    14eb <printf+0x4b>
++    15c3:	90                   	nop
++    15c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++        s = (char*)*ap;
++    15c8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++        ap++;
++    15cb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++        s = (char*)*ap;
++    15cf:	8b 38                	mov    (%eax),%edi
++          s = "(null)";
++    15d1:	b8 79 18 00 00       	mov    $0x1879,%eax
++    15d6:	85 ff                	test   %edi,%edi
++    15d8:	0f 44 f8             	cmove  %eax,%edi
++        while(*s != 0){
++    15db:	0f b6 07             	movzbl (%edi),%eax
++    15de:	84 c0                	test   %al,%al
++    15e0:	74 2a                	je     160c <printf+0x16c>
++    15e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    15e8:	88 45 e3             	mov    %al,-0x1d(%ebp)
++  write(fd, &c, 1);
++    15eb:	8d 45 e3             	lea    -0x1d(%ebp),%eax
++          s++;
++    15ee:	83 c7 01             	add    $0x1,%edi
++  write(fd, &c, 1);
++    15f1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    15f8:	00 
++    15f9:	89 44 24 04          	mov    %eax,0x4(%esp)
++    15fd:	89 34 24             	mov    %esi,(%esp)
++    1600:	e8 5d fd ff ff       	call   1362 <write>
++        while(*s != 0){
++    1605:	0f b6 07             	movzbl (%edi),%eax
++    1608:	84 c0                	test   %al,%al
++    160a:	75 dc                	jne    15e8 <printf+0x148>
++      state = 0;
++    160c:	31 ff                	xor    %edi,%edi
++    160e:	e9 d8 fe ff ff       	jmp    14eb <printf+0x4b>
++    1613:	90                   	nop
++    1614:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++  write(fd, &c, 1);
++    1618:	8d 45 e5             	lea    -0x1b(%ebp),%eax
++      state = 0;
++    161b:	31 ff                	xor    %edi,%edi
++  write(fd, &c, 1);
++    161d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1624:	00 
++    1625:	89 44 24 04          	mov    %eax,0x4(%esp)
++    1629:	89 34 24             	mov    %esi,(%esp)
++    162c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
++    1630:	e8 2d fd ff ff       	call   1362 <write>
++    1635:	e9 b1 fe ff ff       	jmp    14eb <printf+0x4b>
++    163a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++        printint(fd, *ap, 10, 1);
++    1640:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++    1643:	b9 0a 00 00 00       	mov    $0xa,%ecx
++      state = 0;
++    1648:	66 31 ff             	xor    %di,%di
++        printint(fd, *ap, 10, 1);
++    164b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    1652:	8b 10                	mov    (%eax),%edx
++    1654:	89 f0                	mov    %esi,%eax
++    1656:	e8 a5 fd ff ff       	call   1400 <printint>
++        ap++;
++    165b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++    165f:	e9 87 fe ff ff       	jmp    14eb <printf+0x4b>
++        putc(fd, *ap);
++    1664:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++      state = 0;
++    1667:	31 ff                	xor    %edi,%edi
++        putc(fd, *ap);
++    1669:	8b 00                	mov    (%eax),%eax
++  write(fd, &c, 1);
++    166b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1672:	00 
++    1673:	89 34 24             	mov    %esi,(%esp)
++        putc(fd, *ap);
++    1676:	88 45 e4             	mov    %al,-0x1c(%ebp)
++  write(fd, &c, 1);
++    1679:	8d 45 e4             	lea    -0x1c(%ebp),%eax
++    167c:	89 44 24 04          	mov    %eax,0x4(%esp)
++    1680:	e8 dd fc ff ff       	call   1362 <write>
++        ap++;
++    1685:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++    1689:	e9 5d fe ff ff       	jmp    14eb <printf+0x4b>
++    168e:	66 90                	xchg   %ax,%ax
++
++00001690 <free>:
++static Header base;
++static Header *freep;
++
++void
++free(void *ap)
++{
++    1690:	55                   	push   %ebp
++  Header *bp, *p;
++
++  bp = (Header*)ap - 1;
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    1691:	a1 80 1b 00 00       	mov    0x1b80,%eax
++{
++    1696:	89 e5                	mov    %esp,%ebp
++    1698:	57                   	push   %edi
++    1699:	56                   	push   %esi
++    169a:	53                   	push   %ebx
++    169b:	8b 5d 08             	mov    0x8(%ebp),%ebx
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    169e:	8b 08                	mov    (%eax),%ecx
++  bp = (Header*)ap - 1;
++    16a0:	8d 53 f8             	lea    -0x8(%ebx),%edx
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    16a3:	39 d0                	cmp    %edx,%eax
++    16a5:	72 11                	jb     16b8 <free+0x28>
++    16a7:	90                   	nop
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    16a8:	39 c8                	cmp    %ecx,%eax
++    16aa:	72 04                	jb     16b0 <free+0x20>
++    16ac:	39 ca                	cmp    %ecx,%edx
++    16ae:	72 10                	jb     16c0 <free+0x30>
++    16b0:	89 c8                	mov    %ecx,%eax
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    16b2:	39 d0                	cmp    %edx,%eax
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    16b4:	8b 08                	mov    (%eax),%ecx
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    16b6:	73 f0                	jae    16a8 <free+0x18>
++    16b8:	39 ca                	cmp    %ecx,%edx
++    16ba:	72 04                	jb     16c0 <free+0x30>
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    16bc:	39 c8                	cmp    %ecx,%eax
++    16be:	72 f0                	jb     16b0 <free+0x20>
++      break;
++  if(bp + bp->s.size == p->s.ptr){
++    16c0:	8b 73 fc             	mov    -0x4(%ebx),%esi
++    16c3:	8d 3c f2             	lea    (%edx,%esi,8),%edi
++    16c6:	39 cf                	cmp    %ecx,%edi
++    16c8:	74 1e                	je     16e8 <free+0x58>
++    bp->s.size += p->s.ptr->s.size;
++    bp->s.ptr = p->s.ptr->s.ptr;
++  } else
++    bp->s.ptr = p->s.ptr;
++    16ca:	89 4b f8             	mov    %ecx,-0x8(%ebx)
++  if(p + p->s.size == bp){
++    16cd:	8b 48 04             	mov    0x4(%eax),%ecx
++    16d0:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
++    16d3:	39 f2                	cmp    %esi,%edx
++    16d5:	74 28                	je     16ff <free+0x6f>
++    p->s.size += bp->s.size;
++    p->s.ptr = bp->s.ptr;
++  } else
++    p->s.ptr = bp;
++    16d7:	89 10                	mov    %edx,(%eax)
++  freep = p;
++    16d9:	a3 80 1b 00 00       	mov    %eax,0x1b80
++}
++    16de:	5b                   	pop    %ebx
++    16df:	5e                   	pop    %esi
++    16e0:	5f                   	pop    %edi
++    16e1:	5d                   	pop    %ebp
++    16e2:	c3                   	ret    
++    16e3:	90                   	nop
++    16e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    bp->s.size += p->s.ptr->s.size;
++    16e8:	03 71 04             	add    0x4(%ecx),%esi
++    16eb:	89 73 fc             	mov    %esi,-0x4(%ebx)
++    bp->s.ptr = p->s.ptr->s.ptr;
++    16ee:	8b 08                	mov    (%eax),%ecx
++    16f0:	8b 09                	mov    (%ecx),%ecx
++    16f2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
++  if(p + p->s.size == bp){
++    16f5:	8b 48 04             	mov    0x4(%eax),%ecx
++    16f8:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
++    16fb:	39 f2                	cmp    %esi,%edx
++    16fd:	75 d8                	jne    16d7 <free+0x47>
++    p->s.size += bp->s.size;
++    16ff:	03 4b fc             	add    -0x4(%ebx),%ecx
++  freep = p;
++    1702:	a3 80 1b 00 00       	mov    %eax,0x1b80
++    p->s.size += bp->s.size;
++    1707:	89 48 04             	mov    %ecx,0x4(%eax)
++    p->s.ptr = bp->s.ptr;
++    170a:	8b 53 f8             	mov    -0x8(%ebx),%edx
++    170d:	89 10                	mov    %edx,(%eax)
++}
++    170f:	5b                   	pop    %ebx
++    1710:	5e                   	pop    %esi
++    1711:	5f                   	pop    %edi
++    1712:	5d                   	pop    %ebp
++    1713:	c3                   	ret    
++    1714:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    171a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
++
++00001720 <malloc>:
++  return freep;
++}
++
++void*
++malloc(uint nbytes)
++{
++    1720:	55                   	push   %ebp
++    1721:	89 e5                	mov    %esp,%ebp
++    1723:	57                   	push   %edi
++    1724:	56                   	push   %esi
++    1725:	53                   	push   %ebx
++    1726:	83 ec 1c             	sub    $0x1c,%esp
++  Header *p, *prevp;
++  uint nunits;
++
++  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
++    1729:	8b 45 08             	mov    0x8(%ebp),%eax
++  if((prevp = freep) == 0){
++    172c:	8b 1d 80 1b 00 00    	mov    0x1b80,%ebx
++  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
++    1732:	8d 48 07             	lea    0x7(%eax),%ecx
++    1735:	c1 e9 03             	shr    $0x3,%ecx
++  if((prevp = freep) == 0){
++    1738:	85 db                	test   %ebx,%ebx
++  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
++    173a:	8d 71 01             	lea    0x1(%ecx),%esi
++  if((prevp = freep) == 0){
++    173d:	0f 84 9b 00 00 00    	je     17de <malloc+0xbe>
++    1743:	8b 13                	mov    (%ebx),%edx
++    1745:	8b 7a 04             	mov    0x4(%edx),%edi
++    base.s.ptr = freep = prevp = &base;
++    base.s.size = 0;
++  }
++  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
++    if(p->s.size >= nunits){
++    1748:	39 fe                	cmp    %edi,%esi
++    174a:	76 64                	jbe    17b0 <malloc+0x90>
++    174c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
++  if(nu < 4096)
++    1753:	bb 00 80 00 00       	mov    $0x8000,%ebx
++    1758:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++    175b:	eb 0e                	jmp    176b <malloc+0x4b>
++    175d:	8d 76 00             	lea    0x0(%esi),%esi
++  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
++    1760:	8b 02                	mov    (%edx),%eax
++    if(p->s.size >= nunits){
++    1762:	8b 78 04             	mov    0x4(%eax),%edi
++    1765:	39 fe                	cmp    %edi,%esi
++    1767:	76 4f                	jbe    17b8 <malloc+0x98>
++    1769:	89 c2                	mov    %eax,%edx
++        p->s.size = nunits;
++      }
++      freep = prevp;
++      return (void*)(p + 1);
++    }
++    if(p == freep)
++    176b:	3b 15 80 1b 00 00    	cmp    0x1b80,%edx
++    1771:	75 ed                	jne    1760 <malloc+0x40>
++  if(nu < 4096)
++    1773:	8b 45 e4             	mov    -0x1c(%ebp),%eax
++    1776:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
++    177c:	bf 00 10 00 00       	mov    $0x1000,%edi
++    1781:	0f 43 fe             	cmovae %esi,%edi
++    1784:	0f 42 c3             	cmovb  %ebx,%eax
++  p = sbrk(nu * sizeof(Header));
++    1787:	89 04 24             	mov    %eax,(%esp)
++    178a:	e8 3b fc ff ff       	call   13ca <sbrk>
++  if(p == (char*)-1)
++    178f:	83 f8 ff             	cmp    $0xffffffff,%eax
++    1792:	74 18                	je     17ac <malloc+0x8c>
++  hp->s.size = nu;
++    1794:	89 78 04             	mov    %edi,0x4(%eax)
++  free((void*)(hp + 1));
++    1797:	83 c0 08             	add    $0x8,%eax
++    179a:	89 04 24             	mov    %eax,(%esp)
++    179d:	e8 ee fe ff ff       	call   1690 <free>
++  return freep;
++    17a2:	8b 15 80 1b 00 00    	mov    0x1b80,%edx
++      if((p = morecore(nunits)) == 0)
++    17a8:	85 d2                	test   %edx,%edx
++    17aa:	75 b4                	jne    1760 <malloc+0x40>
++        return 0;
++    17ac:	31 c0                	xor    %eax,%eax
++    17ae:	eb 20                	jmp    17d0 <malloc+0xb0>
++    if(p->s.size >= nunits){
++    17b0:	89 d0                	mov    %edx,%eax
++    17b2:	89 da                	mov    %ebx,%edx
++    17b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++      if(p->s.size == nunits)
++    17b8:	39 fe                	cmp    %edi,%esi
++    17ba:	74 1c                	je     17d8 <malloc+0xb8>
++        p->s.size -= nunits;
++    17bc:	29 f7                	sub    %esi,%edi
++    17be:	89 78 04             	mov    %edi,0x4(%eax)
++        p += p->s.size;
++    17c1:	8d 04 f8             	lea    (%eax,%edi,8),%eax
++        p->s.size = nunits;
++    17c4:	89 70 04             	mov    %esi,0x4(%eax)
++      freep = prevp;
++    17c7:	89 15 80 1b 00 00    	mov    %edx,0x1b80
++      return (void*)(p + 1);
++    17cd:	83 c0 08             	add    $0x8,%eax
++  }
++}
++    17d0:	83 c4 1c             	add    $0x1c,%esp
++    17d3:	5b                   	pop    %ebx
++    17d4:	5e                   	pop    %esi
++    17d5:	5f                   	pop    %edi
++    17d6:	5d                   	pop    %ebp
++    17d7:	c3                   	ret    
++        prevp->s.ptr = p->s.ptr;
++    17d8:	8b 08                	mov    (%eax),%ecx
++    17da:	89 0a                	mov    %ecx,(%edx)
++    17dc:	eb e9                	jmp    17c7 <malloc+0xa7>
++    base.s.ptr = freep = prevp = &base;
++    17de:	c7 05 80 1b 00 00 84 	movl   $0x1b84,0x1b80
++    17e5:	1b 00 00 
++    base.s.size = 0;
++    17e8:	ba 84 1b 00 00       	mov    $0x1b84,%edx
++    base.s.ptr = freep = prevp = &base;
++    17ed:	c7 05 84 1b 00 00 84 	movl   $0x1b84,0x1b84
++    17f4:	1b 00 00 
++    base.s.size = 0;
++    17f7:	c7 05 88 1b 00 00 00 	movl   $0x0,0x1b88
++    17fe:	00 00 00 
++    1801:	e9 46 ff ff ff       	jmp    174c <malloc+0x2c>
++    1806:	66 90                	xchg   %ax,%ax
++    1808:	66 90                	xchg   %ax,%ax
++    180a:	66 90                	xchg   %ax,%ax
++    180c:	66 90                	xchg   %ax,%ax
++    180e:	66 90                	xchg   %ax,%ax
++
++00001810 <uacquire>:
++#include "uspinlock.h"
++#include "x86.h"
++
++void
++uacquire(struct uspinlock *lk)
++{
++    1810:	55                   	push   %ebp
++xchg(volatile uint *addr, uint newval)
++{
++  uint result;
++
++  // The + in "+m" denotes a read-modify-write operand.
++  asm volatile("lock; xchgl %0, %1" :
++    1811:	b9 01 00 00 00       	mov    $0x1,%ecx
++    1816:	89 e5                	mov    %esp,%ebp
++    1818:	8b 55 08             	mov    0x8(%ebp),%edx
++    181b:	90                   	nop
++    181c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    1820:	89 c8                	mov    %ecx,%eax
++    1822:	f0 87 02             	lock xchg %eax,(%edx)
++  // The xchg is atomic.
++  while(xchg(&lk->locked, 1) != 0)
++    1825:	85 c0                	test   %eax,%eax
++    1827:	75 f7                	jne    1820 <uacquire+0x10>
++    ;
++
++  // Tell the C compiler and the processor to not move loads or stores
++  // past this point, to ensure that the critical section's memory
++  // references happen after the lock is acquired.
++  __sync_synchronize();
++    1829:	0f ae f0             	mfence 
++}
++    182c:	5d                   	pop    %ebp
++    182d:	c3                   	ret    
++    182e:	66 90                	xchg   %ax,%ax
++
++00001830 <urelease>:
++
++void urelease (struct uspinlock *lk) {
++    1830:	55                   	push   %ebp
++    1831:	89 e5                	mov    %esp,%ebp
++    1833:	8b 45 08             	mov    0x8(%ebp),%eax
++  __sync_synchronize();
++    1836:	0f ae f0             	mfence 
++
++  // Release the lock, equivalent to lk->locked = 0.
++  // This code can't use a C assignment, since it might
++  // not be atomic. A real OS would use C atomics here.
++  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
++    1839:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
++}
++    183f:	5d                   	pop    %ebp
++    1840:	c3                   	ret    
+diff --git a/cat.c b/cat.c
+index 68b1b8d..5ddc820 100644
+--- a/cat.c
++++ b/cat.c
+@@ -12,12 +12,12 @@ cat(int fd)
+   while((n = read(fd, buf, sizeof(buf))) > 0) {
+     if (write(1, buf, n) != n) {
+       printf(1, "cat: write error\n");
+-      exit(3);
++      exit();
+     }
+   }
+   if(n < 0){
+     printf(1, "cat: read error\n");
+-    exit(4);
++    exit();
+   }
+ }
+ 
+@@ -28,16 +28,16 @@ main(int argc, char *argv[])
+ 
+   if(argc <= 1){
+     cat(0);
+-    exit(1);
++    exit();
+   }
+ 
+   for(i = 1; i < argc; i++){
+     if((fd = open(argv[i], 0)) < 0){
+       printf(1, "cat: cannot open %s\n", argv[i]);
+-      exit(2);
++      exit();
+     }
+     cat(fd);
+     close(fd);
+   }
+-  exit(0);
++  exit();
+ }
+diff --git a/cat.d b/cat.d
+new file mode 100644
+index 0000000..8f55acc
+--- /dev/null
++++ b/cat.d
+@@ -0,0 +1 @@
++cat.o: cat.c /usr/include/stdc-predef.h types.h stat.h user.h
+diff --git a/cat.o b/cat.o
+new file mode 100644
+index 0000000..5e359cb
+Binary files /dev/null and b/cat.o differ
+diff --git a/cat.sym b/cat.sym
+new file mode 100644
+index 0000000..8004974
+--- /dev/null
++++ b/cat.sym
+@@ -0,0 +1,64 @@
++00001000 .text
++00001841 .rodata
++00001894 .eh_frame
++00001b80 .bss
++00000000 .comment
++00000000 .debug_aranges
++00000000 .debug_info
++00000000 .debug_abbrev
++00000000 .debug_line
++00000000 .debug_str
++00000000 .debug_loc
++00000000 .debug_ranges
++00000000 cat.c
++00000000 ulib.c
++00000000 printf.c
++00001400 printint
++00001880 digits.1359
++00000000 umalloc.c
++00001b80 freep
++00001b84 base
++00000000 uspinlock.c
++00001120 strcpy
++000014a0 printf
++00001310 memmove
++0000138a mknod
++000013e2 shm_open
++00001230 gets
++000013c2 getpid
++00001090 cat
++00001720 malloc
++000013d2 sleep
++00001352 pipe
++00001362 write
++0000139a fstat
++00001372 kill
++000013b2 chdir
++0000137a exec
++0000134a wait
++0000135a read
++00001392 unlink
++00001810 uacquire
++0000133a fork
++000013ca sbrk
++000013ea shm_close
++000013da uptime
++00001b6c __bss_start
++000011d0 memset
++00001000 main
++00001150 strcmp
++000013ba dup
++00001ba0 buf
++00001290 stat
++00001b6c _edata
++00001da0 _end
++000013a2 link
++00001342 exit
++000012e0 atoi
++000011a0 strlen
++00001382 open
++000011f0 strchr
++000013aa mkdir
++0000136a close
++00001830 urelease
++00001690 free
+diff --git a/code.diff b/code.diff
+index c889659..74fcd4b 100644
+--- a/code.diff
++++ b/code.diff
+@@ -1,2919 +1,16128 @@
++diff --git a/.cvsignore b/.cvsignore
++deleted file mode 100644
++index 081a43c..0000000
++--- a/.cvsignore
+++++ /dev/null
++@@ -1,16 +0,0 @@
++-*.asm
++-*.d
++-*.sym
++-_*
++-kernel
++-user1
++-userfs
++-usertests
++-xv6.img
++-vectors.S
++-bochsout.txt
++-bootblock
++-bootother
++-bootother.out
++-parport.out
++-fmt
++diff --git a/.dir-locals.el b/.dir-locals.el
++deleted file mode 100644
++index da72247..0000000
++--- a/.dir-locals.el
+++++ /dev/null
++@@ -1,4 +0,0 @@
++-((c-mode
++-  (indent-tabs-mode . nil)
++-  (c-file-style . "bsd")
++-  (c-basic-offset . 2)))
++diff --git a/.gdbinit.tmpl b/.gdbinit.tmpl
++index f71681a..ac7a259 100644
++--- a/.gdbinit.tmpl
+++++ b/.gdbinit.tmpl
++@@ -24,4 +24,4 @@ echo + target remote localhost:1234\n
++ target remote localhost:1234
++ 
++ echo + symbol-file kernel\n
++-symbol-file kernel
+++symbol-file kernel
++\ No newline at end of file
++diff --git a/.gitignore b/.gitignore
++deleted file mode 100644
++index 3e2c9de..0000000
++--- a/.gitignore
+++++ /dev/null
++@@ -1,16 +0,0 @@
++-*~
++-_*
++-*.o
++-*.d
++-*.asm
++-*.sym
++-*.img
++-vectors.S
++-bootblock
++-entryother
++-initcode
++-initcode.out
++-kernel
++-kernelmemfs
++-mkfs
++-.gdbinit
++diff --git a/.idea/xv6.iml b/.idea/xv6.iml
++index 5aac3dd..771e54c 100644
++--- a/.idea/xv6.iml
+++++ b/.idea/xv6.iml
++@@ -1,2 +1,2 @@
++ <?xml version="1.0" encoding="UTF-8"?>
++-<module classpath="External" external.linked.project.id="xv6" external.linked.project.path="C:\Users\Kotori\Desktop\Code Projects\School\xv6\xv6" external.root.project.path="$MODULE_DIR$" external.system.id="Makefile" type="CPP_MODULE" version="4" />
++\ No newline at end of file
+++<module classpath="External" type="CPP_MODULE" version="4" />
++\ No newline at end of file
++diff --git a/BUGS b/BUGS
++deleted file mode 100644
++index 81d2220..0000000
++--- a/BUGS
+++++ /dev/null
++@@ -1,7 +0,0 @@
++-formatting:
++-	need to fix PAGEBREAK mechanism
++-
++-sh:
++-	can't always runcmd in child -- breaks cd.
++-	maybe should hard-code PATH=/ ?
++-
++diff --git a/LICENSE b/LICENSE
++deleted file mode 100644
++index 422c0cc..0000000
++--- a/LICENSE
+++++ /dev/null
++@@ -1,24 +0,0 @@
++-The xv6 software is:
++-
++-Copyright (c) 2006-2018 Frans Kaashoek, Robert Morris, Russ Cox,
++-                        Massachusetts Institute of Technology
++-
++-Permission is hereby granted, free of charge, to any person obtaining
++-a copy of this software and associated documentation files (the
++-"Software"), to deal in the Software without restriction, including
++-without limitation the rights to use, copy, modify, merge, publish,
++-distribute, sublicense, and/or sell copies of the Software, and to
++-permit persons to whom the Software is furnished to do so, subject to
++-the following conditions:
++-
++-The above copyright notice and this permission notice shall be
++-included in all copies or substantial portions of the Software.
++-
++-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
++-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
++-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
++-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
++-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
++-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
++-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
++-
+ diff --git a/Makefile b/Makefile
+-index 09d790c..04d74d5 100644
++deleted file mode 100644
++index 04d74d5..0000000
+ --- a/Makefile
+-+++ b/Makefile
+-@@ -181,6 +181,7 @@ UPROGS=\
+- 	_usertests\
+- 	_wc\
+- 	_zombie\
+-+	_lab1\
+- 
+- fs.img: mkfs README $(UPROGS)
+- 	./mkfs fs.img README $(UPROGS)
+-diff --git a/cat.c b/cat.c
+-index 5ddc820..68b1b8d 100644
+---- a/cat.c
+-+++ b/cat.c
+-@@ -12,12 +12,12 @@ cat(int fd)
+-   while((n = read(fd, buf, sizeof(buf))) > 0) {
+-     if (write(1, buf, n) != n) {
+-       printf(1, "cat: write error\n");
+--      exit();
+-+      exit(3);
+-     }
+-   }
+-   if(n < 0){
+-     printf(1, "cat: read error\n");
+--    exit();
+-+    exit(4);
+-   }
+- }
+- 
+-@@ -28,16 +28,16 @@ main(int argc, char *argv[])
+- 
+-   if(argc <= 1){
+-     cat(0);
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-     if((fd = open(argv[i], 0)) < 0){
+-       printf(1, "cat: cannot open %s\n", argv[i]);
+--      exit();
+-+      exit(2);
+-     }
+-     cat(fd);
+-     close(fd);
+-   }
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/cuth b/cuth
+-old mode 100755
+-new mode 100644
+-diff --git a/defs.h b/defs.h
+-index 82fb982..d1934ca 100644
+---- a/defs.h
+-+++ b/defs.h
+-@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
+- //PAGEBREAK: 16
+- // proc.c
+- int             cpuid(void);
+--void            exit(void);
+-+void            exit(int status);
+- int             fork(void);
+- int             growproc(int);
+- int             kill(int);
+-@@ -117,7 +117,8 @@ void            sched(void);
+- void            setproc(struct proc*);
+- void            sleep(void*, struct spinlock*);
+- void            userinit(void);
+--int             wait(void);
+-+int             wait(int* status);
+-+int             waitpid(int pid, int* status, int options);
+- void            wakeup(void*);
+- void            yield(void);
+- 
+-diff --git a/dot-bochsrc b/dot-bochsrc
+-old mode 100755
+-new mode 100644
+-diff --git a/echo.c b/echo.c
+-index 806dee0..eed68a0 100644
+---- a/echo.c
+-+++ b/echo.c
+-@@ -9,5 +9,5 @@ main(int argc, char *argv[])
+- 
+-   for(i = 1; i < argc; i++)
+-     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/forktest.c b/forktest.c
+-index 8bc984d..a4b35ed 100644
+---- a/forktest.c
+-+++ b/forktest.c
+-@@ -25,24 +25,24 @@ forktest(void)
+-     if(pid < 0)
+-       break;
+-     if(pid == 0)
+--      exit();
+-+      exit(4);
+-   }
+- 
+-   if(n == N){
+-     printf(1, "fork claimed to work N times!\n", N);
+--    exit();
+-+    exit(3);
+-   }
+- 
+-   for(; n > 0; n--){
+--    if(wait() < 0){
+-+    if(wait(NULL) < 0){
+-       printf(1, "wait stopped early\n");
+--      exit();
+-+      exit(2);
+-     }
+-   }
+- 
+--  if(wait() != -1){
+-+  if(wait(NULL) != -1){
+-     printf(1, "wait got too many\n");
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   printf(1, "fork test OK\n");
+-@@ -52,5 +52,5 @@ int
+- main(void)
+- {
+-   forktest();
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/grep.c b/grep.c
+-index adc4835..4be3256 100644
+---- a/grep.c
+-+++ b/grep.c
+-@@ -43,24 +43,24 @@ main(int argc, char *argv[])
+- 
+-   if(argc <= 1){
+-     printf(2, "usage: grep pattern [file ...]\n");
+--    exit();
+-+    exit(1);
+-   }
+-   pattern = argv[1];
+- 
+-   if(argc <= 2){
+-     grep(pattern, 0);
+--    exit();
+-+    exit(2);
+-   }
+- 
+-   for(i = 2; i < argc; i++){
+-     if((fd = open(argv[i], 0)) < 0){
+-       printf(1, "grep: cannot open %s\n", argv[i]);
+--      exit();
+-+      exit(3);
+-     }
+-     grep(pattern, fd);
+-     close(fd);
+-   }
+--  exit();
+-+  exit(0);
+- }
+- 
+- // Regexp matcher from Kernighan & Pike,
+-diff --git a/init.c b/init.c
+-index 046b551..bc6547f 100644
+---- a/init.c
+-+++ b/init.c
+-@@ -24,14 +24,14 @@ main(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "init: fork failed\n");
+--      exit();
+-+      exit(2);
+-     }
+-     if(pid == 0){
+-       exec("sh", argv);
+-       printf(1, "init: exec sh failed\n");
+--      exit();
+-+      exit(1);
+-     }
+--    while((wpid=wait()) >= 0 && wpid != pid)
+-+    while((wpid=wait(NULL)) >= 0 && wpid != pid)
+-       printf(1, "zombie!\n");
+-   }
+- }
+-diff --git a/kill.c b/kill.c
+-index 364f6af..875916c 100644
+---- a/kill.c
+-+++ b/kill.c
+-@@ -9,9 +9,9 @@ main(int argc, char **argv)
+- 
+-   if(argc < 2){
+-     printf(2, "usage: kill pid...\n");
+--    exit();
+-+    exit(1);
+-   }
+-   for(i=1; i<argc; i++)
+-     kill(atoi(argv[i]));
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/lab1.c b/lab1.c
+-index 89668ce..2192a52 100644
+---- a/lab1.c
+-+++ b/lab1.c
+-@@ -25,7 +25,7 @@ int main(int argc, char **argv) {
+-     if(pid > 0)
+-     {
+-         waitpid(pid, NULL, 0);
+--        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);
+-+        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
+-         exit(0);
+-     }
+- 
+-diff --git a/ln.c b/ln.c
+-index cf8a64e..fb17c3b 100644
+---- a/ln.c
+-+++ b/ln.c
+-@@ -7,9 +7,9 @@ main(int argc, char *argv[])
+- {
+-   if(argc != 3){
+-     printf(2, "Usage: ln old new\n");
+--    exit();
+-+    exit(1);
+-   }
+-   if(link(argv[1], argv[2]) < 0)
+-     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/ls.c b/ls.c
+-index 2862913..6bf943b 100644
+---- a/ls.c
+-+++ b/ls.c
+-@@ -77,9 +77,9 @@ main(int argc, char *argv[])
+- 
+-   if(argc < 2){
+-     ls(".");
+--    exit();
+-+    exit(1);
+-   }
+-   for(i=1; i<argc; i++)
+-     ls(argv[i]);
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/mkdir.c b/mkdir.c
+-index 6e4c954..2d90781 100644
+---- a/mkdir.c
+-+++ b/mkdir.c
+-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
+- 
+-   if(argc < 2){
+-     printf(2, "Usage: mkdir files...\n");
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
+-     }
+-   }
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/pr.pl b/pr.pl
+-old mode 100755
+-new mode 100644
+-diff --git a/printpcs b/printpcs
+-old mode 100755
+-new mode 100644
+-diff --git a/proc.c b/proc.c
+-index 806b1b1..84b335f 100644
+---- a/proc.c
+-+++ b/proc.c
+-@@ -1,3 +1,5 @@
+-+#include <stddef.h>
+-+
+- #include "types.h"
+- #include "defs.h"
+- #include "param.h"
+-@@ -8,61 +10,61 @@
+- #include "spinlock.h"
+- 
+- struct {
+--  struct spinlock lock;
+--  struct proc proc[NPROC];
+-+    struct spinlock lock;
+-+    struct proc proc[NPROC];
+- } ptable;
+- 
+- static struct proc *initproc;
+- 
+- int nextpid = 1;
+-+
+- extern void forkret(void);
+-+
+- extern void trapret(void);
+- 
+- static void wakeup1(void *chan);
+- 
+- void
+--pinit(void)
+--{
+--  initlock(&ptable.lock, "ptable");
+-+pinit(void) {
+-+    initlock(&ptable.lock, "ptable");
+- }
+- 
+- // Must be called with interrupts disabled
+- int
+- cpuid() {
+--  return mycpu()-cpus;
+-+    return mycpu() - cpus;
+- }
+- 
+- // Must be called with interrupts disabled to avoid the caller being
+- // rescheduled between reading lapicid and running through the loop.
+--struct cpu*
+--mycpu(void)
+--{
+--  int apicid, i;
+--  
+--  if(readeflags()&FL_IF)
+--    panic("mycpu called with interrupts enabled\n");
+--  
+--  apicid = lapicid();
+--  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+--  // a reverse map, or reserve a register to store &cpus[i].
+--  for (i = 0; i < ncpu; ++i) {
+--    if (cpus[i].apicid == apicid)
+--      return &cpus[i];
+--  }
+--  panic("unknown apicid\n");
+-+struct cpu *
+-+mycpu(void) {
+-+    int apicid, i;
+-+
+-+    if (readeflags() & FL_IF)
+-+        panic("mycpu called with interrupts enabled\n");
+-+
+-+    apicid = lapicid();
+-+    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+-+    // a reverse map, or reserve a register to store &cpus[i].
+-+    for (i = 0; i < ncpu; ++i) {
+-+        if (cpus[i].apicid == apicid)
+-+            return &cpus[i];
+-+    }
+-+    panic("unknown apicid\n");
+- }
+- 
+- // Disable interrupts so that we are not rescheduled
+- // while reading proc from the cpu structure
+--struct proc*
+-+struct proc *
+- myproc(void) {
+--  struct cpu *c;
+--  struct proc *p;
+--  pushcli();
+--  c = mycpu();
+--  p = c->proc;
+--  popcli();
+--  return p;
+-+    struct cpu *c;
+-+    struct proc *p;
+-+    pushcli();
+-+    c = mycpu();
+-+    p = c->proc;
+-+    popcli();
+-+    return p;
+- }
+- 
+- //PAGEBREAK: 32
+-@@ -70,245 +72,295 @@ myproc(void) {
+- // If found, change state to EMBRYO and initialize
+- // state required to run in the kernel.
+- // Otherwise return 0.
+--static struct proc*
+--allocproc(void)
+--{
+--  struct proc *p;
+--  char *sp;
+-+static struct proc *
+-+allocproc(void) {
+-+    struct proc *p;
+-+    char *sp;
+- 
+--  acquire(&ptable.lock);
+-+    acquire(&ptable.lock);
+- 
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+--    if(p->state == UNUSED)
+--      goto found;
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-+        if (p->state == UNUSED)
+-+            goto found;
+- 
+--  release(&ptable.lock);
+--  return 0;
+-+    release(&ptable.lock);
+-+    return 0;
+- 
+--found:
+--  p->state = EMBRYO;
+--  p->pid = nextpid++;
+-+    found:
+-+    p->state = EMBRYO;
+-+    p->pid = nextpid++;
+- 
+--  release(&ptable.lock);
+-+    release(&ptable.lock);
+- 
+--  // Allocate kernel stack.
+--  if((p->kstack = kalloc()) == 0){
+--    p->state = UNUSED;
+--    return 0;
+--  }
+--  sp = p->kstack + KSTACKSIZE;
+-+    // Allocate kernel stack.
+-+    if ((p->kstack = kalloc()) == 0) {
+-+        p->state = UNUSED;
+-+        return 0;
+-+    }
+-+    sp = p->kstack + KSTACKSIZE;
+- 
+--  // Leave room for trap frame.
+--  sp -= sizeof *p->tf;
+--  p->tf = (struct trapframe*)sp;
+-+    // Leave room for trap frame.
+-+    sp -= sizeof *p->tf;
+-+    p->tf = (struct trapframe *) sp;
+- 
+--  // Set up new context to start executing at forkret,
+--  // which returns to trapret.
+--  sp -= 4;
+--  *(uint*)sp = (uint)trapret;
+-+    // Set up new context to start executing at forkret,
+-+    // which returns to trapret.
+-+    sp -= 4;
+-+    *(uint *) sp = (uint) trapret;
+- 
+--  sp -= sizeof *p->context;
+--  p->context = (struct context*)sp;
+--  memset(p->context, 0, sizeof *p->context);
+--  p->context->eip = (uint)forkret;
+-+    sp -= sizeof *p->context;
+-+    p->context = (struct context *) sp;
+-+    memset(p->context, 0, sizeof *p->context);
+-+    p->context->eip = (uint) forkret;
+- 
+--  return p;
+-+    return p;
+- }
+- 
+- //PAGEBREAK: 32
+- // Set up first user process.
+- void
+--userinit(void)
+--{
+--  struct proc *p;
+--  extern char _binary_initcode_start[], _binary_initcode_size[];
+++++ /dev/null
++@@ -1,287 +0,0 @@
++-OBJS = \
++-	bio.o\
++-	console.o\
++-	exec.o\
++-	file.o\
++-	fs.o\
++-	ide.o\
++-	ioapic.o\
++-	kalloc.o\
++-	kbd.o\
++-	lapic.o\
++-	log.o\
++-	main.o\
++-	mp.o\
++-	picirq.o\
++-	pipe.o\
++-	proc.o\
++-	sleeplock.o\
++-	spinlock.o\
++-	string.o\
++-	swtch.o\
++-	syscall.o\
++-	sysfile.o\
++-	sysproc.o\
++-	trapasm.o\
++-	trap.o\
++-	uart.o\
++-	vectors.o\
++-	vm.o\
+ -
+--  p = allocproc();
+--  
+--  initproc = p;
+--  if((p->pgdir = setupkvm()) == 0)
+--    panic("userinit: out of memory?");
+--  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+--  p->sz = PGSIZE;
+--  memset(p->tf, 0, sizeof(*p->tf));
+--  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+--  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+--  p->tf->es = p->tf->ds;
+--  p->tf->ss = p->tf->ds;
+--  p->tf->eflags = FL_IF;
+--  p->tf->esp = PGSIZE;
+--  p->tf->eip = 0;  // beginning of initcode.S
+--
+--  safestrcpy(p->name, "initcode", sizeof(p->name));
+--  p->cwd = namei("/");
+--
+--  // this assignment to p->state lets other cores
+--  // run this process. the acquire forces the above
+--  // writes to be visible, and the lock is also needed
+--  // because the assignment might not be atomic.
+--  acquire(&ptable.lock);
+--
+--  p->state = RUNNABLE;
+--
+--  release(&ptable.lock);
+-+userinit(void) {
+-+    struct proc *p;
+-+    extern char _binary_initcode_start[], _binary_initcode_size[];
+-+
+-+    p = allocproc();
+-+
+-+    initproc = p;
+-+    if ((p->pgdir = setupkvm()) == 0)
+-+        panic("userinit: out of memory?");
+-+    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
+-+    p->sz = PGSIZE;
+-+    memset(p->tf, 0, sizeof(*p->tf));
+-+    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+-+    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+-+    p->tf->es = p->tf->ds;
+-+    p->tf->ss = p->tf->ds;
+-+    p->tf->eflags = FL_IF;
+-+    p->tf->esp = PGSIZE;
+-+    p->tf->eip = 0;  // beginning of initcode.S
+-+
+-+    safestrcpy(p->name, "initcode", sizeof(p->name));
+-+    p->cwd = namei("/");
+-+
+-+    // this assignment to p->state lets other cores
+-+    // run this process. the acquire forces the above
+-+    // writes to be visible, and the lock is also needed
+-+    // because the assignment might not be atomic.
+-+    acquire(&ptable.lock);
+-+
+-+    p->state = RUNNABLE;
+-+
+-+    release(&ptable.lock);
+- }
+- 
+- // Grow current process's memory by n bytes.
+- // Return 0 on success, -1 on failure.
+- int
+--growproc(int n)
+--{
+--  uint sz;
+--  struct proc *curproc = myproc();
++-# Cross-compiling (e.g., on Mac OS X)
++-# TOOLPREFIX = i386-jos-elf
+ -
+--  sz = curproc->sz;
+--  if(n > 0){
+--    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+--      return -1;
+--  } else if(n < 0){
+--    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+--      return -1;
+--  }
+--  curproc->sz = sz;
+--  switchuvm(curproc);
+--  return 0;
+-+growproc(int n) {
+-+    uint sz;
+-+    struct proc *curproc = myproc();
+-+
+-+    sz = curproc->sz;
+-+    if (n > 0) {
+-+        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-+            return -1;
+-+    } else if (n < 0) {
+-+        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+-+            return -1;
+-+    }
+-+    curproc->sz = sz;
+-+    switchuvm(curproc);
+-+    return 0;
+- }
+- 
+- // Create a new process copying p as the parent.
+- // Sets up stack to return as if from system call.
+- // Caller must set state of returned proc to RUNNABLE.
+- int
+--fork(void)
+--{
+--  int i, pid;
+--  struct proc *np;
+--  struct proc *curproc = myproc();
++-# Using native tools (e.g., on X86 Linux)
++-#TOOLPREFIX = 
+ -
+--  // Allocate process.
+--  if((np = allocproc()) == 0){
+--    return -1;
+--  }
+-+fork(void) {
+-+    int i, pid;
+-+    struct proc *np;
+-+    struct proc *curproc = myproc();
+-+
+-+    // Allocate process.
+-+    if ((np = allocproc()) == 0) {
+-+        return -1;
+-+    }
+- 
+--  // Copy process state from proc.
+--  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+--    kfree(np->kstack);
+--    np->kstack = 0;
+--    np->state = UNUSED;
+--    return -1;
+--  }
+--  np->sz = curproc->sz;
+--  np->parent = curproc;
+--  *np->tf = *curproc->tf;
+-+    // Copy process state from proc.
+-+    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
+-+        kfree(np->kstack);
+-+        np->kstack = 0;
+-+        np->state = UNUSED;
+-+        return -1;
+-+    }
+-+    np->sz = curproc->sz;
+-+    np->parent = curproc;
+-+    *np->tf = *curproc->tf;
+- 
+--  // Clear %eax so that fork returns 0 in the child.
+--  np->tf->eax = 0;
+-+    // Clear %eax so that fork returns 0 in the child.
+-+    np->tf->eax = 0;
+- 
+--  for(i = 0; i < NOFILE; i++)
+--    if(curproc->ofile[i])
+--      np->ofile[i] = filedup(curproc->ofile[i]);
+--  np->cwd = idup(curproc->cwd);
+-+    for (i = 0; i < NOFILE; i++)
+-+        if (curproc->ofile[i])
+-+            np->ofile[i] = filedup(curproc->ofile[i]);
+-+    np->cwd = idup(curproc->cwd);
+- 
+--  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+-+    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+- 
+--  pid = np->pid;
+-+    pid = np->pid;
+- 
+--  acquire(&ptable.lock);
+-+    acquire(&ptable.lock);
+- 
+--  np->state = RUNNABLE;
+-+    np->state = RUNNABLE;
+- 
+--  release(&ptable.lock);
+-+    release(&ptable.lock);
+- 
+--  return pid;
+-+    return pid;
+- }
+- 
+- // Exit the current process.  Does not return.
+- // An exited process remains in the zombie state
+- // until its parent calls wait() to find out it exited.
+- void
+--exit(void)
+--{
+--  struct proc *curproc = myproc();
+--  struct proc *p;
+--  int fd;
++-# Try to infer the correct TOOLPREFIX if not set
++-ifndef TOOLPREFIX
++-TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
++-	then echo 'i386-jos-elf-'; \
++-	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
++-	then echo ''; \
++-	else echo "***" 1>&2; \
++-	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
++-	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
++-	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
++-	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
++-	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
++-	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
++-	echo "***" 1>&2; exit 1; fi)
++-endif
+ -
+--  if(curproc == initproc)
+--    panic("init exiting");
++-# If the makefile can't find QEMU, specify its path here
++-# QEMU = qemu-system-i386
+ -
+--  // Close all open files.
+--  for(fd = 0; fd < NOFILE; fd++){
+--    if(curproc->ofile[fd]){
+--      fileclose(curproc->ofile[fd]);
+--      curproc->ofile[fd] = 0;
+-+exit(int status) {
+-+    struct proc *curproc = myproc();
+-+    struct proc *p;
+-+    int fd;
+-+
+-+    curproc->status = status;
+-+
+-+    if (curproc == initproc)
+-+        panic("init exiting");
+-+
+-+    // Close all open files.
+-+    for (fd = 0; fd < NOFILE; fd++) {
+-+        if (curproc->ofile[fd]) {
+-+            fileclose(curproc->ofile[fd]);
+-+            curproc->ofile[fd] = 0;
+-+        }
+-     }
+--  }
+- 
+--  begin_op();
+--  iput(curproc->cwd);
+--  end_op();
+--  curproc->cwd = 0;
+-+    begin_op();
+-+    iput(curproc->cwd);
+-+    end_op();
+-+    curproc->cwd = 0;
+- 
+--  acquire(&ptable.lock);
+-+    acquire(&ptable.lock);
+- 
+--  // Parent might be sleeping in wait().
+--  wakeup1(curproc->parent);
+-+    // Parent might be sleeping in wait().
+-+    wakeup1(curproc->parent);
+- 
+--  // Pass abandoned children to init.
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--    if(p->parent == curproc){
+--      p->parent = initproc;
+--      if(p->state == ZOMBIE)
+--        wakeup1(initproc);
+-+    // Pass abandoned children to init.
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+        if (p->parent == curproc) {
+-+            p->parent = initproc;
+-+            if (p->state == ZOMBIE)
+-+                wakeup1(initproc);
+-+        }
+-     }
+--  }
+- 
+--  // Jump into the scheduler, never to return.
+--  curproc->state = ZOMBIE;
+--  sched();
+--  panic("zombie exit");
+-+    // Jump into the scheduler, never to return.
+-+    curproc->state = ZOMBIE;
+-+    sched();
+-+    panic("zombie exit");
+- }
+- 
+- // Wait for a child process to exit and return its pid.
+- // Return -1 if this process has no children.
+- int
+--wait(void)
+--{
+--  struct proc *p;
+--  int havekids, pid;
+--  struct proc *curproc = myproc();
+--  
+--  acquire(&ptable.lock);
+--  for(;;){
+--    // Scan through table looking for exited children.
+--    havekids = 0;
+--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--      if(p->parent != curproc)
+--        continue;
+--      havekids = 1;
+--      if(p->state == ZOMBIE){
+--        // Found one.
+--        pid = p->pid;
+--        kfree(p->kstack);
+--        p->kstack = 0;
+--        freevm(p->pgdir);
+--        p->pid = 0;
+--        p->parent = 0;
+--        p->name[0] = 0;
+--        p->killed = 0;
+--        p->state = UNUSED;
+--        release(&ptable.lock);
+--        return pid;
+--      }
+--    }
+-+wait(int *status) {
+-+    struct proc *p;
+-+    int havekids, pid;
+-+    struct proc *curproc = myproc();
+- 
+--    // No point waiting if we don't have any children.
+--    if(!havekids || curproc->killed){
+--      release(&ptable.lock);
+--      return -1;
+-+    acquire(&ptable.lock);
+-+    for (;;) {
+-+        // Scan through table looking for exited children.
+-+        havekids = 0;
+-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+            if (p->parent != curproc)
+-+                continue;
+-+            havekids = 1;
+-+            if (p->state == ZOMBIE) {
+-+                // Found one.
+-+                pid = p->pid;
+-+                kfree(p->kstack);
+-+                p->kstack = 0;
+-+                freevm(p->pgdir);
+-+                p->pid = 0;
+-+                p->parent = 0;
+-+                p->name[0] = 0;
+-+                p->killed = 0;
+-+                p->state = UNUSED;
+-+                release(&ptable.lock);
+-+                if (status != NULL)
+-+                    *status = p->status;
+-+                return pid;
+-+            }
+-+        }
+-+
+-+        // No point waiting if we don't have any children.
+-+        if (!havekids || curproc->killed) {
+-+            release(&ptable.lock);
+-+            return -1;
+-+        }
+-+
+-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+-     }
+-+}
+- 
+--    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+--    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+--  }
+-+// Wait for a child process to exit and return its pid.
+-+// Return -1 if this process has no children.
+-+int
+-+waitpid(int pidBeingSearchedFor, int *status, int options) {
+-+    struct proc *p;
+-+    int doesProcExist, pidFound;
+-+    struct proc *curproc = myproc();
+-+    acquire(&ptable.lock);
+-+    for (;;) {
+-+        // Scan through table looking for exited children.
+-+        doesProcExist = 0;
+-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+//            if(p->parent != curproc)
+-+//                continue;
+-+
+-+            if (p->pid != pidBeingSearchedFor)
+-+                continue;
+-+
+-+            doesProcExist = 1;
+-+            if (p->state == ZOMBIE) {
+-+                // Found one.
+-+                pidFound = p->pid;
+-+                kfree(p->kstack);
+-+                p->kstack = 0;
+-+                freevm(p->pgdir);
+-+                p->pid = 0;
+-+                p->parent = 0;
+-+                p->name[0] = 0;
+-+                p->killed = 0;
+-+                p->state = UNUSED;
+-+                release(&ptable.lock);
+-+                if (status != NULL)
+-+                    *status = p->status;
+-+                return pidFound;
+-+            }
+-+        }
+-+
+-+//        // No point waiting if we don't have any children.
+-+//        if(!havekids || curproc->killed){
+-+//            release(&ptable.lock);
+-+//            return -1;
+-+//        }
+-+
+-+        if (!doesProcExist || curproc->killed) {
+-+            release(&ptable.lock);
+-+            return -1;
+-+        }
+-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+-+    }
+- }
+- 
+- //PAGEBREAK: 42
+-@@ -320,39 +372,38 @@ wait(void)
+- //  - eventually that process transfers control
+- //      via swtch back to the scheduler.
+- void
+--scheduler(void)
+--{
+--  struct proc *p;
+--  struct cpu *c = mycpu();
+--  c->proc = 0;
+--  
+--  for(;;){
+--    // Enable interrupts on this processor.
+--    sti();
++-# Try to infer the correct QEMU
++-ifndef QEMU
++-QEMU = $(shell if which qemu > /dev/null; \
++-	then echo qemu; exit; \
++-	elif which qemu-system-i386 > /dev/null; \
++-	then echo qemu-system-i386; exit; \
++-	elif which qemu-system-x86_64 > /dev/null; \
++-	then echo qemu-system-x86_64; exit; \
++-	else \
++-	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
++-	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
++-	echo "***" 1>&2; \
++-	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
++-	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
++-	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
++-	echo "***" 1>&2; exit 1)
++-endif
+ -
+--    // Loop over process table looking for process to run.
+--    acquire(&ptable.lock);
+--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--      if(p->state != RUNNABLE)
+--        continue;
++-CC = $(TOOLPREFIX)gcc
++-AS = $(TOOLPREFIX)gas
++-LD = $(TOOLPREFIX)ld
++-OBJCOPY = $(TOOLPREFIX)objcopy
++-OBJDUMP = $(TOOLPREFIX)objdump
++-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
++-CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
++-ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
++-# FreeBSD ld wants ``elf_i386_fbsd''
++-LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+ -
+--      // Switch to chosen process.  It is the process's job
+--      // to release ptable.lock and then reacquire it
+--      // before jumping back to us.
+--      c->proc = p;
+--      switchuvm(p);
+--      p->state = RUNNING;
++-# Disable PIE when possible (for Ubuntu 16.10 toolchain)
++-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
++-CFLAGS += -fno-pie -no-pie
++-endif
++-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
++-CFLAGS += -fno-pie -nopie
++-endif
+ -
+--      swtch(&(c->scheduler), p->context);
+--      switchkvm();
++-xv6.img: bootblock kernel
++-	dd if=/dev/zero of=xv6.img count=10000
++-	dd if=bootblock of=xv6.img conv=notrunc
++-	dd if=kernel of=xv6.img seek=1 conv=notrunc
+ -
+--      // Process is done running for now.
+--      // It should have changed its p->state before coming back.
+--      c->proc = 0;
+--    }
+--    release(&ptable.lock);
+-+scheduler(void) {
+-+    struct proc *p;
+-+    struct cpu *c = mycpu();
+-+    c->proc = 0;
+-+
+-+    for (;;) {
+-+        // Enable interrupts on this processor.
+-+        sti();
+-+
+-+        // Loop over process table looking for process to run.
+-+        acquire(&ptable.lock);
+-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+            if (p->state != RUNNABLE)
+-+                continue;
+-+
+-+            // Switch to chosen process.  It is the process's job
+-+            // to release ptable.lock and then reacquire it
+-+            // before jumping back to us.
+-+            c->proc = p;
+-+            switchuvm(p);
+-+            p->state = RUNNING;
+-+
+-+            swtch(&(c->scheduler), p->context);
+-+            switchkvm();
+-+
+-+            // Process is done running for now.
+-+            // It should have changed its p->state before coming back.
+-+            c->proc = 0;
+-+        }
+-+        release(&ptable.lock);
+- 
+--  }
+-+    }
+- }
+- 
+- // Enter scheduler.  Must hold only ptable.lock
+-@@ -363,137 +414,130 @@ scheduler(void)
+- // break in the few places where a lock is held but
+- // there's no process.
+- void
+--sched(void)
+--{
+--  int intena;
+--  struct proc *p = myproc();
+--
+--  if(!holding(&ptable.lock))
+--    panic("sched ptable.lock");
+--  if(mycpu()->ncli != 1)
+--    panic("sched locks");
+--  if(p->state == RUNNING)
+--    panic("sched running");
+--  if(readeflags()&FL_IF)
+--    panic("sched interruptible");
+--  intena = mycpu()->intena;
+--  swtch(&p->context, mycpu()->scheduler);
+--  mycpu()->intena = intena;
+-+sched(void) {
+-+    int intena;
+-+    struct proc *p = myproc();
+-+
+-+    if (!holding(&ptable.lock))
+-+        panic("sched ptable.lock");
+-+    if (mycpu()->ncli != 1)
+-+        panic("sched locks");
+-+    if (p->state == RUNNING)
+-+        panic("sched running");
+-+    if (readeflags() & FL_IF)
+-+        panic("sched interruptible");
+-+    intena = mycpu()->intena;
+-+    swtch(&p->context, mycpu()->scheduler);
+-+    mycpu()->intena = intena;
+- }
+- 
+- // Give up the CPU for one scheduling round.
+- void
+--yield(void)
+--{
+--  acquire(&ptable.lock);  //DOC: yieldlock
+--  myproc()->state = RUNNABLE;
+--  sched();
+--  release(&ptable.lock);
+-+yield(void) {
+-+    acquire(&ptable.lock);  //DOC: yieldlock
+-+    myproc()->state = RUNNABLE;
+-+    sched();
+-+    release(&ptable.lock);
+- }
+- 
+- // A fork child's very first scheduling by scheduler()
+- // will swtch here.  "Return" to user space.
+- void
+--forkret(void)
+--{
+--  static int first = 1;
+--  // Still holding ptable.lock from scheduler.
+--  release(&ptable.lock);
+--
+--  if (first) {
+--    // Some initialization functions must be run in the context
+--    // of a regular process (e.g., they call sleep), and thus cannot
+--    // be run from main().
+--    first = 0;
+--    iinit(ROOTDEV);
+--    initlog(ROOTDEV);
+--  }
+--
+--  // Return to "caller", actually trapret (see allocproc).
+-+forkret(void) {
+-+    static int first = 1;
+-+    // Still holding ptable.lock from scheduler.
+-+    release(&ptable.lock);
+-+
+-+    if (first) {
+-+        // Some initialization functions must be run in the context
+-+        // of a regular process (e.g., they call sleep), and thus cannot
+-+        // be run from main().
+-+        first = 0;
+-+        iinit(ROOTDEV);
+-+        initlog(ROOTDEV);
+-+    }
+-+
+-+    // Return to "caller", actually trapret (see allocproc).
+- }
+- 
+- // Atomically release lock and sleep on chan.
+- // Reacquires lock when awakened.
+- void
+--sleep(void *chan, struct spinlock *lk)
+--{
+--  struct proc *p = myproc();
+--  
+--  if(p == 0)
+--    panic("sleep");
++-xv6memfs.img: bootblock kernelmemfs
++-	dd if=/dev/zero of=xv6memfs.img count=10000
++-	dd if=bootblock of=xv6memfs.img conv=notrunc
++-	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+ -
+--  if(lk == 0)
+--    panic("sleep without lk");
++-bootblock: bootasm.S bootmain.c
++-	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
++-	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
++-	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
++-	$(OBJDUMP) -S bootblock.o > bootblock.asm
++-	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
++-	./sign.pl bootblock
+ -
+--  // Must acquire ptable.lock in order to
+--  // change p->state and then call sched.
+--  // Once we hold ptable.lock, we can be
+--  // guaranteed that we won't miss any wakeup
+--  // (wakeup runs with ptable.lock locked),
+--  // so it's okay to release lk.
+--  if(lk != &ptable.lock){  //DOC: sleeplock0
+--    acquire(&ptable.lock);  //DOC: sleeplock1
+--    release(lk);
+--  }
+--  // Go to sleep.
+--  p->chan = chan;
+--  p->state = SLEEPING;
++-entryother: entryother.S
++-	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
++-	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
++-	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
++-	$(OBJDUMP) -S bootblockother.o > entryother.asm
+ -
+--  sched();
++-initcode: initcode.S
++-	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
++-	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
++-	$(OBJCOPY) -S -O binary initcode.out initcode
++-	$(OBJDUMP) -S initcode.o > initcode.asm
+ -
+--  // Tidy up.
+--  p->chan = 0;
++-kernel: $(OBJS) entry.o entryother initcode kernel.ld
++-	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
++-	$(OBJDUMP) -S kernel > kernel.asm
++-	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+ -
+--  // Reacquire original lock.
+--  if(lk != &ptable.lock){  //DOC: sleeplock2
+--    release(&ptable.lock);
+--    acquire(lk);
+--  }
+-+sleep(void *chan, struct spinlock *lk) {
+-+    struct proc *p = myproc();
+-+
+-+    if (p == 0)
+-+        panic("sleep");
+-+
+-+    if (lk == 0)
+-+        panic("sleep without lk");
+-+
+-+    // Must acquire ptable.lock in order to
+-+    // change p->state and then call sched.
+-+    // Once we hold ptable.lock, we can be
+-+    // guaranteed that we won't miss any wakeup
+-+    // (wakeup runs with ptable.lock locked),
+-+    // so it's okay to release lk.
+-+    if (lk != &ptable.lock) {  //DOC: sleeplock0
+-+        acquire(&ptable.lock);  //DOC: sleeplock1
+-+        release(lk);
+-+    }
+-+    // Go to sleep.
+-+    p->chan = chan;
+-+    p->state = SLEEPING;
+-+
+-+    sched();
+-+
+-+    // Tidy up.
+-+    p->chan = 0;
+-+
+-+    // Reacquire original lock.
+-+    if (lk != &ptable.lock) {  //DOC: sleeplock2
+-+        release(&ptable.lock);
+-+        acquire(lk);
+-+    }
+- }
+- 
+- //PAGEBREAK!
+- // Wake up all processes sleeping on chan.
+- // The ptable lock must be held.
+- static void
+--wakeup1(void *chan)
+--{
+--  struct proc *p;
+-+wakeup1(void *chan) {
+-+    struct proc *p;
+- 
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+--    if(p->state == SLEEPING && p->chan == chan)
+--      p->state = RUNNABLE;
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-+        if (p->state == SLEEPING && p->chan == chan)
+-+            p->state = RUNNABLE;
+- }
+- 
+- // Wake up all processes sleeping on chan.
+- void
+--wakeup(void *chan)
+--{
+--  acquire(&ptable.lock);
+--  wakeup1(chan);
+--  release(&ptable.lock);
+-+wakeup(void *chan) {
+-+    acquire(&ptable.lock);
+-+    wakeup1(chan);
+-+    release(&ptable.lock);
+- }
+- 
+- // Kill the process with the given pid.
+- // Process won't exit until it returns
+- // to user space (see trap in trap.c).
+- int
+--kill(int pid)
+--{
+--  struct proc *p;
+--
+--  acquire(&ptable.lock);
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--    if(p->pid == pid){
+--      p->killed = 1;
+--      // Wake process from sleep if necessary.
+--      if(p->state == SLEEPING)
+--        p->state = RUNNABLE;
+--      release(&ptable.lock);
+--      return 0;
+-+kill(int pid) {
+-+    struct proc *p;
+-+
+-+    acquire(&ptable.lock);
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+        if (p->pid == pid) {
+-+            p->killed = 1;
+-+            // Wake process from sleep if necessary.
+-+            if (p->state == SLEEPING)
+-+                p->state = RUNNABLE;
+-+            release(&ptable.lock);
+-+            return 0;
+-+        }
+-     }
+--  }
+--  release(&ptable.lock);
+--  return -1;
+-+    release(&ptable.lock);
+-+    return -1;
+- }
+- 
+- //PAGEBREAK: 36
+-@@ -501,34 +545,33 @@ kill(int pid)
+- // Runs when user types ^P on console.
+- // No lock to avoid wedging a stuck machine further.
+- void
+--procdump(void)
+--{
+--  static char *states[] = {
+--  [UNUSED]    "unused",
+--  [EMBRYO]    "embryo",
+--  [SLEEPING]  "sleep ",
+--  [RUNNABLE]  "runble",
+--  [RUNNING]   "run   ",
+--  [ZOMBIE]    "zombie"
+--  };
+--  int i;
+--  struct proc *p;
+--  char *state;
+--  uint pc[10];
++-# kernelmemfs is a copy of kernel that maintains the
++-# disk image in memory instead of writing to a disk.
++-# This is not so useful for testing persistent storage or
++-# exploring disk buffering implementations, but it is
++-# great for testing the kernel on real hardware without
++-# needing a scratch disk.
++-MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
++-kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
++-	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
++-	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
++-	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+ -
+--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--    if(p->state == UNUSED)
++-tags: $(OBJS) entryother.S _init
++-	etags *.S *.c
++-
++-vectors.S: vectors.pl
++-	./vectors.pl > vectors.S
++-
++-ULIB = ulib.o usys.o printf.o umalloc.o
++-
++-_%: %.o $(ULIB)
++-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
++-	$(OBJDUMP) -S $@ > $*.asm
++-	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
++-
++-_forktest: forktest.o $(ULIB)
++-	# forktest has less library code linked in - needs to be small
++-	# in order to be able to max out the proc table.
++-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
++-	$(OBJDUMP) -S _forktest > forktest.asm
++-
++-mkfs: mkfs.c fs.h
++-	gcc -Werror -Wall -o mkfs mkfs.c
++-
++-# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
++-# that disk image changes after first build are persistent until clean.  More
++-# details:
++-# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
++-.PRECIOUS: %.o
++-
++-UPROGS=\
++-	_cat\
++-	_echo\
++-	_forktest\
++-	_grep\
++-	_init\
++-	_kill\
++-	_ln\
++-	_ls\
++-	_mkdir\
++-	_rm\
++-	_sh\
++-	_stressfs\
++-	_usertests\
++-	_wc\
++-	_zombie\
++-	_lab1\
++-
++-fs.img: mkfs README $(UPROGS)
++-	./mkfs fs.img README $(UPROGS)
++-
++--include *.d
++-
++-clean: 
++-	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
++-	*.o *.d *.asm *.sym vectors.S bootblock entryother \
++-	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
++-	xv6memfs.img mkfs .gdbinit \
++-	$(UPROGS)
++-
++-# make a printout
++-FILES = $(shell grep -v '^\#' runoff.list)
++-PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
++-
++-xv6.pdf: $(PRINT)
++-	./runoff
++-	ls -l xv6.pdf
++-
++-print: xv6.pdf
++-
++-# run in emulators
++-
++-bochs : fs.img xv6.img
++-	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
++-	bochs -q
++-
++-# try to generate a unique GDB port
++-GDBPORT = $(shell expr `id -u` % 5000 + 25000)
++-# QEMU's gdb stub command line changed in 0.11
++-QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
++-	then echo "-gdb tcp::$(GDBPORT)"; \
++-	else echo "-s -p $(GDBPORT)"; fi)
++-ifndef CPUS
++-CPUS := 2
++-endif
++-QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
++-
++-qemu: fs.img xv6.img
++-	$(QEMU) -serial mon:stdio $(QEMUOPTS)
++-
++-qemu-memfs: xv6memfs.img
++-	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
++-
++-qemu-nox: fs.img xv6.img
++-	$(QEMU) -nographic $(QEMUOPTS)
++-
++-.gdbinit: .gdbinit.tmpl
++-	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
++-
++-qemu-gdb: fs.img xv6.img .gdbinit
++-	@echo "*** Now run 'gdb'." 1>&2
++-	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
++-
++-qemu-nox-gdb: fs.img xv6.img .gdbinit
++-	@echo "*** Now run 'gdb'." 1>&2
++-	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
++-
++-# CUT HERE
++-# prepare dist for students
++-# after running make dist, probably want to
++-# rename it to rev0 or rev1 or so on and then
++-# check in that version.
++-
++-EXTRA=\
++-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
++-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
++-	printf.c umalloc.c\
++-	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
++-	.gdbinit.tmpl gdbutil\
++-
++-dist:
++-	rm -rf dist
++-	mkdir dist
++-	for i in $(FILES); \
++-	do \
++-		grep -v PAGEBREAK $$i >dist/$$i; \
++-	done
++-	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
++-	echo >dist/runoff.spec
++-	cp $(EXTRA) dist
++-
++-dist-test:
++-	rm -rf dist
++-	make dist
++-	rm -rf dist-test
++-	mkdir dist-test
++-	cp dist/* dist-test
++-	cd dist-test; $(MAKE) print
++-	cd dist-test; $(MAKE) bochs || true
++-	cd dist-test; $(MAKE) qemu
++-
++-# update this rule (change rev#) when it is time to
++-# make a new revision.
++-tar:
++-	rm -rf /tmp/xv6
++-	mkdir -p /tmp/xv6
++-	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
++-	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
++-
++-.PHONY: dist-test dist
++diff --git a/Notes b/Notes
++deleted file mode 100644
++index 74c8aea..0000000
++--- a/Notes
+++++ /dev/null
++@@ -1,123 +0,0 @@
++-bochs 2.2.6:
++-./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae --disable-reset-on-triple-fault
++-bochs CVS after 2.2.6:
++-./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae 
++-
++-bootmain.c doesn't work right if the ELF sections aren't
++-sector-aligned. so you can't use ld -N. and the sections may also need
++-to be non-zero length, only really matters for tiny "kernels".
++-
++-kernel loaded at 1 megabyte. stack same place that bootasm.S left it.
++-
++-kinit() should find real mem size
++-  and rescue useable memory below 1 meg
++-
++-no paging, no use of page table hardware, just segments
++-
++-no user area: no magic kernel stack mapping
++-  so no copying of kernel stack during fork
++-  though there is a kernel stack page for each process
++-
++-no kernel malloc(), just kalloc() for user core
++-
++-user pointers aren't valid in the kernel
++-
++-are interrupts turned on in the kernel? yes.
++-
++-pass curproc explicitly, or implicit from cpu #?
++-  e.g. argument to newproc()?
++-  hmm, you need a global curproc[cpu] for trap() &c
++-
++-no stack expansion
++-
++-test running out of memory, process slots
++-
++-we can't really use a separate stack segment, since stack addresses
++-need to work correctly as ordinary pointers. the same may be true of
++-data vs text. how can we have a gap between data and stack, so that
++-both can grow, without committing 4GB of physical memory? does this
++-mean we need paging?
++-
++-perhaps have fixed-size stack, put it in the data segment?
++-
++-oops, if kernel stack is in contiguous user phys mem, then moving
++-users' memory (e.g. to expand it) will wreck any pointers into the
++-kernel stack.
++-
++-do we need to set fs and gs? so user processes can't abuse them?
++-
++-setupsegs() may modify current segment table, is that legal?
++-
++-trap() ought to lgdt on return, since currently only done in swtch()
++-
++-protect hardware interrupt vectors from user INT instructions?
++-
++-test out-of-fd cases for creating pipe.
++-test pipe reader closes then write
++-test two readers, two writers.
++-test children being inherited by grandparent &c
++-
++-some sleep()s should be interruptible by kill()
++-
++-locks
++-  init_lock
++-    sequences CPU startup
++-  proc_table_lock
++-    also protects next_pid
++-  per-fd lock *just* protects count read-modify-write
++-    also maybe freeness?
++-  memory allocator
++-  printf
++-
++-in general, the table locks protect both free-ness and
++-  public variables of table elements
++-  in many cases you can use table elements w/o a lock
++-  e.g. if you are the process, or you are using an fd
++-
++-lock order
++-  per-pipe lock
++-  proc_table_lock fd_table_lock kalloc_lock
++-  console_lock
++-
++-do you have to be holding the mutex in order to call wakeup()? yes
++-
++-device interrupts don't clear FL_IF
++-  so a recursive timer interrupt is possible
++-
++-what does inode->busy mean?
++-  might be held across disk reads
++-  no-one is allowed to do anything to the inode
++-  protected by inode_table_lock
++-inode->count counts in-memory pointers to the struct
++-  prevents inode[] element from being re-used
++-  protected by inode_table_lock
++-
++-blocks and inodes have ad-hoc sleep-locks
++-  provide a single mechanism?
++-
++-kalloc() can return 0; do callers handle this right?
++-
++-test: one process unlinks a file while another links to it
++-test: one process opens a file while another deletes it
++-test: deadlock d/.. vs ../d, two processes.
++-test: dup() shared fd->off
++-test: does echo foo > x truncate x?
++-
++-sh: ioredirection incorrect now we have pipes
++-sh: chain of pipes won't work, also ugly that parent closes fdarray entries too
++-sh: dynamic memory allocation?
++-sh: should sh support ; () &
++-sh: stop stdin on ctrl-d (for cat > y)
++-
++-really should have bdwrite() for file content
++-  and make some inode updates async
++-  so soft updates make sense
++-
++-disk scheduling
++-echo foo > bar should truncate bar
++-  so O_CREATE should not truncate
++-  but O_TRUNC should
++-
++-make it work on a real machine
++-release before acquire at end of sleep?
++-check 2nd disk (i.e. if not in .bochsrc)
++diff --git a/README b/README
++deleted file mode 100644
++index 923e0a4..0000000
++--- a/README
+++++ /dev/null
++@@ -1,51 +0,0 @@
++-NOTE: we have stopped maintaining the x86 version of xv6, and switched
++-our efforts to the RISC-V version
++-(https://github.com/mit-pdos/xv6-riscv.git)
++-
++-xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
++-Version 6 (v6).  xv6 loosely follows the structure and style of v6,
++-but is implemented for a modern x86-based multiprocessor using ANSI C.
++-
++-ACKNOWLEDGMENTS
++-
++-xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
++-to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
++-2000)). See also https://pdos.csail.mit.edu/6.828/, which
++-provides pointers to on-line resources for v6.
++-
++-xv6 borrows code from the following sources:
++-    JOS (asm.h, elf.h, mmu.h, bootasm.S, ide.c, console.c, and others)
++-    Plan 9 (entryother.S, mp.h, mp.c, lapic.c)
++-    FreeBSD (ioapic.c)
++-    NetBSD (console.c)
++-
++-The following people have made contributions: Russ Cox (context switching,
++-locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
++-Clements.
++-
++-We are also grateful for the bug reports and patches contributed by Silas
++-Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,
++-Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter
++-Froehlich, Yakir Goaron,Shivam Handa, Bryan Henry, Jim Huang, Alexander
++-Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller, Eddie Kohler, Austin
++-Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi
++-Merimovich, Mark Morrissey, mtasm, Joel Nider, Greg Price, Ayan Shafqat,
++-Eldar Sehayek, Yongming Shen, Cam Tenny, tyfkda, Rafael Ubal, Warren
++-Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
++-Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang Wei.
++-
++-The code in the files that constitute xv6 is
++-Copyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.
++-
++-ERROR REPORTS
++-
++-We don't process error reports (see note on top of this file).
++-
++-BUILDING AND RUNNING XV6
++-
++-To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
++-"make". On non-x86 or non-ELF machines (like OS X, even on x86), you
++-will need to install a cross-compiler gcc suite capable of producing
++-x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
++-Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
++-simulator and run "make qemu".
++\ No newline at end of file
++diff --git a/TRICKS b/TRICKS
++deleted file mode 100644
++index 8d1439f..0000000
++--- a/TRICKS
+++++ /dev/null
++@@ -1,140 +0,0 @@
++-This file lists subtle things that might not be commented 
++-as well as they should be in the source code and that
++-might be worth pointing out in a longer explanation or in class.
++-
++----
++-
++-[2009/07/12: No longer relevant; forkret1 changed
++-and this is now cleaner.]
++-
++-forkret1 in trapasm.S is called with a tf argument.
++-In order to use it, forkret1 copies the tf pointer into
++-%esp and then jumps to trapret, which pops the 
++-register state out of the trap frame.  If an interrupt
++-came in between the mov tf, %esp and the iret that
++-goes back out to user space, the interrupt stack frame
++-would end up scribbling over the tf and whatever memory
++-lay under it.
++-
++-Why is this safe?  Because forkret1 is only called
++-the first time a process returns to user space, and
++-at that point, cp->tf is set to point to a trap frame
++-constructed at the top of cp's kernel stack.  So tf 
++-*is* a valid %esp that can hold interrupt state.
++-
++-If other tf's were used in forkret1, we could add
++-a cli before the mov tf, %esp.
++-
++----
++-
++-In pushcli, must cli() no matter what.  It is not safe to do
++-
++-  if(cpus[cpu()].ncli == 0)
++-    cli();
++-  cpus[cpu()].ncli++;
++-
++-because if interrupts are off then we might call cpu(), get
++-rescheduled to a different cpu, look at cpus[oldcpu].ncli,
++-and wrongly decide not to disable interrupts on the new cpu.
++-
++-Instead do 
++-
++-  cli();
++-  cpus[cpu()].ncli++;
++-
++-always.
++-
++----
++-
++-There is a (harmless) race in pushcli, which does
++-
++-	eflags = readeflags();
++-	cli();
++-	if(c->ncli++ == 0)
++-		c->intena = eflags & FL_IF;
++-
++-Consider a bottom-level pushcli.  
++-If interrupts are disabled already, then the right thing
++-happens: read_eflags finds that FL_IF is not set,
++-and intena = 0.  If interrupts are enabled, then
++-it is less clear that the right thing happens:
++-the readeflags can execute, then the process
++-can get preempted and rescheduled on another cpu,
++-and then once it starts running, perhaps with 
++-interrupts disabled (can happen since the scheduler
++-only enables interrupts once per scheduling loop,
++-not every time it schedules a process), it will 
++-incorrectly record that interrupts *were* enabled.
++-This doesn't matter, because if it was safe to be
++-running with interrupts enabled before the context
++-switch, it is still safe (and arguably more correct)
++-to run with them enabled after the context switch too.
++-
++-In fact it would be safe if scheduler always set
++-	c->intena = 1;
++-before calling swtch, and perhaps it should.
++-
++----
++-
++-The x86's processor-ordering memory model 
++-matches spin locks well, so no explicit memory
++-synchronization instructions are required in
++-acquire and release.  
++-
++-Consider two sequences of code on different CPUs:
++-
++-CPU0
++-A;
++-release(lk);
++-
++-and
++-
++-CPU1
++-acquire(lk);
++-B;
++-
++-We want to make sure that:
++-  - all reads in B see the effects of writes in A.
++-  - all reads in A do *not* see the effects of writes in B.
++- 
++-The x86 guarantees that writes in A will go out
++-to memory before the write of lk->locked = 0 in 
++-release(lk).  It further guarantees that CPU1 
++-will observe CPU0's write of lk->locked = 0 only
++-after observing the earlier writes by CPU0.
++-So any reads in B are guaranteed to observe the
++-effects of writes in A.
++-
++-According to the Intel manual behavior spec, the
++-second condition requires a serialization instruction
++-in release, to avoid reads in A happening after giving
++-up lk.  No Intel SMP processor in existence actually
++-moves reads down after writes, but the language in
++-the spec allows it.  There is no telling whether future
++-processors will need it.
++-
++----
++-
++-The code in fork needs to read np->pid before
++-setting np->state to RUNNABLE.  The following
++-is not a correct way to do this:
++-
++-	int
++-	fork(void)
++-	{
++-	  ...
++-	  np->state = RUNNABLE;
++-	  return np->pid; // oops
++-	}
++-
++-After setting np->state to RUNNABLE, some other CPU
++-might run the process, it might exit, and then it might
++-get reused for a different process (with a new pid), all
++-before the return statement.  So it's not safe to just
++-"return np->pid". Even saving a copy of np->pid before
++-setting np->state isn't safe, since the compiler is
++-allowed to re-order statements.
++-
++-The real code saves a copy of np->pid, then acquires a lock
++-around the write to np->state. The acquire() prevents the
++-compiler from re-ordering.
++diff --git a/asm.h b/asm.h
++deleted file mode 100644
++index b8a7353..0000000
++--- a/asm.h
+++++ /dev/null
++@@ -1,18 +0,0 @@
++-//
++-// assembler macros to create x86 segments
++-//
++-
++-#define SEG_NULLASM                                             \
++-        .word 0, 0;                                             \
++-        .byte 0, 0, 0, 0
++-
++-// The 0xC0 means the limit is in 4096-byte units
++-// and (for executable segments) 32-bit mode.
++-#define SEG_ASM(type,base,lim)                                  \
++-        .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
++-        .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
++-                (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
++-
++-#define STA_X     0x8       // Executable segment
++-#define STA_W     0x2       // Writeable (non-executable segments)
++-#define STA_R     0x2       // Readable (executable segments)
++diff --git a/bio.c b/bio.c
++deleted file mode 100644
++index a45ff3e..0000000
++--- a/bio.c
+++++ /dev/null
++@@ -1,144 +0,0 @@
++-// Buffer cache.
++-//
++-// The buffer cache is a linked list of buf structures holding
++-// cached copies of disk block contents.  Caching disk blocks
++-// in memory reduces the number of disk reads and also provides
++-// a synchronization point for disk blocks used by multiple processes.
++-//
++-// Interface:
++-// * To get a buffer for a particular disk block, call bread.
++-// * After changing buffer data, call bwrite to write it to disk.
++-// * When done with the buffer, call brelse.
++-// * Do not use the buffer after calling brelse.
++-// * Only one process at a time can use a buffer,
++-//     so do not keep them longer than necessary.
++-//
++-// The implementation uses two state flags internally:
++-// * B_VALID: the buffer data has been read from the disk.
++-// * B_DIRTY: the buffer data has been modified
++-//     and needs to be written to disk.
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "spinlock.h"
++-#include "sleeplock.h"
++-#include "fs.h"
++-#include "buf.h"
++-
++-struct {
++-  struct spinlock lock;
++-  struct buf buf[NBUF];
++-
++-  // Linked list of all buffers, through prev/next.
++-  // head.next is most recently used.
++-  struct buf head;
++-} bcache;
++-
++-void
++-binit(void)
++-{
++-  struct buf *b;
++-
++-  initlock(&bcache.lock, "bcache");
++-
++-//PAGEBREAK!
++-  // Create linked list of buffers
++-  bcache.head.prev = &bcache.head;
++-  bcache.head.next = &bcache.head;
++-  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
++-    b->next = bcache.head.next;
++-    b->prev = &bcache.head;
++-    initsleeplock(&b->lock, "buffer");
++-    bcache.head.next->prev = b;
++-    bcache.head.next = b;
++-  }
++-}
++-
++-// Look through buffer cache for block on device dev.
++-// If not found, allocate a buffer.
++-// In either case, return locked buffer.
++-static struct buf*
++-bget(uint dev, uint blockno)
++-{
++-  struct buf *b;
++-
++-  acquire(&bcache.lock);
++-
++-  // Is the block already cached?
++-  for(b = bcache.head.next; b != &bcache.head; b = b->next){
++-    if(b->dev == dev && b->blockno == blockno){
++-      b->refcnt++;
++-      release(&bcache.lock);
++-      acquiresleep(&b->lock);
++-      return b;
++-    }
++-  }
++-
++-  // Not cached; recycle an unused buffer.
++-  // Even if refcnt==0, B_DIRTY indicates a buffer is in use
++-  // because log.c has modified it but not yet committed it.
++-  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
++-    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
++-      b->dev = dev;
++-      b->blockno = blockno;
++-      b->flags = 0;
++-      b->refcnt = 1;
++-      release(&bcache.lock);
++-      acquiresleep(&b->lock);
++-      return b;
++-    }
++-  }
++-  panic("bget: no buffers");
++-}
++-
++-// Return a locked buf with the contents of the indicated block.
++-struct buf*
++-bread(uint dev, uint blockno)
++-{
++-  struct buf *b;
++-
++-  b = bget(dev, blockno);
++-  if((b->flags & B_VALID) == 0) {
++-    iderw(b);
++-  }
++-  return b;
++-}
++-
++-// Write b's contents to disk.  Must be locked.
++-void
++-bwrite(struct buf *b)
++-{
++-  if(!holdingsleep(&b->lock))
++-    panic("bwrite");
++-  b->flags |= B_DIRTY;
++-  iderw(b);
++-}
++-
++-// Release a locked buffer.
++-// Move to the head of the MRU list.
++-void
++-brelse(struct buf *b)
++-{
++-  if(!holdingsleep(&b->lock))
++-    panic("brelse");
++-
++-  releasesleep(&b->lock);
++-
++-  acquire(&bcache.lock);
++-  b->refcnt--;
++-  if (b->refcnt == 0) {
++-    // no one is waiting for it.
++-    b->next->prev = b->prev;
++-    b->prev->next = b->next;
++-    b->next = bcache.head.next;
++-    b->prev = &bcache.head;
++-    bcache.head.next->prev = b;
++-    bcache.head.next = b;
++-  }
++-  
++-  release(&bcache.lock);
++-}
++-//PAGEBREAK!
++-// Blank page.
++-
++diff --git a/bootasm.S b/bootasm.S
++deleted file mode 100644
++index 257867c..0000000
++--- a/bootasm.S
+++++ /dev/null
++@@ -1,88 +0,0 @@
++-#include "asm.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-
++-# Start the first CPU: switch to 32-bit protected mode, jump into C.
++-# The BIOS loads this code from the first sector of the hard disk into
++-# memory at physical address 0x7c00 and starts executing in real mode
++-# with %cs=0 %ip=7c00.
++-
++-.code16                       # Assemble for 16-bit mode
++-.globl start
++-start:
++-  cli                         # BIOS enabled interrupts; disable
++-
++-  # Zero data segment registers DS, ES, and SS.
++-  xorw    %ax,%ax             # Set %ax to zero
++-  movw    %ax,%ds             # -> Data Segment
++-  movw    %ax,%es             # -> Extra Segment
++-  movw    %ax,%ss             # -> Stack Segment
++-
++-  # Physical address line A20 is tied to zero so that the first PCs 
++-  # with 2 MB would run software that assumed 1 MB.  Undo that.
++-seta20.1:
++-  inb     $0x64,%al               # Wait for not busy
++-  testb   $0x2,%al
++-  jnz     seta20.1
++-
++-  movb    $0xd1,%al               # 0xd1 -> port 0x64
++-  outb    %al,$0x64
++-
++-seta20.2:
++-  inb     $0x64,%al               # Wait for not busy
++-  testb   $0x2,%al
++-  jnz     seta20.2
++-
++-  movb    $0xdf,%al               # 0xdf -> port 0x60
++-  outb    %al,$0x60
++-
++-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
++-  # virtual addresses map directly to physical addresses so that the
++-  # effective memory map doesn't change during the transition.
++-  lgdt    gdtdesc
++-  movl    %cr0, %eax
++-  orl     $CR0_PE, %eax
++-  movl    %eax, %cr0
++-
++-//PAGEBREAK!
++-  # Complete the transition to 32-bit protected mode by using a long jmp
++-  # to reload %cs and %eip.  The segment descriptors are set up with no
++-  # translation, so that the mapping is still the identity mapping.
++-  ljmp    $(SEG_KCODE<<3), $start32
++-
++-.code32  # Tell assembler to generate 32-bit code now.
++-start32:
++-  # Set up the protected-mode data segment registers
++-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
++-  movw    %ax, %ds                # -> DS: Data Segment
++-  movw    %ax, %es                # -> ES: Extra Segment
++-  movw    %ax, %ss                # -> SS: Stack Segment
++-  movw    $0, %ax                 # Zero segments not ready for use
++-  movw    %ax, %fs                # -> FS
++-  movw    %ax, %gs                # -> GS
++-
++-  # Set up the stack pointer and call into C.
++-  movl    $start, %esp
++-  call    bootmain
++-
++-  # If bootmain returns (it shouldn't), trigger a Bochs
++-  # breakpoint if running under Bochs, then loop.
++-  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
++-  movw    %ax, %dx
++-  outw    %ax, %dx
++-  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
++-  outw    %ax, %dx
++-spin:
++-  jmp     spin
++-
++-# Bootstrap GDT
++-.p2align 2                                # force 4 byte alignment
++-gdt:
++-  SEG_NULLASM                             # null seg
++-  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg
++-  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg
++-
++-gdtdesc:
++-  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
++-  .long   gdt                             # address gdt
++-
++diff --git a/bootmain.c b/bootmain.c
++deleted file mode 100644
++index 1f20e5b..0000000
++--- a/bootmain.c
+++++ /dev/null
++@@ -1,96 +0,0 @@
++-// Boot loader.
++-//
++-// Part of the boot block, along with bootasm.S, which calls bootmain().
++-// bootasm.S has put the processor into protected 32-bit mode.
++-// bootmain() loads an ELF kernel image from the disk starting at
++-// sector 1 and then jumps to the kernel entry routine.
++-
++-#include "types.h"
++-#include "elf.h"
++-#include "x86.h"
++-#include "memlayout.h"
++-
++-#define SECTSIZE  512
++-
++-void readseg(uchar*, uint, uint);
++-
++-void
++-bootmain(void)
++-{
++-  struct elfhdr *elf;
++-  struct proghdr *ph, *eph;
++-  void (*entry)(void);
++-  uchar* pa;
++-
++-  elf = (struct elfhdr*)0x10000;  // scratch space
++-
++-  // Read 1st page off disk
++-  readseg((uchar*)elf, 4096, 0);
++-
++-  // Is this an ELF executable?
++-  if(elf->magic != ELF_MAGIC)
++-    return;  // let bootasm.S handle error
++-
++-  // Load each program segment (ignores ph flags).
++-  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
++-  eph = ph + elf->phnum;
++-  for(; ph < eph; ph++){
++-    pa = (uchar*)ph->paddr;
++-    readseg(pa, ph->filesz, ph->off);
++-    if(ph->memsz > ph->filesz)
++-      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
++-  }
++-
++-  // Call the entry point from the ELF header.
++-  // Does not return!
++-  entry = (void(*)(void))(elf->entry);
++-  entry();
++-}
++-
++-void
++-waitdisk(void)
++-{
++-  // Wait for disk ready.
++-  while((inb(0x1F7) & 0xC0) != 0x40)
++-    ;
++-}
++-
++-// Read a single sector at offset into dst.
++-void
++-readsect(void *dst, uint offset)
++-{
++-  // Issue command.
++-  waitdisk();
++-  outb(0x1F2, 1);   // count = 1
++-  outb(0x1F3, offset);
++-  outb(0x1F4, offset >> 8);
++-  outb(0x1F5, offset >> 16);
++-  outb(0x1F6, (offset >> 24) | 0xE0);
++-  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
++-
++-  // Read data.
++-  waitdisk();
++-  insl(0x1F0, dst, SECTSIZE/4);
++-}
++-
++-// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
++-// Might copy more than asked.
++-void
++-readseg(uchar* pa, uint count, uint offset)
++-{
++-  uchar* epa;
++-
++-  epa = pa + count;
++-
++-  // Round down to sector boundary.
++-  pa -= offset % SECTSIZE;
++-
++-  // Translate from bytes to sectors; kernel starts at sector 1.
++-  offset = (offset / SECTSIZE) + 1;
++-
++-  // If this is too slow, we could read lots of sectors at a time.
++-  // We'd write more to memory than asked, but it doesn't matter --
++-  // we load in increasing order.
++-  for(; pa < epa; pa += SECTSIZE, offset++)
++-    readsect(pa, offset);
++-}
++diff --git a/buf.h b/buf.h
++deleted file mode 100644
++index 3266495..0000000
++--- a/buf.h
+++++ /dev/null
++@@ -1,14 +0,0 @@
++-struct buf {
++-  int flags;
++-  uint dev;
++-  uint blockno;
++-  struct sleeplock lock;
++-  uint refcnt;
++-  struct buf *prev; // LRU cache list
++-  struct buf *next;
++-  struct buf *qnext; // disk queue
++-  uchar data[BSIZE];
++-};
++-#define B_VALID 0x2  // buffer has been read from disk
++-#define B_DIRTY 0x4  // buffer needs to be written to disk
++-
++diff --git a/cat.c b/cat.c
++deleted file mode 100644
++index 68b1b8d..0000000
++--- a/cat.c
+++++ /dev/null
++@@ -1,43 +0,0 @@
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-
++-char buf[512];
++-
++-void
++-cat(int fd)
++-{
++-  int n;
++-
++-  while((n = read(fd, buf, sizeof(buf))) > 0) {
++-    if (write(1, buf, n) != n) {
++-      printf(1, "cat: write error\n");
++-      exit(3);
++-    }
++-  }
++-  if(n < 0){
++-    printf(1, "cat: read error\n");
++-    exit(4);
++-  }
++-}
++-
++-int
++-main(int argc, char *argv[])
++-{
++-  int fd, i;
++-
++-  if(argc <= 1){
++-    cat(0);
++-    exit(1);
++-  }
++-
++-  for(i = 1; i < argc; i++){
++-    if((fd = open(argv[i], 0)) < 0){
++-      printf(1, "cat: cannot open %s\n", argv[i]);
++-      exit(2);
++-    }
++-    cat(fd);
++-    close(fd);
++-  }
++-  exit(0);
++-}
++diff --git a/code.diff b/code.diff
++deleted file mode 100644
++index c889659..0000000
++--- a/code.diff
+++++ /dev/null
++@@ -1,2919 +0,0 @@
++-diff --git a/Makefile b/Makefile
++-index 09d790c..04d74d5 100644
++---- a/Makefile
++-+++ b/Makefile
++-@@ -181,6 +181,7 @@ UPROGS=\
++- 	_usertests\
++- 	_wc\
++- 	_zombie\
++-+	_lab1\
++- 
++- fs.img: mkfs README $(UPROGS)
++- 	./mkfs fs.img README $(UPROGS)
++-diff --git a/cat.c b/cat.c
++-index 5ddc820..68b1b8d 100644
++---- a/cat.c
++-+++ b/cat.c
++-@@ -12,12 +12,12 @@ cat(int fd)
++-   while((n = read(fd, buf, sizeof(buf))) > 0) {
++-     if (write(1, buf, n) != n) {
++-       printf(1, "cat: write error\n");
++--      exit();
++-+      exit(3);
++-     }
++-   }
++-   if(n < 0){
++-     printf(1, "cat: read error\n");
++--    exit();
++-+    exit(4);
++-   }
++- }
++- 
++-@@ -28,16 +28,16 @@ main(int argc, char *argv[])
++- 
++-   if(argc <= 1){
++-     cat(0);
++--    exit();
++-+    exit(1);
++-   }
++- 
++-   for(i = 1; i < argc; i++){
++-     if((fd = open(argv[i], 0)) < 0){
++-       printf(1, "cat: cannot open %s\n", argv[i]);
++--      exit();
++-+      exit(2);
++-     }
++-     cat(fd);
++-     close(fd);
++-   }
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/cuth b/cuth
++-old mode 100755
++-new mode 100644
++-diff --git a/defs.h b/defs.h
++-index 82fb982..d1934ca 100644
++---- a/defs.h
++-+++ b/defs.h
++-@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
++- //PAGEBREAK: 16
++- // proc.c
++- int             cpuid(void);
++--void            exit(void);
++-+void            exit(int status);
++- int             fork(void);
++- int             growproc(int);
++- int             kill(int);
++-@@ -117,7 +117,8 @@ void            sched(void);
++- void            setproc(struct proc*);
++- void            sleep(void*, struct spinlock*);
++- void            userinit(void);
++--int             wait(void);
++-+int             wait(int* status);
++-+int             waitpid(int pid, int* status, int options);
++- void            wakeup(void*);
++- void            yield(void);
++- 
++-diff --git a/dot-bochsrc b/dot-bochsrc
++-old mode 100755
++-new mode 100644
++-diff --git a/echo.c b/echo.c
++-index 806dee0..eed68a0 100644
++---- a/echo.c
++-+++ b/echo.c
++-@@ -9,5 +9,5 @@ main(int argc, char *argv[])
++- 
++-   for(i = 1; i < argc; i++)
++-     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/forktest.c b/forktest.c
++-index 8bc984d..a4b35ed 100644
++---- a/forktest.c
++-+++ b/forktest.c
++-@@ -25,24 +25,24 @@ forktest(void)
++-     if(pid < 0)
++-       break;
++-     if(pid == 0)
++--      exit();
++-+      exit(4);
++-   }
++- 
++-   if(n == N){
++-     printf(1, "fork claimed to work N times!\n", N);
++--    exit();
++-+    exit(3);
++-   }
++- 
++-   for(; n > 0; n--){
++--    if(wait() < 0){
++-+    if(wait(NULL) < 0){
++-       printf(1, "wait stopped early\n");
++--      exit();
++-+      exit(2);
++-     }
++-   }
++- 
++--  if(wait() != -1){
++-+  if(wait(NULL) != -1){
++-     printf(1, "wait got too many\n");
++--    exit();
++-+    exit(1);
++-   }
++- 
++-   printf(1, "fork test OK\n");
++-@@ -52,5 +52,5 @@ int
++- main(void)
++- {
++-   forktest();
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/grep.c b/grep.c
++-index adc4835..4be3256 100644
++---- a/grep.c
++-+++ b/grep.c
++-@@ -43,24 +43,24 @@ main(int argc, char *argv[])
++- 
++-   if(argc <= 1){
++-     printf(2, "usage: grep pattern [file ...]\n");
++--    exit();
++-+    exit(1);
++-   }
++-   pattern = argv[1];
++- 
++-   if(argc <= 2){
++-     grep(pattern, 0);
++--    exit();
++-+    exit(2);
++-   }
++- 
++-   for(i = 2; i < argc; i++){
++-     if((fd = open(argv[i], 0)) < 0){
++-       printf(1, "grep: cannot open %s\n", argv[i]);
++--      exit();
++-+      exit(3);
++-     }
++-     grep(pattern, fd);
++-     close(fd);
++-   }
++--  exit();
++-+  exit(0);
++- }
++- 
++- // Regexp matcher from Kernighan & Pike,
++-diff --git a/init.c b/init.c
++-index 046b551..bc6547f 100644
++---- a/init.c
++-+++ b/init.c
++-@@ -24,14 +24,14 @@ main(void)
++-     pid = fork();
++-     if(pid < 0){
++-       printf(1, "init: fork failed\n");
++--      exit();
++-+      exit(2);
++-     }
++-     if(pid == 0){
++-       exec("sh", argv);
++-       printf(1, "init: exec sh failed\n");
++--      exit();
++-+      exit(1);
++-     }
++--    while((wpid=wait()) >= 0 && wpid != pid)
++-+    while((wpid=wait(NULL)) >= 0 && wpid != pid)
++-       printf(1, "zombie!\n");
++-   }
++- }
++-diff --git a/kill.c b/kill.c
++-index 364f6af..875916c 100644
++---- a/kill.c
++-+++ b/kill.c
++-@@ -9,9 +9,9 @@ main(int argc, char **argv)
++- 
++-   if(argc < 2){
++-     printf(2, "usage: kill pid...\n");
++--    exit();
++-+    exit(1);
++-   }
++-   for(i=1; i<argc; i++)
++-     kill(atoi(argv[i]));
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/lab1.c b/lab1.c
++-index 89668ce..2192a52 100644
++---- a/lab1.c
++-+++ b/lab1.c
++-@@ -25,7 +25,7 @@ int main(int argc, char **argv) {
++-     if(pid > 0)
++-     {
++-         waitpid(pid, NULL, 0);
++--        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);
++-+        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
++-         exit(0);
++-     }
++- 
++-diff --git a/ln.c b/ln.c
++-index cf8a64e..fb17c3b 100644
++---- a/ln.c
++-+++ b/ln.c
++-@@ -7,9 +7,9 @@ main(int argc, char *argv[])
++- {
++-   if(argc != 3){
++-     printf(2, "Usage: ln old new\n");
++--    exit();
++-+    exit(1);
++-   }
++-   if(link(argv[1], argv[2]) < 0)
++-     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/ls.c b/ls.c
++-index 2862913..6bf943b 100644
++---- a/ls.c
++-+++ b/ls.c
++-@@ -77,9 +77,9 @@ main(int argc, char *argv[])
++- 
++-   if(argc < 2){
++-     ls(".");
++--    exit();
++-+    exit(1);
++-   }
++-   for(i=1; i<argc; i++)
++-     ls(argv[i]);
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/mkdir.c b/mkdir.c
++-index 6e4c954..2d90781 100644
++---- a/mkdir.c
++-+++ b/mkdir.c
++-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
++- 
++-   if(argc < 2){
++-     printf(2, "Usage: mkdir files...\n");
++--    exit();
++-+    exit(1);
++-   }
++- 
++-   for(i = 1; i < argc; i++){
++-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
++-     }
++-   }
++- 
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/pr.pl b/pr.pl
++-old mode 100755
++-new mode 100644
++-diff --git a/printpcs b/printpcs
++-old mode 100755
++-new mode 100644
++-diff --git a/proc.c b/proc.c
++-index 806b1b1..84b335f 100644
++---- a/proc.c
++-+++ b/proc.c
++-@@ -1,3 +1,5 @@
++-+#include <stddef.h>
++-+
++- #include "types.h"
++- #include "defs.h"
++- #include "param.h"
++-@@ -8,61 +10,61 @@
++- #include "spinlock.h"
++- 
++- struct {
++--  struct spinlock lock;
++--  struct proc proc[NPROC];
++-+    struct spinlock lock;
++-+    struct proc proc[NPROC];
++- } ptable;
++- 
++- static struct proc *initproc;
++- 
++- int nextpid = 1;
++-+
++- extern void forkret(void);
++-+
++- extern void trapret(void);
++- 
++- static void wakeup1(void *chan);
++- 
++- void
++--pinit(void)
++--{
++--  initlock(&ptable.lock, "ptable");
++-+pinit(void) {
++-+    initlock(&ptable.lock, "ptable");
++- }
++- 
++- // Must be called with interrupts disabled
++- int
++- cpuid() {
++--  return mycpu()-cpus;
++-+    return mycpu() - cpus;
++- }
++- 
++- // Must be called with interrupts disabled to avoid the caller being
++- // rescheduled between reading lapicid and running through the loop.
++--struct cpu*
++--mycpu(void)
++--{
++--  int apicid, i;
++--  
++--  if(readeflags()&FL_IF)
++--    panic("mycpu called with interrupts enabled\n");
++--  
++--  apicid = lapicid();
++--  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
++--  // a reverse map, or reserve a register to store &cpus[i].
++--  for (i = 0; i < ncpu; ++i) {
++--    if (cpus[i].apicid == apicid)
++--      return &cpus[i];
++--  }
++--  panic("unknown apicid\n");
++-+struct cpu *
++-+mycpu(void) {
++-+    int apicid, i;
++-+
++-+    if (readeflags() & FL_IF)
++-+        panic("mycpu called with interrupts enabled\n");
++-+
++-+    apicid = lapicid();
++-+    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
++-+    // a reverse map, or reserve a register to store &cpus[i].
++-+    for (i = 0; i < ncpu; ++i) {
++-+        if (cpus[i].apicid == apicid)
++-+            return &cpus[i];
++-+    }
++-+    panic("unknown apicid\n");
++- }
++- 
++- // Disable interrupts so that we are not rescheduled
++- // while reading proc from the cpu structure
++--struct proc*
++-+struct proc *
++- myproc(void) {
++--  struct cpu *c;
++--  struct proc *p;
++--  pushcli();
++--  c = mycpu();
++--  p = c->proc;
++--  popcli();
++--  return p;
++-+    struct cpu *c;
++-+    struct proc *p;
++-+    pushcli();
++-+    c = mycpu();
++-+    p = c->proc;
++-+    popcli();
++-+    return p;
++- }
++- 
++- //PAGEBREAK: 32
++-@@ -70,245 +72,295 @@ myproc(void) {
++- // If found, change state to EMBRYO and initialize
++- // state required to run in the kernel.
++- // Otherwise return 0.
++--static struct proc*
++--allocproc(void)
++--{
++--  struct proc *p;
++--  char *sp;
++-+static struct proc *
++-+allocproc(void) {
++-+    struct proc *p;
++-+    char *sp;
++- 
++--  acquire(&ptable.lock);
++-+    acquire(&ptable.lock);
++- 
++--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++--    if(p->state == UNUSED)
++--      goto found;
++-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++-+        if (p->state == UNUSED)
++-+            goto found;
++- 
++--  release(&ptable.lock);
++--  return 0;
++-+    release(&ptable.lock);
++-+    return 0;
++- 
++--found:
++--  p->state = EMBRYO;
++--  p->pid = nextpid++;
++-+    found:
++-+    p->state = EMBRYO;
++-+    p->pid = nextpid++;
++- 
++--  release(&ptable.lock);
++-+    release(&ptable.lock);
++- 
++--  // Allocate kernel stack.
++--  if((p->kstack = kalloc()) == 0){
++--    p->state = UNUSED;
++--    return 0;
++--  }
++--  sp = p->kstack + KSTACKSIZE;
++-+    // Allocate kernel stack.
++-+    if ((p->kstack = kalloc()) == 0) {
++-+        p->state = UNUSED;
++-+        return 0;
++-+    }
++-+    sp = p->kstack + KSTACKSIZE;
++- 
++--  // Leave room for trap frame.
++--  sp -= sizeof *p->tf;
++--  p->tf = (struct trapframe*)sp;
++-+    // Leave room for trap frame.
++-+    sp -= sizeof *p->tf;
++-+    p->tf = (struct trapframe *) sp;
++- 
++--  // Set up new context to start executing at forkret,
++--  // which returns to trapret.
++--  sp -= 4;
++--  *(uint*)sp = (uint)trapret;
++-+    // Set up new context to start executing at forkret,
++-+    // which returns to trapret.
++-+    sp -= 4;
++-+    *(uint *) sp = (uint) trapret;
++- 
++--  sp -= sizeof *p->context;
++--  p->context = (struct context*)sp;
++--  memset(p->context, 0, sizeof *p->context);
++--  p->context->eip = (uint)forkret;
++-+    sp -= sizeof *p->context;
++-+    p->context = (struct context *) sp;
++-+    memset(p->context, 0, sizeof *p->context);
++-+    p->context->eip = (uint) forkret;
++- 
++--  return p;
++-+    return p;
++- }
++- 
++- //PAGEBREAK: 32
++- // Set up first user process.
++- void
++--userinit(void)
++--{
++--  struct proc *p;
++--  extern char _binary_initcode_start[], _binary_initcode_size[];
++--
++--  p = allocproc();
++--  
++--  initproc = p;
++--  if((p->pgdir = setupkvm()) == 0)
++--    panic("userinit: out of memory?");
++--  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
++--  p->sz = PGSIZE;
++--  memset(p->tf, 0, sizeof(*p->tf));
++--  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
++--  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
++--  p->tf->es = p->tf->ds;
++--  p->tf->ss = p->tf->ds;
++--  p->tf->eflags = FL_IF;
++--  p->tf->esp = PGSIZE;
++--  p->tf->eip = 0;  // beginning of initcode.S
++--
++--  safestrcpy(p->name, "initcode", sizeof(p->name));
++--  p->cwd = namei("/");
++--
++--  // this assignment to p->state lets other cores
++--  // run this process. the acquire forces the above
++--  // writes to be visible, and the lock is also needed
++--  // because the assignment might not be atomic.
++--  acquire(&ptable.lock);
++--
++--  p->state = RUNNABLE;
++--
++--  release(&ptable.lock);
++-+userinit(void) {
++-+    struct proc *p;
++-+    extern char _binary_initcode_start[], _binary_initcode_size[];
++-+
++-+    p = allocproc();
++-+
++-+    initproc = p;
++-+    if ((p->pgdir = setupkvm()) == 0)
++-+        panic("userinit: out of memory?");
++-+    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
++-+    p->sz = PGSIZE;
++-+    memset(p->tf, 0, sizeof(*p->tf));
++-+    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
++-+    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
++-+    p->tf->es = p->tf->ds;
++-+    p->tf->ss = p->tf->ds;
++-+    p->tf->eflags = FL_IF;
++-+    p->tf->esp = PGSIZE;
++-+    p->tf->eip = 0;  // beginning of initcode.S
++-+
++-+    safestrcpy(p->name, "initcode", sizeof(p->name));
++-+    p->cwd = namei("/");
++-+
++-+    // this assignment to p->state lets other cores
++-+    // run this process. the acquire forces the above
++-+    // writes to be visible, and the lock is also needed
++-+    // because the assignment might not be atomic.
++-+    acquire(&ptable.lock);
++-+
++-+    p->state = RUNNABLE;
++-+
++-+    release(&ptable.lock);
++- }
++- 
++- // Grow current process's memory by n bytes.
++- // Return 0 on success, -1 on failure.
++- int
++--growproc(int n)
++--{
++--  uint sz;
++--  struct proc *curproc = myproc();
++--
++--  sz = curproc->sz;
++--  if(n > 0){
++--    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
++--      return -1;
++--  } else if(n < 0){
++--    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
++--      return -1;
++--  }
++--  curproc->sz = sz;
++--  switchuvm(curproc);
++--  return 0;
++-+growproc(int n) {
++-+    uint sz;
++-+    struct proc *curproc = myproc();
++-+
++-+    sz = curproc->sz;
++-+    if (n > 0) {
++-+        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
++-+            return -1;
++-+    } else if (n < 0) {
++-+        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
++-+            return -1;
++-+    }
++-+    curproc->sz = sz;
++-+    switchuvm(curproc);
++-+    return 0;
++- }
++- 
++- // Create a new process copying p as the parent.
++- // Sets up stack to return as if from system call.
++- // Caller must set state of returned proc to RUNNABLE.
++- int
++--fork(void)
++--{
++--  int i, pid;
++--  struct proc *np;
++--  struct proc *curproc = myproc();
++--
++--  // Allocate process.
++--  if((np = allocproc()) == 0){
++--    return -1;
++--  }
++-+fork(void) {
++-+    int i, pid;
++-+    struct proc *np;
++-+    struct proc *curproc = myproc();
++-+
++-+    // Allocate process.
++-+    if ((np = allocproc()) == 0) {
++-+        return -1;
++-+    }
++- 
++--  // Copy process state from proc.
++--  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
++--    kfree(np->kstack);
++--    np->kstack = 0;
++--    np->state = UNUSED;
++--    return -1;
++--  }
++--  np->sz = curproc->sz;
++--  np->parent = curproc;
++--  *np->tf = *curproc->tf;
++-+    // Copy process state from proc.
++-+    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
++-+        kfree(np->kstack);
++-+        np->kstack = 0;
++-+        np->state = UNUSED;
++-+        return -1;
++-+    }
++-+    np->sz = curproc->sz;
++-+    np->parent = curproc;
++-+    *np->tf = *curproc->tf;
++- 
++--  // Clear %eax so that fork returns 0 in the child.
++--  np->tf->eax = 0;
++-+    // Clear %eax so that fork returns 0 in the child.
++-+    np->tf->eax = 0;
++- 
++--  for(i = 0; i < NOFILE; i++)
++--    if(curproc->ofile[i])
++--      np->ofile[i] = filedup(curproc->ofile[i]);
++--  np->cwd = idup(curproc->cwd);
++-+    for (i = 0; i < NOFILE; i++)
++-+        if (curproc->ofile[i])
++-+            np->ofile[i] = filedup(curproc->ofile[i]);
++-+    np->cwd = idup(curproc->cwd);
++- 
++--  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
++-+    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
++- 
++--  pid = np->pid;
++-+    pid = np->pid;
++- 
++--  acquire(&ptable.lock);
++-+    acquire(&ptable.lock);
++- 
++--  np->state = RUNNABLE;
++-+    np->state = RUNNABLE;
++- 
++--  release(&ptable.lock);
++-+    release(&ptable.lock);
++- 
++--  return pid;
++-+    return pid;
++- }
++- 
++- // Exit the current process.  Does not return.
++- // An exited process remains in the zombie state
++- // until its parent calls wait() to find out it exited.
++- void
++--exit(void)
++--{
++--  struct proc *curproc = myproc();
++--  struct proc *p;
++--  int fd;
++--
++--  if(curproc == initproc)
++--    panic("init exiting");
++--
++--  // Close all open files.
++--  for(fd = 0; fd < NOFILE; fd++){
++--    if(curproc->ofile[fd]){
++--      fileclose(curproc->ofile[fd]);
++--      curproc->ofile[fd] = 0;
++-+exit(int status) {
++-+    struct proc *curproc = myproc();
++-+    struct proc *p;
++-+    int fd;
++-+
++-+    curproc->status = status;
++-+
++-+    if (curproc == initproc)
++-+        panic("init exiting");
++-+
++-+    // Close all open files.
++-+    for (fd = 0; fd < NOFILE; fd++) {
++-+        if (curproc->ofile[fd]) {
++-+            fileclose(curproc->ofile[fd]);
++-+            curproc->ofile[fd] = 0;
++-+        }
++-     }
++--  }
++- 
++--  begin_op();
++--  iput(curproc->cwd);
++--  end_op();
++--  curproc->cwd = 0;
++-+    begin_op();
++-+    iput(curproc->cwd);
++-+    end_op();
++-+    curproc->cwd = 0;
++- 
++--  acquire(&ptable.lock);
++-+    acquire(&ptable.lock);
++- 
++--  // Parent might be sleeping in wait().
++--  wakeup1(curproc->parent);
++-+    // Parent might be sleeping in wait().
++-+    wakeup1(curproc->parent);
++- 
++--  // Pass abandoned children to init.
++--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++--    if(p->parent == curproc){
++--      p->parent = initproc;
++--      if(p->state == ZOMBIE)
++--        wakeup1(initproc);
++-+    // Pass abandoned children to init.
++-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-+        if (p->parent == curproc) {
++-+            p->parent = initproc;
++-+            if (p->state == ZOMBIE)
++-+                wakeup1(initproc);
++-+        }
++-     }
++--  }
++- 
++--  // Jump into the scheduler, never to return.
++--  curproc->state = ZOMBIE;
++--  sched();
++--  panic("zombie exit");
++-+    // Jump into the scheduler, never to return.
++-+    curproc->state = ZOMBIE;
++-+    sched();
++-+    panic("zombie exit");
++- }
++- 
++- // Wait for a child process to exit and return its pid.
++- // Return -1 if this process has no children.
++- int
++--wait(void)
++--{
++--  struct proc *p;
++--  int havekids, pid;
++--  struct proc *curproc = myproc();
++--  
++--  acquire(&ptable.lock);
++--  for(;;){
++--    // Scan through table looking for exited children.
++--    havekids = 0;
++--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++--      if(p->parent != curproc)
++--        continue;
++--      havekids = 1;
++--      if(p->state == ZOMBIE){
++--        // Found one.
++--        pid = p->pid;
++--        kfree(p->kstack);
++--        p->kstack = 0;
++--        freevm(p->pgdir);
++--        p->pid = 0;
++--        p->parent = 0;
++--        p->name[0] = 0;
++--        p->killed = 0;
++--        p->state = UNUSED;
++--        release(&ptable.lock);
++--        return pid;
++--      }
++--    }
++-+wait(int *status) {
++-+    struct proc *p;
++-+    int havekids, pid;
++-+    struct proc *curproc = myproc();
++- 
++--    // No point waiting if we don't have any children.
++--    if(!havekids || curproc->killed){
++--      release(&ptable.lock);
++--      return -1;
++-+    acquire(&ptable.lock);
++-+    for (;;) {
++-+        // Scan through table looking for exited children.
++-+        havekids = 0;
++-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-+            if (p->parent != curproc)
++-+                continue;
++-+            havekids = 1;
++-+            if (p->state == ZOMBIE) {
++-+                // Found one.
++-+                pid = p->pid;
++-+                kfree(p->kstack);
++-+                p->kstack = 0;
++-+                freevm(p->pgdir);
++-+                p->pid = 0;
++-+                p->parent = 0;
++-+                p->name[0] = 0;
++-+                p->killed = 0;
++-+                p->state = UNUSED;
++-+                release(&ptable.lock);
++-+                if (status != NULL)
++-+                    *status = p->status;
++-+                return pid;
++-+            }
++-+        }
++-+
++-+        // No point waiting if we don't have any children.
++-+        if (!havekids || curproc->killed) {
++-+            release(&ptable.lock);
++-+            return -1;
++-+        }
++-+
++-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
++-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
++-     }
++-+}
++- 
++--    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
++--    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
++--  }
++-+// Wait for a child process to exit and return its pid.
++-+// Return -1 if this process has no children.
++-+int
++-+waitpid(int pidBeingSearchedFor, int *status, int options) {
++-+    struct proc *p;
++-+    int doesProcExist, pidFound;
++-+    struct proc *curproc = myproc();
++-+    acquire(&ptable.lock);
++-+    for (;;) {
++-+        // Scan through table looking for exited children.
++-+        doesProcExist = 0;
++-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-+//            if(p->parent != curproc)
++-+//                continue;
++-+
++-+            if (p->pid != pidBeingSearchedFor)
++-+                continue;
++-+
++-+            doesProcExist = 1;
++-+            if (p->state == ZOMBIE) {
++-+                // Found one.
++-+                pidFound = p->pid;
++-+                kfree(p->kstack);
++-+                p->kstack = 0;
++-+                freevm(p->pgdir);
++-+                p->pid = 0;
++-+                p->parent = 0;
++-+                p->name[0] = 0;
++-+                p->killed = 0;
++-+                p->state = UNUSED;
++-+                release(&ptable.lock);
++-+                if (status != NULL)
++-+                    *status = p->status;
++-+                return pidFound;
++-+            }
++-+        }
++-+
++-+//        // No point waiting if we don't have any children.
++-+//        if(!havekids || curproc->killed){
++-+//            release(&ptable.lock);
++-+//            return -1;
++-+//        }
++-+
++-+        if (!doesProcExist || curproc->killed) {
++-+            release(&ptable.lock);
++-+            return -1;
++-+        }
++-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
++-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
++-+    }
++- }
++- 
++- //PAGEBREAK: 42
++-@@ -320,39 +372,38 @@ wait(void)
++- //  - eventually that process transfers control
++- //      via swtch back to the scheduler.
++- void
++--scheduler(void)
++--{
++--  struct proc *p;
++--  struct cpu *c = mycpu();
++--  c->proc = 0;
++--  
++--  for(;;){
++--    // Enable interrupts on this processor.
++--    sti();
++--
++--    // Loop over process table looking for process to run.
++--    acquire(&ptable.lock);
++--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++--      if(p->state != RUNNABLE)
++--        continue;
++--
++--      // Switch to chosen process.  It is the process's job
++--      // to release ptable.lock and then reacquire it
++--      // before jumping back to us.
++--      c->proc = p;
++--      switchuvm(p);
++--      p->state = RUNNING;
++--
++--      swtch(&(c->scheduler), p->context);
++--      switchkvm();
++--
++--      // Process is done running for now.
++--      // It should have changed its p->state before coming back.
++--      c->proc = 0;
++--    }
++--    release(&ptable.lock);
++-+scheduler(void) {
++-+    struct proc *p;
++-+    struct cpu *c = mycpu();
++-+    c->proc = 0;
++-+
++-+    for (;;) {
++-+        // Enable interrupts on this processor.
++-+        sti();
++-+
++-+        // Loop over process table looking for process to run.
++-+        acquire(&ptable.lock);
++-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-+            if (p->state != RUNNABLE)
++-+                continue;
++-+
++-+            // Switch to chosen process.  It is the process's job
++-+            // to release ptable.lock and then reacquire it
++-+            // before jumping back to us.
++-+            c->proc = p;
++-+            switchuvm(p);
++-+            p->state = RUNNING;
++-+
++-+            swtch(&(c->scheduler), p->context);
++-+            switchkvm();
++-+
++-+            // Process is done running for now.
++-+            // It should have changed its p->state before coming back.
++-+            c->proc = 0;
++-+        }
++-+        release(&ptable.lock);
++- 
++--  }
++-+    }
++- }
++- 
++- // Enter scheduler.  Must hold only ptable.lock
++-@@ -363,137 +414,130 @@ scheduler(void)
++- // break in the few places where a lock is held but
++- // there's no process.
++- void
++--sched(void)
++--{
++--  int intena;
++--  struct proc *p = myproc();
++--
++--  if(!holding(&ptable.lock))
++--    panic("sched ptable.lock");
++--  if(mycpu()->ncli != 1)
++--    panic("sched locks");
++--  if(p->state == RUNNING)
++--    panic("sched running");
++--  if(readeflags()&FL_IF)
++--    panic("sched interruptible");
++--  intena = mycpu()->intena;
++--  swtch(&p->context, mycpu()->scheduler);
++--  mycpu()->intena = intena;
++-+sched(void) {
++-+    int intena;
++-+    struct proc *p = myproc();
++-+
++-+    if (!holding(&ptable.lock))
++-+        panic("sched ptable.lock");
++-+    if (mycpu()->ncli != 1)
++-+        panic("sched locks");
++-+    if (p->state == RUNNING)
++-+        panic("sched running");
++-+    if (readeflags() & FL_IF)
++-+        panic("sched interruptible");
++-+    intena = mycpu()->intena;
++-+    swtch(&p->context, mycpu()->scheduler);
++-+    mycpu()->intena = intena;
++- }
++- 
++- // Give up the CPU for one scheduling round.
++- void
++--yield(void)
++--{
++--  acquire(&ptable.lock);  //DOC: yieldlock
++--  myproc()->state = RUNNABLE;
++--  sched();
++--  release(&ptable.lock);
++-+yield(void) {
++-+    acquire(&ptable.lock);  //DOC: yieldlock
++-+    myproc()->state = RUNNABLE;
++-+    sched();
++-+    release(&ptable.lock);
++- }
++- 
++- // A fork child's very first scheduling by scheduler()
++- // will swtch here.  "Return" to user space.
++- void
++--forkret(void)
++--{
++--  static int first = 1;
++--  // Still holding ptable.lock from scheduler.
++--  release(&ptable.lock);
++--
++--  if (first) {
++--    // Some initialization functions must be run in the context
++--    // of a regular process (e.g., they call sleep), and thus cannot
++--    // be run from main().
++--    first = 0;
++--    iinit(ROOTDEV);
++--    initlog(ROOTDEV);
++--  }
++--
++--  // Return to "caller", actually trapret (see allocproc).
++-+forkret(void) {
++-+    static int first = 1;
++-+    // Still holding ptable.lock from scheduler.
++-+    release(&ptable.lock);
++-+
++-+    if (first) {
++-+        // Some initialization functions must be run in the context
++-+        // of a regular process (e.g., they call sleep), and thus cannot
++-+        // be run from main().
++-+        first = 0;
++-+        iinit(ROOTDEV);
++-+        initlog(ROOTDEV);
++-+    }
++-+
++-+    // Return to "caller", actually trapret (see allocproc).
++- }
++- 
++- // Atomically release lock and sleep on chan.
++- // Reacquires lock when awakened.
++- void
++--sleep(void *chan, struct spinlock *lk)
++--{
++--  struct proc *p = myproc();
++--  
++--  if(p == 0)
++--    panic("sleep");
++--
++--  if(lk == 0)
++--    panic("sleep without lk");
++--
++--  // Must acquire ptable.lock in order to
++--  // change p->state and then call sched.
++--  // Once we hold ptable.lock, we can be
++--  // guaranteed that we won't miss any wakeup
++--  // (wakeup runs with ptable.lock locked),
++--  // so it's okay to release lk.
++--  if(lk != &ptable.lock){  //DOC: sleeplock0
++--    acquire(&ptable.lock);  //DOC: sleeplock1
++--    release(lk);
++--  }
++--  // Go to sleep.
++--  p->chan = chan;
++--  p->state = SLEEPING;
++--
++--  sched();
++--
++--  // Tidy up.
++--  p->chan = 0;
++--
++--  // Reacquire original lock.
++--  if(lk != &ptable.lock){  //DOC: sleeplock2
++--    release(&ptable.lock);
++--    acquire(lk);
++--  }
++-+sleep(void *chan, struct spinlock *lk) {
++-+    struct proc *p = myproc();
++-+
++-+    if (p == 0)
++-+        panic("sleep");
++-+
++-+    if (lk == 0)
++-+        panic("sleep without lk");
++-+
++-+    // Must acquire ptable.lock in order to
++-+    // change p->state and then call sched.
++-+    // Once we hold ptable.lock, we can be
++-+    // guaranteed that we won't miss any wakeup
++-+    // (wakeup runs with ptable.lock locked),
++-+    // so it's okay to release lk.
++-+    if (lk != &ptable.lock) {  //DOC: sleeplock0
++-+        acquire(&ptable.lock);  //DOC: sleeplock1
++-+        release(lk);
++-+    }
++-+    // Go to sleep.
++-+    p->chan = chan;
++-+    p->state = SLEEPING;
++-+
++-+    sched();
++-+
++-+    // Tidy up.
++-+    p->chan = 0;
++-+
++-+    // Reacquire original lock.
++-+    if (lk != &ptable.lock) {  //DOC: sleeplock2
++-+        release(&ptable.lock);
++-+        acquire(lk);
++-+    }
++- }
++- 
++- //PAGEBREAK!
++- // Wake up all processes sleeping on chan.
++- // The ptable lock must be held.
++- static void
++--wakeup1(void *chan)
++--{
++--  struct proc *p;
++-+wakeup1(void *chan) {
++-+    struct proc *p;
++- 
++--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++--    if(p->state == SLEEPING && p->chan == chan)
++--      p->state = RUNNABLE;
++-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++-+        if (p->state == SLEEPING && p->chan == chan)
++-+            p->state = RUNNABLE;
++- }
++- 
++- // Wake up all processes sleeping on chan.
++- void
++--wakeup(void *chan)
++--{
++--  acquire(&ptable.lock);
++--  wakeup1(chan);
++--  release(&ptable.lock);
++-+wakeup(void *chan) {
++-+    acquire(&ptable.lock);
++-+    wakeup1(chan);
++-+    release(&ptable.lock);
++- }
++- 
++- // Kill the process with the given pid.
++- // Process won't exit until it returns
++- // to user space (see trap in trap.c).
++- int
++--kill(int pid)
++--{
++--  struct proc *p;
++--
++--  acquire(&ptable.lock);
++--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++--    if(p->pid == pid){
++--      p->killed = 1;
++--      // Wake process from sleep if necessary.
++--      if(p->state == SLEEPING)
++--        p->state = RUNNABLE;
++--      release(&ptable.lock);
++--      return 0;
++-+kill(int pid) {
++-+    struct proc *p;
++-+
++-+    acquire(&ptable.lock);
++-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-+        if (p->pid == pid) {
++-+            p->killed = 1;
++-+            // Wake process from sleep if necessary.
++-+            if (p->state == SLEEPING)
++-+                p->state = RUNNABLE;
++-+            release(&ptable.lock);
++-+            return 0;
++-+        }
++-     }
++--  }
++--  release(&ptable.lock);
++--  return -1;
++-+    release(&ptable.lock);
++-+    return -1;
++- }
++- 
++- //PAGEBREAK: 36
++-@@ -501,34 +545,33 @@ kill(int pid)
++- // Runs when user types ^P on console.
++- // No lock to avoid wedging a stuck machine further.
++- void
++--procdump(void)
++--{
++--  static char *states[] = {
++--  [UNUSED]    "unused",
++--  [EMBRYO]    "embryo",
++--  [SLEEPING]  "sleep ",
++--  [RUNNABLE]  "runble",
++--  [RUNNING]   "run   ",
++--  [ZOMBIE]    "zombie"
++--  };
++--  int i;
++--  struct proc *p;
++--  char *state;
++--  uint pc[10];
++--
++--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++--    if(p->state == UNUSED)
++--      continue;
++--    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
++--      state = states[p->state];
++--    else
++--      state = "???";
++--    cprintf("%d %s %s", p->pid, state, p->name);
++--    if(p->state == SLEEPING){
++--      getcallerpcs((uint*)p->context->ebp+2, pc);
++--      for(i=0; i<10 && pc[i] != 0; i++)
++--        cprintf(" %p", pc[i]);
++-+procdump(void) {
++-+    static char *states[] = {
++-+            [UNUSED]    "unused",
++-+            [EMBRYO]    "embryo",
++-+            [SLEEPING]  "sleep ",
++-+            [RUNNABLE]  "runble",
++-+            [RUNNING]   "run   ",
++-+            [ZOMBIE]    "zombie"
++-+    };
++-+    int i;
++-+    struct proc *p;
++-+    char *state;
++-+    uint pc[10];
++-+
++-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-+        if (p->state == UNUSED)
++-+            continue;
++-+        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
++-+            state = states[p->state];
++-+        else
++-+            state = "???";
++-+        cprintf("%d %s %s", p->pid, state, p->name);
++-+        if (p->state == SLEEPING) {
++-+            getcallerpcs((uint *) p->context->ebp + 2, pc);
++-+            for (i = 0; i < 10 && pc[i] != 0; i++)
++-+                cprintf(" %p", pc[i]);
++-+        }
++-+        cprintf("\n");
++-     }
++--    cprintf("\n");
++--  }
++- }
++-diff --git a/proc.h b/proc.h
++-index 1647114..a06b921 100644
++---- a/proc.h
++-+++ b/proc.h
++-@@ -49,6 +49,7 @@ struct proc {
++-   struct file *ofile[NOFILE];  // Open files
++-   struct inode *cwd;           // Current directory
++-   char name[16];               // Process name (debugging)
++-+  int status;                  // Exit status
++- };
++- 
++- // Process memory is laid out contiguously, low addresses first:
++-diff --git a/rm.c b/rm.c
++-index 4fd33c8..1e6daec 100644
++---- a/rm.c
++-+++ b/rm.c
++-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
++- 
++-   if(argc < 2){
++-     printf(2, "Usage: rm files...\n");
++--    exit();
++-+    exit(1);
++-   }
++- 
++-   for(i = 1; i < argc; i++){
++-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
++-     }
++-   }
++- 
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/runoff b/runoff
++-old mode 100755
++-new mode 100644
++-diff --git a/runoff1 b/runoff1
++-old mode 100755
++-new mode 100644
++-diff --git a/sh.c b/sh.c
++-index 054bab9..ca2ae37 100644
++---- a/sh.c
++-+++ b/sh.c
++-@@ -65,7 +65,7 @@ runcmd(struct cmd *cmd)
++-   struct redircmd *rcmd;
++- 
++-   if(cmd == 0)
++--    exit();
++-+    exit(1);
++- 
++-   switch(cmd->type){
++-   default:
++-@@ -74,7 +74,7 @@ runcmd(struct cmd *cmd)
++-   case EXEC:
++-     ecmd = (struct execcmd*)cmd;
++-     if(ecmd->argv[0] == 0)
++--      exit();
++-+      exit(2);
++-     exec(ecmd->argv[0], ecmd->argv);
++-     printf(2, "exec %s failed\n", ecmd->argv[0]);
++-     break;
++-@@ -84,7 +84,7 @@ runcmd(struct cmd *cmd)
++-     close(rcmd->fd);
++-     if(open(rcmd->file, rcmd->mode) < 0){
++-       printf(2, "open %s failed\n", rcmd->file);
++--      exit();
++-+      exit(6);
++-     }
++-     runcmd(rcmd->cmd);
++-     break;
++-@@ -93,7 +93,7 @@ runcmd(struct cmd *cmd)
++-     lcmd = (struct listcmd*)cmd;
++-     if(fork1() == 0)
++-       runcmd(lcmd->left);
++--    wait();
++-+    wait(NULL);
++-     runcmd(lcmd->right);
++-     break;
++- 
++-@@ -117,8 +117,8 @@ runcmd(struct cmd *cmd)
++-     }
++-     close(p[0]);
++-     close(p[1]);
++--    wait();
++--    wait();
++-+    wait(NULL);
++-+    wait(NULL);
++-     break;
++- 
++-   case BACK:
++-@@ -127,7 +127,7 @@ runcmd(struct cmd *cmd)
++-       runcmd(bcmd->cmd);
++-     break;
++-   }
++--  exit();
++-+  exit(3);
++- }
++- 
++- int
++-@@ -166,16 +166,16 @@ main(void)
++-     }
++-     if(fork1() == 0)
++-       runcmd(parsecmd(buf));
++--    wait();
++-+    wait(NULL);
++-   }
++--  exit();
++-+  exit(0);
++- }
++- 
++- void
++- panic(char *s)
++- {
++-   printf(2, "%s\n", s);
++--  exit();
++-+  exit(5);
++- }
++- 
++- int
++-diff --git a/show1 b/show1
++-old mode 100755
++-new mode 100644
++-diff --git a/sign.pl b/sign.pl
++-old mode 100755
++-new mode 100644
++-diff --git a/spinp b/spinp
++-old mode 100755
++-new mode 100644
++-diff --git a/stressfs.c b/stressfs.c
++-index c0a4743..46e0e66 100644
++---- a/stressfs.c
++-+++ b/stressfs.c
++-@@ -43,7 +43,7 @@ main(int argc, char *argv[])
++-     read(fd, data, sizeof(data));
++-   close(fd);
++- 
++--  wait();
++-+  wait(NULL);
++- 
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/syscall.c b/syscall.c
++-index ee85261..41a8c3c 100644
++---- a/syscall.c
++-+++ b/syscall.c
++-@@ -101,6 +101,7 @@ extern int sys_sbrk(void);
++- extern int sys_sleep(void);
++- extern int sys_unlink(void);
++- extern int sys_wait(void);
++-+extern int sys_waitpid(void);
++- extern int sys_write(void);
++- extern int sys_uptime(void);
++- 
++-@@ -108,6 +109,7 @@ static int (*syscalls[])(void) = {
++- [SYS_fork]    sys_fork,
++- [SYS_exit]    sys_exit,
++- [SYS_wait]    sys_wait,
++-+[SYS_waitpid] sys_waitpid,
++- [SYS_pipe]    sys_pipe,
++- [SYS_read]    sys_read,
++- [SYS_kill]    sys_kill,
++-diff --git a/syscall.h b/syscall.h
++-index bc5f356..374ff05 100644
++---- a/syscall.h
++-+++ b/syscall.h
++-@@ -1,22 +1,23 @@
++- // System call numbers
++--#define SYS_fork    1
++--#define SYS_exit    2
++--#define SYS_wait    3
++--#define SYS_pipe    4
++--#define SYS_read    5
++--#define SYS_kill    6
++--#define SYS_exec    7
++--#define SYS_fstat   8
++--#define SYS_chdir   9
++--#define SYS_dup    10
++--#define SYS_getpid 11
++--#define SYS_sbrk   12
++--#define SYS_sleep  13
++--#define SYS_uptime 14
++--#define SYS_open   15
++--#define SYS_write  16
++--#define SYS_mknod  17
++--#define SYS_unlink 18
++--#define SYS_link   19
++--#define SYS_mkdir  20
++--#define SYS_close  21
++-+#define SYS_fork     1
++-+#define SYS_exit     2
++-+#define SYS_wait     3
++-+#define SYS_pipe     4
++-+#define SYS_read     5
++-+#define SYS_kill     6
++-+#define SYS_exec     7
++-+#define SYS_fstat    8
++-+#define SYS_chdir    9
++-+#define SYS_dup     10
++-+#define SYS_getpid  11
++-+#define SYS_sbrk    12
++-+#define SYS_sleep   13
++-+#define SYS_uptime  14
++-+#define SYS_open    15
++-+#define SYS_write   16
++-+#define SYS_mknod   17
++-+#define SYS_unlink  18
++-+#define SYS_link    19
++-+#define SYS_mkdir   20
++-+#define SYS_close   21
++-+#define SYS_waitpid 22
++-\ No newline at end of file
++-diff --git a/sysproc.c b/sysproc.c
++-index 0686d29..ebccf84 100644
++---- a/sysproc.c
++-+++ b/sysproc.c
++-@@ -14,16 +14,22 @@ sys_fork(void)
++- }
++- 
++- int
++--sys_exit(void)
++-+sys_exit(int status)
++- {
++--  exit();
++-+  exit(status);
++-   return 0;  // not reached
++- }
++- 
++- int
++--sys_wait(void)
++-+sys_wait(int* status)
++- {
++--  return wait();
++-+  return wait(status);
++-+}
++-+
++-+int
++-+sys_waitpid(int pid, int* status, int options)
++-+{
++-+    return waitpid(pid, status, options);
++- }
++- 
++- int
++-diff --git a/trap.c b/trap.c
++-index 41c66eb..432ea5b 100644
++---- a/trap.c
++-+++ b/trap.c
++-@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
++- {
++-   if(tf->trapno == T_SYSCALL){
++-     if(myproc()->killed)
++--      exit();
++-+      exit(4);
++-     myproc()->tf = tf;
++-     syscall();
++-     if(myproc()->killed)
++--      exit();
++-+      exit(3);
++-     return;
++-   }
++- 
++-@@ -98,7 +98,7 @@ trap(struct trapframe *tf)
++-   // (If it is still executing in the kernel, let it keep running
++-   // until it gets to the regular system call return.)
++-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
++--    exit();
++-+    exit(2);
++- 
++-   // Force process to give up CPU on clock tick.
++-   // If interrupts were on while locks held, would need to check nlock.
++-@@ -108,5 +108,5 @@ trap(struct trapframe *tf)
++- 
++-   // Check if the process has been killed since we yielded
++-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
++--    exit();
++-+    exit(1);
++- }
++-diff --git a/user.h b/user.h
++-index 4f99c52..0931387 100644
++---- a/user.h
++-+++ b/user.h
++-@@ -1,10 +1,13 @@
++-+#include <stddef.h>
++-+
++- struct stat;
++- struct rtcdate;
++- 
++- // system calls
++- int fork(void);
++--int exit(void) __attribute__((noreturn));
++--int wait(void);
++-+int exit(int status) __attribute__((noreturn));
++-+int wait(int* status);
++-+int waitpid(int pid, int* status, int options);
++- int pipe(int*);
++- int write(int, const void*, int);
++- int read(int, void*, int);
++-diff --git a/usertests.c b/usertests.c
++-index a1e97e7..2c2c128 100644
++---- a/usertests.c
++-+++ b/usertests.c
++-@@ -21,19 +21,19 @@ iputtest(void)
++- 
++-   if(mkdir("iputdir") < 0){
++-     printf(stdout, "mkdir failed\n");
++--    exit();
++-+    exit(184);
++-   }
++-   if(chdir("iputdir") < 0){
++-     printf(stdout, "chdir iputdir failed\n");
++--    exit();
++-+    exit(183);
++-   }
++-   if(unlink("../iputdir") < 0){
++-     printf(stdout, "unlink ../iputdir failed\n");
++--    exit();
++-+    exit(182);
++-   }
++-   if(chdir("/") < 0){
++-     printf(stdout, "chdir / failed\n");
++--    exit();
++-+    exit(181);
++-   }
++-   printf(stdout, "iput test ok\n");
++- }
++-@@ -49,24 +49,24 @@ exitiputtest(void)
++-   pid = fork();
++-   if(pid < 0){
++-     printf(stdout, "fork failed\n");
++--    exit();
++-+    exit(180);
++-   }
++-   if(pid == 0){
++-     if(mkdir("iputdir") < 0){
++-       printf(stdout, "mkdir failed\n");
++--      exit();
++-+      exit(179);
++-     }
++-     if(chdir("iputdir") < 0){
++-       printf(stdout, "child chdir failed\n");
++--      exit();
++-+      exit(178);
++-     }
++-     if(unlink("../iputdir") < 0){
++-       printf(stdout, "unlink ../iputdir failed\n");
++--      exit();
++-+      exit(177);
++-     }
++--    exit();
++-+    exit(176);
++-   }
++--  wait();
++-+  wait(NULL);
++-   printf(stdout, "exitiput test ok\n");
++- }
++- 
++-@@ -89,27 +89,27 @@ openiputtest(void)
++-   printf(stdout, "openiput test\n");
++-   if(mkdir("oidir") < 0){
++-     printf(stdout, "mkdir oidir failed\n");
++--    exit();
++-+    exit(175);
++-   }
++-   pid = fork();
++-   if(pid < 0){
++-     printf(stdout, "fork failed\n");
++--    exit();
++-+    exit(174);
++-   }
++-   if(pid == 0){
++-     int fd = open("oidir", O_RDWR);
++-     if(fd >= 0){
++-       printf(stdout, "open directory for write succeeded\n");
++--      exit();
++-+      exit(0);
++-     }
++--    exit();
++-+    exit(172);
++-   }
++-   sleep(1);
++-   if(unlink("oidir") != 0){
++-     printf(stdout, "unlink failed\n");
++--    exit();
++-+    exit(171);
++-   }
++--  wait();
++-+  wait(NULL);
++-   printf(stdout, "openiput test ok\n");
++- }
++- 
++-@@ -124,13 +124,13 @@ opentest(void)
++-   fd = open("echo", 0);
++-   if(fd < 0){
++-     printf(stdout, "open echo failed!\n");
++--    exit();
++-+    exit(170);
++-   }
++-   close(fd);
++-   fd = open("doesnotexist", 0);
++-   if(fd >= 0){
++-     printf(stdout, "open doesnotexist succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   printf(stdout, "open test ok\n");
++- }
++-@@ -147,16 +147,16 @@ writetest(void)
++-     printf(stdout, "creat small succeeded; ok\n");
++-   } else {
++-     printf(stdout, "error: creat small failed!\n");
++--    exit();
++-+    exit(168);
++-   }
++-   for(i = 0; i < 100; i++){
++-     if(write(fd, "aaaaaaaaaa", 10) != 10){
++-       printf(stdout, "error: write aa %d new file failed\n", i);
++--      exit();
++-+      exit(167);
++-     }
++-     if(write(fd, "bbbbbbbbbb", 10) != 10){
++-       printf(stdout, "error: write bb %d new file failed\n", i);
++--      exit();
++-+      exit(166);
++-     }
++-   }
++-   printf(stdout, "writes ok\n");
++-@@ -166,20 +166,20 @@ writetest(void)
++-     printf(stdout, "open small succeeded ok\n");
++-   } else {
++-     printf(stdout, "error: open small failed!\n");
++--    exit();
++-+    exit(165);
++-   }
++-   i = read(fd, buf, 2000);
++-   if(i == 2000){
++-     printf(stdout, "read succeeded ok\n");
++-   } else {
++-     printf(stdout, "read failed\n");
++--    exit();
++-+    exit(164);
++-   }
++-   close(fd);
++- 
++-   if(unlink("small") < 0){
++-     printf(stdout, "unlink small failed\n");
++--    exit();
++-+    exit(163);
++-   }
++-   printf(stdout, "small file test ok\n");
++- }
++-@@ -194,14 +194,14 @@ writetest1(void)
++-   fd = open("big", O_CREATE|O_RDWR);
++-   if(fd < 0){
++-     printf(stdout, "error: creat big failed!\n");
++--    exit();
++-+    exit(162);
++-   }
++- 
++-   for(i = 0; i < MAXFILE; i++){
++-     ((int*)buf)[0] = i;
++-     if(write(fd, buf, 512) != 512){
++-       printf(stdout, "error: write big file failed\n", i);
++--      exit();
++-+      exit(161);
++-     }
++-   }
++- 
++-@@ -210,7 +210,7 @@ writetest1(void)
++-   fd = open("big", O_RDONLY);
++-   if(fd < 0){
++-     printf(stdout, "error: open big failed!\n");
++--    exit();
++-+    exit(160);
++-   }
++- 
++-   n = 0;
++-@@ -219,24 +219,24 @@ writetest1(void)
++-     if(i == 0){
++-       if(n == MAXFILE - 1){
++-         printf(stdout, "read only %d blocks from big", n);
++--        exit();
++-+        exit(159);
++-       }
++-       break;
++-     } else if(i != 512){
++-       printf(stdout, "read failed %d\n", i);
++--      exit();
++-+      exit(158);
++-     }
++-     if(((int*)buf)[0] != n){
++-       printf(stdout, "read content of block %d is %d\n",
++-              n, ((int*)buf)[0]);
++--      exit();
++-+      exit(157);
++-     }
++-     n++;
++-   }
++-   close(fd);
++-   if(unlink("big") < 0){
++-     printf(stdout, "unlink big failed\n");
++--    exit();
++-+    exit(156);
++-   }
++-   printf(stdout, "big files ok\n");
++- }
++-@@ -270,22 +270,22 @@ void dirtest(void)
++- 
++-   if(mkdir("dir0") < 0){
++-     printf(stdout, "mkdir failed\n");
++--    exit();
++-+    exit(155);
++-   }
++- 
++-   if(chdir("dir0") < 0){
++-     printf(stdout, "chdir dir0 failed\n");
++--    exit();
++-+    exit(154);
++-   }
++- 
++-   if(chdir("..") < 0){
++-     printf(stdout, "chdir .. failed\n");
++--    exit();
++-+    exit(153);
++-   }
++- 
++-   if(unlink("dir0") < 0){
++-     printf(stdout, "unlink dir0 failed\n");
++--    exit();
++-+    exit(152);
++-   }
++-   printf(stdout, "mkdir test ok\n");
++- }
++-@@ -296,7 +296,7 @@ exectest(void)
++-   printf(stdout, "exec test\n");
++-   if(exec("echo", echoargv) < 0){
++-     printf(stdout, "exec echo failed\n");
++--    exit();
++-+    exit(151);
++-   }
++- }
++- 
++-@@ -310,7 +310,7 @@ pipe1(void)
++- 
++-   if(pipe(fds) != 0){
++-     printf(1, "pipe() failed\n");
++--    exit();
++-+    exit(150);
++-   }
++-   pid = fork();
++-   seq = 0;
++-@@ -321,10 +321,10 @@ pipe1(void)
++-         buf[i] = seq++;
++-       if(write(fds[1], buf, 1033) != 1033){
++-         printf(1, "pipe1 oops 1\n");
++--        exit();
++-+        exit(149);
++-       }
++-     }
++--    exit();
++-+    exit(148);
++-   } else if(pid > 0){
++-     close(fds[1]);
++-     total = 0;
++-@@ -343,13 +343,13 @@ pipe1(void)
++-     }
++-     if(total != 5 * 1033){
++-       printf(1, "pipe1 oops 3 total %d\n", total);
++--      exit();
++-+      exit(147);
++-     }
++-     close(fds[0]);
++--    wait();
++-+    wait(NULL);
++-   } else {
++-     printf(1, "fork() failed\n");
++--    exit();
++-+    exit(146);
++-   }
++-   printf(1, "pipe1 ok\n");
++- }
++-@@ -394,9 +394,9 @@ preempt(void)
++-   kill(pid2);
++-   kill(pid3);
++-   printf(1, "wait... ");
++--  wait();
++--  wait();
++--  wait();
++-+  wait(NULL);
++-+  wait(NULL);
++-+  wait(NULL);
++-   printf(1, "preempt ok\n");
++- }
++- 
++-@@ -413,12 +413,12 @@ exitwait(void)
++-       return;
++-     }
++-     if(pid){
++--      if(wait() != pid){
++-+      if(wait(NULL) != pid){
++-         printf(1, "wait wrong pid\n");
++-         return;
++-       }
++-     } else {
++--      exit();
++-+      exit(145);
++-     }
++-   }
++-   printf(1, "exitwait ok\n");
++-@@ -447,13 +447,13 @@ mem(void)
++-     if(m1 == 0){
++-       printf(1, "couldn't allocate mem?!!\n");
++-       kill(ppid);
++--      exit();
++-+      exit(144);
++-     }
++-     free(m1);
++-     printf(1, "mem ok\n");
++--    exit();
++-+    exit(0);
++-   } else {
++--    wait();
++-+    wait(NULL);
++-   }
++- }
++- 
++-@@ -484,9 +484,9 @@ sharedfd(void)
++-     }
++-   }
++-   if(pid == 0)
++--    exit();
++-+    exit(142);
++-   else
++--    wait();
++-+    wait(NULL);
++-   close(fd);
++-   fd = open("sharedfd", 0);
++-   if(fd < 0){
++-@@ -508,7 +508,7 @@ sharedfd(void)
++-     printf(1, "sharedfd ok\n");
++-   } else {
++-     printf(1, "sharedfd oops %d %d\n", nc, np);
++--    exit();
++-+    exit(141);
++-   }
++- }
++- 
++-@@ -530,29 +530,29 @@ fourfiles(void)
++-     pid = fork();
++-     if(pid < 0){
++-       printf(1, "fork failed\n");
++--      exit();
++-+      exit(140);
++-     }
++- 
++-     if(pid == 0){
++-       fd = open(fname, O_CREATE | O_RDWR);
++-       if(fd < 0){
++-         printf(1, "create failed\n");
++--        exit();
++-+        exit(139);
++-       }
++- 
++-       memset(buf, '0'+pi, 512);
++-       for(i = 0; i < 12; i++){
++-         if((n = write(fd, buf, 500)) != 500){
++-           printf(1, "write failed %d\n", n);
++--          exit();
++-+          exit(138);
++-         }
++-       }
++--      exit();
++-+      exit(137);
++-     }
++-   }
++- 
++-   for(pi = 0; pi < 4; pi++){
++--    wait();
++-+    wait(NULL);
++-   }
++- 
++-   for(i = 0; i < 2; i++){
++-@@ -563,7 +563,7 @@ fourfiles(void)
++-       for(j = 0; j < n; j++){
++-         if(buf[j] != '0'+i){
++-           printf(1, "wrong char\n");
++--          exit();
++-+          exit(136);
++-         }
++-       }
++-       total += n;
++-@@ -571,7 +571,7 @@ fourfiles(void)
++-     close(fd);
++-     if(total != 12*500){
++-       printf(1, "wrong length %d\n", total);
++--      exit();
++-+      exit(135);
++-     }
++-     unlink(fname);
++-   }
++-@@ -593,7 +593,7 @@ createdelete(void)
++-     pid = fork();
++-     if(pid < 0){
++-       printf(1, "fork failed\n");
++--      exit();
++-+      exit(134);
++-     }
++- 
++-     if(pid == 0){
++-@@ -604,23 +604,23 @@ createdelete(void)
++-         fd = open(name, O_CREATE | O_RDWR);
++-         if(fd < 0){
++-           printf(1, "create failed\n");
++--          exit();
++-+          exit(133);
++-         }
++-         close(fd);
++-         if(i > 0 && (i % 2 ) == 0){
++-           name[1] = '0' + (i / 2);
++-           if(unlink(name) < 0){
++-             printf(1, "unlink failed\n");
++--            exit();
++-+            exit(132);
++-           }
++-         }
++-       }
++--      exit();
++-+      exit(131);
++-     }
++-   }
++- 
++-   for(pi = 0; pi < 4; pi++){
++--    wait();
++-+    wait(NULL);
++-   }
++- 
++-   name[0] = name[1] = name[2] = 0;
++-@@ -631,10 +631,10 @@ createdelete(void)
++-       fd = open(name, 0);
++-       if((i == 0 || i >= N/2) && fd < 0){
++-         printf(1, "oops createdelete %s didn't exist\n", name);
++--        exit();
++-+        exit(130);
++-       } else if((i >= 1 && i < N/2) && fd >= 0){
++-         printf(1, "oops createdelete %s did exist\n", name);
++--        exit();
++-+        exit(129);
++-       }
++-       if(fd >= 0)
++-         close(fd);
++-@@ -662,7 +662,7 @@ unlinkread(void)
++-   fd = open("unlinkread", O_CREATE | O_RDWR);
++-   if(fd < 0){
++-     printf(1, "create unlinkread failed\n");
++--    exit();
++-+    exit(128);
++-   }
++-   write(fd, "hello", 5);
++-   close(fd);
++-@@ -670,11 +670,11 @@ unlinkread(void)
++-   fd = open("unlinkread", O_RDWR);
++-   if(fd < 0){
++-     printf(1, "open unlinkread failed\n");
++--    exit();
++-+    exit(127);
++-   }
++-   if(unlink("unlinkread") != 0){
++-     printf(1, "unlink unlinkread failed\n");
++--    exit();
++-+    exit(126);
++-   }
++- 
++-   fd1 = open("unlinkread", O_CREATE | O_RDWR);
++-@@ -683,15 +683,15 @@ unlinkread(void)
++- 
++-   if(read(fd, buf, sizeof(buf)) != 5){
++-     printf(1, "unlinkread read failed");
++--    exit();
++-+    exit(125);
++-   }
++-   if(buf[0] != 'h'){
++-     printf(1, "unlinkread wrong data\n");
++--    exit();
++-+    exit(124);
++-   }
++-   if(write(fd, buf, 10) != 10){
++-     printf(1, "unlinkread write failed\n");
++--    exit();
++-+    exit(123);
++-   }
++-   close(fd);
++-   unlink("unlinkread");
++-@@ -711,50 +711,50 @@ linktest(void)
++-   fd = open("lf1", O_CREATE|O_RDWR);
++-   if(fd < 0){
++-     printf(1, "create lf1 failed\n");
++--    exit();
++-+    exit(122);
++-   }
++-   if(write(fd, "hello", 5) != 5){
++-     printf(1, "write lf1 failed\n");
++--    exit();
++-+    exit(121);
++-   }
++-   close(fd);
++- 
++-   if(link("lf1", "lf2") < 0){
++-     printf(1, "link lf1 lf2 failed\n");
++--    exit();
++-+    exit(120);
++-   }
++-   unlink("lf1");
++- 
++-   if(open("lf1", 0) >= 0){
++-     printf(1, "unlinked lf1 but it is still there!\n");
++--    exit();
++-+    exit(119);
++-   }
++- 
++-   fd = open("lf2", 0);
++-   if(fd < 0){
++-     printf(1, "open lf2 failed\n");
++--    exit();
++-+    exit(118);
++-   }
++-   if(read(fd, buf, sizeof(buf)) != 5){
++-     printf(1, "read lf2 failed\n");
++--    exit();
++-+    exit(117);
++-   }
++-   close(fd);
++- 
++-   if(link("lf2", "lf2") >= 0){
++-     printf(1, "link lf2 lf2 succeeded! oops\n");
++--    exit();
++-+    exit(116);
++-   }
++- 
++-   unlink("lf2");
++-   if(link("lf2", "lf1") >= 0){
++-     printf(1, "link non-existant succeeded! oops\n");
++--    exit();
++-+    exit(115);
++-   }
++- 
++-   if(link(".", "lf1") >= 0){
++-     printf(1, "link . lf1 succeeded! oops\n");
++--    exit();
++-+    exit(114);
++-   }
++- 
++-   printf(1, "linktest ok\n");
++-@@ -787,14 +787,14 @@ concreate(void)
++-       fd = open(file, O_CREATE | O_RDWR);
++-       if(fd < 0){
++-         printf(1, "concreate create %s failed\n", file);
++--        exit();
++-+        exit(113);
++-       }
++-       close(fd);
++-     }
++-     if(pid == 0)
++--      exit();
++-+      exit(112);
++-     else
++--      wait();
++-+      wait(NULL);
++-   }
++- 
++-   memset(fa, 0, sizeof(fa));
++-@@ -807,11 +807,11 @@ concreate(void)
++-       i = de.name[1] - '0';
++-       if(i < 0 || i >= sizeof(fa)){
++-         printf(1, "concreate weird file %s\n", de.name);
++--        exit();
++-+        exit(111);
++-       }
++-       if(fa[i]){
++-         printf(1, "concreate duplicate file %s\n", de.name);
++--        exit();
++-+        exit(110);
++-       }
++-       fa[i] = 1;
++-       n++;
++-@@ -821,7 +821,7 @@ concreate(void)
++- 
++-   if(n != 40){
++-     printf(1, "concreate not enough files in directory listing\n");
++--    exit();
++-+    exit(109);
++-   }
++- 
++-   for(i = 0; i < 40; i++){
++-@@ -829,7 +829,7 @@ concreate(void)
++-     pid = fork();
++-     if(pid < 0){
++-       printf(1, "fork failed\n");
++--      exit();
++-+      exit(108);
++-     }
++-     if(((i % 3) == 0 && pid == 0) ||
++-        ((i % 3) == 1 && pid != 0)){
++-@@ -844,9 +844,9 @@ concreate(void)
++-       unlink(file);
++-     }
++-     if(pid == 0)
++--      exit();
++-+      exit(107);
++-     else
++--      wait();
++-+      wait(NULL);
++-   }
++- 
++-   printf(1, "concreate ok\n");
++-@@ -865,7 +865,7 @@ linkunlink()
++-   pid = fork();
++-   if(pid < 0){
++-     printf(1, "fork failed\n");
++--    exit();
++-+    exit(106);
++-   }
++- 
++-   unsigned int x = (pid ? 1 : 97);
++-@@ -881,9 +881,9 @@ linkunlink()
++-   }
++- 
++-   if(pid)
++--    wait();
++-+    wait(NULL);
++-   else
++--    exit();
++-+    exit(105);
++- 
++-   printf(1, "linkunlink ok\n");
++- }
++-@@ -901,7 +901,7 @@ bigdir(void)
++-   fd = open("bd", O_CREATE);
++-   if(fd < 0){
++-     printf(1, "bigdir create failed\n");
++--    exit();
++-+    exit(104);
++-   }
++-   close(fd);
++- 
++-@@ -912,7 +912,7 @@ bigdir(void)
++-     name[3] = '\0';
++-     if(link("bd", name) != 0){
++-       printf(1, "bigdir link failed\n");
++--      exit();
++-+      exit(103);
++-     }
++-   }
++- 
++-@@ -924,7 +924,7 @@ bigdir(void)
++-     name[3] = '\0';
++-     if(unlink(name) != 0){
++-       printf(1, "bigdir unlink failed");
++--      exit();
++-+      exit(102);
++-     }
++-   }
++- 
++-@@ -941,31 +941,31 @@ subdir(void)
++-   unlink("ff");
++-   if(mkdir("dd") != 0){
++-     printf(1, "subdir mkdir dd failed\n");
++--    exit();
++-+    exit(101);
++-   }
++- 
++-   fd = open("dd/ff", O_CREATE | O_RDWR);
++-   if(fd < 0){
++-     printf(1, "create dd/ff failed\n");
++--    exit();
++-+    exit(100);
++-   }
++-   write(fd, "ff", 2);
++-   close(fd);
++- 
++-   if(unlink("dd") >= 0){
++-     printf(1, "unlink dd (non-empty dir) succeeded!\n");
++--    exit();
++-+    exit(99);
++-   }
++- 
++-   if(mkdir("/dd/dd") != 0){
++-     printf(1, "subdir mkdir dd/dd failed\n");
++--    exit();
++-+    exit(98);
++-   }
++- 
++-   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
++-   if(fd < 0){
++-     printf(1, "create dd/dd/ff failed\n");
++--    exit();
++-+    exit(97);
++-   }
++-   write(fd, "FF", 2);
++-   close(fd);
++-@@ -973,142 +973,142 @@ subdir(void)
++-   fd = open("dd/dd/../ff", 0);
++-   if(fd < 0){
++-     printf(1, "open dd/dd/../ff failed\n");
++--    exit();
++-+    exit(96);
++-   }
++-   cc = read(fd, buf, sizeof(buf));
++-   if(cc != 2 || buf[0] != 'f'){
++-     printf(1, "dd/dd/../ff wrong content\n");
++--    exit();
++-+    exit(95);
++-   }
++-   close(fd);
++- 
++-   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
++-     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
++--    exit();
++-+    exit(94);
++-   }
++- 
++-   if(unlink("dd/dd/ff") != 0){
++-     printf(1, "unlink dd/dd/ff failed\n");
++--    exit();
++-+    exit(93);
++-   }
++-   if(open("dd/dd/ff", O_RDONLY) >= 0){
++-     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
++--    exit();
++-+    exit(92);
++-   }
++- 
++-   if(chdir("dd") != 0){
++-     printf(1, "chdir dd failed\n");
++--    exit();
++-+    exit(91);
++-   }
++-   if(chdir("dd/../../dd") != 0){
++-     printf(1, "chdir dd/../../dd failed\n");
++--    exit();
++-+    exit(90);
++-   }
++-   if(chdir("dd/../../../dd") != 0){
++-     printf(1, "chdir dd/../../dd failed\n");
++--    exit();
++-+    exit(89);
++-   }
++-   if(chdir("./..") != 0){
++-     printf(1, "chdir ./.. failed\n");
++--    exit();
++-+    exit(88);
++-   }
++- 
++-   fd = open("dd/dd/ffff", 0);
++-   if(fd < 0){
++-     printf(1, "open dd/dd/ffff failed\n");
++--    exit();
++-+    exit(87);
++-   }
++-   if(read(fd, buf, sizeof(buf)) != 2){
++-     printf(1, "read dd/dd/ffff wrong len\n");
++--    exit();
++-+    exit(86);
++-   }
++-   close(fd);
++- 
++-   if(open("dd/dd/ff", O_RDONLY) >= 0){
++-     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++- 
++-   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
++-     printf(1, "create dd/ff/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
++-     printf(1, "create dd/xx/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(open("dd", O_CREATE) >= 0){
++-     printf(1, "create dd succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(open("dd", O_RDWR) >= 0){
++-     printf(1, "open dd rdwr succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(open("dd", O_WRONLY) >= 0){
++-     printf(1, "open dd wronly succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(link("dd/ff/ff", "dd/dd/xx") == 0){
++-     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(link("dd/xx/ff", "dd/dd/xx") == 0){
++-     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(link("dd/ff", "dd/dd/ffff") == 0){
++-     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(mkdir("dd/ff/ff") == 0){
++-     printf(1, "mkdir dd/ff/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(mkdir("dd/xx/ff") == 0){
++-     printf(1, "mkdir dd/xx/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(mkdir("dd/dd/ffff") == 0){
++-     printf(1, "mkdir dd/dd/ffff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dd/xx/ff") == 0){
++-     printf(1, "unlink dd/xx/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dd/ff/ff") == 0){
++-     printf(1, "unlink dd/ff/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(chdir("dd/ff") == 0){
++-     printf(1, "chdir dd/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(chdir("dd/xx") == 0){
++-     printf(1, "chdir dd/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++- 
++-   if(unlink("dd/dd/ffff") != 0){
++-     printf(1, "unlink dd/dd/ff failed\n");
++--    exit();
++-+    exit(68);
++-   }
++-   if(unlink("dd/ff") != 0){
++-     printf(1, "unlink dd/ff failed\n");
++--    exit();
++-+    exit(67);
++-   }
++-   if(unlink("dd") == 0){
++-     printf(1, "unlink non-empty dd succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dd/dd") < 0){
++-     printf(1, "unlink dd/dd failed\n");
++--    exit();
++-+    exit(65);
++-   }
++-   if(unlink("dd") < 0){
++-     printf(1, "unlink dd failed\n");
++--    exit();
++-+    exit(64);
++-   }
++- 
++-   printf(1, "subdir ok\n");
++-@@ -1127,14 +1127,14 @@ bigwrite(void)
++-     fd = open("bigwrite", O_CREATE | O_RDWR);
++-     if(fd < 0){
++-       printf(1, "cannot create bigwrite\n");
++--      exit();
++-+      exit(63);
++-     }
++-     int i;
++-     for(i = 0; i < 2; i++){
++-       int cc = write(fd, buf, sz);
++-       if(cc != sz){
++-         printf(1, "write(%d) ret %d\n", sz, cc);
++--        exit();
++-+        exit(62);
++-       }
++-     }
++-     close(fd);
++-@@ -1155,13 +1155,13 @@ bigfile(void)
++-   fd = open("bigfile", O_CREATE | O_RDWR);
++-   if(fd < 0){
++-     printf(1, "cannot create bigfile");
++--    exit();
++-+    exit(61);
++-   }
++-   for(i = 0; i < 20; i++){
++-     memset(buf, i, 600);
++-     if(write(fd, buf, 600) != 600){
++-       printf(1, "write bigfile failed\n");
++--      exit();
++-+      exit(60);
++-     }
++-   }
++-   close(fd);
++-@@ -1169,31 +1169,31 @@ bigfile(void)
++-   fd = open("bigfile", 0);
++-   if(fd < 0){
++-     printf(1, "cannot open bigfile\n");
++--    exit();
++-+    exit(59);
++-   }
++-   total = 0;
++-   for(i = 0; ; i++){
++-     cc = read(fd, buf, 300);
++-     if(cc < 0){
++-       printf(1, "read bigfile failed\n");
++--      exit();
++-+      exit(58);
++-     }
++-     if(cc == 0)
++-       break;
++-     if(cc != 300){
++-       printf(1, "short read bigfile\n");
++--      exit();
++-+      exit(57);
++-     }
++-     if(buf[0] != i/2 || buf[299] != i/2){
++-       printf(1, "read bigfile wrong data\n");
++--      exit();
++-+      exit(56);
++-     }
++-     total += cc;
++-   }
++-   close(fd);
++-   if(total != 20*600){
++-     printf(1, "read bigfile wrong total\n");
++--    exit();
++-+    exit(55);
++-   }
++-   unlink("bigfile");
++- 
++-@@ -1210,32 +1210,32 @@ fourteen(void)
++- 
++-   if(mkdir("12345678901234") != 0){
++-     printf(1, "mkdir 12345678901234 failed\n");
++--    exit();
++-+    exit(54);
++-   }
++-   if(mkdir("12345678901234/123456789012345") != 0){
++-     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
++--    exit();
++-+    exit(53);
++-   }
++-   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
++-   if(fd < 0){
++-     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
++--    exit();
++-+    exit(52);
++-   }
++-   close(fd);
++-   fd = open("12345678901234/12345678901234/12345678901234", 0);
++-   if(fd < 0){
++-     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
++--    exit();
++-+    exit(51);
++-   }
++-   close(fd);
++- 
++-   if(mkdir("12345678901234/12345678901234") == 0){
++-     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(mkdir("123456789012345/12345678901234") == 0){
++-     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++- 
++-   printf(1, "fourteen ok\n");
++-@@ -1247,35 +1247,35 @@ rmdot(void)
++-   printf(1, "rmdot test\n");
++-   if(mkdir("dots") != 0){
++-     printf(1, "mkdir dots failed\n");
++--    exit();
++-+    exit(48);
++-   }
++-   if(chdir("dots") != 0){
++-     printf(1, "chdir dots failed\n");
++--    exit();
++-+    exit(47);
++-   }
++-   if(unlink(".") == 0){
++-     printf(1, "rm . worked!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("..") == 0){
++-     printf(1, "rm .. worked!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(chdir("/") != 0){
++-     printf(1, "chdir / failed\n");
++--    exit();
++-+    exit(44);
++-   }
++-   if(unlink("dots/.") == 0){
++-     printf(1, "unlink dots/. worked!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dots/..") == 0){
++-     printf(1, "unlink dots/.. worked!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dots") != 0){
++-     printf(1, "unlink dots failed!\n");
++--    exit();
++-+    exit(41);
++-   }
++-   printf(1, "rmdot ok\n");
++- }
++-@@ -1290,49 +1290,49 @@ dirfile(void)
++-   fd = open("dirfile", O_CREATE);
++-   if(fd < 0){
++-     printf(1, "create dirfile failed\n");
++--    exit();
++-+    exit(40);
++-   }
++-   close(fd);
++-   if(chdir("dirfile") == 0){
++-     printf(1, "chdir dirfile succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   fd = open("dirfile/xx", 0);
++-   if(fd >= 0){
++-     printf(1, "create dirfile/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   fd = open("dirfile/xx", O_CREATE);
++-   if(fd >= 0){
++-     printf(1, "create dirfile/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(mkdir("dirfile/xx") == 0){
++-     printf(1, "mkdir dirfile/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dirfile/xx") == 0){
++-     printf(1, "unlink dirfile/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(link("README", "dirfile/xx") == 0){
++-     printf(1, "link to dirfile/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dirfile") != 0){
++-     printf(1, "unlink dirfile failed!\n");
++--    exit();
++-+    exit(33);
++-   }
++- 
++-   fd = open(".", O_RDWR);
++-   if(fd >= 0){
++-     printf(1, "open . for writing succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   fd = open(".", 0);
++-   if(write(fd, "x", 1) > 0){
++-     printf(1, "write . succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   close(fd);
++- 
++-@@ -1351,11 +1351,11 @@ iref(void)
++-   for(i = 0; i < 50 + 1; i++){
++-     if(mkdir("irefd") != 0){
++-       printf(1, "mkdir irefd failed\n");
++--      exit();
++-+      exit(30);
++-     }
++-     if(chdir("irefd") != 0){
++-       printf(1, "chdir irefd failed\n");
++--      exit();
++-+      exit(29);
++-     }
++- 
++-     mkdir("");
++-@@ -1388,24 +1388,24 @@ forktest(void)
++-     if(pid < 0)
++-       break;
++-     if(pid == 0)
++--      exit();
++-+      exit(28);
++-   }
++- 
++-   if(n == 1000){
++-     printf(1, "fork claimed to work 1000 times!\n");
++--    exit();
++-+    exit(27);
++-   }
++- 
++-   for(; n > 0; n--){
++--    if(wait() < 0){
++-+    if(wait(NULL) < 0){
++-       printf(1, "wait stopped early\n");
++--      exit();
++-+      exit(26);
++-     }
++-   }
++- 
++--  if(wait() != -1){
++-+  if(wait(NULL) != -1){
++-     printf(1, "wait got too many\n");
++--    exit();
++-+    exit(25);
++-   }
++- 
++-   printf(1, "fork test OK\n");
++-@@ -1428,7 +1428,7 @@ sbrktest(void)
++-     b = sbrk(1);
++-     if(b != a){
++-       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
++--      exit();
++-+      exit(24);
++-     }
++-     *b = 1;
++-     a = b + 1;
++-@@ -1436,17 +1436,17 @@ sbrktest(void)
++-   pid = fork();
++-   if(pid < 0){
++-     printf(stdout, "sbrk test fork failed\n");
++--    exit();
++-+    exit(23);
++-   }
++-   c = sbrk(1);
++-   c = sbrk(1);
++-   if(c != a + 1){
++-     printf(stdout, "sbrk test failed post-fork\n");
++--    exit();
++-+    exit(22);
++-   }
++-   if(pid == 0)
++--    exit();
++--  wait();
++-+    exit(21);
++-+  wait(NULL);
++- 
++-   // can one grow address space to something big?
++- #define BIG (100*1024*1024)
++-@@ -1455,7 +1455,7 @@ sbrktest(void)
++-   p = sbrk(amt);
++-   if (p != a) {
++-     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
++--    exit();
++-+    exit(20);
++-   }
++-   lastaddr = (char*) (BIG-1);
++-   *lastaddr = 99;
++-@@ -1465,12 +1465,12 @@ sbrktest(void)
++-   c = sbrk(-4096);
++-   if(c == (char*)0xffffffff){
++-     printf(stdout, "sbrk could not deallocate\n");
++--    exit();
++-+    exit(19);
++-   }
++-   c = sbrk(0);
++-   if(c != a - 4096){
++-     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
++--    exit();
++-+    exit(18);
++-   }
++- 
++-   // can one re-allocate that page?
++-@@ -1478,19 +1478,19 @@ sbrktest(void)
++-   c = sbrk(4096);
++-   if(c != a || sbrk(0) != a + 4096){
++-     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
++--    exit();
++-+    exit(17);
++-   }
++-   if(*lastaddr == 99){
++-     // should be zero
++-     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
++--    exit();
++-+    exit(16);
++-   }
++- 
++-   a = sbrk(0);
++-   c = sbrk(-(sbrk(0) - oldbrk));
++-   if(c != a){
++-     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
++--    exit();
++-+    exit(15);
++-   }
++- 
++-   // can we read the kernel's memory?
++-@@ -1499,21 +1499,21 @@ sbrktest(void)
++-     pid = fork();
++-     if(pid < 0){
++-       printf(stdout, "fork failed\n");
++--      exit();
++-+      exit(14);
++-     }
++-     if(pid == 0){
++-       printf(stdout, "oops could read %x = %x\n", a, *a);
++-       kill(ppid);
++--      exit();
++-+      exit(13);
++-     }
++--    wait();
++-+    wait(NULL);
++-   }
++- 
++-   // if we run the system out of memory, does it clean up the last
++-   // failed allocation?
++-   if(pipe(fds) != 0){
++-     printf(1, "pipe() failed\n");
++--    exit();
++-+    exit(12);
++-   }
++-   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
++-     if((pids[i] = fork()) == 0){
++-@@ -1533,11 +1533,11 @@ sbrktest(void)
++-     if(pids[i] == -1)
++-       continue;
++-     kill(pids[i]);
++--    wait();
++-+    wait(NULL);
++-   }
++-   if(c == (char*)0xffffffff){
++-     printf(stdout, "failed sbrk leaked memory\n");
++--    exit();
++-+    exit(10);
++-   }
++- 
++-   if(sbrk(0) > oldbrk)
++-@@ -1572,17 +1572,17 @@ validatetest(void)
++-     if((pid = fork()) == 0){
++-       // try to crash the kernel by passing in a badly placed integer
++-       validateint((int*)p);
++--      exit();
++-+      exit(9);
++-     }
++-     sleep(0);
++-     sleep(0);
++-     kill(pid);
++--    wait();
++-+    wait(NULL);
++- 
++-     // try to crash the kernel by passing in a bad string pointer
++-     if(link("nosuchfile", (char*)p) != -1){
++-       printf(stdout, "link should not succeed\n");
++--      exit();
++-+      exit(8);
++-     }
++-   }
++- 
++-@@ -1600,7 +1600,7 @@ bsstest(void)
++-   for(i = 0; i < sizeof(uninit); i++){
++-     if(uninit[i] != '\0'){
++-       printf(stdout, "bss test failed\n");
++--      exit();
++-+      exit(7);
++-     }
++-   }
++-   printf(stdout, "bss test ok\n");
++-@@ -1627,16 +1627,16 @@ bigargtest(void)
++-     printf(stdout, "bigarg test ok\n");
++-     fd = open("bigarg-ok", O_CREATE);
++-     close(fd);
++--    exit();
++-+    exit(6);
++-   } else if(pid < 0){
++-     printf(stdout, "bigargtest: fork failed\n");
++--    exit();
++-+    exit(5);
++-   }
++--  wait();
++-+  wait(NULL);
++-   fd = open("bigarg-ok", 0);
++-   if(fd < 0){
++-     printf(stdout, "bigarg test failed!\n");
++--    exit();
++-+    exit(4);
++-   }
++-   close(fd);
++-   unlink("bigarg-ok");
++-@@ -1715,12 +1715,12 @@ uio()
++-     port = RTC_DATA;
++-     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
++-     printf(1, "uio: uio succeeded; test FAILED\n");
++--    exit();
++-+    exit(3);
++-   } else if(pid < 0){
++-     printf (1, "fork failed\n");
++--    exit();
++-+    exit(2);
++-   }
++--  wait();
++-+  wait(NULL);
++-   printf(1, "uio test done\n");
++- }
++- 
++-@@ -1730,7 +1730,7 @@ void argptest()
++-   fd = open("init", O_RDONLY);
++-   if (fd < 0) {
++-     printf(2, "open failed\n");
++--    exit();
++-+    exit(1);
++-   }
++-   read(fd, sbrk(0) - 1, -1);
++-   close(fd);
++-@@ -1752,7 +1752,7 @@ main(int argc, char *argv[])
++- 
++-   if(open("usertests.ran", 0) >= 0){
++-     printf(1, "already ran user tests -- rebuild fs.img\n");
++--    exit();
++-+    exit(1);
++-   }
++-   close(open("usertests.ran", O_CREATE));
++- 
++-@@ -1799,5 +1799,5 @@ main(int argc, char *argv[])
++- 
++-   exectest();
++- 
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/usys.S b/usys.S
++-index 8bfd8a1..1687ed0 100644
++---- a/usys.S
++-+++ b/usys.S
++-@@ -11,6 +11,7 @@
++- SYSCALL(fork)
++- SYSCALL(exit)
++- SYSCALL(wait)
++-+SYSCALL(waitpid)
++- SYSCALL(pipe)
++- SYSCALL(read)
++- SYSCALL(write)
++-diff --git a/vectors.pl b/vectors.pl
++-old mode 100755
++-new mode 100644
++-diff --git a/wc.c b/wc.c
++-index d6a54df..08b93b6 100644
++---- a/wc.c
++-+++ b/wc.c
++-@@ -27,7 +27,7 @@ wc(int fd, char *name)
++-   }
++-   if(n < 0){
++-     printf(1, "wc: read error\n");
++--    exit();
++-+    exit(3);
++-   }
++-   printf(1, "%d %d %d %s\n", l, w, c, name);
++- }
++-@@ -39,16 +39,16 @@ main(int argc, char *argv[])
++- 
++-   if(argc <= 1){
++-     wc(0, "");
++--    exit();
++-+    exit(2);
++-   }
++- 
++-   for(i = 1; i < argc; i++){
++-     if((fd = open(argv[i], 0)) < 0){
++-       printf(1, "wc: cannot open %s\n", argv[i]);
++--      exit();
++-+      exit(1);
++-     }
++-     wc(fd, argv[i]);
++-     close(fd);
++-   }
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/zombie.c b/zombie.c
++-index ee817da..c96b92d 100644
++---- a/zombie.c
++-+++ b/zombie.c
++-@@ -10,5 +10,5 @@ main(void)
++- {
++-   if(fork() > 0)
++-     sleep(5);  // Let child exit before parent.
++--  exit();
++-+  exit(0);
++- }
++diff --git a/console.c b/console.c
++deleted file mode 100644
++index a280d2b..0000000
++--- a/console.c
+++++ /dev/null
++@@ -1,299 +0,0 @@
++-// Console input and output.
++-// Input is from the keyboard or serial port.
++-// Output is written to the screen and serial port.
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "traps.h"
++-#include "spinlock.h"
++-#include "sleeplock.h"
++-#include "fs.h"
++-#include "file.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "x86.h"
++-
++-static void consputc(int);
++-
++-static int panicked = 0;
++-
++-static struct {
++-  struct spinlock lock;
++-  int locking;
++-} cons;
++-
++-static void
++-printint(int xx, int base, int sign)
++-{
++-  static char digits[] = "0123456789abcdef";
++-  char buf[16];
++-  int i;
++-  uint x;
++-
++-  if(sign && (sign = xx < 0))
++-    x = -xx;
++-  else
++-    x = xx;
++-
++-  i = 0;
++-  do{
++-    buf[i++] = digits[x % base];
++-  }while((x /= base) != 0);
++-
++-  if(sign)
++-    buf[i++] = '-';
++-
++-  while(--i >= 0)
++-    consputc(buf[i]);
++-}
++-//PAGEBREAK: 50
++-
++-// Print to the console. only understands %d, %x, %p, %s.
++-void
++-cprintf(char *fmt, ...)
++-{
++-  int i, c, locking;
++-  uint *argp;
++-  char *s;
++-
++-  locking = cons.locking;
++-  if(locking)
++-    acquire(&cons.lock);
++-
++-  if (fmt == 0)
++-    panic("null fmt");
++-
++-  argp = (uint*)(void*)(&fmt + 1);
++-  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
++-    if(c != '%'){
++-      consputc(c);
+ -      continue;
+--    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+--      state = states[p->state];
+--    else
+--      state = "???";
+--    cprintf("%d %s %s", p->pid, state, p->name);
+--    if(p->state == SLEEPING){
+--      getcallerpcs((uint*)p->context->ebp+2, pc);
+--      for(i=0; i<10 && pc[i] != 0; i++)
+--        cprintf(" %p", pc[i]);
+-+procdump(void) {
+-+    static char *states[] = {
+-+            [UNUSED]    "unused",
+-+            [EMBRYO]    "embryo",
+-+            [SLEEPING]  "sleep ",
+-+            [RUNNABLE]  "runble",
+-+            [RUNNING]   "run   ",
+-+            [ZOMBIE]    "zombie"
+-+    };
+-+    int i;
+-+    struct proc *p;
+-+    char *state;
+-+    uint pc[10];
+-+
+-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+-+        if (p->state == UNUSED)
+-+            continue;
+-+        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
+-+            state = states[p->state];
+-+        else
+-+            state = "???";
+-+        cprintf("%d %s %s", p->pid, state, p->name);
+-+        if (p->state == SLEEPING) {
+-+            getcallerpcs((uint *) p->context->ebp + 2, pc);
+-+            for (i = 0; i < 10 && pc[i] != 0; i++)
+-+                cprintf(" %p", pc[i]);
+-+        }
+-+        cprintf("\n");
+-     }
+--    cprintf("\n");
++-    }
++-    c = fmt[++i] & 0xff;
++-    if(c == 0)
++-      break;
++-    switch(c){
++-    case 'd':
++-      printint(*argp++, 10, 1);
++-      break;
++-    case 'x':
++-    case 'p':
++-      printint(*argp++, 16, 0);
++-      break;
++-    case 's':
++-      if((s = (char*)*argp++) == 0)
++-        s = "(null)";
++-      for(; *s; s++)
++-        consputc(*s);
++-      break;
++-    case '%':
++-      consputc('%');
++-      break;
++-    default:
++-      // Print unknown % sequence to draw attention.
++-      consputc('%');
++-      consputc(c);
++-      break;
++-    }
+ -  }
+- }
+-diff --git a/proc.h b/proc.h
+-index 1647114..a06b921 100644
+---- a/proc.h
+-+++ b/proc.h
+-@@ -49,6 +49,7 @@ struct proc {
+-   struct file *ofile[NOFILE];  // Open files
+-   struct inode *cwd;           // Current directory
+-   char name[16];               // Process name (debugging)
+-+  int status;                  // Exit status
+- };
+- 
+- // Process memory is laid out contiguously, low addresses first:
+-diff --git a/rm.c b/rm.c
+-index 4fd33c8..1e6daec 100644
+---- a/rm.c
+-+++ b/rm.c
+-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
+- 
+-   if(argc < 2){
+-     printf(2, "Usage: rm files...\n");
+--    exit();
+-+    exit(1);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
+-     }
+-   }
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/runoff b/runoff
+-old mode 100755
+-new mode 100644
+-diff --git a/runoff1 b/runoff1
+-old mode 100755
+-new mode 100644
+-diff --git a/sh.c b/sh.c
+-index 054bab9..ca2ae37 100644
+---- a/sh.c
+-+++ b/sh.c
+-@@ -65,7 +65,7 @@ runcmd(struct cmd *cmd)
+-   struct redircmd *rcmd;
+- 
+-   if(cmd == 0)
+--    exit();
+-+    exit(1);
+- 
+-   switch(cmd->type){
+-   default:
+-@@ -74,7 +74,7 @@ runcmd(struct cmd *cmd)
+-   case EXEC:
+-     ecmd = (struct execcmd*)cmd;
+-     if(ecmd->argv[0] == 0)
+--      exit();
+-+      exit(2);
+-     exec(ecmd->argv[0], ecmd->argv);
+-     printf(2, "exec %s failed\n", ecmd->argv[0]);
+-     break;
+-@@ -84,7 +84,7 @@ runcmd(struct cmd *cmd)
+-     close(rcmd->fd);
+-     if(open(rcmd->file, rcmd->mode) < 0){
+-       printf(2, "open %s failed\n", rcmd->file);
+--      exit();
+-+      exit(6);
+-     }
+-     runcmd(rcmd->cmd);
+-     break;
+-@@ -93,7 +93,7 @@ runcmd(struct cmd *cmd)
+-     lcmd = (struct listcmd*)cmd;
+-     if(fork1() == 0)
+-       runcmd(lcmd->left);
+--    wait();
+-+    wait(NULL);
+-     runcmd(lcmd->right);
+-     break;
+- 
+-@@ -117,8 +117,8 @@ runcmd(struct cmd *cmd)
+-     }
+-     close(p[0]);
+-     close(p[1]);
+--    wait();
+--    wait();
+-+    wait(NULL);
+-+    wait(NULL);
+-     break;
+- 
+-   case BACK:
+-@@ -127,7 +127,7 @@ runcmd(struct cmd *cmd)
+-       runcmd(bcmd->cmd);
+-     break;
+-   }
+--  exit();
+-+  exit(3);
+- }
+- 
+- int
+-@@ -166,16 +166,16 @@ main(void)
+-     }
+-     if(fork1() == 0)
+-       runcmd(parsecmd(buf));
+--    wait();
+-+    wait(NULL);
+-   }
+--  exit();
+-+  exit(0);
+- }
+- 
+- void
+- panic(char *s)
+- {
+-   printf(2, "%s\n", s);
+--  exit();
+-+  exit(5);
+- }
+- 
+- int
+-diff --git a/show1 b/show1
+-old mode 100755
+-new mode 100644
+-diff --git a/sign.pl b/sign.pl
+-old mode 100755
+-new mode 100644
+-diff --git a/spinp b/spinp
+-old mode 100755
+-new mode 100644
+-diff --git a/stressfs.c b/stressfs.c
+-index c0a4743..46e0e66 100644
+---- a/stressfs.c
+-+++ b/stressfs.c
+-@@ -43,7 +43,7 @@ main(int argc, char *argv[])
+-     read(fd, data, sizeof(data));
+-   close(fd);
+- 
+--  wait();
+-+  wait(NULL);
+- 
+--  exit();
+-+  exit(0);
+- }
+-diff --git a/syscall.c b/syscall.c
+-index ee85261..41a8c3c 100644
+---- a/syscall.c
+-+++ b/syscall.c
+-@@ -101,6 +101,7 @@ extern int sys_sbrk(void);
+- extern int sys_sleep(void);
+- extern int sys_unlink(void);
+- extern int sys_wait(void);
+-+extern int sys_waitpid(void);
+- extern int sys_write(void);
+- extern int sys_uptime(void);
+- 
+-@@ -108,6 +109,7 @@ static int (*syscalls[])(void) = {
+- [SYS_fork]    sys_fork,
+- [SYS_exit]    sys_exit,
+- [SYS_wait]    sys_wait,
+-+[SYS_waitpid] sys_waitpid,
+- [SYS_pipe]    sys_pipe,
+- [SYS_read]    sys_read,
+- [SYS_kill]    sys_kill,
+-diff --git a/syscall.h b/syscall.h
+-index bc5f356..374ff05 100644
+---- a/syscall.h
+-+++ b/syscall.h
+-@@ -1,22 +1,23 @@
+- // System call numbers
+--#define SYS_fork    1
+--#define SYS_exit    2
+--#define SYS_wait    3
+--#define SYS_pipe    4
+--#define SYS_read    5
+--#define SYS_kill    6
+--#define SYS_exec    7
+--#define SYS_fstat   8
+--#define SYS_chdir   9
+--#define SYS_dup    10
+--#define SYS_getpid 11
+--#define SYS_sbrk   12
+--#define SYS_sleep  13
+--#define SYS_uptime 14
+--#define SYS_open   15
+--#define SYS_write  16
+--#define SYS_mknod  17
+--#define SYS_unlink 18
+--#define SYS_link   19
+--#define SYS_mkdir  20
+--#define SYS_close  21
+-+#define SYS_fork     1
+-+#define SYS_exit     2
+-+#define SYS_wait     3
+-+#define SYS_pipe     4
+-+#define SYS_read     5
+-+#define SYS_kill     6
+-+#define SYS_exec     7
+-+#define SYS_fstat    8
+-+#define SYS_chdir    9
+-+#define SYS_dup     10
+-+#define SYS_getpid  11
+-+#define SYS_sbrk    12
+-+#define SYS_sleep   13
+-+#define SYS_uptime  14
+-+#define SYS_open    15
+-+#define SYS_write   16
+-+#define SYS_mknod   17
+-+#define SYS_unlink  18
+-+#define SYS_link    19
+-+#define SYS_mkdir   20
+-+#define SYS_close   21
+-+#define SYS_waitpid 22
+-\ No newline at end of file
+-diff --git a/sysproc.c b/sysproc.c
+-index 0686d29..ebccf84 100644
+---- a/sysproc.c
+-+++ b/sysproc.c
+-@@ -14,16 +14,22 @@ sys_fork(void)
+- }
+- 
+- int
+--sys_exit(void)
+-+sys_exit(int status)
+- {
+--  exit();
+-+  exit(status);
+-   return 0;  // not reached
+- }
+- 
+- int
+--sys_wait(void)
+-+sys_wait(int* status)
+- {
+--  return wait();
+-+  return wait(status);
++-
++-  if(locking)
++-    release(&cons.lock);
++-}
++-
++-void
++-panic(char *s)
++-{
++-  int i;
++-  uint pcs[10];
++-
++-  cli();
++-  cons.locking = 0;
++-  // use lapiccpunum so that we can call panic from mycpu()
++-  cprintf("lapicid %d: panic: ", lapicid());
++-  cprintf(s);
++-  cprintf("\n");
++-  getcallerpcs(&s, pcs);
++-  for(i=0; i<10; i++)
++-    cprintf(" %p", pcs[i]);
++-  panicked = 1; // freeze other CPU
++-  for(;;)
++-    ;
++-}
++-
++-//PAGEBREAK: 50
++-#define BACKSPACE 0x100
++-#define CRTPORT 0x3d4
++-static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
++-
++-static void
++-cgaputc(int c)
++-{
++-  int pos;
++-
++-  // Cursor position: col + 80*row.
++-  outb(CRTPORT, 14);
++-  pos = inb(CRTPORT+1) << 8;
++-  outb(CRTPORT, 15);
++-  pos |= inb(CRTPORT+1);
++-
++-  if(c == '\n')
++-    pos += 80 - pos%80;
++-  else if(c == BACKSPACE){
++-    if(pos > 0) --pos;
++-  } else
++-    crt[pos++] = (c&0xff) | 0x0700;  // black on white
++-
++-  if(pos < 0 || pos > 25*80)
++-    panic("pos under/overflow");
++-
++-  if((pos/80) >= 24){  // Scroll up.
++-    memmove(crt, crt+80, sizeof(crt[0])*23*80);
++-    pos -= 80;
++-    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
++-  }
++-
++-  outb(CRTPORT, 14);
++-  outb(CRTPORT+1, pos>>8);
++-  outb(CRTPORT, 15);
++-  outb(CRTPORT+1, pos);
++-  crt[pos] = ' ' | 0x0700;
++-}
++-
++-void
++-consputc(int c)
++-{
++-  if(panicked){
++-    cli();
++-    for(;;)
++-      ;
++-  }
++-
++-  if(c == BACKSPACE){
++-    uartputc('\b'); uartputc(' '); uartputc('\b');
++-  } else
++-    uartputc(c);
++-  cgaputc(c);
++-}
++-
++-#define INPUT_BUF 128
++-struct {
++-  char buf[INPUT_BUF];
++-  uint r;  // Read index
++-  uint w;  // Write index
++-  uint e;  // Edit index
++-} input;
++-
++-#define C(x)  ((x)-'@')  // Control-x
++-
++-void
++-consoleintr(int (*getc)(void))
++-{
++-  int c, doprocdump = 0;
++-
++-  acquire(&cons.lock);
++-  while((c = getc()) >= 0){
++-    switch(c){
++-    case C('P'):  // Process listing.
++-      // procdump() locks cons.lock indirectly; invoke later
++-      doprocdump = 1;
++-      break;
++-    case C('U'):  // Kill line.
++-      while(input.e != input.w &&
++-            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
++-        input.e--;
++-        consputc(BACKSPACE);
++-      }
++-      break;
++-    case C('H'): case '\x7f':  // Backspace
++-      if(input.e != input.w){
++-        input.e--;
++-        consputc(BACKSPACE);
++-      }
++-      break;
++-    default:
++-      if(c != 0 && input.e-input.r < INPUT_BUF){
++-        c = (c == '\r') ? '\n' : c;
++-        input.buf[input.e++ % INPUT_BUF] = c;
++-        consputc(c);
++-        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
++-          input.w = input.e;
++-          wakeup(&input.r);
++-        }
++-      }
++-      break;
++-    }
++-  }
++-  release(&cons.lock);
++-  if(doprocdump) {
++-    procdump();  // now call procdump() wo. cons.lock held
++-  }
++-}
++-
++-int
++-consoleread(struct inode *ip, char *dst, int n)
++-{
++-  uint target;
++-  int c;
++-
++-  iunlock(ip);
++-  target = n;
++-  acquire(&cons.lock);
++-  while(n > 0){
++-    while(input.r == input.w){
++-      if(myproc()->killed){
++-        release(&cons.lock);
++-        ilock(ip);
++-        return -1;
++-      }
++-      sleep(&input.r, &cons.lock);
++-    }
++-    c = input.buf[input.r++ % INPUT_BUF];
++-    if(c == C('D')){  // EOF
++-      if(n < target){
++-        // Save ^D for next time, to make sure
++-        // caller gets a 0-byte result.
++-        input.r--;
++-      }
++-      break;
++-    }
++-    *dst++ = c;
++-    --n;
++-    if(c == '\n')
++-      break;
++-  }
++-  release(&cons.lock);
++-  ilock(ip);
++-
++-  return target - n;
++-}
++-
++-int
++-consolewrite(struct inode *ip, char *buf, int n)
++-{
++-  int i;
++-
++-  iunlock(ip);
++-  acquire(&cons.lock);
++-  for(i = 0; i < n; i++)
++-    consputc(buf[i] & 0xff);
++-  release(&cons.lock);
++-  ilock(ip);
++-
++-  return n;
++-}
++-
++-void
++-consoleinit(void)
++-{
++-  initlock(&cons.lock, "console");
++-
++-  devsw[CONSOLE].write = consolewrite;
++-  devsw[CONSOLE].read = consoleread;
++-  cons.locking = 1;
++-
++-  ioapicenable(IRQ_KBD, 0);
++-}
++-
++diff --git a/cuth b/cuth
++deleted file mode 100644
++index cce8c0c..0000000
++--- a/cuth
+++++ /dev/null
++@@ -1,48 +0,0 @@
++-#!/usr/bin/perl
++-
++-$| = 1;
++-
++-sub writefile($@){
++-	my ($file, @lines) = @_;
++-	
++-	sleep(1);
++-	open(F, ">$file") || die "open >$file: $!";
++-	print F @lines;
++-	close(F);
++-}
++-
++-# Cut out #include lines that don't contribute anything.
++-for($i=0; $i<@ARGV; $i++){
++-	$file = $ARGV[$i];
++-	if(!open(F, $file)){
++-		print STDERR "open $file: $!\n";
++-		next;
++-	}
++-	@lines = <F>;
++-	close(F);
++-	
++-	$obj = "$file.o";
++-	$obj =~ s/\.c\.o$/.o/;
++-	system("touch $file");
++-
++-	if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
++-		print STDERR "make $obj failed: $rv\n";
++-		next;
++-	}
++-
++-	system("cp $file =$file");
++-	for($j=@lines-1; $j>=0; $j--){
++-		if($lines[$j] =~ /^#include/){
++-			$old = $lines[$j];
++-			$lines[$j] = "/* CUT-H */\n";
++-			writefile($file, @lines);
++-			if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
++-				$lines[$j] = $old;
++-			}else{
++-				print STDERR "$file $old";
++-			}
++-		}
++-	}
++-	writefile($file, grep {!/CUT-H/} @lines);
++-	system("rm =$file");
++-}
++diff --git a/date.h b/date.h
++deleted file mode 100644
++index 94aec4b..0000000
++--- a/date.h
+++++ /dev/null
++@@ -1,8 +0,0 @@
++-struct rtcdate {
++-  uint second;
++-  uint minute;
++-  uint hour;
++-  uint day;
++-  uint month;
++-  uint year;
++-};
++diff --git a/defs.h b/defs.h
++deleted file mode 100644
++index d1934ca..0000000
++--- a/defs.h
+++++ /dev/null
++@@ -1,191 +0,0 @@
++-struct buf;
++-struct context;
++-struct file;
++-struct inode;
++-struct pipe;
++-struct proc;
++-struct rtcdate;
++-struct spinlock;
++-struct sleeplock;
++-struct stat;
++-struct superblock;
++-
++-// bio.c
++-void            binit(void);
++-struct buf*     bread(uint, uint);
++-void            brelse(struct buf*);
++-void            bwrite(struct buf*);
++-
++-// console.c
++-void            consoleinit(void);
++-void            cprintf(char*, ...);
++-void            consoleintr(int(*)(void));
++-void            panic(char*) __attribute__((noreturn));
++-
++-// exec.c
++-int             exec(char*, char**);
++-
++-// file.c
++-struct file*    filealloc(void);
++-void            fileclose(struct file*);
++-struct file*    filedup(struct file*);
++-void            fileinit(void);
++-int             fileread(struct file*, char*, int n);
++-int             filestat(struct file*, struct stat*);
++-int             filewrite(struct file*, char*, int n);
++-
++-// fs.c
++-void            readsb(int dev, struct superblock *sb);
++-int             dirlink(struct inode*, char*, uint);
++-struct inode*   dirlookup(struct inode*, char*, uint*);
++-struct inode*   ialloc(uint, short);
++-struct inode*   idup(struct inode*);
++-void            iinit(int dev);
++-void            ilock(struct inode*);
++-void            iput(struct inode*);
++-void            iunlock(struct inode*);
++-void            iunlockput(struct inode*);
++-void            iupdate(struct inode*);
++-int             namecmp(const char*, const char*);
++-struct inode*   namei(char*);
++-struct inode*   nameiparent(char*, char*);
++-int             readi(struct inode*, char*, uint, uint);
++-void            stati(struct inode*, struct stat*);
++-int             writei(struct inode*, char*, uint, uint);
++-
++-// ide.c
++-void            ideinit(void);
++-void            ideintr(void);
++-void            iderw(struct buf*);
++-
++-// ioapic.c
++-void            ioapicenable(int irq, int cpu);
++-extern uchar    ioapicid;
++-void            ioapicinit(void);
++-
++-// kalloc.c
++-char*           kalloc(void);
++-void            kfree(char*);
++-void            kinit1(void*, void*);
++-void            kinit2(void*, void*);
++-
++-// kbd.c
++-void            kbdintr(void);
++-
++-// lapic.c
++-void            cmostime(struct rtcdate *r);
++-int             lapicid(void);
++-extern volatile uint*    lapic;
++-void            lapiceoi(void);
++-void            lapicinit(void);
++-void            lapicstartap(uchar, uint);
++-void            microdelay(int);
++-
++-// log.c
++-void            initlog(int dev);
++-void            log_write(struct buf*);
++-void            begin_op();
++-void            end_op();
++-
++-// mp.c
++-extern int      ismp;
++-void            mpinit(void);
++-
++-// picirq.c
++-void            picenable(int);
++-void            picinit(void);
++-
++-// pipe.c
++-int             pipealloc(struct file**, struct file**);
++-void            pipeclose(struct pipe*, int);
++-int             piperead(struct pipe*, char*, int);
++-int             pipewrite(struct pipe*, char*, int);
++-
++-//PAGEBREAK: 16
++-// proc.c
++-int             cpuid(void);
++-void            exit(int status);
++-int             fork(void);
++-int             growproc(int);
++-int             kill(int);
++-struct cpu*     mycpu(void);
++-struct proc*    myproc();
++-void            pinit(void);
++-void            procdump(void);
++-void            scheduler(void) __attribute__((noreturn));
++-void            sched(void);
++-void            setproc(struct proc*);
++-void            sleep(void*, struct spinlock*);
++-void            userinit(void);
++-int             wait(int* status);
++-int             waitpid(int pid, int* status, int options);
++-void            wakeup(void*);
++-void            yield(void);
++-
++-// swtch.S
++-void            swtch(struct context**, struct context*);
++-
++-// spinlock.c
++-void            acquire(struct spinlock*);
++-void            getcallerpcs(void*, uint*);
++-int             holding(struct spinlock*);
++-void            initlock(struct spinlock*, char*);
++-void            release(struct spinlock*);
++-void            pushcli(void);
++-void            popcli(void);
++-
++-// sleeplock.c
++-void            acquiresleep(struct sleeplock*);
++-void            releasesleep(struct sleeplock*);
++-int             holdingsleep(struct sleeplock*);
++-void            initsleeplock(struct sleeplock*, char*);
++-
++-// string.c
++-int             memcmp(const void*, const void*, uint);
++-void*           memmove(void*, const void*, uint);
++-void*           memset(void*, int, uint);
++-char*           safestrcpy(char*, const char*, int);
++-int             strlen(const char*);
++-int             strncmp(const char*, const char*, uint);
++-char*           strncpy(char*, const char*, int);
++-
++-// syscall.c
++-int             argint(int, int*);
++-int             argptr(int, char**, int);
++-int             argstr(int, char**);
++-int             fetchint(uint, int*);
++-int             fetchstr(uint, char**);
++-void            syscall(void);
++-
++-// timer.c
++-void            timerinit(void);
++-
++-// trap.c
++-void            idtinit(void);
++-extern uint     ticks;
++-void            tvinit(void);
++-extern struct spinlock tickslock;
++-
++-// uart.c
++-void            uartinit(void);
++-void            uartintr(void);
++-void            uartputc(int);
++-
++-// vm.c
++-void            seginit(void);
++-void            kvmalloc(void);
++-pde_t*          setupkvm(void);
++-char*           uva2ka(pde_t*, char*);
++-int             allocuvm(pde_t*, uint, uint);
++-int             deallocuvm(pde_t*, uint, uint);
++-void            freevm(pde_t*);
++-void            inituvm(pde_t*, char*, uint);
++-int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
++-pde_t*          copyuvm(pde_t*, uint);
++-void            switchuvm(struct proc*);
++-void            switchkvm(void);
++-int             copyout(pde_t*, uint, void*, uint);
++-void            clearpteu(pde_t *pgdir, char *uva);
++-
++-// number of elements in fixed-size array
++-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
++diff --git a/dot-bochsrc b/dot-bochsrc
++deleted file mode 100644
++index ba13db7..0000000
++--- a/dot-bochsrc
+++++ /dev/null
++@@ -1,738 +0,0 @@
++-# You may now use double quotes around pathnames, in case
++-# your pathname includes spaces.
++-
++-#=======================================================================
++-# CONFIG_INTERFACE
++-#
++-# The configuration interface is a series of menus or dialog boxes that
++-# allows you to change all the settings that control Bochs's behavior.
++-# There are two choices of configuration interface: a text mode version
++-# called "textconfig" and a graphical version called "wx".  The text
++-# mode version uses stdin/stdout and is always compiled in.  The graphical
++-# version is only available when you use "--with-wx" on the configure 
++-# command.  If you do not write a config_interface line, Bochs will 
++-# choose a default for you.
++-#
++-# NOTE: if you use the "wx" configuration interface, you must also use
++-# the "wx" display library.
++-#=======================================================================
++-#config_interface: textconfig
++-#config_interface: wx
++-
++-#=======================================================================
++-# DISPLAY_LIBRARY
++-#
++-# The display library is the code that displays the Bochs VGA screen.  Bochs 
++-# has a selection of about 10 different display library implementations for 
++-# different platforms.  If you run configure with multiple --with-* options, 
++-# the display_library command lets you choose which one you want to run with.
++-# If you do not write a display_library line, Bochs will choose a default for
++-# you.
++-#
++-# The choices are: 
++-#   x              use X windows interface, cross platform
++-#   win32          use native win32 libraries
++-#   carbon         use Carbon library (for MacOS X)
++-#   beos           use native BeOS libraries
++-#   macintosh      use MacOS pre-10
++-#   amigaos        use native AmigaOS libraries
++-#   sdl            use SDL library, cross platform
++-#   svga           use SVGALIB library for Linux, allows graphics without X11
++-#   term           text only, uses curses/ncurses library, cross platform
++-#   rfb            provides an interface to AT&T's VNC viewer, cross platform
++-#   wx             use wxWidgets library, cross platform
++-#   nogui          no display at all
++-#
++-# NOTE: if you use the "wx" configuration interface, you must also use
++-# the "wx" display library.
++-#
++-# Specific options:
++-# Some display libraries now support specific option to control their
++-# behaviour. See the examples below for currently supported options.
++-#=======================================================================
++-#display_library: amigaos
++-#display_library: beos
++-#display_library: carbon
++-#display_library: macintosh
++-#display_library: nogui
++-#display_library: rfb, options="timeout=60" # time to wait for client
++-#display_library: sdl, options="fullscreen" # startup in fullscreen mode
++-#display_library: term
++-#display_library: win32, options="legacyF12" # use F12 to toggle mouse
++-#display_library: wx
++-#display_library: x
++-
++-#=======================================================================
++-# ROMIMAGE:
++-# The ROM BIOS controls what the PC does when it first powers on.
++-# Normally, you can use a precompiled BIOS in the source or binary
++-# distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded
++-# starting at address 0xf0000, and it is exactly 64k long.
++-# You can also use the environment variable $BXSHARE to specify the
++-# location of the BIOS.
++-# The usage of external large BIOS images (up to 512k) at memory top is
++-# now supported, but we still recommend to use the BIOS distributed with
++-# Bochs. Now the start address can be calculated from image size.
++-#=======================================================================
++-romimage: file=$BXSHARE/BIOS-bochs-latest
++-#romimage: file=mybios.bin, address=0xfff80000 # 512k at memory top
++-#romimage: file=mybios.bin # calculate start address from image size
++-
++-#=======================================================================
++-# CPU:
++-# This defines cpu-related parameters inside Bochs:
++-#
++-#  COUNT:
++-#  Set the number of processors when Bochs is compiled for SMP emulation.
++-#  Bochs currently supports up to 8 processors. If Bochs is compiled
++-#  without SMP support, it won't accept values different from 1.
++-#
++-#  IPS:
++-#  Emulated Instructions Per Second.  This is the number of IPS that bochs
++-#  is capable of running on your machine. You can recompile Bochs with
++-#  --enable-show-ips option enabled, to find your workstation's capability.
++-#  Measured IPS value will then be logged into your log file or status bar
++-#  (if supported by the gui).
++-#
++-#  IPS is used to calibrate many time-dependent events within the bochs 
++-#  simulation.  For example, changing IPS affects the frequency of VGA
++-#  updates, the duration of time before a key starts to autorepeat, and
++-#  the measurement of BogoMips and other benchmarks.
++-#
++-#  Examples:
++-#  Machine                                         Mips
++-# ________________________________________________________________
++-#  2.1Ghz Athlon XP with Linux 2.6/g++ 3.4         12 to 15 Mips
++-#  1.6Ghz Intel P4 with Win2000/g++ 3.3             5 to  7 Mips
++-#  650Mhz Athlon K-7 with Linux 2.4.4/egcs-2.91.66  2 to  2.5 Mips
++-#  400Mhz Pentium II with Linux 2.0.36/egcs-1.0.3   1 to  1.8 Mips
++-#=======================================================================
++-cpu: count=2, ips=10000000
++-
++-#=======================================================================
++-# MEGS
++-# Set the number of Megabytes of physical memory you want to emulate. 
++-# The default is 32MB, most OS's won't need more than that.
++-# The maximum amount of memory supported is 2048Mb.
++-#=======================================================================
++-#megs: 256
++-#megs: 128
++-#megs: 64
++-megs: 32
++-#megs: 16
++-#megs: 8
++-
++-#=======================================================================
++-# OPTROMIMAGE[1-4]:
++-# You may now load up to 4 optional ROM images. Be sure to use a 
++-# read-only area, typically between C8000 and EFFFF. These optional
++-# ROM images should not overwrite the rombios (located at
++-# F0000-FFFFF) and the videobios (located at C0000-C7FFF).
++-# Those ROM images will be initialized by the bios if they contain 
++-# the right signature (0x55AA) and a valid checksum.
++-# It can also be a convenient way to upload some arbitrary code/data
++-# in the simulation, that can be retrieved by the boot loader
++-#=======================================================================
++-#optromimage1: file=optionalrom.bin, address=0xd0000
++-#optromimage2: file=optionalrom.bin, address=0xd1000
++-#optromimage3: file=optionalrom.bin, address=0xd2000
++-#optromimage4: file=optionalrom.bin, address=0xd3000
++-
++-#optramimage1: file=/path/file1.img, address=0x0010000
++-#optramimage2: file=/path/file2.img, address=0x0020000
++-#optramimage3: file=/path/file3.img, address=0x0030000
++-#optramimage4: file=/path/file4.img, address=0x0040000
++-
++-#=======================================================================
++-# VGAROMIMAGE
++-# You now need to load a VGA ROM BIOS into C0000.
++-#=======================================================================
++-#vgaromimage: file=bios/VGABIOS-elpin-2.40
++-vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
++-#vgaromimage: file=bios/VGABIOS-lgpl-latest-cirrus
++-
++-#=======================================================================
++-# VGA:
++-# Here you can specify the display extension to be used. With the value
++-# 'none' you can use standard VGA with no extension. Other supported
++-# values are 'vbe' for Bochs VBE and 'cirrus' for Cirrus SVGA support.
++-#=======================================================================
++-#vga: extension=cirrus
++-#vga: extension=vbe
++-vga: extension=none
++-
++-#=======================================================================
++-# FLOPPYA:
++-# Point this to pathname of floppy image file or device
++-# This should be of a bootable floppy(image/device) if you're
++-# booting from 'a' (or 'floppy').
++-#
++-# You can set the initial status of the media to 'ejected' or 'inserted'.
++-#   floppya: 2_88=path, status=ejected             (2.88M 3.5" floppy)
++-#   floppya: 1_44=path, status=inserted            (1.44M 3.5" floppy)
++-#   floppya: 1_2=path, status=ejected              (1.2M  5.25" floppy)
++-#   floppya: 720k=path, status=inserted            (720K  3.5" floppy)
++-#   floppya: 360k=path, status=inserted            (360K  5.25" floppy)
++-#   floppya: 320k=path, status=inserted            (320K  5.25" floppy)
++-#   floppya: 180k=path, status=inserted            (180K  5.25" floppy)
++-#   floppya: 160k=path, status=inserted            (160K  5.25" floppy)
++-#   floppya: image=path, status=inserted           (guess type from image size)
++-#
++-# The path should be the name of a disk image file.  On Unix, you can use a raw
++-# device name such as /dev/fd0 on Linux.  On win32 platforms, use drive letters
++-# such as a: or b: as the path.  The parameter 'image' works with image files
++-# only. In that case the size must match one of the supported types.
++-#=======================================================================
++-floppya: 1_44=/dev/fd0, status=inserted
++-#floppya: image=../1.44, status=inserted
++-#floppya: 1_44=/dev/fd0H1440, status=inserted
++-#floppya: 1_2=../1_2, status=inserted
++-#floppya: 1_44=a:, status=inserted
++-#floppya: 1_44=a.img, status=inserted
++-#floppya: 1_44=/dev/rfd0a, status=inserted
++-
++-#=======================================================================
++-# FLOPPYB:
++-# See FLOPPYA above for syntax
++-#=======================================================================
++-#floppyb: 1_44=b:, status=inserted
++-floppyb: 1_44=b.img, status=inserted
++-
++-#=======================================================================
++-# ATA0, ATA1, ATA2, ATA3
++-# ATA controller for hard disks and cdroms
++-#
++-# ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
++-# 
++-# These options enables up to 4 ata channels. For each channel
++-# the two base io addresses and the irq must be specified.
++-# 
++-# ata0 and ata1 are enabled by default with the values shown below
++-#
++-# Examples:
++-#   ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
++-#   ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
++-#   ata2: enabled=1, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
++-#   ata3: enabled=1, ioaddr1=0x168, ioaddr2=0x360, irq=9
++-#=======================================================================
++-ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
++-ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
++-ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
++-ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9
++-
++-#=======================================================================
++-# ATA[0-3]-MASTER, ATA[0-3]-SLAVE
++-#
++-# This defines the type and characteristics of all attached ata devices:
++-#   type=       type of attached device [disk|cdrom] 
++-#   mode=       only valid for disks [flat|concat|external|dll|sparse|vmware3]
++-#   mode=       only valid for disks [undoable|growing|volatile]
++-#   path=       path of the image
++-#   cylinders=  only valid for disks
++-#   heads=      only valid for disks
++-#   spt=        only valid for disks
++-#   status=     only valid for cdroms [inserted|ejected]
++-#   biosdetect= type of biosdetection [none|auto], only for disks on ata0 [cmos]
++-#   translation=type of translation of the bios, only for disks [none|lba|large|rechs|auto]
++-#   model=      string returned by identify device command
++-#   journal=    optional filename of the redolog for undoable and volatile disks
++-#   
++-# Point this at a hard disk image file, cdrom iso file, or physical cdrom
++-# device.  To create a hard disk image, try running bximage.  It will help you
++-# choose the size and then suggest a line that works with it.
++-#
++-# In UNIX it may be possible to use a raw device as a Bochs hard disk, 
++-# but WE DON'T RECOMMEND IT.  In Windows there is no easy way.
++-#
++-# In windows, the drive letter + colon notation should be used for cdroms.
++-# Depending on versions of windows and drivers, you may only be able to 
++-# access the "first" cdrom in the system.  On MacOSX, use path="drive"
++-# to access the physical drive.
++-#
++-# The path is always mandatory. For flat hard disk images created with
++-# bximage geometry autodetection can be used (cylinders=0 -> cylinders are
++-# calculated using heads=16 and spt=63). For other hard disk images and modes
++-# the cylinders, heads, and spt are mandatory.
++-#
++-# Default values are:
++-#   mode=flat, biosdetect=auto, translation=auto, model="Generic 1234"
++-#
++-# The biosdetect option has currently no effect on the bios
++-#
++-# Examples:
++-#   ata0-master: type=disk, mode=flat, path=10M.sample, cylinders=306, heads=4, spt=17
++-#   ata0-slave:  type=disk, mode=flat, path=20M.sample, cylinders=615, heads=4, spt=17
++-#   ata1-master: type=disk, mode=flat, path=30M.sample, cylinders=615, heads=6, spt=17
++-#   ata1-slave:  type=disk, mode=flat, path=46M.sample, cylinders=940, heads=6, spt=17
++-#   ata2-master: type=disk, mode=flat, path=62M.sample, cylinders=940, heads=8, spt=17
++-#   ata2-slave:  type=disk, mode=flat, path=112M.sample, cylinders=900, heads=15, spt=17
++-#   ata3-master: type=disk, mode=flat, path=483M.sample, cylinders=1024, heads=15, spt=63
++-#   ata3-slave:  type=cdrom, path=iso.sample, status=inserted
++-#=======================================================================
++-ata0-master: type=disk, mode=flat, path="xv6.img", cylinders=100, heads=10, spt=10
++-ata0-slave: type=disk, mode=flat, path="fs.img", cylinders=1024, heads=1, spt=1
++-#ata0-slave: type=cdrom, path=D:, status=inserted
++-#ata0-slave: type=cdrom, path=/dev/cdrom, status=inserted
++-#ata0-slave: type=cdrom, path="drive", status=inserted
++-#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted 
++-
++-#=======================================================================
++-# BOOT:
++-# This defines the boot sequence. Now you can specify up to 3 boot drives.
++-# You can either boot from 'floppy', 'disk' or 'cdrom'
++-# legacy 'a' and 'c' are also supported
++-# Examples:
++-#   boot: floppy
++-#   boot: disk
++-#   boot: cdrom
++-#   boot: c
++-#   boot: a
++-#   boot: cdrom, floppy, disk
++-#=======================================================================
++-#boot: floppy
++-boot: disk
++-
++-#=======================================================================
++-# CLOCK:
++-# This defines the parameters of the clock inside Bochs:
++-#
++-#  SYNC:
++-#  TO BE COMPLETED (see Greg explanation in feature request #536329)
++-#
++-#  TIME0:
++-#  Specifies the start (boot) time of the virtual machine. Use a time 
++-#  value as returned by the time(2) system call. If no time0 value is 
++-#  set or if time0 equal to 1 (special case) or if time0 equal 'local', 
++-#  the simulation will be started at the current local host time.
++-#  If time0 equal to 2 (special case) or if time0 equal 'utc',
++-#  the simulation will be started at the current utc time.
++-#
++-# Syntax:
++-#  clock: sync=[none|slowdown|realtime|both], time0=[timeValue|local|utc]
++-#
++-# Example:
++-#   clock: sync=none,     time0=local       # Now (localtime)
++-#   clock: sync=slowdown, time0=315529200   # Tue Jan  1 00:00:00 1980
++-#   clock: sync=none,     time0=631148400   # Mon Jan  1 00:00:00 1990
++-#   clock: sync=realtime, time0=938581955   # Wed Sep 29 07:12:35 1999
++-#   clock: sync=realtime, time0=946681200   # Sat Jan  1 00:00:00 2000
++-#   clock: sync=none,     time0=1           # Now (localtime)
++-#   clock: sync=none,     time0=utc         # Now (utc/gmt)
++-# 
++-# Default value are sync=none, time0=local
++-#=======================================================================
++-#clock: sync=none, time0=local
++-
++-
++-#=======================================================================
++-# FLOPPY_BOOTSIG_CHECK: disabled=[0|1]
++-# Enables or disables the 0xaa55 signature check on boot floppies
++-# Defaults to disabled=0
++-# Examples:
++-#   floppy_bootsig_check: disabled=0
++-#   floppy_bootsig_check: disabled=1
++-#=======================================================================
++-#floppy_bootsig_check: disabled=1
++-floppy_bootsig_check: disabled=0
++-
++-#=======================================================================
++-# LOG:
++-# Give the path of the log file you'd like Bochs debug and misc. verbiage
++-# to be written to. If you don't use this option or set the filename to
++-# '-' the output is written to the console. If you really don't want it,
++-# make it "/dev/null" (Unix) or "nul" (win32). :^(
++-#
++-# Examples:
++-#   log: ./bochs.out
++-#   log: /dev/tty
++-#=======================================================================
++-#log: /dev/null
++-log: bochsout.txt
++-
++-#=======================================================================
++-# LOGPREFIX:
++-# This handles the format of the string prepended to each log line.
++-# You may use those special tokens :
++-#   %t : 11 decimal digits timer tick
++-#   %i : 8 hexadecimal digits of cpu current eip (ignored in SMP configuration)
++-#   %e : 1 character event type ('i'nfo, 'd'ebug, 'p'anic, 'e'rror)
++-#   %d : 5 characters string of the device, between brackets
++-# 
++-# Default : %t%e%d
++-# Examples:
++-#   logprefix: %t-%e-@%i-%d
++-#   logprefix: %i%e%d
++-#=======================================================================
++-#logprefix: %t%e%d
++-
++-#=======================================================================
++-# LOG CONTROLS
++-#
++-# Bochs now has four severity levels for event logging.
++-#   panic: cannot proceed.  If you choose to continue after a panic, 
++-#          don't be surprised if you get strange behavior or crashes.
++-#   error: something went wrong, but it is probably safe to continue the
++-#          simulation.
++-#   info: interesting or useful messages.
++-#   debug: messages useful only when debugging the code.  This may
++-#          spit out thousands per second.
++-#
++-# For events of each level, you can choose to crash, report, or ignore.
++-# TODO: allow choice based on the facility: e.g. crash on panics from
++-#       everything except the cdrom, and only report those.
++-#
++-# If you are experiencing many panics, it can be helpful to change
++-# the panic action to report instead of fatal.  However, be aware
++-# that anything executed after a panic is uncharted territory and can 
++-# cause bochs to become unstable.  The panic is a "graceful exit," so
++-# if you disable it you may get a spectacular disaster instead.
++-#=======================================================================
++-panic: action=ask
++-error: action=report
++-info: action=report
++-debug: action=ignore
++-#pass: action=fatal
++-
++-#=======================================================================
++-# DEBUGGER_LOG:
++-# Give the path of the log file you'd like Bochs to log debugger output.
++-# If you really don't want it, make it /dev/null or '-'. :^(
++-#
++-# Examples:
++-#   debugger_log: ./debugger.out
++-#=======================================================================
++-#debugger_log: /dev/null
++-#debugger_log: debugger.out
++-debugger_log: -
++-
++-#=======================================================================
++-# COM1, COM2, COM3, COM4:
++-# This defines a serial port (UART type 16550A). In the 'term' you can specify
++-# a device to use as com1. This can be a real serial line, or a pty.  To use
++-# a pty (under X/Unix), create two windows (xterms, usually).  One of them will
++-# run bochs, and the other will act as com1. Find out the tty the com1
++-# window using the `tty' command, and use that as the `dev' parameter.
++-# Then do `sleep 1000000' in the com1 window to keep the shell from
++-# messing with things, and run bochs in the other window.  Serial I/O to
++-# com1 (port 0x3f8) will all go to the other window.
++-# Other serial modes are 'null' (no input/output), 'file' (output to a file
++-# specified as the 'dev' parameter), 'raw' (use the real serial port - under
++-# construction for win32), 'mouse' (standard serial mouse - requires
++-# mouse option setting 'type=serial' or 'type=serial_wheel') and 'socket'
++-# (connect a networking socket).
++-#
++-# Examples:
++-#   com1: enabled=1, mode=null
++-#   com1: enabled=1, mode=mouse
++-#   com2: enabled=1, mode=file, dev=serial.out
++-#   com3: enabled=1, mode=raw, dev=com1
++-#   com3: enabled=1, mode=socket, dev=localhost:8888
++-#=======================================================================
++-#com1: enabled=1, mode=term, dev=/dev/ttyp9
++-
++-
++-#=======================================================================
++-# PARPORT1, PARPORT2:
++-# This defines a parallel (printer) port. When turned on and an output file is
++-# defined the emulated printer port sends characters printed by the guest OS
++-# into the output file. On some platforms a device filename can be used to
++-# send the data to the real parallel port (e.g. "/dev/lp0" on Linux, "lpt1" on
++-# win32 platforms).
++-#
++-# Examples:
++-#   parport1: enabled=1, file="parport.out"
++-#   parport2: enabled=1, file="/dev/lp0"
++-#   parport1: enabled=0
++-#=======================================================================
++-parport1: enabled=1, file="/dev/stdout"
++-
++-#=======================================================================
++-# SB16:
++-# This defines the SB16 sound emulation. It can have several of the
++-# following properties.
++-# All properties are in the format sb16: property=value
++-# midi: The filename is where the midi data is sent. This can be a
++-#       device or just a file if you want to record the midi data.
++-# midimode:
++-#      0=no data
++-#      1=output to device (system dependent. midi denotes the device driver)
++-#      2=SMF file output, including headers
++-#      3=output the midi data stream to the file (no midi headers and no
++-#        delta times, just command and data bytes)
++-# wave: This is the device/file where wave output is stored
++-# wavemode:
++-#      0=no data
++-#      1=output to device (system dependent. wave denotes the device driver)
++-#      2=VOC file output, incl. headers
++-#      3=output the raw wave stream to the file
++-# log:  The file to write the sb16 emulator messages to.
++-# loglevel:
++-#      0=no log
++-#      1=resource changes, midi program and bank changes
++-#      2=severe errors
++-#      3=all errors
++-#      4=all errors plus all port accesses
++-#      5=all errors and port accesses plus a lot of extra info
++-# dmatimer:
++-#      microseconds per second for a DMA cycle.  Make it smaller to fix
++-#      non-continuous sound.  750000 is usually a good value.  This needs a
++-#      reasonably correct setting for the IPS parameter of the CPU option.
++-#
++-# For an example look at the next line:
++-#=======================================================================
++-
++-#sb16: midimode=1, midi=/dev/midi00, wavemode=1, wave=/dev/dsp, loglevel=2, log=sb16.log, dmatimer=600000
++-
++-#=======================================================================
++-# VGA_UPDATE_INTERVAL:
++-# Video memory is scanned for updates and screen updated every so many
++-# virtual seconds.  The default is 40000, about 25Hz. Keep in mind that
++-# you must tweak the 'cpu: ips=N' directive to be as close to the number
++-# of emulated instructions-per-second your workstation can do, for this
++-# to be accurate.
++-#
++-# Examples:
++-#   vga_update_interval: 250000
++-#=======================================================================
++-vga_update_interval: 300000
++-
++-# using for Winstone '98 tests
++-#vga_update_interval:  100000
++-
++-#=======================================================================
++-# KEYBOARD_SERIAL_DELAY:
++-# Approximate time in microseconds that it takes one character to
++-# be transfered from the keyboard to controller over the serial path.
++-# Examples:
++-#   keyboard_serial_delay: 200
++-#=======================================================================
++-keyboard_serial_delay: 250
++-
++-#=======================================================================
++-# KEYBOARD_PASTE_DELAY:
++-# Approximate time in microseconds between attempts to paste
++-# characters to the keyboard controller. This leaves time for the
++-# guest os to deal with the flow of characters.  The ideal setting
++-# depends on how your operating system processes characters.  The
++-# default of 100000 usec (.1 seconds) was chosen because it works 
++-# consistently in Windows.
++-#
++-# If your OS is losing characters during a paste, increase the paste
++-# delay until it stops losing characters.
++-#
++-# Examples:
++-#   keyboard_paste_delay: 100000
++-#=======================================================================
++-keyboard_paste_delay: 100000
++-
++-#=======================================================================
++-# MOUSE: 
++-# This option prevents Bochs from creating mouse "events" unless a mouse
++-# is  enabled. The hardware emulation itself is not disabled by this.
++-# You can turn the mouse on by setting enabled to 1, or turn it off by
++-# setting enabled to 0. Unless you have a particular reason for enabling
++-# the mouse by default, it is recommended that you leave it off.
++-# You can also toggle the mouse usage at runtime (control key + middle
++-# mouse button on X11, SDL, wxWidgets and Win32).
++-# With the mouse type option you can select the type of mouse to emulate.
++-# The default value is 'ps2'. The other choices are 'imps2' (wheel mouse
++-# on PS/2), 'serial', 'serial_wheel' (one com port requires setting
++-# 'mode=mouse') and 'usb' (3-button mouse - one of the USB ports must be
++-# connected with the 'mouse' device - requires PCI and USB support).
++-#
++-# Examples:
++-#   mouse: enabled=1
++-#   mouse: enabled=1, type=imps2
++-#   mouse: enabled=1, type=serial
++-#   mouse: enabled=0
++-#=======================================================================
++-mouse: enabled=0
++-
++-#=======================================================================
++-# private_colormap: Request that the GUI create and use it's own
++-#                   non-shared colormap.  This colormap will be used
++-#                   when in the bochs window.  If not enabled, a
++-#                   shared colormap scheme may be used.  Not implemented
++-#                   on all GUI's.
++-#
++-# Examples:
++-#   private_colormap: enabled=1
++-#   private_colormap: enabled=0
++-#=======================================================================
++-private_colormap: enabled=0
++-
++-#=======================================================================
++-# fullscreen: ONLY IMPLEMENTED ON AMIGA
++-#             Request that Bochs occupy the entire screen instead of a 
++-#             window.
++-#
++-# Examples:
++-#   fullscreen: enabled=0
++-#   fullscreen: enabled=1
++-#=======================================================================
++-#fullscreen: enabled=0
++-#screenmode: name="sample"
++-
++-#=======================================================================
++-# ne2k: NE2000 compatible ethernet adapter
++-#
++-# Examples:
++-# ne2k: ioaddr=IOADDR, irq=IRQ, mac=MACADDR, ethmod=MODULE, ethdev=DEVICE, script=SCRIPT
++-#
++-# ioaddr, irq: You probably won't need to change ioaddr and irq, unless there
++-# are IRQ conflicts.
++-#
++-# mac: The MAC address MUST NOT match the address of any machine on the net.
++-# Also, the first byte must be an even number (bit 0 set means a multicast
++-# address), and you cannot use ff:ff:ff:ff:ff:ff because that's the broadcast
++-# address.  For the ethertap module, you must use fe:fd:00:00:00:01.  There may
++-# be other restrictions too.  To be safe, just use the b0:c4... address.
++-#
++-# ethdev: The ethdev value is the name of the network interface on your host
++-# platform.  On UNIX machines, you can get the name by running ifconfig.  On
++-# Windows machines, you must run niclist to get the name of the ethdev.
++-# Niclist source code is in misc/niclist.c and it is included in Windows 
++-# binary releases.
++-#
++-# script: The script value is optional, and is the name of a script that 
++-# is executed after bochs initialize the network interface. You can use 
++-# this script to configure this network interface, or enable masquerading.
++-# This is mainly useful for the tun/tap devices that only exist during
++-# Bochs execution. The network interface name is supplied to the script
++-# as first parameter
++-#
++-# If you don't want to make connections to any physical networks,
++-# you can use the following 'ethmod's to simulate a virtual network.
++-#   null: All packets are discarded, but logged to a few files.
++-#   arpback: ARP is simulated. Disabled by default.
++-#   vde:  Virtual Distributed Ethernet
++-#   vnet: ARP, ICMP-echo(ping), DHCP and read/write TFTP are simulated.
++-#         The virtual host uses 192.168.10.1.
++-#         DHCP assigns 192.168.10.2 to the guest.
++-#         TFTP uses the ethdev value for the root directory and doesn't
++-#         overwrite files.
++-#
++-#=======================================================================
++-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=fbsd, ethdev=en0 #macosx
++-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=fbsd, ethdev=xl0
++-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=linux, ethdev=eth0
++-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=win32, ethdev=MYCARD
++-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tap, ethdev=tap0
++-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tuntap, ethdev=/dev/net/tun0, script=./tunconfig
++-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=null, ethdev=eth0
++-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vde, ethdev="/tmp/vde.ctl"
++-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vnet, ethdev="c:/temp"
++-
++-#=======================================================================
++-# KEYBOARD_MAPPING:
++-# This enables a remap of a physical localized keyboard to a 
++-# virtualized us keyboard, as the PC architecture expects.
++-# If enabled, the keymap file must be specified.
++-# 
++-# Examples:
++-#   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
++-#=======================================================================
++-keyboard_mapping: enabled=0, map=
++-
++-#=======================================================================
++-# KEYBOARD_TYPE:
++-# Type of keyboard return by a "identify keyboard" command to the
++-# keyboard controler. It must be one of "xt", "at" or "mf".
++-# Defaults to "mf". It should be ok for almost everybody. A known
++-# exception is french macs, that do have a "at"-like keyboard.
++-#
++-# Examples:
++-#   keyboard_type: mf
++-#=======================================================================
++-#keyboard_type: mf
++-
++-#=======================================================================
++-# USER_SHORTCUT:
++-# This defines the keyboard shortcut to be sent when you press the "user"
++-# button in the headerbar. The shortcut string is a combination of maximum
++-# 3 key names (listed below) separated with a '-' character. The old-style
++-# syntax (without the '-') still works for the key combinations supported
++-# in Bochs 2.2.1.
++-# Valid key names:
++-# "alt", "bksl", "bksp", "ctrl", "del", "down", "end", "enter", "esc",
++-# "f1", ... "f12", "home", "ins", "left", "menu", "minus", "pgdwn", "pgup",
++-# "plus", "right", "shift", "space", "tab", "up", and "win".
++-#
++-# Example:
++-#   user_shortcut: keys=ctrl-alt-del
++-#=======================================================================
++-#user_shortcut: keys=ctrl-alt-del
++-
++-#=======================================================================
++-# I440FXSUPPORT:
++-# This option controls the presence of the i440FX PCI chipset. You can
++-# also specify the devices connected to PCI slots. Up to 5 slots are
++-# available now. These devices are currently supported: ne2k, pcivga,
++-# pcidev and pcipnic. If Bochs is compiled with Cirrus SVGA support
++-# you'll have the additional choice 'cirrus'.
++-#
++-# Example:
++-#   i440fxsupport: enabled=1, slot1=pcivga, slot2=ne2k
++-#=======================================================================
++-#i440fxsupport: enabled=1
++-
++-#=======================================================================
++-# USB1:
++-# This option controls the presence of the USB root hub which is a part
++-# of the i440FX PCI chipset. With the portX option you can connect devices
++-# to the hub (currently supported: 'mouse' and 'keypad'). If you connect
++-# the mouse to one of the ports and use the mouse option 'type=usb' you'll
++-# have a 3-button USB mouse.
++-#
++-# Example:
++-#   usb1: enabled=1, port1=mouse, port2=keypad
++-#=======================================================================
++-#usb1: enabled=1
++-
++-#=======================================================================
++-# CMOSIMAGE:
++-# This defines image file that can be loaded into the CMOS RAM at startup.
++-# The rtc_init parameter controls whether initialize the RTC with values stored
++-# in the image. By default the time0 argument given to the clock option is used.
++-# With 'rtc_init=image' the image is the source for the initial time.
++-#
++-# Example:
++-#   cmosimage: file=cmos.img, rtc_init=image
++-#=======================================================================
++-#cmosimage: file=cmos.img, rtc_init=time0
++-
++-#=======================================================================
++-# other stuff
++-#=======================================================================
++-#magic_break: enabled=1
++-#load32bitOSImage: os=nullkernel, path=../kernel.img, iolog=../vga_io.log
++-#load32bitOSImage: os=linux, path=../linux.img, iolog=../vga_io.log, initrd=../initrd.img
++-#text_snapshot_check: enable
++-
++-#-------------------------
++-# PCI host device mapping
++-#-------------------------
++-#pcidev: vendor=0x1234, device=0x5678
++-
++-#=======================================================================
++-# GDBSTUB:
++-# Enable GDB stub. See user documentation for details.
++-# Default value is enabled=0.
++-#=======================================================================
++-#gdbstub: enabled=0, port=1234, text_base=0, data_base=0, bss_base=0
++-
++-#=======================================================================
++-# IPS:
++-# The IPS directive is DEPRECATED. Use the parameter IPS of the CPU
++-# directive instead.
++-#=======================================================================
++-#ips: 10000000
++-
++-#=======================================================================
++-# for Macintosh, use the style of pathnames in the following
++-# examples.
++-#
++-# vgaromimage: :bios:VGABIOS-elpin-2.40
++-# romimage: file=:bios:BIOS-bochs-latest, address=0xf0000
++-# floppya: 1_44=[fd:], status=inserted
++-#=======================================================================
++diff --git a/echo.c b/echo.c
++deleted file mode 100644
++index eed68a0..0000000
++--- a/echo.c
+++++ /dev/null
++@@ -1,13 +0,0 @@
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-
++-int
++-main(int argc, char *argv[])
++-{
++-  int i;
++-
++-  for(i = 1; i < argc; i++)
++-    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
++-  exit(0);
++-}
++diff --git a/elf.h b/elf.h
++deleted file mode 100644
++index d16c967..0000000
++--- a/elf.h
+++++ /dev/null
++@@ -1,42 +0,0 @@
++-// Format of an ELF executable file
++-
++-#define ELF_MAGIC 0x464C457FU  // "\x7FELF" in little endian
++-
++-// File header
++-struct elfhdr {
++-  uint magic;  // must equal ELF_MAGIC
++-  uchar elf[12];
++-  ushort type;
++-  ushort machine;
++-  uint version;
++-  uint entry;
++-  uint phoff;
++-  uint shoff;
++-  uint flags;
++-  ushort ehsize;
++-  ushort phentsize;
++-  ushort phnum;
++-  ushort shentsize;
++-  ushort shnum;
++-  ushort shstrndx;
++-};
++-
++-// Program section header
++-struct proghdr {
++-  uint type;
++-  uint off;
++-  uint vaddr;
++-  uint paddr;
++-  uint filesz;
++-  uint memsz;
++-  uint flags;
++-  uint align;
++-};
++-
++-// Values for Proghdr type
++-#define ELF_PROG_LOAD           1
++-
++-// Flag bits for Proghdr flags
++-#define ELF_PROG_FLAG_EXEC      1
++-#define ELF_PROG_FLAG_WRITE     2
++-#define ELF_PROG_FLAG_READ      4
++diff --git a/entry.S b/entry.S
++deleted file mode 100644
++index bc79bab..0000000
++--- a/entry.S
+++++ /dev/null
++@@ -1,68 +0,0 @@
++-# The xv6 kernel starts executing in this file. This file is linked with
++-# the kernel C code, so it can refer to kernel symbols such as main().
++-# The boot block (bootasm.S and bootmain.c) jumps to entry below.
++-        
++-# Multiboot header, for multiboot boot loaders like GNU Grub.
++-# http://www.gnu.org/software/grub/manual/multiboot/multiboot.html
++-#
++-# Using GRUB 2, you can boot xv6 from a file stored in a
++-# Linux file system by copying kernel or kernelmemfs to /boot
++-# and then adding this menu entry:
++-#
++-# menuentry "xv6" {
++-# 	insmod ext2
++-# 	set root='(hd0,msdos1)'
++-# 	set kernel='/boot/kernel'
++-# 	echo "Loading ${kernel}..."
++-# 	multiboot ${kernel} ${kernel}
++-# 	boot
++-# }
++-
++-#include "asm.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-#include "param.h"
++-
++-# Multiboot header.  Data to direct multiboot loader.
++-.p2align 2
++-.text
++-.globl multiboot_header
++-multiboot_header:
++-  #define magic 0x1badb002
++-  #define flags 0
++-  .long magic
++-  .long flags
++-  .long (-magic-flags)
++-
++-# By convention, the _start symbol specifies the ELF entry point.
++-# Since we haven't set up virtual memory yet, our entry point is
++-# the physical address of 'entry'.
++-.globl _start
++-_start = V2P_WO(entry)
++-
++-# Entering xv6 on boot processor, with paging off.
++-.globl entry
++-entry:
++-  # Turn on page size extension for 4Mbyte pages
++-  movl    %cr4, %eax
++-  orl     $(CR4_PSE), %eax
++-  movl    %eax, %cr4
++-  # Set page directory
++-  movl    $(V2P_WO(entrypgdir)), %eax
++-  movl    %eax, %cr3
++-  # Turn on paging.
++-  movl    %cr0, %eax
++-  orl     $(CR0_PG|CR0_WP), %eax
++-  movl    %eax, %cr0
++-
++-  # Set up the stack pointer.
++-  movl $(stack + KSTACKSIZE), %esp
++-
++-  # Jump to main(), and switch to executing at
++-  # high addresses. The indirect call is needed because
++-  # the assembler produces a PC-relative instruction
++-  # for a direct jump.
++-  mov $main, %eax
++-  jmp *%eax
++-
++-.comm stack, KSTACKSIZE
++diff --git a/entryother.S b/entryother.S
++deleted file mode 100644
++index a3b6dc2..0000000
++--- a/entryother.S
+++++ /dev/null
++@@ -1,93 +0,0 @@
++-#include "asm.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-	
++-# Each non-boot CPU ("AP") is started up in response to a STARTUP
++-# IPI from the boot CPU.  Section B.4.2 of the Multi-Processor
++-# Specification says that the AP will start in real mode with CS:IP
++-# set to XY00:0000, where XY is an 8-bit value sent with the
++-# STARTUP. Thus this code must start at a 4096-byte boundary.
++-#
++-# Because this code sets DS to zero, it must sit
++-# at an address in the low 2^16 bytes.
++-#
++-# Startothers (in main.c) sends the STARTUPs one at a time.
++-# It copies this code (start) at 0x7000.  It puts the address of
++-# a newly allocated per-core stack in start-4,the address of the
++-# place to jump to (mpenter) in start-8, and the physical address
++-# of entrypgdir in start-12.
++-#
++-# This code combines elements of bootasm.S and entry.S.
++-
++-.code16           
++-.globl start
++-start:
++-  cli            
++-
++-  # Zero data segment registers DS, ES, and SS.
++-  xorw    %ax,%ax
++-  movw    %ax,%ds
++-  movw    %ax,%es
++-  movw    %ax,%ss
++-
++-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
++-  # virtual addresses map directly to physical addresses so that the
++-  # effective memory map doesn't change during the transition.
++-  lgdt    gdtdesc
++-  movl    %cr0, %eax
++-  orl     $CR0_PE, %eax
++-  movl    %eax, %cr0
++-
++-  # Complete the transition to 32-bit protected mode by using a long jmp
++-  # to reload %cs and %eip.  The segment descriptors are set up with no
++-  # translation, so that the mapping is still the identity mapping.
++-  ljmpl    $(SEG_KCODE<<3), $(start32)
++-
++-//PAGEBREAK!
++-.code32  # Tell assembler to generate 32-bit code now.
++-start32:
++-  # Set up the protected-mode data segment registers
++-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
++-  movw    %ax, %ds                # -> DS: Data Segment
++-  movw    %ax, %es                # -> ES: Extra Segment
++-  movw    %ax, %ss                # -> SS: Stack Segment
++-  movw    $0, %ax                 # Zero segments not ready for use
++-  movw    %ax, %fs                # -> FS
++-  movw    %ax, %gs                # -> GS
++-
++-  # Turn on page size extension for 4Mbyte pages
++-  movl    %cr4, %eax
++-  orl     $(CR4_PSE), %eax
++-  movl    %eax, %cr4
++-  # Use entrypgdir as our initial page table
++-  movl    (start-12), %eax
++-  movl    %eax, %cr3
++-  # Turn on paging.
++-  movl    %cr0, %eax
++-  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
++-  movl    %eax, %cr0
++-
++-  # Switch to the stack allocated by startothers()
++-  movl    (start-4), %esp
++-  # Call mpenter()
++-  call	 *(start-8)
++-
++-  movw    $0x8a00, %ax
++-  movw    %ax, %dx
++-  outw    %ax, %dx
++-  movw    $0x8ae0, %ax
++-  outw    %ax, %dx
++-spin:
++-  jmp     spin
++-
++-.p2align 2
++-gdt:
++-  SEG_NULLASM
++-  SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
++-  SEG_ASM(STA_W, 0, 0xffffffff)
++-
++-
++-gdtdesc:
++-  .word   (gdtdesc - gdt - 1)
++-  .long   gdt
++-
++diff --git a/exec.c b/exec.c
++deleted file mode 100644
++index b40134f..0000000
++--- a/exec.c
+++++ /dev/null
++@@ -1,114 +0,0 @@
++-#include "types.h"
++-#include "param.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "defs.h"
++-#include "x86.h"
++-#include "elf.h"
++-
++-int
++-exec(char *path, char **argv)
++-{
++-  char *s, *last;
++-  int i, off;
++-  uint argc, sz, sp, ustack[3+MAXARG+1];
++-  struct elfhdr elf;
++-  struct inode *ip;
++-  struct proghdr ph;
++-  pde_t *pgdir, *oldpgdir;
++-  struct proc *curproc = myproc();
++-
++-  begin_op();
++-
++-  if((ip = namei(path)) == 0){
++-    end_op();
++-    cprintf("exec: fail\n");
++-    return -1;
++-  }
++-  ilock(ip);
++-  pgdir = 0;
++-
++-  // Check ELF header
++-  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
++-    goto bad;
++-  if(elf.magic != ELF_MAGIC)
++-    goto bad;
++-
++-  if((pgdir = setupkvm()) == 0)
++-    goto bad;
++-
++-  // Load program into memory.
++-  sz = 0;
++-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
++-    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
++-      goto bad;
++-    if(ph.type != ELF_PROG_LOAD)
++-      continue;
++-    if(ph.memsz < ph.filesz)
++-      goto bad;
++-    if(ph.vaddr + ph.memsz < ph.vaddr)
++-      goto bad;
++-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
++-      goto bad;
++-    if(ph.vaddr % PGSIZE != 0)
++-      goto bad;
++-    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
++-      goto bad;
++-  }
++-  iunlockput(ip);
++-  end_op();
++-  ip = 0;
++-
++-  // Allocate two pages at the next page boundary.
++-  // Make the first inaccessible.  Use the second as the user stack.
++-  sz = PGROUNDUP(sz);
++-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
++-    goto bad;
++-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
++-  sp = sz;
++-
++-  // Push argument strings, prepare rest of stack in ustack.
++-  for(argc = 0; argv[argc]; argc++) {
++-    if(argc >= MAXARG)
++-      goto bad;
++-    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
++-    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
++-      goto bad;
++-    ustack[3+argc] = sp;
++-  }
++-  ustack[3+argc] = 0;
++-
++-  ustack[0] = 0xffffffff;  // fake return PC
++-  ustack[1] = argc;
++-  ustack[2] = sp - (argc+1)*4;  // argv pointer
++-
++-  sp -= (3+argc+1) * 4;
++-  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
++-    goto bad;
++-
++-  // Save program name for debugging.
++-  for(last=s=path; *s; s++)
++-    if(*s == '/')
++-      last = s+1;
++-  safestrcpy(curproc->name, last, sizeof(curproc->name));
++-
++-  // Commit to the user image.
++-  oldpgdir = curproc->pgdir;
++-  curproc->pgdir = pgdir;
++-  curproc->sz = sz;
++-  curproc->tf->eip = elf.entry;  // main
++-  curproc->tf->esp = sp;
++-  switchuvm(curproc);
++-  freevm(oldpgdir);
++-  return 0;
++-
++- bad:
++-  if(pgdir)
++-    freevm(pgdir);
++-  if(ip){
++-    iunlockput(ip);
++-    end_op();
++-  }
++-  return -1;
++-}
++diff --git a/fcntl.h b/fcntl.h
++deleted file mode 100644
++index d565483..0000000
++--- a/fcntl.h
+++++ /dev/null
++@@ -1,4 +0,0 @@
++-#define O_RDONLY  0x000
++-#define O_WRONLY  0x001
++-#define O_RDWR    0x002
++-#define O_CREATE  0x200
++diff --git a/file.c b/file.c
++deleted file mode 100644
++index 24b32c2..0000000
++--- a/file.c
+++++ /dev/null
++@@ -1,157 +0,0 @@
++-//
++-// File descriptors
++-//
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "fs.h"
++-#include "spinlock.h"
++-#include "sleeplock.h"
++-#include "file.h"
++-
++-struct devsw devsw[NDEV];
++-struct {
++-  struct spinlock lock;
++-  struct file file[NFILE];
++-} ftable;
++-
++-void
++-fileinit(void)
++-{
++-  initlock(&ftable.lock, "ftable");
++-}
++-
++-// Allocate a file structure.
++-struct file*
++-filealloc(void)
++-{
++-  struct file *f;
++-
++-  acquire(&ftable.lock);
++-  for(f = ftable.file; f < ftable.file + NFILE; f++){
++-    if(f->ref == 0){
++-      f->ref = 1;
++-      release(&ftable.lock);
++-      return f;
++-    }
++-  }
++-  release(&ftable.lock);
++-  return 0;
++-}
++-
++-// Increment ref count for file f.
++-struct file*
++-filedup(struct file *f)
++-{
++-  acquire(&ftable.lock);
++-  if(f->ref < 1)
++-    panic("filedup");
++-  f->ref++;
++-  release(&ftable.lock);
++-  return f;
++-}
++-
++-// Close file f.  (Decrement ref count, close when reaches 0.)
++-void
++-fileclose(struct file *f)
++-{
++-  struct file ff;
++-
++-  acquire(&ftable.lock);
++-  if(f->ref < 1)
++-    panic("fileclose");
++-  if(--f->ref > 0){
++-    release(&ftable.lock);
++-    return;
++-  }
++-  ff = *f;
++-  f->ref = 0;
++-  f->type = FD_NONE;
++-  release(&ftable.lock);
++-
++-  if(ff.type == FD_PIPE)
++-    pipeclose(ff.pipe, ff.writable);
++-  else if(ff.type == FD_INODE){
++-    begin_op();
++-    iput(ff.ip);
++-    end_op();
++-  }
++-}
++-
++-// Get metadata about file f.
++-int
++-filestat(struct file *f, struct stat *st)
++-{
++-  if(f->type == FD_INODE){
++-    ilock(f->ip);
++-    stati(f->ip, st);
++-    iunlock(f->ip);
++-    return 0;
++-  }
++-  return -1;
++-}
++-
++-// Read from file f.
++-int
++-fileread(struct file *f, char *addr, int n)
++-{
++-  int r;
++-
++-  if(f->readable == 0)
++-    return -1;
++-  if(f->type == FD_PIPE)
++-    return piperead(f->pipe, addr, n);
++-  if(f->type == FD_INODE){
++-    ilock(f->ip);
++-    if((r = readi(f->ip, addr, f->off, n)) > 0)
++-      f->off += r;
++-    iunlock(f->ip);
++-    return r;
++-  }
++-  panic("fileread");
++-}
++-
++-//PAGEBREAK!
++-// Write to file f.
++-int
++-filewrite(struct file *f, char *addr, int n)
++-{
++-  int r;
++-
++-  if(f->writable == 0)
++-    return -1;
++-  if(f->type == FD_PIPE)
++-    return pipewrite(f->pipe, addr, n);
++-  if(f->type == FD_INODE){
++-    // write a few blocks at a time to avoid exceeding
++-    // the maximum log transaction size, including
++-    // i-node, indirect block, allocation blocks,
++-    // and 2 blocks of slop for non-aligned writes.
++-    // this really belongs lower down, since writei()
++-    // might be writing a device like the console.
++-    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
++-    int i = 0;
++-    while(i < n){
++-      int n1 = n - i;
++-      if(n1 > max)
++-        n1 = max;
++-
++-      begin_op();
++-      ilock(f->ip);
++-      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
++-        f->off += r;
++-      iunlock(f->ip);
++-      end_op();
++-
++-      if(r < 0)
++-        break;
++-      if(r != n1)
++-        panic("short filewrite");
++-      i += r;
++-    }
++-    return i == n ? n : -1;
++-  }
++-  panic("filewrite");
++-}
++-
++diff --git a/file.h b/file.h
++deleted file mode 100644
++index 0990c82..0000000
++--- a/file.h
+++++ /dev/null
++@@ -1,37 +0,0 @@
++-struct file {
++-  enum { FD_NONE, FD_PIPE, FD_INODE } type;
++-  int ref; // reference count
++-  char readable;
++-  char writable;
++-  struct pipe *pipe;
++-  struct inode *ip;
++-  uint off;
++-};
++-
++-
++-// in-memory copy of an inode
++-struct inode {
++-  uint dev;           // Device number
++-  uint inum;          // Inode number
++-  int ref;            // Reference count
++-  struct sleeplock lock; // protects everything below here
++-  int valid;          // inode has been read from disk?
++-
++-  short type;         // copy of disk inode
++-  short major;
++-  short minor;
++-  short nlink;
++-  uint size;
++-  uint addrs[NDIRECT+1];
++-};
++-
++-// table mapping major device number to
++-// device functions
++-struct devsw {
++-  int (*read)(struct inode*, char*, int);
++-  int (*write)(struct inode*, char*, int);
++-};
++-
++-extern struct devsw devsw[];
++-
++-#define CONSOLE 1
++diff --git a/forktest.c b/forktest.c
++deleted file mode 100644
++index a4b35ed..0000000
++--- a/forktest.c
+++++ /dev/null
++@@ -1,56 +0,0 @@
++-// Test that fork fails gracefully.
++-// Tiny executable so that the limit can be filling the proc table.
++-
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-
++-#define N  1000
++-
++-void
++-printf(int fd, const char *s, ...)
++-{
++-  write(fd, s, strlen(s));
++-}
++-
++-void
++-forktest(void)
++-{
++-  int n, pid;
++-
++-  printf(1, "fork test\n");
++-
++-  for(n=0; n<N; n++){
++-    pid = fork();
++-    if(pid < 0)
++-      break;
++-    if(pid == 0)
++-      exit(4);
++-  }
++-
++-  if(n == N){
++-    printf(1, "fork claimed to work N times!\n", N);
++-    exit(3);
++-  }
++-
++-  for(; n > 0; n--){
++-    if(wait(NULL) < 0){
++-      printf(1, "wait stopped early\n");
++-      exit(2);
++-    }
++-  }
++-
++-  if(wait(NULL) != -1){
++-    printf(1, "wait got too many\n");
++-    exit(1);
++-  }
++-
++-  printf(1, "fork test OK\n");
++-}
++-
++-int
++-main(void)
++-{
++-  forktest();
++-  exit(0);
++-}
++diff --git a/fs.c b/fs.c
++deleted file mode 100644
++index f77275f..0000000
++--- a/fs.c
+++++ /dev/null
++@@ -1,670 +0,0 @@
++-// File system implementation.  Five layers:
++-//   + Blocks: allocator for raw disk blocks.
++-//   + Log: crash recovery for multi-step updates.
++-//   + Files: inode allocator, reading, writing, metadata.
++-//   + Directories: inode with special contents (list of other inodes!)
++-//   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
++-//
++-// This file contains the low-level file system manipulation
++-// routines.  The (higher-level) system call implementations
++-// are in sysfile.c.
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "stat.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "spinlock.h"
++-#include "sleeplock.h"
++-#include "fs.h"
++-#include "buf.h"
++-#include "file.h"
++-
++-#define min(a, b) ((a) < (b) ? (a) : (b))
++-static void itrunc(struct inode*);
++-// there should be one superblock per disk device, but we run with
++-// only one device
++-struct superblock sb; 
++-
++-// Read the super block.
++-void
++-readsb(int dev, struct superblock *sb)
++-{
++-  struct buf *bp;
++-
++-  bp = bread(dev, 1);
++-  memmove(sb, bp->data, sizeof(*sb));
++-  brelse(bp);
++-}
++-
++-// Zero a block.
++-static void
++-bzero(int dev, int bno)
++-{
++-  struct buf *bp;
++-
++-  bp = bread(dev, bno);
++-  memset(bp->data, 0, BSIZE);
++-  log_write(bp);
++-  brelse(bp);
++-}
++-
++-// Blocks.
++-
++-// Allocate a zeroed disk block.
++-static uint
++-balloc(uint dev)
++-{
++-  int b, bi, m;
++-  struct buf *bp;
++-
++-  bp = 0;
++-  for(b = 0; b < sb.size; b += BPB){
++-    bp = bread(dev, BBLOCK(b, sb));
++-    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
++-      m = 1 << (bi % 8);
++-      if((bp->data[bi/8] & m) == 0){  // Is block free?
++-        bp->data[bi/8] |= m;  // Mark block in use.
++-        log_write(bp);
++-        brelse(bp);
++-        bzero(dev, b + bi);
++-        return b + bi;
++-      }
++-    }
++-    brelse(bp);
++-  }
++-  panic("balloc: out of blocks");
++-}
++-
++-// Free a disk block.
++-static void
++-bfree(int dev, uint b)
++-{
++-  struct buf *bp;
++-  int bi, m;
++-
++-  bp = bread(dev, BBLOCK(b, sb));
++-  bi = b % BPB;
++-  m = 1 << (bi % 8);
++-  if((bp->data[bi/8] & m) == 0)
++-    panic("freeing free block");
++-  bp->data[bi/8] &= ~m;
++-  log_write(bp);
++-  brelse(bp);
++-}
++-
++-// Inodes.
++-//
++-// An inode describes a single unnamed file.
++-// The inode disk structure holds metadata: the file's type,
++-// its size, the number of links referring to it, and the
++-// list of blocks holding the file's content.
++-//
++-// The inodes are laid out sequentially on disk at
++-// sb.startinode. Each inode has a number, indicating its
++-// position on the disk.
++-//
++-// The kernel keeps a cache of in-use inodes in memory
++-// to provide a place for synchronizing access
++-// to inodes used by multiple processes. The cached
++-// inodes include book-keeping information that is
++-// not stored on disk: ip->ref and ip->valid.
++-//
++-// An inode and its in-memory representation go through a
++-// sequence of states before they can be used by the
++-// rest of the file system code.
++-//
++-// * Allocation: an inode is allocated if its type (on disk)
++-//   is non-zero. ialloc() allocates, and iput() frees if
++-//   the reference and link counts have fallen to zero.
++-//
++-// * Referencing in cache: an entry in the inode cache
++-//   is free if ip->ref is zero. Otherwise ip->ref tracks
++-//   the number of in-memory pointers to the entry (open
++-//   files and current directories). iget() finds or
++-//   creates a cache entry and increments its ref; iput()
++-//   decrements ref.
++-//
++-// * Valid: the information (type, size, &c) in an inode
++-//   cache entry is only correct when ip->valid is 1.
++-//   ilock() reads the inode from
++-//   the disk and sets ip->valid, while iput() clears
++-//   ip->valid if ip->ref has fallen to zero.
++-//
++-// * Locked: file system code may only examine and modify
++-//   the information in an inode and its content if it
++-//   has first locked the inode.
++-//
++-// Thus a typical sequence is:
++-//   ip = iget(dev, inum)
++-//   ilock(ip)
++-//   ... examine and modify ip->xxx ...
++-//   iunlock(ip)
++-//   iput(ip)
++-//
++-// ilock() is separate from iget() so that system calls can
++-// get a long-term reference to an inode (as for an open file)
++-// and only lock it for short periods (e.g., in read()).
++-// The separation also helps avoid deadlock and races during
++-// pathname lookup. iget() increments ip->ref so that the inode
++-// stays cached and pointers to it remain valid.
++-//
++-// Many internal file system functions expect the caller to
++-// have locked the inodes involved; this lets callers create
++-// multi-step atomic operations.
++-//
++-// The icache.lock spin-lock protects the allocation of icache
++-// entries. Since ip->ref indicates whether an entry is free,
++-// and ip->dev and ip->inum indicate which i-node an entry
++-// holds, one must hold icache.lock while using any of those fields.
++-//
++-// An ip->lock sleep-lock protects all ip-> fields other than ref,
++-// dev, and inum.  One must hold ip->lock in order to
++-// read or write that inode's ip->valid, ip->size, ip->type, &c.
++-
++-struct {
++-  struct spinlock lock;
++-  struct inode inode[NINODE];
++-} icache;
++-
++-void
++-iinit(int dev)
++-{
++-  int i = 0;
++-  
++-  initlock(&icache.lock, "icache");
++-  for(i = 0; i < NINODE; i++) {
++-    initsleeplock(&icache.inode[i].lock, "inode");
++-  }
++-
++-  readsb(dev, &sb);
++-  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
++- inodestart %d bmap start %d\n", sb.size, sb.nblocks,
++-          sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
++-          sb.bmapstart);
++-}
++-
++-static struct inode* iget(uint dev, uint inum);
++-
++-//PAGEBREAK!
++-// Allocate an inode on device dev.
++-// Mark it as allocated by  giving it type type.
++-// Returns an unlocked but allocated and referenced inode.
++-struct inode*
++-ialloc(uint dev, short type)
++-{
++-  int inum;
++-  struct buf *bp;
++-  struct dinode *dip;
++-
++-  for(inum = 1; inum < sb.ninodes; inum++){
++-    bp = bread(dev, IBLOCK(inum, sb));
++-    dip = (struct dinode*)bp->data + inum%IPB;
++-    if(dip->type == 0){  // a free inode
++-      memset(dip, 0, sizeof(*dip));
++-      dip->type = type;
++-      log_write(bp);   // mark it allocated on the disk
++-      brelse(bp);
++-      return iget(dev, inum);
++-    }
++-    brelse(bp);
++-  }
++-  panic("ialloc: no inodes");
++-}
++-
++-// Copy a modified in-memory inode to disk.
++-// Must be called after every change to an ip->xxx field
++-// that lives on disk, since i-node cache is write-through.
++-// Caller must hold ip->lock.
++-void
++-iupdate(struct inode *ip)
++-{
++-  struct buf *bp;
++-  struct dinode *dip;
++-
++-  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
++-  dip = (struct dinode*)bp->data + ip->inum%IPB;
++-  dip->type = ip->type;
++-  dip->major = ip->major;
++-  dip->minor = ip->minor;
++-  dip->nlink = ip->nlink;
++-  dip->size = ip->size;
++-  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
++-  log_write(bp);
++-  brelse(bp);
++-}
++-
++-// Find the inode with number inum on device dev
++-// and return the in-memory copy. Does not lock
++-// the inode and does not read it from disk.
++-static struct inode*
++-iget(uint dev, uint inum)
++-{
++-  struct inode *ip, *empty;
++-
++-  acquire(&icache.lock);
++-
++-  // Is the inode already cached?
++-  empty = 0;
++-  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
++-    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
++-      ip->ref++;
++-      release(&icache.lock);
++-      return ip;
++-    }
++-    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
++-      empty = ip;
++-  }
++-
++-  // Recycle an inode cache entry.
++-  if(empty == 0)
++-    panic("iget: no inodes");
++-
++-  ip = empty;
++-  ip->dev = dev;
++-  ip->inum = inum;
++-  ip->ref = 1;
++-  ip->valid = 0;
++-  release(&icache.lock);
++-
++-  return ip;
++-}
++-
++-// Increment reference count for ip.
++-// Returns ip to enable ip = idup(ip1) idiom.
++-struct inode*
++-idup(struct inode *ip)
++-{
++-  acquire(&icache.lock);
++-  ip->ref++;
++-  release(&icache.lock);
++-  return ip;
++-}
++-
++-// Lock the given inode.
++-// Reads the inode from disk if necessary.
++-void
++-ilock(struct inode *ip)
++-{
++-  struct buf *bp;
++-  struct dinode *dip;
++-
++-  if(ip == 0 || ip->ref < 1)
++-    panic("ilock");
++-
++-  acquiresleep(&ip->lock);
++-
++-  if(ip->valid == 0){
++-    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
++-    dip = (struct dinode*)bp->data + ip->inum%IPB;
++-    ip->type = dip->type;
++-    ip->major = dip->major;
++-    ip->minor = dip->minor;
++-    ip->nlink = dip->nlink;
++-    ip->size = dip->size;
++-    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
++-    brelse(bp);
++-    ip->valid = 1;
++-    if(ip->type == 0)
++-      panic("ilock: no type");
++-  }
++-}
++-
++-// Unlock the given inode.
++-void
++-iunlock(struct inode *ip)
++-{
++-  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
++-    panic("iunlock");
++-
++-  releasesleep(&ip->lock);
++-}
++-
++-// Drop a reference to an in-memory inode.
++-// If that was the last reference, the inode cache entry can
++-// be recycled.
++-// If that was the last reference and the inode has no links
++-// to it, free the inode (and its content) on disk.
++-// All calls to iput() must be inside a transaction in
++-// case it has to free the inode.
++-void
++-iput(struct inode *ip)
++-{
++-  acquiresleep(&ip->lock);
++-  if(ip->valid && ip->nlink == 0){
++-    acquire(&icache.lock);
++-    int r = ip->ref;
++-    release(&icache.lock);
++-    if(r == 1){
++-      // inode has no links and no other references: truncate and free.
++-      itrunc(ip);
++-      ip->type = 0;
++-      iupdate(ip);
++-      ip->valid = 0;
++-    }
++-  }
++-  releasesleep(&ip->lock);
++-
++-  acquire(&icache.lock);
++-  ip->ref--;
++-  release(&icache.lock);
++-}
++-
++-// Common idiom: unlock, then put.
++-void
++-iunlockput(struct inode *ip)
++-{
++-  iunlock(ip);
++-  iput(ip);
++-}
++-
++-//PAGEBREAK!
++-// Inode content
++-//
++-// The content (data) associated with each inode is stored
++-// in blocks on the disk. The first NDIRECT block numbers
++-// are listed in ip->addrs[].  The next NINDIRECT blocks are
++-// listed in block ip->addrs[NDIRECT].
++-
++-// Return the disk block address of the nth block in inode ip.
++-// If there is no such block, bmap allocates one.
++-static uint
++-bmap(struct inode *ip, uint bn)
++-{
++-  uint addr, *a;
++-  struct buf *bp;
++-
++-  if(bn < NDIRECT){
++-    if((addr = ip->addrs[bn]) == 0)
++-      ip->addrs[bn] = addr = balloc(ip->dev);
++-    return addr;
++-  }
++-  bn -= NDIRECT;
++-
++-  if(bn < NINDIRECT){
++-    // Load indirect block, allocating if necessary.
++-    if((addr = ip->addrs[NDIRECT]) == 0)
++-      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
++-    bp = bread(ip->dev, addr);
++-    a = (uint*)bp->data;
++-    if((addr = a[bn]) == 0){
++-      a[bn] = addr = balloc(ip->dev);
++-      log_write(bp);
++-    }
++-    brelse(bp);
++-    return addr;
++-  }
++-
++-  panic("bmap: out of range");
++-}
++-
++-// Truncate inode (discard contents).
++-// Only called when the inode has no links
++-// to it (no directory entries referring to it)
++-// and has no in-memory reference to it (is
++-// not an open file or current directory).
++-static void
++-itrunc(struct inode *ip)
++-{
++-  int i, j;
++-  struct buf *bp;
++-  uint *a;
++-
++-  for(i = 0; i < NDIRECT; i++){
++-    if(ip->addrs[i]){
++-      bfree(ip->dev, ip->addrs[i]);
++-      ip->addrs[i] = 0;
++-    }
++-  }
++-
++-  if(ip->addrs[NDIRECT]){
++-    bp = bread(ip->dev, ip->addrs[NDIRECT]);
++-    a = (uint*)bp->data;
++-    for(j = 0; j < NINDIRECT; j++){
++-      if(a[j])
++-        bfree(ip->dev, a[j]);
++-    }
++-    brelse(bp);
++-    bfree(ip->dev, ip->addrs[NDIRECT]);
++-    ip->addrs[NDIRECT] = 0;
++-  }
++-
++-  ip->size = 0;
++-  iupdate(ip);
++-}
++-
++-// Copy stat information from inode.
++-// Caller must hold ip->lock.
++-void
++-stati(struct inode *ip, struct stat *st)
++-{
++-  st->dev = ip->dev;
++-  st->ino = ip->inum;
++-  st->type = ip->type;
++-  st->nlink = ip->nlink;
++-  st->size = ip->size;
++-}
++-
++-//PAGEBREAK!
++-// Read data from inode.
++-// Caller must hold ip->lock.
++-int
++-readi(struct inode *ip, char *dst, uint off, uint n)
++-{
++-  uint tot, m;
++-  struct buf *bp;
++-
++-  if(ip->type == T_DEV){
++-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
++-      return -1;
++-    return devsw[ip->major].read(ip, dst, n);
++-  }
++-
++-  if(off > ip->size || off + n < off)
++-    return -1;
++-  if(off + n > ip->size)
++-    n = ip->size - off;
++-
++-  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
++-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
++-    m = min(n - tot, BSIZE - off%BSIZE);
++-    memmove(dst, bp->data + off%BSIZE, m);
++-    brelse(bp);
++-  }
++-  return n;
++-}
++-
++-// PAGEBREAK!
++-// Write data to inode.
++-// Caller must hold ip->lock.
++-int
++-writei(struct inode *ip, char *src, uint off, uint n)
++-{
++-  uint tot, m;
++-  struct buf *bp;
++-
++-  if(ip->type == T_DEV){
++-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
++-      return -1;
++-    return devsw[ip->major].write(ip, src, n);
++-  }
++-
++-  if(off > ip->size || off + n < off)
++-    return -1;
++-  if(off + n > MAXFILE*BSIZE)
++-    return -1;
++-
++-  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
++-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
++-    m = min(n - tot, BSIZE - off%BSIZE);
++-    memmove(bp->data + off%BSIZE, src, m);
++-    log_write(bp);
++-    brelse(bp);
++-  }
++-
++-  if(n > 0 && off > ip->size){
++-    ip->size = off;
++-    iupdate(ip);
++-  }
++-  return n;
++-}
++-
++-//PAGEBREAK!
++-// Directories
++-
++-int
++-namecmp(const char *s, const char *t)
++-{
++-  return strncmp(s, t, DIRSIZ);
++-}
++-
++-// Look for a directory entry in a directory.
++-// If found, set *poff to byte offset of entry.
++-struct inode*
++-dirlookup(struct inode *dp, char *name, uint *poff)
++-{
++-  uint off, inum;
++-  struct dirent de;
++-
++-  if(dp->type != T_DIR)
++-    panic("dirlookup not DIR");
++-
++-  for(off = 0; off < dp->size; off += sizeof(de)){
++-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
++-      panic("dirlookup read");
++-    if(de.inum == 0)
++-      continue;
++-    if(namecmp(name, de.name) == 0){
++-      // entry matches path element
++-      if(poff)
++-        *poff = off;
++-      inum = de.inum;
++-      return iget(dp->dev, inum);
++-    }
++-  }
++-
++-  return 0;
++-}
++-
++-// Write a new directory entry (name, inum) into the directory dp.
++-int
++-dirlink(struct inode *dp, char *name, uint inum)
++-{
++-  int off;
++-  struct dirent de;
++-  struct inode *ip;
++-
++-  // Check that name is not present.
++-  if((ip = dirlookup(dp, name, 0)) != 0){
++-    iput(ip);
++-    return -1;
++-  }
++-
++-  // Look for an empty dirent.
++-  for(off = 0; off < dp->size; off += sizeof(de)){
++-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
++-      panic("dirlink read");
++-    if(de.inum == 0)
++-      break;
++-  }
++-
++-  strncpy(de.name, name, DIRSIZ);
++-  de.inum = inum;
++-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
++-    panic("dirlink");
++-
++-  return 0;
++-}
++-
++-//PAGEBREAK!
++-// Paths
++-
++-// Copy the next path element from path into name.
++-// Return a pointer to the element following the copied one.
++-// The returned path has no leading slashes,
++-// so the caller can check *path=='\0' to see if the name is the last one.
++-// If no name to remove, return 0.
++-//
++-// Examples:
++-//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
++-//   skipelem("///a//bb", name) = "bb", setting name = "a"
++-//   skipelem("a", name) = "", setting name = "a"
++-//   skipelem("", name) = skipelem("////", name) = 0
++-//
++-static char*
++-skipelem(char *path, char *name)
++-{
++-  char *s;
++-  int len;
++-
++-  while(*path == '/')
++-    path++;
++-  if(*path == 0)
++-    return 0;
++-  s = path;
++-  while(*path != '/' && *path != 0)
++-    path++;
++-  len = path - s;
++-  if(len >= DIRSIZ)
++-    memmove(name, s, DIRSIZ);
++-  else {
++-    memmove(name, s, len);
++-    name[len] = 0;
++-  }
++-  while(*path == '/')
++-    path++;
++-  return path;
++-}
++-
++-// Look up and return the inode for a path name.
++-// If parent != 0, return the inode for the parent and copy the final
++-// path element into name, which must have room for DIRSIZ bytes.
++-// Must be called inside a transaction since it calls iput().
++-static struct inode*
++-namex(char *path, int nameiparent, char *name)
++-{
++-  struct inode *ip, *next;
++-
++-  if(*path == '/')
++-    ip = iget(ROOTDEV, ROOTINO);
++-  else
++-    ip = idup(myproc()->cwd);
++-
++-  while((path = skipelem(path, name)) != 0){
++-    ilock(ip);
++-    if(ip->type != T_DIR){
++-      iunlockput(ip);
++-      return 0;
++-    }
++-    if(nameiparent && *path == '\0'){
++-      // Stop one level early.
++-      iunlock(ip);
++-      return ip;
++-    }
++-    if((next = dirlookup(ip, name, 0)) == 0){
++-      iunlockput(ip);
++-      return 0;
++-    }
++-    iunlockput(ip);
++-    ip = next;
++-  }
++-  if(nameiparent){
++-    iput(ip);
++-    return 0;
++-  }
++-  return ip;
++-}
++-
++-struct inode*
++-namei(char *path)
++-{
++-  char name[DIRSIZ];
++-  return namex(path, 0, name);
++-}
++-
++-struct inode*
++-nameiparent(char *path, char *name)
++-{
++-  return namex(path, 1, name);
++-}
++diff --git a/fs.h b/fs.h
++deleted file mode 100644
++index 3214f1d..0000000
++--- a/fs.h
+++++ /dev/null
++@@ -1,57 +0,0 @@
++-// On-disk file system format.
++-// Both the kernel and user programs use this header file.
++-
++-
++-#define ROOTINO 1  // root i-number
++-#define BSIZE 512  // block size
++-
++-// Disk layout:
++-// [ boot block | super block | log | inode blocks |
++-//                                          free bit map | data blocks]
++-//
++-// mkfs computes the super block and builds an initial file system. The
++-// super block describes the disk layout:
++-struct superblock {
++-  uint size;         // Size of file system image (blocks)
++-  uint nblocks;      // Number of data blocks
++-  uint ninodes;      // Number of inodes.
++-  uint nlog;         // Number of log blocks
++-  uint logstart;     // Block number of first log block
++-  uint inodestart;   // Block number of first inode block
++-  uint bmapstart;    // Block number of first free map block
++-};
++-
++-#define NDIRECT 12
++-#define NINDIRECT (BSIZE / sizeof(uint))
++-#define MAXFILE (NDIRECT + NINDIRECT)
++-
++-// On-disk inode structure
++-struct dinode {
++-  short type;           // File type
++-  short major;          // Major device number (T_DEV only)
++-  short minor;          // Minor device number (T_DEV only)
++-  short nlink;          // Number of links to inode in file system
++-  uint size;            // Size of file (bytes)
++-  uint addrs[NDIRECT+1];   // Data block addresses
++-};
++-
++-// Inodes per block.
++-#define IPB           (BSIZE / sizeof(struct dinode))
++-
++-// Block containing inode i
++-#define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
++-
++-// Bitmap bits per block
++-#define BPB           (BSIZE*8)
++-
++-// Block of free map containing bit for block b
++-#define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
++-
++-// Directory is a file containing a sequence of dirent structures.
++-#define DIRSIZ 14
++-
++-struct dirent {
++-  ushort inum;
++-  char name[DIRSIZ];
++-};
++-
++diff --git a/gdbutil b/gdbutil
++deleted file mode 100644
++index e0c362f..0000000
++--- a/gdbutil
+++++ /dev/null
++@@ -1,291 +0,0 @@
++-# -*- gdb-script -*-
++-
++-# Utility functions to pretty-print x86 segment/interrupt descriptors.
++-# To load this file, run "source gdbutil" in gdb.
++-# printdesc and printdescs are the main entry points.
++-
++-# IA32 2007, Volume 3A, Table 3-2
++-set $STS_T16A = 0x1
++-set $STS_LDT  = 0x2
++-set $STS_T16B = 0x3
++-set $STS_CG16 = 0x4
++-set $STS_TG   = 0x5
++-set $STS_IG16 = 0x6
++-set $STS_TG16 = 0x7
++-set $STS_T32A = 0x9
++-set $STS_T32B = 0xB
++-set $STS_CG32 = 0xC
++-set $STS_IG32 = 0xE
++-set $STS_TG32 = 0xF
++-
++-define outputsts
++-  while 1
++-    if $arg0 == $STS_T16A
++-      echo STS_T16A
++-      loop_break
++-    end
++-    if $arg0 == $STS_LDT
++-      echo STS_LDT\ 
++-      loop_break
++-    end
++-    if $arg0 == $STS_T16B
++-      echo STS_T16B
++-      loop_break
++-    end
++-    if $arg0 == $STS_CG16
++-      echo STS_CG16
++-      loop_break
++-    end
++-    if $arg0 == $STS_TG
++-      echo STS_TG\ \ 
++-      loop_break
++-    end
++-    if $arg0 == $STS_IG16
++-      echo STS_IG16
++-      loop_break
++-    end
++-    if $arg0 == $STS_TG16
++-      echo STS_TG16
++-      loop_break
++-    end
++-    if $arg0 == $STS_T32A
++-      echo STS_T32A
++-      loop_break
++-    end
++-    if $arg0 == $STS_T32B
++-      echo STS_T32B
++-      loop_break
++-    end
++-    if $arg0 == $STS_CG32
++-      echo STS_CG32
++-      loop_break
++-    end
++-    if $arg0 == $STS_IG32
++-      echo STS_IG32
++-      loop_break
++-    end
++-    if $arg0 == $STS_TG32
++-      echo STS_TG32
++-      loop_break
++-    end
++-    echo Reserved
++-    loop_break
++-  end
++-end  
++-
++-# IA32 2007, Volume 3A, Table 3-1
++-set $STA_X = 0x8
++-set $STA_E = 0x4
++-set $STA_C = 0x4
++-set $STA_W = 0x2
++-set $STA_R = 0x2
++-set $STA_A = 0x1
++-
++-define outputsta
++-  if $arg0 & $STA_X
++-    # Code segment
++-    echo code
++-    if $arg0 & $STA_C
++-      echo |STA_C
++-    end
++-    if $arg0 & $STA_R
++-      echo |STA_R
++-    end
++-  else
++-    # Data segment
++-    echo data
++-    if $arg0 & $STA_E
++-      echo |STA_E
++-    end
++-    if $arg0 & $STA_W
++-      echo |STA_W
++-    end
++-  end
++-  if $arg0 & $STA_A
++-    echo |STA_A
++-  else
++-    printf "      "
++-  end
++-end
++-
++-# xv6-specific
++-set $SEG_KCODE = 1
++-set $SEG_KDATA = 2
++-set $SEG_KCPU  = 3
++-set $SEG_UCODE = 4
++-set $SEG_UDATA = 5
++-set $SEG_TSS   = 6
++-
++-define outputcs
++-  if ($arg0 & 4) == 0
++-    if $arg0 >> 3 == $SEG_KCODE
++-      printf "SEG_KCODE<<3"
++-    end
++-    if $arg0 >> 3 == $SEG_KDATA
++-      printf "SEG_KDATA<<3"
++-    end
++-    if $arg0 >> 3 == $SEG_KCPU
++-      printf "SEG_KCPU<<3"
++-    end
++-    if $arg0 >> 3 == $SEG_UCODE
++-      printf "SEG_UCODE<<3"
++-    end
++-    if $arg0 >> 3 == $SEG_UDATA
++-      printf "SEG_UDATA<<3"
++-    end
++-    if $arg0 >> 3 == $SEG_TSS
++-      printf "SEG_TSS<<3"
++-    end
++-    if ($arg0 >> 3 < 1) + ($arg0 >> 3 > 6)
++-      printf "GDT[%d]", $arg0 >> 3
++-    end
++-  else
++-    printf "LDT[%d]", $arg0 >> 3
++-  end
++-  if ($arg0 & 3) > 0
++-    printf "|"
++-    outputdpl ($arg0&3)
++-  end
++-end
++-
++-define outputdpl
++-  if $arg0 == 0
++-    printf "DPL_KERN"
++-  else
++-    if $arg0 == 3
++-      printf "DPL_USER"
++-    else
++-      printf "DPL%d", $arg0
++-    end
++-  end
++-end
++-
++-define printdesc
++-  if $argc != 1
++-    echo Usage: printdesc expr
++-  else
++-    _printdesc ((uint*)&($arg0))[0] ((uint*)&($arg0))[1]
++-    printf "\n"
++-  end
++-end
++-
++-document printdesc
++-Print an x86 segment or gate descriptor.
++-printdesc EXPR
++-EXPR must evaluate to a descriptor value.  It can be of any C type.
++-end
++-
++-define _printdesc
++-  _printdesc1 $arg0 $arg1 ($arg1>>15&1) ($arg1>>13&3) ($arg1>>12&1) ($arg1>>8&15)
++-end
++-
++-define _printdesc1
++-  # 2:P 3:DPL 4:S 5:Type
++-  if $arg2 == 0
++-    printf "P = 0 (Not present)"
++-  else
++-    printf "type = "
++-    if $arg4 == 0
++-      # System segment
++-      outputsts $arg5
++-      printf " (0x%x)    ", $arg5
++-      _printsysdesc $arg0 $arg1 $arg5
++-    else
++-      # Code/data segment
++-      outputsta $arg5
++-      printf "  "
++-      _printsegdesc $arg0 $arg1
++-    end
++-
++-    printf "  DPL = "
++-    outputdpl $arg3
++-    printf " (%d)", $arg3
++-  end
++-end
++-
++-define _printsysdesc
++-  # 2:Type
++-  # GDB's || is buggy
++-  if ($arg2 == $STS_TG) + (($arg2&7) == $STS_IG16) + (($arg2&7) == $STS_TG16)
++-    # Gate descriptor
++-    _printgate $arg2 ($arg0>>16) ($arg0&0xFFFF) ($arg1>>16)
++-  else
++-    # System segment descriptor
++-    _printsegdesc $arg0 $arg1
++-  end
++-end
++-
++-define _printgate
++-  # IA32 2007, Voume 3A, Figure 5-2
++-  # 0:Type 1:CS 2:Offset 15..0 3:Offset 31..16
++-  printf "CS = "
++-  outputcs $arg1
++-  printf " (%d)", $arg1
++-
++-  if (($arg0&7) == $STS_IG16) + (($arg0&7) == $STS_TG16)
++-    printf "  Offset = "
++-    output/a $arg3 << 16 | $arg2
++-  end
++-end
++-
++-define _printsegdesc
++-  # IA32 20007, Volume 3A, Figure 3-8 and Figure 4-1
++-  _printsegdesc1 ($arg0>>16) ($arg1&0xFF) ($arg1>>24) ($arg0&0xFFFF) ($arg1>>16&15) ($arg1>>23&1)
++-  if ($arg1>>12&1) == 1
++-    printf "  AVL = %d", $arg1>>20&1
++-    if ($arg1>>11&1) == 0
++-      # Data segment
++-      if ($arg1>>22&1) == 0
++-        printf "  B = small (0) "
++-      else
++-        printf "  B = big (1)   "
++-      end
++-    else
++-      # Code segment
++-      printf "  D = "
++-      if ($arg1>>22&1) == 0
++-        printf "16-bit (0)"
++-      else
++-        printf "32-bit (1)"
++-      end
++-    end
++-  end
++-end
++-
++-define _printsegdesc1
++-  # 0:Base 0..15  1:Base 16..23  2:Base 24..32  3:Limit 0..15  4:Limit 16..19  5:G
++-  printf "base = 0x%08x", $arg0 | ($arg1<<16) | ($arg2<<24)
++-  printf "  limit = 0x"
++-  if $arg5 == 0
++-    printf "%08x", $arg3 | ($arg4<<16)
++-  else
++-    printf "%08x", (($arg3 | ($arg4<<16)) << 12) | 0xFFF
++-  end
++-end
++-
++-define printdescs
++-  if $argc < 1 || $argc > 2
++-    echo Usage: printdescs expr [count]
++-  else
++-    if $argc == 1
++-      _printdescs ($arg0) (sizeof($arg0)/sizeof(($arg0)[0]))
++-    else
++-      _printdescs ($arg0) ($arg1)
++-    end
++-  end
++-end
++-
++-document printdescs
++-Print an array of x86 segment or gate descriptors.
++-printdescs EXPR [COUNT]
++-EXPR must evaluate to an array of descriptors.
++-end
++-
++-define _printdescs
++-  set $i = 0
++-  while $i < $arg1
++-    printf "[%d] ", $i
++-    printdesc $arg0[$i]
++-    set $i = $i + 1
++-  end
++-end
++diff --git a/grep.c b/grep.c
++deleted file mode 100644
++index 4be3256..0000000
++--- a/grep.c
+++++ /dev/null
++@@ -1,107 +0,0 @@
++-// Simple grep.  Only supports ^ . * $ operators.
++-
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-
++-char buf[1024];
++-int match(char*, char*);
++-
++-void
++-grep(char *pattern, int fd)
++-{
++-  int n, m;
++-  char *p, *q;
++-
++-  m = 0;
++-  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
++-    m += n;
++-    buf[m] = '\0';
++-    p = buf;
++-    while((q = strchr(p, '\n')) != 0){
++-      *q = 0;
++-      if(match(pattern, p)){
++-        *q = '\n';
++-        write(1, p, q+1 - p);
++-      }
++-      p = q+1;
++-    }
++-    if(p == buf)
++-      m = 0;
++-    if(m > 0){
++-      m -= p - buf;
++-      memmove(buf, p, m);
++-    }
++-  }
++-}
++-
++-int
++-main(int argc, char *argv[])
++-{
++-  int fd, i;
++-  char *pattern;
++-
++-  if(argc <= 1){
++-    printf(2, "usage: grep pattern [file ...]\n");
++-    exit(1);
++-  }
++-  pattern = argv[1];
++-
++-  if(argc <= 2){
++-    grep(pattern, 0);
++-    exit(2);
++-  }
++-
++-  for(i = 2; i < argc; i++){
++-    if((fd = open(argv[i], 0)) < 0){
++-      printf(1, "grep: cannot open %s\n", argv[i]);
++-      exit(3);
++-    }
++-    grep(pattern, fd);
++-    close(fd);
++-  }
++-  exit(0);
++-}
++-
++-// Regexp matcher from Kernighan & Pike,
++-// The Practice of Programming, Chapter 9.
++-
++-int matchhere(char*, char*);
++-int matchstar(int, char*, char*);
++-
++-int
++-match(char *re, char *text)
++-{
++-  if(re[0] == '^')
++-    return matchhere(re+1, text);
++-  do{  // must look at empty string
++-    if(matchhere(re, text))
++-      return 1;
++-  }while(*text++ != '\0');
++-  return 0;
++-}
++-
++-// matchhere: search for re at beginning of text
++-int matchhere(char *re, char *text)
++-{
++-  if(re[0] == '\0')
++-    return 1;
++-  if(re[1] == '*')
++-    return matchstar(re[0], re+2, text);
++-  if(re[0] == '$' && re[1] == '\0')
++-    return *text == '\0';
++-  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
++-    return matchhere(re+1, text+1);
++-  return 0;
++-}
++-
++-// matchstar: search for c*re at beginning of text
++-int matchstar(int c, char *re, char *text)
++-{
++-  do{  // a * matches zero or more instances
++-    if(matchhere(re, text))
++-      return 1;
++-  }while(*text!='\0' && (*text++==c || c=='.'));
++-  return 0;
++-}
++-
++diff --git a/ide.c b/ide.c
++deleted file mode 100644
++index b4c0b1f..0000000
++--- a/ide.c
+++++ /dev/null
++@@ -1,168 +0,0 @@
++-// Simple PIO-based (non-DMA) IDE driver code.
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "x86.h"
++-#include "traps.h"
++-#include "spinlock.h"
++-#include "sleeplock.h"
++-#include "fs.h"
++-#include "buf.h"
++-
++-#define SECTOR_SIZE   512
++-#define IDE_BSY       0x80
++-#define IDE_DRDY      0x40
++-#define IDE_DF        0x20
++-#define IDE_ERR       0x01
++-
++-#define IDE_CMD_READ  0x20
++-#define IDE_CMD_WRITE 0x30
++-#define IDE_CMD_RDMUL 0xc4
++-#define IDE_CMD_WRMUL 0xc5
++-
++-// idequeue points to the buf now being read/written to the disk.
++-// idequeue->qnext points to the next buf to be processed.
++-// You must hold idelock while manipulating queue.
++-
++-static struct spinlock idelock;
++-static struct buf *idequeue;
++-
++-static int havedisk1;
++-static void idestart(struct buf*);
++-
++-// Wait for IDE disk to become ready.
++-static int
++-idewait(int checkerr)
++-{
++-  int r;
++-
++-  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
++-    ;
++-  if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
++-    return -1;
++-  return 0;
++-}
++-
++-void
++-ideinit(void)
++-{
++-  int i;
++-
++-  initlock(&idelock, "ide");
++-  ioapicenable(IRQ_IDE, ncpu - 1);
++-  idewait(0);
++-
++-  // Check if disk 1 is present
++-  outb(0x1f6, 0xe0 | (1<<4));
++-  for(i=0; i<1000; i++){
++-    if(inb(0x1f7) != 0){
++-      havedisk1 = 1;
++-      break;
++-    }
++-  }
++-
++-  // Switch back to disk 0.
++-  outb(0x1f6, 0xe0 | (0<<4));
++-}
++-
++-// Start the request for b.  Caller must hold idelock.
++-static void
++-idestart(struct buf *b)
++-{
++-  if(b == 0)
++-    panic("idestart");
++-  if(b->blockno >= FSSIZE)
++-    panic("incorrect blockno");
++-  int sector_per_block =  BSIZE/SECTOR_SIZE;
++-  int sector = b->blockno * sector_per_block;
++-  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
++-  int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
++-
++-  if (sector_per_block > 7) panic("idestart");
++-
++-  idewait(0);
++-  outb(0x3f6, 0);  // generate interrupt
++-  outb(0x1f2, sector_per_block);  // number of sectors
++-  outb(0x1f3, sector & 0xff);
++-  outb(0x1f4, (sector >> 8) & 0xff);
++-  outb(0x1f5, (sector >> 16) & 0xff);
++-  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
++-  if(b->flags & B_DIRTY){
++-    outb(0x1f7, write_cmd);
++-    outsl(0x1f0, b->data, BSIZE/4);
++-  } else {
++-    outb(0x1f7, read_cmd);
++-  }
++-}
++-
++-// Interrupt handler.
++-void
++-ideintr(void)
++-{
++-  struct buf *b;
++-
++-  // First queued buffer is the active request.
++-  acquire(&idelock);
++-
++-  if((b = idequeue) == 0){
++-    release(&idelock);
++-    return;
++-  }
++-  idequeue = b->qnext;
++-
++-  // Read data if needed.
++-  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
++-    insl(0x1f0, b->data, BSIZE/4);
++-
++-  // Wake process waiting for this buf.
++-  b->flags |= B_VALID;
++-  b->flags &= ~B_DIRTY;
++-  wakeup(b);
++-
++-  // Start disk on next buf in queue.
++-  if(idequeue != 0)
++-    idestart(idequeue);
++-
++-  release(&idelock);
++-}
++-
++-//PAGEBREAK!
++-// Sync buf with disk.
++-// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
++-// Else if B_VALID is not set, read buf from disk, set B_VALID.
++-void
++-iderw(struct buf *b)
++-{
++-  struct buf **pp;
++-
++-  if(!holdingsleep(&b->lock))
++-    panic("iderw: buf not locked");
++-  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
++-    panic("iderw: nothing to do");
++-  if(b->dev != 0 && !havedisk1)
++-    panic("iderw: ide disk 1 not present");
++-
++-  acquire(&idelock);  //DOC:acquire-lock
++-
++-  // Append b to idequeue.
++-  b->qnext = 0;
++-  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
++-    ;
++-  *pp = b;
++-
++-  // Start disk if necessary.
++-  if(idequeue == b)
++-    idestart(b);
++-
++-  // Wait for request to finish.
++-  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
++-    sleep(b, &idelock);
++-  }
++-
++-
++-  release(&idelock);
++-}
++diff --git a/init.c b/init.c
++deleted file mode 100644
++index bc6547f..0000000
++--- a/init.c
+++++ /dev/null
++@@ -1,37 +0,0 @@
++-// init: The initial user-level program
++-
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-#include "fcntl.h"
++-
++-char *argv[] = { "sh", 0 };
++-
++-int
++-main(void)
++-{
++-  int pid, wpid;
++-
++-  if(open("console", O_RDWR) < 0){
++-    mknod("console", 1, 1);
++-    open("console", O_RDWR);
++-  }
++-  dup(0);  // stdout
++-  dup(0);  // stderr
++-
++-  for(;;){
++-    printf(1, "init: starting sh\n");
++-    pid = fork();
++-    if(pid < 0){
++-      printf(1, "init: fork failed\n");
++-      exit(2);
++-    }
++-    if(pid == 0){
++-      exec("sh", argv);
++-      printf(1, "init: exec sh failed\n");
++-      exit(1);
++-    }
++-    while((wpid=wait(NULL)) >= 0 && wpid != pid)
++-      printf(1, "zombie!\n");
++-  }
++-}
++diff --git a/initcode.S b/initcode.S
++deleted file mode 100644
++index 80ac5d8..0000000
++--- a/initcode.S
+++++ /dev/null
++@@ -1,32 +0,0 @@
++-# Initial process execs /init.
++-# This code runs in user space.
++-
++-#include "syscall.h"
++-#include "traps.h"
++-
++-
++-# exec(init, argv)
++-.globl start
++-start:
++-  pushl $argv
++-  pushl $init
++-  pushl $0  // where caller pc would be
++-  movl $SYS_exec, %eax
++-  int $T_SYSCALL
++-
++-# for(;;) exit();
++-exit:
++-  movl $SYS_exit, %eax
++-  int $T_SYSCALL
++-  jmp exit
++-
++-# char init[] = "/init\0";
++-init:
++-  .string "/init\0"
++-
++-# char *argv[] = { init, 0 };
++-.p2align 2
++-argv:
++-  .long init
++-  .long 0
++-
++diff --git a/ioapic.c b/ioapic.c
++deleted file mode 100644
++index cb0f015..0000000
++--- a/ioapic.c
+++++ /dev/null
++@@ -1,75 +0,0 @@
++-// The I/O APIC manages hardware interrupts for an SMP system.
++-// http://www.intel.com/design/chipsets/datashts/29056601.pdf
++-// See also picirq.c.
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "traps.h"
++-
++-#define IOAPIC  0xFEC00000   // Default physical address of IO APIC
++-
++-#define REG_ID     0x00  // Register index: ID
++-#define REG_VER    0x01  // Register index: version
++-#define REG_TABLE  0x10  // Redirection table base
++-
++-// The redirection table starts at REG_TABLE and uses
++-// two registers to configure each interrupt.
++-// The first (low) register in a pair contains configuration bits.
++-// The second (high) register contains a bitmask telling which
++-// CPUs can serve that interrupt.
++-#define INT_DISABLED   0x00010000  // Interrupt disabled
++-#define INT_LEVEL      0x00008000  // Level-triggered (vs edge-)
++-#define INT_ACTIVELOW  0x00002000  // Active low (vs high)
++-#define INT_LOGICAL    0x00000800  // Destination is CPU id (vs APIC ID)
++-
++-volatile struct ioapic *ioapic;
++-
++-// IO APIC MMIO structure: write reg, then read or write data.
++-struct ioapic {
++-  uint reg;
++-  uint pad[3];
++-  uint data;
++-};
++-
++-static uint
++-ioapicread(int reg)
++-{
++-  ioapic->reg = reg;
++-  return ioapic->data;
++-}
++-
++-static void
++-ioapicwrite(int reg, uint data)
++-{
++-  ioapic->reg = reg;
++-  ioapic->data = data;
++-}
++-
++-void
++-ioapicinit(void)
++-{
++-  int i, id, maxintr;
++-
++-  ioapic = (volatile struct ioapic*)IOAPIC;
++-  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
++-  id = ioapicread(REG_ID) >> 24;
++-  if(id != ioapicid)
++-    cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
++-
++-  // Mark all interrupts edge-triggered, active high, disabled,
++-  // and not routed to any CPUs.
++-  for(i = 0; i <= maxintr; i++){
++-    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
++-    ioapicwrite(REG_TABLE+2*i+1, 0);
++-  }
++-}
++-
++-void
++-ioapicenable(int irq, int cpunum)
++-{
++-  // Mark interrupt edge-triggered, active high,
++-  // enabled, and routed to the given cpunum,
++-  // which happens to be that cpu's APIC ID.
++-  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
++-  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
++-}
++diff --git a/kalloc.c b/kalloc.c
++deleted file mode 100644
++index 14cd4f4..0000000
++--- a/kalloc.c
+++++ /dev/null
++@@ -1,96 +0,0 @@
++-// Physical memory allocator, intended to allocate
++-// memory for user processes, kernel stacks, page table pages,
++-// and pipe buffers. Allocates 4096-byte pages.
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-#include "spinlock.h"
++-
++-void freerange(void *vstart, void *vend);
++-extern char end[]; // first address after kernel loaded from ELF file
++-                   // defined by the kernel linker script in kernel.ld
++-
++-struct run {
++-  struct run *next;
++-};
++-
++-struct {
++-  struct spinlock lock;
++-  int use_lock;
++-  struct run *freelist;
++-} kmem;
++-
++-// Initialization happens in two phases.
++-// 1. main() calls kinit1() while still using entrypgdir to place just
++-// the pages mapped by entrypgdir on free list.
++-// 2. main() calls kinit2() with the rest of the physical pages
++-// after installing a full page table that maps them on all cores.
++-void
++-kinit1(void *vstart, void *vend)
++-{
++-  initlock(&kmem.lock, "kmem");
++-  kmem.use_lock = 0;
++-  freerange(vstart, vend);
++-}
++-
++-void
++-kinit2(void *vstart, void *vend)
++-{
++-  freerange(vstart, vend);
++-  kmem.use_lock = 1;
++-}
++-
++-void
++-freerange(void *vstart, void *vend)
++-{
++-  char *p;
++-  p = (char*)PGROUNDUP((uint)vstart);
++-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
++-    kfree(p);
++-}
++-//PAGEBREAK: 21
++-// Free the page of physical memory pointed at by v,
++-// which normally should have been returned by a
++-// call to kalloc().  (The exception is when
++-// initializing the allocator; see kinit above.)
++-void
++-kfree(char *v)
++-{
++-  struct run *r;
++-
++-  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
++-    panic("kfree");
++-
++-  // Fill with junk to catch dangling refs.
++-  memset(v, 1, PGSIZE);
++-
++-  if(kmem.use_lock)
++-    acquire(&kmem.lock);
++-  r = (struct run*)v;
++-  r->next = kmem.freelist;
++-  kmem.freelist = r;
++-  if(kmem.use_lock)
++-    release(&kmem.lock);
++-}
++-
++-// Allocate one 4096-byte page of physical memory.
++-// Returns a pointer that the kernel can use.
++-// Returns 0 if the memory cannot be allocated.
++-char*
++-kalloc(void)
++-{
++-  struct run *r;
++-
++-  if(kmem.use_lock)
++-    acquire(&kmem.lock);
++-  r = kmem.freelist;
++-  if(r)
++-    kmem.freelist = r->next;
++-  if(kmem.use_lock)
++-    release(&kmem.lock);
++-  return (char*)r;
++-}
++-
++diff --git a/kbd.c b/kbd.c
++deleted file mode 100644
++index 32c1463..0000000
++--- a/kbd.c
+++++ /dev/null
++@@ -1,50 +0,0 @@
++-#include "types.h"
++-#include "x86.h"
++-#include "defs.h"
++-#include "kbd.h"
++-
++-int
++-kbdgetc(void)
++-{
++-  static uint shift;
++-  static uchar *charcode[4] = {
++-    normalmap, shiftmap, ctlmap, ctlmap
++-  };
++-  uint st, data, c;
++-
++-  st = inb(KBSTATP);
++-  if((st & KBS_DIB) == 0)
++-    return -1;
++-  data = inb(KBDATAP);
++-
++-  if(data == 0xE0){
++-    shift |= E0ESC;
++-    return 0;
++-  } else if(data & 0x80){
++-    // Key released
++-    data = (shift & E0ESC ? data : data & 0x7F);
++-    shift &= ~(shiftcode[data] | E0ESC);
++-    return 0;
++-  } else if(shift & E0ESC){
++-    // Last character was an E0 escape; or with 0x80
++-    data |= 0x80;
++-    shift &= ~E0ESC;
++-  }
++-
++-  shift |= shiftcode[data];
++-  shift ^= togglecode[data];
++-  c = charcode[shift & (CTL | SHIFT)][data];
++-  if(shift & CAPSLOCK){
++-    if('a' <= c && c <= 'z')
++-      c += 'A' - 'a';
++-    else if('A' <= c && c <= 'Z')
++-      c += 'a' - 'A';
++-  }
++-  return c;
++-}
++-
++-void
++-kbdintr(void)
++-{
++-  consoleintr(kbdgetc);
++-}
++diff --git a/kbd.h b/kbd.h
++deleted file mode 100644
++index babbd6e..0000000
++--- a/kbd.h
+++++ /dev/null
++@@ -1,112 +0,0 @@
++-// PC keyboard interface constants
++-
++-#define KBSTATP         0x64    // kbd controller status port(I)
++-#define KBS_DIB         0x01    // kbd data in buffer
++-#define KBDATAP         0x60    // kbd data port(I)
++-
++-#define NO              0
++-
++-#define SHIFT           (1<<0)
++-#define CTL             (1<<1)
++-#define ALT             (1<<2)
++-
++-#define CAPSLOCK        (1<<3)
++-#define NUMLOCK         (1<<4)
++-#define SCROLLLOCK      (1<<5)
++-
++-#define E0ESC           (1<<6)
++-
++-// Special keycodes
++-#define KEY_HOME        0xE0
++-#define KEY_END         0xE1
++-#define KEY_UP          0xE2
++-#define KEY_DN          0xE3
++-#define KEY_LF          0xE4
++-#define KEY_RT          0xE5
++-#define KEY_PGUP        0xE6
++-#define KEY_PGDN        0xE7
++-#define KEY_INS         0xE8
++-#define KEY_DEL         0xE9
++-
++-// C('A') == Control-A
++-#define C(x) (x - '@')
++-
++-static uchar shiftcode[256] =
++-{
++-  [0x1D] CTL,
++-  [0x2A] SHIFT,
++-  [0x36] SHIFT,
++-  [0x38] ALT,
++-  [0x9D] CTL,
++-  [0xB8] ALT
++-};
++-
++-static uchar togglecode[256] =
++-{
++-  [0x3A] CAPSLOCK,
++-  [0x45] NUMLOCK,
++-  [0x46] SCROLLLOCK
++-};
++-
++-static uchar normalmap[256] =
++-{
++-  NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  // 0x00
++-  '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
++-  'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  // 0x10
++-  'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
++-  'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  // 0x20
++-  '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
++-  'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  // 0x30
++-  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
++-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
++-  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
++-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
++-  [0x9C] '\n',      // KP_Enter
++-  [0xB5] '/',       // KP_Div
++-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
++-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
++-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
++-  [0x97] KEY_HOME,  [0xCF] KEY_END,
++-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
++-};
++-
++-static uchar shiftmap[256] =
++-{
++-  NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  // 0x00
++-  '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
++-  'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  // 0x10
++-  'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
++-  'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  // 0x20
++-  '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
++-  'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  // 0x30
++-  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
++-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
++-  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
++-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
++-  [0x9C] '\n',      // KP_Enter
++-  [0xB5] '/',       // KP_Div
++-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
++-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
++-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
++-  [0x97] KEY_HOME,  [0xCF] KEY_END,
++-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
++-};
++-
++-static uchar ctlmap[256] =
++-{
++-  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
++-  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
++-  C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
++-  C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
++-  C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
++-  NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
++-  C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
++-  [0x9C] '\r',      // KP_Enter
++-  [0xB5] C('/'),    // KP_Div
++-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
++-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
++-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
++-  [0x97] KEY_HOME,  [0xCF] KEY_END,
++-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
++-};
++-
++diff --git a/kernel.ld b/kernel.ld
++deleted file mode 100644
++index 4e12e14..0000000
++--- a/kernel.ld
+++++ /dev/null
++@@ -1,64 +0,0 @@
++-/* Simple linker script for the JOS kernel.
++-   See the GNU ld 'info' manual ("info ld") to learn the syntax. */
++-
++-OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
++-OUTPUT_ARCH(i386)
++-ENTRY(_start)
++-
++-SECTIONS
++-{
++-	/* Link the kernel at this address: "." means the current address */
++-        /* Must be equal to KERNLINK */
++-	. = 0x80100000;
++-
++-	.text : AT(0x100000) {
++-		*(.text .stub .text.* .gnu.linkonce.t.*)
++-	}
++-
++-	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
++-
++-	.rodata : {
++-		*(.rodata .rodata.* .gnu.linkonce.r.*)
++-	}
++-
++-	/* Include debugging information in kernel memory */
++-	.stab : {
++-		PROVIDE(__STAB_BEGIN__ = .);
++-		*(.stab);
++-		PROVIDE(__STAB_END__ = .);
++-	}
++-
++-	.stabstr : {
++-		PROVIDE(__STABSTR_BEGIN__ = .);
++-		*(.stabstr);
++-		PROVIDE(__STABSTR_END__ = .);
++-	}
++-
++-	/* Adjust the address for the data segment to the next page */
++-	. = ALIGN(0x1000);
++-
++-	/* Conventionally, Unix linkers provide pseudo-symbols
++-	 * etext, edata, and end, at the end of the text, data, and bss.
++-	 * For the kernel mapping, we need the address at the beginning
++-	 * of the data section, but that's not one of the conventional
++-	 * symbols, because the convention started before there was a
++-	 * read-only rodata section between text and data. */
++-	PROVIDE(data = .);
++-
++-	/* The data segment */
++-	.data : {
++-		*(.data)
++-	}
++-
++-	PROVIDE(edata = .);
++-
++-	.bss : {
++-		*(.bss)
++-	}
++-
++-	PROVIDE(end = .);
++-
++-	/DISCARD/ : {
++-		*(.eh_frame .note.GNU-stack)
++-	}
++-}
++diff --git a/kill.c b/kill.c
++deleted file mode 100644
++index 875916c..0000000
++--- a/kill.c
+++++ /dev/null
++@@ -1,17 +0,0 @@
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-
++-int
++-main(int argc, char **argv)
++-{
++-  int i;
++-
++-  if(argc < 2){
++-    printf(2, "usage: kill pid...\n");
++-    exit(1);
++-  }
++-  for(i=1; i<argc; i++)
++-    kill(atoi(argv[i]));
++-  exit(0);
++-}
++diff --git a/lab1.c b/lab3.c
++similarity index 50%
++rename from lab1.c
++rename to lab3.c
++index 2192a52..7cf6b00 100644
++--- a/lab1.c
+++++ b/lab3.c
++@@ -16,54 +16,11 @@
++ #include "types.h"
++ #include "user.h"
++ 
++-int main(int argc, char **argv) {
+++int main(int argc, char *argv[]) {
++ 
++-    int pid;
+++    int v = argc;
++ 
++-    pid = fork();
++-
++-    if(pid > 0)
++-    {
++-        waitpid(pid, NULL, 0);
++-        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
++-        exit(0);
++-    }
++-
++-
++-    pid = fork();
++-
++-    if(pid == 0)
++-    {
++-        printf(1, "I'm the child! PID: %d\n", pid);
++-    }
++-    else
++-    {
++-        printf(1, "I'm the parent! PID: %d\n", pid);
++-        waitpid(pid, NULL, 0);
++-
++-    }
++-
++-
++-    exit(0);
+++    printf(1, "%d",sizeof(*argv) / sizeof(*argv[0]));
+++    printf(1, "%p\n", &v);
+++    exit();
++ }
++-//    printf(1, "Waitpid Demo Initializing...\n"); // fd=1 means standard output.
++-//
++-//    int defValue = -1;
++-//    int* status = &defValue;
++-//
++-//    int pid = fork();
++-//
++-//
++-//    if(pid > 0)
++-//    while(waitpid(pid, status, 0) == -1);
++-//
++-//    if(pid == 0)
++-//    {
++-//        printf(1, "hi im the child :)\n"); // fd=1 means standard output.
++-//        exit(0);
++-//    }
++-//
++-//    printf(1, "Exit status returned is: %d\n", *status); // fd=1 means standard output.
++-//
++-//    exit(0);
++-//}
++diff --git a/lab3p2.c b/lab3p2.c
++new file mode 100644
++index 0000000..f94207f
++--- /dev/null
+++++ b/lab3p2.c
++@@ -0,0 +1,31 @@
+++#include "types.h"
+++#include "user.h"
+++
+++// Prevent this function from being optimized, which might give it closed form
+++#pragma GCC push_options
+++#pragma GCC optimize ("O0")
+++static int
+++recurse(int n)
+++{
+++    if(n == 0)
+++        return 0;
+++    return n + recurse(n - 1);
+ +}
+++#pragma GCC pop_options
+ +
+ +int
+-+sys_waitpid(int pid, int* status, int options)
+++main(int argc, char *argv[])
+ +{
+-+    return waitpid(pid, status, options);
+- }
+- 
+- int
+++    int n, m;
+++
+++    if(argc != 2){
+++        printf(1, "Usage: %s levels\n", argv[0]);
+++        exit();
+++    }
+++
+++    n = atoi(argv[1]);
+++    printf(1, "Lab 3: Recursing %d levels\n", n);
+++    m = recurse(n);
+++    printf(1, "Lab 3: Yielded a value of %d\n", m);
+++    exit();
+++}
++\ No newline at end of file
++diff --git a/lapic.c b/lapic.c
++deleted file mode 100644
++index b22bbd7..0000000
++--- a/lapic.c
+++++ /dev/null
++@@ -1,229 +0,0 @@
++-// The local APIC manages internal (non-I/O) interrupts.
++-// See Chapter 8 & Appendix C of Intel processor manual volume 3.
++-
++-#include "param.h"
++-#include "types.h"
++-#include "defs.h"
++-#include "date.h"
++-#include "memlayout.h"
++-#include "traps.h"
++-#include "mmu.h"
++-#include "x86.h"
++-
++-// Local APIC registers, divided by 4 for use as uint[] indices.
++-#define ID      (0x0020/4)   // ID
++-#define VER     (0x0030/4)   // Version
++-#define TPR     (0x0080/4)   // Task Priority
++-#define EOI     (0x00B0/4)   // EOI
++-#define SVR     (0x00F0/4)   // Spurious Interrupt Vector
++-  #define ENABLE     0x00000100   // Unit Enable
++-#define ESR     (0x0280/4)   // Error Status
++-#define ICRLO   (0x0300/4)   // Interrupt Command
++-  #define INIT       0x00000500   // INIT/RESET
++-  #define STARTUP    0x00000600   // Startup IPI
++-  #define DELIVS     0x00001000   // Delivery status
++-  #define ASSERT     0x00004000   // Assert interrupt (vs deassert)
++-  #define DEASSERT   0x00000000
++-  #define LEVEL      0x00008000   // Level triggered
++-  #define BCAST      0x00080000   // Send to all APICs, including self.
++-  #define BUSY       0x00001000
++-  #define FIXED      0x00000000
++-#define ICRHI   (0x0310/4)   // Interrupt Command [63:32]
++-#define TIMER   (0x0320/4)   // Local Vector Table 0 (TIMER)
++-  #define X1         0x0000000B   // divide counts by 1
++-  #define PERIODIC   0x00020000   // Periodic
++-#define PCINT   (0x0340/4)   // Performance Counter LVT
++-#define LINT0   (0x0350/4)   // Local Vector Table 1 (LINT0)
++-#define LINT1   (0x0360/4)   // Local Vector Table 2 (LINT1)
++-#define ERROR   (0x0370/4)   // Local Vector Table 3 (ERROR)
++-  #define MASKED     0x00010000   // Interrupt masked
++-#define TICR    (0x0380/4)   // Timer Initial Count
++-#define TCCR    (0x0390/4)   // Timer Current Count
++-#define TDCR    (0x03E0/4)   // Timer Divide Configuration
++-
++-volatile uint *lapic;  // Initialized in mp.c
++-
++-//PAGEBREAK!
++-static void
++-lapicw(int index, int value)
++-{
++-  lapic[index] = value;
++-  lapic[ID];  // wait for write to finish, by reading
++-}
++-
++-void
++-lapicinit(void)
++-{
++-  if(!lapic)
++-    return;
++-
++-  // Enable local APIC; set spurious interrupt vector.
++-  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
++-
++-  // The timer repeatedly counts down at bus frequency
++-  // from lapic[TICR] and then issues an interrupt.
++-  // If xv6 cared more about precise timekeeping,
++-  // TICR would be calibrated using an external time source.
++-  lapicw(TDCR, X1);
++-  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
++-  lapicw(TICR, 10000000);
++-
++-  // Disable logical interrupt lines.
++-  lapicw(LINT0, MASKED);
++-  lapicw(LINT1, MASKED);
++-
++-  // Disable performance counter overflow interrupts
++-  // on machines that provide that interrupt entry.
++-  if(((lapic[VER]>>16) & 0xFF) >= 4)
++-    lapicw(PCINT, MASKED);
++-
++-  // Map error interrupt to IRQ_ERROR.
++-  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
++-
++-  // Clear error status register (requires back-to-back writes).
++-  lapicw(ESR, 0);
++-  lapicw(ESR, 0);
++-
++-  // Ack any outstanding interrupts.
++-  lapicw(EOI, 0);
++-
++-  // Send an Init Level De-Assert to synchronise arbitration ID's.
++-  lapicw(ICRHI, 0);
++-  lapicw(ICRLO, BCAST | INIT | LEVEL);
++-  while(lapic[ICRLO] & DELIVS)
++-    ;
++-
++-  // Enable interrupts on the APIC (but not on the processor).
++-  lapicw(TPR, 0);
++-}
++-
++-int
++-lapicid(void)
++-{
++-  if (!lapic)
++-    return 0;
++-  return lapic[ID] >> 24;
++-}
++-
++-// Acknowledge interrupt.
++-void
++-lapiceoi(void)
++-{
++-  if(lapic)
++-    lapicw(EOI, 0);
++-}
++-
++-// Spin for a given number of microseconds.
++-// On real hardware would want to tune this dynamically.
++-void
++-microdelay(int us)
++-{
++-}
++-
++-#define CMOS_PORT    0x70
++-#define CMOS_RETURN  0x71
++-
++-// Start additional processor running entry code at addr.
++-// See Appendix B of MultiProcessor Specification.
++-void
++-lapicstartap(uchar apicid, uint addr)
++-{
++-  int i;
++-  ushort *wrv;
++-
++-  // "The BSP must initialize CMOS shutdown code to 0AH
++-  // and the warm reset vector (DWORD based at 40:67) to point at
++-  // the AP startup code prior to the [universal startup algorithm]."
++-  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
++-  outb(CMOS_PORT+1, 0x0A);
++-  wrv = (ushort*)P2V((0x40<<4 | 0x67));  // Warm reset vector
++-  wrv[0] = 0;
++-  wrv[1] = addr >> 4;
++-
++-  // "Universal startup algorithm."
++-  // Send INIT (level-triggered) interrupt to reset other CPU.
++-  lapicw(ICRHI, apicid<<24);
++-  lapicw(ICRLO, INIT | LEVEL | ASSERT);
++-  microdelay(200);
++-  lapicw(ICRLO, INIT | LEVEL);
++-  microdelay(100);    // should be 10ms, but too slow in Bochs!
++-
++-  // Send startup IPI (twice!) to enter code.
++-  // Regular hardware is supposed to only accept a STARTUP
++-  // when it is in the halted state due to an INIT.  So the second
++-  // should be ignored, but it is part of the official Intel algorithm.
++-  // Bochs complains about the second one.  Too bad for Bochs.
++-  for(i = 0; i < 2; i++){
++-    lapicw(ICRHI, apicid<<24);
++-    lapicw(ICRLO, STARTUP | (addr>>12));
++-    microdelay(200);
++-  }
++-}
++-
++-#define CMOS_STATA   0x0a
++-#define CMOS_STATB   0x0b
++-#define CMOS_UIP    (1 << 7)        // RTC update in progress
++-
++-#define SECS    0x00
++-#define MINS    0x02
++-#define HOURS   0x04
++-#define DAY     0x07
++-#define MONTH   0x08
++-#define YEAR    0x09
++-
++-static uint
++-cmos_read(uint reg)
++-{
++-  outb(CMOS_PORT,  reg);
++-  microdelay(200);
++-
++-  return inb(CMOS_RETURN);
++-}
++-
++-static void
++-fill_rtcdate(struct rtcdate *r)
++-{
++-  r->second = cmos_read(SECS);
++-  r->minute = cmos_read(MINS);
++-  r->hour   = cmos_read(HOURS);
++-  r->day    = cmos_read(DAY);
++-  r->month  = cmos_read(MONTH);
++-  r->year   = cmos_read(YEAR);
++-}
++-
++-// qemu seems to use 24-hour GWT and the values are BCD encoded
++-void
++-cmostime(struct rtcdate *r)
++-{
++-  struct rtcdate t1, t2;
++-  int sb, bcd;
++-
++-  sb = cmos_read(CMOS_STATB);
++-
++-  bcd = (sb & (1 << 2)) == 0;
++-
++-  // make sure CMOS doesn't modify time while we read it
++-  for(;;) {
++-    fill_rtcdate(&t1);
++-    if(cmos_read(CMOS_STATA) & CMOS_UIP)
++-        continue;
++-    fill_rtcdate(&t2);
++-    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
++-      break;
++-  }
++-
++-  // convert
++-  if(bcd) {
++-#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
++-    CONV(second);
++-    CONV(minute);
++-    CONV(hour  );
++-    CONV(day   );
++-    CONV(month );
++-    CONV(year  );
++-#undef     CONV
++-  }
++-
++-  *r = t1;
++-  r->year += 2000;
++-}
++diff --git a/ln.c b/ln.c
++deleted file mode 100644
++index fb17c3b..0000000
++--- a/ln.c
+++++ /dev/null
++@@ -1,15 +0,0 @@
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-
++-int
++-main(int argc, char *argv[])
++-{
++-  if(argc != 3){
++-    printf(2, "Usage: ln old new\n");
++-    exit(1);
++-  }
++-  if(link(argv[1], argv[2]) < 0)
++-    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
++-  exit(0);
++-}
++diff --git a/log.c b/log.c
++deleted file mode 100644
++index a64c0f6..0000000
++--- a/log.c
+++++ /dev/null
++@@ -1,234 +0,0 @@
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "spinlock.h"
++-#include "sleeplock.h"
++-#include "fs.h"
++-#include "buf.h"
++-
++-// Simple logging that allows concurrent FS system calls.
++-//
++-// A log transaction contains the updates of multiple FS system
++-// calls. The logging system only commits when there are
++-// no FS system calls active. Thus there is never
++-// any reasoning required about whether a commit might
++-// write an uncommitted system call's updates to disk.
++-//
++-// A system call should call begin_op()/end_op() to mark
++-// its start and end. Usually begin_op() just increments
++-// the count of in-progress FS system calls and returns.
++-// But if it thinks the log is close to running out, it
++-// sleeps until the last outstanding end_op() commits.
++-//
++-// The log is a physical re-do log containing disk blocks.
++-// The on-disk log format:
++-//   header block, containing block #s for block A, B, C, ...
++-//   block A
++-//   block B
++-//   block C
++-//   ...
++-// Log appends are synchronous.
++-
++-// Contents of the header block, used for both the on-disk header block
++-// and to keep track in memory of logged block# before commit.
++-struct logheader {
++-  int n;
++-  int block[LOGSIZE];
++-};
++-
++-struct log {
++-  struct spinlock lock;
++-  int start;
++-  int size;
++-  int outstanding; // how many FS sys calls are executing.
++-  int committing;  // in commit(), please wait.
++-  int dev;
++-  struct logheader lh;
++-};
++-struct log log;
++-
++-static void recover_from_log(void);
++-static void commit();
++-
++-void
++-initlog(int dev)
++-{
++-  if (sizeof(struct logheader) >= BSIZE)
++-    panic("initlog: too big logheader");
++-
++-  struct superblock sb;
++-  initlock(&log.lock, "log");
++-  readsb(dev, &sb);
++-  log.start = sb.logstart;
++-  log.size = sb.nlog;
++-  log.dev = dev;
++-  recover_from_log();
++-}
++-
++-// Copy committed blocks from log to their home location
++-static void
++-install_trans(void)
++-{
++-  int tail;
++-
++-  for (tail = 0; tail < log.lh.n; tail++) {
++-    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
++-    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
++-    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
++-    bwrite(dbuf);  // write dst to disk
++-    brelse(lbuf);
++-    brelse(dbuf);
++-  }
++-}
++-
++-// Read the log header from disk into the in-memory log header
++-static void
++-read_head(void)
++-{
++-  struct buf *buf = bread(log.dev, log.start);
++-  struct logheader *lh = (struct logheader *) (buf->data);
++-  int i;
++-  log.lh.n = lh->n;
++-  for (i = 0; i < log.lh.n; i++) {
++-    log.lh.block[i] = lh->block[i];
++-  }
++-  brelse(buf);
++-}
++-
++-// Write in-memory log header to disk.
++-// This is the true point at which the
++-// current transaction commits.
++-static void
++-write_head(void)
++-{
++-  struct buf *buf = bread(log.dev, log.start);
++-  struct logheader *hb = (struct logheader *) (buf->data);
++-  int i;
++-  hb->n = log.lh.n;
++-  for (i = 0; i < log.lh.n; i++) {
++-    hb->block[i] = log.lh.block[i];
++-  }
++-  bwrite(buf);
++-  brelse(buf);
++-}
++-
++-static void
++-recover_from_log(void)
++-{
++-  read_head();
++-  install_trans(); // if committed, copy from log to disk
++-  log.lh.n = 0;
++-  write_head(); // clear the log
++-}
++-
++-// called at the start of each FS system call.
++-void
++-begin_op(void)
++-{
++-  acquire(&log.lock);
++-  while(1){
++-    if(log.committing){
++-      sleep(&log, &log.lock);
++-    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
++-      // this op might exhaust log space; wait for commit.
++-      sleep(&log, &log.lock);
++-    } else {
++-      log.outstanding += 1;
++-      release(&log.lock);
++-      break;
++-    }
++-  }
++-}
++-
++-// called at the end of each FS system call.
++-// commits if this was the last outstanding operation.
++-void
++-end_op(void)
++-{
++-  int do_commit = 0;
++-
++-  acquire(&log.lock);
++-  log.outstanding -= 1;
++-  if(log.committing)
++-    panic("log.committing");
++-  if(log.outstanding == 0){
++-    do_commit = 1;
++-    log.committing = 1;
++-  } else {
++-    // begin_op() may be waiting for log space,
++-    // and decrementing log.outstanding has decreased
++-    // the amount of reserved space.
++-    wakeup(&log);
++-  }
++-  release(&log.lock);
++-
++-  if(do_commit){
++-    // call commit w/o holding locks, since not allowed
++-    // to sleep with locks.
++-    commit();
++-    acquire(&log.lock);
++-    log.committing = 0;
++-    wakeup(&log);
++-    release(&log.lock);
++-  }
++-}
++-
++-// Copy modified blocks from cache to log.
++-static void
++-write_log(void)
++-{
++-  int tail;
++-
++-  for (tail = 0; tail < log.lh.n; tail++) {
++-    struct buf *to = bread(log.dev, log.start+tail+1); // log block
++-    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
++-    memmove(to->data, from->data, BSIZE);
++-    bwrite(to);  // write the log
++-    brelse(from);
++-    brelse(to);
++-  }
++-}
++-
++-static void
++-commit()
++-{
++-  if (log.lh.n > 0) {
++-    write_log();     // Write modified blocks from cache to log
++-    write_head();    // Write header to disk -- the real commit
++-    install_trans(); // Now install writes to home locations
++-    log.lh.n = 0;
++-    write_head();    // Erase the transaction from the log
++-  }
++-}
++-
++-// Caller has modified b->data and is done with the buffer.
++-// Record the block number and pin in the cache with B_DIRTY.
++-// commit()/write_log() will do the disk write.
++-//
++-// log_write() replaces bwrite(); a typical use is:
++-//   bp = bread(...)
++-//   modify bp->data[]
++-//   log_write(bp)
++-//   brelse(bp)
++-void
++-log_write(struct buf *b)
++-{
++-  int i;
++-
++-  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
++-    panic("too big a transaction");
++-  if (log.outstanding < 1)
++-    panic("log_write outside of trans");
++-
++-  acquire(&log.lock);
++-  for (i = 0; i < log.lh.n; i++) {
++-    if (log.lh.block[i] == b->blockno)   // log absorbtion
++-      break;
++-  }
++-  log.lh.block[i] = b->blockno;
++-  if (i == log.lh.n)
++-    log.lh.n++;
++-  b->flags |= B_DIRTY; // prevent eviction
++-  release(&log.lock);
++-}
++-
++diff --git a/ls.c b/ls.c
++deleted file mode 100644
++index 6bf943b..0000000
++--- a/ls.c
+++++ /dev/null
++@@ -1,85 +0,0 @@
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-#include "fs.h"
++-
++-char*
++-fmtname(char *path)
++-{
++-  static char buf[DIRSIZ+1];
++-  char *p;
++-
++-  // Find first character after last slash.
++-  for(p=path+strlen(path); p >= path && *p != '/'; p--)
++-    ;
++-  p++;
++-
++-  // Return blank-padded name.
++-  if(strlen(p) >= DIRSIZ)
++-    return p;
++-  memmove(buf, p, strlen(p));
++-  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
++-  return buf;
++-}
++-
++-void
++-ls(char *path)
++-{
++-  char buf[512], *p;
++-  int fd;
++-  struct dirent de;
++-  struct stat st;
++-
++-  if((fd = open(path, 0)) < 0){
++-    printf(2, "ls: cannot open %s\n", path);
++-    return;
++-  }
++-
++-  if(fstat(fd, &st) < 0){
++-    printf(2, "ls: cannot stat %s\n", path);
++-    close(fd);
++-    return;
++-  }
++-
++-  switch(st.type){
++-  case T_FILE:
++-    printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
++-    break;
++-
++-  case T_DIR:
++-    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
++-      printf(1, "ls: path too long\n");
++-      break;
++-    }
++-    strcpy(buf, path);
++-    p = buf+strlen(buf);
++-    *p++ = '/';
++-    while(read(fd, &de, sizeof(de)) == sizeof(de)){
++-      if(de.inum == 0)
++-        continue;
++-      memmove(p, de.name, DIRSIZ);
++-      p[DIRSIZ] = 0;
++-      if(stat(buf, &st) < 0){
++-        printf(1, "ls: cannot stat %s\n", buf);
++-        continue;
++-      }
++-      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
++-    }
++-    break;
++-  }
++-  close(fd);
++-}
++-
++-int
++-main(int argc, char *argv[])
++-{
++-  int i;
++-
++-  if(argc < 2){
++-    ls(".");
++-    exit(1);
++-  }
++-  for(i=1; i<argc; i++)
++-    ls(argv[i]);
++-  exit(0);
++-}
++diff --git a/main.c b/main.c
++deleted file mode 100644
++index 9924e64..0000000
++--- a/main.c
+++++ /dev/null
++@@ -1,116 +0,0 @@
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "x86.h"
++-
++-static void startothers(void);
++-static void mpmain(void)  __attribute__((noreturn));
++-extern pde_t *kpgdir;
++-extern char end[]; // first address after kernel loaded from ELF file
++-
++-// Bootstrap processor starts running C code here.
++-// Allocate a real stack and switch to it, first
++-// doing some setup required for memory allocator to work.
++-int
++-main(void)
++-{
++-  kinit1(end, P2V(4*1024*1024)); // phys page allocator
++-  kvmalloc();      // kernel page table
++-  mpinit();        // detect other processors
++-  lapicinit();     // interrupt controller
++-  seginit();       // segment descriptors
++-  picinit();       // disable pic
++-  ioapicinit();    // another interrupt controller
++-  consoleinit();   // console hardware
++-  uartinit();      // serial port
++-  pinit();         // process table
++-  tvinit();        // trap vectors
++-  binit();         // buffer cache
++-  fileinit();      // file table
++-  ideinit();       // disk 
++-  startothers();   // start other processors
++-  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
++-  userinit();      // first user process
++-  mpmain();        // finish this processor's setup
++-}
++-
++-// Other CPUs jump here from entryother.S.
++-static void
++-mpenter(void)
++-{
++-  switchkvm();
++-  seginit();
++-  lapicinit();
++-  mpmain();
++-}
++-
++-// Common CPU setup code.
++-static void
++-mpmain(void)
++-{
++-  cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
++-  idtinit();       // load idt register
++-  xchg(&(mycpu()->started), 1); // tell startothers() we're up
++-  scheduler();     // start running processes
++-}
++-
++-pde_t entrypgdir[];  // For entry.S
++-
++-// Start the non-boot (AP) processors.
++-static void
++-startothers(void)
++-{
++-  extern uchar _binary_entryother_start[], _binary_entryother_size[];
++-  uchar *code;
++-  struct cpu *c;
++-  char *stack;
++-
++-  // Write entry code to unused memory at 0x7000.
++-  // The linker has placed the image of entryother.S in
++-  // _binary_entryother_start.
++-  code = P2V(0x7000);
++-  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
++-
++-  for(c = cpus; c < cpus+ncpu; c++){
++-    if(c == mycpu())  // We've started already.
++-      continue;
++-
++-    // Tell entryother.S what stack to use, where to enter, and what
++-    // pgdir to use. We cannot use kpgdir yet, because the AP processor
++-    // is running in low  memory, so we use entrypgdir for the APs too.
++-    stack = kalloc();
++-    *(void**)(code-4) = stack + KSTACKSIZE;
++-    *(void(**)(void))(code-8) = mpenter;
++-    *(int**)(code-12) = (void *) V2P(entrypgdir);
++-
++-    lapicstartap(c->apicid, V2P(code));
++-
++-    // wait for cpu to finish mpmain()
++-    while(c->started == 0)
++-      ;
++-  }
++-}
++-
++-// The boot page table used in entry.S and entryother.S.
++-// Page directories (and page tables) must start on page boundaries,
++-// hence the __aligned__ attribute.
++-// PTE_PS in a page directory entry enables 4Mbyte pages.
++-
++-__attribute__((__aligned__(PGSIZE)))
++-pde_t entrypgdir[NPDENTRIES] = {
++-  // Map VA's [0, 4MB) to PA's [0, 4MB)
++-  [0] = (0) | PTE_P | PTE_W | PTE_PS,
++-  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
++-  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
++-};
++-
++-//PAGEBREAK!
++-// Blank page.
++-//PAGEBREAK!
++-// Blank page.
++-//PAGEBREAK!
++-// Blank page.
++-
++diff --git a/memide.c b/memide.c
++deleted file mode 100644
++index ba267ac..0000000
++--- a/memide.c
+++++ /dev/null
++@@ -1,60 +0,0 @@
++-// Fake IDE disk; stores blocks in memory.
++-// Useful for running kernel without scratch disk.
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "x86.h"
++-#include "traps.h"
++-#include "spinlock.h"
++-#include "sleeplock.h"
++-#include "fs.h"
++-#include "buf.h"
++-
++-extern uchar _binary_fs_img_start[], _binary_fs_img_size[];
++-
++-static int disksize;
++-static uchar *memdisk;
++-
++-void
++-ideinit(void)
++-{
++-  memdisk = _binary_fs_img_start;
++-  disksize = (uint)_binary_fs_img_size/BSIZE;
++-}
++-
++-// Interrupt handler.
++-void
++-ideintr(void)
++-{
++-  // no-op
++-}
++-
++-// Sync buf with disk.
++-// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
++-// Else if B_VALID is not set, read buf from disk, set B_VALID.
++-void
++-iderw(struct buf *b)
++-{
++-  uchar *p;
++-
++-  if(!holdingsleep(&b->lock))
++-    panic("iderw: buf not locked");
++-  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
++-    panic("iderw: nothing to do");
++-  if(b->dev != 1)
++-    panic("iderw: request not for disk 1");
++-  if(b->blockno >= disksize)
++-    panic("iderw: block out of range");
++-
++-  p = memdisk + b->blockno*BSIZE;
++-
++-  if(b->flags & B_DIRTY){
++-    b->flags &= ~B_DIRTY;
++-    memmove(p, b->data, BSIZE);
++-  } else
++-    memmove(b->data, p, BSIZE);
++-  b->flags |= B_VALID;
++-}
++diff --git a/memlayout.h b/memlayout.h
++deleted file mode 100644
++index d1615f7..0000000
++--- a/memlayout.h
+++++ /dev/null
++@@ -1,15 +0,0 @@
++-// Memory layout
++-
++-#define EXTMEM  0x100000            // Start of extended memory
++-#define PHYSTOP 0xE000000           // Top physical memory
++-#define DEVSPACE 0xFE000000         // Other devices are at high addresses
++-
++-// Key addresses for address space layout (see kmap in vm.c for layout)
++-#define KERNBASE 0x80000000         // First kernel virtual address
++-#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
++-
++-#define V2P(a) (((uint) (a)) - KERNBASE)
++-#define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
++-
++-#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
++-#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts
++diff --git a/mkdir.c b/mkdir.c
++deleted file mode 100644
++index 2d90781..0000000
++--- a/mkdir.c
+++++ /dev/null
++@@ -1,23 +0,0 @@
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-
++-int
++-main(int argc, char *argv[])
++-{
++-  int i;
++-
++-  if(argc < 2){
++-    printf(2, "Usage: mkdir files...\n");
++-    exit(1);
++-  }
++-
++-  for(i = 1; i < argc; i++){
++-    if(mkdir(argv[i]) < 0){
++-      printf(2, "mkdir: %s failed to create\n", argv[i]);
++-      break;
++-    }
++-  }
++-
++-  exit(0);
++-}
++diff --git a/mkfs.c b/mkfs.c
++deleted file mode 100644
++index 8e011a7..0000000
++--- a/mkfs.c
+++++ /dev/null
++@@ -1,297 +0,0 @@
++-#include <stdio.h>
++-#include <unistd.h>
++-#include <stdlib.h>
++-#include <string.h>
++-#include <fcntl.h>
++-#include <assert.h>
++-
++-#define stat xv6_stat  // avoid clash with host struct stat
++-#include "types.h"
++-#include "fs.h"
++-#include "stat.h"
++-#include "param.h"
++-
++-#ifndef static_assert
++-#define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0)
++-#endif
++-
++-#define NINODES 200
++-
++-// Disk layout:
++-// [ boot block | sb block | log | inode blocks | free bit map | data blocks ]
++-
++-int nbitmap = FSSIZE/(BSIZE*8) + 1;
++-int ninodeblocks = NINODES / IPB + 1;
++-int nlog = LOGSIZE;
++-int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
++-int nblocks;  // Number of data blocks
++-
++-int fsfd;
++-struct superblock sb;
++-char zeroes[BSIZE];
++-uint freeinode = 1;
++-uint freeblock;
++-
++-
++-void balloc(int);
++-void wsect(uint, void*);
++-void winode(uint, struct dinode*);
++-void rinode(uint inum, struct dinode *ip);
++-void rsect(uint sec, void *buf);
++-uint ialloc(ushort type);
++-void iappend(uint inum, void *p, int n);
++-
++-// convert to intel byte order
++-ushort
++-xshort(ushort x)
++-{
++-  ushort y;
++-  uchar *a = (uchar*)&y;
++-  a[0] = x;
++-  a[1] = x >> 8;
++-  return y;
++-}
++-
++-uint
++-xint(uint x)
++-{
++-  uint y;
++-  uchar *a = (uchar*)&y;
++-  a[0] = x;
++-  a[1] = x >> 8;
++-  a[2] = x >> 16;
++-  a[3] = x >> 24;
++-  return y;
++-}
++-
++-int
++-main(int argc, char *argv[])
++-{
++-  int i, cc, fd;
++-  uint rootino, inum, off;
++-  struct dirent de;
++-  char buf[BSIZE];
++-  struct dinode din;
++-
++-
++-  static_assert(sizeof(int) == 4, "Integers must be 4 bytes!");
++-
++-  if(argc < 2){
++-    fprintf(stderr, "Usage: mkfs fs.img files...\n");
++-    exit(1);
++-  }
++-
++-  assert((BSIZE % sizeof(struct dinode)) == 0);
++-  assert((BSIZE % sizeof(struct dirent)) == 0);
++-
++-  fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);
++-  if(fsfd < 0){
++-    perror(argv[1]);
++-    exit(1);
++-  }
++-
++-  // 1 fs block = 1 disk sector
++-  nmeta = 2 + nlog + ninodeblocks + nbitmap;
++-  nblocks = FSSIZE - nmeta;
++-
++-  sb.size = xint(FSSIZE);
++-  sb.nblocks = xint(nblocks);
++-  sb.ninodes = xint(NINODES);
++-  sb.nlog = xint(nlog);
++-  sb.logstart = xint(2);
++-  sb.inodestart = xint(2+nlog);
++-  sb.bmapstart = xint(2+nlog+ninodeblocks);
++-
++-  printf("nmeta %d (boot, super, log blocks %u inode blocks %u, bitmap blocks %u) blocks %d total %d\n",
++-         nmeta, nlog, ninodeblocks, nbitmap, nblocks, FSSIZE);
++-
++-  freeblock = nmeta;     // the first free block that we can allocate
++-
++-  for(i = 0; i < FSSIZE; i++)
++-    wsect(i, zeroes);
++-
++-  memset(buf, 0, sizeof(buf));
++-  memmove(buf, &sb, sizeof(sb));
++-  wsect(1, buf);
++-
++-  rootino = ialloc(T_DIR);
++-  assert(rootino == ROOTINO);
++-
++-  bzero(&de, sizeof(de));
++-  de.inum = xshort(rootino);
++-  strcpy(de.name, ".");
++-  iappend(rootino, &de, sizeof(de));
++-
++-  bzero(&de, sizeof(de));
++-  de.inum = xshort(rootino);
++-  strcpy(de.name, "..");
++-  iappend(rootino, &de, sizeof(de));
++-
++-  for(i = 2; i < argc; i++){
++-    assert(index(argv[i], '/') == 0);
++-
++-    if((fd = open(argv[i], 0)) < 0){
++-      perror(argv[i]);
++-      exit(1);
++-    }
++-
++-    // Skip leading _ in name when writing to file system.
++-    // The binaries are named _rm, _cat, etc. to keep the
++-    // build operating system from trying to execute them
++-    // in place of system binaries like rm and cat.
++-    if(argv[i][0] == '_')
++-      ++argv[i];
++-
++-    inum = ialloc(T_FILE);
++-
++-    bzero(&de, sizeof(de));
++-    de.inum = xshort(inum);
++-    strncpy(de.name, argv[i], DIRSIZ);
++-    iappend(rootino, &de, sizeof(de));
++-
++-    while((cc = read(fd, buf, sizeof(buf))) > 0)
++-      iappend(inum, buf, cc);
++-
++-    close(fd);
++-  }
++-
++-  // fix size of root inode dir
++-  rinode(rootino, &din);
++-  off = xint(din.size);
++-  off = ((off/BSIZE) + 1) * BSIZE;
++-  din.size = xint(off);
++-  winode(rootino, &din);
++-
++-  balloc(freeblock);
++-
++-  exit(0);
++-}
++-
++-void
++-wsect(uint sec, void *buf)
++-{
++-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
++-    perror("lseek");
++-    exit(1);
++-  }
++-  if(write(fsfd, buf, BSIZE) != BSIZE){
++-    perror("write");
++-    exit(1);
++-  }
++-}
++-
++-void
++-winode(uint inum, struct dinode *ip)
++-{
++-  char buf[BSIZE];
++-  uint bn;
++-  struct dinode *dip;
++-
++-  bn = IBLOCK(inum, sb);
++-  rsect(bn, buf);
++-  dip = ((struct dinode*)buf) + (inum % IPB);
++-  *dip = *ip;
++-  wsect(bn, buf);
++-}
++-
++-void
++-rinode(uint inum, struct dinode *ip)
++-{
++-  char buf[BSIZE];
++-  uint bn;
++-  struct dinode *dip;
++-
++-  bn = IBLOCK(inum, sb);
++-  rsect(bn, buf);
++-  dip = ((struct dinode*)buf) + (inum % IPB);
++-  *ip = *dip;
++-}
++-
++-void
++-rsect(uint sec, void *buf)
++-{
++-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
++-    perror("lseek");
++-    exit(1);
++-  }
++-  if(read(fsfd, buf, BSIZE) != BSIZE){
++-    perror("read");
++-    exit(1);
++-  }
++-}
++-
++-uint
++-ialloc(ushort type)
++-{
++-  uint inum = freeinode++;
++-  struct dinode din;
++-
++-  bzero(&din, sizeof(din));
++-  din.type = xshort(type);
++-  din.nlink = xshort(1);
++-  din.size = xint(0);
++-  winode(inum, &din);
++-  return inum;
++-}
++-
++-void
++-balloc(int used)
++-{
++-  uchar buf[BSIZE];
++-  int i;
++-
++-  printf("balloc: first %d blocks have been allocated\n", used);
++-  assert(used < BSIZE*8);
++-  bzero(buf, BSIZE);
++-  for(i = 0; i < used; i++){
++-    buf[i/8] = buf[i/8] | (0x1 << (i%8));
++-  }
++-  printf("balloc: write bitmap block at sector %d\n", sb.bmapstart);
++-  wsect(sb.bmapstart, buf);
++-}
++-
++-#define min(a, b) ((a) < (b) ? (a) : (b))
++-
++-void
++-iappend(uint inum, void *xp, int n)
++-{
++-  char *p = (char*)xp;
++-  uint fbn, off, n1;
++-  struct dinode din;
++-  char buf[BSIZE];
++-  uint indirect[NINDIRECT];
++-  uint x;
++-
++-  rinode(inum, &din);
++-  off = xint(din.size);
++-  // printf("append inum %d at off %d sz %d\n", inum, off, n);
++-  while(n > 0){
++-    fbn = off / BSIZE;
++-    assert(fbn < MAXFILE);
++-    if(fbn < NDIRECT){
++-      if(xint(din.addrs[fbn]) == 0){
++-        din.addrs[fbn] = xint(freeblock++);
++-      }
++-      x = xint(din.addrs[fbn]);
++-    } else {
++-      if(xint(din.addrs[NDIRECT]) == 0){
++-        din.addrs[NDIRECT] = xint(freeblock++);
++-      }
++-      rsect(xint(din.addrs[NDIRECT]), (char*)indirect);
++-      if(indirect[fbn - NDIRECT] == 0){
++-        indirect[fbn - NDIRECT] = xint(freeblock++);
++-        wsect(xint(din.addrs[NDIRECT]), (char*)indirect);
++-      }
++-      x = xint(indirect[fbn-NDIRECT]);
++-    }
++-    n1 = min(n, (fbn + 1) * BSIZE - off);
++-    rsect(x, buf);
++-    bcopy(p, buf + off - (fbn * BSIZE), n1);
++-    wsect(x, buf);
++-    n -= n1;
++-    off += n1;
++-    p += n1;
++-  }
++-  din.size = xint(off);
++-  winode(inum, &din);
++-}
++diff --git a/mmu.h b/mmu.h
++deleted file mode 100644
++index a82d8e2..0000000
++--- a/mmu.h
+++++ /dev/null
++@@ -1,181 +0,0 @@
++-// This file contains definitions for the
++-// x86 memory management unit (MMU).
++-
++-// Eflags register
++-#define FL_IF           0x00000200      // Interrupt Enable
++-
++-// Control Register flags
++-#define CR0_PE          0x00000001      // Protection Enable
++-#define CR0_WP          0x00010000      // Write Protect
++-#define CR0_PG          0x80000000      // Paging
++-
++-#define CR4_PSE         0x00000010      // Page size extension
++-
++-// various segment selectors.
++-#define SEG_KCODE 1  // kernel code
++-#define SEG_KDATA 2  // kernel data+stack
++-#define SEG_UCODE 3  // user code
++-#define SEG_UDATA 4  // user data+stack
++-#define SEG_TSS   5  // this process's task state
++-
++-// cpu->gdt[NSEGS] holds the above segments.
++-#define NSEGS     6
++-
++-#ifndef __ASSEMBLER__
++-// Segment Descriptor
++-struct segdesc {
++-  uint lim_15_0 : 16;  // Low bits of segment limit
++-  uint base_15_0 : 16; // Low bits of segment base address
++-  uint base_23_16 : 8; // Middle bits of segment base address
++-  uint type : 4;       // Segment type (see STS_ constants)
++-  uint s : 1;          // 0 = system, 1 = application
++-  uint dpl : 2;        // Descriptor Privilege Level
++-  uint p : 1;          // Present
++-  uint lim_19_16 : 4;  // High bits of segment limit
++-  uint avl : 1;        // Unused (available for software use)
++-  uint rsv1 : 1;       // Reserved
++-  uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
++-  uint g : 1;          // Granularity: limit scaled by 4K when set
++-  uint base_31_24 : 8; // High bits of segment base address
++-};
++-
++-// Normal segment
++-#define SEG(type, base, lim, dpl) (struct segdesc)    \
++-{ ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
++-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
++-  (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
++-#define SEG16(type, base, lim, dpl) (struct segdesc)  \
++-{ (lim) & 0xffff, (uint)(base) & 0xffff,              \
++-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
++-  (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
++-#endif
++-
++-#define DPL_USER    0x3     // User DPL
++-
++-// Application segment type bits
++-#define STA_X       0x8     // Executable segment
++-#define STA_W       0x2     // Writeable (non-executable segments)
++-#define STA_R       0x2     // Readable (executable segments)
++-
++-// System segment type bits
++-#define STS_T32A    0x9     // Available 32-bit TSS
++-#define STS_IG32    0xE     // 32-bit Interrupt Gate
++-#define STS_TG32    0xF     // 32-bit Trap Gate
++-
++-// A virtual address 'la' has a three-part structure as follows:
++-//
++-// +--------10------+-------10-------+---------12----------+
++-// | Page Directory |   Page Table   | Offset within Page  |
++-// |      Index     |      Index     |                     |
++-// +----------------+----------------+---------------------+
++-//  \--- PDX(va) --/ \--- PTX(va) --/
++-
++-// page directory index
++-#define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
++-
++-// page table index
++-#define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
++-
++-// construct virtual address from indexes and offset
++-#define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
++-
++-// Page directory and page table constants.
++-#define NPDENTRIES      1024    // # directory entries per page directory
++-#define NPTENTRIES      1024    // # PTEs per page table
++-#define PGSIZE          4096    // bytes mapped by a page
++-
++-#define PTXSHIFT        12      // offset of PTX in a linear address
++-#define PDXSHIFT        22      // offset of PDX in a linear address
++-
++-#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
++-#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
++-
++-// Page table/directory entry flags.
++-#define PTE_P           0x001   // Present
++-#define PTE_W           0x002   // Writeable
++-#define PTE_U           0x004   // User
++-#define PTE_PS          0x080   // Page Size
++-
++-// Address in page table or page directory entry
++-#define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
++-#define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
++-
++-#ifndef __ASSEMBLER__
++-typedef uint pte_t;
++-
++-// Task state segment format
++-struct taskstate {
++-  uint link;         // Old ts selector
++-  uint esp0;         // Stack pointers and segment selectors
++-  ushort ss0;        //   after an increase in privilege level
++-  ushort padding1;
++-  uint *esp1;
++-  ushort ss1;
++-  ushort padding2;
++-  uint *esp2;
++-  ushort ss2;
++-  ushort padding3;
++-  void *cr3;         // Page directory base
++-  uint *eip;         // Saved state from last task switch
++-  uint eflags;
++-  uint eax;          // More saved state (registers)
++-  uint ecx;
++-  uint edx;
++-  uint ebx;
++-  uint *esp;
++-  uint *ebp;
++-  uint esi;
++-  uint edi;
++-  ushort es;         // Even more saved state (segment selectors)
++-  ushort padding4;
++-  ushort cs;
++-  ushort padding5;
++-  ushort ss;
++-  ushort padding6;
++-  ushort ds;
++-  ushort padding7;
++-  ushort fs;
++-  ushort padding8;
++-  ushort gs;
++-  ushort padding9;
++-  ushort ldt;
++-  ushort padding10;
++-  ushort t;          // Trap on task switch
++-  ushort iomb;       // I/O map base address
++-};
++-
++-// Gate descriptors for interrupts and traps
++-struct gatedesc {
++-  uint off_15_0 : 16;   // low 16 bits of offset in segment
++-  uint cs : 16;         // code segment selector
++-  uint args : 5;        // # args, 0 for interrupt/trap gates
++-  uint rsv1 : 3;        // reserved(should be zero I guess)
++-  uint type : 4;        // type(STS_{IG32,TG32})
++-  uint s : 1;           // must be 0 (system)
++-  uint dpl : 2;         // descriptor(meaning new) privilege level
++-  uint p : 1;           // Present
++-  uint off_31_16 : 16;  // high bits of offset in segment
++-};
++-
++-// Set up a normal interrupt/trap gate descriptor.
++-// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
++-//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
++-// - sel: Code segment selector for interrupt/trap handler
++-// - off: Offset in code segment for interrupt/trap handler
++-// - dpl: Descriptor Privilege Level -
++-//        the privilege level required for software to invoke
++-//        this interrupt/trap gate explicitly using an int instruction.
++-#define SETGATE(gate, istrap, sel, off, d)                \
++-{                                                         \
++-  (gate).off_15_0 = (uint)(off) & 0xffff;                \
++-  (gate).cs = (sel);                                      \
++-  (gate).args = 0;                                        \
++-  (gate).rsv1 = 0;                                        \
++-  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
++-  (gate).s = 0;                                           \
++-  (gate).dpl = (d);                                       \
++-  (gate).p = 1;                                           \
++-  (gate).off_31_16 = (uint)(off) >> 16;                  \
++-}
++-
++-#endif
++diff --git a/mp.c b/mp.c
++deleted file mode 100644
++index 79bb0ad..0000000
++--- a/mp.c
+++++ /dev/null
++@@ -1,139 +0,0 @@
++-// Multiprocessor support
++-// Search memory for MP description structures.
++-// http://developer.intel.com/design/pentium/datashts/24201606.pdf
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "memlayout.h"
++-#include "mp.h"
++-#include "x86.h"
++-#include "mmu.h"
++-#include "proc.h"
++-
++-struct cpu cpus[NCPU];
++-int ncpu;
++-uchar ioapicid;
++-
++-static uchar
++-sum(uchar *addr, int len)
++-{
++-  int i, sum;
++-
++-  sum = 0;
++-  for(i=0; i<len; i++)
++-    sum += addr[i];
++-  return sum;
++-}
++-
++-// Look for an MP structure in the len bytes at addr.
++-static struct mp*
++-mpsearch1(uint a, int len)
++-{
++-  uchar *e, *p, *addr;
++-
++-  addr = P2V(a);
++-  e = addr+len;
++-  for(p = addr; p < e; p += sizeof(struct mp))
++-    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
++-      return (struct mp*)p;
++-  return 0;
++-}
++-
++-// Search for the MP Floating Pointer Structure, which according to the
++-// spec is in one of the following three locations:
++-// 1) in the first KB of the EBDA;
++-// 2) in the last KB of system base memory;
++-// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
++-static struct mp*
++-mpsearch(void)
++-{
++-  uchar *bda;
++-  uint p;
++-  struct mp *mp;
++-
++-  bda = (uchar *) P2V(0x400);
++-  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
++-    if((mp = mpsearch1(p, 1024)))
++-      return mp;
++-  } else {
++-    p = ((bda[0x14]<<8)|bda[0x13])*1024;
++-    if((mp = mpsearch1(p-1024, 1024)))
++-      return mp;
++-  }
++-  return mpsearch1(0xF0000, 0x10000);
++-}
++-
++-// Search for an MP configuration table.  For now,
++-// don't accept the default configurations (physaddr == 0).
++-// Check for correct signature, calculate the checksum and,
++-// if correct, check the version.
++-// To do: check extended table checksum.
++-static struct mpconf*
++-mpconfig(struct mp **pmp)
++-{
++-  struct mpconf *conf;
++-  struct mp *mp;
++-
++-  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
++-    return 0;
++-  conf = (struct mpconf*) P2V((uint) mp->physaddr);
++-  if(memcmp(conf, "PCMP", 4) != 0)
++-    return 0;
++-  if(conf->version != 1 && conf->version != 4)
++-    return 0;
++-  if(sum((uchar*)conf, conf->length) != 0)
++-    return 0;
++-  *pmp = mp;
++-  return conf;
++-}
++-
++-void
++-mpinit(void)
++-{
++-  uchar *p, *e;
++-  int ismp;
++-  struct mp *mp;
++-  struct mpconf *conf;
++-  struct mpproc *proc;
++-  struct mpioapic *ioapic;
++-
++-  if((conf = mpconfig(&mp)) == 0)
++-    panic("Expect to run on an SMP");
++-  ismp = 1;
++-  lapic = (uint*)conf->lapicaddr;
++-  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
++-    switch(*p){
++-    case MPPROC:
++-      proc = (struct mpproc*)p;
++-      if(ncpu < NCPU) {
++-        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
++-        ncpu++;
++-      }
++-      p += sizeof(struct mpproc);
++-      continue;
++-    case MPIOAPIC:
++-      ioapic = (struct mpioapic*)p;
++-      ioapicid = ioapic->apicno;
++-      p += sizeof(struct mpioapic);
++-      continue;
++-    case MPBUS:
++-    case MPIOINTR:
++-    case MPLINTR:
++-      p += 8;
++-      continue;
++-    default:
++-      ismp = 0;
++-      break;
++-    }
++-  }
++-  if(!ismp)
++-    panic("Didn't find a suitable machine");
++-
++-  if(mp->imcrp){
++-    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
++-    // But it would on real hardware.
++-    outb(0x22, 0x70);   // Select IMCR
++-    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
++-  }
++-}
++diff --git a/mp.h b/mp.h
++deleted file mode 100644
++index 4d17283..0000000
++--- a/mp.h
+++++ /dev/null
++@@ -1,56 +0,0 @@
++-// See MultiProcessor Specification Version 1.[14]
++-
++-struct mp {             // floating pointer
++-  uchar signature[4];           // "_MP_"
++-  void *physaddr;               // phys addr of MP config table
++-  uchar length;                 // 1
++-  uchar specrev;                // [14]
++-  uchar checksum;               // all bytes must add up to 0
++-  uchar type;                   // MP system config type
++-  uchar imcrp;
++-  uchar reserved[3];
++-};
++-
++-struct mpconf {         // configuration table header
++-  uchar signature[4];           // "PCMP"
++-  ushort length;                // total table length
++-  uchar version;                // [14]
++-  uchar checksum;               // all bytes must add up to 0
++-  uchar product[20];            // product id
++-  uint *oemtable;               // OEM table pointer
++-  ushort oemlength;             // OEM table length
++-  ushort entry;                 // entry count
++-  uint *lapicaddr;              // address of local APIC
++-  ushort xlength;               // extended table length
++-  uchar xchecksum;              // extended table checksum
++-  uchar reserved;
++-};
++-
++-struct mpproc {         // processor table entry
++-  uchar type;                   // entry type (0)
++-  uchar apicid;                 // local APIC id
++-  uchar version;                // local APIC verison
++-  uchar flags;                  // CPU flags
++-    #define MPBOOT 0x02           // This proc is the bootstrap processor.
++-  uchar signature[4];           // CPU signature
++-  uint feature;                 // feature flags from CPUID instruction
++-  uchar reserved[8];
++-};
++-
++-struct mpioapic {       // I/O APIC table entry
++-  uchar type;                   // entry type (2)
++-  uchar apicno;                 // I/O APIC id
++-  uchar version;                // I/O APIC version
++-  uchar flags;                  // I/O APIC flags
++-  uint *addr;                  // I/O APIC address
++-};
++-
++-// Table entry types
++-#define MPPROC    0x00  // One per processor
++-#define MPBUS     0x01  // One per bus
++-#define MPIOAPIC  0x02  // One per I/O APIC
++-#define MPIOINTR  0x03  // One per bus interrupt source
++-#define MPLINTR   0x04  // One per system interrupt source
++-
++-//PAGEBREAK!
++-// Blank page.
++diff --git a/param.h b/param.h
++deleted file mode 100644
++index a7e90ef..0000000
++--- a/param.h
+++++ /dev/null
++@@ -1,14 +0,0 @@
++-#define NPROC        64  // maximum number of processes
++-#define KSTACKSIZE 4096  // size of per-process kernel stack
++-#define NCPU          8  // maximum number of CPUs
++-#define NOFILE       16  // open files per process
++-#define NFILE       100  // open files per system
++-#define NINODE       50  // maximum number of active i-nodes
++-#define NDEV         10  // maximum major device number
++-#define ROOTDEV       1  // device number of file system root disk
++-#define MAXARG       32  // max exec arguments
++-#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
++-#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
++-#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
++-#define FSSIZE       1000  // size of file system in blocks
++-
++diff --git a/picirq.c b/picirq.c
++deleted file mode 100644
++index e26957f..0000000
++--- a/picirq.c
+++++ /dev/null
++@@ -1,19 +0,0 @@
++-#include "types.h"
++-#include "x86.h"
++-#include "traps.h"
++-
++-// I/O Addresses of the two programmable interrupt controllers
++-#define IO_PIC1         0x20    // Master (IRQs 0-7)
++-#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
++-
++-// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
++-void
++-picinit(void)
++-{
++-  // mask all interrupts
++-  outb(IO_PIC1+1, 0xFF);
++-  outb(IO_PIC2+1, 0xFF);
++-}
++-
++-//PAGEBREAK!
++-// Blank page.
++diff --git a/pipe.c b/pipe.c
++deleted file mode 100644
++index e9abe7f..0000000
++--- a/pipe.c
+++++ /dev/null
++@@ -1,121 +0,0 @@
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "fs.h"
++-#include "spinlock.h"
++-#include "sleeplock.h"
++-#include "file.h"
++-
++-#define PIPESIZE 512
++-
++-struct pipe {
++-  struct spinlock lock;
++-  char data[PIPESIZE];
++-  uint nread;     // number of bytes read
++-  uint nwrite;    // number of bytes written
++-  int readopen;   // read fd is still open
++-  int writeopen;  // write fd is still open
++-};
++-
++-int
++-pipealloc(struct file **f0, struct file **f1)
++-{
++-  struct pipe *p;
++-
++-  p = 0;
++-  *f0 = *f1 = 0;
++-  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
++-    goto bad;
++-  if((p = (struct pipe*)kalloc()) == 0)
++-    goto bad;
++-  p->readopen = 1;
++-  p->writeopen = 1;
++-  p->nwrite = 0;
++-  p->nread = 0;
++-  initlock(&p->lock, "pipe");
++-  (*f0)->type = FD_PIPE;
++-  (*f0)->readable = 1;
++-  (*f0)->writable = 0;
++-  (*f0)->pipe = p;
++-  (*f1)->type = FD_PIPE;
++-  (*f1)->readable = 0;
++-  (*f1)->writable = 1;
++-  (*f1)->pipe = p;
++-  return 0;
++-
++-//PAGEBREAK: 20
++- bad:
++-  if(p)
++-    kfree((char*)p);
++-  if(*f0)
++-    fileclose(*f0);
++-  if(*f1)
++-    fileclose(*f1);
++-  return -1;
++-}
++-
++-void
++-pipeclose(struct pipe *p, int writable)
++-{
++-  acquire(&p->lock);
++-  if(writable){
++-    p->writeopen = 0;
++-    wakeup(&p->nread);
++-  } else {
++-    p->readopen = 0;
++-    wakeup(&p->nwrite);
++-  }
++-  if(p->readopen == 0 && p->writeopen == 0){
++-    release(&p->lock);
++-    kfree((char*)p);
++-  } else
++-    release(&p->lock);
++-}
++-
++-//PAGEBREAK: 40
++-int
++-pipewrite(struct pipe *p, char *addr, int n)
++-{
++-  int i;
++-
++-  acquire(&p->lock);
++-  for(i = 0; i < n; i++){
++-    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
++-      if(p->readopen == 0 || myproc()->killed){
++-        release(&p->lock);
++-        return -1;
++-      }
++-      wakeup(&p->nread);
++-      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
++-    }
++-    p->data[p->nwrite++ % PIPESIZE] = addr[i];
++-  }
++-  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
++-  release(&p->lock);
++-  return n;
++-}
++-
++-int
++-piperead(struct pipe *p, char *addr, int n)
++-{
++-  int i;
++-
++-  acquire(&p->lock);
++-  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
++-    if(myproc()->killed){
++-      release(&p->lock);
++-      return -1;
++-    }
++-    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
++-  }
++-  for(i = 0; i < n; i++){  //DOC: piperead-copy
++-    if(p->nread == p->nwrite)
++-      break;
++-    addr[i] = p->data[p->nread++ % PIPESIZE];
++-  }
++-  wakeup(&p->nwrite);  //DOC: piperead-wakeup
++-  release(&p->lock);
++-  return i;
++-}
++diff --git a/pr.pl b/pr.pl
++deleted file mode 100644
++index 46905bd..0000000
++--- a/pr.pl
+++++ /dev/null
++@@ -1,36 +0,0 @@
++-#!/usr/bin/perl
++-
++-use POSIX qw(strftime);
++-
++-if($ARGV[0] eq "-h"){
++-	shift @ARGV;
++-	$h = $ARGV[0];
++-	shift @ARGV;
++-}else{
++-	$h = $ARGV[0];
++-}
++-
++-$page = 0;
++-$now = strftime "%b %e %H:%M %Y", localtime;
++-
++-@lines = <>;
++-for($i=0; $i<@lines; $i+=50){
++-	print "\n\n";
++-	++$page;
++-	print "$now  $h  Page $page\n";
++-	print "\n\n";
++-	for($j=$i; $j<@lines && $j<$i +50; $j++){
++-		$lines[$j] =~ s!//DOC.*!!;
++-		print $lines[$j];
++-	}
++-	for(; $j<$i+50; $j++){
++-		print "\n";
++-	}
++-	$sheet = "";
++-	if($lines[$i] =~ /^([0-9][0-9])[0-9][0-9] /){
++-		$sheet = "Sheet $1";
++-	}
++-	print "\n\n";
++-	print "$sheet\n";
++-	print "\n\n";
++-}
++diff --git a/printf.c b/printf.c
++deleted file mode 100644
++index b3298aa..0000000
++--- a/printf.c
+++++ /dev/null
++@@ -1,85 +0,0 @@
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-
++-static void
++-putc(int fd, char c)
++-{
++-  write(fd, &c, 1);
++-}
++-
++-static void
++-printint(int fd, int xx, int base, int sgn)
++-{
++-  static char digits[] = "0123456789ABCDEF";
++-  char buf[16];
++-  int i, neg;
++-  uint x;
++-
++-  neg = 0;
++-  if(sgn && xx < 0){
++-    neg = 1;
++-    x = -xx;
++-  } else {
++-    x = xx;
++-  }
++-
++-  i = 0;
++-  do{
++-    buf[i++] = digits[x % base];
++-  }while((x /= base) != 0);
++-  if(neg)
++-    buf[i++] = '-';
++-
++-  while(--i >= 0)
++-    putc(fd, buf[i]);
++-}
++-
++-// Print to the given fd. Only understands %d, %x, %p, %s.
++-void
++-printf(int fd, const char *fmt, ...)
++-{
++-  char *s;
++-  int c, i, state;
++-  uint *ap;
++-
++-  state = 0;
++-  ap = (uint*)(void*)&fmt + 1;
++-  for(i = 0; fmt[i]; i++){
++-    c = fmt[i] & 0xff;
++-    if(state == 0){
++-      if(c == '%'){
++-        state = '%';
++-      } else {
++-        putc(fd, c);
++-      }
++-    } else if(state == '%'){
++-      if(c == 'd'){
++-        printint(fd, *ap, 10, 1);
++-        ap++;
++-      } else if(c == 'x' || c == 'p'){
++-        printint(fd, *ap, 16, 0);
++-        ap++;
++-      } else if(c == 's'){
++-        s = (char*)*ap;
++-        ap++;
++-        if(s == 0)
++-          s = "(null)";
++-        while(*s != 0){
++-          putc(fd, *s);
++-          s++;
++-        }
++-      } else if(c == 'c'){
++-        putc(fd, *ap);
++-        ap++;
++-      } else if(c == '%'){
++-        putc(fd, c);
++-      } else {
++-        // Unknown % sequence.  Print it to draw attention.
++-        putc(fd, '%');
++-        putc(fd, c);
++-      }
++-      state = 0;
++-    }
++-  }
++-}
++diff --git a/printpcs b/printpcs
++deleted file mode 100644
++index 81d039b..0000000
++--- a/printpcs
+++++ /dev/null
++@@ -1,14 +0,0 @@
++-#!/bin/sh
++-
++-# Decode the symbols from a panic EIP list
++-
++-# Find a working addr2line
++-for p in i386-jos-elf-addr2line addr2line; do
++-    if which $p 2>&1 >/dev/null && \
++-       $p -h 2>&1 | grep -q '\belf32-i386\b'; then
++-        break
++-    fi
++-done
++-
++-# Enable as much pretty-printing as this addr2line can do
++-$p $($p -h | grep ' -[aipsf] ' | awk '{print $1}') -e kernel "$@"
++diff --git a/proc.c b/proc.c
++deleted file mode 100644
++index 84b335f..0000000
++--- a/proc.c
+++++ /dev/null
++@@ -1,577 +0,0 @@
++-#include <stddef.h>
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-#include "x86.h"
++-#include "proc.h"
++-#include "spinlock.h"
++-
++-struct {
++-    struct spinlock lock;
++-    struct proc proc[NPROC];
++-} ptable;
++-
++-static struct proc *initproc;
++-
++-int nextpid = 1;
++-
++-extern void forkret(void);
++-
++-extern void trapret(void);
++-
++-static void wakeup1(void *chan);
++-
++-void
++-pinit(void) {
++-    initlock(&ptable.lock, "ptable");
++-}
++-
++-// Must be called with interrupts disabled
++-int
++-cpuid() {
++-    return mycpu() - cpus;
++-}
++-
++-// Must be called with interrupts disabled to avoid the caller being
++-// rescheduled between reading lapicid and running through the loop.
++-struct cpu *
++-mycpu(void) {
++-    int apicid, i;
++-
++-    if (readeflags() & FL_IF)
++-        panic("mycpu called with interrupts enabled\n");
++-
++-    apicid = lapicid();
++-    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
++-    // a reverse map, or reserve a register to store &cpus[i].
++-    for (i = 0; i < ncpu; ++i) {
++-        if (cpus[i].apicid == apicid)
++-            return &cpus[i];
++-    }
++-    panic("unknown apicid\n");
++-}
++-
++-// Disable interrupts so that we are not rescheduled
++-// while reading proc from the cpu structure
++-struct proc *
++-myproc(void) {
++-    struct cpu *c;
++-    struct proc *p;
++-    pushcli();
++-    c = mycpu();
++-    p = c->proc;
++-    popcli();
++-    return p;
++-}
++-
++-//PAGEBREAK: 32
++-// Look in the process table for an UNUSED proc.
++-// If found, change state to EMBRYO and initialize
++-// state required to run in the kernel.
++-// Otherwise return 0.
++-static struct proc *
++-allocproc(void) {
++-    struct proc *p;
++-    char *sp;
++-
++-    acquire(&ptable.lock);
++-
++-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++-        if (p->state == UNUSED)
++-            goto found;
++-
++-    release(&ptable.lock);
++-    return 0;
++-
++-    found:
++-    p->state = EMBRYO;
++-    p->pid = nextpid++;
++-
++-    release(&ptable.lock);
++-
++-    // Allocate kernel stack.
++-    if ((p->kstack = kalloc()) == 0) {
++-        p->state = UNUSED;
++-        return 0;
++-    }
++-    sp = p->kstack + KSTACKSIZE;
++-
++-    // Leave room for trap frame.
++-    sp -= sizeof *p->tf;
++-    p->tf = (struct trapframe *) sp;
++-
++-    // Set up new context to start executing at forkret,
++-    // which returns to trapret.
++-    sp -= 4;
++-    *(uint *) sp = (uint) trapret;
++-
++-    sp -= sizeof *p->context;
++-    p->context = (struct context *) sp;
++-    memset(p->context, 0, sizeof *p->context);
++-    p->context->eip = (uint) forkret;
++-
++-    return p;
++-}
++-
++-//PAGEBREAK: 32
++-// Set up first user process.
++-void
++-userinit(void) {
++-    struct proc *p;
++-    extern char _binary_initcode_start[], _binary_initcode_size[];
++-
++-    p = allocproc();
++-
++-    initproc = p;
++-    if ((p->pgdir = setupkvm()) == 0)
++-        panic("userinit: out of memory?");
++-    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
++-    p->sz = PGSIZE;
++-    memset(p->tf, 0, sizeof(*p->tf));
++-    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
++-    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
++-    p->tf->es = p->tf->ds;
++-    p->tf->ss = p->tf->ds;
++-    p->tf->eflags = FL_IF;
++-    p->tf->esp = PGSIZE;
++-    p->tf->eip = 0;  // beginning of initcode.S
++-
++-    safestrcpy(p->name, "initcode", sizeof(p->name));
++-    p->cwd = namei("/");
++-
++-    // this assignment to p->state lets other cores
++-    // run this process. the acquire forces the above
++-    // writes to be visible, and the lock is also needed
++-    // because the assignment might not be atomic.
++-    acquire(&ptable.lock);
++-
++-    p->state = RUNNABLE;
++-
++-    release(&ptable.lock);
++-}
++-
++-// Grow current process's memory by n bytes.
++-// Return 0 on success, -1 on failure.
++-int
++-growproc(int n) {
++-    uint sz;
++-    struct proc *curproc = myproc();
++-
++-    sz = curproc->sz;
++-    if (n > 0) {
++-        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
++-            return -1;
++-    } else if (n < 0) {
++-        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
++-            return -1;
++-    }
++-    curproc->sz = sz;
++-    switchuvm(curproc);
++-    return 0;
++-}
++-
++-// Create a new process copying p as the parent.
++-// Sets up stack to return as if from system call.
++-// Caller must set state of returned proc to RUNNABLE.
++-int
++-fork(void) {
++-    int i, pid;
++-    struct proc *np;
++-    struct proc *curproc = myproc();
++-
++-    // Allocate process.
++-    if ((np = allocproc()) == 0) {
++-        return -1;
++-    }
++-
++-    // Copy process state from proc.
++-    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
++-        kfree(np->kstack);
++-        np->kstack = 0;
++-        np->state = UNUSED;
++-        return -1;
++-    }
++-    np->sz = curproc->sz;
++-    np->parent = curproc;
++-    *np->tf = *curproc->tf;
++-
++-    // Clear %eax so that fork returns 0 in the child.
++-    np->tf->eax = 0;
++-
++-    for (i = 0; i < NOFILE; i++)
++-        if (curproc->ofile[i])
++-            np->ofile[i] = filedup(curproc->ofile[i]);
++-    np->cwd = idup(curproc->cwd);
++-
++-    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
++-
++-    pid = np->pid;
++-
++-    acquire(&ptable.lock);
++-
++-    np->state = RUNNABLE;
++-
++-    release(&ptable.lock);
++-
++-    return pid;
++-}
++-
++-// Exit the current process.  Does not return.
++-// An exited process remains in the zombie state
++-// until its parent calls wait() to find out it exited.
++-void
++-exit(int status) {
++-    struct proc *curproc = myproc();
++-    struct proc *p;
++-    int fd;
++-
++-    curproc->status = status;
++-
++-    if (curproc == initproc)
++-        panic("init exiting");
++-
++-    // Close all open files.
++-    for (fd = 0; fd < NOFILE; fd++) {
++-        if (curproc->ofile[fd]) {
++-            fileclose(curproc->ofile[fd]);
++-            curproc->ofile[fd] = 0;
++-        }
++-    }
++-
++-    begin_op();
++-    iput(curproc->cwd);
++-    end_op();
++-    curproc->cwd = 0;
++-
++-    acquire(&ptable.lock);
++-
++-    // Parent might be sleeping in wait().
++-    wakeup1(curproc->parent);
++-
++-    // Pass abandoned children to init.
++-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-        if (p->parent == curproc) {
++-            p->parent = initproc;
++-            if (p->state == ZOMBIE)
++-                wakeup1(initproc);
++-        }
++-    }
++-
++-    // Jump into the scheduler, never to return.
++-    curproc->state = ZOMBIE;
++-    sched();
++-    panic("zombie exit");
++-}
++-
++-// Wait for a child process to exit and return its pid.
++-// Return -1 if this process has no children.
++-int
++-wait(int *status) {
++-    struct proc *p;
++-    int havekids, pid;
++-    struct proc *curproc = myproc();
++-
++-    acquire(&ptable.lock);
++-    for (;;) {
++-        // Scan through table looking for exited children.
++-        havekids = 0;
++-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-            if (p->parent != curproc)
++-                continue;
++-            havekids = 1;
++-            if (p->state == ZOMBIE) {
++-                // Found one.
++-                pid = p->pid;
++-                kfree(p->kstack);
++-                p->kstack = 0;
++-                freevm(p->pgdir);
++-                p->pid = 0;
++-                p->parent = 0;
++-                p->name[0] = 0;
++-                p->killed = 0;
++-                p->state = UNUSED;
++-                release(&ptable.lock);
++-                if (status != NULL)
++-                    *status = p->status;
++-                return pid;
++-            }
++-        }
++-
++-        // No point waiting if we don't have any children.
++-        if (!havekids || curproc->killed) {
++-            release(&ptable.lock);
++-            return -1;
++-        }
++-
++-        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
++-        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
++-    }
++-}
++-
++-// Wait for a child process to exit and return its pid.
++-// Return -1 if this process has no children.
++-int
++-waitpid(int pidBeingSearchedFor, int *status, int options) {
++-    struct proc *p;
++-    int doesProcExist, pidFound;
++-    struct proc *curproc = myproc();
++-    acquire(&ptable.lock);
++-    for (;;) {
++-        // Scan through table looking for exited children.
++-        doesProcExist = 0;
++-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-//            if(p->parent != curproc)
++-//                continue;
++-
++-            if (p->pid != pidBeingSearchedFor)
++-                continue;
++-
++-            doesProcExist = 1;
++-            if (p->state == ZOMBIE) {
++-                // Found one.
++-                pidFound = p->pid;
++-                kfree(p->kstack);
++-                p->kstack = 0;
++-                freevm(p->pgdir);
++-                p->pid = 0;
++-                p->parent = 0;
++-                p->name[0] = 0;
++-                p->killed = 0;
++-                p->state = UNUSED;
++-                release(&ptable.lock);
++-                if (status != NULL)
++-                    *status = p->status;
++-                return pidFound;
++-            }
++-        }
++-
++-//        // No point waiting if we don't have any children.
++-//        if(!havekids || curproc->killed){
++-//            release(&ptable.lock);
++-//            return -1;
++-//        }
++-
++-        if (!doesProcExist || curproc->killed) {
++-            release(&ptable.lock);
++-            return -1;
++-        }
++-        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
++-        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
++-    }
++-}
++-
++-//PAGEBREAK: 42
++-// Per-CPU process scheduler.
++-// Each CPU calls scheduler() after setting itself up.
++-// Scheduler never returns.  It loops, doing:
++-//  - choose a process to run
++-//  - swtch to start running that process
++-//  - eventually that process transfers control
++-//      via swtch back to the scheduler.
++-void
++-scheduler(void) {
++-    struct proc *p;
++-    struct cpu *c = mycpu();
++-    c->proc = 0;
++-
++-    for (;;) {
++-        // Enable interrupts on this processor.
++-        sti();
++-
++-        // Loop over process table looking for process to run.
++-        acquire(&ptable.lock);
++-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-            if (p->state != RUNNABLE)
++-                continue;
++-
++-            // Switch to chosen process.  It is the process's job
++-            // to release ptable.lock and then reacquire it
++-            // before jumping back to us.
++-            c->proc = p;
++-            switchuvm(p);
++-            p->state = RUNNING;
++-
++-            swtch(&(c->scheduler), p->context);
++-            switchkvm();
++-
++-            // Process is done running for now.
++-            // It should have changed its p->state before coming back.
++-            c->proc = 0;
++-        }
++-        release(&ptable.lock);
++-
++-    }
++-}
++-
++-// Enter scheduler.  Must hold only ptable.lock
++-// and have changed proc->state. Saves and restores
++-// intena because intena is a property of this
++-// kernel thread, not this CPU. It should
++-// be proc->intena and proc->ncli, but that would
++-// break in the few places where a lock is held but
++-// there's no process.
++-void
++-sched(void) {
++-    int intena;
++-    struct proc *p = myproc();
++-
++-    if (!holding(&ptable.lock))
++-        panic("sched ptable.lock");
++-    if (mycpu()->ncli != 1)
++-        panic("sched locks");
++-    if (p->state == RUNNING)
++-        panic("sched running");
++-    if (readeflags() & FL_IF)
++-        panic("sched interruptible");
++-    intena = mycpu()->intena;
++-    swtch(&p->context, mycpu()->scheduler);
++-    mycpu()->intena = intena;
++-}
++-
++-// Give up the CPU for one scheduling round.
++-void
++-yield(void) {
++-    acquire(&ptable.lock);  //DOC: yieldlock
++-    myproc()->state = RUNNABLE;
++-    sched();
++-    release(&ptable.lock);
++-}
++-
++-// A fork child's very first scheduling by scheduler()
++-// will swtch here.  "Return" to user space.
++-void
++-forkret(void) {
++-    static int first = 1;
++-    // Still holding ptable.lock from scheduler.
++-    release(&ptable.lock);
++-
++-    if (first) {
++-        // Some initialization functions must be run in the context
++-        // of a regular process (e.g., they call sleep), and thus cannot
++-        // be run from main().
++-        first = 0;
++-        iinit(ROOTDEV);
++-        initlog(ROOTDEV);
++-    }
++-
++-    // Return to "caller", actually trapret (see allocproc).
++-}
++-
++-// Atomically release lock and sleep on chan.
++-// Reacquires lock when awakened.
++-void
++-sleep(void *chan, struct spinlock *lk) {
++-    struct proc *p = myproc();
++-
++-    if (p == 0)
++-        panic("sleep");
++-
++-    if (lk == 0)
++-        panic("sleep without lk");
++-
++-    // Must acquire ptable.lock in order to
++-    // change p->state and then call sched.
++-    // Once we hold ptable.lock, we can be
++-    // guaranteed that we won't miss any wakeup
++-    // (wakeup runs with ptable.lock locked),
++-    // so it's okay to release lk.
++-    if (lk != &ptable.lock) {  //DOC: sleeplock0
++-        acquire(&ptable.lock);  //DOC: sleeplock1
++-        release(lk);
++-    }
++-    // Go to sleep.
++-    p->chan = chan;
++-    p->state = SLEEPING;
++-
++-    sched();
++-
++-    // Tidy up.
++-    p->chan = 0;
++-
++-    // Reacquire original lock.
++-    if (lk != &ptable.lock) {  //DOC: sleeplock2
++-        release(&ptable.lock);
++-        acquire(lk);
++-    }
++-}
++-
++-//PAGEBREAK!
++-// Wake up all processes sleeping on chan.
++-// The ptable lock must be held.
++-static void
++-wakeup1(void *chan) {
++-    struct proc *p;
++-
++-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++-        if (p->state == SLEEPING && p->chan == chan)
++-            p->state = RUNNABLE;
++-}
++-
++-// Wake up all processes sleeping on chan.
++-void
++-wakeup(void *chan) {
++-    acquire(&ptable.lock);
++-    wakeup1(chan);
++-    release(&ptable.lock);
++-}
++-
++-// Kill the process with the given pid.
++-// Process won't exit until it returns
++-// to user space (see trap in trap.c).
++-int
++-kill(int pid) {
++-    struct proc *p;
++-
++-    acquire(&ptable.lock);
++-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-        if (p->pid == pid) {
++-            p->killed = 1;
++-            // Wake process from sleep if necessary.
++-            if (p->state == SLEEPING)
++-                p->state = RUNNABLE;
++-            release(&ptable.lock);
++-            return 0;
++-        }
++-    }
++-    release(&ptable.lock);
++-    return -1;
++-}
++-
++-//PAGEBREAK: 36
++-// Print a process listing to console.  For debugging.
++-// Runs when user types ^P on console.
++-// No lock to avoid wedging a stuck machine further.
++-void
++-procdump(void) {
++-    static char *states[] = {
++-            [UNUSED]    "unused",
++-            [EMBRYO]    "embryo",
++-            [SLEEPING]  "sleep ",
++-            [RUNNABLE]  "runble",
++-            [RUNNING]   "run   ",
++-            [ZOMBIE]    "zombie"
++-    };
++-    int i;
++-    struct proc *p;
++-    char *state;
++-    uint pc[10];
++-
++-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-        if (p->state == UNUSED)
++-            continue;
++-        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
++-            state = states[p->state];
++-        else
++-            state = "???";
++-        cprintf("%d %s %s", p->pid, state, p->name);
++-        if (p->state == SLEEPING) {
++-            getcallerpcs((uint *) p->context->ebp + 2, pc);
++-            for (i = 0; i < 10 && pc[i] != 0; i++)
++-                cprintf(" %p", pc[i]);
++-        }
++-        cprintf("\n");
++-    }
++-}
++diff --git a/proc.h b/proc.h
++deleted file mode 100644
++index a06b921..0000000
++--- a/proc.h
+++++ /dev/null
++@@ -1,59 +0,0 @@
++-// Per-CPU state
++-struct cpu {
++-  uchar apicid;                // Local APIC ID
++-  struct context *scheduler;   // swtch() here to enter scheduler
++-  struct taskstate ts;         // Used by x86 to find stack for interrupt
++-  struct segdesc gdt[NSEGS];   // x86 global descriptor table
++-  volatile uint started;       // Has the CPU started?
++-  int ncli;                    // Depth of pushcli nesting.
++-  int intena;                  // Were interrupts enabled before pushcli?
++-  struct proc *proc;           // The process running on this cpu or null
++-};
++-
++-extern struct cpu cpus[NCPU];
++-extern int ncpu;
++-
++-//PAGEBREAK: 17
++-// Saved registers for kernel context switches.
++-// Don't need to save all the segment registers (%cs, etc),
++-// because they are constant across kernel contexts.
++-// Don't need to save %eax, %ecx, %edx, because the
++-// x86 convention is that the caller has saved them.
++-// Contexts are stored at the bottom of the stack they
++-// describe; the stack pointer is the address of the context.
++-// The layout of the context matches the layout of the stack in swtch.S
++-// at the "Switch stacks" comment. Switch doesn't save eip explicitly,
++-// but it is on the stack and allocproc() manipulates it.
++-struct context {
++-  uint edi;
++-  uint esi;
++-  uint ebx;
++-  uint ebp;
++-  uint eip;
++-};
++-
++-enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
++-
++-// Per-process state
++-struct proc {
++-  uint sz;                     // Size of process memory (bytes)
++-  pde_t* pgdir;                // Page table
++-  char *kstack;                // Bottom of kernel stack for this process
++-  enum procstate state;        // Process state
++-  int pid;                     // Process ID
++-  struct proc *parent;         // Parent process
++-  struct trapframe *tf;        // Trap frame for current syscall
++-  struct context *context;     // swtch() here to run process
++-  void *chan;                  // If non-zero, sleeping on chan
++-  int killed;                  // If non-zero, have been killed
++-  struct file *ofile[NOFILE];  // Open files
++-  struct inode *cwd;           // Current directory
++-  char name[16];               // Process name (debugging)
++-  int status;                  // Exit status
++-};
++-
++-// Process memory is laid out contiguously, low addresses first:
++-//   text
++-//   original data and bss
++-//   fixed-size stack
++-//   expandable heap
++diff --git a/rm.c b/rm.c
++deleted file mode 100644
++index 1e6daec..0000000
++--- a/rm.c
+++++ /dev/null
++@@ -1,23 +0,0 @@
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-
++-int
++-main(int argc, char *argv[])
++-{
++-  int i;
++-
++-  if(argc < 2){
++-    printf(2, "Usage: rm files...\n");
++-    exit(1);
++-  }
++-
++-  for(i = 1; i < argc; i++){
++-    if(unlink(argv[i]) < 0){
++-      printf(2, "rm: %s failed to delete\n", argv[i]);
++-      break;
++-    }
++-  }
++-
++-  exit(0);
++-}
++diff --git a/runoff b/runoff
++deleted file mode 100644
++index be362d0..0000000
++--- a/runoff
+++++ /dev/null
++@@ -1,246 +0,0 @@
++-#!/bin/sh
++-
++-echo This script takes a minute to run.  Be patient. 1>&2
++-
++-LC_CTYPE=C export LC_CTYPE
++-
++-# pad stdin to multiple of 120 lines
++-pad()
++-{
++-	awk '{print} END{for(; NR%120!=0; NR++) print ""}'
++-}
++-
++-# create formatted (numbered) files
++-mkdir -p fmt
++-rm -f fmt/*
++-cp README fmt
++-echo > fmt/blank
++-files=`grep -v '^#' runoff.list | awk '{print $1}'`
++-n=99
++-for i in $files
++-do
++-	./runoff1 -n $n $i >fmt/$i
++-	nn=`tail -1 fmt/$i | sed 's/ .*//; s/^0*//'`
++-	if [ "x$nn" != x ]; then
++-		n=$nn
++-	fi
++-done
++-
++-# create table of contents
++-cat toc.hdr >fmt/toc
++-pr -e8 -t runoff.list | awk '
++-/^[a-z0-9]/ {
++-	s=$0
++-	f="fmt/"$1
++-	getline<f
++-	close(f)
++-	n=$1
++-	printf("%02d %s\n", n/100, s);
++-	printf("TOC: %04d %s\n", n, s) >"fmt/tocdata"
++-	next
++-}
++-{
++-	print
++-}' | pr -3 -t >>fmt/toc
++-cat toc.ftr >>fmt/toc
++-
++-# check for bad alignments
++-perl -e '
++-	$leftwarn = 0;
++-	while(<>){
++-		chomp;
++-		s!#.*!!;
++-		s!\s+! !g;
++-		s! +$!!;
++-		next if /^$/;
++-		
++-		if(/TOC: (\d+) (.*)/){
++-			$toc{$2} = $1;
++-			next;
++-		}
++-		
++-		if(/sheet1: (left|right)$/){
++-			print STDERR "assuming that sheet 1 is a $1 page.  double-check!\n";
++-			$left = $1 eq "left" ? "13579" : "02468";
++-			$right = $1 eq "left" ? "02468" : "13579";
++-			next;
++-		}
++-		
++-		if(/even: (.*)/){
++-			$file = $1;
++-			if(!defined($toc{$file})){
++-				print STDERR "Have no toc for $file\n";
++-				next;
++-			}
++-			if($toc{$file} =~ /^\d\d[^0]/){
++-				print STDERR "$file does not start on a fresh page.\n";
++-			}
++-			next;
++-		}
++-		
++-		if(/odd: (.*)/){
++-			$file = $1;
++-			if(!defined($toc{$file})){
++-				print STDERR "Have no toc for $file\n";
++-				next;
++-			}
++-			if($toc{$file} !~ /^\d\d5/){
++-				print STDERR "$file does not start on a second half page.\n";
++-			}
++-			next;
++-		}
++-		
++-		if(/(left|right): (.*)/){
++-			$what = $1;
++-			$file = $2;
++-			if(!defined($toc{$file})){
++-				print STDERR "Have no toc for $file\n";
++-				next;
++-			}
++-			if($what eq "left" && !($toc{$file} =~ /^\d[$left][05]/)){
++-				print STDERR "$file does not start on a left page [$toc{$file}]\n";
++-			}
++-			# why does this not work if I inline $x in the if?
++-			$x = ($toc{$file} =~ /^\d[$right][05]/);
++-			if($what eq "right" && !$x){
++-				print STDERR "$file does not start on a right page [$toc{$file}] [$x]\n";
++-			}
++-			next;
++-		}
++-		
++-		print STDERR "Unknown spec: $_\n";
++-	}
++-' fmt/tocdata runoff.spec
++-
++-# make definition list
++-cd fmt
++-perl -e '
++-	while(<>) {
++-		chomp;
++-
++-		s!//.*!!;
++-		s!/\*([^*]|[*][^/])*\*/!!g;
++-		s!\s! !g;
++-		s! +$!!;
++-
++-		# look for declarations like char* x;
++-		if (/^[0-9]+ typedef .* u(int|short|long|char);/) {
++-			next;
++-		}
++-		if (/^[0-9]+ extern/) {
++-			next;
++-		}
++-		if (/^[0-9]+ struct [a-zA-Z0-9_]+;/) {
++-			next;
++-		}
++-		if (/^([0-9]+) #define +([A-za-z0-9_]+) +?\(.*/) {
++-			print "$1 $2\n"
++-		}
++-		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+) +([^ ]+)/) {
++-			print "$1 $2 $3\n";
++-		}
++-		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+)/) {
++-			print "$1 $2\n";
++-		}
++-		
++-		if(/^^([0-9]+) \.globl ([a-zA-Z0-9_]+)/){
++-			$isglobl{$2} = 1;
++-		}
++-		if(/^^([0-9]+) ([a-zA-Z0-9_]+):$/ && $isglobl{$2}){
++-			print "$1 $2\n";
++-		}
++-		
++-		if (/\(/) {
++-			next;
++-		}
++-
++-		if (/^([0-9]+) (((static|struct|extern|union|enum) +)*([A-Za-z0-9_]+))( .*)? +([A-Za-z_][A-Za-z0-9_]*)(,|;|=| =)/) {
++-			print "$1 $7\n";
++-		}
++-		
++-		elsif(/^([0-9]+) (enum|struct|union) +([A-Za-z0-9_]+) +{/){ 
++-			print "$1 $3\n";
++-		}
++-		# TODO: enum members
++-	}
++-' $files >defs
++-
++-(for i in $files
++-do
++-	case "$i" in
++-	*.S)
++-		cat $i | sed 's;#.*;;; s;//.*;;;'
++-		;;
++-	*)
++-		cat $i | sed 's;//.*;;; s;"([^"\\]|\\.)*";;;'
++-	esac
++-done
++-) >alltext
++-
++-perl -n -e 'print if s/^([0-9]+ [a-zA-Z0-9_]+)\(.*$/\1/;' alltext |
++-	egrep -v ' (STUB|usage|main|if|for)$' >>defs
++-#perl -n -e 'print if s/^([0-9]+) STUB\(([a-zA-Z0-9_]+)\)$/\1 \2/;' alltext \
++-#	>>defs
++-(
++->s.defs
++-
++-# make reference list
++-for i in `awk '{print $2}' defs | sort -f | uniq`
++-do
++-	defs=`egrep '^[0-9]+ '$i'( |$)' defs | awk '{print $1}'`
++-	echo $i $defs >>s.defs
++-	uses=`egrep -h '([^a-zA-Z_0-9])'$i'($|[^a-zA-Z_0-9])' alltext | awk '{print $1}'`
++-	if [ "x$defs" != "x$uses" ]; then
++-		echo $i $defs
++-		echo $uses |fmt -29 | sed 's/^/    /'
++-#	else
++-#		echo $i defined but not used >&2
++-	fi
++-done
++-) >refs
++-
++-# build defs list
++-awk '
++-{
++-	printf("%04d %s\n", $2, $1);
++-	for(i=3; i<=NF; i++)
++-		printf("%04d    \" \n", $i);
++-}
++-' s.defs > t.defs
++-
++-# format the whole thing
++-(
++-	../pr.pl README
++-	../pr.pl -h "table of contents" toc
++-	# pr -t -2 t.defs | ../pr.pl -h "definitions" | pad
++-	pr -t -l50 -2 refs | ../pr.pl -h "cross-references" | pad
++-	# pr.pl -h "definitions" -2 t.defs | pad
++-	# pr.pl -h "cross-references" -2 refs | pad
++-	../pr.pl blank  # make sheet 1 start on left page
++-	../pr.pl blank
++-	for i in $files
++-	do
++-		../pr.pl -h "xv6/$i" $i
++-	done
++-) | mpage -m50t50b -o -bLetter -T -t -2 -FCourier -L60 >all.ps
++-grep Pages: all.ps
++-
++-# if we have the nice font, use it
++-nicefont=LucidaSans-Typewriter83
++-if [ ! -f ../$nicefont ]
++-then
++-	if git cat-file blob font:$nicefont > ../$nicefont~; then
++-		mv ../$nicefont~ ../$nicefont
++-	fi
++-fi
++-if [ -f ../$nicefont ]
++-then
++-	echo nicefont
++-	(sed 1q all.ps; cat ../$nicefont; sed "1d; s/Courier/$nicefont/" all.ps) >allf.ps
++-else
++-	echo ugly font!
++-	cp all.ps allf.ps
++-fi
++-ps2pdf allf.ps ../xv6.pdf
++-# cd ..
++-# pdftops xv6.pdf xv6.ps
++diff --git a/runoff.list b/runoff.list
++deleted file mode 100644
++index 2df9b81..0000000
++--- a/runoff.list
+++++ /dev/null
++@@ -1,80 +0,0 @@
++-# basic headers
++-types.h
++-param.h
++-memlayout.h
++-defs.h
++-x86.h
++-asm.h
++-mmu.h
++-elf.h
++-date.h
++-
++-# entering xv6
++-entry.S
++-entryother.S
++-main.c
++-
++-# locks
++-spinlock.h
++-spinlock.c
++-
++-# processes
++-vm.c
++-proc.h
++-proc.c
++-swtch.S
++-kalloc.c
++-
++-# system calls
++-traps.h
++-vectors.pl
++-trapasm.S
++-trap.c
++-syscall.h
++-syscall.c
++-sysproc.c
++-
++-# file system
++-buf.h
++-sleeplock.h
++-fcntl.h
++-stat.h
++-fs.h
++-file.h
++-ide.c
++-bio.c
++-sleeplock.c
++-log.c
++-fs.c
++-file.c
++-sysfile.c
++-exec.c
++-
++-# pipes
++-pipe.c
++-
++-# string operations
++-string.c
++-
++-# low-level hardware
++-mp.h
++-mp.c
++-lapic.c
++-ioapic.c
++-kbd.h
++-kbd.c
++-console.c
++-uart.c
++-
++-# user-level
++-initcode.S
++-usys.S
++-init.c
++-sh.c
++-
++-# bootloader
++-bootasm.S
++-bootmain.c
++-
++-# link
++-kernel.ld
++diff --git a/runoff.spec b/runoff.spec
++deleted file mode 100644
++index 9247948..0000000
++--- a/runoff.spec
+++++ /dev/null
++@@ -1,102 +0,0 @@
++-# Is sheet 01 (after the TOC) a left sheet or a right sheet?
++-sheet1: left
++-
++-# "left" and "right" specify which page of a two-page spread a file
++-# must start on.  "left" means that a file must start on the first of
++-# the two pages.  "right" means it must start on the second of the two
++-# pages.  The file may start in either column.
++-#
++-# "even" and "odd" specify which column a file must start on.  "even"
++-# means it must start in the left of the two columns (00).  "odd" means it
++-# must start in the right of the two columns (50).
++-#
++-# You'd think these would be the other way around.
++-
++-# types.h either
++-# param.h either
++-# defs.h either
++-# x86.h either
++-# asm.h either
++-# mmu.h either
++-# elf.h either
++-# mp.h either
++-
++-even: entry.S  # mild preference
++-even: entryother.S  # mild preference
++-even: main.c
++-# mp.c don't care at all
++-# even: initcode.S
++-# odd: init.c
++-
++-left: spinlock.h
++-even: spinlock.h
++-
++-# This gets struct proc and allocproc on the same spread
++-left: proc.h
++-even: proc.h
++-
++-# goal is to have two action-packed 2-page spreads,
++-# one with
++-#     userinit growproc fork exit wait
++-# and another with
++-#     scheduler sched yield forkret sleep wakeup1 wakeup
++-right: proc.c   # VERY important
++-even: proc.c   # VERY important
++-
++-# A few more action packed spreads
++-# page table creation and process loading
++-#     walkpgdir mappages setupkvm switch[ku]vm inituvm (loaduvm)
++-# process memory management
++-#     allocuvm deallocuvm freevm
++-left: vm.c
++-
++-even: kalloc.c  # mild preference
++-
++-# syscall.h either
++-# trapasm.S either
++-# traps.h either
++-# even: trap.c
++-# vectors.pl either
++-# syscall.c either
++-# sysproc.c either
++-
++-# buf.h either
++-# dev.h either
++-# fcntl.h either
++-# stat.h either
++-# file.h either
++-# fs.h either
++-# fsvar.h either
++-# left: ide.c # mild preference
++-even: ide.c
++-# odd: bio.c
++-
++-# log.c fits nicely in a spread
++-even: log.c
++-left: log.c
++-
++-# with fs.c starting on 2nd column of a left page, we get these 2-page spreads:
++-#	ialloc iupdate iget idup ilock iunlock iput iunlockput
++-#	bmap itrunc stati readi writei
++-#	namecmp dirlookup dirlink skipelem namex namei
++-#	fileinit filealloc filedup fileclose filestat fileread filewrite
++-# starting on 2nd column of a right page is not terrible either
++-odd: fs.c   # VERY important
++-left: fs.c  # mild preference
++-# file.c either
++-# exec.c either
++-# sysfile.c either
++-
++-# Mild preference, but makes spreads of mp.c, lapic.c, and ioapic.c+picirq.c
++-even: mp.c
++-left: mp.c
++-
++-# even: pipe.c  # mild preference
++-# string.c either
++-# left: kbd.h  # mild preference
++-even: kbd.h
++-even: console.c
++-odd: sh.c
++-
++-even: bootasm.S   # mild preference
++-even: bootmain.c  # mild preference
++diff --git a/runoff1 b/runoff1
++deleted file mode 100644
++index 532f844..0000000
++--- a/runoff1
+++++ /dev/null
++@@ -1,108 +0,0 @@
++-#!/usr/bin/perl
++-
++-$n = 0;
++-$v = 0;
++-if($ARGV[0] eq "-v") {
++-	$v = 1;
++-	shift @ARGV;
++-}
++-if($ARGV[0] eq "-n") {
++-	$n = $ARGV[1];
++-	shift @ARGV;
++-	shift @ARGV;
++-}
++-$n = int(($n+49)/50)*50 - 1;
++-
++-$file = $ARGV[0];
++-@lines = <>;
++-$linenum = 0;
++-foreach (@lines) {
++-	$linenum++;
++-	chomp;
++-	s/\s+$//;
++-	if(length() >= 75){
++-		print STDERR "$file:$linenum: line too long\n";
++-	}
++-}
++-@outlines = ();
++-$nextout = 0;
++-
++-for($i=0; $i<@lines; ){
++-	# Skip leading blank lines.
++-	$i++ while $i<@lines && $lines[$i] =~ /^$/;
++-	last if $i>=@lines;
++-
++-	# If the rest of the file fits, use the whole thing.
++-	if(@lines <= $i+50 && !grep { /PAGEBREAK/ } @lines){
++-		$breakbefore = @lines;
++-	}else{
++-		# Find a good next page break;
++-		# Hope for end of function.
++-		# but settle for a blank line (but not first blank line
++-		# in function, which comes after variable declarations).
++-		$breakbefore = $i;
++-		$lastblank = $i;
++-		$sawbrace = 0;
++-		$breaksize = 15;  # 15 lines to get to function
++-		for($j=$i; $j<$i+50 && $j < @lines; $j++){
++-			if($lines[$j] =~ /PAGEBREAK!/){
++-				$lines[$j] = "";
++-				$breakbefore = $j;
++-				$breaksize = 100;
++-				last;
++-			}
++-			if($lines[$j] =~ /PAGEBREAK:\s*([0-9]+)/){
++-				$breaksize = $1;
++-				$breakbefore = $j;
++-				$lines[$j] = "";
++-			}
++-			if($lines[$j] =~ /^};?$/){
++-				$breakbefore = $j+1;
++-				$breaksize = 15;
++-			}
++-			if($lines[$j] =~ /^{$/){
++-				$sawbrace = 1;
++-			}
++-			if($lines[$j] =~ /^$/){
++-				if($sawbrace){
++-					$sawbrace = 0;
++-				}else{
++-					$lastblank = $j;
++-				}
++-			}
++-		}
++-		if($j<@lines && $lines[$j] =~ /^$/){
++-			$lastblank = $j;
++-		}
++-
++-		# If we are not putting enough on a page, try a blank line.
++-		if($breakbefore - $i < 50 - $breaksize && $lastblank > $breakbefore && $lastblank >= $i+50 - 5){
++-			if($v){
++-				print STDERR "breakbefore $breakbefore i $i breaksize $breaksize\n";
++-			}
++-			$breakbefore = $lastblank;
++-			$breaksize = 5;  # only 5 lines to get to blank line
++-		}
++-
++-		# If we are not putting enough on a page, force a full page.
++-		if($breakbefore - $i < 50 - $breaksize && $breakbefore != @lines){
++-			$breakbefore = $i + 50;
++-			$breakbefore = @lines if @lines < $breakbefore;
++-		}
++-
++-		if($breakbefore < $i+2){
++-			$breakbefore = $i+2;
++-		}
++-	}
++-
++-	# Emit the page.
++-	$i50 = $i + 50;
++-	for(; $i<$breakbefore; $i++){
++-		printf "%04d %s\n", ++$n, $lines[$i];
++-	}
++-
++-	# Finish page
++-	for($j=$i; $j<$i50; $j++){
++-		printf "%04d \n", ++$n;
++-	}
++-}
++diff --git a/sh.c b/sh.c
++deleted file mode 100644
++index ca2ae37..0000000
++--- a/sh.c
+++++ /dev/null
++@@ -1,493 +0,0 @@
++-// Shell.
++-
++-#include "types.h"
++-#include "user.h"
++-#include "fcntl.h"
++-
++-// Parsed command representation
++-#define EXEC  1
++-#define REDIR 2
++-#define PIPE  3
++-#define LIST  4
++-#define BACK  5
++-
++-#define MAXARGS 10
++-
++-struct cmd {
++-  int type;
++-};
++-
++-struct execcmd {
++-  int type;
++-  char *argv[MAXARGS];
++-  char *eargv[MAXARGS];
++-};
++-
++-struct redircmd {
++-  int type;
++-  struct cmd *cmd;
++-  char *file;
++-  char *efile;
++-  int mode;
++-  int fd;
++-};
++-
++-struct pipecmd {
++-  int type;
++-  struct cmd *left;
++-  struct cmd *right;
++-};
++-
++-struct listcmd {
++-  int type;
++-  struct cmd *left;
++-  struct cmd *right;
++-};
++-
++-struct backcmd {
++-  int type;
++-  struct cmd *cmd;
++-};
++-
++-int fork1(void);  // Fork but panics on failure.
++-void panic(char*);
++-struct cmd *parsecmd(char*);
++-
++-// Execute cmd.  Never returns.
++-void
++-runcmd(struct cmd *cmd)
++-{
++-  int p[2];
++-  struct backcmd *bcmd;
++-  struct execcmd *ecmd;
++-  struct listcmd *lcmd;
++-  struct pipecmd *pcmd;
++-  struct redircmd *rcmd;
++-
++-  if(cmd == 0)
++-    exit(1);
++-
++-  switch(cmd->type){
++-  default:
++-    panic("runcmd");
++-
++-  case EXEC:
++-    ecmd = (struct execcmd*)cmd;
++-    if(ecmd->argv[0] == 0)
++-      exit(2);
++-    exec(ecmd->argv[0], ecmd->argv);
++-    printf(2, "exec %s failed\n", ecmd->argv[0]);
++-    break;
++-
++-  case REDIR:
++-    rcmd = (struct redircmd*)cmd;
++-    close(rcmd->fd);
++-    if(open(rcmd->file, rcmd->mode) < 0){
++-      printf(2, "open %s failed\n", rcmd->file);
++-      exit(6);
++-    }
++-    runcmd(rcmd->cmd);
++-    break;
++-
++-  case LIST:
++-    lcmd = (struct listcmd*)cmd;
++-    if(fork1() == 0)
++-      runcmd(lcmd->left);
++-    wait(NULL);
++-    runcmd(lcmd->right);
++-    break;
++-
++-  case PIPE:
++-    pcmd = (struct pipecmd*)cmd;
++-    if(pipe(p) < 0)
++-      panic("pipe");
++-    if(fork1() == 0){
++-      close(1);
++-      dup(p[1]);
++-      close(p[0]);
++-      close(p[1]);
++-      runcmd(pcmd->left);
++-    }
++-    if(fork1() == 0){
++-      close(0);
++-      dup(p[0]);
++-      close(p[0]);
++-      close(p[1]);
++-      runcmd(pcmd->right);
++-    }
++-    close(p[0]);
++-    close(p[1]);
++-    wait(NULL);
++-    wait(NULL);
++-    break;
++-
++-  case BACK:
++-    bcmd = (struct backcmd*)cmd;
++-    if(fork1() == 0)
++-      runcmd(bcmd->cmd);
++-    break;
++-  }
++-  exit(3);
++-}
++-
++-int
++-getcmd(char *buf, int nbuf)
++-{
++-  printf(2, "$ ");
++-  memset(buf, 0, nbuf);
++-  gets(buf, nbuf);
++-  if(buf[0] == 0) // EOF
++-    return -1;
++-  return 0;
++-}
++-
++-int
++-main(void)
++-{
++-  static char buf[100];
++-  int fd;
++-
++-  // Ensure that three file descriptors are open.
++-  while((fd = open("console", O_RDWR)) >= 0){
++-    if(fd >= 3){
++-      close(fd);
++-      break;
++-    }
++-  }
++-
++-  // Read and run input commands.
++-  while(getcmd(buf, sizeof(buf)) >= 0){
++-    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
++-      // Chdir must be called by the parent, not the child.
++-      buf[strlen(buf)-1] = 0;  // chop \n
++-      if(chdir(buf+3) < 0)
++-        printf(2, "cannot cd %s\n", buf+3);
++-      continue;
++-    }
++-    if(fork1() == 0)
++-      runcmd(parsecmd(buf));
++-    wait(NULL);
++-  }
++-  exit(0);
++-}
++-
++-void
++-panic(char *s)
++-{
++-  printf(2, "%s\n", s);
++-  exit(5);
++-}
++-
++-int
++-fork1(void)
++-{
++-  int pid;
++-
++-  pid = fork();
++-  if(pid == -1)
++-    panic("fork");
++-  return pid;
++-}
++-
++-//PAGEBREAK!
++-// Constructors
++-
++-struct cmd*
++-execcmd(void)
++-{
++-  struct execcmd *cmd;
++-
++-  cmd = malloc(sizeof(*cmd));
++-  memset(cmd, 0, sizeof(*cmd));
++-  cmd->type = EXEC;
++-  return (struct cmd*)cmd;
++-}
++-
++-struct cmd*
++-redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
++-{
++-  struct redircmd *cmd;
++-
++-  cmd = malloc(sizeof(*cmd));
++-  memset(cmd, 0, sizeof(*cmd));
++-  cmd->type = REDIR;
++-  cmd->cmd = subcmd;
++-  cmd->file = file;
++-  cmd->efile = efile;
++-  cmd->mode = mode;
++-  cmd->fd = fd;
++-  return (struct cmd*)cmd;
++-}
++-
++-struct cmd*
++-pipecmd(struct cmd *left, struct cmd *right)
++-{
++-  struct pipecmd *cmd;
++-
++-  cmd = malloc(sizeof(*cmd));
++-  memset(cmd, 0, sizeof(*cmd));
++-  cmd->type = PIPE;
++-  cmd->left = left;
++-  cmd->right = right;
++-  return (struct cmd*)cmd;
++-}
++-
++-struct cmd*
++-listcmd(struct cmd *left, struct cmd *right)
++-{
++-  struct listcmd *cmd;
++-
++-  cmd = malloc(sizeof(*cmd));
++-  memset(cmd, 0, sizeof(*cmd));
++-  cmd->type = LIST;
++-  cmd->left = left;
++-  cmd->right = right;
++-  return (struct cmd*)cmd;
++-}
++-
++-struct cmd*
++-backcmd(struct cmd *subcmd)
++-{
++-  struct backcmd *cmd;
++-
++-  cmd = malloc(sizeof(*cmd));
++-  memset(cmd, 0, sizeof(*cmd));
++-  cmd->type = BACK;
++-  cmd->cmd = subcmd;
++-  return (struct cmd*)cmd;
++-}
++-//PAGEBREAK!
++-// Parsing
++-
++-char whitespace[] = " \t\r\n\v";
++-char symbols[] = "<|>&;()";
++-
++-int
++-gettoken(char **ps, char *es, char **q, char **eq)
++-{
++-  char *s;
++-  int ret;
++-
++-  s = *ps;
++-  while(s < es && strchr(whitespace, *s))
++-    s++;
++-  if(q)
++-    *q = s;
++-  ret = *s;
++-  switch(*s){
++-  case 0:
++-    break;
++-  case '|':
++-  case '(':
++-  case ')':
++-  case ';':
++-  case '&':
++-  case '<':
++-    s++;
++-    break;
++-  case '>':
++-    s++;
++-    if(*s == '>'){
++-      ret = '+';
++-      s++;
++-    }
++-    break;
++-  default:
++-    ret = 'a';
++-    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
++-      s++;
++-    break;
++-  }
++-  if(eq)
++-    *eq = s;
++-
++-  while(s < es && strchr(whitespace, *s))
++-    s++;
++-  *ps = s;
++-  return ret;
++-}
++-
++-int
++-peek(char **ps, char *es, char *toks)
++-{
++-  char *s;
++-
++-  s = *ps;
++-  while(s < es && strchr(whitespace, *s))
++-    s++;
++-  *ps = s;
++-  return *s && strchr(toks, *s);
++-}
++-
++-struct cmd *parseline(char**, char*);
++-struct cmd *parsepipe(char**, char*);
++-struct cmd *parseexec(char**, char*);
++-struct cmd *nulterminate(struct cmd*);
++-
++-struct cmd*
++-parsecmd(char *s)
++-{
++-  char *es;
++-  struct cmd *cmd;
++-
++-  es = s + strlen(s);
++-  cmd = parseline(&s, es);
++-  peek(&s, es, "");
++-  if(s != es){
++-    printf(2, "leftovers: %s\n", s);
++-    panic("syntax");
++-  }
++-  nulterminate(cmd);
++-  return cmd;
++-}
++-
++-struct cmd*
++-parseline(char **ps, char *es)
++-{
++-  struct cmd *cmd;
++-
++-  cmd = parsepipe(ps, es);
++-  while(peek(ps, es, "&")){
++-    gettoken(ps, es, 0, 0);
++-    cmd = backcmd(cmd);
++-  }
++-  if(peek(ps, es, ";")){
++-    gettoken(ps, es, 0, 0);
++-    cmd = listcmd(cmd, parseline(ps, es));
++-  }
++-  return cmd;
++-}
++-
++-struct cmd*
++-parsepipe(char **ps, char *es)
++-{
++-  struct cmd *cmd;
++-
++-  cmd = parseexec(ps, es);
++-  if(peek(ps, es, "|")){
++-    gettoken(ps, es, 0, 0);
++-    cmd = pipecmd(cmd, parsepipe(ps, es));
++-  }
++-  return cmd;
++-}
++-
++-struct cmd*
++-parseredirs(struct cmd *cmd, char **ps, char *es)
++-{
++-  int tok;
++-  char *q, *eq;
++-
++-  while(peek(ps, es, "<>")){
++-    tok = gettoken(ps, es, 0, 0);
++-    if(gettoken(ps, es, &q, &eq) != 'a')
++-      panic("missing file for redirection");
++-    switch(tok){
++-    case '<':
++-      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
++-      break;
++-    case '>':
++-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
++-      break;
++-    case '+':  // >>
++-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
++-      break;
++-    }
++-  }
++-  return cmd;
++-}
++-
++-struct cmd*
++-parseblock(char **ps, char *es)
++-{
++-  struct cmd *cmd;
++-
++-  if(!peek(ps, es, "("))
++-    panic("parseblock");
++-  gettoken(ps, es, 0, 0);
++-  cmd = parseline(ps, es);
++-  if(!peek(ps, es, ")"))
++-    panic("syntax - missing )");
++-  gettoken(ps, es, 0, 0);
++-  cmd = parseredirs(cmd, ps, es);
++-  return cmd;
++-}
++-
++-struct cmd*
++-parseexec(char **ps, char *es)
++-{
++-  char *q, *eq;
++-  int tok, argc;
++-  struct execcmd *cmd;
++-  struct cmd *ret;
++-
++-  if(peek(ps, es, "("))
++-    return parseblock(ps, es);
++-
++-  ret = execcmd();
++-  cmd = (struct execcmd*)ret;
++-
++-  argc = 0;
++-  ret = parseredirs(ret, ps, es);
++-  while(!peek(ps, es, "|)&;")){
++-    if((tok=gettoken(ps, es, &q, &eq)) == 0)
++-      break;
++-    if(tok != 'a')
++-      panic("syntax");
++-    cmd->argv[argc] = q;
++-    cmd->eargv[argc] = eq;
++-    argc++;
++-    if(argc >= MAXARGS)
++-      panic("too many args");
++-    ret = parseredirs(ret, ps, es);
++-  }
++-  cmd->argv[argc] = 0;
++-  cmd->eargv[argc] = 0;
++-  return ret;
++-}
++-
++-// NUL-terminate all the counted strings.
++-struct cmd*
++-nulterminate(struct cmd *cmd)
++-{
++-  int i;
++-  struct backcmd *bcmd;
++-  struct execcmd *ecmd;
++-  struct listcmd *lcmd;
++-  struct pipecmd *pcmd;
++-  struct redircmd *rcmd;
++-
++-  if(cmd == 0)
++-    return 0;
++-
++-  switch(cmd->type){
++-  case EXEC:
++-    ecmd = (struct execcmd*)cmd;
++-    for(i=0; ecmd->argv[i]; i++)
++-      *ecmd->eargv[i] = 0;
++-    break;
++-
++-  case REDIR:
++-    rcmd = (struct redircmd*)cmd;
++-    nulterminate(rcmd->cmd);
++-    *rcmd->efile = 0;
++-    break;
++-
++-  case PIPE:
++-    pcmd = (struct pipecmd*)cmd;
++-    nulterminate(pcmd->left);
++-    nulterminate(pcmd->right);
++-    break;
++-
++-  case LIST:
++-    lcmd = (struct listcmd*)cmd;
++-    nulterminate(lcmd->left);
++-    nulterminate(lcmd->right);
++-    break;
++-
++-  case BACK:
++-    bcmd = (struct backcmd*)cmd;
++-    nulterminate(bcmd->cmd);
++-    break;
++-  }
++-  return cmd;
++-}
++diff --git a/show1 b/show1
++deleted file mode 100644
++index e0d3d83..0000000
++--- a/show1
+++++ /dev/null
++@@ -1,3 +0,0 @@
++-#!/bin/sh
++-
++-runoff1 "$@" | pr.pl -h "xv6/$@" | mpage -m50t50b -o -bLetter -T -t -2 -FLucidaSans-Typewriter83 -L60 >x.ps; gv --swap x.ps
++diff --git a/sign.pl b/sign.pl
++deleted file mode 100644
++index d793035..0000000
++--- a/sign.pl
+++++ /dev/null
++@@ -1,19 +0,0 @@
++-#!/usr/bin/perl
++-
++-open(SIG, $ARGV[0]) || die "open $ARGV[0]: $!";
++-
++-$n = sysread(SIG, $buf, 1000);
++-
++-if($n > 510){
++-  print STDERR "boot block too large: $n bytes (max 510)\n";
++-  exit 1;
++-}
++-
++-print STDERR "boot block is $n bytes (max 510)\n";
++-
++-$buf .= "\0" x (510-$n);
++-$buf .= "\x55\xAA";
++-
++-open(SIG, ">$ARGV[0]") || die "open >$ARGV[0]: $!";
++-print SIG $buf;
++-close SIG;
++diff --git a/sleep1.p b/sleep1.p
++deleted file mode 100644
++index af69772..0000000
++--- a/sleep1.p
+++++ /dev/null
++@@ -1,134 +0,0 @@
++-/*
++-This file defines a Promela model for xv6's
++-acquire, release, sleep, and wakeup, along with
++-a model of a simple producer/consumer queue.
++-
++-To run:
++-	spinp sleep1.p
++-
++-(You may need to install Spin, available at http://spinroot.com/.)
++-
++-After a successful run spin prints something like:
++-
++-	unreached in proctype consumer
++-		(0 of 37 states)
++-	unreached in proctype producer
++-		(0 of 23 states)
++-
++-After an unsuccessful run, the spinp script prints
++-an execution trace that causes a deadlock.
++-
++-The safe body of producer reads:
++-
++-		acquire(lk);
++-		x = value; value = x + 1; x = 0;
++-		wakeup(0);
++-		release(lk);
++-		i = i + 1;
++-
++-If this is changed to:
++-
++-		x = value; value = x + 1; x = 0;
++-		acquire(lk);
++-		wakeup(0);
++-		release(lk);
++-		i = i + 1;
++-
++-then a deadlock can happen, because the non-atomic
++-increment of value conflicts with the non-atomic 
++-decrement in consumer, causing value to have a bad value.
++-Try this.
++-
++-If it is changed to:
++-
++-		acquire(lk);
++-		x = value; value = x + 1; x = 0;
++-		release(lk);
++-		wakeup(0);
++-		i = i + 1;
++-
++-then nothing bad happens: it is okay to wakeup after release
++-instead of before, although it seems morally wrong.
++-*/
++-
++-#define ITER 4
++-#define N 2
++-
++-bit lk;
++-byte value;
++-bit sleeping[N];
++-
++-inline acquire(x)
++-{
++-	atomic { x == 0; x = 1 }
++-}
++-
++-inline release(x)
++-{
++-	assert x==1;
++-	x = 0
++-}
++-
++-inline sleep(cond, lk)
++-{
++-	assert !sleeping[_pid];
++-	if
++-	:: cond ->
++-		skip
++-	:: else ->
++-		atomic { release(lk); sleeping[_pid] = 1 };
++-		sleeping[_pid] == 0;
++-		acquire(lk)
++-	fi
++-}
++-
++-inline wakeup()
++-{
++-	w = 0;
++-	do
++-	:: w < N ->
++-		sleeping[w] = 0;
++-		w = w + 1
++-	:: else ->
++-		break
++-	od
++-}
++-
++-active[N] proctype consumer()
++-{
++-	byte i, x;
++-	
++-	i = 0;
++-	do
++-	:: i < ITER ->
++-		acquire(lk);
++-		sleep(value > 0, lk);
++-		x = value; value = x - 1; x = 0;
++-		release(lk);
++-		i = i + 1;
++-	:: else ->
++-		break
++-	od;
++-	i = 0;
++-	skip
++-}
++-
++-active[N] proctype producer()
++-{
++-	byte i, x, w;
++-	
++-	i = 0;
++-	do
++-	:: i < ITER ->
++-		acquire(lk);
++-		x = value; value = x + 1; x = 0;
++-		release(lk);
++-		wakeup();
++-		i = i + 1;
++-	:: else ->
++-		break
++-	od;
++-	i = 0;
++-	skip	
++-}
++-
++diff --git a/sleeplock.c b/sleeplock.c
++deleted file mode 100644
++index e0750ea..0000000
++--- a/sleeplock.c
+++++ /dev/null
++@@ -1,56 +0,0 @@
++-// Sleeping locks
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "x86.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "spinlock.h"
++-#include "sleeplock.h"
++-
++-void
++-initsleeplock(struct sleeplock *lk, char *name)
++-{
++-  initlock(&lk->lk, "sleep lock");
++-  lk->name = name;
++-  lk->locked = 0;
++-  lk->pid = 0;
++-}
++-
++-void
++-acquiresleep(struct sleeplock *lk)
++-{
++-  acquire(&lk->lk);
++-  while (lk->locked) {
++-    sleep(lk, &lk->lk);
++-  }
++-  lk->locked = 1;
++-  lk->pid = myproc()->pid;
++-  release(&lk->lk);
++-}
++-
++-void
++-releasesleep(struct sleeplock *lk)
++-{
++-  acquire(&lk->lk);
++-  lk->locked = 0;
++-  lk->pid = 0;
++-  wakeup(lk);
++-  release(&lk->lk);
++-}
++-
++-int
++-holdingsleep(struct sleeplock *lk)
++-{
++-  int r;
++-  
++-  acquire(&lk->lk);
++-  r = lk->locked && (lk->pid == myproc()->pid);
++-  release(&lk->lk);
++-  return r;
++-}
++-
++-
++-
++diff --git a/sleeplock.h b/sleeplock.h
++deleted file mode 100644
++index 110e6f3..0000000
++--- a/sleeplock.h
+++++ /dev/null
++@@ -1,10 +0,0 @@
++-// Long-term locks for processes
++-struct sleeplock {
++-  uint locked;       // Is the lock held?
++-  struct spinlock lk; // spinlock protecting this sleep lock
++-  
++-  // For debugging:
++-  char *name;        // Name of lock.
++-  int pid;           // Process holding lock
++-};
++-
++diff --git a/spinlock.c b/spinlock.c
++deleted file mode 100644
++index 4020186..0000000
++--- a/spinlock.c
+++++ /dev/null
++@@ -1,126 +0,0 @@
++-// Mutual exclusion spin locks.
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "x86.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "spinlock.h"
++-
++-void
++-initlock(struct spinlock *lk, char *name)
++-{
++-  lk->name = name;
++-  lk->locked = 0;
++-  lk->cpu = 0;
++-}
++-
++-// Acquire the lock.
++-// Loops (spins) until the lock is acquired.
++-// Holding a lock for a long time may cause
++-// other CPUs to waste time spinning to acquire it.
++-void
++-acquire(struct spinlock *lk)
++-{
++-  pushcli(); // disable interrupts to avoid deadlock.
++-  if(holding(lk))
++-    panic("acquire");
++-
++-  // The xchg is atomic.
++-  while(xchg(&lk->locked, 1) != 0)
++-    ;
++-
++-  // Tell the C compiler and the processor to not move loads or stores
++-  // past this point, to ensure that the critical section's memory
++-  // references happen after the lock is acquired.
++-  __sync_synchronize();
++-
++-  // Record info about lock acquisition for debugging.
++-  lk->cpu = mycpu();
++-  getcallerpcs(&lk, lk->pcs);
++-}
++-
++-// Release the lock.
++-void
++-release(struct spinlock *lk)
++-{
++-  if(!holding(lk))
++-    panic("release");
++-
++-  lk->pcs[0] = 0;
++-  lk->cpu = 0;
++-
++-  // Tell the C compiler and the processor to not move loads or stores
++-  // past this point, to ensure that all the stores in the critical
++-  // section are visible to other cores before the lock is released.
++-  // Both the C compiler and the hardware may re-order loads and
++-  // stores; __sync_synchronize() tells them both not to.
++-  __sync_synchronize();
++-
++-  // Release the lock, equivalent to lk->locked = 0.
++-  // This code can't use a C assignment, since it might
++-  // not be atomic. A real OS would use C atomics here.
++-  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
++-
++-  popcli();
++-}
++-
++-// Record the current call stack in pcs[] by following the %ebp chain.
++-void
++-getcallerpcs(void *v, uint pcs[])
++-{
++-  uint *ebp;
++-  int i;
++-
++-  ebp = (uint*)v - 2;
++-  for(i = 0; i < 10; i++){
++-    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
++-      break;
++-    pcs[i] = ebp[1];     // saved %eip
++-    ebp = (uint*)ebp[0]; // saved %ebp
++-  }
++-  for(; i < 10; i++)
++-    pcs[i] = 0;
++-}
++-
++-// Check whether this cpu is holding the lock.
++-int
++-holding(struct spinlock *lock)
++-{
++-  int r;
++-  pushcli();
++-  r = lock->locked && lock->cpu == mycpu();
++-  popcli();
++-  return r;
++-}
++-
++-
++-// Pushcli/popcli are like cli/sti except that they are matched:
++-// it takes two popcli to undo two pushcli.  Also, if interrupts
++-// are off, then pushcli, popcli leaves them off.
++-
++-void
++-pushcli(void)
++-{
++-  int eflags;
++-
++-  eflags = readeflags();
++-  cli();
++-  if(mycpu()->ncli == 0)
++-    mycpu()->intena = eflags & FL_IF;
++-  mycpu()->ncli += 1;
++-}
++-
++-void
++-popcli(void)
++-{
++-  if(readeflags()&FL_IF)
++-    panic("popcli - interruptible");
++-  if(--mycpu()->ncli < 0)
++-    panic("popcli");
++-  if(mycpu()->ncli == 0 && mycpu()->intena)
++-    sti();
++-}
++-
++diff --git a/spinlock.h b/spinlock.h
++deleted file mode 100644
++index 0a9d8e2..0000000
++--- a/spinlock.h
+++++ /dev/null
++@@ -1,11 +0,0 @@
++-// Mutual exclusion lock.
++-struct spinlock {
++-  uint locked;       // Is the lock held?
++-
++-  // For debugging:
++-  char *name;        // Name of lock.
++-  struct cpu *cpu;   // The cpu holding the lock.
++-  uint pcs[10];      // The call stack (an array of program counters)
++-                     // that locked the lock.
++-};
++-
++diff --git a/spinp b/spinp
++deleted file mode 100644
++index db9614b..0000000
++--- a/spinp
+++++ /dev/null
++@@ -1,16 +0,0 @@
++-#!/bin/sh
++-
++-if [ $# != 1 ] || [ ! -f "$1" ]; then
++-	echo 'usage: spinp file.p' 1>&2
++-	exit 1
++-fi
++-
++-rm -f $1.trail
++-spin -a $1 || exit 1
++-cc -DSAFETY -DREACH -DMEMLIM=500 -o pan pan.c
++-pan -i
++-rm pan.* pan
++-if [ -f $1.trail ]; then
++-	spin -t -p $1
++-fi
++-
++diff --git a/stat.h b/stat.h
++deleted file mode 100644
++index 8a80933..0000000
++--- a/stat.h
+++++ /dev/null
++@@ -1,11 +0,0 @@
++-#define T_DIR  1   // Directory
++-#define T_FILE 2   // File
++-#define T_DEV  3   // Device
++-
++-struct stat {
++-  short type;  // Type of file
++-  int dev;     // File system's disk device
++-  uint ino;    // Inode number
++-  short nlink; // Number of links to file
++-  uint size;   // Size of file in bytes
++-};
++diff --git a/stressfs.c b/stressfs.c
++deleted file mode 100644
++index 46e0e66..0000000
++--- a/stressfs.c
+++++ /dev/null
++@@ -1,49 +0,0 @@
++-// Demonstrate that moving the "acquire" in iderw after the loop that
++-// appends to the idequeue results in a race.
++-
++-// For this to work, you should also add a spin within iderw's
++-// idequeue traversal loop.  Adding the following demonstrated a panic
++-// after about 5 runs of stressfs in QEMU on a 2.1GHz CPU:
++-//    for (i = 0; i < 40000; i++)
++-//      asm volatile("");
++-
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-#include "fs.h"
++-#include "fcntl.h"
++-
++-int
++-main(int argc, char *argv[])
++-{
++-  int fd, i;
++-  char path[] = "stressfs0";
++-  char data[512];
++-
++-  printf(1, "stressfs starting\n");
++-  memset(data, 'a', sizeof(data));
++-
++-  for(i = 0; i < 4; i++)
++-    if(fork() > 0)
++-      break;
++-
++-  printf(1, "write %d\n", i);
++-
++-  path[8] += i;
++-  fd = open(path, O_CREATE | O_RDWR);
++-  for(i = 0; i < 20; i++)
++-//    printf(fd, "%d\n", i);
++-    write(fd, data, sizeof(data));
++-  close(fd);
++-
++-  printf(1, "read\n");
++-
++-  fd = open(path, O_RDONLY);
++-  for (i = 0; i < 20; i++)
++-    read(fd, data, sizeof(data));
++-  close(fd);
++-
++-  wait(NULL);
++-
++-  exit(0);
++-}
++diff --git a/string.c b/string.c
++deleted file mode 100644
++index a7cc61f..0000000
++--- a/string.c
+++++ /dev/null
++@@ -1,105 +0,0 @@
++-#include "types.h"
++-#include "x86.h"
++-
++-void*
++-memset(void *dst, int c, uint n)
++-{
++-  if ((int)dst%4 == 0 && n%4 == 0){
++-    c &= 0xFF;
++-    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
++-  } else
++-    stosb(dst, c, n);
++-  return dst;
++-}
++-
++-int
++-memcmp(const void *v1, const void *v2, uint n)
++-{
++-  const uchar *s1, *s2;
++-
++-  s1 = v1;
++-  s2 = v2;
++-  while(n-- > 0){
++-    if(*s1 != *s2)
++-      return *s1 - *s2;
++-    s1++, s2++;
++-  }
++-
++-  return 0;
++-}
++-
++-void*
++-memmove(void *dst, const void *src, uint n)
++-{
++-  const char *s;
++-  char *d;
++-
++-  s = src;
++-  d = dst;
++-  if(s < d && s + n > d){
++-    s += n;
++-    d += n;
++-    while(n-- > 0)
++-      *--d = *--s;
++-  } else
++-    while(n-- > 0)
++-      *d++ = *s++;
++-
++-  return dst;
++-}
++-
++-// memcpy exists to placate GCC.  Use memmove.
++-void*
++-memcpy(void *dst, const void *src, uint n)
++-{
++-  return memmove(dst, src, n);
++-}
++-
++-int
++-strncmp(const char *p, const char *q, uint n)
++-{
++-  while(n > 0 && *p && *p == *q)
++-    n--, p++, q++;
++-  if(n == 0)
++-    return 0;
++-  return (uchar)*p - (uchar)*q;
++-}
++-
++-char*
++-strncpy(char *s, const char *t, int n)
++-{
++-  char *os;
++-
++-  os = s;
++-  while(n-- > 0 && (*s++ = *t++) != 0)
++-    ;
++-  while(n-- > 0)
++-    *s++ = 0;
++-  return os;
++-}
++-
++-// Like strncpy but guaranteed to NUL-terminate.
++-char*
++-safestrcpy(char *s, const char *t, int n)
++-{
++-  char *os;
++-
++-  os = s;
++-  if(n <= 0)
++-    return os;
++-  while(--n > 0 && (*s++ = *t++) != 0)
++-    ;
++-  *s = 0;
++-  return os;
++-}
++-
++-int
++-strlen(const char *s)
++-{
++-  int n;
++-
++-  for(n = 0; s[n]; n++)
++-    ;
++-  return n;
++-}
++-
++diff --git a/swtch.S b/swtch.S
++deleted file mode 100644
++index 63a7dcc..0000000
++--- a/swtch.S
+++++ /dev/null
++@@ -1,29 +0,0 @@
++-# Context switch
++-#
++-#   void swtch(struct context **old, struct context *new);
++-# 
++-# Save the current registers on the stack, creating
++-# a struct context, and save its address in *old.
++-# Switch stacks to new and pop previously-saved registers.
++-
++-.globl swtch
++-swtch:
++-  movl 4(%esp), %eax
++-  movl 8(%esp), %edx
++-
++-  # Save old callee-saved registers
++-  pushl %ebp
++-  pushl %ebx
++-  pushl %esi
++-  pushl %edi
++-
++-  # Switch stacks
++-  movl %esp, (%eax)
++-  movl %edx, %esp
++-
++-  # Load new callee-saved registers
++-  popl %edi
++-  popl %esi
++-  popl %ebx
++-  popl %ebp
++-  ret
++diff --git a/syscall.c b/syscall.c
++deleted file mode 100644
++index 41a8c3c..0000000
++--- a/syscall.c
+++++ /dev/null
++@@ -1,147 +0,0 @@
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "x86.h"
++-#include "syscall.h"
++-
++-// User code makes a system call with INT T_SYSCALL.
++-// System call number in %eax.
++-// Arguments on the stack, from the user call to the C
++-// library system call function. The saved user %esp points
++-// to a saved program counter, and then the first argument.
++-
++-// Fetch the int at addr from the current process.
++-int
++-fetchint(uint addr, int *ip)
++-{
++-  struct proc *curproc = myproc();
++-
++-  if(addr >= curproc->sz || addr+4 > curproc->sz)
++-    return -1;
++-  *ip = *(int*)(addr);
++-  return 0;
++-}
++-
++-// Fetch the nul-terminated string at addr from the current process.
++-// Doesn't actually copy the string - just sets *pp to point at it.
++-// Returns length of string, not including nul.
++-int
++-fetchstr(uint addr, char **pp)
++-{
++-  char *s, *ep;
++-  struct proc *curproc = myproc();
++-
++-  if(addr >= curproc->sz)
++-    return -1;
++-  *pp = (char*)addr;
++-  ep = (char*)curproc->sz;
++-  for(s = *pp; s < ep; s++){
++-    if(*s == 0)
++-      return s - *pp;
++-  }
++-  return -1;
++-}
++-
++-// Fetch the nth 32-bit system call argument.
++-int
++-argint(int n, int *ip)
++-{
++-  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
++-}
++-
++-// Fetch the nth word-sized system call argument as a pointer
++-// to a block of memory of size bytes.  Check that the pointer
++-// lies within the process address space.
++-int
++-argptr(int n, char **pp, int size)
++-{
++-  int i;
++-  struct proc *curproc = myproc();
++- 
++-  if(argint(n, &i) < 0)
++-    return -1;
++-  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
++-    return -1;
++-  *pp = (char*)i;
++-  return 0;
++-}
++-
++-// Fetch the nth word-sized system call argument as a string pointer.
++-// Check that the pointer is valid and the string is nul-terminated.
++-// (There is no shared writable memory, so the string can't change
++-// between this check and being used by the kernel.)
++-int
++-argstr(int n, char **pp)
++-{
++-  int addr;
++-  if(argint(n, &addr) < 0)
++-    return -1;
++-  return fetchstr(addr, pp);
++-}
++-
++-extern int sys_chdir(void);
++-extern int sys_close(void);
++-extern int sys_dup(void);
++-extern int sys_exec(void);
++-extern int sys_exit(void);
++-extern int sys_fork(void);
++-extern int sys_fstat(void);
++-extern int sys_getpid(void);
++-extern int sys_kill(void);
++-extern int sys_link(void);
++-extern int sys_mkdir(void);
++-extern int sys_mknod(void);
++-extern int sys_open(void);
++-extern int sys_pipe(void);
++-extern int sys_read(void);
++-extern int sys_sbrk(void);
++-extern int sys_sleep(void);
++-extern int sys_unlink(void);
++-extern int sys_wait(void);
++-extern int sys_waitpid(void);
++-extern int sys_write(void);
++-extern int sys_uptime(void);
++-
++-static int (*syscalls[])(void) = {
++-[SYS_fork]    sys_fork,
++-[SYS_exit]    sys_exit,
++-[SYS_wait]    sys_wait,
++-[SYS_waitpid] sys_waitpid,
++-[SYS_pipe]    sys_pipe,
++-[SYS_read]    sys_read,
++-[SYS_kill]    sys_kill,
++-[SYS_exec]    sys_exec,
++-[SYS_fstat]   sys_fstat,
++-[SYS_chdir]   sys_chdir,
++-[SYS_dup]     sys_dup,
++-[SYS_getpid]  sys_getpid,
++-[SYS_sbrk]    sys_sbrk,
++-[SYS_sleep]   sys_sleep,
++-[SYS_uptime]  sys_uptime,
++-[SYS_open]    sys_open,
++-[SYS_write]   sys_write,
++-[SYS_mknod]   sys_mknod,
++-[SYS_unlink]  sys_unlink,
++-[SYS_link]    sys_link,
++-[SYS_mkdir]   sys_mkdir,
++-[SYS_close]   sys_close,
++-};
++-
++-void
++-syscall(void)
++-{
++-  int num;
++-  struct proc *curproc = myproc();
++-
++-  num = curproc->tf->eax;
++-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
++-    curproc->tf->eax = syscalls[num]();
++-  } else {
++-    cprintf("%d %s: unknown sys call %d\n",
++-            curproc->pid, curproc->name, num);
++-    curproc->tf->eax = -1;
++-  }
++-}
++diff --git a/syscall.h b/syscall.h
++deleted file mode 100644
++index 374ff05..0000000
++--- a/syscall.h
+++++ /dev/null
++@@ -1,23 +0,0 @@
++-// System call numbers
++-#define SYS_fork     1
++-#define SYS_exit     2
++-#define SYS_wait     3
++-#define SYS_pipe     4
++-#define SYS_read     5
++-#define SYS_kill     6
++-#define SYS_exec     7
++-#define SYS_fstat    8
++-#define SYS_chdir    9
++-#define SYS_dup     10
++-#define SYS_getpid  11
++-#define SYS_sbrk    12
++-#define SYS_sleep   13
++-#define SYS_uptime  14
++-#define SYS_open    15
++-#define SYS_write   16
++-#define SYS_mknod   17
++-#define SYS_unlink  18
++-#define SYS_link    19
++-#define SYS_mkdir   20
++-#define SYS_close   21
++-#define SYS_waitpid 22
++\ No newline at end of file
++diff --git a/sysfile.c b/sysfile.c
++deleted file mode 100644
++index bfe61b7..0000000
++--- a/sysfile.c
+++++ /dev/null
++@@ -1,444 +0,0 @@
++-//
++-// File-system system calls.
++-// Mostly argument checking, since we don't trust
++-// user code, and calls into file.c and fs.c.
++-//
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "stat.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "fs.h"
++-#include "spinlock.h"
++-#include "sleeplock.h"
++-#include "file.h"
++-#include "fcntl.h"
++-
++-// Fetch the nth word-sized system call argument as a file descriptor
++-// and return both the descriptor and the corresponding struct file.
++-static int
++-argfd(int n, int *pfd, struct file **pf)
++-{
++-  int fd;
++-  struct file *f;
++-
++-  if(argint(n, &fd) < 0)
++-    return -1;
++-  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
++-    return -1;
++-  if(pfd)
++-    *pfd = fd;
++-  if(pf)
++-    *pf = f;
++-  return 0;
++-}
++-
++-// Allocate a file descriptor for the given file.
++-// Takes over file reference from caller on success.
++-static int
++-fdalloc(struct file *f)
++-{
++-  int fd;
++-  struct proc *curproc = myproc();
++-
++-  for(fd = 0; fd < NOFILE; fd++){
++-    if(curproc->ofile[fd] == 0){
++-      curproc->ofile[fd] = f;
++-      return fd;
++-    }
++-  }
++-  return -1;
++-}
++-
++-int
++-sys_dup(void)
++-{
++-  struct file *f;
++-  int fd;
++-
++-  if(argfd(0, 0, &f) < 0)
++-    return -1;
++-  if((fd=fdalloc(f)) < 0)
++-    return -1;
++-  filedup(f);
++-  return fd;
++-}
++-
++-int
++-sys_read(void)
++-{
++-  struct file *f;
++-  int n;
++-  char *p;
++-
++-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
++-    return -1;
++-  return fileread(f, p, n);
++-}
++-
++-int
++-sys_write(void)
++-{
++-  struct file *f;
++-  int n;
++-  char *p;
++-
++-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
++-    return -1;
++-  return filewrite(f, p, n);
++-}
++-
++-int
++-sys_close(void)
++-{
++-  int fd;
++-  struct file *f;
++-
++-  if(argfd(0, &fd, &f) < 0)
++-    return -1;
++-  myproc()->ofile[fd] = 0;
++-  fileclose(f);
++-  return 0;
++-}
++-
++-int
++-sys_fstat(void)
++-{
++-  struct file *f;
++-  struct stat *st;
++-
++-  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
++-    return -1;
++-  return filestat(f, st);
++-}
++-
++-// Create the path new as a link to the same inode as old.
++-int
++-sys_link(void)
++-{
++-  char name[DIRSIZ], *new, *old;
++-  struct inode *dp, *ip;
++-
++-  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
++-    return -1;
++-
++-  begin_op();
++-  if((ip = namei(old)) == 0){
++-    end_op();
++-    return -1;
++-  }
++-
++-  ilock(ip);
++-  if(ip->type == T_DIR){
++-    iunlockput(ip);
++-    end_op();
++-    return -1;
++-  }
++-
++-  ip->nlink++;
++-  iupdate(ip);
++-  iunlock(ip);
++-
++-  if((dp = nameiparent(new, name)) == 0)
++-    goto bad;
++-  ilock(dp);
++-  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
++-    iunlockput(dp);
++-    goto bad;
++-  }
++-  iunlockput(dp);
++-  iput(ip);
++-
++-  end_op();
++-
++-  return 0;
++-
++-bad:
++-  ilock(ip);
++-  ip->nlink--;
++-  iupdate(ip);
++-  iunlockput(ip);
++-  end_op();
++-  return -1;
++-}
++-
++-// Is the directory dp empty except for "." and ".." ?
++-static int
++-isdirempty(struct inode *dp)
++-{
++-  int off;
++-  struct dirent de;
++-
++-  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
++-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
++-      panic("isdirempty: readi");
++-    if(de.inum != 0)
++-      return 0;
++-  }
++-  return 1;
++-}
++-
++-//PAGEBREAK!
++-int
++-sys_unlink(void)
++-{
++-  struct inode *ip, *dp;
++-  struct dirent de;
++-  char name[DIRSIZ], *path;
++-  uint off;
++-
++-  if(argstr(0, &path) < 0)
++-    return -1;
++-
++-  begin_op();
++-  if((dp = nameiparent(path, name)) == 0){
++-    end_op();
++-    return -1;
++-  }
++-
++-  ilock(dp);
++-
++-  // Cannot unlink "." or "..".
++-  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
++-    goto bad;
++-
++-  if((ip = dirlookup(dp, name, &off)) == 0)
++-    goto bad;
++-  ilock(ip);
++-
++-  if(ip->nlink < 1)
++-    panic("unlink: nlink < 1");
++-  if(ip->type == T_DIR && !isdirempty(ip)){
++-    iunlockput(ip);
++-    goto bad;
++-  }
++-
++-  memset(&de, 0, sizeof(de));
++-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
++-    panic("unlink: writei");
++-  if(ip->type == T_DIR){
++-    dp->nlink--;
++-    iupdate(dp);
++-  }
++-  iunlockput(dp);
++-
++-  ip->nlink--;
++-  iupdate(ip);
++-  iunlockput(ip);
++-
++-  end_op();
++-
++-  return 0;
++-
++-bad:
++-  iunlockput(dp);
++-  end_op();
++-  return -1;
++-}
++-
++-static struct inode*
++-create(char *path, short type, short major, short minor)
++-{
++-  struct inode *ip, *dp;
++-  char name[DIRSIZ];
++-
++-  if((dp = nameiparent(path, name)) == 0)
++-    return 0;
++-  ilock(dp);
++-
++-  if((ip = dirlookup(dp, name, 0)) != 0){
++-    iunlockput(dp);
++-    ilock(ip);
++-    if(type == T_FILE && ip->type == T_FILE)
++-      return ip;
++-    iunlockput(ip);
++-    return 0;
++-  }
++-
++-  if((ip = ialloc(dp->dev, type)) == 0)
++-    panic("create: ialloc");
++-
++-  ilock(ip);
++-  ip->major = major;
++-  ip->minor = minor;
++-  ip->nlink = 1;
++-  iupdate(ip);
++-
++-  if(type == T_DIR){  // Create . and .. entries.
++-    dp->nlink++;  // for ".."
++-    iupdate(dp);
++-    // No ip->nlink++ for ".": avoid cyclic ref count.
++-    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
++-      panic("create dots");
++-  }
++-
++-  if(dirlink(dp, name, ip->inum) < 0)
++-    panic("create: dirlink");
++-
++-  iunlockput(dp);
++-
++-  return ip;
++-}
++-
++-int
++-sys_open(void)
++-{
++-  char *path;
++-  int fd, omode;
++-  struct file *f;
++-  struct inode *ip;
++-
++-  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
++-    return -1;
++-
++-  begin_op();
++-
++-  if(omode & O_CREATE){
++-    ip = create(path, T_FILE, 0, 0);
++-    if(ip == 0){
++-      end_op();
++-      return -1;
++-    }
++-  } else {
++-    if((ip = namei(path)) == 0){
++-      end_op();
++-      return -1;
++-    }
++-    ilock(ip);
++-    if(ip->type == T_DIR && omode != O_RDONLY){
++-      iunlockput(ip);
++-      end_op();
++-      return -1;
++-    }
++-  }
++-
++-  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
++-    if(f)
++-      fileclose(f);
++-    iunlockput(ip);
++-    end_op();
++-    return -1;
++-  }
++-  iunlock(ip);
++-  end_op();
++-
++-  f->type = FD_INODE;
++-  f->ip = ip;
++-  f->off = 0;
++-  f->readable = !(omode & O_WRONLY);
++-  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
++-  return fd;
++-}
++-
++-int
++-sys_mkdir(void)
++-{
++-  char *path;
++-  struct inode *ip;
++-
++-  begin_op();
++-  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
++-    end_op();
++-    return -1;
++-  }
++-  iunlockput(ip);
++-  end_op();
++-  return 0;
++-}
++-
++-int
++-sys_mknod(void)
++-{
++-  struct inode *ip;
++-  char *path;
++-  int major, minor;
++-
++-  begin_op();
++-  if((argstr(0, &path)) < 0 ||
++-     argint(1, &major) < 0 ||
++-     argint(2, &minor) < 0 ||
++-     (ip = create(path, T_DEV, major, minor)) == 0){
++-    end_op();
++-    return -1;
++-  }
++-  iunlockput(ip);
++-  end_op();
++-  return 0;
++-}
++-
++-int
++-sys_chdir(void)
++-{
++-  char *path;
++-  struct inode *ip;
++-  struct proc *curproc = myproc();
++-  
++-  begin_op();
++-  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
++-    end_op();
++-    return -1;
++-  }
++-  ilock(ip);
++-  if(ip->type != T_DIR){
++-    iunlockput(ip);
++-    end_op();
++-    return -1;
++-  }
++-  iunlock(ip);
++-  iput(curproc->cwd);
++-  end_op();
++-  curproc->cwd = ip;
++-  return 0;
++-}
++-
++-int
++-sys_exec(void)
++-{
++-  char *path, *argv[MAXARG];
++-  int i;
++-  uint uargv, uarg;
++-
++-  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
++-    return -1;
++-  }
++-  memset(argv, 0, sizeof(argv));
++-  for(i=0;; i++){
++-    if(i >= NELEM(argv))
++-      return -1;
++-    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
++-      return -1;
++-    if(uarg == 0){
++-      argv[i] = 0;
++-      break;
++-    }
++-    if(fetchstr(uarg, &argv[i]) < 0)
++-      return -1;
++-  }
++-  return exec(path, argv);
++-}
++-
++-int
++-sys_pipe(void)
++-{
++-  int *fd;
++-  struct file *rf, *wf;
++-  int fd0, fd1;
++-
++-  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
++-    return -1;
++-  if(pipealloc(&rf, &wf) < 0)
++-    return -1;
++-  fd0 = -1;
++-  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
++-    if(fd0 >= 0)
++-      myproc()->ofile[fd0] = 0;
++-    fileclose(rf);
++-    fileclose(wf);
++-    return -1;
++-  }
++-  fd[0] = fd0;
++-  fd[1] = fd1;
++-  return 0;
++-}
++diff --git a/sysproc.c b/sysproc.c
++deleted file mode 100644
++index ebccf84..0000000
++--- a/sysproc.c
+++++ /dev/null
++@@ -1,97 +0,0 @@
++-#include "types.h"
++-#include "x86.h"
++-#include "defs.h"
++-#include "date.h"
++-#include "param.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-#include "proc.h"
++-
++-int
++-sys_fork(void)
++-{
++-  return fork();
++-}
++-
++-int
++-sys_exit(int status)
++-{
++-  exit(status);
++-  return 0;  // not reached
++-}
++-
++-int
++-sys_wait(int* status)
++-{
++-  return wait(status);
++-}
++-
++-int
++-sys_waitpid(int pid, int* status, int options)
++-{
++-    return waitpid(pid, status, options);
++-}
++-
++-int
++-sys_kill(void)
++-{
++-  int pid;
++-
++-  if(argint(0, &pid) < 0)
++-    return -1;
++-  return kill(pid);
++-}
++-
++-int
++-sys_getpid(void)
++-{
++-  return myproc()->pid;
++-}
++-
++-int
++-sys_sbrk(void)
++-{
++-  int addr;
++-  int n;
++-
++-  if(argint(0, &n) < 0)
++-    return -1;
++-  addr = myproc()->sz;
++-  if(growproc(n) < 0)
++-    return -1;
++-  return addr;
++-}
++-
++-int
++-sys_sleep(void)
++-{
++-  int n;
++-  uint ticks0;
++-
++-  if(argint(0, &n) < 0)
++-    return -1;
++-  acquire(&tickslock);
++-  ticks0 = ticks;
++-  while(ticks - ticks0 < n){
++-    if(myproc()->killed){
++-      release(&tickslock);
++-      return -1;
++-    }
++-    sleep(&ticks, &tickslock);
++-  }
++-  release(&tickslock);
++-  return 0;
++-}
++-
++-// return how many clock tick interrupts have occurred
++-// since start.
++-int
++-sys_uptime(void)
++-{
++-  uint xticks;
++-
++-  acquire(&tickslock);
++-  xticks = ticks;
++-  release(&tickslock);
++-  return xticks;
++-}
++diff --git a/toc.ftr b/toc.ftr
++deleted file mode 100644
++index 0061c1d..0000000
++--- a/toc.ftr
+++++ /dev/null
++@@ -1,13 +0,0 @@
++-
++-
++-The source listing is preceded by a cross-reference that lists every defined 
++-constant, struct, global variable, and function in xv6.  Each entry gives,
++-on the same line as the name, the line number (or, in a few cases, numbers)
++-where the name is defined.  Successive lines in an entry list the line
++-numbers where the name is used.  For example, this entry:
++-
++-    swtch 2658
++-        0374 2428 2466 2657 2658
++-
++-indicates that swtch is defined on line 2658 and is mentioned on five lines
++-on sheets 03, 24, and 26.
++diff --git a/toc.hdr b/toc.hdr
++deleted file mode 100644
++index 3698d81..0000000
++--- a/toc.hdr
+++++ /dev/null
++@@ -1,6 +0,0 @@
++-The numbers to the left of the file names in the table are sheet numbers.
++-The source code has been printed in a double column format with fifty
++-lines per column, giving one hundred lines per sheet (or page).
++-Thus there is a convenient relationship between line numbers and sheet numbers.
++-
++-
+ diff --git a/trap.c b/trap.c
+-index 41c66eb..432ea5b 100644
++deleted file mode 100644
++index 432ea5b..0000000
+ --- a/trap.c
+-+++ b/trap.c
+-@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
+- {
+-   if(tf->trapno == T_SYSCALL){
+-     if(myproc()->killed)
+--      exit();
+-+      exit(4);
+-     myproc()->tf = tf;
+-     syscall();
+-     if(myproc()->killed)
+--      exit();
+-+      exit(3);
+-     return;
+-   }
+- 
+-@@ -98,7 +98,7 @@ trap(struct trapframe *tf)
+-   // (If it is still executing in the kernel, let it keep running
+-   // until it gets to the regular system call return.)
+-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+--    exit();
+-+    exit(2);
+- 
+-   // Force process to give up CPU on clock tick.
+-   // If interrupts were on while locks held, would need to check nlock.
+-@@ -108,5 +108,5 @@ trap(struct trapframe *tf)
+- 
+-   // Check if the process has been killed since we yielded
+-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+--    exit();
+-+    exit(1);
+- }
+++++ /dev/null
++@@ -1,112 +0,0 @@
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "x86.h"
++-#include "traps.h"
++-#include "spinlock.h"
++-
++-// Interrupt descriptor table (shared by all CPUs).
++-struct gatedesc idt[256];
++-extern uint vectors[];  // in vectors.S: array of 256 entry pointers
++-struct spinlock tickslock;
++-uint ticks;
++-
++-void
++-tvinit(void)
++-{
++-  int i;
++-
++-  for(i = 0; i < 256; i++)
++-    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
++-  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
++-
++-  initlock(&tickslock, "time");
++-}
++-
++-void
++-idtinit(void)
++-{
++-  lidt(idt, sizeof(idt));
++-}
++-
++-//PAGEBREAK: 41
++-void
++-trap(struct trapframe *tf)
++-{
++-  if(tf->trapno == T_SYSCALL){
++-    if(myproc()->killed)
++-      exit(4);
++-    myproc()->tf = tf;
++-    syscall();
++-    if(myproc()->killed)
++-      exit(3);
++-    return;
++-  }
++-
++-  switch(tf->trapno){
++-  case T_IRQ0 + IRQ_TIMER:
++-    if(cpuid() == 0){
++-      acquire(&tickslock);
++-      ticks++;
++-      wakeup(&ticks);
++-      release(&tickslock);
++-    }
++-    lapiceoi();
++-    break;
++-  case T_IRQ0 + IRQ_IDE:
++-    ideintr();
++-    lapiceoi();
++-    break;
++-  case T_IRQ0 + IRQ_IDE+1:
++-    // Bochs generates spurious IDE1 interrupts.
++-    break;
++-  case T_IRQ0 + IRQ_KBD:
++-    kbdintr();
++-    lapiceoi();
++-    break;
++-  case T_IRQ0 + IRQ_COM1:
++-    uartintr();
++-    lapiceoi();
++-    break;
++-  case T_IRQ0 + 7:
++-  case T_IRQ0 + IRQ_SPURIOUS:
++-    cprintf("cpu%d: spurious interrupt at %x:%x\n",
++-            cpuid(), tf->cs, tf->eip);
++-    lapiceoi();
++-    break;
++-
++-  //PAGEBREAK: 13
++-  default:
++-    if(myproc() == 0 || (tf->cs&3) == 0){
++-      // In kernel, it must be our mistake.
++-      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
++-              tf->trapno, cpuid(), tf->eip, rcr2());
++-      panic("trap");
++-    }
++-    // In user space, assume process misbehaved.
++-    cprintf("pid %d %s: trap %d err %d on cpu %d "
++-            "eip 0x%x addr 0x%x--kill proc\n",
++-            myproc()->pid, myproc()->name, tf->trapno,
++-            tf->err, cpuid(), tf->eip, rcr2());
++-    myproc()->killed = 1;
++-  }
++-
++-  // Force process exit if it has been killed and is in user space.
++-  // (If it is still executing in the kernel, let it keep running
++-  // until it gets to the regular system call return.)
++-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
++-    exit(2);
++-
++-  // Force process to give up CPU on clock tick.
++-  // If interrupts were on while locks held, would need to check nlock.
++-  if(myproc() && myproc()->state == RUNNING &&
++-     tf->trapno == T_IRQ0+IRQ_TIMER)
++-    yield();
++-
++-  // Check if the process has been killed since we yielded
++-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
++-    exit(1);
++-}
++diff --git a/trapasm.S b/trapasm.S
++deleted file mode 100644
++index da8aefc..0000000
++--- a/trapasm.S
+++++ /dev/null
++@@ -1,32 +0,0 @@
++-#include "mmu.h"
++-
++-  # vectors.S sends all traps here.
++-.globl alltraps
++-alltraps:
++-  # Build trap frame.
++-  pushl %ds
++-  pushl %es
++-  pushl %fs
++-  pushl %gs
++-  pushal
++-  
++-  # Set up data segments.
++-  movw $(SEG_KDATA<<3), %ax
++-  movw %ax, %ds
++-  movw %ax, %es
++-
++-  # Call trap(tf), where tf=%esp
++-  pushl %esp
++-  call trap
++-  addl $4, %esp
++-
++-  # Return falls through to trapret...
++-.globl trapret
++-trapret:
++-  popal
++-  popl %gs
++-  popl %fs
++-  popl %es
++-  popl %ds
++-  addl $0x8, %esp  # trapno and errcode
++-  iret
++diff --git a/traps.h b/traps.h
++deleted file mode 100644
++index 0bd1fd8..0000000
++--- a/traps.h
+++++ /dev/null
++@@ -1,38 +0,0 @@
++-// x86 trap and interrupt constants.
++-
++-// Processor-defined:
++-#define T_DIVIDE         0      // divide error
++-#define T_DEBUG          1      // debug exception
++-#define T_NMI            2      // non-maskable interrupt
++-#define T_BRKPT          3      // breakpoint
++-#define T_OFLOW          4      // overflow
++-#define T_BOUND          5      // bounds check
++-#define T_ILLOP          6      // illegal opcode
++-#define T_DEVICE         7      // device not available
++-#define T_DBLFLT         8      // double fault
++-// #define T_COPROC      9      // reserved (not used since 486)
++-#define T_TSS           10      // invalid task switch segment
++-#define T_SEGNP         11      // segment not present
++-#define T_STACK         12      // stack exception
++-#define T_GPFLT         13      // general protection fault
++-#define T_PGFLT         14      // page fault
++-// #define T_RES        15      // reserved
++-#define T_FPERR         16      // floating point error
++-#define T_ALIGN         17      // aligment check
++-#define T_MCHK          18      // machine check
++-#define T_SIMDERR       19      // SIMD floating point error
++-
++-// These are arbitrarily chosen, but with care not to overlap
++-// processor defined exceptions or interrupt vectors.
++-#define T_SYSCALL       64      // system call
++-#define T_DEFAULT      500      // catchall
++-
++-#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ
++-
++-#define IRQ_TIMER        0
++-#define IRQ_KBD          1
++-#define IRQ_COM1         4
++-#define IRQ_IDE         14
++-#define IRQ_ERROR       19
++-#define IRQ_SPURIOUS    31
++-
++diff --git a/types.h b/types.h
++deleted file mode 100644
++index e4adf64..0000000
++--- a/types.h
+++++ /dev/null
++@@ -1,4 +0,0 @@
++-typedef unsigned int   uint;
++-typedef unsigned short ushort;
++-typedef unsigned char  uchar;
++-typedef uint pde_t;
++diff --git a/uart.c b/uart.c
++deleted file mode 100644
++index b8946da..0000000
++--- a/uart.c
+++++ /dev/null
++@@ -1,77 +0,0 @@
++-// Intel 8250 serial port (UART).
++-
++-#include "types.h"
++-#include "defs.h"
++-#include "param.h"
++-#include "traps.h"
++-#include "spinlock.h"
++-#include "sleeplock.h"
++-#include "fs.h"
++-#include "file.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "x86.h"
++-
++-#define COM1    0x3f8
++-
++-static int uart;    // is there a uart?
++-
++-void
++-uartinit(void)
++-{
++-  char *p;
++-
++-  // Turn off the FIFO
++-  outb(COM1+2, 0);
++-
++-  // 9600 baud, 8 data bits, 1 stop bit, parity off.
++-  outb(COM1+3, 0x80);    // Unlock divisor
++-  outb(COM1+0, 115200/9600);
++-  outb(COM1+1, 0);
++-  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
++-  outb(COM1+4, 0);
++-  outb(COM1+1, 0x01);    // Enable receive interrupts.
++-
++-  // If status is 0xFF, no serial port.
++-  if(inb(COM1+5) == 0xFF)
++-    return;
++-  uart = 1;
++-
++-  // Acknowledge pre-existing interrupt conditions;
++-  // enable interrupts.
++-  inb(COM1+2);
++-  inb(COM1+0);
++-  ioapicenable(IRQ_COM1, 0);
++-
++-  // Announce that we're here.
++-  for(p="xv6...\n"; *p; p++)
++-    uartputc(*p);
++-}
++-
++-void
++-uartputc(int c)
++-{
++-  int i;
++-
++-  if(!uart)
++-    return;
++-  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
++-    microdelay(10);
++-  outb(COM1+0, c);
++-}
++-
++-static int
++-uartgetc(void)
++-{
++-  if(!uart)
++-    return -1;
++-  if(!(inb(COM1+5) & 0x01))
++-    return -1;
++-  return inb(COM1+0);
++-}
++-
++-void
++-uartintr(void)
++-{
++-  consoleintr(uartgetc);
++-}
++diff --git a/ulib.c b/ulib.c
++deleted file mode 100644
++index 8e1e1a2..0000000
++--- a/ulib.c
+++++ /dev/null
++@@ -1,106 +0,0 @@
++-#include "types.h"
++-#include "stat.h"
++-#include "fcntl.h"
++-#include "user.h"
++-#include "x86.h"
++-
++-char*
++-strcpy(char *s, const char *t)
++-{
++-  char *os;
++-
++-  os = s;
++-  while((*s++ = *t++) != 0)
++-    ;
++-  return os;
++-}
++-
++-int
++-strcmp(const char *p, const char *q)
++-{
++-  while(*p && *p == *q)
++-    p++, q++;
++-  return (uchar)*p - (uchar)*q;
++-}
++-
++-uint
++-strlen(const char *s)
++-{
++-  int n;
++-
++-  for(n = 0; s[n]; n++)
++-    ;
++-  return n;
++-}
++-
++-void*
++-memset(void *dst, int c, uint n)
++-{
++-  stosb(dst, c, n);
++-  return dst;
++-}
++-
++-char*
++-strchr(const char *s, char c)
++-{
++-  for(; *s; s++)
++-    if(*s == c)
++-      return (char*)s;
++-  return 0;
++-}
++-
++-char*
++-gets(char *buf, int max)
++-{
++-  int i, cc;
++-  char c;
++-
++-  for(i=0; i+1 < max; ){
++-    cc = read(0, &c, 1);
++-    if(cc < 1)
++-      break;
++-    buf[i++] = c;
++-    if(c == '\n' || c == '\r')
++-      break;
++-  }
++-  buf[i] = '\0';
++-  return buf;
++-}
++-
++-int
++-stat(const char *n, struct stat *st)
++-{
++-  int fd;
++-  int r;
++-
++-  fd = open(n, O_RDONLY);
++-  if(fd < 0)
++-    return -1;
++-  r = fstat(fd, st);
++-  close(fd);
++-  return r;
++-}
++-
++-int
++-atoi(const char *s)
++-{
++-  int n;
++-
++-  n = 0;
++-  while('0' <= *s && *s <= '9')
++-    n = n*10 + *s++ - '0';
++-  return n;
++-}
++-
++-void*
++-memmove(void *vdst, const void *vsrc, int n)
++-{
++-  char *dst;
++-  const char *src;
++-
++-  dst = vdst;
++-  src = vsrc;
++-  while(n-- > 0)
++-    *dst++ = *src++;
++-  return vdst;
++-}
++diff --git a/umalloc.c b/umalloc.c
++deleted file mode 100644
++index a7e7d2c..0000000
++--- a/umalloc.c
+++++ /dev/null
++@@ -1,90 +0,0 @@
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-#include "param.h"
++-
++-// Memory allocator by Kernighan and Ritchie,
++-// The C programming Language, 2nd ed.  Section 8.7.
++-
++-typedef long Align;
++-
++-union header {
++-  struct {
++-    union header *ptr;
++-    uint size;
++-  } s;
++-  Align x;
++-};
++-
++-typedef union header Header;
++-
++-static Header base;
++-static Header *freep;
++-
++-void
++-free(void *ap)
++-{
++-  Header *bp, *p;
++-
++-  bp = (Header*)ap - 1;
++-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++-      break;
++-  if(bp + bp->s.size == p->s.ptr){
++-    bp->s.size += p->s.ptr->s.size;
++-    bp->s.ptr = p->s.ptr->s.ptr;
++-  } else
++-    bp->s.ptr = p->s.ptr;
++-  if(p + p->s.size == bp){
++-    p->s.size += bp->s.size;
++-    p->s.ptr = bp->s.ptr;
++-  } else
++-    p->s.ptr = bp;
++-  freep = p;
++-}
++-
++-static Header*
++-morecore(uint nu)
++-{
++-  char *p;
++-  Header *hp;
++-
++-  if(nu < 4096)
++-    nu = 4096;
++-  p = sbrk(nu * sizeof(Header));
++-  if(p == (char*)-1)
++-    return 0;
++-  hp = (Header*)p;
++-  hp->s.size = nu;
++-  free((void*)(hp + 1));
++-  return freep;
++-}
++-
++-void*
++-malloc(uint nbytes)
++-{
++-  Header *p, *prevp;
++-  uint nunits;
++-
++-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
++-  if((prevp = freep) == 0){
++-    base.s.ptr = freep = prevp = &base;
++-    base.s.size = 0;
++-  }
++-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
++-    if(p->s.size >= nunits){
++-      if(p->s.size == nunits)
++-        prevp->s.ptr = p->s.ptr;
++-      else {
++-        p->s.size -= nunits;
++-        p += p->s.size;
++-        p->s.size = nunits;
++-      }
++-      freep = prevp;
++-      return (void*)(p + 1);
++-    }
++-    if(p == freep)
++-      if((p = morecore(nunits)) == 0)
++-        return 0;
++-  }
++-}
+ diff --git a/user.h b/user.h
+-index 4f99c52..0931387 100644
++deleted file mode 100644
++index 0931387..0000000
+ --- a/user.h
+-+++ b/user.h
+-@@ -1,10 +1,13 @@
+-+#include <stddef.h>
+-+
+- struct stat;
+- struct rtcdate;
+- 
+- // system calls
+- int fork(void);
+--int exit(void) __attribute__((noreturn));
+--int wait(void);
+-+int exit(int status) __attribute__((noreturn));
+-+int wait(int* status);
+-+int waitpid(int pid, int* status, int options);
+- int pipe(int*);
+- int write(int, const void*, int);
+- int read(int, void*, int);
+++++ /dev/null
++@@ -1,42 +0,0 @@
++-#include <stddef.h>
++-
++-struct stat;
++-struct rtcdate;
++-
++-// system calls
++-int fork(void);
++-int exit(int status) __attribute__((noreturn));
++-int wait(int* status);
++-int waitpid(int pid, int* status, int options);
++-int pipe(int*);
++-int write(int, const void*, int);
++-int read(int, void*, int);
++-int close(int);
++-int kill(int);
++-int exec(char*, char**);
++-int open(const char*, int);
++-int mknod(const char*, short, short);
++-int unlink(const char*);
++-int fstat(int fd, struct stat*);
++-int link(const char*, const char*);
++-int mkdir(const char*);
++-int chdir(const char*);
++-int dup(int);
++-int getpid(void);
++-char* sbrk(int);
++-int sleep(int);
++-int uptime(void);
++-
++-// ulib.c
++-int stat(const char*, struct stat*);
++-char* strcpy(char*, const char*);
++-void *memmove(void*, const void*, int);
++-char* strchr(const char*, char c);
++-int strcmp(const char*, const char*);
++-void printf(int, const char*, ...);
++-char* gets(char*, int max);
++-uint strlen(const char*);
++-void* memset(void*, int, uint);
++-void* malloc(uint);
++-void free(void*);
++-int atoi(const char*);
+ diff --git a/usertests.c b/usertests.c
+-index a1e97e7..2c2c128 100644
++deleted file mode 100644
++index 2c2c128..0000000
+ --- a/usertests.c
+-+++ b/usertests.c
+-@@ -21,19 +21,19 @@ iputtest(void)
+- 
+-   if(mkdir("iputdir") < 0){
+-     printf(stdout, "mkdir failed\n");
+--    exit();
+-+    exit(184);
+-   }
+-   if(chdir("iputdir") < 0){
+-     printf(stdout, "chdir iputdir failed\n");
+--    exit();
+-+    exit(183);
+-   }
+-   if(unlink("../iputdir") < 0){
+-     printf(stdout, "unlink ../iputdir failed\n");
+--    exit();
+-+    exit(182);
+-   }
+-   if(chdir("/") < 0){
+-     printf(stdout, "chdir / failed\n");
+--    exit();
+-+    exit(181);
+-   }
+-   printf(stdout, "iput test ok\n");
+- }
+-@@ -49,24 +49,24 @@ exitiputtest(void)
+-   pid = fork();
+-   if(pid < 0){
+-     printf(stdout, "fork failed\n");
+--    exit();
+-+    exit(180);
+-   }
+-   if(pid == 0){
+-     if(mkdir("iputdir") < 0){
+-       printf(stdout, "mkdir failed\n");
+--      exit();
+-+      exit(179);
+-     }
+-     if(chdir("iputdir") < 0){
+-       printf(stdout, "child chdir failed\n");
+--      exit();
+-+      exit(178);
+-     }
+-     if(unlink("../iputdir") < 0){
+-       printf(stdout, "unlink ../iputdir failed\n");
+--      exit();
+-+      exit(177);
+-     }
+--    exit();
+-+    exit(176);
+-   }
+--  wait();
+-+  wait(NULL);
+-   printf(stdout, "exitiput test ok\n");
+- }
+- 
+-@@ -89,27 +89,27 @@ openiputtest(void)
+-   printf(stdout, "openiput test\n");
+-   if(mkdir("oidir") < 0){
+-     printf(stdout, "mkdir oidir failed\n");
+--    exit();
+-+    exit(175);
+-   }
+-   pid = fork();
+-   if(pid < 0){
+-     printf(stdout, "fork failed\n");
+--    exit();
+-+    exit(174);
+-   }
+-   if(pid == 0){
+-     int fd = open("oidir", O_RDWR);
+-     if(fd >= 0){
+-       printf(stdout, "open directory for write succeeded\n");
+--      exit();
+-+      exit(0);
+-     }
+--    exit();
+-+    exit(172);
+-   }
+-   sleep(1);
+-   if(unlink("oidir") != 0){
+-     printf(stdout, "unlink failed\n");
+--    exit();
+-+    exit(171);
+-   }
+--  wait();
+-+  wait(NULL);
+-   printf(stdout, "openiput test ok\n");
+- }
+- 
+-@@ -124,13 +124,13 @@ opentest(void)
+-   fd = open("echo", 0);
+-   if(fd < 0){
+-     printf(stdout, "open echo failed!\n");
+--    exit();
+-+    exit(170);
+-   }
+-   close(fd);
+-   fd = open("doesnotexist", 0);
+-   if(fd >= 0){
+-     printf(stdout, "open doesnotexist succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   printf(stdout, "open test ok\n");
+- }
+-@@ -147,16 +147,16 @@ writetest(void)
+-     printf(stdout, "creat small succeeded; ok\n");
+-   } else {
+-     printf(stdout, "error: creat small failed!\n");
+--    exit();
+-+    exit(168);
+-   }
+-   for(i = 0; i < 100; i++){
+-     if(write(fd, "aaaaaaaaaa", 10) != 10){
+-       printf(stdout, "error: write aa %d new file failed\n", i);
+--      exit();
+-+      exit(167);
+-     }
+-     if(write(fd, "bbbbbbbbbb", 10) != 10){
+-       printf(stdout, "error: write bb %d new file failed\n", i);
+--      exit();
+-+      exit(166);
+-     }
+-   }
+-   printf(stdout, "writes ok\n");
+-@@ -166,20 +166,20 @@ writetest(void)
+-     printf(stdout, "open small succeeded ok\n");
+-   } else {
+-     printf(stdout, "error: open small failed!\n");
+--    exit();
+-+    exit(165);
+-   }
+-   i = read(fd, buf, 2000);
+-   if(i == 2000){
+-     printf(stdout, "read succeeded ok\n");
+-   } else {
+-     printf(stdout, "read failed\n");
+--    exit();
+-+    exit(164);
+-   }
+-   close(fd);
+- 
+-   if(unlink("small") < 0){
+-     printf(stdout, "unlink small failed\n");
+--    exit();
+-+    exit(163);
+-   }
+-   printf(stdout, "small file test ok\n");
+- }
+-@@ -194,14 +194,14 @@ writetest1(void)
+-   fd = open("big", O_CREATE|O_RDWR);
+-   if(fd < 0){
+-     printf(stdout, "error: creat big failed!\n");
+--    exit();
+-+    exit(162);
+-   }
+- 
+-   for(i = 0; i < MAXFILE; i++){
+-     ((int*)buf)[0] = i;
+-     if(write(fd, buf, 512) != 512){
+-       printf(stdout, "error: write big file failed\n", i);
+--      exit();
+-+      exit(161);
+-     }
+-   }
+- 
+-@@ -210,7 +210,7 @@ writetest1(void)
+-   fd = open("big", O_RDONLY);
+-   if(fd < 0){
+-     printf(stdout, "error: open big failed!\n");
+--    exit();
+-+    exit(160);
+-   }
+- 
+-   n = 0;
+-@@ -219,24 +219,24 @@ writetest1(void)
+-     if(i == 0){
+-       if(n == MAXFILE - 1){
+-         printf(stdout, "read only %d blocks from big", n);
+--        exit();
+-+        exit(159);
+-       }
+-       break;
+-     } else if(i != 512){
+-       printf(stdout, "read failed %d\n", i);
+--      exit();
+-+      exit(158);
+-     }
+-     if(((int*)buf)[0] != n){
+-       printf(stdout, "read content of block %d is %d\n",
+-              n, ((int*)buf)[0]);
+--      exit();
+-+      exit(157);
+-     }
+-     n++;
+-   }
+-   close(fd);
+-   if(unlink("big") < 0){
+-     printf(stdout, "unlink big failed\n");
+--    exit();
+-+    exit(156);
+-   }
+-   printf(stdout, "big files ok\n");
+- }
+-@@ -270,22 +270,22 @@ void dirtest(void)
+- 
+-   if(mkdir("dir0") < 0){
+-     printf(stdout, "mkdir failed\n");
+--    exit();
+-+    exit(155);
+-   }
+- 
+-   if(chdir("dir0") < 0){
+-     printf(stdout, "chdir dir0 failed\n");
+--    exit();
+-+    exit(154);
+-   }
+- 
+-   if(chdir("..") < 0){
+-     printf(stdout, "chdir .. failed\n");
+--    exit();
+-+    exit(153);
+-   }
+- 
+-   if(unlink("dir0") < 0){
+-     printf(stdout, "unlink dir0 failed\n");
+--    exit();
+-+    exit(152);
+-   }
+-   printf(stdout, "mkdir test ok\n");
+- }
+-@@ -296,7 +296,7 @@ exectest(void)
+-   printf(stdout, "exec test\n");
+-   if(exec("echo", echoargv) < 0){
+-     printf(stdout, "exec echo failed\n");
+--    exit();
+-+    exit(151);
+-   }
+- }
+- 
+-@@ -310,7 +310,7 @@ pipe1(void)
+- 
+-   if(pipe(fds) != 0){
+-     printf(1, "pipe() failed\n");
+--    exit();
+-+    exit(150);
+-   }
+-   pid = fork();
+-   seq = 0;
+-@@ -321,10 +321,10 @@ pipe1(void)
+-         buf[i] = seq++;
+-       if(write(fds[1], buf, 1033) != 1033){
+-         printf(1, "pipe1 oops 1\n");
+--        exit();
+-+        exit(149);
+-       }
+-     }
+--    exit();
+-+    exit(148);
+-   } else if(pid > 0){
+-     close(fds[1]);
+-     total = 0;
+-@@ -343,13 +343,13 @@ pipe1(void)
+-     }
+-     if(total != 5 * 1033){
+-       printf(1, "pipe1 oops 3 total %d\n", total);
+--      exit();
+-+      exit(147);
+-     }
+-     close(fds[0]);
+--    wait();
+-+    wait(NULL);
+-   } else {
+-     printf(1, "fork() failed\n");
+--    exit();
+-+    exit(146);
+-   }
+-   printf(1, "pipe1 ok\n");
+- }
+-@@ -394,9 +394,9 @@ preempt(void)
+-   kill(pid2);
+-   kill(pid3);
+-   printf(1, "wait... ");
+--  wait();
+--  wait();
+--  wait();
+-+  wait(NULL);
+-+  wait(NULL);
+-+  wait(NULL);
+-   printf(1, "preempt ok\n");
+- }
+- 
+-@@ -413,12 +413,12 @@ exitwait(void)
+-       return;
+-     }
+-     if(pid){
+--      if(wait() != pid){
+-+      if(wait(NULL) != pid){
+-         printf(1, "wait wrong pid\n");
+-         return;
+-       }
+-     } else {
+--      exit();
+-+      exit(145);
+-     }
+-   }
+-   printf(1, "exitwait ok\n");
+-@@ -447,13 +447,13 @@ mem(void)
+-     if(m1 == 0){
+-       printf(1, "couldn't allocate mem?!!\n");
+-       kill(ppid);
+--      exit();
+-+      exit(144);
+-     }
+-     free(m1);
+-     printf(1, "mem ok\n");
+--    exit();
+-+    exit(0);
+-   } else {
+--    wait();
+-+    wait(NULL);
+-   }
+- }
+- 
+-@@ -484,9 +484,9 @@ sharedfd(void)
+-     }
+-   }
+-   if(pid == 0)
+--    exit();
+-+    exit(142);
+-   else
+--    wait();
+-+    wait(NULL);
+-   close(fd);
+-   fd = open("sharedfd", 0);
+-   if(fd < 0){
+-@@ -508,7 +508,7 @@ sharedfd(void)
+-     printf(1, "sharedfd ok\n");
+-   } else {
+-     printf(1, "sharedfd oops %d %d\n", nc, np);
+--    exit();
+-+    exit(141);
+-   }
+- }
+- 
+-@@ -530,29 +530,29 @@ fourfiles(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "fork failed\n");
+--      exit();
+-+      exit(140);
+-     }
+- 
+-     if(pid == 0){
+-       fd = open(fname, O_CREATE | O_RDWR);
+-       if(fd < 0){
+-         printf(1, "create failed\n");
+--        exit();
+-+        exit(139);
+-       }
+- 
+-       memset(buf, '0'+pi, 512);
+-       for(i = 0; i < 12; i++){
+-         if((n = write(fd, buf, 500)) != 500){
+-           printf(1, "write failed %d\n", n);
+--          exit();
+-+          exit(138);
+-         }
+-       }
+--      exit();
+-+      exit(137);
+-     }
+-   }
+- 
+-   for(pi = 0; pi < 4; pi++){
+--    wait();
+-+    wait(NULL);
+-   }
+- 
+-   for(i = 0; i < 2; i++){
+-@@ -563,7 +563,7 @@ fourfiles(void)
+-       for(j = 0; j < n; j++){
+-         if(buf[j] != '0'+i){
+-           printf(1, "wrong char\n");
+--          exit();
+-+          exit(136);
+-         }
+-       }
+-       total += n;
+-@@ -571,7 +571,7 @@ fourfiles(void)
+-     close(fd);
+-     if(total != 12*500){
+-       printf(1, "wrong length %d\n", total);
+--      exit();
+-+      exit(135);
+-     }
+-     unlink(fname);
+-   }
+-@@ -593,7 +593,7 @@ createdelete(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "fork failed\n");
+--      exit();
+-+      exit(134);
+-     }
+- 
+-     if(pid == 0){
+-@@ -604,23 +604,23 @@ createdelete(void)
+-         fd = open(name, O_CREATE | O_RDWR);
+-         if(fd < 0){
+-           printf(1, "create failed\n");
+--          exit();
+-+          exit(133);
+-         }
+-         close(fd);
+-         if(i > 0 && (i % 2 ) == 0){
+-           name[1] = '0' + (i / 2);
+-           if(unlink(name) < 0){
+-             printf(1, "unlink failed\n");
+--            exit();
+-+            exit(132);
+-           }
+-         }
+-       }
+--      exit();
+-+      exit(131);
+-     }
+-   }
+- 
+-   for(pi = 0; pi < 4; pi++){
+--    wait();
+-+    wait(NULL);
+-   }
+- 
+-   name[0] = name[1] = name[2] = 0;
+-@@ -631,10 +631,10 @@ createdelete(void)
+-       fd = open(name, 0);
+-       if((i == 0 || i >= N/2) && fd < 0){
+-         printf(1, "oops createdelete %s didn't exist\n", name);
+--        exit();
+-+        exit(130);
+-       } else if((i >= 1 && i < N/2) && fd >= 0){
+-         printf(1, "oops createdelete %s did exist\n", name);
+--        exit();
+-+        exit(129);
+-       }
+-       if(fd >= 0)
+-         close(fd);
+-@@ -662,7 +662,7 @@ unlinkread(void)
+-   fd = open("unlinkread", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create unlinkread failed\n");
+--    exit();
+-+    exit(128);
+-   }
+-   write(fd, "hello", 5);
+-   close(fd);
+-@@ -670,11 +670,11 @@ unlinkread(void)
+-   fd = open("unlinkread", O_RDWR);
+-   if(fd < 0){
+-     printf(1, "open unlinkread failed\n");
+--    exit();
+-+    exit(127);
+-   }
+-   if(unlink("unlinkread") != 0){
+-     printf(1, "unlink unlinkread failed\n");
+--    exit();
+-+    exit(126);
+-   }
+- 
+-   fd1 = open("unlinkread", O_CREATE | O_RDWR);
+-@@ -683,15 +683,15 @@ unlinkread(void)
+- 
+-   if(read(fd, buf, sizeof(buf)) != 5){
+-     printf(1, "unlinkread read failed");
+--    exit();
+-+    exit(125);
+-   }
+-   if(buf[0] != 'h'){
+-     printf(1, "unlinkread wrong data\n");
+--    exit();
+-+    exit(124);
+-   }
+-   if(write(fd, buf, 10) != 10){
+-     printf(1, "unlinkread write failed\n");
+--    exit();
+-+    exit(123);
+-   }
+-   close(fd);
+-   unlink("unlinkread");
+-@@ -711,50 +711,50 @@ linktest(void)
+-   fd = open("lf1", O_CREATE|O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create lf1 failed\n");
+--    exit();
+-+    exit(122);
+-   }
+-   if(write(fd, "hello", 5) != 5){
+-     printf(1, "write lf1 failed\n");
+--    exit();
+-+    exit(121);
+-   }
+-   close(fd);
+- 
+-   if(link("lf1", "lf2") < 0){
+-     printf(1, "link lf1 lf2 failed\n");
+--    exit();
+-+    exit(120);
+-   }
+-   unlink("lf1");
+- 
+-   if(open("lf1", 0) >= 0){
+-     printf(1, "unlinked lf1 but it is still there!\n");
+--    exit();
+-+    exit(119);
+-   }
+- 
+-   fd = open("lf2", 0);
+-   if(fd < 0){
+-     printf(1, "open lf2 failed\n");
+--    exit();
+-+    exit(118);
+-   }
+-   if(read(fd, buf, sizeof(buf)) != 5){
+-     printf(1, "read lf2 failed\n");
+--    exit();
+-+    exit(117);
+-   }
+-   close(fd);
+- 
+-   if(link("lf2", "lf2") >= 0){
+-     printf(1, "link lf2 lf2 succeeded! oops\n");
+--    exit();
+-+    exit(116);
+-   }
+- 
+-   unlink("lf2");
+-   if(link("lf2", "lf1") >= 0){
+-     printf(1, "link non-existant succeeded! oops\n");
+--    exit();
+-+    exit(115);
+-   }
+- 
+-   if(link(".", "lf1") >= 0){
+-     printf(1, "link . lf1 succeeded! oops\n");
+--    exit();
+-+    exit(114);
+-   }
+- 
+-   printf(1, "linktest ok\n");
+-@@ -787,14 +787,14 @@ concreate(void)
+-       fd = open(file, O_CREATE | O_RDWR);
+-       if(fd < 0){
+-         printf(1, "concreate create %s failed\n", file);
+--        exit();
+-+        exit(113);
+-       }
+-       close(fd);
+-     }
+-     if(pid == 0)
+--      exit();
+-+      exit(112);
+-     else
+--      wait();
+-+      wait(NULL);
+-   }
+- 
+-   memset(fa, 0, sizeof(fa));
+-@@ -807,11 +807,11 @@ concreate(void)
+-       i = de.name[1] - '0';
+-       if(i < 0 || i >= sizeof(fa)){
+-         printf(1, "concreate weird file %s\n", de.name);
+--        exit();
+-+        exit(111);
+-       }
+-       if(fa[i]){
+-         printf(1, "concreate duplicate file %s\n", de.name);
+--        exit();
+-+        exit(110);
+-       }
+-       fa[i] = 1;
+-       n++;
+-@@ -821,7 +821,7 @@ concreate(void)
+- 
+-   if(n != 40){
+-     printf(1, "concreate not enough files in directory listing\n");
+--    exit();
+-+    exit(109);
+-   }
+- 
+-   for(i = 0; i < 40; i++){
+-@@ -829,7 +829,7 @@ concreate(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(1, "fork failed\n");
+--      exit();
+-+      exit(108);
+-     }
+-     if(((i % 3) == 0 && pid == 0) ||
+-        ((i % 3) == 1 && pid != 0)){
+-@@ -844,9 +844,9 @@ concreate(void)
+-       unlink(file);
+-     }
+-     if(pid == 0)
+--      exit();
+-+      exit(107);
+-     else
+--      wait();
+-+      wait(NULL);
+-   }
+- 
+-   printf(1, "concreate ok\n");
+-@@ -865,7 +865,7 @@ linkunlink()
+-   pid = fork();
+-   if(pid < 0){
+-     printf(1, "fork failed\n");
+--    exit();
+-+    exit(106);
+-   }
+- 
+-   unsigned int x = (pid ? 1 : 97);
+-@@ -881,9 +881,9 @@ linkunlink()
+-   }
+- 
+-   if(pid)
+--    wait();
+-+    wait(NULL);
+-   else
+--    exit();
+-+    exit(105);
+- 
+-   printf(1, "linkunlink ok\n");
+- }
+-@@ -901,7 +901,7 @@ bigdir(void)
+-   fd = open("bd", O_CREATE);
+-   if(fd < 0){
+-     printf(1, "bigdir create failed\n");
+--    exit();
+-+    exit(104);
+-   }
+-   close(fd);
+- 
+-@@ -912,7 +912,7 @@ bigdir(void)
+-     name[3] = '\0';
+-     if(link("bd", name) != 0){
+-       printf(1, "bigdir link failed\n");
+--      exit();
+-+      exit(103);
+-     }
+-   }
+- 
+-@@ -924,7 +924,7 @@ bigdir(void)
+-     name[3] = '\0';
+-     if(unlink(name) != 0){
+-       printf(1, "bigdir unlink failed");
+--      exit();
+-+      exit(102);
+-     }
+-   }
+- 
+-@@ -941,31 +941,31 @@ subdir(void)
+-   unlink("ff");
+-   if(mkdir("dd") != 0){
+-     printf(1, "subdir mkdir dd failed\n");
+--    exit();
+-+    exit(101);
+-   }
+- 
+-   fd = open("dd/ff", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create dd/ff failed\n");
+--    exit();
+-+    exit(100);
+-   }
+-   write(fd, "ff", 2);
+-   close(fd);
+- 
+-   if(unlink("dd") >= 0){
+-     printf(1, "unlink dd (non-empty dir) succeeded!\n");
+--    exit();
+-+    exit(99);
+-   }
+- 
+-   if(mkdir("/dd/dd") != 0){
+-     printf(1, "subdir mkdir dd/dd failed\n");
+--    exit();
+-+    exit(98);
+-   }
+- 
+-   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "create dd/dd/ff failed\n");
+--    exit();
+-+    exit(97);
+-   }
+-   write(fd, "FF", 2);
+-   close(fd);
+-@@ -973,142 +973,142 @@ subdir(void)
+-   fd = open("dd/dd/../ff", 0);
+-   if(fd < 0){
+-     printf(1, "open dd/dd/../ff failed\n");
+--    exit();
+-+    exit(96);
+-   }
+-   cc = read(fd, buf, sizeof(buf));
+-   if(cc != 2 || buf[0] != 'f'){
+-     printf(1, "dd/dd/../ff wrong content\n");
+--    exit();
+-+    exit(95);
+-   }
+-   close(fd);
+- 
+-   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+-     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+--    exit();
+-+    exit(94);
+-   }
+- 
+-   if(unlink("dd/dd/ff") != 0){
+-     printf(1, "unlink dd/dd/ff failed\n");
+--    exit();
+-+    exit(93);
+-   }
+-   if(open("dd/dd/ff", O_RDONLY) >= 0){
+-     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+--    exit();
+-+    exit(92);
+-   }
+- 
+-   if(chdir("dd") != 0){
+-     printf(1, "chdir dd failed\n");
+--    exit();
+-+    exit(91);
+-   }
+-   if(chdir("dd/../../dd") != 0){
+-     printf(1, "chdir dd/../../dd failed\n");
+--    exit();
+-+    exit(90);
+-   }
+-   if(chdir("dd/../../../dd") != 0){
+-     printf(1, "chdir dd/../../dd failed\n");
+--    exit();
+-+    exit(89);
+-   }
+-   if(chdir("./..") != 0){
+-     printf(1, "chdir ./.. failed\n");
+--    exit();
+-+    exit(88);
+-   }
+- 
+-   fd = open("dd/dd/ffff", 0);
+-   if(fd < 0){
+-     printf(1, "open dd/dd/ffff failed\n");
+--    exit();
+-+    exit(87);
+-   }
+-   if(read(fd, buf, sizeof(buf)) != 2){
+-     printf(1, "read dd/dd/ffff wrong len\n");
+--    exit();
+-+    exit(86);
+-   }
+-   close(fd);
+- 
+-   if(open("dd/dd/ff", O_RDONLY) >= 0){
+-     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+- 
+-   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+-     printf(1, "create dd/ff/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+-     printf(1, "create dd/xx/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd", O_CREATE) >= 0){
+-     printf(1, "create dd succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd", O_RDWR) >= 0){
+-     printf(1, "open dd rdwr succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(open("dd", O_WRONLY) >= 0){
+-     printf(1, "open dd wronly succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("dd/ff/ff", "dd/dd/xx") == 0){
+-     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("dd/xx/ff", "dd/dd/xx") == 0){
+-     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("dd/ff", "dd/dd/ffff") == 0){
+-     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dd/ff/ff") == 0){
+-     printf(1, "mkdir dd/ff/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dd/xx/ff") == 0){
+-     printf(1, "mkdir dd/xx/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dd/dd/ffff") == 0){
+-     printf(1, "mkdir dd/dd/ffff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dd/xx/ff") == 0){
+-     printf(1, "unlink dd/xx/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dd/ff/ff") == 0){
+-     printf(1, "unlink dd/ff/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(chdir("dd/ff") == 0){
+-     printf(1, "chdir dd/ff succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(chdir("dd/xx") == 0){
+-     printf(1, "chdir dd/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+- 
+-   if(unlink("dd/dd/ffff") != 0){
+-     printf(1, "unlink dd/dd/ff failed\n");
+--    exit();
+-+    exit(68);
+-   }
+-   if(unlink("dd/ff") != 0){
+-     printf(1, "unlink dd/ff failed\n");
+--    exit();
+-+    exit(67);
+-   }
+-   if(unlink("dd") == 0){
+-     printf(1, "unlink non-empty dd succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dd/dd") < 0){
+-     printf(1, "unlink dd/dd failed\n");
+--    exit();
+-+    exit(65);
+-   }
+-   if(unlink("dd") < 0){
+-     printf(1, "unlink dd failed\n");
+--    exit();
+-+    exit(64);
+-   }
+- 
+-   printf(1, "subdir ok\n");
+-@@ -1127,14 +1127,14 @@ bigwrite(void)
+-     fd = open("bigwrite", O_CREATE | O_RDWR);
+-     if(fd < 0){
+-       printf(1, "cannot create bigwrite\n");
+--      exit();
+-+      exit(63);
+-     }
+-     int i;
+-     for(i = 0; i < 2; i++){
+-       int cc = write(fd, buf, sz);
+-       if(cc != sz){
+-         printf(1, "write(%d) ret %d\n", sz, cc);
+--        exit();
+-+        exit(62);
+-       }
+-     }
+-     close(fd);
+-@@ -1155,13 +1155,13 @@ bigfile(void)
+-   fd = open("bigfile", O_CREATE | O_RDWR);
+-   if(fd < 0){
+-     printf(1, "cannot create bigfile");
+--    exit();
+-+    exit(61);
+-   }
+-   for(i = 0; i < 20; i++){
+-     memset(buf, i, 600);
+-     if(write(fd, buf, 600) != 600){
+-       printf(1, "write bigfile failed\n");
+--      exit();
+-+      exit(60);
+-     }
+-   }
+-   close(fd);
+-@@ -1169,31 +1169,31 @@ bigfile(void)
+-   fd = open("bigfile", 0);
+-   if(fd < 0){
+-     printf(1, "cannot open bigfile\n");
+--    exit();
+-+    exit(59);
+-   }
+-   total = 0;
+-   for(i = 0; ; i++){
+-     cc = read(fd, buf, 300);
+-     if(cc < 0){
+-       printf(1, "read bigfile failed\n");
+--      exit();
+-+      exit(58);
+-     }
+-     if(cc == 0)
+-       break;
+-     if(cc != 300){
+-       printf(1, "short read bigfile\n");
+--      exit();
+-+      exit(57);
+-     }
+-     if(buf[0] != i/2 || buf[299] != i/2){
+-       printf(1, "read bigfile wrong data\n");
+--      exit();
+-+      exit(56);
+-     }
+-     total += cc;
+-   }
+-   close(fd);
+-   if(total != 20*600){
+-     printf(1, "read bigfile wrong total\n");
+--    exit();
+-+    exit(55);
+-   }
+-   unlink("bigfile");
+- 
+-@@ -1210,32 +1210,32 @@ fourteen(void)
+- 
+-   if(mkdir("12345678901234") != 0){
+-     printf(1, "mkdir 12345678901234 failed\n");
+--    exit();
+-+    exit(54);
+-   }
+-   if(mkdir("12345678901234/123456789012345") != 0){
+-     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+--    exit();
+-+    exit(53);
+-   }
+-   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+-   if(fd < 0){
+-     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+--    exit();
+-+    exit(52);
+-   }
+-   close(fd);
+-   fd = open("12345678901234/12345678901234/12345678901234", 0);
+-   if(fd < 0){
+-     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+--    exit();
+-+    exit(51);
+-   }
+-   close(fd);
+- 
+-   if(mkdir("12345678901234/12345678901234") == 0){
+-     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("123456789012345/12345678901234") == 0){
+-     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+- 
+-   printf(1, "fourteen ok\n");
+-@@ -1247,35 +1247,35 @@ rmdot(void)
+-   printf(1, "rmdot test\n");
+-   if(mkdir("dots") != 0){
+-     printf(1, "mkdir dots failed\n");
+--    exit();
+-+    exit(48);
+-   }
+-   if(chdir("dots") != 0){
+-     printf(1, "chdir dots failed\n");
+--    exit();
+-+    exit(47);
+-   }
+-   if(unlink(".") == 0){
+-     printf(1, "rm . worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("..") == 0){
+-     printf(1, "rm .. worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(chdir("/") != 0){
+-     printf(1, "chdir / failed\n");
+--    exit();
+-+    exit(44);
+-   }
+-   if(unlink("dots/.") == 0){
+-     printf(1, "unlink dots/. worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dots/..") == 0){
+-     printf(1, "unlink dots/.. worked!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dots") != 0){
+-     printf(1, "unlink dots failed!\n");
+--    exit();
+-+    exit(41);
+-   }
+-   printf(1, "rmdot ok\n");
+- }
+-@@ -1290,49 +1290,49 @@ dirfile(void)
+-   fd = open("dirfile", O_CREATE);
+-   if(fd < 0){
+-     printf(1, "create dirfile failed\n");
+--    exit();
+-+    exit(40);
+-   }
+-   close(fd);
+-   if(chdir("dirfile") == 0){
+-     printf(1, "chdir dirfile succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   fd = open("dirfile/xx", 0);
+-   if(fd >= 0){
+-     printf(1, "create dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   fd = open("dirfile/xx", O_CREATE);
+-   if(fd >= 0){
+-     printf(1, "create dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(mkdir("dirfile/xx") == 0){
+-     printf(1, "mkdir dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dirfile/xx") == 0){
+-     printf(1, "unlink dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(link("README", "dirfile/xx") == 0){
+-     printf(1, "link to dirfile/xx succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   if(unlink("dirfile") != 0){
+-     printf(1, "unlink dirfile failed!\n");
+--    exit();
+-+    exit(33);
+-   }
+- 
+-   fd = open(".", O_RDWR);
+-   if(fd >= 0){
+-     printf(1, "open . for writing succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   fd = open(".", 0);
+-   if(write(fd, "x", 1) > 0){
+-     printf(1, "write . succeeded!\n");
+--    exit();
+-+    exit(0);
+-   }
+-   close(fd);
+- 
+-@@ -1351,11 +1351,11 @@ iref(void)
+-   for(i = 0; i < 50 + 1; i++){
+-     if(mkdir("irefd") != 0){
+-       printf(1, "mkdir irefd failed\n");
+--      exit();
+-+      exit(30);
+-     }
+-     if(chdir("irefd") != 0){
+-       printf(1, "chdir irefd failed\n");
+--      exit();
+-+      exit(29);
+-     }
+- 
+-     mkdir("");
+-@@ -1388,24 +1388,24 @@ forktest(void)
+-     if(pid < 0)
+-       break;
+-     if(pid == 0)
+--      exit();
+-+      exit(28);
+-   }
+- 
+-   if(n == 1000){
+-     printf(1, "fork claimed to work 1000 times!\n");
+--    exit();
+-+    exit(27);
+-   }
+- 
+-   for(; n > 0; n--){
+--    if(wait() < 0){
+-+    if(wait(NULL) < 0){
+-       printf(1, "wait stopped early\n");
+--      exit();
+-+      exit(26);
+-     }
+-   }
+- 
+--  if(wait() != -1){
+-+  if(wait(NULL) != -1){
+-     printf(1, "wait got too many\n");
+--    exit();
+-+    exit(25);
+-   }
+- 
+-   printf(1, "fork test OK\n");
+-@@ -1428,7 +1428,7 @@ sbrktest(void)
+-     b = sbrk(1);
+-     if(b != a){
+-       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+--      exit();
+-+      exit(24);
+-     }
+-     *b = 1;
+-     a = b + 1;
+-@@ -1436,17 +1436,17 @@ sbrktest(void)
+-   pid = fork();
+-   if(pid < 0){
+-     printf(stdout, "sbrk test fork failed\n");
+--    exit();
+-+    exit(23);
+-   }
+-   c = sbrk(1);
+-   c = sbrk(1);
+-   if(c != a + 1){
+-     printf(stdout, "sbrk test failed post-fork\n");
+--    exit();
+-+    exit(22);
+-   }
+-   if(pid == 0)
+--    exit();
+--  wait();
+-+    exit(21);
+-+  wait(NULL);
+- 
+-   // can one grow address space to something big?
+- #define BIG (100*1024*1024)
+-@@ -1455,7 +1455,7 @@ sbrktest(void)
+-   p = sbrk(amt);
+-   if (p != a) {
+-     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+--    exit();
+-+    exit(20);
+-   }
+-   lastaddr = (char*) (BIG-1);
+-   *lastaddr = 99;
+-@@ -1465,12 +1465,12 @@ sbrktest(void)
+-   c = sbrk(-4096);
+-   if(c == (char*)0xffffffff){
+-     printf(stdout, "sbrk could not deallocate\n");
+--    exit();
+-+    exit(19);
+-   }
+-   c = sbrk(0);
+-   if(c != a - 4096){
+-     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+--    exit();
+-+    exit(18);
+-   }
+- 
+-   // can one re-allocate that page?
+-@@ -1478,19 +1478,19 @@ sbrktest(void)
+-   c = sbrk(4096);
+-   if(c != a || sbrk(0) != a + 4096){
+-     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+--    exit();
+-+    exit(17);
+-   }
+-   if(*lastaddr == 99){
+-     // should be zero
+-     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+--    exit();
+-+    exit(16);
+-   }
+- 
+-   a = sbrk(0);
+-   c = sbrk(-(sbrk(0) - oldbrk));
+-   if(c != a){
+-     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+--    exit();
+-+    exit(15);
+-   }
+- 
+-   // can we read the kernel's memory?
+-@@ -1499,21 +1499,21 @@ sbrktest(void)
+-     pid = fork();
+-     if(pid < 0){
+-       printf(stdout, "fork failed\n");
+--      exit();
+-+      exit(14);
+-     }
+-     if(pid == 0){
+-       printf(stdout, "oops could read %x = %x\n", a, *a);
+-       kill(ppid);
+--      exit();
+-+      exit(13);
+-     }
+--    wait();
+-+    wait(NULL);
+-   }
+- 
+-   // if we run the system out of memory, does it clean up the last
+-   // failed allocation?
+-   if(pipe(fds) != 0){
+-     printf(1, "pipe() failed\n");
+--    exit();
+-+    exit(12);
+-   }
+-   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+-     if((pids[i] = fork()) == 0){
+-@@ -1533,11 +1533,11 @@ sbrktest(void)
+-     if(pids[i] == -1)
+-       continue;
+-     kill(pids[i]);
+--    wait();
+-+    wait(NULL);
+-   }
+-   if(c == (char*)0xffffffff){
+-     printf(stdout, "failed sbrk leaked memory\n");
+--    exit();
+-+    exit(10);
+-   }
+- 
+-   if(sbrk(0) > oldbrk)
+-@@ -1572,17 +1572,17 @@ validatetest(void)
+-     if((pid = fork()) == 0){
+-       // try to crash the kernel by passing in a badly placed integer
+-       validateint((int*)p);
+--      exit();
+-+      exit(9);
+-     }
+-     sleep(0);
+-     sleep(0);
+-     kill(pid);
+--    wait();
+-+    wait(NULL);
+- 
+-     // try to crash the kernel by passing in a bad string pointer
+-     if(link("nosuchfile", (char*)p) != -1){
+-       printf(stdout, "link should not succeed\n");
+--      exit();
+-+      exit(8);
+-     }
+-   }
+- 
+-@@ -1600,7 +1600,7 @@ bsstest(void)
+-   for(i = 0; i < sizeof(uninit); i++){
+-     if(uninit[i] != '\0'){
+-       printf(stdout, "bss test failed\n");
+--      exit();
+-+      exit(7);
+-     }
+-   }
+-   printf(stdout, "bss test ok\n");
+-@@ -1627,16 +1627,16 @@ bigargtest(void)
+-     printf(stdout, "bigarg test ok\n");
+-     fd = open("bigarg-ok", O_CREATE);
+-     close(fd);
+--    exit();
+-+    exit(6);
+-   } else if(pid < 0){
+-     printf(stdout, "bigargtest: fork failed\n");
+--    exit();
+-+    exit(5);
+-   }
+--  wait();
+-+  wait(NULL);
+-   fd = open("bigarg-ok", 0);
+-   if(fd < 0){
+-     printf(stdout, "bigarg test failed!\n");
+--    exit();
+-+    exit(4);
+-   }
+-   close(fd);
+-   unlink("bigarg-ok");
+-@@ -1715,12 +1715,12 @@ uio()
+-     port = RTC_DATA;
+-     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+-     printf(1, "uio: uio succeeded; test FAILED\n");
+--    exit();
+-+    exit(3);
+-   } else if(pid < 0){
+-     printf (1, "fork failed\n");
+--    exit();
+-+    exit(2);
+-   }
+--  wait();
+-+  wait(NULL);
+-   printf(1, "uio test done\n");
+- }
+- 
+-@@ -1730,7 +1730,7 @@ void argptest()
+-   fd = open("init", O_RDONLY);
+-   if (fd < 0) {
+-     printf(2, "open failed\n");
+--    exit();
+-+    exit(1);
+-   }
+-   read(fd, sbrk(0) - 1, -1);
+-   close(fd);
+-@@ -1752,7 +1752,7 @@ main(int argc, char *argv[])
+- 
+-   if(open("usertests.ran", 0) >= 0){
+-     printf(1, "already ran user tests -- rebuild fs.img\n");
+--    exit();
+-+    exit(1);
+-   }
+-   close(open("usertests.ran", O_CREATE));
+- 
+-@@ -1799,5 +1799,5 @@ main(int argc, char *argv[])
+- 
+-   exectest();
+- 
+--  exit();
+-+  exit(0);
+- }
+++++ /dev/null
++@@ -1,1803 +0,0 @@
++-#include "param.h"
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-#include "fs.h"
++-#include "fcntl.h"
++-#include "syscall.h"
++-#include "traps.h"
++-#include "memlayout.h"
++-
++-char buf[8192];
++-char name[3];
++-char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };
++-int stdout = 1;
++-
++-// does chdir() call iput(p->cwd) in a transaction?
++-void
++-iputtest(void)
++-{
++-  printf(stdout, "iput test\n");
++-
++-  if(mkdir("iputdir") < 0){
++-    printf(stdout, "mkdir failed\n");
++-    exit(184);
++-  }
++-  if(chdir("iputdir") < 0){
++-    printf(stdout, "chdir iputdir failed\n");
++-    exit(183);
++-  }
++-  if(unlink("../iputdir") < 0){
++-    printf(stdout, "unlink ../iputdir failed\n");
++-    exit(182);
++-  }
++-  if(chdir("/") < 0){
++-    printf(stdout, "chdir / failed\n");
++-    exit(181);
++-  }
++-  printf(stdout, "iput test ok\n");
++-}
++-
++-// does exit() call iput(p->cwd) in a transaction?
++-void
++-exitiputtest(void)
++-{
++-  int pid;
++-
++-  printf(stdout, "exitiput test\n");
++-
++-  pid = fork();
++-  if(pid < 0){
++-    printf(stdout, "fork failed\n");
++-    exit(180);
++-  }
++-  if(pid == 0){
++-    if(mkdir("iputdir") < 0){
++-      printf(stdout, "mkdir failed\n");
++-      exit(179);
++-    }
++-    if(chdir("iputdir") < 0){
++-      printf(stdout, "child chdir failed\n");
++-      exit(178);
++-    }
++-    if(unlink("../iputdir") < 0){
++-      printf(stdout, "unlink ../iputdir failed\n");
++-      exit(177);
++-    }
++-    exit(176);
++-  }
++-  wait(NULL);
++-  printf(stdout, "exitiput test ok\n");
++-}
++-
++-// does the error path in open() for attempt to write a
++-// directory call iput() in a transaction?
++-// needs a hacked kernel that pauses just after the namei()
++-// call in sys_open():
++-//    if((ip = namei(path)) == 0)
++-//      return -1;
++-//    {
++-//      int i;
++-//      for(i = 0; i < 10000; i++)
++-//        yield();
++-//    }
++-void
++-openiputtest(void)
++-{
++-  int pid;
++-
++-  printf(stdout, "openiput test\n");
++-  if(mkdir("oidir") < 0){
++-    printf(stdout, "mkdir oidir failed\n");
++-    exit(175);
++-  }
++-  pid = fork();
++-  if(pid < 0){
++-    printf(stdout, "fork failed\n");
++-    exit(174);
++-  }
++-  if(pid == 0){
++-    int fd = open("oidir", O_RDWR);
++-    if(fd >= 0){
++-      printf(stdout, "open directory for write succeeded\n");
++-      exit(0);
++-    }
++-    exit(172);
++-  }
++-  sleep(1);
++-  if(unlink("oidir") != 0){
++-    printf(stdout, "unlink failed\n");
++-    exit(171);
++-  }
++-  wait(NULL);
++-  printf(stdout, "openiput test ok\n");
++-}
++-
++-// simple file system tests
++-
++-void
++-opentest(void)
++-{
++-  int fd;
++-
++-  printf(stdout, "open test\n");
++-  fd = open("echo", 0);
++-  if(fd < 0){
++-    printf(stdout, "open echo failed!\n");
++-    exit(170);
++-  }
++-  close(fd);
++-  fd = open("doesnotexist", 0);
++-  if(fd >= 0){
++-    printf(stdout, "open doesnotexist succeeded!\n");
++-    exit(0);
++-  }
++-  printf(stdout, "open test ok\n");
++-}
++-
++-void
++-writetest(void)
++-{
++-  int fd;
++-  int i;
++-
++-  printf(stdout, "small file test\n");
++-  fd = open("small", O_CREATE|O_RDWR);
++-  if(fd >= 0){
++-    printf(stdout, "creat small succeeded; ok\n");
++-  } else {
++-    printf(stdout, "error: creat small failed!\n");
++-    exit(168);
++-  }
++-  for(i = 0; i < 100; i++){
++-    if(write(fd, "aaaaaaaaaa", 10) != 10){
++-      printf(stdout, "error: write aa %d new file failed\n", i);
++-      exit(167);
++-    }
++-    if(write(fd, "bbbbbbbbbb", 10) != 10){
++-      printf(stdout, "error: write bb %d new file failed\n", i);
++-      exit(166);
++-    }
++-  }
++-  printf(stdout, "writes ok\n");
++-  close(fd);
++-  fd = open("small", O_RDONLY);
++-  if(fd >= 0){
++-    printf(stdout, "open small succeeded ok\n");
++-  } else {
++-    printf(stdout, "error: open small failed!\n");
++-    exit(165);
++-  }
++-  i = read(fd, buf, 2000);
++-  if(i == 2000){
++-    printf(stdout, "read succeeded ok\n");
++-  } else {
++-    printf(stdout, "read failed\n");
++-    exit(164);
++-  }
++-  close(fd);
++-
++-  if(unlink("small") < 0){
++-    printf(stdout, "unlink small failed\n");
++-    exit(163);
++-  }
++-  printf(stdout, "small file test ok\n");
++-}
++-
++-void
++-writetest1(void)
++-{
++-  int i, fd, n;
++-
++-  printf(stdout, "big files test\n");
++-
++-  fd = open("big", O_CREATE|O_RDWR);
++-  if(fd < 0){
++-    printf(stdout, "error: creat big failed!\n");
++-    exit(162);
++-  }
++-
++-  for(i = 0; i < MAXFILE; i++){
++-    ((int*)buf)[0] = i;
++-    if(write(fd, buf, 512) != 512){
++-      printf(stdout, "error: write big file failed\n", i);
++-      exit(161);
++-    }
++-  }
++-
++-  close(fd);
++-
++-  fd = open("big", O_RDONLY);
++-  if(fd < 0){
++-    printf(stdout, "error: open big failed!\n");
++-    exit(160);
++-  }
++-
++-  n = 0;
++-  for(;;){
++-    i = read(fd, buf, 512);
++-    if(i == 0){
++-      if(n == MAXFILE - 1){
++-        printf(stdout, "read only %d blocks from big", n);
++-        exit(159);
++-      }
++-      break;
++-    } else if(i != 512){
++-      printf(stdout, "read failed %d\n", i);
++-      exit(158);
++-    }
++-    if(((int*)buf)[0] != n){
++-      printf(stdout, "read content of block %d is %d\n",
++-             n, ((int*)buf)[0]);
++-      exit(157);
++-    }
++-    n++;
++-  }
++-  close(fd);
++-  if(unlink("big") < 0){
++-    printf(stdout, "unlink big failed\n");
++-    exit(156);
++-  }
++-  printf(stdout, "big files ok\n");
++-}
++-
++-void
++-createtest(void)
++-{
++-  int i, fd;
++-
++-  printf(stdout, "many creates, followed by unlink test\n");
++-
++-  name[0] = 'a';
++-  name[2] = '\0';
++-  for(i = 0; i < 52; i++){
++-    name[1] = '0' + i;
++-    fd = open(name, O_CREATE|O_RDWR);
++-    close(fd);
++-  }
++-  name[0] = 'a';
++-  name[2] = '\0';
++-  for(i = 0; i < 52; i++){
++-    name[1] = '0' + i;
++-    unlink(name);
++-  }
++-  printf(stdout, "many creates, followed by unlink; ok\n");
++-}
++-
++-void dirtest(void)
++-{
++-  printf(stdout, "mkdir test\n");
++-
++-  if(mkdir("dir0") < 0){
++-    printf(stdout, "mkdir failed\n");
++-    exit(155);
++-  }
++-
++-  if(chdir("dir0") < 0){
++-    printf(stdout, "chdir dir0 failed\n");
++-    exit(154);
++-  }
++-
++-  if(chdir("..") < 0){
++-    printf(stdout, "chdir .. failed\n");
++-    exit(153);
++-  }
++-
++-  if(unlink("dir0") < 0){
++-    printf(stdout, "unlink dir0 failed\n");
++-    exit(152);
++-  }
++-  printf(stdout, "mkdir test ok\n");
++-}
++-
++-void
++-exectest(void)
++-{
++-  printf(stdout, "exec test\n");
++-  if(exec("echo", echoargv) < 0){
++-    printf(stdout, "exec echo failed\n");
++-    exit(151);
++-  }
++-}
++-
++-// simple fork and pipe read/write
++-
++-void
++-pipe1(void)
++-{
++-  int fds[2], pid;
++-  int seq, i, n, cc, total;
++-
++-  if(pipe(fds) != 0){
++-    printf(1, "pipe() failed\n");
++-    exit(150);
++-  }
++-  pid = fork();
++-  seq = 0;
++-  if(pid == 0){
++-    close(fds[0]);
++-    for(n = 0; n < 5; n++){
++-      for(i = 0; i < 1033; i++)
++-        buf[i] = seq++;
++-      if(write(fds[1], buf, 1033) != 1033){
++-        printf(1, "pipe1 oops 1\n");
++-        exit(149);
++-      }
++-    }
++-    exit(148);
++-  } else if(pid > 0){
++-    close(fds[1]);
++-    total = 0;
++-    cc = 1;
++-    while((n = read(fds[0], buf, cc)) > 0){
++-      for(i = 0; i < n; i++){
++-        if((buf[i] & 0xff) != (seq++ & 0xff)){
++-          printf(1, "pipe1 oops 2\n");
++-          return;
++-        }
++-      }
++-      total += n;
++-      cc = cc * 2;
++-      if(cc > sizeof(buf))
++-        cc = sizeof(buf);
++-    }
++-    if(total != 5 * 1033){
++-      printf(1, "pipe1 oops 3 total %d\n", total);
++-      exit(147);
++-    }
++-    close(fds[0]);
++-    wait(NULL);
++-  } else {
++-    printf(1, "fork() failed\n");
++-    exit(146);
++-  }
++-  printf(1, "pipe1 ok\n");
++-}
++-
++-// meant to be run w/ at most two CPUs
++-void
++-preempt(void)
++-{
++-  int pid1, pid2, pid3;
++-  int pfds[2];
++-
++-  printf(1, "preempt: ");
++-  pid1 = fork();
++-  if(pid1 == 0)
++-    for(;;)
++-      ;
++-
++-  pid2 = fork();
++-  if(pid2 == 0)
++-    for(;;)
++-      ;
++-
++-  pipe(pfds);
++-  pid3 = fork();
++-  if(pid3 == 0){
++-    close(pfds[0]);
++-    if(write(pfds[1], "x", 1) != 1)
++-      printf(1, "preempt write error");
++-    close(pfds[1]);
++-    for(;;)
++-      ;
++-  }
++-
++-  close(pfds[1]);
++-  if(read(pfds[0], buf, sizeof(buf)) != 1){
++-    printf(1, "preempt read error");
++-    return;
++-  }
++-  close(pfds[0]);
++-  printf(1, "kill... ");
++-  kill(pid1);
++-  kill(pid2);
++-  kill(pid3);
++-  printf(1, "wait... ");
++-  wait(NULL);
++-  wait(NULL);
++-  wait(NULL);
++-  printf(1, "preempt ok\n");
++-}
++-
++-// try to find any races between exit and wait
++-void
++-exitwait(void)
++-{
++-  int i, pid;
++-
++-  for(i = 0; i < 100; i++){
++-    pid = fork();
++-    if(pid < 0){
++-      printf(1, "fork failed\n");
++-      return;
++-    }
++-    if(pid){
++-      if(wait(NULL) != pid){
++-        printf(1, "wait wrong pid\n");
++-        return;
++-      }
++-    } else {
++-      exit(145);
++-    }
++-  }
++-  printf(1, "exitwait ok\n");
++-}
++-
++-void
++-mem(void)
++-{
++-  void *m1, *m2;
++-  int pid, ppid;
++-
++-  printf(1, "mem test\n");
++-  ppid = getpid();
++-  if((pid = fork()) == 0){
++-    m1 = 0;
++-    while((m2 = malloc(10001)) != 0){
++-      *(char**)m2 = m1;
++-      m1 = m2;
++-    }
++-    while(m1){
++-      m2 = *(char**)m1;
++-      free(m1);
++-      m1 = m2;
++-    }
++-    m1 = malloc(1024*20);
++-    if(m1 == 0){
++-      printf(1, "couldn't allocate mem?!!\n");
++-      kill(ppid);
++-      exit(144);
++-    }
++-    free(m1);
++-    printf(1, "mem ok\n");
++-    exit(0);
++-  } else {
++-    wait(NULL);
++-  }
++-}
++-
++-// More file system tests
++-
++-// two processes write to the same file descriptor
++-// is the offset shared? does inode locking work?
++-void
++-sharedfd(void)
++-{
++-  int fd, pid, i, n, nc, np;
++-  char buf[10];
++-
++-  printf(1, "sharedfd test\n");
++-
++-  unlink("sharedfd");
++-  fd = open("sharedfd", O_CREATE|O_RDWR);
++-  if(fd < 0){
++-    printf(1, "fstests: cannot open sharedfd for writing");
++-    return;
++-  }
++-  pid = fork();
++-  memset(buf, pid==0?'c':'p', sizeof(buf));
++-  for(i = 0; i < 1000; i++){
++-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
++-      printf(1, "fstests: write sharedfd failed\n");
++-      break;
++-    }
++-  }
++-  if(pid == 0)
++-    exit(142);
++-  else
++-    wait(NULL);
++-  close(fd);
++-  fd = open("sharedfd", 0);
++-  if(fd < 0){
++-    printf(1, "fstests: cannot open sharedfd for reading\n");
++-    return;
++-  }
++-  nc = np = 0;
++-  while((n = read(fd, buf, sizeof(buf))) > 0){
++-    for(i = 0; i < sizeof(buf); i++){
++-      if(buf[i] == 'c')
++-        nc++;
++-      if(buf[i] == 'p')
++-        np++;
++-    }
++-  }
++-  close(fd);
++-  unlink("sharedfd");
++-  if(nc == 10000 && np == 10000){
++-    printf(1, "sharedfd ok\n");
++-  } else {
++-    printf(1, "sharedfd oops %d %d\n", nc, np);
++-    exit(141);
++-  }
++-}
++-
++-// four processes write different files at the same
++-// time, to test block allocation.
++-void
++-fourfiles(void)
++-{
++-  int fd, pid, i, j, n, total, pi;
++-  char *names[] = { "f0", "f1", "f2", "f3" };
++-  char *fname;
++-
++-  printf(1, "fourfiles test\n");
++-
++-  for(pi = 0; pi < 4; pi++){
++-    fname = names[pi];
++-    unlink(fname);
++-
++-    pid = fork();
++-    if(pid < 0){
++-      printf(1, "fork failed\n");
++-      exit(140);
++-    }
++-
++-    if(pid == 0){
++-      fd = open(fname, O_CREATE | O_RDWR);
++-      if(fd < 0){
++-        printf(1, "create failed\n");
++-        exit(139);
++-      }
++-
++-      memset(buf, '0'+pi, 512);
++-      for(i = 0; i < 12; i++){
++-        if((n = write(fd, buf, 500)) != 500){
++-          printf(1, "write failed %d\n", n);
++-          exit(138);
++-        }
++-      }
++-      exit(137);
++-    }
++-  }
++-
++-  for(pi = 0; pi < 4; pi++){
++-    wait(NULL);
++-  }
++-
++-  for(i = 0; i < 2; i++){
++-    fname = names[i];
++-    fd = open(fname, 0);
++-    total = 0;
++-    while((n = read(fd, buf, sizeof(buf))) > 0){
++-      for(j = 0; j < n; j++){
++-        if(buf[j] != '0'+i){
++-          printf(1, "wrong char\n");
++-          exit(136);
++-        }
++-      }
++-      total += n;
++-    }
++-    close(fd);
++-    if(total != 12*500){
++-      printf(1, "wrong length %d\n", total);
++-      exit(135);
++-    }
++-    unlink(fname);
++-  }
++-
++-  printf(1, "fourfiles ok\n");
++-}
++-
++-// four processes create and delete different files in same directory
++-void
++-createdelete(void)
++-{
++-  enum { N = 20 };
++-  int pid, i, fd, pi;
++-  char name[32];
++-
++-  printf(1, "createdelete test\n");
++-
++-  for(pi = 0; pi < 4; pi++){
++-    pid = fork();
++-    if(pid < 0){
++-      printf(1, "fork failed\n");
++-      exit(134);
++-    }
++-
++-    if(pid == 0){
++-      name[0] = 'p' + pi;
++-      name[2] = '\0';
++-      for(i = 0; i < N; i++){
++-        name[1] = '0' + i;
++-        fd = open(name, O_CREATE | O_RDWR);
++-        if(fd < 0){
++-          printf(1, "create failed\n");
++-          exit(133);
++-        }
++-        close(fd);
++-        if(i > 0 && (i % 2 ) == 0){
++-          name[1] = '0' + (i / 2);
++-          if(unlink(name) < 0){
++-            printf(1, "unlink failed\n");
++-            exit(132);
++-          }
++-        }
++-      }
++-      exit(131);
++-    }
++-  }
++-
++-  for(pi = 0; pi < 4; pi++){
++-    wait(NULL);
++-  }
++-
++-  name[0] = name[1] = name[2] = 0;
++-  for(i = 0; i < N; i++){
++-    for(pi = 0; pi < 4; pi++){
++-      name[0] = 'p' + pi;
++-      name[1] = '0' + i;
++-      fd = open(name, 0);
++-      if((i == 0 || i >= N/2) && fd < 0){
++-        printf(1, "oops createdelete %s didn't exist\n", name);
++-        exit(130);
++-      } else if((i >= 1 && i < N/2) && fd >= 0){
++-        printf(1, "oops createdelete %s did exist\n", name);
++-        exit(129);
++-      }
++-      if(fd >= 0)
++-        close(fd);
++-    }
++-  }
++-
++-  for(i = 0; i < N; i++){
++-    for(pi = 0; pi < 4; pi++){
++-      name[0] = 'p' + i;
++-      name[1] = '0' + i;
++-      unlink(name);
++-    }
++-  }
++-
++-  printf(1, "createdelete ok\n");
++-}
++-
++-// can I unlink a file and still read it?
++-void
++-unlinkread(void)
++-{
++-  int fd, fd1;
++-
++-  printf(1, "unlinkread test\n");
++-  fd = open("unlinkread", O_CREATE | O_RDWR);
++-  if(fd < 0){
++-    printf(1, "create unlinkread failed\n");
++-    exit(128);
++-  }
++-  write(fd, "hello", 5);
++-  close(fd);
++-
++-  fd = open("unlinkread", O_RDWR);
++-  if(fd < 0){
++-    printf(1, "open unlinkread failed\n");
++-    exit(127);
++-  }
++-  if(unlink("unlinkread") != 0){
++-    printf(1, "unlink unlinkread failed\n");
++-    exit(126);
++-  }
++-
++-  fd1 = open("unlinkread", O_CREATE | O_RDWR);
++-  write(fd1, "yyy", 3);
++-  close(fd1);
++-
++-  if(read(fd, buf, sizeof(buf)) != 5){
++-    printf(1, "unlinkread read failed");
++-    exit(125);
++-  }
++-  if(buf[0] != 'h'){
++-    printf(1, "unlinkread wrong data\n");
++-    exit(124);
++-  }
++-  if(write(fd, buf, 10) != 10){
++-    printf(1, "unlinkread write failed\n");
++-    exit(123);
++-  }
++-  close(fd);
++-  unlink("unlinkread");
++-  printf(1, "unlinkread ok\n");
++-}
++-
++-void
++-linktest(void)
++-{
++-  int fd;
++-
++-  printf(1, "linktest\n");
++-
++-  unlink("lf1");
++-  unlink("lf2");
++-
++-  fd = open("lf1", O_CREATE|O_RDWR);
++-  if(fd < 0){
++-    printf(1, "create lf1 failed\n");
++-    exit(122);
++-  }
++-  if(write(fd, "hello", 5) != 5){
++-    printf(1, "write lf1 failed\n");
++-    exit(121);
++-  }
++-  close(fd);
++-
++-  if(link("lf1", "lf2") < 0){
++-    printf(1, "link lf1 lf2 failed\n");
++-    exit(120);
++-  }
++-  unlink("lf1");
++-
++-  if(open("lf1", 0) >= 0){
++-    printf(1, "unlinked lf1 but it is still there!\n");
++-    exit(119);
++-  }
++-
++-  fd = open("lf2", 0);
++-  if(fd < 0){
++-    printf(1, "open lf2 failed\n");
++-    exit(118);
++-  }
++-  if(read(fd, buf, sizeof(buf)) != 5){
++-    printf(1, "read lf2 failed\n");
++-    exit(117);
++-  }
++-  close(fd);
++-
++-  if(link("lf2", "lf2") >= 0){
++-    printf(1, "link lf2 lf2 succeeded! oops\n");
++-    exit(116);
++-  }
++-
++-  unlink("lf2");
++-  if(link("lf2", "lf1") >= 0){
++-    printf(1, "link non-existant succeeded! oops\n");
++-    exit(115);
++-  }
++-
++-  if(link(".", "lf1") >= 0){
++-    printf(1, "link . lf1 succeeded! oops\n");
++-    exit(114);
++-  }
++-
++-  printf(1, "linktest ok\n");
++-}
++-
++-// test concurrent create/link/unlink of the same file
++-void
++-concreate(void)
++-{
++-  char file[3];
++-  int i, pid, n, fd;
++-  char fa[40];
++-  struct {
++-    ushort inum;
++-    char name[14];
++-  } de;
++-
++-  printf(1, "concreate test\n");
++-  file[0] = 'C';
++-  file[2] = '\0';
++-  for(i = 0; i < 40; i++){
++-    file[1] = '0' + i;
++-    unlink(file);
++-    pid = fork();
++-    if(pid && (i % 3) == 1){
++-      link("C0", file);
++-    } else if(pid == 0 && (i % 5) == 1){
++-      link("C0", file);
++-    } else {
++-      fd = open(file, O_CREATE | O_RDWR);
++-      if(fd < 0){
++-        printf(1, "concreate create %s failed\n", file);
++-        exit(113);
++-      }
++-      close(fd);
++-    }
++-    if(pid == 0)
++-      exit(112);
++-    else
++-      wait(NULL);
++-  }
++-
++-  memset(fa, 0, sizeof(fa));
++-  fd = open(".", 0);
++-  n = 0;
++-  while(read(fd, &de, sizeof(de)) > 0){
++-    if(de.inum == 0)
++-      continue;
++-    if(de.name[0] == 'C' && de.name[2] == '\0'){
++-      i = de.name[1] - '0';
++-      if(i < 0 || i >= sizeof(fa)){
++-        printf(1, "concreate weird file %s\n", de.name);
++-        exit(111);
++-      }
++-      if(fa[i]){
++-        printf(1, "concreate duplicate file %s\n", de.name);
++-        exit(110);
++-      }
++-      fa[i] = 1;
++-      n++;
++-    }
++-  }
++-  close(fd);
++-
++-  if(n != 40){
++-    printf(1, "concreate not enough files in directory listing\n");
++-    exit(109);
++-  }
++-
++-  for(i = 0; i < 40; i++){
++-    file[1] = '0' + i;
++-    pid = fork();
++-    if(pid < 0){
++-      printf(1, "fork failed\n");
++-      exit(108);
++-    }
++-    if(((i % 3) == 0 && pid == 0) ||
++-       ((i % 3) == 1 && pid != 0)){
++-      close(open(file, 0));
++-      close(open(file, 0));
++-      close(open(file, 0));
++-      close(open(file, 0));
++-    } else {
++-      unlink(file);
++-      unlink(file);
++-      unlink(file);
++-      unlink(file);
++-    }
++-    if(pid == 0)
++-      exit(107);
++-    else
++-      wait(NULL);
++-  }
++-
++-  printf(1, "concreate ok\n");
++-}
++-
++-// another concurrent link/unlink/create test,
++-// to look for deadlocks.
++-void
++-linkunlink()
++-{
++-  int pid, i;
++-
++-  printf(1, "linkunlink test\n");
++-
++-  unlink("x");
++-  pid = fork();
++-  if(pid < 0){
++-    printf(1, "fork failed\n");
++-    exit(106);
++-  }
++-
++-  unsigned int x = (pid ? 1 : 97);
++-  for(i = 0; i < 100; i++){
++-    x = x * 1103515245 + 12345;
++-    if((x % 3) == 0){
++-      close(open("x", O_RDWR | O_CREATE));
++-    } else if((x % 3) == 1){
++-      link("cat", "x");
++-    } else {
++-      unlink("x");
++-    }
++-  }
++-
++-  if(pid)
++-    wait(NULL);
++-  else
++-    exit(105);
++-
++-  printf(1, "linkunlink ok\n");
++-}
++-
++-// directory that uses indirect blocks
++-void
++-bigdir(void)
++-{
++-  int i, fd;
++-  char name[10];
++-
++-  printf(1, "bigdir test\n");
++-  unlink("bd");
++-
++-  fd = open("bd", O_CREATE);
++-  if(fd < 0){
++-    printf(1, "bigdir create failed\n");
++-    exit(104);
++-  }
++-  close(fd);
++-
++-  for(i = 0; i < 500; i++){
++-    name[0] = 'x';
++-    name[1] = '0' + (i / 64);
++-    name[2] = '0' + (i % 64);
++-    name[3] = '\0';
++-    if(link("bd", name) != 0){
++-      printf(1, "bigdir link failed\n");
++-      exit(103);
++-    }
++-  }
++-
++-  unlink("bd");
++-  for(i = 0; i < 500; i++){
++-    name[0] = 'x';
++-    name[1] = '0' + (i / 64);
++-    name[2] = '0' + (i % 64);
++-    name[3] = '\0';
++-    if(unlink(name) != 0){
++-      printf(1, "bigdir unlink failed");
++-      exit(102);
++-    }
++-  }
++-
++-  printf(1, "bigdir ok\n");
++-}
++-
++-void
++-subdir(void)
++-{
++-  int fd, cc;
++-
++-  printf(1, "subdir test\n");
++-
++-  unlink("ff");
++-  if(mkdir("dd") != 0){
++-    printf(1, "subdir mkdir dd failed\n");
++-    exit(101);
++-  }
++-
++-  fd = open("dd/ff", O_CREATE | O_RDWR);
++-  if(fd < 0){
++-    printf(1, "create dd/ff failed\n");
++-    exit(100);
++-  }
++-  write(fd, "ff", 2);
++-  close(fd);
++-
++-  if(unlink("dd") >= 0){
++-    printf(1, "unlink dd (non-empty dir) succeeded!\n");
++-    exit(99);
++-  }
++-
++-  if(mkdir("/dd/dd") != 0){
++-    printf(1, "subdir mkdir dd/dd failed\n");
++-    exit(98);
++-  }
++-
++-  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
++-  if(fd < 0){
++-    printf(1, "create dd/dd/ff failed\n");
++-    exit(97);
++-  }
++-  write(fd, "FF", 2);
++-  close(fd);
++-
++-  fd = open("dd/dd/../ff", 0);
++-  if(fd < 0){
++-    printf(1, "open dd/dd/../ff failed\n");
++-    exit(96);
++-  }
++-  cc = read(fd, buf, sizeof(buf));
++-  if(cc != 2 || buf[0] != 'f'){
++-    printf(1, "dd/dd/../ff wrong content\n");
++-    exit(95);
++-  }
++-  close(fd);
++-
++-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
++-    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
++-    exit(94);
++-  }
++-
++-  if(unlink("dd/dd/ff") != 0){
++-    printf(1, "unlink dd/dd/ff failed\n");
++-    exit(93);
++-  }
++-  if(open("dd/dd/ff", O_RDONLY) >= 0){
++-    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
++-    exit(92);
++-  }
++-
++-  if(chdir("dd") != 0){
++-    printf(1, "chdir dd failed\n");
++-    exit(91);
++-  }
++-  if(chdir("dd/../../dd") != 0){
++-    printf(1, "chdir dd/../../dd failed\n");
++-    exit(90);
++-  }
++-  if(chdir("dd/../../../dd") != 0){
++-    printf(1, "chdir dd/../../dd failed\n");
++-    exit(89);
++-  }
++-  if(chdir("./..") != 0){
++-    printf(1, "chdir ./.. failed\n");
++-    exit(88);
++-  }
++-
++-  fd = open("dd/dd/ffff", 0);
++-  if(fd < 0){
++-    printf(1, "open dd/dd/ffff failed\n");
++-    exit(87);
++-  }
++-  if(read(fd, buf, sizeof(buf)) != 2){
++-    printf(1, "read dd/dd/ffff wrong len\n");
++-    exit(86);
++-  }
++-  close(fd);
++-
++-  if(open("dd/dd/ff", O_RDONLY) >= 0){
++-    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
++-    exit(0);
++-  }
++-
++-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
++-    printf(1, "create dd/ff/ff succeeded!\n");
++-    exit(0);
++-  }
++-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
++-    printf(1, "create dd/xx/ff succeeded!\n");
++-    exit(0);
++-  }
++-  if(open("dd", O_CREATE) >= 0){
++-    printf(1, "create dd succeeded!\n");
++-    exit(0);
++-  }
++-  if(open("dd", O_RDWR) >= 0){
++-    printf(1, "open dd rdwr succeeded!\n");
++-    exit(0);
++-  }
++-  if(open("dd", O_WRONLY) >= 0){
++-    printf(1, "open dd wronly succeeded!\n");
++-    exit(0);
++-  }
++-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
++-    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
++-    exit(0);
++-  }
++-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
++-    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
++-    exit(0);
++-  }
++-  if(link("dd/ff", "dd/dd/ffff") == 0){
++-    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
++-    exit(0);
++-  }
++-  if(mkdir("dd/ff/ff") == 0){
++-    printf(1, "mkdir dd/ff/ff succeeded!\n");
++-    exit(0);
++-  }
++-  if(mkdir("dd/xx/ff") == 0){
++-    printf(1, "mkdir dd/xx/ff succeeded!\n");
++-    exit(0);
++-  }
++-  if(mkdir("dd/dd/ffff") == 0){
++-    printf(1, "mkdir dd/dd/ffff succeeded!\n");
++-    exit(0);
++-  }
++-  if(unlink("dd/xx/ff") == 0){
++-    printf(1, "unlink dd/xx/ff succeeded!\n");
++-    exit(0);
++-  }
++-  if(unlink("dd/ff/ff") == 0){
++-    printf(1, "unlink dd/ff/ff succeeded!\n");
++-    exit(0);
++-  }
++-  if(chdir("dd/ff") == 0){
++-    printf(1, "chdir dd/ff succeeded!\n");
++-    exit(0);
++-  }
++-  if(chdir("dd/xx") == 0){
++-    printf(1, "chdir dd/xx succeeded!\n");
++-    exit(0);
++-  }
++-
++-  if(unlink("dd/dd/ffff") != 0){
++-    printf(1, "unlink dd/dd/ff failed\n");
++-    exit(68);
++-  }
++-  if(unlink("dd/ff") != 0){
++-    printf(1, "unlink dd/ff failed\n");
++-    exit(67);
++-  }
++-  if(unlink("dd") == 0){
++-    printf(1, "unlink non-empty dd succeeded!\n");
++-    exit(0);
++-  }
++-  if(unlink("dd/dd") < 0){
++-    printf(1, "unlink dd/dd failed\n");
++-    exit(65);
++-  }
++-  if(unlink("dd") < 0){
++-    printf(1, "unlink dd failed\n");
++-    exit(64);
++-  }
++-
++-  printf(1, "subdir ok\n");
++-}
++-
++-// test writes that are larger than the log.
++-void
++-bigwrite(void)
++-{
++-  int fd, sz;
++-
++-  printf(1, "bigwrite test\n");
++-
++-  unlink("bigwrite");
++-  for(sz = 499; sz < 12*512; sz += 471){
++-    fd = open("bigwrite", O_CREATE | O_RDWR);
++-    if(fd < 0){
++-      printf(1, "cannot create bigwrite\n");
++-      exit(63);
++-    }
++-    int i;
++-    for(i = 0; i < 2; i++){
++-      int cc = write(fd, buf, sz);
++-      if(cc != sz){
++-        printf(1, "write(%d) ret %d\n", sz, cc);
++-        exit(62);
++-      }
++-    }
++-    close(fd);
++-    unlink("bigwrite");
++-  }
++-
++-  printf(1, "bigwrite ok\n");
++-}
++-
++-void
++-bigfile(void)
++-{
++-  int fd, i, total, cc;
++-
++-  printf(1, "bigfile test\n");
++-
++-  unlink("bigfile");
++-  fd = open("bigfile", O_CREATE | O_RDWR);
++-  if(fd < 0){
++-    printf(1, "cannot create bigfile");
++-    exit(61);
++-  }
++-  for(i = 0; i < 20; i++){
++-    memset(buf, i, 600);
++-    if(write(fd, buf, 600) != 600){
++-      printf(1, "write bigfile failed\n");
++-      exit(60);
++-    }
++-  }
++-  close(fd);
++-
++-  fd = open("bigfile", 0);
++-  if(fd < 0){
++-    printf(1, "cannot open bigfile\n");
++-    exit(59);
++-  }
++-  total = 0;
++-  for(i = 0; ; i++){
++-    cc = read(fd, buf, 300);
++-    if(cc < 0){
++-      printf(1, "read bigfile failed\n");
++-      exit(58);
++-    }
++-    if(cc == 0)
++-      break;
++-    if(cc != 300){
++-      printf(1, "short read bigfile\n");
++-      exit(57);
++-    }
++-    if(buf[0] != i/2 || buf[299] != i/2){
++-      printf(1, "read bigfile wrong data\n");
++-      exit(56);
++-    }
++-    total += cc;
++-  }
++-  close(fd);
++-  if(total != 20*600){
++-    printf(1, "read bigfile wrong total\n");
++-    exit(55);
++-  }
++-  unlink("bigfile");
++-
++-  printf(1, "bigfile test ok\n");
++-}
++-
++-void
++-fourteen(void)
++-{
++-  int fd;
++-
++-  // DIRSIZ is 14.
++-  printf(1, "fourteen test\n");
++-
++-  if(mkdir("12345678901234") != 0){
++-    printf(1, "mkdir 12345678901234 failed\n");
++-    exit(54);
++-  }
++-  if(mkdir("12345678901234/123456789012345") != 0){
++-    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
++-    exit(53);
++-  }
++-  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
++-  if(fd < 0){
++-    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
++-    exit(52);
++-  }
++-  close(fd);
++-  fd = open("12345678901234/12345678901234/12345678901234", 0);
++-  if(fd < 0){
++-    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
++-    exit(51);
++-  }
++-  close(fd);
++-
++-  if(mkdir("12345678901234/12345678901234") == 0){
++-    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
++-    exit(0);
++-  }
++-  if(mkdir("123456789012345/12345678901234") == 0){
++-    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
++-    exit(0);
++-  }
++-
++-  printf(1, "fourteen ok\n");
++-}
++-
++-void
++-rmdot(void)
++-{
++-  printf(1, "rmdot test\n");
++-  if(mkdir("dots") != 0){
++-    printf(1, "mkdir dots failed\n");
++-    exit(48);
++-  }
++-  if(chdir("dots") != 0){
++-    printf(1, "chdir dots failed\n");
++-    exit(47);
++-  }
++-  if(unlink(".") == 0){
++-    printf(1, "rm . worked!\n");
++-    exit(0);
++-  }
++-  if(unlink("..") == 0){
++-    printf(1, "rm .. worked!\n");
++-    exit(0);
++-  }
++-  if(chdir("/") != 0){
++-    printf(1, "chdir / failed\n");
++-    exit(44);
++-  }
++-  if(unlink("dots/.") == 0){
++-    printf(1, "unlink dots/. worked!\n");
++-    exit(0);
++-  }
++-  if(unlink("dots/..") == 0){
++-    printf(1, "unlink dots/.. worked!\n");
++-    exit(0);
++-  }
++-  if(unlink("dots") != 0){
++-    printf(1, "unlink dots failed!\n");
++-    exit(41);
++-  }
++-  printf(1, "rmdot ok\n");
++-}
++-
++-void
++-dirfile(void)
++-{
++-  int fd;
++-
++-  printf(1, "dir vs file\n");
++-
++-  fd = open("dirfile", O_CREATE);
++-  if(fd < 0){
++-    printf(1, "create dirfile failed\n");
++-    exit(40);
++-  }
++-  close(fd);
++-  if(chdir("dirfile") == 0){
++-    printf(1, "chdir dirfile succeeded!\n");
++-    exit(0);
++-  }
++-  fd = open("dirfile/xx", 0);
++-  if(fd >= 0){
++-    printf(1, "create dirfile/xx succeeded!\n");
++-    exit(0);
++-  }
++-  fd = open("dirfile/xx", O_CREATE);
++-  if(fd >= 0){
++-    printf(1, "create dirfile/xx succeeded!\n");
++-    exit(0);
++-  }
++-  if(mkdir("dirfile/xx") == 0){
++-    printf(1, "mkdir dirfile/xx succeeded!\n");
++-    exit(0);
++-  }
++-  if(unlink("dirfile/xx") == 0){
++-    printf(1, "unlink dirfile/xx succeeded!\n");
++-    exit(0);
++-  }
++-  if(link("README", "dirfile/xx") == 0){
++-    printf(1, "link to dirfile/xx succeeded!\n");
++-    exit(0);
++-  }
++-  if(unlink("dirfile") != 0){
++-    printf(1, "unlink dirfile failed!\n");
++-    exit(33);
++-  }
++-
++-  fd = open(".", O_RDWR);
++-  if(fd >= 0){
++-    printf(1, "open . for writing succeeded!\n");
++-    exit(0);
++-  }
++-  fd = open(".", 0);
++-  if(write(fd, "x", 1) > 0){
++-    printf(1, "write . succeeded!\n");
++-    exit(0);
++-  }
++-  close(fd);
++-
++-  printf(1, "dir vs file OK\n");
++-}
++-
++-// test that iput() is called at the end of _namei()
++-void
++-iref(void)
++-{
++-  int i, fd;
++-
++-  printf(1, "empty file name\n");
++-
++-  // the 50 is NINODE
++-  for(i = 0; i < 50 + 1; i++){
++-    if(mkdir("irefd") != 0){
++-      printf(1, "mkdir irefd failed\n");
++-      exit(30);
++-    }
++-    if(chdir("irefd") != 0){
++-      printf(1, "chdir irefd failed\n");
++-      exit(29);
++-    }
++-
++-    mkdir("");
++-    link("README", "");
++-    fd = open("", O_CREATE);
++-    if(fd >= 0)
++-      close(fd);
++-    fd = open("xx", O_CREATE);
++-    if(fd >= 0)
++-      close(fd);
++-    unlink("xx");
++-  }
++-
++-  chdir("/");
++-  printf(1, "empty file name OK\n");
++-}
++-
++-// test that fork fails gracefully
++-// the forktest binary also does this, but it runs out of proc entries first.
++-// inside the bigger usertests binary, we run out of memory first.
++-void
++-forktest(void)
++-{
++-  int n, pid;
++-
++-  printf(1, "fork test\n");
++-
++-  for(n=0; n<1000; n++){
++-    pid = fork();
++-    if(pid < 0)
++-      break;
++-    if(pid == 0)
++-      exit(28);
++-  }
++-
++-  if(n == 1000){
++-    printf(1, "fork claimed to work 1000 times!\n");
++-    exit(27);
++-  }
++-
++-  for(; n > 0; n--){
++-    if(wait(NULL) < 0){
++-      printf(1, "wait stopped early\n");
++-      exit(26);
++-    }
++-  }
++-
++-  if(wait(NULL) != -1){
++-    printf(1, "wait got too many\n");
++-    exit(25);
++-  }
++-
++-  printf(1, "fork test OK\n");
++-}
++-
++-void
++-sbrktest(void)
++-{
++-  int fds[2], pid, pids[10], ppid;
++-  char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
++-  uint amt;
++-
++-  printf(stdout, "sbrk test\n");
++-  oldbrk = sbrk(0);
++-
++-  // can one sbrk() less than a page?
++-  a = sbrk(0);
++-  int i;
++-  for(i = 0; i < 5000; i++){
++-    b = sbrk(1);
++-    if(b != a){
++-      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
++-      exit(24);
++-    }
++-    *b = 1;
++-    a = b + 1;
++-  }
++-  pid = fork();
++-  if(pid < 0){
++-    printf(stdout, "sbrk test fork failed\n");
++-    exit(23);
++-  }
++-  c = sbrk(1);
++-  c = sbrk(1);
++-  if(c != a + 1){
++-    printf(stdout, "sbrk test failed post-fork\n");
++-    exit(22);
++-  }
++-  if(pid == 0)
++-    exit(21);
++-  wait(NULL);
++-
++-  // can one grow address space to something big?
++-#define BIG (100*1024*1024)
++-  a = sbrk(0);
++-  amt = (BIG) - (uint)a;
++-  p = sbrk(amt);
++-  if (p != a) {
++-    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
++-    exit(20);
++-  }
++-  lastaddr = (char*) (BIG-1);
++-  *lastaddr = 99;
++-
++-  // can one de-allocate?
++-  a = sbrk(0);
++-  c = sbrk(-4096);
++-  if(c == (char*)0xffffffff){
++-    printf(stdout, "sbrk could not deallocate\n");
++-    exit(19);
++-  }
++-  c = sbrk(0);
++-  if(c != a - 4096){
++-    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
++-    exit(18);
++-  }
++-
++-  // can one re-allocate that page?
++-  a = sbrk(0);
++-  c = sbrk(4096);
++-  if(c != a || sbrk(0) != a + 4096){
++-    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
++-    exit(17);
++-  }
++-  if(*lastaddr == 99){
++-    // should be zero
++-    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
++-    exit(16);
++-  }
++-
++-  a = sbrk(0);
++-  c = sbrk(-(sbrk(0) - oldbrk));
++-  if(c != a){
++-    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
++-    exit(15);
++-  }
++-
++-  // can we read the kernel's memory?
++-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
++-    ppid = getpid();
++-    pid = fork();
++-    if(pid < 0){
++-      printf(stdout, "fork failed\n");
++-      exit(14);
++-    }
++-    if(pid == 0){
++-      printf(stdout, "oops could read %x = %x\n", a, *a);
++-      kill(ppid);
++-      exit(13);
++-    }
++-    wait(NULL);
++-  }
++-
++-  // if we run the system out of memory, does it clean up the last
++-  // failed allocation?
++-  if(pipe(fds) != 0){
++-    printf(1, "pipe() failed\n");
++-    exit(12);
++-  }
++-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
++-    if((pids[i] = fork()) == 0){
++-      // allocate a lot of memory
++-      sbrk(BIG - (uint)sbrk(0));
++-      write(fds[1], "x", 1);
++-      // sit around until killed
++-      for(;;) sleep(1000);
++-    }
++-    if(pids[i] != -1)
++-      read(fds[0], &scratch, 1);
++-  }
++-  // if those failed allocations freed up the pages they did allocate,
++-  // we'll be able to allocate here
++-  c = sbrk(4096);
++-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
++-    if(pids[i] == -1)
++-      continue;
++-    kill(pids[i]);
++-    wait(NULL);
++-  }
++-  if(c == (char*)0xffffffff){
++-    printf(stdout, "failed sbrk leaked memory\n");
++-    exit(10);
++-  }
++-
++-  if(sbrk(0) > oldbrk)
++-    sbrk(-(sbrk(0) - oldbrk));
++-
++-  printf(stdout, "sbrk test OK\n");
++-}
++-
++-void
++-validateint(int *p)
++-{
++-  int res;
++-  asm("mov %%esp, %%ebx\n\t"
++-      "mov %3, %%esp\n\t"
++-      "int %2\n\t"
++-      "mov %%ebx, %%esp" :
++-      "=a" (res) :
++-      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
++-      "ebx");
++-}
++-
++-void
++-validatetest(void)
++-{
++-  int hi, pid;
++-  uint p;
++-
++-  printf(stdout, "validate test\n");
++-  hi = 1100*1024;
++-
++-  for(p = 0; p <= (uint)hi; p += 4096){
++-    if((pid = fork()) == 0){
++-      // try to crash the kernel by passing in a badly placed integer
++-      validateint((int*)p);
++-      exit(9);
++-    }
++-    sleep(0);
++-    sleep(0);
++-    kill(pid);
++-    wait(NULL);
++-
++-    // try to crash the kernel by passing in a bad string pointer
++-    if(link("nosuchfile", (char*)p) != -1){
++-      printf(stdout, "link should not succeed\n");
++-      exit(8);
++-    }
++-  }
++-
++-  printf(stdout, "validate ok\n");
++-}
++-
++-// does unintialized data start out zero?
++-char uninit[10000];
++-void
++-bsstest(void)
++-{
++-  int i;
++-
++-  printf(stdout, "bss test\n");
++-  for(i = 0; i < sizeof(uninit); i++){
++-    if(uninit[i] != '\0'){
++-      printf(stdout, "bss test failed\n");
++-      exit(7);
++-    }
++-  }
++-  printf(stdout, "bss test ok\n");
++-}
++-
++-// does exec return an error if the arguments
++-// are larger than a page? or does it write
++-// below the stack and wreck the instructions/data?
++-void
++-bigargtest(void)
++-{
++-  int pid, fd;
++-
++-  unlink("bigarg-ok");
++-  pid = fork();
++-  if(pid == 0){
++-    static char *args[MAXARG];
++-    int i;
++-    for(i = 0; i < MAXARG-1; i++)
++-      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
++-    args[MAXARG-1] = 0;
++-    printf(stdout, "bigarg test\n");
++-    exec("echo", args);
++-    printf(stdout, "bigarg test ok\n");
++-    fd = open("bigarg-ok", O_CREATE);
++-    close(fd);
++-    exit(6);
++-  } else if(pid < 0){
++-    printf(stdout, "bigargtest: fork failed\n");
++-    exit(5);
++-  }
++-  wait(NULL);
++-  fd = open("bigarg-ok", 0);
++-  if(fd < 0){
++-    printf(stdout, "bigarg test failed!\n");
++-    exit(4);
++-  }
++-  close(fd);
++-  unlink("bigarg-ok");
++-}
++-
++-// what happens when the file system runs out of blocks?
++-// answer: balloc panics, so this test is not useful.
++-void
++-fsfull()
++-{
++-  int nfiles;
++-  int fsblocks = 0;
++-
++-  printf(1, "fsfull test\n");
++-
++-  for(nfiles = 0; ; nfiles++){
++-    char name[64];
++-    name[0] = 'f';
++-    name[1] = '0' + nfiles / 1000;
++-    name[2] = '0' + (nfiles % 1000) / 100;
++-    name[3] = '0' + (nfiles % 100) / 10;
++-    name[4] = '0' + (nfiles % 10);
++-    name[5] = '\0';
++-    printf(1, "writing %s\n", name);
++-    int fd = open(name, O_CREATE|O_RDWR);
++-    if(fd < 0){
++-      printf(1, "open %s failed\n", name);
++-      break;
++-    }
++-    int total = 0;
++-    while(1){
++-      int cc = write(fd, buf, 512);
++-      if(cc < 512)
++-        break;
++-      total += cc;
++-      fsblocks++;
++-    }
++-    printf(1, "wrote %d bytes\n", total);
++-    close(fd);
++-    if(total == 0)
++-      break;
++-  }
++-
++-  while(nfiles >= 0){
++-    char name[64];
++-    name[0] = 'f';
++-    name[1] = '0' + nfiles / 1000;
++-    name[2] = '0' + (nfiles % 1000) / 100;
++-    name[3] = '0' + (nfiles % 100) / 10;
++-    name[4] = '0' + (nfiles % 10);
++-    name[5] = '\0';
++-    unlink(name);
++-    nfiles--;
++-  }
++-
++-  printf(1, "fsfull test finished\n");
++-}
++-
++-void
++-uio()
++-{
++-  #define RTC_ADDR 0x70
++-  #define RTC_DATA 0x71
++-
++-  ushort port = 0;
++-  uchar val = 0;
++-  int pid;
++-
++-  printf(1, "uio test\n");
++-  pid = fork();
++-  if(pid == 0){
++-    port = RTC_ADDR;
++-    val = 0x09;  /* year */
++-    /* http://wiki.osdev.org/Inline_Assembly/Examples */
++-    asm volatile("outb %0,%1"::"a"(val), "d" (port));
++-    port = RTC_DATA;
++-    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
++-    printf(1, "uio: uio succeeded; test FAILED\n");
++-    exit(3);
++-  } else if(pid < 0){
++-    printf (1, "fork failed\n");
++-    exit(2);
++-  }
++-  wait(NULL);
++-  printf(1, "uio test done\n");
++-}
++-
++-void argptest()
++-{
++-  int fd;
++-  fd = open("init", O_RDONLY);
++-  if (fd < 0) {
++-    printf(2, "open failed\n");
++-    exit(1);
++-  }
++-  read(fd, sbrk(0) - 1, -1);
++-  close(fd);
++-  printf(1, "arg test passed\n");
++-}
++-
++-unsigned long randstate = 1;
++-unsigned int
++-rand()
++-{
++-  randstate = randstate * 1664525 + 1013904223;
++-  return randstate;
++-}
++-
++-int
++-main(int argc, char *argv[])
++-{
++-  printf(1, "usertests starting\n");
++-
++-  if(open("usertests.ran", 0) >= 0){
++-    printf(1, "already ran user tests -- rebuild fs.img\n");
++-    exit(1);
++-  }
++-  close(open("usertests.ran", O_CREATE));
++-
++-  argptest();
++-  createdelete();
++-  linkunlink();
++-  concreate();
++-  fourfiles();
++-  sharedfd();
++-
++-  bigargtest();
++-  bigwrite();
++-  bigargtest();
++-  bsstest();
++-  sbrktest();
++-  validatetest();
++-
++-  opentest();
++-  writetest();
++-  writetest1();
++-  createtest();
++-
++-  openiputtest();
++-  exitiputtest();
++-  iputtest();
++-
++-  mem();
++-  pipe1();
++-  preempt();
++-  exitwait();
++-
++-  rmdot();
++-  fourteen();
++-  bigfile();
++-  subdir();
++-  linktest();
++-  unlinkread();
++-  dirfile();
++-  iref();
++-  forktest();
++-  bigdir(); // slow
++-
++-  uio();
++-
++-  exectest();
++-
++-  exit(0);
++-}
+ diff --git a/usys.S b/usys.S
+-index 8bfd8a1..1687ed0 100644
++deleted file mode 100644
++index 1687ed0..0000000
+ --- a/usys.S
+-+++ b/usys.S
+-@@ -11,6 +11,7 @@
+- SYSCALL(fork)
+- SYSCALL(exit)
+- SYSCALL(wait)
+-+SYSCALL(waitpid)
+- SYSCALL(pipe)
+- SYSCALL(read)
+- SYSCALL(write)
+++++ /dev/null
++@@ -1,32 +0,0 @@
++-#include "syscall.h"
++-#include "traps.h"
++-
++-#define SYSCALL(name) \
++-  .globl name; \
++-  name: \
++-    movl $SYS_ ## name, %eax; \
++-    int $T_SYSCALL; \
++-    ret
++-
++-SYSCALL(fork)
++-SYSCALL(exit)
++-SYSCALL(wait)
++-SYSCALL(waitpid)
++-SYSCALL(pipe)
++-SYSCALL(read)
++-SYSCALL(write)
++-SYSCALL(close)
++-SYSCALL(kill)
++-SYSCALL(exec)
++-SYSCALL(open)
++-SYSCALL(mknod)
++-SYSCALL(unlink)
++-SYSCALL(fstat)
++-SYSCALL(link)
++-SYSCALL(mkdir)
++-SYSCALL(chdir)
++-SYSCALL(dup)
++-SYSCALL(getpid)
++-SYSCALL(sbrk)
++-SYSCALL(sleep)
++-SYSCALL(uptime)
+ diff --git a/vectors.pl b/vectors.pl
+-old mode 100755
+-new mode 100644
++deleted file mode 100644
++index 57b49dd..0000000
++--- a/vectors.pl
+++++ /dev/null
++@@ -1,47 +0,0 @@
++-#!/usr/bin/perl -w
++-
++-# Generate vectors.S, the trap/interrupt entry points.
++-# There has to be one entry point per interrupt number
++-# since otherwise there's no way for trap() to discover
++-# the interrupt number.
++-
++-print "# generated by vectors.pl - do not edit\n";
++-print "# handlers\n";
++-print ".globl alltraps\n";
++-for(my $i = 0; $i < 256; $i++){
++-    print ".globl vector$i\n";
++-    print "vector$i:\n";
++-    if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
++-        print "  pushl \$0\n";
++-    }
++-    print "  pushl \$$i\n";
++-    print "  jmp alltraps\n";
++-}
++-
++-print "\n# vector table\n";
++-print ".data\n";
++-print ".globl vectors\n";
++-print "vectors:\n";
++-for(my $i = 0; $i < 256; $i++){
++-    print "  .long vector$i\n";
++-}
++-
++-# sample output:
++-#   # handlers
++-#   .globl alltraps
++-#   .globl vector0
++-#   vector0:
++-#     pushl $0
++-#     pushl $0
++-#     jmp alltraps
++-#   ...
++-#   
++-#   # vector table
++-#   .data
++-#   .globl vectors
++-#   vectors:
++-#     .long vector0
++-#     .long vector1
++-#     .long vector2
++-#   ...
++-
++diff --git a/vm.c b/vm.c
++deleted file mode 100644
++index 7134cff..0000000
++--- a/vm.c
+++++ /dev/null
++@@ -1,394 +0,0 @@
++-#include "param.h"
++-#include "types.h"
++-#include "defs.h"
++-#include "x86.h"
++-#include "memlayout.h"
++-#include "mmu.h"
++-#include "proc.h"
++-#include "elf.h"
++-
++-extern char data[];  // defined by kernel.ld
++-pde_t *kpgdir;  // for use in scheduler()
++-
++-// Set up CPU's kernel segment descriptors.
++-// Run once on entry on each CPU.
++-void
++-seginit(void)
++-{
++-  struct cpu *c;
++-
++-  // Map "logical" addresses to virtual addresses using identity map.
++-  // Cannot share a CODE descriptor for both kernel and user
++-  // because it would have to have DPL_USR, but the CPU forbids
++-  // an interrupt from CPL=0 to DPL=3.
++-  c = &cpus[cpuid()];
++-  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
++-  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
++-  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
++-  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
++-  lgdt(c->gdt, sizeof(c->gdt));
++-}
++-
++-// Return the address of the PTE in page table pgdir
++-// that corresponds to virtual address va.  If alloc!=0,
++-// create any required page table pages.
++-static pte_t *
++-walkpgdir(pde_t *pgdir, const void *va, int alloc)
++-{
++-  pde_t *pde;
++-  pte_t *pgtab;
++-
++-  pde = &pgdir[PDX(va)];
++-  if(*pde & PTE_P){
++-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
++-  } else {
++-    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
++-      return 0;
++-    // Make sure all those PTE_P bits are zero.
++-    memset(pgtab, 0, PGSIZE);
++-    // The permissions here are overly generous, but they can
++-    // be further restricted by the permissions in the page table
++-    // entries, if necessary.
++-    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
++-  }
++-  return &pgtab[PTX(va)];
++-}
++-
++-// Create PTEs for virtual addresses starting at va that refer to
++-// physical addresses starting at pa. va and size might not
++-// be page-aligned.
++-static int
++-mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
++-{
++-  char *a, *last;
++-  pte_t *pte;
++-
++-  a = (char*)PGROUNDDOWN((uint)va);
++-  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
++-  for(;;){
++-    if((pte = walkpgdir(pgdir, a, 1)) == 0)
++-      return -1;
++-    if(*pte & PTE_P)
++-      panic("remap");
++-    *pte = pa | perm | PTE_P;
++-    if(a == last)
++-      break;
++-    a += PGSIZE;
++-    pa += PGSIZE;
++-  }
++-  return 0;
++-}
++-
++-// There is one page table per process, plus one that's used when
++-// a CPU is not running any process (kpgdir). The kernel uses the
++-// current process's page table during system calls and interrupts;
++-// page protection bits prevent user code from using the kernel's
++-// mappings.
++-//
++-// setupkvm() and exec() set up every page table like this:
++-//
++-//   0..KERNBASE: user memory (text+data+stack+heap), mapped to
++-//                phys memory allocated by the kernel
++-//   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)
++-//   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)
++-//                for the kernel's instructions and r/o data
++-//   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,
++-//                                  rw data + free physical memory
++-//   0xfe000000..0: mapped direct (devices such as ioapic)
++-//
++-// The kernel allocates physical memory for its heap and for user memory
++-// between V2P(end) and the end of physical memory (PHYSTOP)
++-// (directly addressable from end..P2V(PHYSTOP)).
++-
++-// This table defines the kernel's mappings, which are present in
++-// every process's page table.
++-static struct kmap {
++-  void *virt;
++-  uint phys_start;
++-  uint phys_end;
++-  int perm;
++-} kmap[] = {
++- { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
++- { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
++- { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
++- { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
++-};
++-
++-// Set up kernel part of a page table.
++-pde_t*
++-setupkvm(void)
++-{
++-  pde_t *pgdir;
++-  struct kmap *k;
++-
++-  if((pgdir = (pde_t*)kalloc()) == 0)
++-    return 0;
++-  memset(pgdir, 0, PGSIZE);
++-  if (P2V(PHYSTOP) > (void*)DEVSPACE)
++-    panic("PHYSTOP too high");
++-  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
++-    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
++-                (uint)k->phys_start, k->perm) < 0) {
++-      freevm(pgdir);
++-      return 0;
++-    }
++-  return pgdir;
++-}
++-
++-// Allocate one page table for the machine for the kernel address
++-// space for scheduler processes.
++-void
++-kvmalloc(void)
++-{
++-  kpgdir = setupkvm();
++-  switchkvm();
++-}
++-
++-// Switch h/w page table register to the kernel-only page table,
++-// for when no process is running.
++-void
++-switchkvm(void)
++-{
++-  lcr3(V2P(kpgdir));   // switch to the kernel page table
++-}
++-
++-// Switch TSS and h/w page table to correspond to process p.
++-void
++-switchuvm(struct proc *p)
++-{
++-  if(p == 0)
++-    panic("switchuvm: no process");
++-  if(p->kstack == 0)
++-    panic("switchuvm: no kstack");
++-  if(p->pgdir == 0)
++-    panic("switchuvm: no pgdir");
++-
++-  pushcli();
++-  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
++-                                sizeof(mycpu()->ts)-1, 0);
++-  mycpu()->gdt[SEG_TSS].s = 0;
++-  mycpu()->ts.ss0 = SEG_KDATA << 3;
++-  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
++-  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
++-  // forbids I/O instructions (e.g., inb and outb) from user space
++-  mycpu()->ts.iomb = (ushort) 0xFFFF;
++-  ltr(SEG_TSS << 3);
++-  lcr3(V2P(p->pgdir));  // switch to process's address space
++-  popcli();
++-}
++-
++-// Load the initcode into address 0 of pgdir.
++-// sz must be less than a page.
++-void
++-inituvm(pde_t *pgdir, char *init, uint sz)
++-{
++-  char *mem;
++-
++-  if(sz >= PGSIZE)
++-    panic("inituvm: more than a page");
++-  mem = kalloc();
++-  memset(mem, 0, PGSIZE);
++-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
++-  memmove(mem, init, sz);
++-}
++-
++-// Load a program segment into pgdir.  addr must be page-aligned
++-// and the pages from addr to addr+sz must already be mapped.
++-int
++-loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
++-{
++-  uint i, pa, n;
++-  pte_t *pte;
++-
++-  if((uint) addr % PGSIZE != 0)
++-    panic("loaduvm: addr must be page aligned");
++-  for(i = 0; i < sz; i += PGSIZE){
++-    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
++-      panic("loaduvm: address should exist");
++-    pa = PTE_ADDR(*pte);
++-    if(sz - i < PGSIZE)
++-      n = sz - i;
++-    else
++-      n = PGSIZE;
++-    if(readi(ip, P2V(pa), offset+i, n) != n)
++-      return -1;
++-  }
++-  return 0;
++-}
++-
++-// Allocate page tables and physical memory to grow process from oldsz to
++-// newsz, which need not be page aligned.  Returns new size or 0 on error.
++-int
++-allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
++-{
++-  char *mem;
++-  uint a;
++-
++-  if(newsz >= KERNBASE)
++-    return 0;
++-  if(newsz < oldsz)
++-    return oldsz;
++-
++-  a = PGROUNDUP(oldsz);
++-  for(; a < newsz; a += PGSIZE){
++-    mem = kalloc();
++-    if(mem == 0){
++-      cprintf("allocuvm out of memory\n");
++-      deallocuvm(pgdir, newsz, oldsz);
++-      return 0;
++-    }
++-    memset(mem, 0, PGSIZE);
++-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
++-      cprintf("allocuvm out of memory (2)\n");
++-      deallocuvm(pgdir, newsz, oldsz);
++-      kfree(mem);
++-      return 0;
++-    }
++-  }
++-  return newsz;
++-}
++-
++-// Deallocate user pages to bring the process size from oldsz to
++-// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
++-// need to be less than oldsz.  oldsz can be larger than the actual
++-// process size.  Returns the new process size.
++-int
++-deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
++-{
++-  pte_t *pte;
++-  uint a, pa;
++-
++-  if(newsz >= oldsz)
++-    return oldsz;
++-
++-  a = PGROUNDUP(newsz);
++-  for(; a  < oldsz; a += PGSIZE){
++-    pte = walkpgdir(pgdir, (char*)a, 0);
++-    if(!pte)
++-      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
++-    else if((*pte & PTE_P) != 0){
++-      pa = PTE_ADDR(*pte);
++-      if(pa == 0)
++-        panic("kfree");
++-      char *v = P2V(pa);
++-      kfree(v);
++-      *pte = 0;
++-    }
++-  }
++-  return newsz;
++-}
++-
++-// Free a page table and all the physical memory pages
++-// in the user part.
++-void
++-freevm(pde_t *pgdir)
++-{
++-  uint i;
++-
++-  if(pgdir == 0)
++-    panic("freevm: no pgdir");
++-  deallocuvm(pgdir, KERNBASE, 0);
++-  for(i = 0; i < NPDENTRIES; i++){
++-    if(pgdir[i] & PTE_P){
++-      char * v = P2V(PTE_ADDR(pgdir[i]));
++-      kfree(v);
++-    }
++-  }
++-  kfree((char*)pgdir);
++-}
++-
++-// Clear PTE_U on a page. Used to create an inaccessible
++-// page beneath the user stack.
++-void
++-clearpteu(pde_t *pgdir, char *uva)
++-{
++-  pte_t *pte;
++-
++-  pte = walkpgdir(pgdir, uva, 0);
++-  if(pte == 0)
++-    panic("clearpteu");
++-  *pte &= ~PTE_U;
++-}
++-
++-// Given a parent process's page table, create a copy
++-// of it for a child.
++-pde_t*
++-copyuvm(pde_t *pgdir, uint sz)
++-{
++-  pde_t *d;
++-  pte_t *pte;
++-  uint pa, i, flags;
++-  char *mem;
++-
++-  if((d = setupkvm()) == 0)
++-    return 0;
++-  for(i = 0; i < sz; i += PGSIZE){
++-    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
++-      panic("copyuvm: pte should exist");
++-    if(!(*pte & PTE_P))
++-      panic("copyuvm: page not present");
++-    pa = PTE_ADDR(*pte);
++-    flags = PTE_FLAGS(*pte);
++-    if((mem = kalloc()) == 0)
++-      goto bad;
++-    memmove(mem, (char*)P2V(pa), PGSIZE);
++-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
++-      kfree(mem);
++-      goto bad;
++-    }
++-  }
++-  return d;
++-
++-bad:
++-  freevm(d);
++-  return 0;
++-}
++-
++-//PAGEBREAK!
++-// Map user virtual address to kernel address.
++-char*
++-uva2ka(pde_t *pgdir, char *uva)
++-{
++-  pte_t *pte;
++-
++-  pte = walkpgdir(pgdir, uva, 0);
++-  if((*pte & PTE_P) == 0)
++-    return 0;
++-  if((*pte & PTE_U) == 0)
++-    return 0;
++-  return (char*)P2V(PTE_ADDR(*pte));
++-}
++-
++-// Copy len bytes from p to user address va in page table pgdir.
++-// Most useful when pgdir is not the current page table.
++-// uva2ka ensures this only works for PTE_U pages.
++-int
++-copyout(pde_t *pgdir, uint va, void *p, uint len)
++-{
++-  char *buf, *pa0;
++-  uint n, va0;
++-
++-  buf = (char*)p;
++-  while(len > 0){
++-    va0 = (uint)PGROUNDDOWN(va);
++-    pa0 = uva2ka(pgdir, (char*)va0);
++-    if(pa0 == 0)
++-      return -1;
++-    n = PGSIZE - (va - va0);
++-    if(n > len)
++-      n = len;
++-    memmove(pa0 + (va - va0), buf, n);
++-    len -= n;
++-    buf += n;
++-    va = va0 + PGSIZE;
++-  }
++-  return 0;
++-}
++-
++-//PAGEBREAK!
++-// Blank page.
++-//PAGEBREAK!
++-// Blank page.
++-//PAGEBREAK!
++-// Blank page.
++-
+ diff --git a/wc.c b/wc.c
+-index d6a54df..08b93b6 100644
++deleted file mode 100644
++index 08b93b6..0000000
+ --- a/wc.c
+-+++ b/wc.c
+-@@ -27,7 +27,7 @@ wc(int fd, char *name)
+-   }
+-   if(n < 0){
+-     printf(1, "wc: read error\n");
+--    exit();
+-+    exit(3);
+-   }
+-   printf(1, "%d %d %d %s\n", l, w, c, name);
+- }
+-@@ -39,16 +39,16 @@ main(int argc, char *argv[])
+- 
+-   if(argc <= 1){
+-     wc(0, "");
+--    exit();
+-+    exit(2);
+-   }
+- 
+-   for(i = 1; i < argc; i++){
+-     if((fd = open(argv[i], 0)) < 0){
+-       printf(1, "wc: cannot open %s\n", argv[i]);
+--      exit();
+-+      exit(1);
+-     }
+-     wc(fd, argv[i]);
+-     close(fd);
+-   }
+--  exit();
+-+  exit(0);
+- }
+++++ /dev/null
++@@ -1,54 +0,0 @@
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-
++-char buf[512];
++-
++-void
++-wc(int fd, char *name)
++-{
++-  int i, n;
++-  int l, w, c, inword;
++-
++-  l = w = c = 0;
++-  inword = 0;
++-  while((n = read(fd, buf, sizeof(buf))) > 0){
++-    for(i=0; i<n; i++){
++-      c++;
++-      if(buf[i] == '\n')
++-        l++;
++-      if(strchr(" \r\t\n\v", buf[i]))
++-        inword = 0;
++-      else if(!inword){
++-        w++;
++-        inword = 1;
++-      }
++-    }
++-  }
++-  if(n < 0){
++-    printf(1, "wc: read error\n");
++-    exit(3);
++-  }
++-  printf(1, "%d %d %d %s\n", l, w, c, name);
++-}
++-
++-int
++-main(int argc, char *argv[])
++-{
++-  int fd, i;
++-
++-  if(argc <= 1){
++-    wc(0, "");
++-    exit(2);
++-  }
++-
++-  for(i = 1; i < argc; i++){
++-    if((fd = open(argv[i], 0)) < 0){
++-      printf(1, "wc: cannot open %s\n", argv[i]);
++-      exit(1);
++-    }
++-    wc(fd, argv[i]);
++-    close(fd);
++-  }
++-  exit(0);
++-}
++diff --git a/x86.h b/x86.h
++deleted file mode 100644
++index 07312a5..0000000
++--- a/x86.h
+++++ /dev/null
++@@ -1,183 +0,0 @@
++-// Routines to let C code use special x86 instructions.
++-
++-static inline uchar
++-inb(ushort port)
++-{
++-  uchar data;
++-
++-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
++-  return data;
++-}
++-
++-static inline void
++-insl(int port, void *addr, int cnt)
++-{
++-  asm volatile("cld; rep insl" :
++-               "=D" (addr), "=c" (cnt) :
++-               "d" (port), "0" (addr), "1" (cnt) :
++-               "memory", "cc");
++-}
++-
++-static inline void
++-outb(ushort port, uchar data)
++-{
++-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
++-}
++-
++-static inline void
++-outw(ushort port, ushort data)
++-{
++-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
++-}
++-
++-static inline void
++-outsl(int port, const void *addr, int cnt)
++-{
++-  asm volatile("cld; rep outsl" :
++-               "=S" (addr), "=c" (cnt) :
++-               "d" (port), "0" (addr), "1" (cnt) :
++-               "cc");
++-}
++-
++-static inline void
++-stosb(void *addr, int data, int cnt)
++-{
++-  asm volatile("cld; rep stosb" :
++-               "=D" (addr), "=c" (cnt) :
++-               "0" (addr), "1" (cnt), "a" (data) :
++-               "memory", "cc");
++-}
++-
++-static inline void
++-stosl(void *addr, int data, int cnt)
++-{
++-  asm volatile("cld; rep stosl" :
++-               "=D" (addr), "=c" (cnt) :
++-               "0" (addr), "1" (cnt), "a" (data) :
++-               "memory", "cc");
++-}
++-
++-struct segdesc;
++-
++-static inline void
++-lgdt(struct segdesc *p, int size)
++-{
++-  volatile ushort pd[3];
++-
++-  pd[0] = size-1;
++-  pd[1] = (uint)p;
++-  pd[2] = (uint)p >> 16;
++-
++-  asm volatile("lgdt (%0)" : : "r" (pd));
++-}
++-
++-struct gatedesc;
++-
++-static inline void
++-lidt(struct gatedesc *p, int size)
++-{
++-  volatile ushort pd[3];
++-
++-  pd[0] = size-1;
++-  pd[1] = (uint)p;
++-  pd[2] = (uint)p >> 16;
++-
++-  asm volatile("lidt (%0)" : : "r" (pd));
++-}
++-
++-static inline void
++-ltr(ushort sel)
++-{
++-  asm volatile("ltr %0" : : "r" (sel));
++-}
++-
++-static inline uint
++-readeflags(void)
++-{
++-  uint eflags;
++-  asm volatile("pushfl; popl %0" : "=r" (eflags));
++-  return eflags;
++-}
++-
++-static inline void
++-loadgs(ushort v)
++-{
++-  asm volatile("movw %0, %%gs" : : "r" (v));
++-}
++-
++-static inline void
++-cli(void)
++-{
++-  asm volatile("cli");
++-}
++-
++-static inline void
++-sti(void)
++-{
++-  asm volatile("sti");
++-}
++-
++-static inline uint
++-xchg(volatile uint *addr, uint newval)
++-{
++-  uint result;
++-
++-  // The + in "+m" denotes a read-modify-write operand.
++-  asm volatile("lock; xchgl %0, %1" :
++-               "+m" (*addr), "=a" (result) :
++-               "1" (newval) :
++-               "cc");
++-  return result;
++-}
++-
++-static inline uint
++-rcr2(void)
++-{
++-  uint val;
++-  asm volatile("movl %%cr2,%0" : "=r" (val));
++-  return val;
++-}
++-
++-static inline void
++-lcr3(uint val)
++-{
++-  asm volatile("movl %0,%%cr3" : : "r" (val));
++-}
++-
++-//PAGEBREAK: 36
++-// Layout of the trap frame built on the stack by the
++-// hardware and by trapasm.S, and passed to trap().
++-struct trapframe {
++-  // registers as pushed by pusha
++-  uint edi;
++-  uint esi;
++-  uint ebp;
++-  uint oesp;      // useless & ignored
++-  uint ebx;
++-  uint edx;
++-  uint ecx;
++-  uint eax;
++-
++-  // rest of trap frame
++-  ushort gs;
++-  ushort padding1;
++-  ushort fs;
++-  ushort padding2;
++-  ushort es;
++-  ushort padding3;
++-  ushort ds;
++-  ushort padding4;
++-  uint trapno;
++-
++-  // below here defined by x86 hardware
++-  uint err;
++-  uint eip;
++-  ushort cs;
++-  ushort padding5;
++-  uint eflags;
++-
++-  // below here only when crossing rings, such as from user to kernel
++-  uint esp;
++-  ushort ss;
++-  ushort padding6;
++-};
+ diff --git a/zombie.c b/zombie.c
+-index ee817da..c96b92d 100644
++deleted file mode 100644
++index c96b92d..0000000
+ --- a/zombie.c
+-+++ b/zombie.c
+-@@ -10,5 +10,5 @@ main(void)
+- {
+-   if(fork() > 0)
+-     sleep(5);  // Let child exit before parent.
+--  exit();
+-+  exit(0);
+- }
+++++ /dev/null
++@@ -1,14 +0,0 @@
++-// Create a zombie process that
++-// must be reparented at exit.
++-
++-#include "types.h"
++-#include "stat.h"
++-#include "user.h"
++-
++-int
++-main(void)
++-{
++-  if(fork() > 0)
++-    sleep(5);  // Let child exit before parent.
++-  exit(0);
++-}
+diff --git a/code2.diff b/code2.diff
+new file mode 100644
+index 0000000..3794ab0
+--- /dev/null
++++ b/code2.diff
+@@ -0,0 +1,5876 @@
++diff --git a/Makefile b/Makefile
++index 04d74d5..09d790c 100644
++--- a/Makefile
+++++ b/Makefile
++@@ -181,7 +181,6 @@ UPROGS=\
++ 	_usertests\
++ 	_wc\
++ 	_zombie\
++-	_lab1\
++ 
++ fs.img: mkfs README $(UPROGS)
++ 	./mkfs fs.img README $(UPROGS)
++diff --git a/cat.c b/cat.c
++index 68b1b8d..5ddc820 100644
++--- a/cat.c
+++++ b/cat.c
++@@ -12,12 +12,12 @@ cat(int fd)
++   while((n = read(fd, buf, sizeof(buf))) > 0) {
++     if (write(1, buf, n) != n) {
++       printf(1, "cat: write error\n");
++-      exit(3);
+++      exit();
++     }
++   }
++   if(n < 0){
++     printf(1, "cat: read error\n");
++-    exit(4);
+++    exit();
++   }
++ }
++ 
++@@ -28,16 +28,16 @@ main(int argc, char *argv[])
++ 
++   if(argc <= 1){
++     cat(0);
++-    exit(1);
+++    exit();
++   }
++ 
++   for(i = 1; i < argc; i++){
++     if((fd = open(argv[i], 0)) < 0){
++       printf(1, "cat: cannot open %s\n", argv[i]);
++-      exit(2);
+++      exit();
++     }
++     cat(fd);
++     close(fd);
++   }
++-  exit(0);
+++  exit();
++ }
++diff --git a/code.diff b/code.diff
++deleted file mode 100644
++index c889659..0000000
++--- a/code.diff
+++++ /dev/null
++@@ -1,2919 +0,0 @@
++-diff --git a/Makefile b/Makefile
++-index 09d790c..04d74d5 100644
++---- a/Makefile
++-+++ b/Makefile
++-@@ -181,6 +181,7 @@ UPROGS=\
++- 	_usertests\
++- 	_wc\
++- 	_zombie\
++-+	_lab1\
++- 
++- fs.img: mkfs README $(UPROGS)
++- 	./mkfs fs.img README $(UPROGS)
++-diff --git a/cat.c b/cat.c
++-index 5ddc820..68b1b8d 100644
++---- a/cat.c
++-+++ b/cat.c
++-@@ -12,12 +12,12 @@ cat(int fd)
++-   while((n = read(fd, buf, sizeof(buf))) > 0) {
++-     if (write(1, buf, n) != n) {
++-       printf(1, "cat: write error\n");
++--      exit();
++-+      exit(3);
++-     }
++-   }
++-   if(n < 0){
++-     printf(1, "cat: read error\n");
++--    exit();
++-+    exit(4);
++-   }
++- }
++- 
++-@@ -28,16 +28,16 @@ main(int argc, char *argv[])
++- 
++-   if(argc <= 1){
++-     cat(0);
++--    exit();
++-+    exit(1);
++-   }
++- 
++-   for(i = 1; i < argc; i++){
++-     if((fd = open(argv[i], 0)) < 0){
++-       printf(1, "cat: cannot open %s\n", argv[i]);
++--      exit();
++-+      exit(2);
++-     }
++-     cat(fd);
++-     close(fd);
++-   }
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/cuth b/cuth
++-old mode 100755
++-new mode 100644
++-diff --git a/defs.h b/defs.h
++-index 82fb982..d1934ca 100644
++---- a/defs.h
++-+++ b/defs.h
++-@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
++- //PAGEBREAK: 16
++- // proc.c
++- int             cpuid(void);
++--void            exit(void);
++-+void            exit(int status);
++- int             fork(void);
++- int             growproc(int);
++- int             kill(int);
++-@@ -117,7 +117,8 @@ void            sched(void);
++- void            setproc(struct proc*);
++- void            sleep(void*, struct spinlock*);
++- void            userinit(void);
++--int             wait(void);
++-+int             wait(int* status);
++-+int             waitpid(int pid, int* status, int options);
++- void            wakeup(void*);
++- void            yield(void);
++- 
++-diff --git a/dot-bochsrc b/dot-bochsrc
++-old mode 100755
++-new mode 100644
++-diff --git a/echo.c b/echo.c
++-index 806dee0..eed68a0 100644
++---- a/echo.c
++-+++ b/echo.c
++-@@ -9,5 +9,5 @@ main(int argc, char *argv[])
++- 
++-   for(i = 1; i < argc; i++)
++-     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/forktest.c b/forktest.c
++-index 8bc984d..a4b35ed 100644
++---- a/forktest.c
++-+++ b/forktest.c
++-@@ -25,24 +25,24 @@ forktest(void)
++-     if(pid < 0)
++-       break;
++-     if(pid == 0)
++--      exit();
++-+      exit(4);
++-   }
++- 
++-   if(n == N){
++-     printf(1, "fork claimed to work N times!\n", N);
++--    exit();
++-+    exit(3);
++-   }
++- 
++-   for(; n > 0; n--){
++--    if(wait() < 0){
++-+    if(wait(NULL) < 0){
++-       printf(1, "wait stopped early\n");
++--      exit();
++-+      exit(2);
++-     }
++-   }
++- 
++--  if(wait() != -1){
++-+  if(wait(NULL) != -1){
++-     printf(1, "wait got too many\n");
++--    exit();
++-+    exit(1);
++-   }
++- 
++-   printf(1, "fork test OK\n");
++-@@ -52,5 +52,5 @@ int
++- main(void)
++- {
++-   forktest();
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/grep.c b/grep.c
++-index adc4835..4be3256 100644
++---- a/grep.c
++-+++ b/grep.c
++-@@ -43,24 +43,24 @@ main(int argc, char *argv[])
++- 
++-   if(argc <= 1){
++-     printf(2, "usage: grep pattern [file ...]\n");
++--    exit();
++-+    exit(1);
++-   }
++-   pattern = argv[1];
++- 
++-   if(argc <= 2){
++-     grep(pattern, 0);
++--    exit();
++-+    exit(2);
++-   }
++- 
++-   for(i = 2; i < argc; i++){
++-     if((fd = open(argv[i], 0)) < 0){
++-       printf(1, "grep: cannot open %s\n", argv[i]);
++--      exit();
++-+      exit(3);
++-     }
++-     grep(pattern, fd);
++-     close(fd);
++-   }
++--  exit();
++-+  exit(0);
++- }
++- 
++- // Regexp matcher from Kernighan & Pike,
++-diff --git a/init.c b/init.c
++-index 046b551..bc6547f 100644
++---- a/init.c
++-+++ b/init.c
++-@@ -24,14 +24,14 @@ main(void)
++-     pid = fork();
++-     if(pid < 0){
++-       printf(1, "init: fork failed\n");
++--      exit();
++-+      exit(2);
++-     }
++-     if(pid == 0){
++-       exec("sh", argv);
++-       printf(1, "init: exec sh failed\n");
++--      exit();
++-+      exit(1);
++-     }
++--    while((wpid=wait()) >= 0 && wpid != pid)
++-+    while((wpid=wait(NULL)) >= 0 && wpid != pid)
++-       printf(1, "zombie!\n");
++-   }
++- }
++-diff --git a/kill.c b/kill.c
++-index 364f6af..875916c 100644
++---- a/kill.c
++-+++ b/kill.c
++-@@ -9,9 +9,9 @@ main(int argc, char **argv)
++- 
++-   if(argc < 2){
++-     printf(2, "usage: kill pid...\n");
++--    exit();
++-+    exit(1);
++-   }
++-   for(i=1; i<argc; i++)
++-     kill(atoi(argv[i]));
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/lab1.c b/lab1.c
++-index 89668ce..2192a52 100644
++---- a/lab1.c
++-+++ b/lab1.c
++-@@ -25,7 +25,7 @@ int main(int argc, char **argv) {
++-     if(pid > 0)
++-     {
++-         waitpid(pid, NULL, 0);
++--        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);
++-+        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
++-         exit(0);
++-     }
++- 
++-diff --git a/ln.c b/ln.c
++-index cf8a64e..fb17c3b 100644
++---- a/ln.c
++-+++ b/ln.c
++-@@ -7,9 +7,9 @@ main(int argc, char *argv[])
++- {
++-   if(argc != 3){
++-     printf(2, "Usage: ln old new\n");
++--    exit();
++-+    exit(1);
++-   }
++-   if(link(argv[1], argv[2]) < 0)
++-     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/ls.c b/ls.c
++-index 2862913..6bf943b 100644
++---- a/ls.c
++-+++ b/ls.c
++-@@ -77,9 +77,9 @@ main(int argc, char *argv[])
++- 
++-   if(argc < 2){
++-     ls(".");
++--    exit();
++-+    exit(1);
++-   }
++-   for(i=1; i<argc; i++)
++-     ls(argv[i]);
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/mkdir.c b/mkdir.c
++-index 6e4c954..2d90781 100644
++---- a/mkdir.c
++-+++ b/mkdir.c
++-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
++- 
++-   if(argc < 2){
++-     printf(2, "Usage: mkdir files...\n");
++--    exit();
++-+    exit(1);
++-   }
++- 
++-   for(i = 1; i < argc; i++){
++-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
++-     }
++-   }
++- 
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/pr.pl b/pr.pl
++-old mode 100755
++-new mode 100644
++-diff --git a/printpcs b/printpcs
++-old mode 100755
++-new mode 100644
++-diff --git a/proc.c b/proc.c
++-index 806b1b1..84b335f 100644
++---- a/proc.c
++-+++ b/proc.c
++-@@ -1,3 +1,5 @@
++-+#include <stddef.h>
++-+
++- #include "types.h"
++- #include "defs.h"
++- #include "param.h"
++-@@ -8,61 +10,61 @@
++- #include "spinlock.h"
++- 
++- struct {
++--  struct spinlock lock;
++--  struct proc proc[NPROC];
++-+    struct spinlock lock;
++-+    struct proc proc[NPROC];
++- } ptable;
++- 
++- static struct proc *initproc;
++- 
++- int nextpid = 1;
++-+
++- extern void forkret(void);
++-+
++- extern void trapret(void);
++- 
++- static void wakeup1(void *chan);
++- 
++- void
++--pinit(void)
++--{
++--  initlock(&ptable.lock, "ptable");
++-+pinit(void) {
++-+    initlock(&ptable.lock, "ptable");
++- }
++- 
++- // Must be called with interrupts disabled
++- int
++- cpuid() {
++--  return mycpu()-cpus;
++-+    return mycpu() - cpus;
++- }
++- 
++- // Must be called with interrupts disabled to avoid the caller being
++- // rescheduled between reading lapicid and running through the loop.
++--struct cpu*
++--mycpu(void)
++--{
++--  int apicid, i;
++--  
++--  if(readeflags()&FL_IF)
++--    panic("mycpu called with interrupts enabled\n");
++--  
++--  apicid = lapicid();
++--  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
++--  // a reverse map, or reserve a register to store &cpus[i].
++--  for (i = 0; i < ncpu; ++i) {
++--    if (cpus[i].apicid == apicid)
++--      return &cpus[i];
++--  }
++--  panic("unknown apicid\n");
++-+struct cpu *
++-+mycpu(void) {
++-+    int apicid, i;
++-+
++-+    if (readeflags() & FL_IF)
++-+        panic("mycpu called with interrupts enabled\n");
++-+
++-+    apicid = lapicid();
++-+    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
++-+    // a reverse map, or reserve a register to store &cpus[i].
++-+    for (i = 0; i < ncpu; ++i) {
++-+        if (cpus[i].apicid == apicid)
++-+            return &cpus[i];
++-+    }
++-+    panic("unknown apicid\n");
++- }
++- 
++- // Disable interrupts so that we are not rescheduled
++- // while reading proc from the cpu structure
++--struct proc*
++-+struct proc *
++- myproc(void) {
++--  struct cpu *c;
++--  struct proc *p;
++--  pushcli();
++--  c = mycpu();
++--  p = c->proc;
++--  popcli();
++--  return p;
++-+    struct cpu *c;
++-+    struct proc *p;
++-+    pushcli();
++-+    c = mycpu();
++-+    p = c->proc;
++-+    popcli();
++-+    return p;
++- }
++- 
++- //PAGEBREAK: 32
++-@@ -70,245 +72,295 @@ myproc(void) {
++- // If found, change state to EMBRYO and initialize
++- // state required to run in the kernel.
++- // Otherwise return 0.
++--static struct proc*
++--allocproc(void)
++--{
++--  struct proc *p;
++--  char *sp;
++-+static struct proc *
++-+allocproc(void) {
++-+    struct proc *p;
++-+    char *sp;
++- 
++--  acquire(&ptable.lock);
++-+    acquire(&ptable.lock);
++- 
++--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++--    if(p->state == UNUSED)
++--      goto found;
++-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++-+        if (p->state == UNUSED)
++-+            goto found;
++- 
++--  release(&ptable.lock);
++--  return 0;
++-+    release(&ptable.lock);
++-+    return 0;
++- 
++--found:
++--  p->state = EMBRYO;
++--  p->pid = nextpid++;
++-+    found:
++-+    p->state = EMBRYO;
++-+    p->pid = nextpid++;
++- 
++--  release(&ptable.lock);
++-+    release(&ptable.lock);
++- 
++--  // Allocate kernel stack.
++--  if((p->kstack = kalloc()) == 0){
++--    p->state = UNUSED;
++--    return 0;
++--  }
++--  sp = p->kstack + KSTACKSIZE;
++-+    // Allocate kernel stack.
++-+    if ((p->kstack = kalloc()) == 0) {
++-+        p->state = UNUSED;
++-+        return 0;
++-+    }
++-+    sp = p->kstack + KSTACKSIZE;
++- 
++--  // Leave room for trap frame.
++--  sp -= sizeof *p->tf;
++--  p->tf = (struct trapframe*)sp;
++-+    // Leave room for trap frame.
++-+    sp -= sizeof *p->tf;
++-+    p->tf = (struct trapframe *) sp;
++- 
++--  // Set up new context to start executing at forkret,
++--  // which returns to trapret.
++--  sp -= 4;
++--  *(uint*)sp = (uint)trapret;
++-+    // Set up new context to start executing at forkret,
++-+    // which returns to trapret.
++-+    sp -= 4;
++-+    *(uint *) sp = (uint) trapret;
++- 
++--  sp -= sizeof *p->context;
++--  p->context = (struct context*)sp;
++--  memset(p->context, 0, sizeof *p->context);
++--  p->context->eip = (uint)forkret;
++-+    sp -= sizeof *p->context;
++-+    p->context = (struct context *) sp;
++-+    memset(p->context, 0, sizeof *p->context);
++-+    p->context->eip = (uint) forkret;
++- 
++--  return p;
++-+    return p;
++- }
++- 
++- //PAGEBREAK: 32
++- // Set up first user process.
++- void
++--userinit(void)
++--{
++--  struct proc *p;
++--  extern char _binary_initcode_start[], _binary_initcode_size[];
++--
++--  p = allocproc();
++--  
++--  initproc = p;
++--  if((p->pgdir = setupkvm()) == 0)
++--    panic("userinit: out of memory?");
++--  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
++--  p->sz = PGSIZE;
++--  memset(p->tf, 0, sizeof(*p->tf));
++--  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
++--  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
++--  p->tf->es = p->tf->ds;
++--  p->tf->ss = p->tf->ds;
++--  p->tf->eflags = FL_IF;
++--  p->tf->esp = PGSIZE;
++--  p->tf->eip = 0;  // beginning of initcode.S
++--
++--  safestrcpy(p->name, "initcode", sizeof(p->name));
++--  p->cwd = namei("/");
++--
++--  // this assignment to p->state lets other cores
++--  // run this process. the acquire forces the above
++--  // writes to be visible, and the lock is also needed
++--  // because the assignment might not be atomic.
++--  acquire(&ptable.lock);
++--
++--  p->state = RUNNABLE;
++--
++--  release(&ptable.lock);
++-+userinit(void) {
++-+    struct proc *p;
++-+    extern char _binary_initcode_start[], _binary_initcode_size[];
++-+
++-+    p = allocproc();
++-+
++-+    initproc = p;
++-+    if ((p->pgdir = setupkvm()) == 0)
++-+        panic("userinit: out of memory?");
++-+    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
++-+    p->sz = PGSIZE;
++-+    memset(p->tf, 0, sizeof(*p->tf));
++-+    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
++-+    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
++-+    p->tf->es = p->tf->ds;
++-+    p->tf->ss = p->tf->ds;
++-+    p->tf->eflags = FL_IF;
++-+    p->tf->esp = PGSIZE;
++-+    p->tf->eip = 0;  // beginning of initcode.S
++-+
++-+    safestrcpy(p->name, "initcode", sizeof(p->name));
++-+    p->cwd = namei("/");
++-+
++-+    // this assignment to p->state lets other cores
++-+    // run this process. the acquire forces the above
++-+    // writes to be visible, and the lock is also needed
++-+    // because the assignment might not be atomic.
++-+    acquire(&ptable.lock);
++-+
++-+    p->state = RUNNABLE;
++-+
++-+    release(&ptable.lock);
++- }
++- 
++- // Grow current process's memory by n bytes.
++- // Return 0 on success, -1 on failure.
++- int
++--growproc(int n)
++--{
++--  uint sz;
++--  struct proc *curproc = myproc();
++--
++--  sz = curproc->sz;
++--  if(n > 0){
++--    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
++--      return -1;
++--  } else if(n < 0){
++--    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
++--      return -1;
++--  }
++--  curproc->sz = sz;
++--  switchuvm(curproc);
++--  return 0;
++-+growproc(int n) {
++-+    uint sz;
++-+    struct proc *curproc = myproc();
++-+
++-+    sz = curproc->sz;
++-+    if (n > 0) {
++-+        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
++-+            return -1;
++-+    } else if (n < 0) {
++-+        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
++-+            return -1;
++-+    }
++-+    curproc->sz = sz;
++-+    switchuvm(curproc);
++-+    return 0;
++- }
++- 
++- // Create a new process copying p as the parent.
++- // Sets up stack to return as if from system call.
++- // Caller must set state of returned proc to RUNNABLE.
++- int
++--fork(void)
++--{
++--  int i, pid;
++--  struct proc *np;
++--  struct proc *curproc = myproc();
++--
++--  // Allocate process.
++--  if((np = allocproc()) == 0){
++--    return -1;
++--  }
++-+fork(void) {
++-+    int i, pid;
++-+    struct proc *np;
++-+    struct proc *curproc = myproc();
++-+
++-+    // Allocate process.
++-+    if ((np = allocproc()) == 0) {
++-+        return -1;
++-+    }
++- 
++--  // Copy process state from proc.
++--  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
++--    kfree(np->kstack);
++--    np->kstack = 0;
++--    np->state = UNUSED;
++--    return -1;
++--  }
++--  np->sz = curproc->sz;
++--  np->parent = curproc;
++--  *np->tf = *curproc->tf;
++-+    // Copy process state from proc.
++-+    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
++-+        kfree(np->kstack);
++-+        np->kstack = 0;
++-+        np->state = UNUSED;
++-+        return -1;
++-+    }
++-+    np->sz = curproc->sz;
++-+    np->parent = curproc;
++-+    *np->tf = *curproc->tf;
++- 
++--  // Clear %eax so that fork returns 0 in the child.
++--  np->tf->eax = 0;
++-+    // Clear %eax so that fork returns 0 in the child.
++-+    np->tf->eax = 0;
++- 
++--  for(i = 0; i < NOFILE; i++)
++--    if(curproc->ofile[i])
++--      np->ofile[i] = filedup(curproc->ofile[i]);
++--  np->cwd = idup(curproc->cwd);
++-+    for (i = 0; i < NOFILE; i++)
++-+        if (curproc->ofile[i])
++-+            np->ofile[i] = filedup(curproc->ofile[i]);
++-+    np->cwd = idup(curproc->cwd);
++- 
++--  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
++-+    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
++- 
++--  pid = np->pid;
++-+    pid = np->pid;
++- 
++--  acquire(&ptable.lock);
++-+    acquire(&ptable.lock);
++- 
++--  np->state = RUNNABLE;
++-+    np->state = RUNNABLE;
++- 
++--  release(&ptable.lock);
++-+    release(&ptable.lock);
++- 
++--  return pid;
++-+    return pid;
++- }
++- 
++- // Exit the current process.  Does not return.
++- // An exited process remains in the zombie state
++- // until its parent calls wait() to find out it exited.
++- void
++--exit(void)
++--{
++--  struct proc *curproc = myproc();
++--  struct proc *p;
++--  int fd;
++--
++--  if(curproc == initproc)
++--    panic("init exiting");
++--
++--  // Close all open files.
++--  for(fd = 0; fd < NOFILE; fd++){
++--    if(curproc->ofile[fd]){
++--      fileclose(curproc->ofile[fd]);
++--      curproc->ofile[fd] = 0;
++-+exit(int status) {
++-+    struct proc *curproc = myproc();
++-+    struct proc *p;
++-+    int fd;
++-+
++-+    curproc->status = status;
++-+
++-+    if (curproc == initproc)
++-+        panic("init exiting");
++-+
++-+    // Close all open files.
++-+    for (fd = 0; fd < NOFILE; fd++) {
++-+        if (curproc->ofile[fd]) {
++-+            fileclose(curproc->ofile[fd]);
++-+            curproc->ofile[fd] = 0;
++-+        }
++-     }
++--  }
++- 
++--  begin_op();
++--  iput(curproc->cwd);
++--  end_op();
++--  curproc->cwd = 0;
++-+    begin_op();
++-+    iput(curproc->cwd);
++-+    end_op();
++-+    curproc->cwd = 0;
++- 
++--  acquire(&ptable.lock);
++-+    acquire(&ptable.lock);
++- 
++--  // Parent might be sleeping in wait().
++--  wakeup1(curproc->parent);
++-+    // Parent might be sleeping in wait().
++-+    wakeup1(curproc->parent);
++- 
++--  // Pass abandoned children to init.
++--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++--    if(p->parent == curproc){
++--      p->parent = initproc;
++--      if(p->state == ZOMBIE)
++--        wakeup1(initproc);
++-+    // Pass abandoned children to init.
++-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-+        if (p->parent == curproc) {
++-+            p->parent = initproc;
++-+            if (p->state == ZOMBIE)
++-+                wakeup1(initproc);
++-+        }
++-     }
++--  }
++- 
++--  // Jump into the scheduler, never to return.
++--  curproc->state = ZOMBIE;
++--  sched();
++--  panic("zombie exit");
++-+    // Jump into the scheduler, never to return.
++-+    curproc->state = ZOMBIE;
++-+    sched();
++-+    panic("zombie exit");
++- }
++- 
++- // Wait for a child process to exit and return its pid.
++- // Return -1 if this process has no children.
++- int
++--wait(void)
++--{
++--  struct proc *p;
++--  int havekids, pid;
++--  struct proc *curproc = myproc();
++--  
++--  acquire(&ptable.lock);
++--  for(;;){
++--    // Scan through table looking for exited children.
++--    havekids = 0;
++--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++--      if(p->parent != curproc)
++--        continue;
++--      havekids = 1;
++--      if(p->state == ZOMBIE){
++--        // Found one.
++--        pid = p->pid;
++--        kfree(p->kstack);
++--        p->kstack = 0;
++--        freevm(p->pgdir);
++--        p->pid = 0;
++--        p->parent = 0;
++--        p->name[0] = 0;
++--        p->killed = 0;
++--        p->state = UNUSED;
++--        release(&ptable.lock);
++--        return pid;
++--      }
++--    }
++-+wait(int *status) {
++-+    struct proc *p;
++-+    int havekids, pid;
++-+    struct proc *curproc = myproc();
++- 
++--    // No point waiting if we don't have any children.
++--    if(!havekids || curproc->killed){
++--      release(&ptable.lock);
++--      return -1;
++-+    acquire(&ptable.lock);
++-+    for (;;) {
++-+        // Scan through table looking for exited children.
++-+        havekids = 0;
++-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-+            if (p->parent != curproc)
++-+                continue;
++-+            havekids = 1;
++-+            if (p->state == ZOMBIE) {
++-+                // Found one.
++-+                pid = p->pid;
++-+                kfree(p->kstack);
++-+                p->kstack = 0;
++-+                freevm(p->pgdir);
++-+                p->pid = 0;
++-+                p->parent = 0;
++-+                p->name[0] = 0;
++-+                p->killed = 0;
++-+                p->state = UNUSED;
++-+                release(&ptable.lock);
++-+                if (status != NULL)
++-+                    *status = p->status;
++-+                return pid;
++-+            }
++-+        }
++-+
++-+        // No point waiting if we don't have any children.
++-+        if (!havekids || curproc->killed) {
++-+            release(&ptable.lock);
++-+            return -1;
++-+        }
++-+
++-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
++-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
++-     }
++-+}
++- 
++--    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
++--    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
++--  }
++-+// Wait for a child process to exit and return its pid.
++-+// Return -1 if this process has no children.
++-+int
++-+waitpid(int pidBeingSearchedFor, int *status, int options) {
++-+    struct proc *p;
++-+    int doesProcExist, pidFound;
++-+    struct proc *curproc = myproc();
++-+    acquire(&ptable.lock);
++-+    for (;;) {
++-+        // Scan through table looking for exited children.
++-+        doesProcExist = 0;
++-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-+//            if(p->parent != curproc)
++-+//                continue;
++-+
++-+            if (p->pid != pidBeingSearchedFor)
++-+                continue;
++-+
++-+            doesProcExist = 1;
++-+            if (p->state == ZOMBIE) {
++-+                // Found one.
++-+                pidFound = p->pid;
++-+                kfree(p->kstack);
++-+                p->kstack = 0;
++-+                freevm(p->pgdir);
++-+                p->pid = 0;
++-+                p->parent = 0;
++-+                p->name[0] = 0;
++-+                p->killed = 0;
++-+                p->state = UNUSED;
++-+                release(&ptable.lock);
++-+                if (status != NULL)
++-+                    *status = p->status;
++-+                return pidFound;
++-+            }
++-+        }
++-+
++-+//        // No point waiting if we don't have any children.
++-+//        if(!havekids || curproc->killed){
++-+//            release(&ptable.lock);
++-+//            return -1;
++-+//        }
++-+
++-+        if (!doesProcExist || curproc->killed) {
++-+            release(&ptable.lock);
++-+            return -1;
++-+        }
++-+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
++-+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
++-+    }
++- }
++- 
++- //PAGEBREAK: 42
++-@@ -320,39 +372,38 @@ wait(void)
++- //  - eventually that process transfers control
++- //      via swtch back to the scheduler.
++- void
++--scheduler(void)
++--{
++--  struct proc *p;
++--  struct cpu *c = mycpu();
++--  c->proc = 0;
++--  
++--  for(;;){
++--    // Enable interrupts on this processor.
++--    sti();
++--
++--    // Loop over process table looking for process to run.
++--    acquire(&ptable.lock);
++--    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++--      if(p->state != RUNNABLE)
++--        continue;
++--
++--      // Switch to chosen process.  It is the process's job
++--      // to release ptable.lock and then reacquire it
++--      // before jumping back to us.
++--      c->proc = p;
++--      switchuvm(p);
++--      p->state = RUNNING;
++--
++--      swtch(&(c->scheduler), p->context);
++--      switchkvm();
++--
++--      // Process is done running for now.
++--      // It should have changed its p->state before coming back.
++--      c->proc = 0;
++--    }
++--    release(&ptable.lock);
++-+scheduler(void) {
++-+    struct proc *p;
++-+    struct cpu *c = mycpu();
++-+    c->proc = 0;
++-+
++-+    for (;;) {
++-+        // Enable interrupts on this processor.
++-+        sti();
++-+
++-+        // Loop over process table looking for process to run.
++-+        acquire(&ptable.lock);
++-+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-+            if (p->state != RUNNABLE)
++-+                continue;
++-+
++-+            // Switch to chosen process.  It is the process's job
++-+            // to release ptable.lock and then reacquire it
++-+            // before jumping back to us.
++-+            c->proc = p;
++-+            switchuvm(p);
++-+            p->state = RUNNING;
++-+
++-+            swtch(&(c->scheduler), p->context);
++-+            switchkvm();
++-+
++-+            // Process is done running for now.
++-+            // It should have changed its p->state before coming back.
++-+            c->proc = 0;
++-+        }
++-+        release(&ptable.lock);
++- 
++--  }
++-+    }
++- }
++- 
++- // Enter scheduler.  Must hold only ptable.lock
++-@@ -363,137 +414,130 @@ scheduler(void)
++- // break in the few places where a lock is held but
++- // there's no process.
++- void
++--sched(void)
++--{
++--  int intena;
++--  struct proc *p = myproc();
++--
++--  if(!holding(&ptable.lock))
++--    panic("sched ptable.lock");
++--  if(mycpu()->ncli != 1)
++--    panic("sched locks");
++--  if(p->state == RUNNING)
++--    panic("sched running");
++--  if(readeflags()&FL_IF)
++--    panic("sched interruptible");
++--  intena = mycpu()->intena;
++--  swtch(&p->context, mycpu()->scheduler);
++--  mycpu()->intena = intena;
++-+sched(void) {
++-+    int intena;
++-+    struct proc *p = myproc();
++-+
++-+    if (!holding(&ptable.lock))
++-+        panic("sched ptable.lock");
++-+    if (mycpu()->ncli != 1)
++-+        panic("sched locks");
++-+    if (p->state == RUNNING)
++-+        panic("sched running");
++-+    if (readeflags() & FL_IF)
++-+        panic("sched interruptible");
++-+    intena = mycpu()->intena;
++-+    swtch(&p->context, mycpu()->scheduler);
++-+    mycpu()->intena = intena;
++- }
++- 
++- // Give up the CPU for one scheduling round.
++- void
++--yield(void)
++--{
++--  acquire(&ptable.lock);  //DOC: yieldlock
++--  myproc()->state = RUNNABLE;
++--  sched();
++--  release(&ptable.lock);
++-+yield(void) {
++-+    acquire(&ptable.lock);  //DOC: yieldlock
++-+    myproc()->state = RUNNABLE;
++-+    sched();
++-+    release(&ptable.lock);
++- }
++- 
++- // A fork child's very first scheduling by scheduler()
++- // will swtch here.  "Return" to user space.
++- void
++--forkret(void)
++--{
++--  static int first = 1;
++--  // Still holding ptable.lock from scheduler.
++--  release(&ptable.lock);
++--
++--  if (first) {
++--    // Some initialization functions must be run in the context
++--    // of a regular process (e.g., they call sleep), and thus cannot
++--    // be run from main().
++--    first = 0;
++--    iinit(ROOTDEV);
++--    initlog(ROOTDEV);
++--  }
++--
++--  // Return to "caller", actually trapret (see allocproc).
++-+forkret(void) {
++-+    static int first = 1;
++-+    // Still holding ptable.lock from scheduler.
++-+    release(&ptable.lock);
++-+
++-+    if (first) {
++-+        // Some initialization functions must be run in the context
++-+        // of a regular process (e.g., they call sleep), and thus cannot
++-+        // be run from main().
++-+        first = 0;
++-+        iinit(ROOTDEV);
++-+        initlog(ROOTDEV);
++-+    }
++-+
++-+    // Return to "caller", actually trapret (see allocproc).
++- }
++- 
++- // Atomically release lock and sleep on chan.
++- // Reacquires lock when awakened.
++- void
++--sleep(void *chan, struct spinlock *lk)
++--{
++--  struct proc *p = myproc();
++--  
++--  if(p == 0)
++--    panic("sleep");
++--
++--  if(lk == 0)
++--    panic("sleep without lk");
++--
++--  // Must acquire ptable.lock in order to
++--  // change p->state and then call sched.
++--  // Once we hold ptable.lock, we can be
++--  // guaranteed that we won't miss any wakeup
++--  // (wakeup runs with ptable.lock locked),
++--  // so it's okay to release lk.
++--  if(lk != &ptable.lock){  //DOC: sleeplock0
++--    acquire(&ptable.lock);  //DOC: sleeplock1
++--    release(lk);
++--  }
++--  // Go to sleep.
++--  p->chan = chan;
++--  p->state = SLEEPING;
++--
++--  sched();
++--
++--  // Tidy up.
++--  p->chan = 0;
++--
++--  // Reacquire original lock.
++--  if(lk != &ptable.lock){  //DOC: sleeplock2
++--    release(&ptable.lock);
++--    acquire(lk);
++--  }
++-+sleep(void *chan, struct spinlock *lk) {
++-+    struct proc *p = myproc();
++-+
++-+    if (p == 0)
++-+        panic("sleep");
++-+
++-+    if (lk == 0)
++-+        panic("sleep without lk");
++-+
++-+    // Must acquire ptable.lock in order to
++-+    // change p->state and then call sched.
++-+    // Once we hold ptable.lock, we can be
++-+    // guaranteed that we won't miss any wakeup
++-+    // (wakeup runs with ptable.lock locked),
++-+    // so it's okay to release lk.
++-+    if (lk != &ptable.lock) {  //DOC: sleeplock0
++-+        acquire(&ptable.lock);  //DOC: sleeplock1
++-+        release(lk);
++-+    }
++-+    // Go to sleep.
++-+    p->chan = chan;
++-+    p->state = SLEEPING;
++-+
++-+    sched();
++-+
++-+    // Tidy up.
++-+    p->chan = 0;
++-+
++-+    // Reacquire original lock.
++-+    if (lk != &ptable.lock) {  //DOC: sleeplock2
++-+        release(&ptable.lock);
++-+        acquire(lk);
++-+    }
++- }
++- 
++- //PAGEBREAK!
++- // Wake up all processes sleeping on chan.
++- // The ptable lock must be held.
++- static void
++--wakeup1(void *chan)
++--{
++--  struct proc *p;
++-+wakeup1(void *chan) {
++-+    struct proc *p;
++- 
++--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++--    if(p->state == SLEEPING && p->chan == chan)
++--      p->state = RUNNABLE;
++-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++-+        if (p->state == SLEEPING && p->chan == chan)
++-+            p->state = RUNNABLE;
++- }
++- 
++- // Wake up all processes sleeping on chan.
++- void
++--wakeup(void *chan)
++--{
++--  acquire(&ptable.lock);
++--  wakeup1(chan);
++--  release(&ptable.lock);
++-+wakeup(void *chan) {
++-+    acquire(&ptable.lock);
++-+    wakeup1(chan);
++-+    release(&ptable.lock);
++- }
++- 
++- // Kill the process with the given pid.
++- // Process won't exit until it returns
++- // to user space (see trap in trap.c).
++- int
++--kill(int pid)
++--{
++--  struct proc *p;
++--
++--  acquire(&ptable.lock);
++--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++--    if(p->pid == pid){
++--      p->killed = 1;
++--      // Wake process from sleep if necessary.
++--      if(p->state == SLEEPING)
++--        p->state = RUNNABLE;
++--      release(&ptable.lock);
++--      return 0;
++-+kill(int pid) {
++-+    struct proc *p;
++-+
++-+    acquire(&ptable.lock);
++-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-+        if (p->pid == pid) {
++-+            p->killed = 1;
++-+            // Wake process from sleep if necessary.
++-+            if (p->state == SLEEPING)
++-+                p->state = RUNNABLE;
++-+            release(&ptable.lock);
++-+            return 0;
++-+        }
++-     }
++--  }
++--  release(&ptable.lock);
++--  return -1;
++-+    release(&ptable.lock);
++-+    return -1;
++- }
++- 
++- //PAGEBREAK: 36
++-@@ -501,34 +545,33 @@ kill(int pid)
++- // Runs when user types ^P on console.
++- // No lock to avoid wedging a stuck machine further.
++- void
++--procdump(void)
++--{
++--  static char *states[] = {
++--  [UNUSED]    "unused",
++--  [EMBRYO]    "embryo",
++--  [SLEEPING]  "sleep ",
++--  [RUNNABLE]  "runble",
++--  [RUNNING]   "run   ",
++--  [ZOMBIE]    "zombie"
++--  };
++--  int i;
++--  struct proc *p;
++--  char *state;
++--  uint pc[10];
++--
++--  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++--    if(p->state == UNUSED)
++--      continue;
++--    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
++--      state = states[p->state];
++--    else
++--      state = "???";
++--    cprintf("%d %s %s", p->pid, state, p->name);
++--    if(p->state == SLEEPING){
++--      getcallerpcs((uint*)p->context->ebp+2, pc);
++--      for(i=0; i<10 && pc[i] != 0; i++)
++--        cprintf(" %p", pc[i]);
++-+procdump(void) {
++-+    static char *states[] = {
++-+            [UNUSED]    "unused",
++-+            [EMBRYO]    "embryo",
++-+            [SLEEPING]  "sleep ",
++-+            [RUNNABLE]  "runble",
++-+            [RUNNING]   "run   ",
++-+            [ZOMBIE]    "zombie"
++-+    };
++-+    int i;
++-+    struct proc *p;
++-+    char *state;
++-+    uint pc[10];
++-+
++-+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-+        if (p->state == UNUSED)
++-+            continue;
++-+        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
++-+            state = states[p->state];
++-+        else
++-+            state = "???";
++-+        cprintf("%d %s %s", p->pid, state, p->name);
++-+        if (p->state == SLEEPING) {
++-+            getcallerpcs((uint *) p->context->ebp + 2, pc);
++-+            for (i = 0; i < 10 && pc[i] != 0; i++)
++-+                cprintf(" %p", pc[i]);
++-+        }
++-+        cprintf("\n");
++-     }
++--    cprintf("\n");
++--  }
++- }
++-diff --git a/proc.h b/proc.h
++-index 1647114..a06b921 100644
++---- a/proc.h
++-+++ b/proc.h
++-@@ -49,6 +49,7 @@ struct proc {
++-   struct file *ofile[NOFILE];  // Open files
++-   struct inode *cwd;           // Current directory
++-   char name[16];               // Process name (debugging)
++-+  int status;                  // Exit status
++- };
++- 
++- // Process memory is laid out contiguously, low addresses first:
++-diff --git a/rm.c b/rm.c
++-index 4fd33c8..1e6daec 100644
++---- a/rm.c
++-+++ b/rm.c
++-@@ -9,7 +9,7 @@ main(int argc, char *argv[])
++- 
++-   if(argc < 2){
++-     printf(2, "Usage: rm files...\n");
++--    exit();
++-+    exit(1);
++-   }
++- 
++-   for(i = 1; i < argc; i++){
++-@@ -19,5 +19,5 @@ main(int argc, char *argv[])
++-     }
++-   }
++- 
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/runoff b/runoff
++-old mode 100755
++-new mode 100644
++-diff --git a/runoff1 b/runoff1
++-old mode 100755
++-new mode 100644
++-diff --git a/sh.c b/sh.c
++-index 054bab9..ca2ae37 100644
++---- a/sh.c
++-+++ b/sh.c
++-@@ -65,7 +65,7 @@ runcmd(struct cmd *cmd)
++-   struct redircmd *rcmd;
++- 
++-   if(cmd == 0)
++--    exit();
++-+    exit(1);
++- 
++-   switch(cmd->type){
++-   default:
++-@@ -74,7 +74,7 @@ runcmd(struct cmd *cmd)
++-   case EXEC:
++-     ecmd = (struct execcmd*)cmd;
++-     if(ecmd->argv[0] == 0)
++--      exit();
++-+      exit(2);
++-     exec(ecmd->argv[0], ecmd->argv);
++-     printf(2, "exec %s failed\n", ecmd->argv[0]);
++-     break;
++-@@ -84,7 +84,7 @@ runcmd(struct cmd *cmd)
++-     close(rcmd->fd);
++-     if(open(rcmd->file, rcmd->mode) < 0){
++-       printf(2, "open %s failed\n", rcmd->file);
++--      exit();
++-+      exit(6);
++-     }
++-     runcmd(rcmd->cmd);
++-     break;
++-@@ -93,7 +93,7 @@ runcmd(struct cmd *cmd)
++-     lcmd = (struct listcmd*)cmd;
++-     if(fork1() == 0)
++-       runcmd(lcmd->left);
++--    wait();
++-+    wait(NULL);
++-     runcmd(lcmd->right);
++-     break;
++- 
++-@@ -117,8 +117,8 @@ runcmd(struct cmd *cmd)
++-     }
++-     close(p[0]);
++-     close(p[1]);
++--    wait();
++--    wait();
++-+    wait(NULL);
++-+    wait(NULL);
++-     break;
++- 
++-   case BACK:
++-@@ -127,7 +127,7 @@ runcmd(struct cmd *cmd)
++-       runcmd(bcmd->cmd);
++-     break;
++-   }
++--  exit();
++-+  exit(3);
++- }
++- 
++- int
++-@@ -166,16 +166,16 @@ main(void)
++-     }
++-     if(fork1() == 0)
++-       runcmd(parsecmd(buf));
++--    wait();
++-+    wait(NULL);
++-   }
++--  exit();
++-+  exit(0);
++- }
++- 
++- void
++- panic(char *s)
++- {
++-   printf(2, "%s\n", s);
++--  exit();
++-+  exit(5);
++- }
++- 
++- int
++-diff --git a/show1 b/show1
++-old mode 100755
++-new mode 100644
++-diff --git a/sign.pl b/sign.pl
++-old mode 100755
++-new mode 100644
++-diff --git a/spinp b/spinp
++-old mode 100755
++-new mode 100644
++-diff --git a/stressfs.c b/stressfs.c
++-index c0a4743..46e0e66 100644
++---- a/stressfs.c
++-+++ b/stressfs.c
++-@@ -43,7 +43,7 @@ main(int argc, char *argv[])
++-     read(fd, data, sizeof(data));
++-   close(fd);
++- 
++--  wait();
++-+  wait(NULL);
++- 
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/syscall.c b/syscall.c
++-index ee85261..41a8c3c 100644
++---- a/syscall.c
++-+++ b/syscall.c
++-@@ -101,6 +101,7 @@ extern int sys_sbrk(void);
++- extern int sys_sleep(void);
++- extern int sys_unlink(void);
++- extern int sys_wait(void);
++-+extern int sys_waitpid(void);
++- extern int sys_write(void);
++- extern int sys_uptime(void);
++- 
++-@@ -108,6 +109,7 @@ static int (*syscalls[])(void) = {
++- [SYS_fork]    sys_fork,
++- [SYS_exit]    sys_exit,
++- [SYS_wait]    sys_wait,
++-+[SYS_waitpid] sys_waitpid,
++- [SYS_pipe]    sys_pipe,
++- [SYS_read]    sys_read,
++- [SYS_kill]    sys_kill,
++-diff --git a/syscall.h b/syscall.h
++-index bc5f356..374ff05 100644
++---- a/syscall.h
++-+++ b/syscall.h
++-@@ -1,22 +1,23 @@
++- // System call numbers
++--#define SYS_fork    1
++--#define SYS_exit    2
++--#define SYS_wait    3
++--#define SYS_pipe    4
++--#define SYS_read    5
++--#define SYS_kill    6
++--#define SYS_exec    7
++--#define SYS_fstat   8
++--#define SYS_chdir   9
++--#define SYS_dup    10
++--#define SYS_getpid 11
++--#define SYS_sbrk   12
++--#define SYS_sleep  13
++--#define SYS_uptime 14
++--#define SYS_open   15
++--#define SYS_write  16
++--#define SYS_mknod  17
++--#define SYS_unlink 18
++--#define SYS_link   19
++--#define SYS_mkdir  20
++--#define SYS_close  21
++-+#define SYS_fork     1
++-+#define SYS_exit     2
++-+#define SYS_wait     3
++-+#define SYS_pipe     4
++-+#define SYS_read     5
++-+#define SYS_kill     6
++-+#define SYS_exec     7
++-+#define SYS_fstat    8
++-+#define SYS_chdir    9
++-+#define SYS_dup     10
++-+#define SYS_getpid  11
++-+#define SYS_sbrk    12
++-+#define SYS_sleep   13
++-+#define SYS_uptime  14
++-+#define SYS_open    15
++-+#define SYS_write   16
++-+#define SYS_mknod   17
++-+#define SYS_unlink  18
++-+#define SYS_link    19
++-+#define SYS_mkdir   20
++-+#define SYS_close   21
++-+#define SYS_waitpid 22
++-\ No newline at end of file
++-diff --git a/sysproc.c b/sysproc.c
++-index 0686d29..ebccf84 100644
++---- a/sysproc.c
++-+++ b/sysproc.c
++-@@ -14,16 +14,22 @@ sys_fork(void)
++- }
++- 
++- int
++--sys_exit(void)
++-+sys_exit(int status)
++- {
++--  exit();
++-+  exit(status);
++-   return 0;  // not reached
++- }
++- 
++- int
++--sys_wait(void)
++-+sys_wait(int* status)
++- {
++--  return wait();
++-+  return wait(status);
++-+}
++-+
++-+int
++-+sys_waitpid(int pid, int* status, int options)
++-+{
++-+    return waitpid(pid, status, options);
++- }
++- 
++- int
++-diff --git a/trap.c b/trap.c
++-index 41c66eb..432ea5b 100644
++---- a/trap.c
++-+++ b/trap.c
++-@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
++- {
++-   if(tf->trapno == T_SYSCALL){
++-     if(myproc()->killed)
++--      exit();
++-+      exit(4);
++-     myproc()->tf = tf;
++-     syscall();
++-     if(myproc()->killed)
++--      exit();
++-+      exit(3);
++-     return;
++-   }
++- 
++-@@ -98,7 +98,7 @@ trap(struct trapframe *tf)
++-   // (If it is still executing in the kernel, let it keep running
++-   // until it gets to the regular system call return.)
++-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
++--    exit();
++-+    exit(2);
++- 
++-   // Force process to give up CPU on clock tick.
++-   // If interrupts were on while locks held, would need to check nlock.
++-@@ -108,5 +108,5 @@ trap(struct trapframe *tf)
++- 
++-   // Check if the process has been killed since we yielded
++-   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
++--    exit();
++-+    exit(1);
++- }
++-diff --git a/user.h b/user.h
++-index 4f99c52..0931387 100644
++---- a/user.h
++-+++ b/user.h
++-@@ -1,10 +1,13 @@
++-+#include <stddef.h>
++-+
++- struct stat;
++- struct rtcdate;
++- 
++- // system calls
++- int fork(void);
++--int exit(void) __attribute__((noreturn));
++--int wait(void);
++-+int exit(int status) __attribute__((noreturn));
++-+int wait(int* status);
++-+int waitpid(int pid, int* status, int options);
++- int pipe(int*);
++- int write(int, const void*, int);
++- int read(int, void*, int);
++-diff --git a/usertests.c b/usertests.c
++-index a1e97e7..2c2c128 100644
++---- a/usertests.c
++-+++ b/usertests.c
++-@@ -21,19 +21,19 @@ iputtest(void)
++- 
++-   if(mkdir("iputdir") < 0){
++-     printf(stdout, "mkdir failed\n");
++--    exit();
++-+    exit(184);
++-   }
++-   if(chdir("iputdir") < 0){
++-     printf(stdout, "chdir iputdir failed\n");
++--    exit();
++-+    exit(183);
++-   }
++-   if(unlink("../iputdir") < 0){
++-     printf(stdout, "unlink ../iputdir failed\n");
++--    exit();
++-+    exit(182);
++-   }
++-   if(chdir("/") < 0){
++-     printf(stdout, "chdir / failed\n");
++--    exit();
++-+    exit(181);
++-   }
++-   printf(stdout, "iput test ok\n");
++- }
++-@@ -49,24 +49,24 @@ exitiputtest(void)
++-   pid = fork();
++-   if(pid < 0){
++-     printf(stdout, "fork failed\n");
++--    exit();
++-+    exit(180);
++-   }
++-   if(pid == 0){
++-     if(mkdir("iputdir") < 0){
++-       printf(stdout, "mkdir failed\n");
++--      exit();
++-+      exit(179);
++-     }
++-     if(chdir("iputdir") < 0){
++-       printf(stdout, "child chdir failed\n");
++--      exit();
++-+      exit(178);
++-     }
++-     if(unlink("../iputdir") < 0){
++-       printf(stdout, "unlink ../iputdir failed\n");
++--      exit();
++-+      exit(177);
++-     }
++--    exit();
++-+    exit(176);
++-   }
++--  wait();
++-+  wait(NULL);
++-   printf(stdout, "exitiput test ok\n");
++- }
++- 
++-@@ -89,27 +89,27 @@ openiputtest(void)
++-   printf(stdout, "openiput test\n");
++-   if(mkdir("oidir") < 0){
++-     printf(stdout, "mkdir oidir failed\n");
++--    exit();
++-+    exit(175);
++-   }
++-   pid = fork();
++-   if(pid < 0){
++-     printf(stdout, "fork failed\n");
++--    exit();
++-+    exit(174);
++-   }
++-   if(pid == 0){
++-     int fd = open("oidir", O_RDWR);
++-     if(fd >= 0){
++-       printf(stdout, "open directory for write succeeded\n");
++--      exit();
++-+      exit(0);
++-     }
++--    exit();
++-+    exit(172);
++-   }
++-   sleep(1);
++-   if(unlink("oidir") != 0){
++-     printf(stdout, "unlink failed\n");
++--    exit();
++-+    exit(171);
++-   }
++--  wait();
++-+  wait(NULL);
++-   printf(stdout, "openiput test ok\n");
++- }
++- 
++-@@ -124,13 +124,13 @@ opentest(void)
++-   fd = open("echo", 0);
++-   if(fd < 0){
++-     printf(stdout, "open echo failed!\n");
++--    exit();
++-+    exit(170);
++-   }
++-   close(fd);
++-   fd = open("doesnotexist", 0);
++-   if(fd >= 0){
++-     printf(stdout, "open doesnotexist succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   printf(stdout, "open test ok\n");
++- }
++-@@ -147,16 +147,16 @@ writetest(void)
++-     printf(stdout, "creat small succeeded; ok\n");
++-   } else {
++-     printf(stdout, "error: creat small failed!\n");
++--    exit();
++-+    exit(168);
++-   }
++-   for(i = 0; i < 100; i++){
++-     if(write(fd, "aaaaaaaaaa", 10) != 10){
++-       printf(stdout, "error: write aa %d new file failed\n", i);
++--      exit();
++-+      exit(167);
++-     }
++-     if(write(fd, "bbbbbbbbbb", 10) != 10){
++-       printf(stdout, "error: write bb %d new file failed\n", i);
++--      exit();
++-+      exit(166);
++-     }
++-   }
++-   printf(stdout, "writes ok\n");
++-@@ -166,20 +166,20 @@ writetest(void)
++-     printf(stdout, "open small succeeded ok\n");
++-   } else {
++-     printf(stdout, "error: open small failed!\n");
++--    exit();
++-+    exit(165);
++-   }
++-   i = read(fd, buf, 2000);
++-   if(i == 2000){
++-     printf(stdout, "read succeeded ok\n");
++-   } else {
++-     printf(stdout, "read failed\n");
++--    exit();
++-+    exit(164);
++-   }
++-   close(fd);
++- 
++-   if(unlink("small") < 0){
++-     printf(stdout, "unlink small failed\n");
++--    exit();
++-+    exit(163);
++-   }
++-   printf(stdout, "small file test ok\n");
++- }
++-@@ -194,14 +194,14 @@ writetest1(void)
++-   fd = open("big", O_CREATE|O_RDWR);
++-   if(fd < 0){
++-     printf(stdout, "error: creat big failed!\n");
++--    exit();
++-+    exit(162);
++-   }
++- 
++-   for(i = 0; i < MAXFILE; i++){
++-     ((int*)buf)[0] = i;
++-     if(write(fd, buf, 512) != 512){
++-       printf(stdout, "error: write big file failed\n", i);
++--      exit();
++-+      exit(161);
++-     }
++-   }
++- 
++-@@ -210,7 +210,7 @@ writetest1(void)
++-   fd = open("big", O_RDONLY);
++-   if(fd < 0){
++-     printf(stdout, "error: open big failed!\n");
++--    exit();
++-+    exit(160);
++-   }
++- 
++-   n = 0;
++-@@ -219,24 +219,24 @@ writetest1(void)
++-     if(i == 0){
++-       if(n == MAXFILE - 1){
++-         printf(stdout, "read only %d blocks from big", n);
++--        exit();
++-+        exit(159);
++-       }
++-       break;
++-     } else if(i != 512){
++-       printf(stdout, "read failed %d\n", i);
++--      exit();
++-+      exit(158);
++-     }
++-     if(((int*)buf)[0] != n){
++-       printf(stdout, "read content of block %d is %d\n",
++-              n, ((int*)buf)[0]);
++--      exit();
++-+      exit(157);
++-     }
++-     n++;
++-   }
++-   close(fd);
++-   if(unlink("big") < 0){
++-     printf(stdout, "unlink big failed\n");
++--    exit();
++-+    exit(156);
++-   }
++-   printf(stdout, "big files ok\n");
++- }
++-@@ -270,22 +270,22 @@ void dirtest(void)
++- 
++-   if(mkdir("dir0") < 0){
++-     printf(stdout, "mkdir failed\n");
++--    exit();
++-+    exit(155);
++-   }
++- 
++-   if(chdir("dir0") < 0){
++-     printf(stdout, "chdir dir0 failed\n");
++--    exit();
++-+    exit(154);
++-   }
++- 
++-   if(chdir("..") < 0){
++-     printf(stdout, "chdir .. failed\n");
++--    exit();
++-+    exit(153);
++-   }
++- 
++-   if(unlink("dir0") < 0){
++-     printf(stdout, "unlink dir0 failed\n");
++--    exit();
++-+    exit(152);
++-   }
++-   printf(stdout, "mkdir test ok\n");
++- }
++-@@ -296,7 +296,7 @@ exectest(void)
++-   printf(stdout, "exec test\n");
++-   if(exec("echo", echoargv) < 0){
++-     printf(stdout, "exec echo failed\n");
++--    exit();
++-+    exit(151);
++-   }
++- }
++- 
++-@@ -310,7 +310,7 @@ pipe1(void)
++- 
++-   if(pipe(fds) != 0){
++-     printf(1, "pipe() failed\n");
++--    exit();
++-+    exit(150);
++-   }
++-   pid = fork();
++-   seq = 0;
++-@@ -321,10 +321,10 @@ pipe1(void)
++-         buf[i] = seq++;
++-       if(write(fds[1], buf, 1033) != 1033){
++-         printf(1, "pipe1 oops 1\n");
++--        exit();
++-+        exit(149);
++-       }
++-     }
++--    exit();
++-+    exit(148);
++-   } else if(pid > 0){
++-     close(fds[1]);
++-     total = 0;
++-@@ -343,13 +343,13 @@ pipe1(void)
++-     }
++-     if(total != 5 * 1033){
++-       printf(1, "pipe1 oops 3 total %d\n", total);
++--      exit();
++-+      exit(147);
++-     }
++-     close(fds[0]);
++--    wait();
++-+    wait(NULL);
++-   } else {
++-     printf(1, "fork() failed\n");
++--    exit();
++-+    exit(146);
++-   }
++-   printf(1, "pipe1 ok\n");
++- }
++-@@ -394,9 +394,9 @@ preempt(void)
++-   kill(pid2);
++-   kill(pid3);
++-   printf(1, "wait... ");
++--  wait();
++--  wait();
++--  wait();
++-+  wait(NULL);
++-+  wait(NULL);
++-+  wait(NULL);
++-   printf(1, "preempt ok\n");
++- }
++- 
++-@@ -413,12 +413,12 @@ exitwait(void)
++-       return;
++-     }
++-     if(pid){
++--      if(wait() != pid){
++-+      if(wait(NULL) != pid){
++-         printf(1, "wait wrong pid\n");
++-         return;
++-       }
++-     } else {
++--      exit();
++-+      exit(145);
++-     }
++-   }
++-   printf(1, "exitwait ok\n");
++-@@ -447,13 +447,13 @@ mem(void)
++-     if(m1 == 0){
++-       printf(1, "couldn't allocate mem?!!\n");
++-       kill(ppid);
++--      exit();
++-+      exit(144);
++-     }
++-     free(m1);
++-     printf(1, "mem ok\n");
++--    exit();
++-+    exit(0);
++-   } else {
++--    wait();
++-+    wait(NULL);
++-   }
++- }
++- 
++-@@ -484,9 +484,9 @@ sharedfd(void)
++-     }
++-   }
++-   if(pid == 0)
++--    exit();
++-+    exit(142);
++-   else
++--    wait();
++-+    wait(NULL);
++-   close(fd);
++-   fd = open("sharedfd", 0);
++-   if(fd < 0){
++-@@ -508,7 +508,7 @@ sharedfd(void)
++-     printf(1, "sharedfd ok\n");
++-   } else {
++-     printf(1, "sharedfd oops %d %d\n", nc, np);
++--    exit();
++-+    exit(141);
++-   }
++- }
++- 
++-@@ -530,29 +530,29 @@ fourfiles(void)
++-     pid = fork();
++-     if(pid < 0){
++-       printf(1, "fork failed\n");
++--      exit();
++-+      exit(140);
++-     }
++- 
++-     if(pid == 0){
++-       fd = open(fname, O_CREATE | O_RDWR);
++-       if(fd < 0){
++-         printf(1, "create failed\n");
++--        exit();
++-+        exit(139);
++-       }
++- 
++-       memset(buf, '0'+pi, 512);
++-       for(i = 0; i < 12; i++){
++-         if((n = write(fd, buf, 500)) != 500){
++-           printf(1, "write failed %d\n", n);
++--          exit();
++-+          exit(138);
++-         }
++-       }
++--      exit();
++-+      exit(137);
++-     }
++-   }
++- 
++-   for(pi = 0; pi < 4; pi++){
++--    wait();
++-+    wait(NULL);
++-   }
++- 
++-   for(i = 0; i < 2; i++){
++-@@ -563,7 +563,7 @@ fourfiles(void)
++-       for(j = 0; j < n; j++){
++-         if(buf[j] != '0'+i){
++-           printf(1, "wrong char\n");
++--          exit();
++-+          exit(136);
++-         }
++-       }
++-       total += n;
++-@@ -571,7 +571,7 @@ fourfiles(void)
++-     close(fd);
++-     if(total != 12*500){
++-       printf(1, "wrong length %d\n", total);
++--      exit();
++-+      exit(135);
++-     }
++-     unlink(fname);
++-   }
++-@@ -593,7 +593,7 @@ createdelete(void)
++-     pid = fork();
++-     if(pid < 0){
++-       printf(1, "fork failed\n");
++--      exit();
++-+      exit(134);
++-     }
++- 
++-     if(pid == 0){
++-@@ -604,23 +604,23 @@ createdelete(void)
++-         fd = open(name, O_CREATE | O_RDWR);
++-         if(fd < 0){
++-           printf(1, "create failed\n");
++--          exit();
++-+          exit(133);
++-         }
++-         close(fd);
++-         if(i > 0 && (i % 2 ) == 0){
++-           name[1] = '0' + (i / 2);
++-           if(unlink(name) < 0){
++-             printf(1, "unlink failed\n");
++--            exit();
++-+            exit(132);
++-           }
++-         }
++-       }
++--      exit();
++-+      exit(131);
++-     }
++-   }
++- 
++-   for(pi = 0; pi < 4; pi++){
++--    wait();
++-+    wait(NULL);
++-   }
++- 
++-   name[0] = name[1] = name[2] = 0;
++-@@ -631,10 +631,10 @@ createdelete(void)
++-       fd = open(name, 0);
++-       if((i == 0 || i >= N/2) && fd < 0){
++-         printf(1, "oops createdelete %s didn't exist\n", name);
++--        exit();
++-+        exit(130);
++-       } else if((i >= 1 && i < N/2) && fd >= 0){
++-         printf(1, "oops createdelete %s did exist\n", name);
++--        exit();
++-+        exit(129);
++-       }
++-       if(fd >= 0)
++-         close(fd);
++-@@ -662,7 +662,7 @@ unlinkread(void)
++-   fd = open("unlinkread", O_CREATE | O_RDWR);
++-   if(fd < 0){
++-     printf(1, "create unlinkread failed\n");
++--    exit();
++-+    exit(128);
++-   }
++-   write(fd, "hello", 5);
++-   close(fd);
++-@@ -670,11 +670,11 @@ unlinkread(void)
++-   fd = open("unlinkread", O_RDWR);
++-   if(fd < 0){
++-     printf(1, "open unlinkread failed\n");
++--    exit();
++-+    exit(127);
++-   }
++-   if(unlink("unlinkread") != 0){
++-     printf(1, "unlink unlinkread failed\n");
++--    exit();
++-+    exit(126);
++-   }
++- 
++-   fd1 = open("unlinkread", O_CREATE | O_RDWR);
++-@@ -683,15 +683,15 @@ unlinkread(void)
++- 
++-   if(read(fd, buf, sizeof(buf)) != 5){
++-     printf(1, "unlinkread read failed");
++--    exit();
++-+    exit(125);
++-   }
++-   if(buf[0] != 'h'){
++-     printf(1, "unlinkread wrong data\n");
++--    exit();
++-+    exit(124);
++-   }
++-   if(write(fd, buf, 10) != 10){
++-     printf(1, "unlinkread write failed\n");
++--    exit();
++-+    exit(123);
++-   }
++-   close(fd);
++-   unlink("unlinkread");
++-@@ -711,50 +711,50 @@ linktest(void)
++-   fd = open("lf1", O_CREATE|O_RDWR);
++-   if(fd < 0){
++-     printf(1, "create lf1 failed\n");
++--    exit();
++-+    exit(122);
++-   }
++-   if(write(fd, "hello", 5) != 5){
++-     printf(1, "write lf1 failed\n");
++--    exit();
++-+    exit(121);
++-   }
++-   close(fd);
++- 
++-   if(link("lf1", "lf2") < 0){
++-     printf(1, "link lf1 lf2 failed\n");
++--    exit();
++-+    exit(120);
++-   }
++-   unlink("lf1");
++- 
++-   if(open("lf1", 0) >= 0){
++-     printf(1, "unlinked lf1 but it is still there!\n");
++--    exit();
++-+    exit(119);
++-   }
++- 
++-   fd = open("lf2", 0);
++-   if(fd < 0){
++-     printf(1, "open lf2 failed\n");
++--    exit();
++-+    exit(118);
++-   }
++-   if(read(fd, buf, sizeof(buf)) != 5){
++-     printf(1, "read lf2 failed\n");
++--    exit();
++-+    exit(117);
++-   }
++-   close(fd);
++- 
++-   if(link("lf2", "lf2") >= 0){
++-     printf(1, "link lf2 lf2 succeeded! oops\n");
++--    exit();
++-+    exit(116);
++-   }
++- 
++-   unlink("lf2");
++-   if(link("lf2", "lf1") >= 0){
++-     printf(1, "link non-existant succeeded! oops\n");
++--    exit();
++-+    exit(115);
++-   }
++- 
++-   if(link(".", "lf1") >= 0){
++-     printf(1, "link . lf1 succeeded! oops\n");
++--    exit();
++-+    exit(114);
++-   }
++- 
++-   printf(1, "linktest ok\n");
++-@@ -787,14 +787,14 @@ concreate(void)
++-       fd = open(file, O_CREATE | O_RDWR);
++-       if(fd < 0){
++-         printf(1, "concreate create %s failed\n", file);
++--        exit();
++-+        exit(113);
++-       }
++-       close(fd);
++-     }
++-     if(pid == 0)
++--      exit();
++-+      exit(112);
++-     else
++--      wait();
++-+      wait(NULL);
++-   }
++- 
++-   memset(fa, 0, sizeof(fa));
++-@@ -807,11 +807,11 @@ concreate(void)
++-       i = de.name[1] - '0';
++-       if(i < 0 || i >= sizeof(fa)){
++-         printf(1, "concreate weird file %s\n", de.name);
++--        exit();
++-+        exit(111);
++-       }
++-       if(fa[i]){
++-         printf(1, "concreate duplicate file %s\n", de.name);
++--        exit();
++-+        exit(110);
++-       }
++-       fa[i] = 1;
++-       n++;
++-@@ -821,7 +821,7 @@ concreate(void)
++- 
++-   if(n != 40){
++-     printf(1, "concreate not enough files in directory listing\n");
++--    exit();
++-+    exit(109);
++-   }
++- 
++-   for(i = 0; i < 40; i++){
++-@@ -829,7 +829,7 @@ concreate(void)
++-     pid = fork();
++-     if(pid < 0){
++-       printf(1, "fork failed\n");
++--      exit();
++-+      exit(108);
++-     }
++-     if(((i % 3) == 0 && pid == 0) ||
++-        ((i % 3) == 1 && pid != 0)){
++-@@ -844,9 +844,9 @@ concreate(void)
++-       unlink(file);
++-     }
++-     if(pid == 0)
++--      exit();
++-+      exit(107);
++-     else
++--      wait();
++-+      wait(NULL);
++-   }
++- 
++-   printf(1, "concreate ok\n");
++-@@ -865,7 +865,7 @@ linkunlink()
++-   pid = fork();
++-   if(pid < 0){
++-     printf(1, "fork failed\n");
++--    exit();
++-+    exit(106);
++-   }
++- 
++-   unsigned int x = (pid ? 1 : 97);
++-@@ -881,9 +881,9 @@ linkunlink()
++-   }
++- 
++-   if(pid)
++--    wait();
++-+    wait(NULL);
++-   else
++--    exit();
++-+    exit(105);
++- 
++-   printf(1, "linkunlink ok\n");
++- }
++-@@ -901,7 +901,7 @@ bigdir(void)
++-   fd = open("bd", O_CREATE);
++-   if(fd < 0){
++-     printf(1, "bigdir create failed\n");
++--    exit();
++-+    exit(104);
++-   }
++-   close(fd);
++- 
++-@@ -912,7 +912,7 @@ bigdir(void)
++-     name[3] = '\0';
++-     if(link("bd", name) != 0){
++-       printf(1, "bigdir link failed\n");
++--      exit();
++-+      exit(103);
++-     }
++-   }
++- 
++-@@ -924,7 +924,7 @@ bigdir(void)
++-     name[3] = '\0';
++-     if(unlink(name) != 0){
++-       printf(1, "bigdir unlink failed");
++--      exit();
++-+      exit(102);
++-     }
++-   }
++- 
++-@@ -941,31 +941,31 @@ subdir(void)
++-   unlink("ff");
++-   if(mkdir("dd") != 0){
++-     printf(1, "subdir mkdir dd failed\n");
++--    exit();
++-+    exit(101);
++-   }
++- 
++-   fd = open("dd/ff", O_CREATE | O_RDWR);
++-   if(fd < 0){
++-     printf(1, "create dd/ff failed\n");
++--    exit();
++-+    exit(100);
++-   }
++-   write(fd, "ff", 2);
++-   close(fd);
++- 
++-   if(unlink("dd") >= 0){
++-     printf(1, "unlink dd (non-empty dir) succeeded!\n");
++--    exit();
++-+    exit(99);
++-   }
++- 
++-   if(mkdir("/dd/dd") != 0){
++-     printf(1, "subdir mkdir dd/dd failed\n");
++--    exit();
++-+    exit(98);
++-   }
++- 
++-   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
++-   if(fd < 0){
++-     printf(1, "create dd/dd/ff failed\n");
++--    exit();
++-+    exit(97);
++-   }
++-   write(fd, "FF", 2);
++-   close(fd);
++-@@ -973,142 +973,142 @@ subdir(void)
++-   fd = open("dd/dd/../ff", 0);
++-   if(fd < 0){
++-     printf(1, "open dd/dd/../ff failed\n");
++--    exit();
++-+    exit(96);
++-   }
++-   cc = read(fd, buf, sizeof(buf));
++-   if(cc != 2 || buf[0] != 'f'){
++-     printf(1, "dd/dd/../ff wrong content\n");
++--    exit();
++-+    exit(95);
++-   }
++-   close(fd);
++- 
++-   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
++-     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
++--    exit();
++-+    exit(94);
++-   }
++- 
++-   if(unlink("dd/dd/ff") != 0){
++-     printf(1, "unlink dd/dd/ff failed\n");
++--    exit();
++-+    exit(93);
++-   }
++-   if(open("dd/dd/ff", O_RDONLY) >= 0){
++-     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
++--    exit();
++-+    exit(92);
++-   }
++- 
++-   if(chdir("dd") != 0){
++-     printf(1, "chdir dd failed\n");
++--    exit();
++-+    exit(91);
++-   }
++-   if(chdir("dd/../../dd") != 0){
++-     printf(1, "chdir dd/../../dd failed\n");
++--    exit();
++-+    exit(90);
++-   }
++-   if(chdir("dd/../../../dd") != 0){
++-     printf(1, "chdir dd/../../dd failed\n");
++--    exit();
++-+    exit(89);
++-   }
++-   if(chdir("./..") != 0){
++-     printf(1, "chdir ./.. failed\n");
++--    exit();
++-+    exit(88);
++-   }
++- 
++-   fd = open("dd/dd/ffff", 0);
++-   if(fd < 0){
++-     printf(1, "open dd/dd/ffff failed\n");
++--    exit();
++-+    exit(87);
++-   }
++-   if(read(fd, buf, sizeof(buf)) != 2){
++-     printf(1, "read dd/dd/ffff wrong len\n");
++--    exit();
++-+    exit(86);
++-   }
++-   close(fd);
++- 
++-   if(open("dd/dd/ff", O_RDONLY) >= 0){
++-     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++- 
++-   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
++-     printf(1, "create dd/ff/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
++-     printf(1, "create dd/xx/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(open("dd", O_CREATE) >= 0){
++-     printf(1, "create dd succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(open("dd", O_RDWR) >= 0){
++-     printf(1, "open dd rdwr succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(open("dd", O_WRONLY) >= 0){
++-     printf(1, "open dd wronly succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(link("dd/ff/ff", "dd/dd/xx") == 0){
++-     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(link("dd/xx/ff", "dd/dd/xx") == 0){
++-     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(link("dd/ff", "dd/dd/ffff") == 0){
++-     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(mkdir("dd/ff/ff") == 0){
++-     printf(1, "mkdir dd/ff/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(mkdir("dd/xx/ff") == 0){
++-     printf(1, "mkdir dd/xx/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(mkdir("dd/dd/ffff") == 0){
++-     printf(1, "mkdir dd/dd/ffff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dd/xx/ff") == 0){
++-     printf(1, "unlink dd/xx/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dd/ff/ff") == 0){
++-     printf(1, "unlink dd/ff/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(chdir("dd/ff") == 0){
++-     printf(1, "chdir dd/ff succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(chdir("dd/xx") == 0){
++-     printf(1, "chdir dd/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++- 
++-   if(unlink("dd/dd/ffff") != 0){
++-     printf(1, "unlink dd/dd/ff failed\n");
++--    exit();
++-+    exit(68);
++-   }
++-   if(unlink("dd/ff") != 0){
++-     printf(1, "unlink dd/ff failed\n");
++--    exit();
++-+    exit(67);
++-   }
++-   if(unlink("dd") == 0){
++-     printf(1, "unlink non-empty dd succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dd/dd") < 0){
++-     printf(1, "unlink dd/dd failed\n");
++--    exit();
++-+    exit(65);
++-   }
++-   if(unlink("dd") < 0){
++-     printf(1, "unlink dd failed\n");
++--    exit();
++-+    exit(64);
++-   }
++- 
++-   printf(1, "subdir ok\n");
++-@@ -1127,14 +1127,14 @@ bigwrite(void)
++-     fd = open("bigwrite", O_CREATE | O_RDWR);
++-     if(fd < 0){
++-       printf(1, "cannot create bigwrite\n");
++--      exit();
++-+      exit(63);
++-     }
++-     int i;
++-     for(i = 0; i < 2; i++){
++-       int cc = write(fd, buf, sz);
++-       if(cc != sz){
++-         printf(1, "write(%d) ret %d\n", sz, cc);
++--        exit();
++-+        exit(62);
++-       }
++-     }
++-     close(fd);
++-@@ -1155,13 +1155,13 @@ bigfile(void)
++-   fd = open("bigfile", O_CREATE | O_RDWR);
++-   if(fd < 0){
++-     printf(1, "cannot create bigfile");
++--    exit();
++-+    exit(61);
++-   }
++-   for(i = 0; i < 20; i++){
++-     memset(buf, i, 600);
++-     if(write(fd, buf, 600) != 600){
++-       printf(1, "write bigfile failed\n");
++--      exit();
++-+      exit(60);
++-     }
++-   }
++-   close(fd);
++-@@ -1169,31 +1169,31 @@ bigfile(void)
++-   fd = open("bigfile", 0);
++-   if(fd < 0){
++-     printf(1, "cannot open bigfile\n");
++--    exit();
++-+    exit(59);
++-   }
++-   total = 0;
++-   for(i = 0; ; i++){
++-     cc = read(fd, buf, 300);
++-     if(cc < 0){
++-       printf(1, "read bigfile failed\n");
++--      exit();
++-+      exit(58);
++-     }
++-     if(cc == 0)
++-       break;
++-     if(cc != 300){
++-       printf(1, "short read bigfile\n");
++--      exit();
++-+      exit(57);
++-     }
++-     if(buf[0] != i/2 || buf[299] != i/2){
++-       printf(1, "read bigfile wrong data\n");
++--      exit();
++-+      exit(56);
++-     }
++-     total += cc;
++-   }
++-   close(fd);
++-   if(total != 20*600){
++-     printf(1, "read bigfile wrong total\n");
++--    exit();
++-+    exit(55);
++-   }
++-   unlink("bigfile");
++- 
++-@@ -1210,32 +1210,32 @@ fourteen(void)
++- 
++-   if(mkdir("12345678901234") != 0){
++-     printf(1, "mkdir 12345678901234 failed\n");
++--    exit();
++-+    exit(54);
++-   }
++-   if(mkdir("12345678901234/123456789012345") != 0){
++-     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
++--    exit();
++-+    exit(53);
++-   }
++-   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
++-   if(fd < 0){
++-     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
++--    exit();
++-+    exit(52);
++-   }
++-   close(fd);
++-   fd = open("12345678901234/12345678901234/12345678901234", 0);
++-   if(fd < 0){
++-     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
++--    exit();
++-+    exit(51);
++-   }
++-   close(fd);
++- 
++-   if(mkdir("12345678901234/12345678901234") == 0){
++-     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(mkdir("123456789012345/12345678901234") == 0){
++-     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++- 
++-   printf(1, "fourteen ok\n");
++-@@ -1247,35 +1247,35 @@ rmdot(void)
++-   printf(1, "rmdot test\n");
++-   if(mkdir("dots") != 0){
++-     printf(1, "mkdir dots failed\n");
++--    exit();
++-+    exit(48);
++-   }
++-   if(chdir("dots") != 0){
++-     printf(1, "chdir dots failed\n");
++--    exit();
++-+    exit(47);
++-   }
++-   if(unlink(".") == 0){
++-     printf(1, "rm . worked!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("..") == 0){
++-     printf(1, "rm .. worked!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(chdir("/") != 0){
++-     printf(1, "chdir / failed\n");
++--    exit();
++-+    exit(44);
++-   }
++-   if(unlink("dots/.") == 0){
++-     printf(1, "unlink dots/. worked!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dots/..") == 0){
++-     printf(1, "unlink dots/.. worked!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dots") != 0){
++-     printf(1, "unlink dots failed!\n");
++--    exit();
++-+    exit(41);
++-   }
++-   printf(1, "rmdot ok\n");
++- }
++-@@ -1290,49 +1290,49 @@ dirfile(void)
++-   fd = open("dirfile", O_CREATE);
++-   if(fd < 0){
++-     printf(1, "create dirfile failed\n");
++--    exit();
++-+    exit(40);
++-   }
++-   close(fd);
++-   if(chdir("dirfile") == 0){
++-     printf(1, "chdir dirfile succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   fd = open("dirfile/xx", 0);
++-   if(fd >= 0){
++-     printf(1, "create dirfile/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   fd = open("dirfile/xx", O_CREATE);
++-   if(fd >= 0){
++-     printf(1, "create dirfile/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(mkdir("dirfile/xx") == 0){
++-     printf(1, "mkdir dirfile/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dirfile/xx") == 0){
++-     printf(1, "unlink dirfile/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(link("README", "dirfile/xx") == 0){
++-     printf(1, "link to dirfile/xx succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   if(unlink("dirfile") != 0){
++-     printf(1, "unlink dirfile failed!\n");
++--    exit();
++-+    exit(33);
++-   }
++- 
++-   fd = open(".", O_RDWR);
++-   if(fd >= 0){
++-     printf(1, "open . for writing succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   fd = open(".", 0);
++-   if(write(fd, "x", 1) > 0){
++-     printf(1, "write . succeeded!\n");
++--    exit();
++-+    exit(0);
++-   }
++-   close(fd);
++- 
++-@@ -1351,11 +1351,11 @@ iref(void)
++-   for(i = 0; i < 50 + 1; i++){
++-     if(mkdir("irefd") != 0){
++-       printf(1, "mkdir irefd failed\n");
++--      exit();
++-+      exit(30);
++-     }
++-     if(chdir("irefd") != 0){
++-       printf(1, "chdir irefd failed\n");
++--      exit();
++-+      exit(29);
++-     }
++- 
++-     mkdir("");
++-@@ -1388,24 +1388,24 @@ forktest(void)
++-     if(pid < 0)
++-       break;
++-     if(pid == 0)
++--      exit();
++-+      exit(28);
++-   }
++- 
++-   if(n == 1000){
++-     printf(1, "fork claimed to work 1000 times!\n");
++--    exit();
++-+    exit(27);
++-   }
++- 
++-   for(; n > 0; n--){
++--    if(wait() < 0){
++-+    if(wait(NULL) < 0){
++-       printf(1, "wait stopped early\n");
++--      exit();
++-+      exit(26);
++-     }
++-   }
++- 
++--  if(wait() != -1){
++-+  if(wait(NULL) != -1){
++-     printf(1, "wait got too many\n");
++--    exit();
++-+    exit(25);
++-   }
++- 
++-   printf(1, "fork test OK\n");
++-@@ -1428,7 +1428,7 @@ sbrktest(void)
++-     b = sbrk(1);
++-     if(b != a){
++-       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
++--      exit();
++-+      exit(24);
++-     }
++-     *b = 1;
++-     a = b + 1;
++-@@ -1436,17 +1436,17 @@ sbrktest(void)
++-   pid = fork();
++-   if(pid < 0){
++-     printf(stdout, "sbrk test fork failed\n");
++--    exit();
++-+    exit(23);
++-   }
++-   c = sbrk(1);
++-   c = sbrk(1);
++-   if(c != a + 1){
++-     printf(stdout, "sbrk test failed post-fork\n");
++--    exit();
++-+    exit(22);
++-   }
++-   if(pid == 0)
++--    exit();
++--  wait();
++-+    exit(21);
++-+  wait(NULL);
++- 
++-   // can one grow address space to something big?
++- #define BIG (100*1024*1024)
++-@@ -1455,7 +1455,7 @@ sbrktest(void)
++-   p = sbrk(amt);
++-   if (p != a) {
++-     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
++--    exit();
++-+    exit(20);
++-   }
++-   lastaddr = (char*) (BIG-1);
++-   *lastaddr = 99;
++-@@ -1465,12 +1465,12 @@ sbrktest(void)
++-   c = sbrk(-4096);
++-   if(c == (char*)0xffffffff){
++-     printf(stdout, "sbrk could not deallocate\n");
++--    exit();
++-+    exit(19);
++-   }
++-   c = sbrk(0);
++-   if(c != a - 4096){
++-     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
++--    exit();
++-+    exit(18);
++-   }
++- 
++-   // can one re-allocate that page?
++-@@ -1478,19 +1478,19 @@ sbrktest(void)
++-   c = sbrk(4096);
++-   if(c != a || sbrk(0) != a + 4096){
++-     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
++--    exit();
++-+    exit(17);
++-   }
++-   if(*lastaddr == 99){
++-     // should be zero
++-     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
++--    exit();
++-+    exit(16);
++-   }
++- 
++-   a = sbrk(0);
++-   c = sbrk(-(sbrk(0) - oldbrk));
++-   if(c != a){
++-     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
++--    exit();
++-+    exit(15);
++-   }
++- 
++-   // can we read the kernel's memory?
++-@@ -1499,21 +1499,21 @@ sbrktest(void)
++-     pid = fork();
++-     if(pid < 0){
++-       printf(stdout, "fork failed\n");
++--      exit();
++-+      exit(14);
++-     }
++-     if(pid == 0){
++-       printf(stdout, "oops could read %x = %x\n", a, *a);
++-       kill(ppid);
++--      exit();
++-+      exit(13);
++-     }
++--    wait();
++-+    wait(NULL);
++-   }
++- 
++-   // if we run the system out of memory, does it clean up the last
++-   // failed allocation?
++-   if(pipe(fds) != 0){
++-     printf(1, "pipe() failed\n");
++--    exit();
++-+    exit(12);
++-   }
++-   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
++-     if((pids[i] = fork()) == 0){
++-@@ -1533,11 +1533,11 @@ sbrktest(void)
++-     if(pids[i] == -1)
++-       continue;
++-     kill(pids[i]);
++--    wait();
++-+    wait(NULL);
++-   }
++-   if(c == (char*)0xffffffff){
++-     printf(stdout, "failed sbrk leaked memory\n");
++--    exit();
++-+    exit(10);
++-   }
++- 
++-   if(sbrk(0) > oldbrk)
++-@@ -1572,17 +1572,17 @@ validatetest(void)
++-     if((pid = fork()) == 0){
++-       // try to crash the kernel by passing in a badly placed integer
++-       validateint((int*)p);
++--      exit();
++-+      exit(9);
++-     }
++-     sleep(0);
++-     sleep(0);
++-     kill(pid);
++--    wait();
++-+    wait(NULL);
++- 
++-     // try to crash the kernel by passing in a bad string pointer
++-     if(link("nosuchfile", (char*)p) != -1){
++-       printf(stdout, "link should not succeed\n");
++--      exit();
++-+      exit(8);
++-     }
++-   }
++- 
++-@@ -1600,7 +1600,7 @@ bsstest(void)
++-   for(i = 0; i < sizeof(uninit); i++){
++-     if(uninit[i] != '\0'){
++-       printf(stdout, "bss test failed\n");
++--      exit();
++-+      exit(7);
++-     }
++-   }
++-   printf(stdout, "bss test ok\n");
++-@@ -1627,16 +1627,16 @@ bigargtest(void)
++-     printf(stdout, "bigarg test ok\n");
++-     fd = open("bigarg-ok", O_CREATE);
++-     close(fd);
++--    exit();
++-+    exit(6);
++-   } else if(pid < 0){
++-     printf(stdout, "bigargtest: fork failed\n");
++--    exit();
++-+    exit(5);
++-   }
++--  wait();
++-+  wait(NULL);
++-   fd = open("bigarg-ok", 0);
++-   if(fd < 0){
++-     printf(stdout, "bigarg test failed!\n");
++--    exit();
++-+    exit(4);
++-   }
++-   close(fd);
++-   unlink("bigarg-ok");
++-@@ -1715,12 +1715,12 @@ uio()
++-     port = RTC_DATA;
++-     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
++-     printf(1, "uio: uio succeeded; test FAILED\n");
++--    exit();
++-+    exit(3);
++-   } else if(pid < 0){
++-     printf (1, "fork failed\n");
++--    exit();
++-+    exit(2);
++-   }
++--  wait();
++-+  wait(NULL);
++-   printf(1, "uio test done\n");
++- }
++- 
++-@@ -1730,7 +1730,7 @@ void argptest()
++-   fd = open("init", O_RDONLY);
++-   if (fd < 0) {
++-     printf(2, "open failed\n");
++--    exit();
++-+    exit(1);
++-   }
++-   read(fd, sbrk(0) - 1, -1);
++-   close(fd);
++-@@ -1752,7 +1752,7 @@ main(int argc, char *argv[])
++- 
++-   if(open("usertests.ran", 0) >= 0){
++-     printf(1, "already ran user tests -- rebuild fs.img\n");
++--    exit();
++-+    exit(1);
++-   }
++-   close(open("usertests.ran", O_CREATE));
++- 
++-@@ -1799,5 +1799,5 @@ main(int argc, char *argv[])
++- 
++-   exectest();
++- 
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/usys.S b/usys.S
++-index 8bfd8a1..1687ed0 100644
++---- a/usys.S
++-+++ b/usys.S
++-@@ -11,6 +11,7 @@
++- SYSCALL(fork)
++- SYSCALL(exit)
++- SYSCALL(wait)
++-+SYSCALL(waitpid)
++- SYSCALL(pipe)
++- SYSCALL(read)
++- SYSCALL(write)
++-diff --git a/vectors.pl b/vectors.pl
++-old mode 100755
++-new mode 100644
++-diff --git a/wc.c b/wc.c
++-index d6a54df..08b93b6 100644
++---- a/wc.c
++-+++ b/wc.c
++-@@ -27,7 +27,7 @@ wc(int fd, char *name)
++-   }
++-   if(n < 0){
++-     printf(1, "wc: read error\n");
++--    exit();
++-+    exit(3);
++-   }
++-   printf(1, "%d %d %d %s\n", l, w, c, name);
++- }
++-@@ -39,16 +39,16 @@ main(int argc, char *argv[])
++- 
++-   if(argc <= 1){
++-     wc(0, "");
++--    exit();
++-+    exit(2);
++-   }
++- 
++-   for(i = 1; i < argc; i++){
++-     if((fd = open(argv[i], 0)) < 0){
++-       printf(1, "wc: cannot open %s\n", argv[i]);
++--      exit();
++-+      exit(1);
++-     }
++-     wc(fd, argv[i]);
++-     close(fd);
++-   }
++--  exit();
++-+  exit(0);
++- }
++-diff --git a/zombie.c b/zombie.c
++-index ee817da..c96b92d 100644
++---- a/zombie.c
++-+++ b/zombie.c
++-@@ -10,5 +10,5 @@ main(void)
++- {
++-   if(fork() > 0)
++-     sleep(5);  // Let child exit before parent.
++--  exit();
++-+  exit(0);
++- }
++diff --git a/defs.h b/defs.h
++index d1934ca..82fb982 100644
++--- a/defs.h
+++++ b/defs.h
++@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
++ //PAGEBREAK: 16
++ // proc.c
++ int             cpuid(void);
++-void            exit(int status);
+++void            exit(void);
++ int             fork(void);
++ int             growproc(int);
++ int             kill(int);
++@@ -117,8 +117,7 @@ void            sched(void);
++ void            setproc(struct proc*);
++ void            sleep(void*, struct spinlock*);
++ void            userinit(void);
++-int             wait(int* status);
++-int             waitpid(int pid, int* status, int options);
+++int             wait(void);
++ void            wakeup(void*);
++ void            yield(void);
++ 
++diff --git a/echo.c b/echo.c
++index eed68a0..806dee0 100644
++--- a/echo.c
+++++ b/echo.c
++@@ -9,5 +9,5 @@ main(int argc, char *argv[])
++ 
++   for(i = 1; i < argc; i++)
++     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
++-  exit(0);
+++  exit();
++ }
++diff --git a/forktest.c b/forktest.c
++index a4b35ed..8bc984d 100644
++--- a/forktest.c
+++++ b/forktest.c
++@@ -25,24 +25,24 @@ forktest(void)
++     if(pid < 0)
++       break;
++     if(pid == 0)
++-      exit(4);
+++      exit();
++   }
++ 
++   if(n == N){
++     printf(1, "fork claimed to work N times!\n", N);
++-    exit(3);
+++    exit();
++   }
++ 
++   for(; n > 0; n--){
++-    if(wait(NULL) < 0){
+++    if(wait() < 0){
++       printf(1, "wait stopped early\n");
++-      exit(2);
+++      exit();
++     }
++   }
++ 
++-  if(wait(NULL) != -1){
+++  if(wait() != -1){
++     printf(1, "wait got too many\n");
++-    exit(1);
+++    exit();
++   }
++ 
++   printf(1, "fork test OK\n");
++@@ -52,5 +52,5 @@ int
++ main(void)
++ {
++   forktest();
++-  exit(0);
+++  exit();
++ }
++diff --git a/grep.c b/grep.c
++index 4be3256..adc4835 100644
++--- a/grep.c
+++++ b/grep.c
++@@ -43,24 +43,24 @@ main(int argc, char *argv[])
++ 
++   if(argc <= 1){
++     printf(2, "usage: grep pattern [file ...]\n");
++-    exit(1);
+++    exit();
++   }
++   pattern = argv[1];
++ 
++   if(argc <= 2){
++     grep(pattern, 0);
++-    exit(2);
+++    exit();
++   }
++ 
++   for(i = 2; i < argc; i++){
++     if((fd = open(argv[i], 0)) < 0){
++       printf(1, "grep: cannot open %s\n", argv[i]);
++-      exit(3);
+++      exit();
++     }
++     grep(pattern, fd);
++     close(fd);
++   }
++-  exit(0);
+++  exit();
++ }
++ 
++ // Regexp matcher from Kernighan & Pike,
++diff --git a/init.c b/init.c
++index bc6547f..046b551 100644
++--- a/init.c
+++++ b/init.c
++@@ -24,14 +24,14 @@ main(void)
++     pid = fork();
++     if(pid < 0){
++       printf(1, "init: fork failed\n");
++-      exit(2);
+++      exit();
++     }
++     if(pid == 0){
++       exec("sh", argv);
++       printf(1, "init: exec sh failed\n");
++-      exit(1);
+++      exit();
++     }
++-    while((wpid=wait(NULL)) >= 0 && wpid != pid)
+++    while((wpid=wait()) >= 0 && wpid != pid)
++       printf(1, "zombie!\n");
++   }
++ }
++diff --git a/kill.c b/kill.c
++index 875916c..364f6af 100644
++--- a/kill.c
+++++ b/kill.c
++@@ -9,9 +9,9 @@ main(int argc, char **argv)
++ 
++   if(argc < 2){
++     printf(2, "usage: kill pid...\n");
++-    exit(1);
+++    exit();
++   }
++   for(i=1; i<argc; i++)
++     kill(atoi(argv[i]));
++-  exit(0);
+++  exit();
++ }
++diff --git a/lab1.c b/lab1.c
++deleted file mode 100644
++index 2192a52..0000000
++--- a/lab1.c
+++++ /dev/null
++@@ -1,69 +0,0 @@
++-// ------------------------------------------------------------
++-// steps to reproduce the hello program demo during lab session:
++-// ------------------------------------------------------------
++-// 1. Create new file named hello.c inside local copy of xv6 folder. Copy the source code below over.
++-// 2. Modify local Makefile to include this new user program to let xv6 recognize this new prog.
++-// add "_hello/" to variable UPROG
++-// 3. Make sure both hello.c and Makefile modifications are uploaded to remote copy;
++-// option1 (sync any changed file): tools -> deployment -> automatic upload (always);
++-// option2 (sync one specific file):
++-// choose the file to upload in project window -> tools -> deployment -> upload to <name of your deployment>
++-// 4. In a sledge terminal session:
++-// (after entering xv6 folder) $ make qemu-nox
++-// 5. Run new user program with command below:
++-// (xv6) $ hello
++-
++-#include "types.h"
++-#include "user.h"
++-
++-int main(int argc, char **argv) {
++-
++-    int pid;
++-
++-    pid = fork();
++-
++-    if(pid > 0)
++-    {
++-        waitpid(pid, NULL, 0);
++-        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
++-        exit(0);
++-    }
++-
++-
++-    pid = fork();
++-
++-    if(pid == 0)
++-    {
++-        printf(1, "I'm the child! PID: %d\n", pid);
++-    }
++-    else
++-    {
++-        printf(1, "I'm the parent! PID: %d\n", pid);
++-        waitpid(pid, NULL, 0);
++-
++-    }
++-
++-
++-    exit(0);
++-}
++-//    printf(1, "Waitpid Demo Initializing...\n"); // fd=1 means standard output.
++-//
++-//    int defValue = -1;
++-//    int* status = &defValue;
++-//
++-//    int pid = fork();
++-//
++-//
++-//    if(pid > 0)
++-//    while(waitpid(pid, status, 0) == -1);
++-//
++-//    if(pid == 0)
++-//    {
++-//        printf(1, "hi im the child :)\n"); // fd=1 means standard output.
++-//        exit(0);
++-//    }
++-//
++-//    printf(1, "Exit status returned is: %d\n", *status); // fd=1 means standard output.
++-//
++-//    exit(0);
++-//}
++diff --git a/ln.c b/ln.c
++index fb17c3b..cf8a64e 100644
++--- a/ln.c
+++++ b/ln.c
++@@ -7,9 +7,9 @@ main(int argc, char *argv[])
++ {
++   if(argc != 3){
++     printf(2, "Usage: ln old new\n");
++-    exit(1);
+++    exit();
++   }
++   if(link(argv[1], argv[2]) < 0)
++     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
++-  exit(0);
+++  exit();
++ }
++diff --git a/ls.c b/ls.c
++index 6bf943b..2862913 100644
++--- a/ls.c
+++++ b/ls.c
++@@ -77,9 +77,9 @@ main(int argc, char *argv[])
++ 
++   if(argc < 2){
++     ls(".");
++-    exit(1);
+++    exit();
++   }
++   for(i=1; i<argc; i++)
++     ls(argv[i]);
++-  exit(0);
+++  exit();
++ }
++diff --git a/mkdir.c b/mkdir.c
++index 2d90781..6e4c954 100644
++--- a/mkdir.c
+++++ b/mkdir.c
++@@ -9,7 +9,7 @@ main(int argc, char *argv[])
++ 
++   if(argc < 2){
++     printf(2, "Usage: mkdir files...\n");
++-    exit(1);
+++    exit();
++   }
++ 
++   for(i = 1; i < argc; i++){
++@@ -19,5 +19,5 @@ main(int argc, char *argv[])
++     }
++   }
++ 
++-  exit(0);
+++  exit();
++ }
++diff --git a/proc.c b/proc.c
++index 84b335f..806b1b1 100644
++--- a/proc.c
+++++ b/proc.c
++@@ -1,5 +1,3 @@
++-#include <stddef.h>
++-
++ #include "types.h"
++ #include "defs.h"
++ #include "param.h"
++@@ -10,61 +8,61 @@
++ #include "spinlock.h"
++ 
++ struct {
++-    struct spinlock lock;
++-    struct proc proc[NPROC];
+++  struct spinlock lock;
+++  struct proc proc[NPROC];
++ } ptable;
++ 
++ static struct proc *initproc;
++ 
++ int nextpid = 1;
++-
++ extern void forkret(void);
++-
++ extern void trapret(void);
++ 
++ static void wakeup1(void *chan);
++ 
++ void
++-pinit(void) {
++-    initlock(&ptable.lock, "ptable");
+++pinit(void)
+++{
+++  initlock(&ptable.lock, "ptable");
++ }
++ 
++ // Must be called with interrupts disabled
++ int
++ cpuid() {
++-    return mycpu() - cpus;
+++  return mycpu()-cpus;
++ }
++ 
++ // Must be called with interrupts disabled to avoid the caller being
++ // rescheduled between reading lapicid and running through the loop.
++-struct cpu *
++-mycpu(void) {
++-    int apicid, i;
++-
++-    if (readeflags() & FL_IF)
++-        panic("mycpu called with interrupts enabled\n");
++-
++-    apicid = lapicid();
++-    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
++-    // a reverse map, or reserve a register to store &cpus[i].
++-    for (i = 0; i < ncpu; ++i) {
++-        if (cpus[i].apicid == apicid)
++-            return &cpus[i];
++-    }
++-    panic("unknown apicid\n");
+++struct cpu*
+++mycpu(void)
+++{
+++  int apicid, i;
+++  
+++  if(readeflags()&FL_IF)
+++    panic("mycpu called with interrupts enabled\n");
+++  
+++  apicid = lapicid();
+++  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+++  // a reverse map, or reserve a register to store &cpus[i].
+++  for (i = 0; i < ncpu; ++i) {
+++    if (cpus[i].apicid == apicid)
+++      return &cpus[i];
+++  }
+++  panic("unknown apicid\n");
++ }
++ 
++ // Disable interrupts so that we are not rescheduled
++ // while reading proc from the cpu structure
++-struct proc *
+++struct proc*
++ myproc(void) {
++-    struct cpu *c;
++-    struct proc *p;
++-    pushcli();
++-    c = mycpu();
++-    p = c->proc;
++-    popcli();
++-    return p;
+++  struct cpu *c;
+++  struct proc *p;
+++  pushcli();
+++  c = mycpu();
+++  p = c->proc;
+++  popcli();
+++  return p;
++ }
++ 
++ //PAGEBREAK: 32
++@@ -72,295 +70,245 @@ myproc(void) {
++ // If found, change state to EMBRYO and initialize
++ // state required to run in the kernel.
++ // Otherwise return 0.
++-static struct proc *
++-allocproc(void) {
++-    struct proc *p;
++-    char *sp;
+++static struct proc*
+++allocproc(void)
+++{
+++  struct proc *p;
+++  char *sp;
++ 
++-    acquire(&ptable.lock);
+++  acquire(&ptable.lock);
++ 
++-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++-        if (p->state == UNUSED)
++-            goto found;
+++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+++    if(p->state == UNUSED)
+++      goto found;
++ 
++-    release(&ptable.lock);
++-    return 0;
+++  release(&ptable.lock);
+++  return 0;
++ 
++-    found:
++-    p->state = EMBRYO;
++-    p->pid = nextpid++;
+++found:
+++  p->state = EMBRYO;
+++  p->pid = nextpid++;
++ 
++-    release(&ptable.lock);
+++  release(&ptable.lock);
++ 
++-    // Allocate kernel stack.
++-    if ((p->kstack = kalloc()) == 0) {
++-        p->state = UNUSED;
++-        return 0;
++-    }
++-    sp = p->kstack + KSTACKSIZE;
+++  // Allocate kernel stack.
+++  if((p->kstack = kalloc()) == 0){
+++    p->state = UNUSED;
+++    return 0;
+++  }
+++  sp = p->kstack + KSTACKSIZE;
++ 
++-    // Leave room for trap frame.
++-    sp -= sizeof *p->tf;
++-    p->tf = (struct trapframe *) sp;
+++  // Leave room for trap frame.
+++  sp -= sizeof *p->tf;
+++  p->tf = (struct trapframe*)sp;
++ 
++-    // Set up new context to start executing at forkret,
++-    // which returns to trapret.
++-    sp -= 4;
++-    *(uint *) sp = (uint) trapret;
+++  // Set up new context to start executing at forkret,
+++  // which returns to trapret.
+++  sp -= 4;
+++  *(uint*)sp = (uint)trapret;
++ 
++-    sp -= sizeof *p->context;
++-    p->context = (struct context *) sp;
++-    memset(p->context, 0, sizeof *p->context);
++-    p->context->eip = (uint) forkret;
+++  sp -= sizeof *p->context;
+++  p->context = (struct context*)sp;
+++  memset(p->context, 0, sizeof *p->context);
+++  p->context->eip = (uint)forkret;
++ 
++-    return p;
+++  return p;
++ }
++ 
++ //PAGEBREAK: 32
++ // Set up first user process.
++ void
++-userinit(void) {
++-    struct proc *p;
++-    extern char _binary_initcode_start[], _binary_initcode_size[];
++-
++-    p = allocproc();
++-
++-    initproc = p;
++-    if ((p->pgdir = setupkvm()) == 0)
++-        panic("userinit: out of memory?");
++-    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
++-    p->sz = PGSIZE;
++-    memset(p->tf, 0, sizeof(*p->tf));
++-    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
++-    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
++-    p->tf->es = p->tf->ds;
++-    p->tf->ss = p->tf->ds;
++-    p->tf->eflags = FL_IF;
++-    p->tf->esp = PGSIZE;
++-    p->tf->eip = 0;  // beginning of initcode.S
++-
++-    safestrcpy(p->name, "initcode", sizeof(p->name));
++-    p->cwd = namei("/");
++-
++-    // this assignment to p->state lets other cores
++-    // run this process. the acquire forces the above
++-    // writes to be visible, and the lock is also needed
++-    // because the assignment might not be atomic.
++-    acquire(&ptable.lock);
++-
++-    p->state = RUNNABLE;
++-
++-    release(&ptable.lock);
+++userinit(void)
+++{
+++  struct proc *p;
+++  extern char _binary_initcode_start[], _binary_initcode_size[];
+++
+++  p = allocproc();
+++  
+++  initproc = p;
+++  if((p->pgdir = setupkvm()) == 0)
+++    panic("userinit: out of memory?");
+++  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+++  p->sz = PGSIZE;
+++  memset(p->tf, 0, sizeof(*p->tf));
+++  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+++  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+++  p->tf->es = p->tf->ds;
+++  p->tf->ss = p->tf->ds;
+++  p->tf->eflags = FL_IF;
+++  p->tf->esp = PGSIZE;
+++  p->tf->eip = 0;  // beginning of initcode.S
+++
+++  safestrcpy(p->name, "initcode", sizeof(p->name));
+++  p->cwd = namei("/");
+++
+++  // this assignment to p->state lets other cores
+++  // run this process. the acquire forces the above
+++  // writes to be visible, and the lock is also needed
+++  // because the assignment might not be atomic.
+++  acquire(&ptable.lock);
+++
+++  p->state = RUNNABLE;
+++
+++  release(&ptable.lock);
++ }
++ 
++ // Grow current process's memory by n bytes.
++ // Return 0 on success, -1 on failure.
++ int
++-growproc(int n) {
++-    uint sz;
++-    struct proc *curproc = myproc();
++-
++-    sz = curproc->sz;
++-    if (n > 0) {
++-        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
++-            return -1;
++-    } else if (n < 0) {
++-        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
++-            return -1;
++-    }
++-    curproc->sz = sz;
++-    switchuvm(curproc);
++-    return 0;
+++growproc(int n)
+++{
+++  uint sz;
+++  struct proc *curproc = myproc();
+++
+++  sz = curproc->sz;
+++  if(n > 0){
+++    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+++      return -1;
+++  } else if(n < 0){
+++    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+++      return -1;
+++  }
+++  curproc->sz = sz;
+++  switchuvm(curproc);
+++  return 0;
++ }
++ 
++ // Create a new process copying p as the parent.
++ // Sets up stack to return as if from system call.
++ // Caller must set state of returned proc to RUNNABLE.
++ int
++-fork(void) {
++-    int i, pid;
++-    struct proc *np;
++-    struct proc *curproc = myproc();
++-
++-    // Allocate process.
++-    if ((np = allocproc()) == 0) {
++-        return -1;
++-    }
+++fork(void)
+++{
+++  int i, pid;
+++  struct proc *np;
+++  struct proc *curproc = myproc();
+++
+++  // Allocate process.
+++  if((np = allocproc()) == 0){
+++    return -1;
+++  }
++ 
++-    // Copy process state from proc.
++-    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
++-        kfree(np->kstack);
++-        np->kstack = 0;
++-        np->state = UNUSED;
++-        return -1;
++-    }
++-    np->sz = curproc->sz;
++-    np->parent = curproc;
++-    *np->tf = *curproc->tf;
+++  // Copy process state from proc.
+++  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+++    kfree(np->kstack);
+++    np->kstack = 0;
+++    np->state = UNUSED;
+++    return -1;
+++  }
+++  np->sz = curproc->sz;
+++  np->parent = curproc;
+++  *np->tf = *curproc->tf;
++ 
++-    // Clear %eax so that fork returns 0 in the child.
++-    np->tf->eax = 0;
+++  // Clear %eax so that fork returns 0 in the child.
+++  np->tf->eax = 0;
++ 
++-    for (i = 0; i < NOFILE; i++)
++-        if (curproc->ofile[i])
++-            np->ofile[i] = filedup(curproc->ofile[i]);
++-    np->cwd = idup(curproc->cwd);
+++  for(i = 0; i < NOFILE; i++)
+++    if(curproc->ofile[i])
+++      np->ofile[i] = filedup(curproc->ofile[i]);
+++  np->cwd = idup(curproc->cwd);
++ 
++-    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+++  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
++ 
++-    pid = np->pid;
+++  pid = np->pid;
++ 
++-    acquire(&ptable.lock);
+++  acquire(&ptable.lock);
++ 
++-    np->state = RUNNABLE;
+++  np->state = RUNNABLE;
++ 
++-    release(&ptable.lock);
+++  release(&ptable.lock);
++ 
++-    return pid;
+++  return pid;
++ }
++ 
++ // Exit the current process.  Does not return.
++ // An exited process remains in the zombie state
++ // until its parent calls wait() to find out it exited.
++ void
++-exit(int status) {
++-    struct proc *curproc = myproc();
++-    struct proc *p;
++-    int fd;
++-
++-    curproc->status = status;
++-
++-    if (curproc == initproc)
++-        panic("init exiting");
++-
++-    // Close all open files.
++-    for (fd = 0; fd < NOFILE; fd++) {
++-        if (curproc->ofile[fd]) {
++-            fileclose(curproc->ofile[fd]);
++-            curproc->ofile[fd] = 0;
++-        }
+++exit(void)
+++{
+++  struct proc *curproc = myproc();
+++  struct proc *p;
+++  int fd;
+++
+++  if(curproc == initproc)
+++    panic("init exiting");
+++
+++  // Close all open files.
+++  for(fd = 0; fd < NOFILE; fd++){
+++    if(curproc->ofile[fd]){
+++      fileclose(curproc->ofile[fd]);
+++      curproc->ofile[fd] = 0;
++     }
+++  }
++ 
++-    begin_op();
++-    iput(curproc->cwd);
++-    end_op();
++-    curproc->cwd = 0;
+++  begin_op();
+++  iput(curproc->cwd);
+++  end_op();
+++  curproc->cwd = 0;
++ 
++-    acquire(&ptable.lock);
+++  acquire(&ptable.lock);
++ 
++-    // Parent might be sleeping in wait().
++-    wakeup1(curproc->parent);
+++  // Parent might be sleeping in wait().
+++  wakeup1(curproc->parent);
++ 
++-    // Pass abandoned children to init.
++-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-        if (p->parent == curproc) {
++-            p->parent = initproc;
++-            if (p->state == ZOMBIE)
++-                wakeup1(initproc);
++-        }
+++  // Pass abandoned children to init.
+++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+++    if(p->parent == curproc){
+++      p->parent = initproc;
+++      if(p->state == ZOMBIE)
+++        wakeup1(initproc);
++     }
+++  }
++ 
++-    // Jump into the scheduler, never to return.
++-    curproc->state = ZOMBIE;
++-    sched();
++-    panic("zombie exit");
+++  // Jump into the scheduler, never to return.
+++  curproc->state = ZOMBIE;
+++  sched();
+++  panic("zombie exit");
++ }
++ 
++ // Wait for a child process to exit and return its pid.
++ // Return -1 if this process has no children.
++ int
++-wait(int *status) {
++-    struct proc *p;
++-    int havekids, pid;
++-    struct proc *curproc = myproc();
++-
++-    acquire(&ptable.lock);
++-    for (;;) {
++-        // Scan through table looking for exited children.
++-        havekids = 0;
++-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-            if (p->parent != curproc)
++-                continue;
++-            havekids = 1;
++-            if (p->state == ZOMBIE) {
++-                // Found one.
++-                pid = p->pid;
++-                kfree(p->kstack);
++-                p->kstack = 0;
++-                freevm(p->pgdir);
++-                p->pid = 0;
++-                p->parent = 0;
++-                p->name[0] = 0;
++-                p->killed = 0;
++-                p->state = UNUSED;
++-                release(&ptable.lock);
++-                if (status != NULL)
++-                    *status = p->status;
++-                return pid;
++-            }
++-        }
++-
++-        // No point waiting if we don't have any children.
++-        if (!havekids || curproc->killed) {
++-            release(&ptable.lock);
++-            return -1;
++-        }
++-
++-        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
++-        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+++wait(void)
+++{
+++  struct proc *p;
+++  int havekids, pid;
+++  struct proc *curproc = myproc();
+++  
+++  acquire(&ptable.lock);
+++  for(;;){
+++    // Scan through table looking for exited children.
+++    havekids = 0;
+++    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+++      if(p->parent != curproc)
+++        continue;
+++      havekids = 1;
+++      if(p->state == ZOMBIE){
+++        // Found one.
+++        pid = p->pid;
+++        kfree(p->kstack);
+++        p->kstack = 0;
+++        freevm(p->pgdir);
+++        p->pid = 0;
+++        p->parent = 0;
+++        p->name[0] = 0;
+++        p->killed = 0;
+++        p->state = UNUSED;
+++        release(&ptable.lock);
+++        return pid;
+++      }
++     }
++-}
++ 
++-// Wait for a child process to exit and return its pid.
++-// Return -1 if this process has no children.
++-int
++-waitpid(int pidBeingSearchedFor, int *status, int options) {
++-    struct proc *p;
++-    int doesProcExist, pidFound;
++-    struct proc *curproc = myproc();
++-    acquire(&ptable.lock);
++-    for (;;) {
++-        // Scan through table looking for exited children.
++-        doesProcExist = 0;
++-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-//            if(p->parent != curproc)
++-//                continue;
++-
++-            if (p->pid != pidBeingSearchedFor)
++-                continue;
++-
++-            doesProcExist = 1;
++-            if (p->state == ZOMBIE) {
++-                // Found one.
++-                pidFound = p->pid;
++-                kfree(p->kstack);
++-                p->kstack = 0;
++-                freevm(p->pgdir);
++-                p->pid = 0;
++-                p->parent = 0;
++-                p->name[0] = 0;
++-                p->killed = 0;
++-                p->state = UNUSED;
++-                release(&ptable.lock);
++-                if (status != NULL)
++-                    *status = p->status;
++-                return pidFound;
++-            }
++-        }
++-
++-//        // No point waiting if we don't have any children.
++-//        if(!havekids || curproc->killed){
++-//            release(&ptable.lock);
++-//            return -1;
++-//        }
++-
++-        if (!doesProcExist || curproc->killed) {
++-            release(&ptable.lock);
++-            return -1;
++-        }
++-        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
++-        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+++    // No point waiting if we don't have any children.
+++    if(!havekids || curproc->killed){
+++      release(&ptable.lock);
+++      return -1;
++     }
+++
+++    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+++    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+++  }
++ }
++ 
++ //PAGEBREAK: 42
++@@ -372,38 +320,39 @@ waitpid(int pidBeingSearchedFor, int *status, int options) {
++ //  - eventually that process transfers control
++ //      via swtch back to the scheduler.
++ void
++-scheduler(void) {
++-    struct proc *p;
++-    struct cpu *c = mycpu();
++-    c->proc = 0;
++-
++-    for (;;) {
++-        // Enable interrupts on this processor.
++-        sti();
++-
++-        // Loop over process table looking for process to run.
++-        acquire(&ptable.lock);
++-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-            if (p->state != RUNNABLE)
++-                continue;
++-
++-            // Switch to chosen process.  It is the process's job
++-            // to release ptable.lock and then reacquire it
++-            // before jumping back to us.
++-            c->proc = p;
++-            switchuvm(p);
++-            p->state = RUNNING;
++-
++-            swtch(&(c->scheduler), p->context);
++-            switchkvm();
++-
++-            // Process is done running for now.
++-            // It should have changed its p->state before coming back.
++-            c->proc = 0;
++-        }
++-        release(&ptable.lock);
++-
+++scheduler(void)
+++{
+++  struct proc *p;
+++  struct cpu *c = mycpu();
+++  c->proc = 0;
+++  
+++  for(;;){
+++    // Enable interrupts on this processor.
+++    sti();
+++
+++    // Loop over process table looking for process to run.
+++    acquire(&ptable.lock);
+++    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+++      if(p->state != RUNNABLE)
+++        continue;
+++
+++      // Switch to chosen process.  It is the process's job
+++      // to release ptable.lock and then reacquire it
+++      // before jumping back to us.
+++      c->proc = p;
+++      switchuvm(p);
+++      p->state = RUNNING;
+++
+++      swtch(&(c->scheduler), p->context);
+++      switchkvm();
+++
+++      // Process is done running for now.
+++      // It should have changed its p->state before coming back.
+++      c->proc = 0;
++     }
+++    release(&ptable.lock);
+++
+++  }
++ }
++ 
++ // Enter scheduler.  Must hold only ptable.lock
++@@ -414,130 +363,137 @@ scheduler(void) {
++ // break in the few places where a lock is held but
++ // there's no process.
++ void
++-sched(void) {
++-    int intena;
++-    struct proc *p = myproc();
++-
++-    if (!holding(&ptable.lock))
++-        panic("sched ptable.lock");
++-    if (mycpu()->ncli != 1)
++-        panic("sched locks");
++-    if (p->state == RUNNING)
++-        panic("sched running");
++-    if (readeflags() & FL_IF)
++-        panic("sched interruptible");
++-    intena = mycpu()->intena;
++-    swtch(&p->context, mycpu()->scheduler);
++-    mycpu()->intena = intena;
+++sched(void)
+++{
+++  int intena;
+++  struct proc *p = myproc();
+++
+++  if(!holding(&ptable.lock))
+++    panic("sched ptable.lock");
+++  if(mycpu()->ncli != 1)
+++    panic("sched locks");
+++  if(p->state == RUNNING)
+++    panic("sched running");
+++  if(readeflags()&FL_IF)
+++    panic("sched interruptible");
+++  intena = mycpu()->intena;
+++  swtch(&p->context, mycpu()->scheduler);
+++  mycpu()->intena = intena;
++ }
++ 
++ // Give up the CPU for one scheduling round.
++ void
++-yield(void) {
++-    acquire(&ptable.lock);  //DOC: yieldlock
++-    myproc()->state = RUNNABLE;
++-    sched();
++-    release(&ptable.lock);
+++yield(void)
+++{
+++  acquire(&ptable.lock);  //DOC: yieldlock
+++  myproc()->state = RUNNABLE;
+++  sched();
+++  release(&ptable.lock);
++ }
++ 
++ // A fork child's very first scheduling by scheduler()
++ // will swtch here.  "Return" to user space.
++ void
++-forkret(void) {
++-    static int first = 1;
++-    // Still holding ptable.lock from scheduler.
++-    release(&ptable.lock);
++-
++-    if (first) {
++-        // Some initialization functions must be run in the context
++-        // of a regular process (e.g., they call sleep), and thus cannot
++-        // be run from main().
++-        first = 0;
++-        iinit(ROOTDEV);
++-        initlog(ROOTDEV);
++-    }
++-
++-    // Return to "caller", actually trapret (see allocproc).
+++forkret(void)
+++{
+++  static int first = 1;
+++  // Still holding ptable.lock from scheduler.
+++  release(&ptable.lock);
+++
+++  if (first) {
+++    // Some initialization functions must be run in the context
+++    // of a regular process (e.g., they call sleep), and thus cannot
+++    // be run from main().
+++    first = 0;
+++    iinit(ROOTDEV);
+++    initlog(ROOTDEV);
+++  }
+++
+++  // Return to "caller", actually trapret (see allocproc).
++ }
++ 
++ // Atomically release lock and sleep on chan.
++ // Reacquires lock when awakened.
++ void
++-sleep(void *chan, struct spinlock *lk) {
++-    struct proc *p = myproc();
++-
++-    if (p == 0)
++-        panic("sleep");
++-
++-    if (lk == 0)
++-        panic("sleep without lk");
++-
++-    // Must acquire ptable.lock in order to
++-    // change p->state and then call sched.
++-    // Once we hold ptable.lock, we can be
++-    // guaranteed that we won't miss any wakeup
++-    // (wakeup runs with ptable.lock locked),
++-    // so it's okay to release lk.
++-    if (lk != &ptable.lock) {  //DOC: sleeplock0
++-        acquire(&ptable.lock);  //DOC: sleeplock1
++-        release(lk);
++-    }
++-    // Go to sleep.
++-    p->chan = chan;
++-    p->state = SLEEPING;
++-
++-    sched();
++-
++-    // Tidy up.
++-    p->chan = 0;
++-
++-    // Reacquire original lock.
++-    if (lk != &ptable.lock) {  //DOC: sleeplock2
++-        release(&ptable.lock);
++-        acquire(lk);
++-    }
+++sleep(void *chan, struct spinlock *lk)
+++{
+++  struct proc *p = myproc();
+++  
+++  if(p == 0)
+++    panic("sleep");
+++
+++  if(lk == 0)
+++    panic("sleep without lk");
+++
+++  // Must acquire ptable.lock in order to
+++  // change p->state and then call sched.
+++  // Once we hold ptable.lock, we can be
+++  // guaranteed that we won't miss any wakeup
+++  // (wakeup runs with ptable.lock locked),
+++  // so it's okay to release lk.
+++  if(lk != &ptable.lock){  //DOC: sleeplock0
+++    acquire(&ptable.lock);  //DOC: sleeplock1
+++    release(lk);
+++  }
+++  // Go to sleep.
+++  p->chan = chan;
+++  p->state = SLEEPING;
+++
+++  sched();
+++
+++  // Tidy up.
+++  p->chan = 0;
+++
+++  // Reacquire original lock.
+++  if(lk != &ptable.lock){  //DOC: sleeplock2
+++    release(&ptable.lock);
+++    acquire(lk);
+++  }
++ }
++ 
++ //PAGEBREAK!
++ // Wake up all processes sleeping on chan.
++ // The ptable lock must be held.
++ static void
++-wakeup1(void *chan) {
++-    struct proc *p;
+++wakeup1(void *chan)
+++{
+++  struct proc *p;
++ 
++-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++-        if (p->state == SLEEPING && p->chan == chan)
++-            p->state = RUNNABLE;
+++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+++    if(p->state == SLEEPING && p->chan == chan)
+++      p->state = RUNNABLE;
++ }
++ 
++ // Wake up all processes sleeping on chan.
++ void
++-wakeup(void *chan) {
++-    acquire(&ptable.lock);
++-    wakeup1(chan);
++-    release(&ptable.lock);
+++wakeup(void *chan)
+++{
+++  acquire(&ptable.lock);
+++  wakeup1(chan);
+++  release(&ptable.lock);
++ }
++ 
++ // Kill the process with the given pid.
++ // Process won't exit until it returns
++ // to user space (see trap in trap.c).
++ int
++-kill(int pid) {
++-    struct proc *p;
++-
++-    acquire(&ptable.lock);
++-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-        if (p->pid == pid) {
++-            p->killed = 1;
++-            // Wake process from sleep if necessary.
++-            if (p->state == SLEEPING)
++-                p->state = RUNNABLE;
++-            release(&ptable.lock);
++-            return 0;
++-        }
+++kill(int pid)
+++{
+++  struct proc *p;
+++
+++  acquire(&ptable.lock);
+++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+++    if(p->pid == pid){
+++      p->killed = 1;
+++      // Wake process from sleep if necessary.
+++      if(p->state == SLEEPING)
+++        p->state = RUNNABLE;
+++      release(&ptable.lock);
+++      return 0;
++     }
++-    release(&ptable.lock);
++-    return -1;
+++  }
+++  release(&ptable.lock);
+++  return -1;
++ }
++ 
++ //PAGEBREAK: 36
++@@ -545,33 +501,34 @@ kill(int pid) {
++ // Runs when user types ^P on console.
++ // No lock to avoid wedging a stuck machine further.
++ void
++-procdump(void) {
++-    static char *states[] = {
++-            [UNUSED]    "unused",
++-            [EMBRYO]    "embryo",
++-            [SLEEPING]  "sleep ",
++-            [RUNNABLE]  "runble",
++-            [RUNNING]   "run   ",
++-            [ZOMBIE]    "zombie"
++-    };
++-    int i;
++-    struct proc *p;
++-    char *state;
++-    uint pc[10];
++-
++-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
++-        if (p->state == UNUSED)
++-            continue;
++-        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
++-            state = states[p->state];
++-        else
++-            state = "???";
++-        cprintf("%d %s %s", p->pid, state, p->name);
++-        if (p->state == SLEEPING) {
++-            getcallerpcs((uint *) p->context->ebp + 2, pc);
++-            for (i = 0; i < 10 && pc[i] != 0; i++)
++-                cprintf(" %p", pc[i]);
++-        }
++-        cprintf("\n");
+++procdump(void)
+++{
+++  static char *states[] = {
+++  [UNUSED]    "unused",
+++  [EMBRYO]    "embryo",
+++  [SLEEPING]  "sleep ",
+++  [RUNNABLE]  "runble",
+++  [RUNNING]   "run   ",
+++  [ZOMBIE]    "zombie"
+++  };
+++  int i;
+++  struct proc *p;
+++  char *state;
+++  uint pc[10];
+++
+++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+++    if(p->state == UNUSED)
+++      continue;
+++    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+++      state = states[p->state];
+++    else
+++      state = "???";
+++    cprintf("%d %s %s", p->pid, state, p->name);
+++    if(p->state == SLEEPING){
+++      getcallerpcs((uint*)p->context->ebp+2, pc);
+++      for(i=0; i<10 && pc[i] != 0; i++)
+++        cprintf(" %p", pc[i]);
++     }
+++    cprintf("\n");
+++  }
++ }
++diff --git a/proc.h b/proc.h
++index a06b921..1647114 100644
++--- a/proc.h
+++++ b/proc.h
++@@ -49,7 +49,6 @@ struct proc {
++   struct file *ofile[NOFILE];  // Open files
++   struct inode *cwd;           // Current directory
++   char name[16];               // Process name (debugging)
++-  int status;                  // Exit status
++ };
++ 
++ // Process memory is laid out contiguously, low addresses first:
++diff --git a/rm.c b/rm.c
++index 1e6daec..4fd33c8 100644
++--- a/rm.c
+++++ b/rm.c
++@@ -9,7 +9,7 @@ main(int argc, char *argv[])
++ 
++   if(argc < 2){
++     printf(2, "Usage: rm files...\n");
++-    exit(1);
+++    exit();
++   }
++ 
++   for(i = 1; i < argc; i++){
++@@ -19,5 +19,5 @@ main(int argc, char *argv[])
++     }
++   }
++ 
++-  exit(0);
+++  exit();
++ }
++diff --git a/sh.c b/sh.c
++index ca2ae37..054bab9 100644
++--- a/sh.c
+++++ b/sh.c
++@@ -65,7 +65,7 @@ runcmd(struct cmd *cmd)
++   struct redircmd *rcmd;
++ 
++   if(cmd == 0)
++-    exit(1);
+++    exit();
++ 
++   switch(cmd->type){
++   default:
++@@ -74,7 +74,7 @@ runcmd(struct cmd *cmd)
++   case EXEC:
++     ecmd = (struct execcmd*)cmd;
++     if(ecmd->argv[0] == 0)
++-      exit(2);
+++      exit();
++     exec(ecmd->argv[0], ecmd->argv);
++     printf(2, "exec %s failed\n", ecmd->argv[0]);
++     break;
++@@ -84,7 +84,7 @@ runcmd(struct cmd *cmd)
++     close(rcmd->fd);
++     if(open(rcmd->file, rcmd->mode) < 0){
++       printf(2, "open %s failed\n", rcmd->file);
++-      exit(6);
+++      exit();
++     }
++     runcmd(rcmd->cmd);
++     break;
++@@ -93,7 +93,7 @@ runcmd(struct cmd *cmd)
++     lcmd = (struct listcmd*)cmd;
++     if(fork1() == 0)
++       runcmd(lcmd->left);
++-    wait(NULL);
+++    wait();
++     runcmd(lcmd->right);
++     break;
++ 
++@@ -117,8 +117,8 @@ runcmd(struct cmd *cmd)
++     }
++     close(p[0]);
++     close(p[1]);
++-    wait(NULL);
++-    wait(NULL);
+++    wait();
+++    wait();
++     break;
++ 
++   case BACK:
++@@ -127,7 +127,7 @@ runcmd(struct cmd *cmd)
++       runcmd(bcmd->cmd);
++     break;
++   }
++-  exit(3);
+++  exit();
++ }
++ 
++ int
++@@ -166,16 +166,16 @@ main(void)
++     }
++     if(fork1() == 0)
++       runcmd(parsecmd(buf));
++-    wait(NULL);
+++    wait();
++   }
++-  exit(0);
+++  exit();
++ }
++ 
++ void
++ panic(char *s)
++ {
++   printf(2, "%s\n", s);
++-  exit(5);
+++  exit();
++ }
++ 
++ int
++diff --git a/stressfs.c b/stressfs.c
++index 46e0e66..c0a4743 100644
++--- a/stressfs.c
+++++ b/stressfs.c
++@@ -43,7 +43,7 @@ main(int argc, char *argv[])
++     read(fd, data, sizeof(data));
++   close(fd);
++ 
++-  wait(NULL);
+++  wait();
++ 
++-  exit(0);
+++  exit();
++ }
++diff --git a/syscall.c b/syscall.c
++index 41a8c3c..ee85261 100644
++--- a/syscall.c
+++++ b/syscall.c
++@@ -101,7 +101,6 @@ extern int sys_sbrk(void);
++ extern int sys_sleep(void);
++ extern int sys_unlink(void);
++ extern int sys_wait(void);
++-extern int sys_waitpid(void);
++ extern int sys_write(void);
++ extern int sys_uptime(void);
++ 
++@@ -109,7 +108,6 @@ static int (*syscalls[])(void) = {
++ [SYS_fork]    sys_fork,
++ [SYS_exit]    sys_exit,
++ [SYS_wait]    sys_wait,
++-[SYS_waitpid] sys_waitpid,
++ [SYS_pipe]    sys_pipe,
++ [SYS_read]    sys_read,
++ [SYS_kill]    sys_kill,
++diff --git a/syscall.h b/syscall.h
++index 374ff05..bc5f356 100644
++--- a/syscall.h
+++++ b/syscall.h
++@@ -1,23 +1,22 @@
++ // System call numbers
++-#define SYS_fork     1
++-#define SYS_exit     2
++-#define SYS_wait     3
++-#define SYS_pipe     4
++-#define SYS_read     5
++-#define SYS_kill     6
++-#define SYS_exec     7
++-#define SYS_fstat    8
++-#define SYS_chdir    9
++-#define SYS_dup     10
++-#define SYS_getpid  11
++-#define SYS_sbrk    12
++-#define SYS_sleep   13
++-#define SYS_uptime  14
++-#define SYS_open    15
++-#define SYS_write   16
++-#define SYS_mknod   17
++-#define SYS_unlink  18
++-#define SYS_link    19
++-#define SYS_mkdir   20
++-#define SYS_close   21
++-#define SYS_waitpid 22
++\ No newline at end of file
+++#define SYS_fork    1
+++#define SYS_exit    2
+++#define SYS_wait    3
+++#define SYS_pipe    4
+++#define SYS_read    5
+++#define SYS_kill    6
+++#define SYS_exec    7
+++#define SYS_fstat   8
+++#define SYS_chdir   9
+++#define SYS_dup    10
+++#define SYS_getpid 11
+++#define SYS_sbrk   12
+++#define SYS_sleep  13
+++#define SYS_uptime 14
+++#define SYS_open   15
+++#define SYS_write  16
+++#define SYS_mknod  17
+++#define SYS_unlink 18
+++#define SYS_link   19
+++#define SYS_mkdir  20
+++#define SYS_close  21
++diff --git a/sysproc.c b/sysproc.c
++index ebccf84..0686d29 100644
++--- a/sysproc.c
+++++ b/sysproc.c
++@@ -14,22 +14,16 @@ sys_fork(void)
++ }
++ 
++ int
++-sys_exit(int status)
+++sys_exit(void)
++ {
++-  exit(status);
+++  exit();
++   return 0;  // not reached
++ }
++ 
++ int
++-sys_wait(int* status)
+++sys_wait(void)
++ {
++-  return wait(status);
++-}
++-
++-int
++-sys_waitpid(int pid, int* status, int options)
++-{
++-    return waitpid(pid, status, options);
+++  return wait();
++ }
++ 
++ int
++diff --git a/trap.c b/trap.c
++index 432ea5b..41c66eb 100644
++--- a/trap.c
+++++ b/trap.c
++@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
++ {
++   if(tf->trapno == T_SYSCALL){
++     if(myproc()->killed)
++-      exit(4);
+++      exit();
++     myproc()->tf = tf;
++     syscall();
++     if(myproc()->killed)
++-      exit(3);
+++      exit();
++     return;
++   }
++ 
++@@ -98,7 +98,7 @@ trap(struct trapframe *tf)
++   // (If it is still executing in the kernel, let it keep running
++   // until it gets to the regular system call return.)
++   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
++-    exit(2);
+++    exit();
++ 
++   // Force process to give up CPU on clock tick.
++   // If interrupts were on while locks held, would need to check nlock.
++@@ -108,5 +108,5 @@ trap(struct trapframe *tf)
++ 
++   // Check if the process has been killed since we yielded
++   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
++-    exit(1);
+++    exit();
++ }
++diff --git a/user.h b/user.h
++index 0931387..4f99c52 100644
++--- a/user.h
+++++ b/user.h
++@@ -1,13 +1,10 @@
++-#include <stddef.h>
++-
++ struct stat;
++ struct rtcdate;
++ 
++ // system calls
++ int fork(void);
++-int exit(int status) __attribute__((noreturn));
++-int wait(int* status);
++-int waitpid(int pid, int* status, int options);
+++int exit(void) __attribute__((noreturn));
+++int wait(void);
++ int pipe(int*);
++ int write(int, const void*, int);
++ int read(int, void*, int);
++diff --git a/usertests.c b/usertests.c
++index 2c2c128..a1e97e7 100644
++--- a/usertests.c
+++++ b/usertests.c
++@@ -21,19 +21,19 @@ iputtest(void)
++ 
++   if(mkdir("iputdir") < 0){
++     printf(stdout, "mkdir failed\n");
++-    exit(184);
+++    exit();
++   }
++   if(chdir("iputdir") < 0){
++     printf(stdout, "chdir iputdir failed\n");
++-    exit(183);
+++    exit();
++   }
++   if(unlink("../iputdir") < 0){
++     printf(stdout, "unlink ../iputdir failed\n");
++-    exit(182);
+++    exit();
++   }
++   if(chdir("/") < 0){
++     printf(stdout, "chdir / failed\n");
++-    exit(181);
+++    exit();
++   }
++   printf(stdout, "iput test ok\n");
++ }
++@@ -49,24 +49,24 @@ exitiputtest(void)
++   pid = fork();
++   if(pid < 0){
++     printf(stdout, "fork failed\n");
++-    exit(180);
+++    exit();
++   }
++   if(pid == 0){
++     if(mkdir("iputdir") < 0){
++       printf(stdout, "mkdir failed\n");
++-      exit(179);
+++      exit();
++     }
++     if(chdir("iputdir") < 0){
++       printf(stdout, "child chdir failed\n");
++-      exit(178);
+++      exit();
++     }
++     if(unlink("../iputdir") < 0){
++       printf(stdout, "unlink ../iputdir failed\n");
++-      exit(177);
+++      exit();
++     }
++-    exit(176);
+++    exit();
++   }
++-  wait(NULL);
+++  wait();
++   printf(stdout, "exitiput test ok\n");
++ }
++ 
++@@ -89,27 +89,27 @@ openiputtest(void)
++   printf(stdout, "openiput test\n");
++   if(mkdir("oidir") < 0){
++     printf(stdout, "mkdir oidir failed\n");
++-    exit(175);
+++    exit();
++   }
++   pid = fork();
++   if(pid < 0){
++     printf(stdout, "fork failed\n");
++-    exit(174);
+++    exit();
++   }
++   if(pid == 0){
++     int fd = open("oidir", O_RDWR);
++     if(fd >= 0){
++       printf(stdout, "open directory for write succeeded\n");
++-      exit(0);
+++      exit();
++     }
++-    exit(172);
+++    exit();
++   }
++   sleep(1);
++   if(unlink("oidir") != 0){
++     printf(stdout, "unlink failed\n");
++-    exit(171);
+++    exit();
++   }
++-  wait(NULL);
+++  wait();
++   printf(stdout, "openiput test ok\n");
++ }
++ 
++@@ -124,13 +124,13 @@ opentest(void)
++   fd = open("echo", 0);
++   if(fd < 0){
++     printf(stdout, "open echo failed!\n");
++-    exit(170);
+++    exit();
++   }
++   close(fd);
++   fd = open("doesnotexist", 0);
++   if(fd >= 0){
++     printf(stdout, "open doesnotexist succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   printf(stdout, "open test ok\n");
++ }
++@@ -147,16 +147,16 @@ writetest(void)
++     printf(stdout, "creat small succeeded; ok\n");
++   } else {
++     printf(stdout, "error: creat small failed!\n");
++-    exit(168);
+++    exit();
++   }
++   for(i = 0; i < 100; i++){
++     if(write(fd, "aaaaaaaaaa", 10) != 10){
++       printf(stdout, "error: write aa %d new file failed\n", i);
++-      exit(167);
+++      exit();
++     }
++     if(write(fd, "bbbbbbbbbb", 10) != 10){
++       printf(stdout, "error: write bb %d new file failed\n", i);
++-      exit(166);
+++      exit();
++     }
++   }
++   printf(stdout, "writes ok\n");
++@@ -166,20 +166,20 @@ writetest(void)
++     printf(stdout, "open small succeeded ok\n");
++   } else {
++     printf(stdout, "error: open small failed!\n");
++-    exit(165);
+++    exit();
++   }
++   i = read(fd, buf, 2000);
++   if(i == 2000){
++     printf(stdout, "read succeeded ok\n");
++   } else {
++     printf(stdout, "read failed\n");
++-    exit(164);
+++    exit();
++   }
++   close(fd);
++ 
++   if(unlink("small") < 0){
++     printf(stdout, "unlink small failed\n");
++-    exit(163);
+++    exit();
++   }
++   printf(stdout, "small file test ok\n");
++ }
++@@ -194,14 +194,14 @@ writetest1(void)
++   fd = open("big", O_CREATE|O_RDWR);
++   if(fd < 0){
++     printf(stdout, "error: creat big failed!\n");
++-    exit(162);
+++    exit();
++   }
++ 
++   for(i = 0; i < MAXFILE; i++){
++     ((int*)buf)[0] = i;
++     if(write(fd, buf, 512) != 512){
++       printf(stdout, "error: write big file failed\n", i);
++-      exit(161);
+++      exit();
++     }
++   }
++ 
++@@ -210,7 +210,7 @@ writetest1(void)
++   fd = open("big", O_RDONLY);
++   if(fd < 0){
++     printf(stdout, "error: open big failed!\n");
++-    exit(160);
+++    exit();
++   }
++ 
++   n = 0;
++@@ -219,24 +219,24 @@ writetest1(void)
++     if(i == 0){
++       if(n == MAXFILE - 1){
++         printf(stdout, "read only %d blocks from big", n);
++-        exit(159);
+++        exit();
++       }
++       break;
++     } else if(i != 512){
++       printf(stdout, "read failed %d\n", i);
++-      exit(158);
+++      exit();
++     }
++     if(((int*)buf)[0] != n){
++       printf(stdout, "read content of block %d is %d\n",
++              n, ((int*)buf)[0]);
++-      exit(157);
+++      exit();
++     }
++     n++;
++   }
++   close(fd);
++   if(unlink("big") < 0){
++     printf(stdout, "unlink big failed\n");
++-    exit(156);
+++    exit();
++   }
++   printf(stdout, "big files ok\n");
++ }
++@@ -270,22 +270,22 @@ void dirtest(void)
++ 
++   if(mkdir("dir0") < 0){
++     printf(stdout, "mkdir failed\n");
++-    exit(155);
+++    exit();
++   }
++ 
++   if(chdir("dir0") < 0){
++     printf(stdout, "chdir dir0 failed\n");
++-    exit(154);
+++    exit();
++   }
++ 
++   if(chdir("..") < 0){
++     printf(stdout, "chdir .. failed\n");
++-    exit(153);
+++    exit();
++   }
++ 
++   if(unlink("dir0") < 0){
++     printf(stdout, "unlink dir0 failed\n");
++-    exit(152);
+++    exit();
++   }
++   printf(stdout, "mkdir test ok\n");
++ }
++@@ -296,7 +296,7 @@ exectest(void)
++   printf(stdout, "exec test\n");
++   if(exec("echo", echoargv) < 0){
++     printf(stdout, "exec echo failed\n");
++-    exit(151);
+++    exit();
++   }
++ }
++ 
++@@ -310,7 +310,7 @@ pipe1(void)
++ 
++   if(pipe(fds) != 0){
++     printf(1, "pipe() failed\n");
++-    exit(150);
+++    exit();
++   }
++   pid = fork();
++   seq = 0;
++@@ -321,10 +321,10 @@ pipe1(void)
++         buf[i] = seq++;
++       if(write(fds[1], buf, 1033) != 1033){
++         printf(1, "pipe1 oops 1\n");
++-        exit(149);
+++        exit();
++       }
++     }
++-    exit(148);
+++    exit();
++   } else if(pid > 0){
++     close(fds[1]);
++     total = 0;
++@@ -343,13 +343,13 @@ pipe1(void)
++     }
++     if(total != 5 * 1033){
++       printf(1, "pipe1 oops 3 total %d\n", total);
++-      exit(147);
+++      exit();
++     }
++     close(fds[0]);
++-    wait(NULL);
+++    wait();
++   } else {
++     printf(1, "fork() failed\n");
++-    exit(146);
+++    exit();
++   }
++   printf(1, "pipe1 ok\n");
++ }
++@@ -394,9 +394,9 @@ preempt(void)
++   kill(pid2);
++   kill(pid3);
++   printf(1, "wait... ");
++-  wait(NULL);
++-  wait(NULL);
++-  wait(NULL);
+++  wait();
+++  wait();
+++  wait();
++   printf(1, "preempt ok\n");
++ }
++ 
++@@ -413,12 +413,12 @@ exitwait(void)
++       return;
++     }
++     if(pid){
++-      if(wait(NULL) != pid){
+++      if(wait() != pid){
++         printf(1, "wait wrong pid\n");
++         return;
++       }
++     } else {
++-      exit(145);
+++      exit();
++     }
++   }
++   printf(1, "exitwait ok\n");
++@@ -447,13 +447,13 @@ mem(void)
++     if(m1 == 0){
++       printf(1, "couldn't allocate mem?!!\n");
++       kill(ppid);
++-      exit(144);
+++      exit();
++     }
++     free(m1);
++     printf(1, "mem ok\n");
++-    exit(0);
+++    exit();
++   } else {
++-    wait(NULL);
+++    wait();
++   }
++ }
++ 
++@@ -484,9 +484,9 @@ sharedfd(void)
++     }
++   }
++   if(pid == 0)
++-    exit(142);
+++    exit();
++   else
++-    wait(NULL);
+++    wait();
++   close(fd);
++   fd = open("sharedfd", 0);
++   if(fd < 0){
++@@ -508,7 +508,7 @@ sharedfd(void)
++     printf(1, "sharedfd ok\n");
++   } else {
++     printf(1, "sharedfd oops %d %d\n", nc, np);
++-    exit(141);
+++    exit();
++   }
++ }
++ 
++@@ -530,29 +530,29 @@ fourfiles(void)
++     pid = fork();
++     if(pid < 0){
++       printf(1, "fork failed\n");
++-      exit(140);
+++      exit();
++     }
++ 
++     if(pid == 0){
++       fd = open(fname, O_CREATE | O_RDWR);
++       if(fd < 0){
++         printf(1, "create failed\n");
++-        exit(139);
+++        exit();
++       }
++ 
++       memset(buf, '0'+pi, 512);
++       for(i = 0; i < 12; i++){
++         if((n = write(fd, buf, 500)) != 500){
++           printf(1, "write failed %d\n", n);
++-          exit(138);
+++          exit();
++         }
++       }
++-      exit(137);
+++      exit();
++     }
++   }
++ 
++   for(pi = 0; pi < 4; pi++){
++-    wait(NULL);
+++    wait();
++   }
++ 
++   for(i = 0; i < 2; i++){
++@@ -563,7 +563,7 @@ fourfiles(void)
++       for(j = 0; j < n; j++){
++         if(buf[j] != '0'+i){
++           printf(1, "wrong char\n");
++-          exit(136);
+++          exit();
++         }
++       }
++       total += n;
++@@ -571,7 +571,7 @@ fourfiles(void)
++     close(fd);
++     if(total != 12*500){
++       printf(1, "wrong length %d\n", total);
++-      exit(135);
+++      exit();
++     }
++     unlink(fname);
++   }
++@@ -593,7 +593,7 @@ createdelete(void)
++     pid = fork();
++     if(pid < 0){
++       printf(1, "fork failed\n");
++-      exit(134);
+++      exit();
++     }
++ 
++     if(pid == 0){
++@@ -604,23 +604,23 @@ createdelete(void)
++         fd = open(name, O_CREATE | O_RDWR);
++         if(fd < 0){
++           printf(1, "create failed\n");
++-          exit(133);
+++          exit();
++         }
++         close(fd);
++         if(i > 0 && (i % 2 ) == 0){
++           name[1] = '0' + (i / 2);
++           if(unlink(name) < 0){
++             printf(1, "unlink failed\n");
++-            exit(132);
+++            exit();
++           }
++         }
++       }
++-      exit(131);
+++      exit();
++     }
++   }
++ 
++   for(pi = 0; pi < 4; pi++){
++-    wait(NULL);
+++    wait();
++   }
++ 
++   name[0] = name[1] = name[2] = 0;
++@@ -631,10 +631,10 @@ createdelete(void)
++       fd = open(name, 0);
++       if((i == 0 || i >= N/2) && fd < 0){
++         printf(1, "oops createdelete %s didn't exist\n", name);
++-        exit(130);
+++        exit();
++       } else if((i >= 1 && i < N/2) && fd >= 0){
++         printf(1, "oops createdelete %s did exist\n", name);
++-        exit(129);
+++        exit();
++       }
++       if(fd >= 0)
++         close(fd);
++@@ -662,7 +662,7 @@ unlinkread(void)
++   fd = open("unlinkread", O_CREATE | O_RDWR);
++   if(fd < 0){
++     printf(1, "create unlinkread failed\n");
++-    exit(128);
+++    exit();
++   }
++   write(fd, "hello", 5);
++   close(fd);
++@@ -670,11 +670,11 @@ unlinkread(void)
++   fd = open("unlinkread", O_RDWR);
++   if(fd < 0){
++     printf(1, "open unlinkread failed\n");
++-    exit(127);
+++    exit();
++   }
++   if(unlink("unlinkread") != 0){
++     printf(1, "unlink unlinkread failed\n");
++-    exit(126);
+++    exit();
++   }
++ 
++   fd1 = open("unlinkread", O_CREATE | O_RDWR);
++@@ -683,15 +683,15 @@ unlinkread(void)
++ 
++   if(read(fd, buf, sizeof(buf)) != 5){
++     printf(1, "unlinkread read failed");
++-    exit(125);
+++    exit();
++   }
++   if(buf[0] != 'h'){
++     printf(1, "unlinkread wrong data\n");
++-    exit(124);
+++    exit();
++   }
++   if(write(fd, buf, 10) != 10){
++     printf(1, "unlinkread write failed\n");
++-    exit(123);
+++    exit();
++   }
++   close(fd);
++   unlink("unlinkread");
++@@ -711,50 +711,50 @@ linktest(void)
++   fd = open("lf1", O_CREATE|O_RDWR);
++   if(fd < 0){
++     printf(1, "create lf1 failed\n");
++-    exit(122);
+++    exit();
++   }
++   if(write(fd, "hello", 5) != 5){
++     printf(1, "write lf1 failed\n");
++-    exit(121);
+++    exit();
++   }
++   close(fd);
++ 
++   if(link("lf1", "lf2") < 0){
++     printf(1, "link lf1 lf2 failed\n");
++-    exit(120);
+++    exit();
++   }
++   unlink("lf1");
++ 
++   if(open("lf1", 0) >= 0){
++     printf(1, "unlinked lf1 but it is still there!\n");
++-    exit(119);
+++    exit();
++   }
++ 
++   fd = open("lf2", 0);
++   if(fd < 0){
++     printf(1, "open lf2 failed\n");
++-    exit(118);
+++    exit();
++   }
++   if(read(fd, buf, sizeof(buf)) != 5){
++     printf(1, "read lf2 failed\n");
++-    exit(117);
+++    exit();
++   }
++   close(fd);
++ 
++   if(link("lf2", "lf2") >= 0){
++     printf(1, "link lf2 lf2 succeeded! oops\n");
++-    exit(116);
+++    exit();
++   }
++ 
++   unlink("lf2");
++   if(link("lf2", "lf1") >= 0){
++     printf(1, "link non-existant succeeded! oops\n");
++-    exit(115);
+++    exit();
++   }
++ 
++   if(link(".", "lf1") >= 0){
++     printf(1, "link . lf1 succeeded! oops\n");
++-    exit(114);
+++    exit();
++   }
++ 
++   printf(1, "linktest ok\n");
++@@ -787,14 +787,14 @@ concreate(void)
++       fd = open(file, O_CREATE | O_RDWR);
++       if(fd < 0){
++         printf(1, "concreate create %s failed\n", file);
++-        exit(113);
+++        exit();
++       }
++       close(fd);
++     }
++     if(pid == 0)
++-      exit(112);
+++      exit();
++     else
++-      wait(NULL);
+++      wait();
++   }
++ 
++   memset(fa, 0, sizeof(fa));
++@@ -807,11 +807,11 @@ concreate(void)
++       i = de.name[1] - '0';
++       if(i < 0 || i >= sizeof(fa)){
++         printf(1, "concreate weird file %s\n", de.name);
++-        exit(111);
+++        exit();
++       }
++       if(fa[i]){
++         printf(1, "concreate duplicate file %s\n", de.name);
++-        exit(110);
+++        exit();
++       }
++       fa[i] = 1;
++       n++;
++@@ -821,7 +821,7 @@ concreate(void)
++ 
++   if(n != 40){
++     printf(1, "concreate not enough files in directory listing\n");
++-    exit(109);
+++    exit();
++   }
++ 
++   for(i = 0; i < 40; i++){
++@@ -829,7 +829,7 @@ concreate(void)
++     pid = fork();
++     if(pid < 0){
++       printf(1, "fork failed\n");
++-      exit(108);
+++      exit();
++     }
++     if(((i % 3) == 0 && pid == 0) ||
++        ((i % 3) == 1 && pid != 0)){
++@@ -844,9 +844,9 @@ concreate(void)
++       unlink(file);
++     }
++     if(pid == 0)
++-      exit(107);
+++      exit();
++     else
++-      wait(NULL);
+++      wait();
++   }
++ 
++   printf(1, "concreate ok\n");
++@@ -865,7 +865,7 @@ linkunlink()
++   pid = fork();
++   if(pid < 0){
++     printf(1, "fork failed\n");
++-    exit(106);
+++    exit();
++   }
++ 
++   unsigned int x = (pid ? 1 : 97);
++@@ -881,9 +881,9 @@ linkunlink()
++   }
++ 
++   if(pid)
++-    wait(NULL);
+++    wait();
++   else
++-    exit(105);
+++    exit();
++ 
++   printf(1, "linkunlink ok\n");
++ }
++@@ -901,7 +901,7 @@ bigdir(void)
++   fd = open("bd", O_CREATE);
++   if(fd < 0){
++     printf(1, "bigdir create failed\n");
++-    exit(104);
+++    exit();
++   }
++   close(fd);
++ 
++@@ -912,7 +912,7 @@ bigdir(void)
++     name[3] = '\0';
++     if(link("bd", name) != 0){
++       printf(1, "bigdir link failed\n");
++-      exit(103);
+++      exit();
++     }
++   }
++ 
++@@ -924,7 +924,7 @@ bigdir(void)
++     name[3] = '\0';
++     if(unlink(name) != 0){
++       printf(1, "bigdir unlink failed");
++-      exit(102);
+++      exit();
++     }
++   }
++ 
++@@ -941,31 +941,31 @@ subdir(void)
++   unlink("ff");
++   if(mkdir("dd") != 0){
++     printf(1, "subdir mkdir dd failed\n");
++-    exit(101);
+++    exit();
++   }
++ 
++   fd = open("dd/ff", O_CREATE | O_RDWR);
++   if(fd < 0){
++     printf(1, "create dd/ff failed\n");
++-    exit(100);
+++    exit();
++   }
++   write(fd, "ff", 2);
++   close(fd);
++ 
++   if(unlink("dd") >= 0){
++     printf(1, "unlink dd (non-empty dir) succeeded!\n");
++-    exit(99);
+++    exit();
++   }
++ 
++   if(mkdir("/dd/dd") != 0){
++     printf(1, "subdir mkdir dd/dd failed\n");
++-    exit(98);
+++    exit();
++   }
++ 
++   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
++   if(fd < 0){
++     printf(1, "create dd/dd/ff failed\n");
++-    exit(97);
+++    exit();
++   }
++   write(fd, "FF", 2);
++   close(fd);
++@@ -973,142 +973,142 @@ subdir(void)
++   fd = open("dd/dd/../ff", 0);
++   if(fd < 0){
++     printf(1, "open dd/dd/../ff failed\n");
++-    exit(96);
+++    exit();
++   }
++   cc = read(fd, buf, sizeof(buf));
++   if(cc != 2 || buf[0] != 'f'){
++     printf(1, "dd/dd/../ff wrong content\n");
++-    exit(95);
+++    exit();
++   }
++   close(fd);
++ 
++   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
++     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
++-    exit(94);
+++    exit();
++   }
++ 
++   if(unlink("dd/dd/ff") != 0){
++     printf(1, "unlink dd/dd/ff failed\n");
++-    exit(93);
+++    exit();
++   }
++   if(open("dd/dd/ff", O_RDONLY) >= 0){
++     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
++-    exit(92);
+++    exit();
++   }
++ 
++   if(chdir("dd") != 0){
++     printf(1, "chdir dd failed\n");
++-    exit(91);
+++    exit();
++   }
++   if(chdir("dd/../../dd") != 0){
++     printf(1, "chdir dd/../../dd failed\n");
++-    exit(90);
+++    exit();
++   }
++   if(chdir("dd/../../../dd") != 0){
++     printf(1, "chdir dd/../../dd failed\n");
++-    exit(89);
+++    exit();
++   }
++   if(chdir("./..") != 0){
++     printf(1, "chdir ./.. failed\n");
++-    exit(88);
+++    exit();
++   }
++ 
++   fd = open("dd/dd/ffff", 0);
++   if(fd < 0){
++     printf(1, "open dd/dd/ffff failed\n");
++-    exit(87);
+++    exit();
++   }
++   if(read(fd, buf, sizeof(buf)) != 2){
++     printf(1, "read dd/dd/ffff wrong len\n");
++-    exit(86);
+++    exit();
++   }
++   close(fd);
++ 
++   if(open("dd/dd/ff", O_RDONLY) >= 0){
++     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++ 
++   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
++     printf(1, "create dd/ff/ff succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
++     printf(1, "create dd/xx/ff succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(open("dd", O_CREATE) >= 0){
++     printf(1, "create dd succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(open("dd", O_RDWR) >= 0){
++     printf(1, "open dd rdwr succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(open("dd", O_WRONLY) >= 0){
++     printf(1, "open dd wronly succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(link("dd/ff/ff", "dd/dd/xx") == 0){
++     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(link("dd/xx/ff", "dd/dd/xx") == 0){
++     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(link("dd/ff", "dd/dd/ffff") == 0){
++     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(mkdir("dd/ff/ff") == 0){
++     printf(1, "mkdir dd/ff/ff succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(mkdir("dd/xx/ff") == 0){
++     printf(1, "mkdir dd/xx/ff succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(mkdir("dd/dd/ffff") == 0){
++     printf(1, "mkdir dd/dd/ffff succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(unlink("dd/xx/ff") == 0){
++     printf(1, "unlink dd/xx/ff succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(unlink("dd/ff/ff") == 0){
++     printf(1, "unlink dd/ff/ff succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(chdir("dd/ff") == 0){
++     printf(1, "chdir dd/ff succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(chdir("dd/xx") == 0){
++     printf(1, "chdir dd/xx succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++ 
++   if(unlink("dd/dd/ffff") != 0){
++     printf(1, "unlink dd/dd/ff failed\n");
++-    exit(68);
+++    exit();
++   }
++   if(unlink("dd/ff") != 0){
++     printf(1, "unlink dd/ff failed\n");
++-    exit(67);
+++    exit();
++   }
++   if(unlink("dd") == 0){
++     printf(1, "unlink non-empty dd succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(unlink("dd/dd") < 0){
++     printf(1, "unlink dd/dd failed\n");
++-    exit(65);
+++    exit();
++   }
++   if(unlink("dd") < 0){
++     printf(1, "unlink dd failed\n");
++-    exit(64);
+++    exit();
++   }
++ 
++   printf(1, "subdir ok\n");
++@@ -1127,14 +1127,14 @@ bigwrite(void)
++     fd = open("bigwrite", O_CREATE | O_RDWR);
++     if(fd < 0){
++       printf(1, "cannot create bigwrite\n");
++-      exit(63);
+++      exit();
++     }
++     int i;
++     for(i = 0; i < 2; i++){
++       int cc = write(fd, buf, sz);
++       if(cc != sz){
++         printf(1, "write(%d) ret %d\n", sz, cc);
++-        exit(62);
+++        exit();
++       }
++     }
++     close(fd);
++@@ -1155,13 +1155,13 @@ bigfile(void)
++   fd = open("bigfile", O_CREATE | O_RDWR);
++   if(fd < 0){
++     printf(1, "cannot create bigfile");
++-    exit(61);
+++    exit();
++   }
++   for(i = 0; i < 20; i++){
++     memset(buf, i, 600);
++     if(write(fd, buf, 600) != 600){
++       printf(1, "write bigfile failed\n");
++-      exit(60);
+++      exit();
++     }
++   }
++   close(fd);
++@@ -1169,31 +1169,31 @@ bigfile(void)
++   fd = open("bigfile", 0);
++   if(fd < 0){
++     printf(1, "cannot open bigfile\n");
++-    exit(59);
+++    exit();
++   }
++   total = 0;
++   for(i = 0; ; i++){
++     cc = read(fd, buf, 300);
++     if(cc < 0){
++       printf(1, "read bigfile failed\n");
++-      exit(58);
+++      exit();
++     }
++     if(cc == 0)
++       break;
++     if(cc != 300){
++       printf(1, "short read bigfile\n");
++-      exit(57);
+++      exit();
++     }
++     if(buf[0] != i/2 || buf[299] != i/2){
++       printf(1, "read bigfile wrong data\n");
++-      exit(56);
+++      exit();
++     }
++     total += cc;
++   }
++   close(fd);
++   if(total != 20*600){
++     printf(1, "read bigfile wrong total\n");
++-    exit(55);
+++    exit();
++   }
++   unlink("bigfile");
++ 
++@@ -1210,32 +1210,32 @@ fourteen(void)
++ 
++   if(mkdir("12345678901234") != 0){
++     printf(1, "mkdir 12345678901234 failed\n");
++-    exit(54);
+++    exit();
++   }
++   if(mkdir("12345678901234/123456789012345") != 0){
++     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
++-    exit(53);
+++    exit();
++   }
++   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
++   if(fd < 0){
++     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
++-    exit(52);
+++    exit();
++   }
++   close(fd);
++   fd = open("12345678901234/12345678901234/12345678901234", 0);
++   if(fd < 0){
++     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
++-    exit(51);
+++    exit();
++   }
++   close(fd);
++ 
++   if(mkdir("12345678901234/12345678901234") == 0){
++     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(mkdir("123456789012345/12345678901234") == 0){
++     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++ 
++   printf(1, "fourteen ok\n");
++@@ -1247,35 +1247,35 @@ rmdot(void)
++   printf(1, "rmdot test\n");
++   if(mkdir("dots") != 0){
++     printf(1, "mkdir dots failed\n");
++-    exit(48);
+++    exit();
++   }
++   if(chdir("dots") != 0){
++     printf(1, "chdir dots failed\n");
++-    exit(47);
+++    exit();
++   }
++   if(unlink(".") == 0){
++     printf(1, "rm . worked!\n");
++-    exit(0);
+++    exit();
++   }
++   if(unlink("..") == 0){
++     printf(1, "rm .. worked!\n");
++-    exit(0);
+++    exit();
++   }
++   if(chdir("/") != 0){
++     printf(1, "chdir / failed\n");
++-    exit(44);
+++    exit();
++   }
++   if(unlink("dots/.") == 0){
++     printf(1, "unlink dots/. worked!\n");
++-    exit(0);
+++    exit();
++   }
++   if(unlink("dots/..") == 0){
++     printf(1, "unlink dots/.. worked!\n");
++-    exit(0);
+++    exit();
++   }
++   if(unlink("dots") != 0){
++     printf(1, "unlink dots failed!\n");
++-    exit(41);
+++    exit();
++   }
++   printf(1, "rmdot ok\n");
++ }
++@@ -1290,49 +1290,49 @@ dirfile(void)
++   fd = open("dirfile", O_CREATE);
++   if(fd < 0){
++     printf(1, "create dirfile failed\n");
++-    exit(40);
+++    exit();
++   }
++   close(fd);
++   if(chdir("dirfile") == 0){
++     printf(1, "chdir dirfile succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   fd = open("dirfile/xx", 0);
++   if(fd >= 0){
++     printf(1, "create dirfile/xx succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   fd = open("dirfile/xx", O_CREATE);
++   if(fd >= 0){
++     printf(1, "create dirfile/xx succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(mkdir("dirfile/xx") == 0){
++     printf(1, "mkdir dirfile/xx succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(unlink("dirfile/xx") == 0){
++     printf(1, "unlink dirfile/xx succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(link("README", "dirfile/xx") == 0){
++     printf(1, "link to dirfile/xx succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   if(unlink("dirfile") != 0){
++     printf(1, "unlink dirfile failed!\n");
++-    exit(33);
+++    exit();
++   }
++ 
++   fd = open(".", O_RDWR);
++   if(fd >= 0){
++     printf(1, "open . for writing succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   fd = open(".", 0);
++   if(write(fd, "x", 1) > 0){
++     printf(1, "write . succeeded!\n");
++-    exit(0);
+++    exit();
++   }
++   close(fd);
++ 
++@@ -1351,11 +1351,11 @@ iref(void)
++   for(i = 0; i < 50 + 1; i++){
++     if(mkdir("irefd") != 0){
++       printf(1, "mkdir irefd failed\n");
++-      exit(30);
+++      exit();
++     }
++     if(chdir("irefd") != 0){
++       printf(1, "chdir irefd failed\n");
++-      exit(29);
+++      exit();
++     }
++ 
++     mkdir("");
++@@ -1388,24 +1388,24 @@ forktest(void)
++     if(pid < 0)
++       break;
++     if(pid == 0)
++-      exit(28);
+++      exit();
++   }
++ 
++   if(n == 1000){
++     printf(1, "fork claimed to work 1000 times!\n");
++-    exit(27);
+++    exit();
++   }
++ 
++   for(; n > 0; n--){
++-    if(wait(NULL) < 0){
+++    if(wait() < 0){
++       printf(1, "wait stopped early\n");
++-      exit(26);
+++      exit();
++     }
++   }
++ 
++-  if(wait(NULL) != -1){
+++  if(wait() != -1){
++     printf(1, "wait got too many\n");
++-    exit(25);
+++    exit();
++   }
++ 
++   printf(1, "fork test OK\n");
++@@ -1428,7 +1428,7 @@ sbrktest(void)
++     b = sbrk(1);
++     if(b != a){
++       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
++-      exit(24);
+++      exit();
++     }
++     *b = 1;
++     a = b + 1;
++@@ -1436,17 +1436,17 @@ sbrktest(void)
++   pid = fork();
++   if(pid < 0){
++     printf(stdout, "sbrk test fork failed\n");
++-    exit(23);
+++    exit();
++   }
++   c = sbrk(1);
++   c = sbrk(1);
++   if(c != a + 1){
++     printf(stdout, "sbrk test failed post-fork\n");
++-    exit(22);
+++    exit();
++   }
++   if(pid == 0)
++-    exit(21);
++-  wait(NULL);
+++    exit();
+++  wait();
++ 
++   // can one grow address space to something big?
++ #define BIG (100*1024*1024)
++@@ -1455,7 +1455,7 @@ sbrktest(void)
++   p = sbrk(amt);
++   if (p != a) {
++     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
++-    exit(20);
+++    exit();
++   }
++   lastaddr = (char*) (BIG-1);
++   *lastaddr = 99;
++@@ -1465,12 +1465,12 @@ sbrktest(void)
++   c = sbrk(-4096);
++   if(c == (char*)0xffffffff){
++     printf(stdout, "sbrk could not deallocate\n");
++-    exit(19);
+++    exit();
++   }
++   c = sbrk(0);
++   if(c != a - 4096){
++     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
++-    exit(18);
+++    exit();
++   }
++ 
++   // can one re-allocate that page?
++@@ -1478,19 +1478,19 @@ sbrktest(void)
++   c = sbrk(4096);
++   if(c != a || sbrk(0) != a + 4096){
++     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
++-    exit(17);
+++    exit();
++   }
++   if(*lastaddr == 99){
++     // should be zero
++     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
++-    exit(16);
+++    exit();
++   }
++ 
++   a = sbrk(0);
++   c = sbrk(-(sbrk(0) - oldbrk));
++   if(c != a){
++     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
++-    exit(15);
+++    exit();
++   }
++ 
++   // can we read the kernel's memory?
++@@ -1499,21 +1499,21 @@ sbrktest(void)
++     pid = fork();
++     if(pid < 0){
++       printf(stdout, "fork failed\n");
++-      exit(14);
+++      exit();
++     }
++     if(pid == 0){
++       printf(stdout, "oops could read %x = %x\n", a, *a);
++       kill(ppid);
++-      exit(13);
+++      exit();
++     }
++-    wait(NULL);
+++    wait();
++   }
++ 
++   // if we run the system out of memory, does it clean up the last
++   // failed allocation?
++   if(pipe(fds) != 0){
++     printf(1, "pipe() failed\n");
++-    exit(12);
+++    exit();
++   }
++   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
++     if((pids[i] = fork()) == 0){
++@@ -1533,11 +1533,11 @@ sbrktest(void)
++     if(pids[i] == -1)
++       continue;
++     kill(pids[i]);
++-    wait(NULL);
+++    wait();
++   }
++   if(c == (char*)0xffffffff){
++     printf(stdout, "failed sbrk leaked memory\n");
++-    exit(10);
+++    exit();
++   }
++ 
++   if(sbrk(0) > oldbrk)
++@@ -1572,17 +1572,17 @@ validatetest(void)
++     if((pid = fork()) == 0){
++       // try to crash the kernel by passing in a badly placed integer
++       validateint((int*)p);
++-      exit(9);
+++      exit();
++     }
++     sleep(0);
++     sleep(0);
++     kill(pid);
++-    wait(NULL);
+++    wait();
++ 
++     // try to crash the kernel by passing in a bad string pointer
++     if(link("nosuchfile", (char*)p) != -1){
++       printf(stdout, "link should not succeed\n");
++-      exit(8);
+++      exit();
++     }
++   }
++ 
++@@ -1600,7 +1600,7 @@ bsstest(void)
++   for(i = 0; i < sizeof(uninit); i++){
++     if(uninit[i] != '\0'){
++       printf(stdout, "bss test failed\n");
++-      exit(7);
+++      exit();
++     }
++   }
++   printf(stdout, "bss test ok\n");
++@@ -1627,16 +1627,16 @@ bigargtest(void)
++     printf(stdout, "bigarg test ok\n");
++     fd = open("bigarg-ok", O_CREATE);
++     close(fd);
++-    exit(6);
+++    exit();
++   } else if(pid < 0){
++     printf(stdout, "bigargtest: fork failed\n");
++-    exit(5);
+++    exit();
++   }
++-  wait(NULL);
+++  wait();
++   fd = open("bigarg-ok", 0);
++   if(fd < 0){
++     printf(stdout, "bigarg test failed!\n");
++-    exit(4);
+++    exit();
++   }
++   close(fd);
++   unlink("bigarg-ok");
++@@ -1715,12 +1715,12 @@ uio()
++     port = RTC_DATA;
++     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
++     printf(1, "uio: uio succeeded; test FAILED\n");
++-    exit(3);
+++    exit();
++   } else if(pid < 0){
++     printf (1, "fork failed\n");
++-    exit(2);
+++    exit();
++   }
++-  wait(NULL);
+++  wait();
++   printf(1, "uio test done\n");
++ }
++ 
++@@ -1730,7 +1730,7 @@ void argptest()
++   fd = open("init", O_RDONLY);
++   if (fd < 0) {
++     printf(2, "open failed\n");
++-    exit(1);
+++    exit();
++   }
++   read(fd, sbrk(0) - 1, -1);
++   close(fd);
++@@ -1752,7 +1752,7 @@ main(int argc, char *argv[])
++ 
++   if(open("usertests.ran", 0) >= 0){
++     printf(1, "already ran user tests -- rebuild fs.img\n");
++-    exit(1);
+++    exit();
++   }
++   close(open("usertests.ran", O_CREATE));
++ 
++@@ -1799,5 +1799,5 @@ main(int argc, char *argv[])
++ 
++   exectest();
++ 
++-  exit(0);
+++  exit();
++ }
++diff --git a/usys.S b/usys.S
++index 1687ed0..8bfd8a1 100644
++--- a/usys.S
+++++ b/usys.S
++@@ -11,7 +11,6 @@
++ SYSCALL(fork)
++ SYSCALL(exit)
++ SYSCALL(wait)
++-SYSCALL(waitpid)
++ SYSCALL(pipe)
++ SYSCALL(read)
++ SYSCALL(write)
++diff --git a/wc.c b/wc.c
++index 08b93b6..d6a54df 100644
++--- a/wc.c
+++++ b/wc.c
++@@ -27,7 +27,7 @@ wc(int fd, char *name)
++   }
++   if(n < 0){
++     printf(1, "wc: read error\n");
++-    exit(3);
+++    exit();
++   }
++   printf(1, "%d %d %d %s\n", l, w, c, name);
++ }
++@@ -39,16 +39,16 @@ main(int argc, char *argv[])
++ 
++   if(argc <= 1){
++     wc(0, "");
++-    exit(2);
+++    exit();
++   }
++ 
++   for(i = 1; i < argc; i++){
++     if((fd = open(argv[i], 0)) < 0){
++       printf(1, "wc: cannot open %s\n", argv[i]);
++-      exit(1);
+++      exit();
++     }
++     wc(fd, argv[i]);
++     close(fd);
++   }
++-  exit(0);
+++  exit();
++ }
++diff --git a/zombie.c b/zombie.c
++index c96b92d..ee817da 100644
++--- a/zombie.c
+++++ b/zombie.c
++@@ -10,5 +10,5 @@ main(void)
++ {
++   if(fork() > 0)
++     sleep(5);  // Let child exit before parent.
++-  exit(0);
+++  exit();
++ }
+diff --git a/console.d b/console.d
+new file mode 100644
+index 0000000..7b5564c
+--- /dev/null
++++ b/console.d
+@@ -0,0 +1,3 @@
++console.o: console.c /usr/include/stdc-predef.h types.h defs.h param.h \
++ traps.h spinlock.h sleeplock.h fs.h file.h memlayout.h mmu.h proc.h \
++ x86.h
+diff --git a/console.o b/console.o
+new file mode 100644
+index 0000000..2d077bf
+Binary files /dev/null and b/console.o differ
+diff --git a/defs.h b/defs.h
+index d1934ca..5b36aac 100644
+--- a/defs.h
++++ b/defs.h
+@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
+ //PAGEBREAK: 16
+ // proc.c
+ int             cpuid(void);
+-void            exit(int status);
++void            exit(void);
+ int             fork(void);
+ int             growproc(int);
+ int             kill(int);
+@@ -117,8 +117,7 @@ void            sched(void);
+ void            setproc(struct proc*);
+ void            sleep(void*, struct spinlock*);
+ void            userinit(void);
+-int             wait(int* status);
+-int             waitpid(int pid, int* status, int options);
++int             wait(void);
+ void            wakeup(void*);
+ void            yield(void);
+ 
+@@ -181,11 +180,23 @@ int             deallocuvm(pde_t*, uint, uint);
+ void            freevm(pde_t*);
+ void            inituvm(pde_t*, char*, uint);
+ int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
+-pde_t*          copyuvm(pde_t*, uint);
++pde_t*          copyuvm(pde_t*, uint, uint);
+ void            switchuvm(struct proc*);
+ void            switchkvm(void);
+ int             copyout(pde_t*, uint, void*, uint);
+ void            clearpteu(pde_t *pgdir, char *uva);
++int             growstack(pde_t *pgdir, uint sp, uint topStack);
++void            setpteu(pde_t *pgdir, char *uva);
++
++
++//made mappages visible (and removed static) to facilitate implementing shm
++int
++mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm);
++
++//shm.c
++void shminit(void);
++int shm_open(int id, char **pointer);
++int shm_close(int id);
+ 
+ // number of elements in fixed-size array
+ #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+diff --git a/echo.asm b/echo.asm
+new file mode 100644
+index 0000000..46b5f43
+--- /dev/null
++++ b/echo.asm
+@@ -0,0 +1,1220 @@
++
++_echo:     file format elf32-i386
++
++
++Disassembly of section .text:
++
++00001000 <main>:
++#include "stat.h"
++#include "user.h"
++
++int
++main(int argc, char *argv[])
++{
++    1000:	55                   	push   %ebp
++    1001:	89 e5                	mov    %esp,%ebp
++    1003:	57                   	push   %edi
++    1004:	56                   	push   %esi
++    1005:	53                   	push   %ebx
++    1006:	83 e4 f0             	and    $0xfffffff0,%esp
++    1009:	83 ec 10             	sub    $0x10,%esp
++    100c:	8b 75 08             	mov    0x8(%ebp),%esi
++    100f:	8b 7d 0c             	mov    0xc(%ebp),%edi
++  int i;
++
++  for(i = 1; i < argc; i++)
++    1012:	83 fe 01             	cmp    $0x1,%esi
++    1015:	7e 58                	jle    106f <main+0x6f>
++    1017:	bb 01 00 00 00       	mov    $0x1,%ebx
++    101c:	eb 26                	jmp    1044 <main+0x44>
++    101e:	66 90                	xchg   %ax,%ax
++    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
++    1020:	c7 44 24 0c a1 17 00 	movl   $0x17a1,0xc(%esp)
++    1027:	00 
++    1028:	8b 44 9f fc          	mov    -0x4(%edi,%ebx,4),%eax
++    102c:	c7 44 24 04 a3 17 00 	movl   $0x17a3,0x4(%esp)
++    1033:	00 
++    1034:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    103b:	89 44 24 08          	mov    %eax,0x8(%esp)
++    103f:	e8 bc 03 00 00       	call   1400 <printf>
++    1044:	83 c3 01             	add    $0x1,%ebx
++    1047:	39 f3                	cmp    %esi,%ebx
++    1049:	75 d5                	jne    1020 <main+0x20>
++    104b:	c7 44 24 0c a8 17 00 	movl   $0x17a8,0xc(%esp)
++    1052:	00 
++    1053:	8b 44 9f fc          	mov    -0x4(%edi,%ebx,4),%eax
++    1057:	c7 44 24 04 a3 17 00 	movl   $0x17a3,0x4(%esp)
++    105e:	00 
++    105f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    1066:	89 44 24 08          	mov    %eax,0x8(%esp)
++    106a:	e8 91 03 00 00       	call   1400 <printf>
++  exit();
++    106f:	e8 2e 02 00 00       	call   12a2 <exit>
++    1074:	66 90                	xchg   %ax,%ax
++    1076:	66 90                	xchg   %ax,%ax
++    1078:	66 90                	xchg   %ax,%ax
++    107a:	66 90                	xchg   %ax,%ax
++    107c:	66 90                	xchg   %ax,%ax
++    107e:	66 90                	xchg   %ax,%ax
++
++00001080 <strcpy>:
++#include "user.h"
++#include "x86.h"
++
++char*
++strcpy(char *s, char *t)
++{
++    1080:	55                   	push   %ebp
++    1081:	89 e5                	mov    %esp,%ebp
++    1083:	8b 45 08             	mov    0x8(%ebp),%eax
++    1086:	8b 4d 0c             	mov    0xc(%ebp),%ecx
++    1089:	53                   	push   %ebx
++  char *os;
++
++  os = s;
++  while((*s++ = *t++) != 0)
++    108a:	89 c2                	mov    %eax,%edx
++    108c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    1090:	83 c1 01             	add    $0x1,%ecx
++    1093:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
++    1097:	83 c2 01             	add    $0x1,%edx
++    109a:	84 db                	test   %bl,%bl
++    109c:	88 5a ff             	mov    %bl,-0x1(%edx)
++    109f:	75 ef                	jne    1090 <strcpy+0x10>
++    ;
++  return os;
++}
++    10a1:	5b                   	pop    %ebx
++    10a2:	5d                   	pop    %ebp
++    10a3:	c3                   	ret    
++    10a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    10aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
++
++000010b0 <strcmp>:
++
++int
++strcmp(const char *p, const char *q)
++{
++    10b0:	55                   	push   %ebp
++    10b1:	89 e5                	mov    %esp,%ebp
++    10b3:	8b 55 08             	mov    0x8(%ebp),%edx
++    10b6:	53                   	push   %ebx
++    10b7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
++  while(*p && *p == *q)
++    10ba:	0f b6 02             	movzbl (%edx),%eax
++    10bd:	84 c0                	test   %al,%al
++    10bf:	74 2d                	je     10ee <strcmp+0x3e>
++    10c1:	0f b6 19             	movzbl (%ecx),%ebx
++    10c4:	38 d8                	cmp    %bl,%al
++    10c6:	74 0e                	je     10d6 <strcmp+0x26>
++    10c8:	eb 2b                	jmp    10f5 <strcmp+0x45>
++    10ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    10d0:	38 c8                	cmp    %cl,%al
++    10d2:	75 15                	jne    10e9 <strcmp+0x39>
++    p++, q++;
++    10d4:	89 d9                	mov    %ebx,%ecx
++    10d6:	83 c2 01             	add    $0x1,%edx
++  while(*p && *p == *q)
++    10d9:	0f b6 02             	movzbl (%edx),%eax
++    p++, q++;
++    10dc:	8d 59 01             	lea    0x1(%ecx),%ebx
++  while(*p && *p == *q)
++    10df:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
++    10e3:	84 c0                	test   %al,%al
++    10e5:	75 e9                	jne    10d0 <strcmp+0x20>
++    10e7:	31 c0                	xor    %eax,%eax
++  return (uchar)*p - (uchar)*q;
++    10e9:	29 c8                	sub    %ecx,%eax
++}
++    10eb:	5b                   	pop    %ebx
++    10ec:	5d                   	pop    %ebp
++    10ed:	c3                   	ret    
++    10ee:	0f b6 09             	movzbl (%ecx),%ecx
++  while(*p && *p == *q)
++    10f1:	31 c0                	xor    %eax,%eax
++    10f3:	eb f4                	jmp    10e9 <strcmp+0x39>
++    10f5:	0f b6 cb             	movzbl %bl,%ecx
++    10f8:	eb ef                	jmp    10e9 <strcmp+0x39>
++    10fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++
++00001100 <strlen>:
++
++uint
++strlen(char *s)
++{
++    1100:	55                   	push   %ebp
++    1101:	89 e5                	mov    %esp,%ebp
++    1103:	8b 4d 08             	mov    0x8(%ebp),%ecx
++  int n;
++
++  for(n = 0; s[n]; n++)
++    1106:	80 39 00             	cmpb   $0x0,(%ecx)
++    1109:	74 12                	je     111d <strlen+0x1d>
++    110b:	31 d2                	xor    %edx,%edx
++    110d:	8d 76 00             	lea    0x0(%esi),%esi
++    1110:	83 c2 01             	add    $0x1,%edx
++    1113:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
++    1117:	89 d0                	mov    %edx,%eax
++    1119:	75 f5                	jne    1110 <strlen+0x10>
++    ;
++  return n;
++}
++    111b:	5d                   	pop    %ebp
++    111c:	c3                   	ret    
++  for(n = 0; s[n]; n++)
++    111d:	31 c0                	xor    %eax,%eax
++}
++    111f:	5d                   	pop    %ebp
++    1120:	c3                   	ret    
++    1121:	eb 0d                	jmp    1130 <memset>
++    1123:	90                   	nop
++    1124:	90                   	nop
++    1125:	90                   	nop
++    1126:	90                   	nop
++    1127:	90                   	nop
++    1128:	90                   	nop
++    1129:	90                   	nop
++    112a:	90                   	nop
++    112b:	90                   	nop
++    112c:	90                   	nop
++    112d:	90                   	nop
++    112e:	90                   	nop
++    112f:	90                   	nop
++
++00001130 <memset>:
++
++void*
++memset(void *dst, int c, uint n)
++{
++    1130:	55                   	push   %ebp
++    1131:	89 e5                	mov    %esp,%ebp
++    1133:	8b 55 08             	mov    0x8(%ebp),%edx
++    1136:	57                   	push   %edi
++}
++
++static inline void
++stosb(void *addr, int data, int cnt)
++{
++  asm volatile("cld; rep stosb" :
++    1137:	8b 4d 10             	mov    0x10(%ebp),%ecx
++    113a:	8b 45 0c             	mov    0xc(%ebp),%eax
++    113d:	89 d7                	mov    %edx,%edi
++    113f:	fc                   	cld    
++    1140:	f3 aa                	rep stos %al,%es:(%edi)
++  stosb(dst, c, n);
++  return dst;
++}
++    1142:	89 d0                	mov    %edx,%eax
++    1144:	5f                   	pop    %edi
++    1145:	5d                   	pop    %ebp
++    1146:	c3                   	ret    
++    1147:	89 f6                	mov    %esi,%esi
++    1149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++00001150 <strchr>:
++
++char*
++strchr(const char *s, char c)
++{
++    1150:	55                   	push   %ebp
++    1151:	89 e5                	mov    %esp,%ebp
++    1153:	8b 45 08             	mov    0x8(%ebp),%eax
++    1156:	53                   	push   %ebx
++    1157:	8b 55 0c             	mov    0xc(%ebp),%edx
++  for(; *s; s++)
++    115a:	0f b6 18             	movzbl (%eax),%ebx
++    115d:	84 db                	test   %bl,%bl
++    115f:	74 1d                	je     117e <strchr+0x2e>
++    if(*s == c)
++    1161:	38 d3                	cmp    %dl,%bl
++    1163:	89 d1                	mov    %edx,%ecx
++    1165:	75 0d                	jne    1174 <strchr+0x24>
++    1167:	eb 17                	jmp    1180 <strchr+0x30>
++    1169:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++    1170:	38 ca                	cmp    %cl,%dl
++    1172:	74 0c                	je     1180 <strchr+0x30>
++  for(; *s; s++)
++    1174:	83 c0 01             	add    $0x1,%eax
++    1177:	0f b6 10             	movzbl (%eax),%edx
++    117a:	84 d2                	test   %dl,%dl
++    117c:	75 f2                	jne    1170 <strchr+0x20>
++      return (char*)s;
++  return 0;
++    117e:	31 c0                	xor    %eax,%eax
++}
++    1180:	5b                   	pop    %ebx
++    1181:	5d                   	pop    %ebp
++    1182:	c3                   	ret    
++    1183:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    1189:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++00001190 <gets>:
++
++char*
++gets(char *buf, int max)
++{
++    1190:	55                   	push   %ebp
++    1191:	89 e5                	mov    %esp,%ebp
++    1193:	57                   	push   %edi
++    1194:	56                   	push   %esi
++  int i, cc;
++  char c;
++
++  for(i=0; i+1 < max; ){
++    1195:	31 f6                	xor    %esi,%esi
++{
++    1197:	53                   	push   %ebx
++    1198:	83 ec 2c             	sub    $0x2c,%esp
++    cc = read(0, &c, 1);
++    119b:	8d 7d e7             	lea    -0x19(%ebp),%edi
++  for(i=0; i+1 < max; ){
++    119e:	eb 31                	jmp    11d1 <gets+0x41>
++    cc = read(0, &c, 1);
++    11a0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    11a7:	00 
++    11a8:	89 7c 24 04          	mov    %edi,0x4(%esp)
++    11ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
++    11b3:	e8 02 01 00 00       	call   12ba <read>
++    if(cc < 1)
++    11b8:	85 c0                	test   %eax,%eax
++    11ba:	7e 1d                	jle    11d9 <gets+0x49>
++      break;
++    buf[i++] = c;
++    11bc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
++  for(i=0; i+1 < max; ){
++    11c0:	89 de                	mov    %ebx,%esi
++    buf[i++] = c;
++    11c2:	8b 55 08             	mov    0x8(%ebp),%edx
++    if(c == '\n' || c == '\r')
++    11c5:	3c 0d                	cmp    $0xd,%al
++    buf[i++] = c;
++    11c7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
++    if(c == '\n' || c == '\r')
++    11cb:	74 0c                	je     11d9 <gets+0x49>
++    11cd:	3c 0a                	cmp    $0xa,%al
++    11cf:	74 08                	je     11d9 <gets+0x49>
++  for(i=0; i+1 < max; ){
++    11d1:	8d 5e 01             	lea    0x1(%esi),%ebx
++    11d4:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
++    11d7:	7c c7                	jl     11a0 <gets+0x10>
++      break;
++  }
++  buf[i] = '\0';
++    11d9:	8b 45 08             	mov    0x8(%ebp),%eax
++    11dc:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
++  return buf;
++}
++    11e0:	83 c4 2c             	add    $0x2c,%esp
++    11e3:	5b                   	pop    %ebx
++    11e4:	5e                   	pop    %esi
++    11e5:	5f                   	pop    %edi
++    11e6:	5d                   	pop    %ebp
++    11e7:	c3                   	ret    
++    11e8:	90                   	nop
++    11e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++
++000011f0 <stat>:
++
++int
++stat(char *n, struct stat *st)
++{
++    11f0:	55                   	push   %ebp
++    11f1:	89 e5                	mov    %esp,%ebp
++    11f3:	56                   	push   %esi
++    11f4:	53                   	push   %ebx
++    11f5:	83 ec 10             	sub    $0x10,%esp
++  int fd;
++  int r;
++
++  fd = open(n, O_RDONLY);
++    11f8:	8b 45 08             	mov    0x8(%ebp),%eax
++    11fb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
++    1202:	00 
++    1203:	89 04 24             	mov    %eax,(%esp)
++    1206:	e8 d7 00 00 00       	call   12e2 <open>
++  if(fd < 0)
++    120b:	85 c0                	test   %eax,%eax
++  fd = open(n, O_RDONLY);
++    120d:	89 c3                	mov    %eax,%ebx
++  if(fd < 0)
++    120f:	78 27                	js     1238 <stat+0x48>
++    return -1;
++  r = fstat(fd, st);
++    1211:	8b 45 0c             	mov    0xc(%ebp),%eax
++    1214:	89 1c 24             	mov    %ebx,(%esp)
++    1217:	89 44 24 04          	mov    %eax,0x4(%esp)
++    121b:	e8 da 00 00 00       	call   12fa <fstat>
++  close(fd);
++    1220:	89 1c 24             	mov    %ebx,(%esp)
++  r = fstat(fd, st);
++    1223:	89 c6                	mov    %eax,%esi
++  close(fd);
++    1225:	e8 a0 00 00 00       	call   12ca <close>
++  return r;
++    122a:	89 f0                	mov    %esi,%eax
++}
++    122c:	83 c4 10             	add    $0x10,%esp
++    122f:	5b                   	pop    %ebx
++    1230:	5e                   	pop    %esi
++    1231:	5d                   	pop    %ebp
++    1232:	c3                   	ret    
++    1233:	90                   	nop
++    1234:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    return -1;
++    1238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++    123d:	eb ed                	jmp    122c <stat+0x3c>
++    123f:	90                   	nop
++
++00001240 <atoi>:
++
++int
++atoi(const char *s)
++{
++    1240:	55                   	push   %ebp
++    1241:	89 e5                	mov    %esp,%ebp
++    1243:	8b 4d 08             	mov    0x8(%ebp),%ecx
++    1246:	53                   	push   %ebx
++  int n;
++
++  n = 0;
++  while('0' <= *s && *s <= '9')
++    1247:	0f be 11             	movsbl (%ecx),%edx
++    124a:	8d 42 d0             	lea    -0x30(%edx),%eax
++    124d:	3c 09                	cmp    $0x9,%al
++  n = 0;
++    124f:	b8 00 00 00 00       	mov    $0x0,%eax
++  while('0' <= *s && *s <= '9')
++    1254:	77 17                	ja     126d <atoi+0x2d>
++    1256:	66 90                	xchg   %ax,%ax
++    n = n*10 + *s++ - '0';
++    1258:	83 c1 01             	add    $0x1,%ecx
++    125b:	8d 04 80             	lea    (%eax,%eax,4),%eax
++    125e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
++  while('0' <= *s && *s <= '9')
++    1262:	0f be 11             	movsbl (%ecx),%edx
++    1265:	8d 5a d0             	lea    -0x30(%edx),%ebx
++    1268:	80 fb 09             	cmp    $0x9,%bl
++    126b:	76 eb                	jbe    1258 <atoi+0x18>
++  return n;
++}
++    126d:	5b                   	pop    %ebx
++    126e:	5d                   	pop    %ebp
++    126f:	c3                   	ret    
++
++00001270 <memmove>:
++
++void*
++memmove(void *vdst, void *vsrc, int n)
++{
++    1270:	55                   	push   %ebp
++  char *dst, *src;
++
++  dst = vdst;
++  src = vsrc;
++  while(n-- > 0)
++    1271:	31 d2                	xor    %edx,%edx
++{
++    1273:	89 e5                	mov    %esp,%ebp
++    1275:	56                   	push   %esi
++    1276:	8b 45 08             	mov    0x8(%ebp),%eax
++    1279:	53                   	push   %ebx
++    127a:	8b 5d 10             	mov    0x10(%ebp),%ebx
++    127d:	8b 75 0c             	mov    0xc(%ebp),%esi
++  while(n-- > 0)
++    1280:	85 db                	test   %ebx,%ebx
++    1282:	7e 12                	jle    1296 <memmove+0x26>
++    1284:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    *dst++ = *src++;
++    1288:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
++    128c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
++    128f:	83 c2 01             	add    $0x1,%edx
++  while(n-- > 0)
++    1292:	39 da                	cmp    %ebx,%edx
++    1294:	75 f2                	jne    1288 <memmove+0x18>
++  return vdst;
++}
++    1296:	5b                   	pop    %ebx
++    1297:	5e                   	pop    %esi
++    1298:	5d                   	pop    %ebp
++    1299:	c3                   	ret    
++
++0000129a <fork>:
++  name: \
++    movl $SYS_ ## name, %eax; \
++    int $T_SYSCALL; \
++    ret
++
++SYSCALL(fork)
++    129a:	b8 01 00 00 00       	mov    $0x1,%eax
++    129f:	cd 40                	int    $0x40
++    12a1:	c3                   	ret    
++
++000012a2 <exit>:
++SYSCALL(exit)
++    12a2:	b8 02 00 00 00       	mov    $0x2,%eax
++    12a7:	cd 40                	int    $0x40
++    12a9:	c3                   	ret    
++
++000012aa <wait>:
++SYSCALL(wait)
++    12aa:	b8 03 00 00 00       	mov    $0x3,%eax
++    12af:	cd 40                	int    $0x40
++    12b1:	c3                   	ret    
++
++000012b2 <pipe>:
++SYSCALL(pipe)
++    12b2:	b8 04 00 00 00       	mov    $0x4,%eax
++    12b7:	cd 40                	int    $0x40
++    12b9:	c3                   	ret    
++
++000012ba <read>:
++SYSCALL(read)
++    12ba:	b8 05 00 00 00       	mov    $0x5,%eax
++    12bf:	cd 40                	int    $0x40
++    12c1:	c3                   	ret    
++
++000012c2 <write>:
++SYSCALL(write)
++    12c2:	b8 10 00 00 00       	mov    $0x10,%eax
++    12c7:	cd 40                	int    $0x40
++    12c9:	c3                   	ret    
++
++000012ca <close>:
++SYSCALL(close)
++    12ca:	b8 15 00 00 00       	mov    $0x15,%eax
++    12cf:	cd 40                	int    $0x40
++    12d1:	c3                   	ret    
++
++000012d2 <kill>:
++SYSCALL(kill)
++    12d2:	b8 06 00 00 00       	mov    $0x6,%eax
++    12d7:	cd 40                	int    $0x40
++    12d9:	c3                   	ret    
++
++000012da <exec>:
++SYSCALL(exec)
++    12da:	b8 07 00 00 00       	mov    $0x7,%eax
++    12df:	cd 40                	int    $0x40
++    12e1:	c3                   	ret    
++
++000012e2 <open>:
++SYSCALL(open)
++    12e2:	b8 0f 00 00 00       	mov    $0xf,%eax
++    12e7:	cd 40                	int    $0x40
++    12e9:	c3                   	ret    
++
++000012ea <mknod>:
++SYSCALL(mknod)
++    12ea:	b8 11 00 00 00       	mov    $0x11,%eax
++    12ef:	cd 40                	int    $0x40
++    12f1:	c3                   	ret    
++
++000012f2 <unlink>:
++SYSCALL(unlink)
++    12f2:	b8 12 00 00 00       	mov    $0x12,%eax
++    12f7:	cd 40                	int    $0x40
++    12f9:	c3                   	ret    
++
++000012fa <fstat>:
++SYSCALL(fstat)
++    12fa:	b8 08 00 00 00       	mov    $0x8,%eax
++    12ff:	cd 40                	int    $0x40
++    1301:	c3                   	ret    
++
++00001302 <link>:
++SYSCALL(link)
++    1302:	b8 13 00 00 00       	mov    $0x13,%eax
++    1307:	cd 40                	int    $0x40
++    1309:	c3                   	ret    
++
++0000130a <mkdir>:
++SYSCALL(mkdir)
++    130a:	b8 14 00 00 00       	mov    $0x14,%eax
++    130f:	cd 40                	int    $0x40
++    1311:	c3                   	ret    
++
++00001312 <chdir>:
++SYSCALL(chdir)
++    1312:	b8 09 00 00 00       	mov    $0x9,%eax
++    1317:	cd 40                	int    $0x40
++    1319:	c3                   	ret    
++
++0000131a <dup>:
++SYSCALL(dup)
++    131a:	b8 0a 00 00 00       	mov    $0xa,%eax
++    131f:	cd 40                	int    $0x40
++    1321:	c3                   	ret    
++
++00001322 <getpid>:
++SYSCALL(getpid)
++    1322:	b8 0b 00 00 00       	mov    $0xb,%eax
++    1327:	cd 40                	int    $0x40
++    1329:	c3                   	ret    
++
++0000132a <sbrk>:
++SYSCALL(sbrk)
++    132a:	b8 0c 00 00 00       	mov    $0xc,%eax
++    132f:	cd 40                	int    $0x40
++    1331:	c3                   	ret    
++
++00001332 <sleep>:
++SYSCALL(sleep)
++    1332:	b8 0d 00 00 00       	mov    $0xd,%eax
++    1337:	cd 40                	int    $0x40
++    1339:	c3                   	ret    
++
++0000133a <uptime>:
++SYSCALL(uptime)
++    133a:	b8 0e 00 00 00       	mov    $0xe,%eax
++    133f:	cd 40                	int    $0x40
++    1341:	c3                   	ret    
++
++00001342 <shm_open>:
++SYSCALL(shm_open)
++    1342:	b8 16 00 00 00       	mov    $0x16,%eax
++    1347:	cd 40                	int    $0x40
++    1349:	c3                   	ret    
++
++0000134a <shm_close>:
++SYSCALL(shm_close)	
++    134a:	b8 17 00 00 00       	mov    $0x17,%eax
++    134f:	cd 40                	int    $0x40
++    1351:	c3                   	ret    
++    1352:	66 90                	xchg   %ax,%ax
++    1354:	66 90                	xchg   %ax,%ax
++    1356:	66 90                	xchg   %ax,%ax
++    1358:	66 90                	xchg   %ax,%ax
++    135a:	66 90                	xchg   %ax,%ax
++    135c:	66 90                	xchg   %ax,%ax
++    135e:	66 90                	xchg   %ax,%ax
++
++00001360 <printint>:
++  write(fd, &c, 1);
++}
++
++static void
++printint(int fd, int xx, int base, int sgn)
++{
++    1360:	55                   	push   %ebp
++    1361:	89 e5                	mov    %esp,%ebp
++    1363:	57                   	push   %edi
++    1364:	56                   	push   %esi
++    1365:	89 c6                	mov    %eax,%esi
++    1367:	53                   	push   %ebx
++    1368:	83 ec 4c             	sub    $0x4c,%esp
++  char buf[16];
++  int i, neg;
++  uint x;
++
++  neg = 0;
++  if(sgn && xx < 0){
++    136b:	8b 5d 08             	mov    0x8(%ebp),%ebx
++    136e:	85 db                	test   %ebx,%ebx
++    1370:	74 09                	je     137b <printint+0x1b>
++    1372:	89 d0                	mov    %edx,%eax
++    1374:	c1 e8 1f             	shr    $0x1f,%eax
++    1377:	84 c0                	test   %al,%al
++    1379:	75 75                	jne    13f0 <printint+0x90>
++    neg = 1;
++    x = -xx;
++  } else {
++    x = xx;
++    137b:	89 d0                	mov    %edx,%eax
++  neg = 0;
++    137d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
++    1384:	89 75 c0             	mov    %esi,-0x40(%ebp)
++  }
++
++  i = 0;
++    1387:	31 ff                	xor    %edi,%edi
++    1389:	89 ce                	mov    %ecx,%esi
++    138b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
++    138e:	eb 02                	jmp    1392 <printint+0x32>
++  do{
++    buf[i++] = digits[x % base];
++    1390:	89 cf                	mov    %ecx,%edi
++    1392:	31 d2                	xor    %edx,%edx
++    1394:	f7 f6                	div    %esi
++    1396:	8d 4f 01             	lea    0x1(%edi),%ecx
++    1399:	0f b6 92 b1 17 00 00 	movzbl 0x17b1(%edx),%edx
++  }while((x /= base) != 0);
++    13a0:	85 c0                	test   %eax,%eax
++    buf[i++] = digits[x % base];
++    13a2:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
++  }while((x /= base) != 0);
++    13a5:	75 e9                	jne    1390 <printint+0x30>
++  if(neg)
++    13a7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
++    buf[i++] = digits[x % base];
++    13aa:	89 c8                	mov    %ecx,%eax
++    13ac:	8b 75 c0             	mov    -0x40(%ebp),%esi
++  if(neg)
++    13af:	85 d2                	test   %edx,%edx
++    13b1:	74 08                	je     13bb <printint+0x5b>
++    buf[i++] = '-';
++    13b3:	8d 4f 02             	lea    0x2(%edi),%ecx
++    13b6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
++
++  while(--i >= 0)
++    13bb:	8d 79 ff             	lea    -0x1(%ecx),%edi
++    13be:	66 90                	xchg   %ax,%ax
++    13c0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
++    13c5:	83 ef 01             	sub    $0x1,%edi
++  write(fd, &c, 1);
++    13c8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    13cf:	00 
++    13d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++    13d4:	89 34 24             	mov    %esi,(%esp)
++    13d7:	88 45 d7             	mov    %al,-0x29(%ebp)
++    13da:	e8 e3 fe ff ff       	call   12c2 <write>
++  while(--i >= 0)
++    13df:	83 ff ff             	cmp    $0xffffffff,%edi
++    13e2:	75 dc                	jne    13c0 <printint+0x60>
++    putc(fd, buf[i]);
++}
++    13e4:	83 c4 4c             	add    $0x4c,%esp
++    13e7:	5b                   	pop    %ebx
++    13e8:	5e                   	pop    %esi
++    13e9:	5f                   	pop    %edi
++    13ea:	5d                   	pop    %ebp
++    13eb:	c3                   	ret    
++    13ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    x = -xx;
++    13f0:	89 d0                	mov    %edx,%eax
++    13f2:	f7 d8                	neg    %eax
++    neg = 1;
++    13f4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
++    13fb:	eb 87                	jmp    1384 <printint+0x24>
++    13fd:	8d 76 00             	lea    0x0(%esi),%esi
++
++00001400 <printf>:
++
++// Print to the given fd. Only understands %d, %x, %p, %s.
++void
++printf(int fd, char *fmt, ...)
++{
++    1400:	55                   	push   %ebp
++    1401:	89 e5                	mov    %esp,%ebp
++    1403:	57                   	push   %edi
++  char *s;
++  int c, i, state;
++  uint *ap;
++
++  state = 0;
++    1404:	31 ff                	xor    %edi,%edi
++{
++    1406:	56                   	push   %esi
++    1407:	53                   	push   %ebx
++    1408:	83 ec 3c             	sub    $0x3c,%esp
++  ap = (uint*)(void*)&fmt + 1;
++  for(i = 0; fmt[i]; i++){
++    140b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
++  ap = (uint*)(void*)&fmt + 1;
++    140e:	8d 45 10             	lea    0x10(%ebp),%eax
++{
++    1411:	8b 75 08             	mov    0x8(%ebp),%esi
++  ap = (uint*)(void*)&fmt + 1;
++    1414:	89 45 d4             	mov    %eax,-0x2c(%ebp)
++  for(i = 0; fmt[i]; i++){
++    1417:	0f b6 13             	movzbl (%ebx),%edx
++    141a:	83 c3 01             	add    $0x1,%ebx
++    141d:	84 d2                	test   %dl,%dl
++    141f:	75 39                	jne    145a <printf+0x5a>
++    1421:	e9 c2 00 00 00       	jmp    14e8 <printf+0xe8>
++    1426:	66 90                	xchg   %ax,%ax
++    c = fmt[i] & 0xff;
++    if(state == 0){
++      if(c == '%'){
++    1428:	83 fa 25             	cmp    $0x25,%edx
++    142b:	0f 84 bf 00 00 00    	je     14f0 <printf+0xf0>
++  write(fd, &c, 1);
++    1431:	8d 45 e2             	lea    -0x1e(%ebp),%eax
++    1434:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    143b:	00 
++    143c:	89 44 24 04          	mov    %eax,0x4(%esp)
++    1440:	89 34 24             	mov    %esi,(%esp)
++        state = '%';
++      } else {
++        putc(fd, c);
++    1443:	88 55 e2             	mov    %dl,-0x1e(%ebp)
++  write(fd, &c, 1);
++    1446:	e8 77 fe ff ff       	call   12c2 <write>
++    144b:	83 c3 01             	add    $0x1,%ebx
++  for(i = 0; fmt[i]; i++){
++    144e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
++    1452:	84 d2                	test   %dl,%dl
++    1454:	0f 84 8e 00 00 00    	je     14e8 <printf+0xe8>
++    if(state == 0){
++    145a:	85 ff                	test   %edi,%edi
++    c = fmt[i] & 0xff;
++    145c:	0f be c2             	movsbl %dl,%eax
++    if(state == 0){
++    145f:	74 c7                	je     1428 <printf+0x28>
++      }
++    } else if(state == '%'){
++    1461:	83 ff 25             	cmp    $0x25,%edi
++    1464:	75 e5                	jne    144b <printf+0x4b>
++      if(c == 'd'){
++    1466:	83 fa 64             	cmp    $0x64,%edx
++    1469:	0f 84 31 01 00 00    	je     15a0 <printf+0x1a0>
++        printint(fd, *ap, 10, 1);
++        ap++;
++      } else if(c == 'x' || c == 'p'){
++    146f:	25 f7 00 00 00       	and    $0xf7,%eax
++    1474:	83 f8 70             	cmp    $0x70,%eax
++    1477:	0f 84 83 00 00 00    	je     1500 <printf+0x100>
++        printint(fd, *ap, 16, 0);
++        ap++;
++      } else if(c == 's'){
++    147d:	83 fa 73             	cmp    $0x73,%edx
++    1480:	0f 84 a2 00 00 00    	je     1528 <printf+0x128>
++          s = "(null)";
++        while(*s != 0){
++          putc(fd, *s);
++          s++;
++        }
++      } else if(c == 'c'){
++    1486:	83 fa 63             	cmp    $0x63,%edx
++    1489:	0f 84 35 01 00 00    	je     15c4 <printf+0x1c4>
++        putc(fd, *ap);
++        ap++;
++      } else if(c == '%'){
++    148f:	83 fa 25             	cmp    $0x25,%edx
++    1492:	0f 84 e0 00 00 00    	je     1578 <printf+0x178>
++  write(fd, &c, 1);
++    1498:	8d 45 e6             	lea    -0x1a(%ebp),%eax
++    149b:	83 c3 01             	add    $0x1,%ebx
++    149e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    14a5:	00 
++      } else {
++        // Unknown % sequence.  Print it to draw attention.
++        putc(fd, '%');
++        putc(fd, c);
++      }
++      state = 0;
++    14a6:	31 ff                	xor    %edi,%edi
++  write(fd, &c, 1);
++    14a8:	89 44 24 04          	mov    %eax,0x4(%esp)
++    14ac:	89 34 24             	mov    %esi,(%esp)
++    14af:	89 55 d0             	mov    %edx,-0x30(%ebp)
++    14b2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
++    14b6:	e8 07 fe ff ff       	call   12c2 <write>
++        putc(fd, c);
++    14bb:	8b 55 d0             	mov    -0x30(%ebp),%edx
++  write(fd, &c, 1);
++    14be:	8d 45 e7             	lea    -0x19(%ebp),%eax
++    14c1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    14c8:	00 
++    14c9:	89 44 24 04          	mov    %eax,0x4(%esp)
++    14cd:	89 34 24             	mov    %esi,(%esp)
++        putc(fd, c);
++    14d0:	88 55 e7             	mov    %dl,-0x19(%ebp)
++  write(fd, &c, 1);
++    14d3:	e8 ea fd ff ff       	call   12c2 <write>
++  for(i = 0; fmt[i]; i++){
++    14d8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
++    14dc:	84 d2                	test   %dl,%dl
++    14de:	0f 85 76 ff ff ff    	jne    145a <printf+0x5a>
++    14e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    }
++  }
++}
++    14e8:	83 c4 3c             	add    $0x3c,%esp
++    14eb:	5b                   	pop    %ebx
++    14ec:	5e                   	pop    %esi
++    14ed:	5f                   	pop    %edi
++    14ee:	5d                   	pop    %ebp
++    14ef:	c3                   	ret    
++        state = '%';
++    14f0:	bf 25 00 00 00       	mov    $0x25,%edi
++    14f5:	e9 51 ff ff ff       	jmp    144b <printf+0x4b>
++    14fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++        printint(fd, *ap, 16, 0);
++    1500:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++    1503:	b9 10 00 00 00       	mov    $0x10,%ecx
++      state = 0;
++    1508:	31 ff                	xor    %edi,%edi
++        printint(fd, *ap, 16, 0);
++    150a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
++    1511:	8b 10                	mov    (%eax),%edx
++    1513:	89 f0                	mov    %esi,%eax
++    1515:	e8 46 fe ff ff       	call   1360 <printint>
++        ap++;
++    151a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++    151e:	e9 28 ff ff ff       	jmp    144b <printf+0x4b>
++    1523:	90                   	nop
++    1524:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++        s = (char*)*ap;
++    1528:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++        ap++;
++    152b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++        s = (char*)*ap;
++    152f:	8b 38                	mov    (%eax),%edi
++          s = "(null)";
++    1531:	b8 aa 17 00 00       	mov    $0x17aa,%eax
++    1536:	85 ff                	test   %edi,%edi
++    1538:	0f 44 f8             	cmove  %eax,%edi
++        while(*s != 0){
++    153b:	0f b6 07             	movzbl (%edi),%eax
++    153e:	84 c0                	test   %al,%al
++    1540:	74 2a                	je     156c <printf+0x16c>
++    1542:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    1548:	88 45 e3             	mov    %al,-0x1d(%ebp)
++  write(fd, &c, 1);
++    154b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
++          s++;
++    154e:	83 c7 01             	add    $0x1,%edi
++  write(fd, &c, 1);
++    1551:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1558:	00 
++    1559:	89 44 24 04          	mov    %eax,0x4(%esp)
++    155d:	89 34 24             	mov    %esi,(%esp)
++    1560:	e8 5d fd ff ff       	call   12c2 <write>
++        while(*s != 0){
++    1565:	0f b6 07             	movzbl (%edi),%eax
++    1568:	84 c0                	test   %al,%al
++    156a:	75 dc                	jne    1548 <printf+0x148>
++      state = 0;
++    156c:	31 ff                	xor    %edi,%edi
++    156e:	e9 d8 fe ff ff       	jmp    144b <printf+0x4b>
++    1573:	90                   	nop
++    1574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++  write(fd, &c, 1);
++    1578:	8d 45 e5             	lea    -0x1b(%ebp),%eax
++      state = 0;
++    157b:	31 ff                	xor    %edi,%edi
++  write(fd, &c, 1);
++    157d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1584:	00 
++    1585:	89 44 24 04          	mov    %eax,0x4(%esp)
++    1589:	89 34 24             	mov    %esi,(%esp)
++    158c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
++    1590:	e8 2d fd ff ff       	call   12c2 <write>
++    1595:	e9 b1 fe ff ff       	jmp    144b <printf+0x4b>
++    159a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++        printint(fd, *ap, 10, 1);
++    15a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++    15a3:	b9 0a 00 00 00       	mov    $0xa,%ecx
++      state = 0;
++    15a8:	66 31 ff             	xor    %di,%di
++        printint(fd, *ap, 10, 1);
++    15ab:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    15b2:	8b 10                	mov    (%eax),%edx
++    15b4:	89 f0                	mov    %esi,%eax
++    15b6:	e8 a5 fd ff ff       	call   1360 <printint>
++        ap++;
++    15bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++    15bf:	e9 87 fe ff ff       	jmp    144b <printf+0x4b>
++        putc(fd, *ap);
++    15c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++      state = 0;
++    15c7:	31 ff                	xor    %edi,%edi
++        putc(fd, *ap);
++    15c9:	8b 00                	mov    (%eax),%eax
++  write(fd, &c, 1);
++    15cb:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    15d2:	00 
++    15d3:	89 34 24             	mov    %esi,(%esp)
++        putc(fd, *ap);
++    15d6:	88 45 e4             	mov    %al,-0x1c(%ebp)
++  write(fd, &c, 1);
++    15d9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
++    15dc:	89 44 24 04          	mov    %eax,0x4(%esp)
++    15e0:	e8 dd fc ff ff       	call   12c2 <write>
++        ap++;
++    15e5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++    15e9:	e9 5d fe ff ff       	jmp    144b <printf+0x4b>
++    15ee:	66 90                	xchg   %ax,%ax
++
++000015f0 <free>:
++static Header base;
++static Header *freep;
++
++void
++free(void *ap)
++{
++    15f0:	55                   	push   %ebp
++  Header *bp, *p;
++
++  bp = (Header*)ap - 1;
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    15f1:	a1 6c 1a 00 00       	mov    0x1a6c,%eax
++{
++    15f6:	89 e5                	mov    %esp,%ebp
++    15f8:	57                   	push   %edi
++    15f9:	56                   	push   %esi
++    15fa:	53                   	push   %ebx
++    15fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    15fe:	8b 08                	mov    (%eax),%ecx
++  bp = (Header*)ap - 1;
++    1600:	8d 53 f8             	lea    -0x8(%ebx),%edx
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    1603:	39 d0                	cmp    %edx,%eax
++    1605:	72 11                	jb     1618 <free+0x28>
++    1607:	90                   	nop
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    1608:	39 c8                	cmp    %ecx,%eax
++    160a:	72 04                	jb     1610 <free+0x20>
++    160c:	39 ca                	cmp    %ecx,%edx
++    160e:	72 10                	jb     1620 <free+0x30>
++    1610:	89 c8                	mov    %ecx,%eax
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    1612:	39 d0                	cmp    %edx,%eax
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    1614:	8b 08                	mov    (%eax),%ecx
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    1616:	73 f0                	jae    1608 <free+0x18>
++    1618:	39 ca                	cmp    %ecx,%edx
++    161a:	72 04                	jb     1620 <free+0x30>
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    161c:	39 c8                	cmp    %ecx,%eax
++    161e:	72 f0                	jb     1610 <free+0x20>
++      break;
++  if(bp + bp->s.size == p->s.ptr){
++    1620:	8b 73 fc             	mov    -0x4(%ebx),%esi
++    1623:	8d 3c f2             	lea    (%edx,%esi,8),%edi
++    1626:	39 cf                	cmp    %ecx,%edi
++    1628:	74 1e                	je     1648 <free+0x58>
++    bp->s.size += p->s.ptr->s.size;
++    bp->s.ptr = p->s.ptr->s.ptr;
++  } else
++    bp->s.ptr = p->s.ptr;
++    162a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
++  if(p + p->s.size == bp){
++    162d:	8b 48 04             	mov    0x4(%eax),%ecx
++    1630:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
++    1633:	39 f2                	cmp    %esi,%edx
++    1635:	74 28                	je     165f <free+0x6f>
++    p->s.size += bp->s.size;
++    p->s.ptr = bp->s.ptr;
++  } else
++    p->s.ptr = bp;
++    1637:	89 10                	mov    %edx,(%eax)
++  freep = p;
++    1639:	a3 6c 1a 00 00       	mov    %eax,0x1a6c
++}
++    163e:	5b                   	pop    %ebx
++    163f:	5e                   	pop    %esi
++    1640:	5f                   	pop    %edi
++    1641:	5d                   	pop    %ebp
++    1642:	c3                   	ret    
++    1643:	90                   	nop
++    1644:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    bp->s.size += p->s.ptr->s.size;
++    1648:	03 71 04             	add    0x4(%ecx),%esi
++    164b:	89 73 fc             	mov    %esi,-0x4(%ebx)
++    bp->s.ptr = p->s.ptr->s.ptr;
++    164e:	8b 08                	mov    (%eax),%ecx
++    1650:	8b 09                	mov    (%ecx),%ecx
++    1652:	89 4b f8             	mov    %ecx,-0x8(%ebx)
++  if(p + p->s.size == bp){
++    1655:	8b 48 04             	mov    0x4(%eax),%ecx
++    1658:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
++    165b:	39 f2                	cmp    %esi,%edx
++    165d:	75 d8                	jne    1637 <free+0x47>
++    p->s.size += bp->s.size;
++    165f:	03 4b fc             	add    -0x4(%ebx),%ecx
++  freep = p;
++    1662:	a3 6c 1a 00 00       	mov    %eax,0x1a6c
++    p->s.size += bp->s.size;
++    1667:	89 48 04             	mov    %ecx,0x4(%eax)
++    p->s.ptr = bp->s.ptr;
++    166a:	8b 53 f8             	mov    -0x8(%ebx),%edx
++    166d:	89 10                	mov    %edx,(%eax)
++}
++    166f:	5b                   	pop    %ebx
++    1670:	5e                   	pop    %esi
++    1671:	5f                   	pop    %edi
++    1672:	5d                   	pop    %ebp
++    1673:	c3                   	ret    
++    1674:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    167a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
++
++00001680 <malloc>:
++  return freep;
++}
++
++void*
++malloc(uint nbytes)
++{
++    1680:	55                   	push   %ebp
++    1681:	89 e5                	mov    %esp,%ebp
++    1683:	57                   	push   %edi
++    1684:	56                   	push   %esi
++    1685:	53                   	push   %ebx
++    1686:	83 ec 1c             	sub    $0x1c,%esp
++  Header *p, *prevp;
++  uint nunits;
++
++  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
++    1689:	8b 45 08             	mov    0x8(%ebp),%eax
++  if((prevp = freep) == 0){
++    168c:	8b 1d 6c 1a 00 00    	mov    0x1a6c,%ebx
++  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
++    1692:	8d 48 07             	lea    0x7(%eax),%ecx
++    1695:	c1 e9 03             	shr    $0x3,%ecx
++  if((prevp = freep) == 0){
++    1698:	85 db                	test   %ebx,%ebx
++  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
++    169a:	8d 71 01             	lea    0x1(%ecx),%esi
++  if((prevp = freep) == 0){
++    169d:	0f 84 9b 00 00 00    	je     173e <malloc+0xbe>
++    16a3:	8b 13                	mov    (%ebx),%edx
++    16a5:	8b 7a 04             	mov    0x4(%edx),%edi
++    base.s.ptr = freep = prevp = &base;
++    base.s.size = 0;
++  }
++  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
++    if(p->s.size >= nunits){
++    16a8:	39 fe                	cmp    %edi,%esi
++    16aa:	76 64                	jbe    1710 <malloc+0x90>
++    16ac:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
++  if(nu < 4096)
++    16b3:	bb 00 80 00 00       	mov    $0x8000,%ebx
++    16b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++    16bb:	eb 0e                	jmp    16cb <malloc+0x4b>
++    16bd:	8d 76 00             	lea    0x0(%esi),%esi
++  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
++    16c0:	8b 02                	mov    (%edx),%eax
++    if(p->s.size >= nunits){
++    16c2:	8b 78 04             	mov    0x4(%eax),%edi
++    16c5:	39 fe                	cmp    %edi,%esi
++    16c7:	76 4f                	jbe    1718 <malloc+0x98>
++    16c9:	89 c2                	mov    %eax,%edx
++        p->s.size = nunits;
++      }
++      freep = prevp;
++      return (void*)(p + 1);
++    }
++    if(p == freep)
++    16cb:	3b 15 6c 1a 00 00    	cmp    0x1a6c,%edx
++    16d1:	75 ed                	jne    16c0 <malloc+0x40>
++  if(nu < 4096)
++    16d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
++    16d6:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
++    16dc:	bf 00 10 00 00       	mov    $0x1000,%edi
++    16e1:	0f 43 fe             	cmovae %esi,%edi
++    16e4:	0f 42 c3             	cmovb  %ebx,%eax
++  p = sbrk(nu * sizeof(Header));
++    16e7:	89 04 24             	mov    %eax,(%esp)
++    16ea:	e8 3b fc ff ff       	call   132a <sbrk>
++  if(p == (char*)-1)
++    16ef:	83 f8 ff             	cmp    $0xffffffff,%eax
++    16f2:	74 18                	je     170c <malloc+0x8c>
++  hp->s.size = nu;
++    16f4:	89 78 04             	mov    %edi,0x4(%eax)
++  free((void*)(hp + 1));
++    16f7:	83 c0 08             	add    $0x8,%eax
++    16fa:	89 04 24             	mov    %eax,(%esp)
++    16fd:	e8 ee fe ff ff       	call   15f0 <free>
++  return freep;
++    1702:	8b 15 6c 1a 00 00    	mov    0x1a6c,%edx
++      if((p = morecore(nunits)) == 0)
++    1708:	85 d2                	test   %edx,%edx
++    170a:	75 b4                	jne    16c0 <malloc+0x40>
++        return 0;
++    170c:	31 c0                	xor    %eax,%eax
++    170e:	eb 20                	jmp    1730 <malloc+0xb0>
++    if(p->s.size >= nunits){
++    1710:	89 d0                	mov    %edx,%eax
++    1712:	89 da                	mov    %ebx,%edx
++    1714:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++      if(p->s.size == nunits)
++    1718:	39 fe                	cmp    %edi,%esi
++    171a:	74 1c                	je     1738 <malloc+0xb8>
++        p->s.size -= nunits;
++    171c:	29 f7                	sub    %esi,%edi
++    171e:	89 78 04             	mov    %edi,0x4(%eax)
++        p += p->s.size;
++    1721:	8d 04 f8             	lea    (%eax,%edi,8),%eax
++        p->s.size = nunits;
++    1724:	89 70 04             	mov    %esi,0x4(%eax)
++      freep = prevp;
++    1727:	89 15 6c 1a 00 00    	mov    %edx,0x1a6c
++      return (void*)(p + 1);
++    172d:	83 c0 08             	add    $0x8,%eax
++  }
++}
++    1730:	83 c4 1c             	add    $0x1c,%esp
++    1733:	5b                   	pop    %ebx
++    1734:	5e                   	pop    %esi
++    1735:	5f                   	pop    %edi
++    1736:	5d                   	pop    %ebp
++    1737:	c3                   	ret    
++        prevp->s.ptr = p->s.ptr;
++    1738:	8b 08                	mov    (%eax),%ecx
++    173a:	89 0a                	mov    %ecx,(%edx)
++    173c:	eb e9                	jmp    1727 <malloc+0xa7>
++    base.s.ptr = freep = prevp = &base;
++    173e:	c7 05 6c 1a 00 00 70 	movl   $0x1a70,0x1a6c
++    1745:	1a 00 00 
++    base.s.size = 0;
++    1748:	ba 70 1a 00 00       	mov    $0x1a70,%edx
++    base.s.ptr = freep = prevp = &base;
++    174d:	c7 05 70 1a 00 00 70 	movl   $0x1a70,0x1a70
++    1754:	1a 00 00 
++    base.s.size = 0;
++    1757:	c7 05 74 1a 00 00 00 	movl   $0x0,0x1a74
++    175e:	00 00 00 
++    1761:	e9 46 ff ff ff       	jmp    16ac <malloc+0x2c>
++    1766:	66 90                	xchg   %ax,%ax
++    1768:	66 90                	xchg   %ax,%ax
++    176a:	66 90                	xchg   %ax,%ax
++    176c:	66 90                	xchg   %ax,%ax
++    176e:	66 90                	xchg   %ax,%ax
++
++00001770 <uacquire>:
++#include "uspinlock.h"
++#include "x86.h"
++
++void
++uacquire(struct uspinlock *lk)
++{
++    1770:	55                   	push   %ebp
++xchg(volatile uint *addr, uint newval)
++{
++  uint result;
++
++  // The + in "+m" denotes a read-modify-write operand.
++  asm volatile("lock; xchgl %0, %1" :
++    1771:	b9 01 00 00 00       	mov    $0x1,%ecx
++    1776:	89 e5                	mov    %esp,%ebp
++    1778:	8b 55 08             	mov    0x8(%ebp),%edx
++    177b:	90                   	nop
++    177c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    1780:	89 c8                	mov    %ecx,%eax
++    1782:	f0 87 02             	lock xchg %eax,(%edx)
++  // The xchg is atomic.
++  while(xchg(&lk->locked, 1) != 0)
++    1785:	85 c0                	test   %eax,%eax
++    1787:	75 f7                	jne    1780 <uacquire+0x10>
++    ;
++
++  // Tell the C compiler and the processor to not move loads or stores
++  // past this point, to ensure that the critical section's memory
++  // references happen after the lock is acquired.
++  __sync_synchronize();
++    1789:	0f ae f0             	mfence 
++}
++    178c:	5d                   	pop    %ebp
++    178d:	c3                   	ret    
++    178e:	66 90                	xchg   %ax,%ax
++
++00001790 <urelease>:
++
++void urelease (struct uspinlock *lk) {
++    1790:	55                   	push   %ebp
++    1791:	89 e5                	mov    %esp,%ebp
++    1793:	8b 45 08             	mov    0x8(%ebp),%eax
++  __sync_synchronize();
++    1796:	0f ae f0             	mfence 
++
++  // Release the lock, equivalent to lk->locked = 0.
++  // This code can't use a C assignment, since it might
++  // not be atomic. A real OS would use C atomics here.
++  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
++    1799:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
++}
++    179f:	5d                   	pop    %ebp
++    17a0:	c3                   	ret    
+diff --git a/echo.c b/echo.c
+index eed68a0..806dee0 100644
+--- a/echo.c
++++ b/echo.c
+@@ -9,5 +9,5 @@ main(int argc, char *argv[])
+ 
+   for(i = 1; i < argc; i++)
+     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+-  exit(0);
++  exit();
+ }
+diff --git a/echo.d b/echo.d
+new file mode 100644
+index 0000000..16a6098
+--- /dev/null
++++ b/echo.d
+@@ -0,0 +1 @@
++echo.o: echo.c /usr/include/stdc-predef.h types.h stat.h user.h
+diff --git a/echo.o b/echo.o
+new file mode 100644
+index 0000000..692b600
+Binary files /dev/null and b/echo.o differ
+diff --git a/echo.sym b/echo.sym
+new file mode 100644
+index 0000000..5c2052d
+--- /dev/null
++++ b/echo.sym
+@@ -0,0 +1,62 @@
++00001000 .text
++000017a1 .rodata
++000017c4 .eh_frame
++00001a6c .bss
++00000000 .comment
++00000000 .debug_aranges
++00000000 .debug_info
++00000000 .debug_abbrev
++00000000 .debug_line
++00000000 .debug_str
++00000000 .debug_loc
++00000000 .debug_ranges
++00000000 echo.c
++00000000 ulib.c
++00000000 printf.c
++00001360 printint
++000017b1 digits.1359
++00000000 umalloc.c
++00001a6c freep
++00001a70 base
++00000000 uspinlock.c
++00001080 strcpy
++00001400 printf
++00001270 memmove
++000012ea mknod
++00001342 shm_open
++00001190 gets
++00001322 getpid
++00001680 malloc
++00001332 sleep
++000012b2 pipe
++000012c2 write
++000012fa fstat
++000012d2 kill
++00001312 chdir
++000012da exec
++000012aa wait
++000012ba read
++000012f2 unlink
++00001770 uacquire
++0000129a fork
++0000132a sbrk
++0000134a shm_close
++0000133a uptime
++00001a6c __bss_start
++00001130 memset
++00001000 main
++000010b0 strcmp
++0000131a dup
++000011f0 stat
++00001a6c _edata
++00001a78 _end
++00001302 link
++000012a2 exit
++00001240 atoi
++00001100 strlen
++000012e2 open
++00001150 strchr
++0000130a mkdir
++000012ca close
++00001790 urelease
++000015f0 free
+diff --git a/entry.o b/entry.o
+new file mode 100644
+index 0000000..aac007f
+Binary files /dev/null and b/entry.o differ
+diff --git a/entryother b/entryother
+new file mode 100644
+index 0000000..a7673de
+Binary files /dev/null and b/entryother differ
+diff --git a/entryother.asm b/entryother.asm
+new file mode 100644
+index 0000000..c845a5d
+--- /dev/null
++++ b/entryother.asm
+@@ -0,0 +1,125 @@
++
++bootblockother.o:     file format elf32-i386
++
++
++Disassembly of section .text:
++
++00007000 <start>:
++# This code combines elements of bootasm.S and entry.S.
++
++.code16           
++.globl start
++start:
++  cli            
++    7000:	fa                   	cli    
++
++  # Zero data segment registers DS, ES, and SS.
++  xorw    %ax,%ax
++    7001:	31 c0                	xor    %eax,%eax
++  movw    %ax,%ds
++    7003:	8e d8                	mov    %eax,%ds
++  movw    %ax,%es
++    7005:	8e c0                	mov    %eax,%es
++  movw    %ax,%ss
++    7007:	8e d0                	mov    %eax,%ss
++
++  # Switch from real to protected mode.  Use a bootstrap GDT that makes
++  # virtual addresses map directly to physical addresses so that the
++  # effective memory map doesn't change during the transition.
++  lgdt    gdtdesc
++    7009:	0f 01 16             	lgdtl  (%esi)
++    700c:	84 70 0f             	test   %dh,0xf(%eax)
++  movl    %cr0, %eax
++    700f:	20 c0                	and    %al,%al
++  orl     $CR0_PE, %eax
++    7011:	66 83 c8 01          	or     $0x1,%ax
++  movl    %eax, %cr0
++    7015:	0f 22 c0             	mov    %eax,%cr0
++
++  # Complete the transition to 32-bit protected mode by using a long jmp
++  # to reload %cs and %eip.  The segment descriptors are set up with no
++  # translation, so that the mapping is still the identity mapping.
++  ljmpl    $(SEG_KCODE<<3), $(start32)
++    7018:	66 ea 20 70 00 00    	ljmpw  $0x0,$0x7020
++    701e:	08 00                	or     %al,(%eax)
++
++00007020 <start32>:
++
++//PAGEBREAK!
++.code32  # Tell assembler to generate 32-bit code now.
++start32:
++  # Set up the protected-mode data segment registers
++  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
++    7020:	66 b8 10 00          	mov    $0x10,%ax
++  movw    %ax, %ds                # -> DS: Data Segment
++    7024:	8e d8                	mov    %eax,%ds
++  movw    %ax, %es                # -> ES: Extra Segment
++    7026:	8e c0                	mov    %eax,%es
++  movw    %ax, %ss                # -> SS: Stack Segment
++    7028:	8e d0                	mov    %eax,%ss
++  movw    $0, %ax                 # Zero segments not ready for use
++    702a:	66 b8 00 00          	mov    $0x0,%ax
++  movw    %ax, %fs                # -> FS
++    702e:	8e e0                	mov    %eax,%fs
++  movw    %ax, %gs                # -> GS
++    7030:	8e e8                	mov    %eax,%gs
++
++  # Turn on page size extension for 4Mbyte pages
++  movl    %cr4, %eax
++    7032:	0f 20 e0             	mov    %cr4,%eax
++  orl     $(CR4_PSE), %eax
++    7035:	83 c8 10             	or     $0x10,%eax
++  movl    %eax, %cr4
++    7038:	0f 22 e0             	mov    %eax,%cr4
++  # Use entrypgdir as our initial page table
++  movl    (start-12), %eax
++    703b:	a1 f4 6f 00 00       	mov    0x6ff4,%eax
++  movl    %eax, %cr3
++    7040:	0f 22 d8             	mov    %eax,%cr3
++  # Turn on paging.
++  movl    %cr0, %eax
++    7043:	0f 20 c0             	mov    %cr0,%eax
++  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
++    7046:	0d 01 00 01 80       	or     $0x80010001,%eax
++  movl    %eax, %cr0
++    704b:	0f 22 c0             	mov    %eax,%cr0
++
++  # Switch to the stack allocated by startothers()
++  movl    (start-4), %esp
++    704e:	8b 25 fc 6f 00 00    	mov    0x6ffc,%esp
++  # Call mpenter()
++  call	 *(start-8)
++    7054:	ff 15 f8 6f 00 00    	call   *0x6ff8
++
++  movw    $0x8a00, %ax
++    705a:	66 b8 00 8a          	mov    $0x8a00,%ax
++  movw    %ax, %dx
++    705e:	66 89 c2             	mov    %ax,%dx
++  outw    %ax, %dx
++    7061:	66 ef                	out    %ax,(%dx)
++  movw    $0x8ae0, %ax
++    7063:	66 b8 e0 8a          	mov    $0x8ae0,%ax
++  outw    %ax, %dx
++    7067:	66 ef                	out    %ax,(%dx)
++
++00007069 <spin>:
++spin:
++  jmp     spin
++    7069:	eb fe                	jmp    7069 <spin>
++    706b:	90                   	nop
++
++0000706c <gdt>:
++	...
++    7074:	ff                   	(bad)  
++    7075:	ff 00                	incl   (%eax)
++    7077:	00 00                	add    %al,(%eax)
++    7079:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
++    7080:	00                   	.byte 0x0
++    7081:	92                   	xchg   %eax,%edx
++    7082:	cf                   	iret   
++	...
++
++00007084 <gdtdesc>:
++    7084:	17                   	pop    %ss
++    7085:	00 6c 70 00          	add    %ch,0x0(%eax,%esi,2)
++	...
+diff --git a/entryother.d b/entryother.d
+new file mode 100644
+index 0000000..a140303
+--- /dev/null
++++ b/entryother.d
+@@ -0,0 +1 @@
++entryother.o: entryother.S asm.h memlayout.h mmu.h
+diff --git a/entryother.o b/entryother.o
+new file mode 100644
+index 0000000..3beef68
+Binary files /dev/null and b/entryother.o differ
+diff --git a/exec.c b/exec.c
+index b40134f..bb64faa 100644
+--- a/exec.c
++++ b/exec.c
+@@ -13,70 +13,72 @@ exec(char *path, char **argv)
+   char *s, *last;
+   int i, off;
+   uint argc, sz, sp, ustack[3+MAXARG+1];
++  uint stackTop;
+   struct elfhdr elf;
+   struct inode *ip;
+   struct proghdr ph;
+   pde_t *pgdir, *oldpgdir;
+   struct proc *curproc = myproc();
+ 
+-  begin_op();
++    begin_op();
+ 
+-  if((ip = namei(path)) == 0){
+-    end_op();
+-    cprintf("exec: fail\n");
+-    return -1;
+-  }
+-  ilock(ip);
+-  pgdir = 0;
++    if ((ip = namei(path)) == 0) {
++        end_op();
++        cprintf("exec: fail\n");
++        return -1;
++    }
++    ilock(ip);
++    pgdir = 0;
+ 
+-  // Check ELF header
+-  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
+-    goto bad;
+-  if(elf.magic != ELF_MAGIC)
+-    goto bad;
++    // Check ELF header
++    if (readi(ip, (char *) &elf, 0, sizeof(elf)) != sizeof(elf))
++        goto bad;
++    if (elf.magic != ELF_MAGIC)
++        goto bad;
+ 
+-  if((pgdir = setupkvm()) == 0)
+-    goto bad;
++    if ((pgdir = setupkvm()) == 0)
++        goto bad;
+ 
+-  // Load program into memory.
+-  sz = 0;
+-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+-    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
+-      goto bad;
+-    if(ph.type != ELF_PROG_LOAD)
+-      continue;
+-    if(ph.memsz < ph.filesz)
+-      goto bad;
+-    if(ph.vaddr + ph.memsz < ph.vaddr)
+-      goto bad;
+-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+-      goto bad;
+-    if(ph.vaddr % PGSIZE != 0)
+-      goto bad;
+-    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+-      goto bad;
+-  }
+-  iunlockput(ip);
+-  end_op();
+-  ip = 0;
++    // Load program into memory.
++    sz = 0;
++    for (i = 0, off = elf.phoff; i < elf.phnum; i++, off += sizeof(ph)) {
++        if (readi(ip, (char *) &ph, off, sizeof(ph)) != sizeof(ph))
++            goto bad;
++        if (ph.type != ELF_PROG_LOAD)
++            continue;
++        if (ph.memsz < ph.filesz)
++            goto bad;
++        if (ph.vaddr + ph.memsz < ph.vaddr)
++            goto bad;
++        if ((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
++            goto bad;
++        if (ph.vaddr % PGSIZE != 0)
++            goto bad;
++        if (loaduvm(pgdir, (char *) ph.vaddr, ip, ph.off, ph.filesz) < 0)
++            goto bad;
++    }
++    iunlockput(ip);
++    end_op();
++    ip = 0;
+ 
+-  // Allocate two pages at the next page boundary.
+-  // Make the first inaccessible.  Use the second as the user stack.
+-  sz = PGROUNDUP(sz);
+-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+-    goto bad;
+-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+-  sp = sz;
++    // Allocate two pages at the next page boundary.
++    // Make the first inaccessible.  Use the second as the user stack.
++//  sz = PGROUNDUP(sz);
++    stackTop = USERTOP - 2 * PGSIZE;
++    if ((sp = allocuvm(pgdir, stackTop, USERTOP)) == 0)
++        goto bad;
++    clearpteu(pgdir, (char *) (stackTop));
++    //sp = sz;
+ 
+-  // Push argument strings, prepare rest of stack in ustack.
+-  for(argc = 0; argv[argc]; argc++) {
+-    if(argc >= MAXARG)
+-      goto bad;
+-    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+-    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+-      goto bad;
+-    ustack[3+argc] = sp;
+-  }
++    // Push argument strings, prepare rest of stack in ustack.
++    for (argc = 0; argv[argc]; argc++) {
++        if (argc >= MAXARG)
++            goto bad;
++        sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
++        if (copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
++            goto bad;
++        ustack[3 + argc] = sp;
++    }
+   ustack[3+argc] = 0;
+ 
+   ustack[0] = 0xffffffff;  // fake return PC
+@@ -99,6 +101,7 @@ exec(char *path, char **argv)
+   curproc->sz = sz;
+   curproc->tf->eip = elf.entry;  // main
+   curproc->tf->esp = sp;
++  curproc->stackTop = stackTop;
+   switchuvm(curproc);
+   freevm(oldpgdir);
+   return 0;
+diff --git a/exec.d b/exec.d
+new file mode 100644
+index 0000000..0400275
+--- /dev/null
++++ b/exec.d
+@@ -0,0 +1,2 @@
++exec.o: exec.c /usr/include/stdc-predef.h types.h param.h memlayout.h \
++ mmu.h proc.h defs.h x86.h elf.h
+diff --git a/exec.o b/exec.o
+new file mode 100644
+index 0000000..410cb49
+Binary files /dev/null and b/exec.o differ
+diff --git a/file.c b/file.c
+index 24b32c2..95cadb3 100644
+--- a/file.c
++++ b/file.c
+@@ -130,7 +130,7 @@ filewrite(struct file *f, char *addr, int n)
+     // and 2 blocks of slop for non-aligned writes.
+     // this really belongs lower down, since writei()
+     // might be writing a device like the console.
+-    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
++    int max = ((LOGSIZE-1-1-2) / 2) * 512;
+     int i = 0;
+     while(i < n){
+       int n1 = n - i;
+diff --git a/file.d b/file.d
+new file mode 100644
+index 0000000..fea73d1
+--- /dev/null
++++ b/file.d
+@@ -0,0 +1,2 @@
++file.o: file.c /usr/include/stdc-predef.h types.h defs.h param.h fs.h \
++ spinlock.h sleeplock.h file.h
+diff --git a/file.o b/file.o
+new file mode 100644
+index 0000000..3fa31a8
+Binary files /dev/null and b/file.o differ
+diff --git a/forktest.asm b/forktest.asm
+new file mode 100644
+index 0000000..7cba8fd
+--- /dev/null
++++ b/forktest.asm
+@@ -0,0 +1,652 @@
++
++_forktest:     file format elf32-i386
++
++
++Disassembly of section .text:
++
++00001000 <main>:
++  printf(1, "fork test OK\n");
++}
++
++int
++main(void)
++{
++    1000:	55                   	push   %ebp
++    1001:	89 e5                	mov    %esp,%ebp
++    1003:	83 e4 f0             	and    $0xfffffff0,%esp
++  forktest();
++    1006:	e8 35 00 00 00       	call   1040 <forktest>
++  exit();
++    100b:	e8 32 03 00 00       	call   1342 <exit>
++
++00001010 <printf>:
++{
++    1010:	55                   	push   %ebp
++    1011:	89 e5                	mov    %esp,%ebp
++    1013:	53                   	push   %ebx
++    1014:	83 ec 14             	sub    $0x14,%esp
++    1017:	8b 5d 0c             	mov    0xc(%ebp),%ebx
++  write(fd, s, strlen(s));
++    101a:	89 1c 24             	mov    %ebx,(%esp)
++    101d:	e8 7e 01 00 00       	call   11a0 <strlen>
++    1022:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++    1026:	89 44 24 08          	mov    %eax,0x8(%esp)
++    102a:	8b 45 08             	mov    0x8(%ebp),%eax
++    102d:	89 04 24             	mov    %eax,(%esp)
++    1030:	e8 2d 03 00 00       	call   1362 <write>
++}
++    1035:	83 c4 14             	add    $0x14,%esp
++    1038:	5b                   	pop    %ebx
++    1039:	5d                   	pop    %ebp
++    103a:	c3                   	ret    
++    103b:	90                   	nop
++    103c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++
++00001040 <forktest>:
++{
++    1040:	55                   	push   %ebp
++    1041:	89 e5                	mov    %esp,%ebp
++    1043:	53                   	push   %ebx
++  for(n=0; n<N; n++){
++    1044:	31 db                	xor    %ebx,%ebx
++{
++    1046:	83 ec 14             	sub    $0x14,%esp
++  printf(1, "fork test\n");
++    1049:	c7 44 24 04 f4 13 00 	movl   $0x13f4,0x4(%esp)
++    1050:	00 
++    1051:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    1058:	e8 b3 ff ff ff       	call   1010 <printf>
++    105d:	eb 13                	jmp    1072 <forktest+0x32>
++    105f:	90                   	nop
++    if(pid == 0)
++    1060:	0f 84 97 00 00 00    	je     10fd <forktest+0xbd>
++  for(n=0; n<N; n++){
++    1066:	83 c3 01             	add    $0x1,%ebx
++    1069:	81 fb e8 03 00 00    	cmp    $0x3e8,%ebx
++    106f:	90                   	nop
++    1070:	74 4e                	je     10c0 <forktest+0x80>
++    pid = fork();
++    1072:	e8 c3 02 00 00       	call   133a <fork>
++    if(pid < 0)
++    1077:	85 c0                	test   %eax,%eax
++    1079:	79 e5                	jns    1060 <forktest+0x20>
++  for(; n > 0; n--){
++    107b:	85 db                	test   %ebx,%ebx
++    107d:	8d 76 00             	lea    0x0(%esi),%esi
++    1080:	74 15                	je     1097 <forktest+0x57>
++    1082:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    if(wait() < 0){
++    1088:	e8 bd 02 00 00       	call   134a <wait>
++    108d:	85 c0                	test   %eax,%eax
++    108f:	90                   	nop
++    1090:	78 57                	js     10e9 <forktest+0xa9>
++  for(; n > 0; n--){
++    1092:	83 eb 01             	sub    $0x1,%ebx
++    1095:	75 f1                	jne    1088 <forktest+0x48>
++  if(wait() != -1){
++    1097:	e8 ae 02 00 00       	call   134a <wait>
++    109c:	83 f8 ff             	cmp    $0xffffffff,%eax
++    109f:	90                   	nop
++    10a0:	75 60                	jne    1102 <forktest+0xc2>
++  printf(1, "fork test OK\n");
++    10a2:	c7 44 24 04 26 14 00 	movl   $0x1426,0x4(%esp)
++    10a9:	00 
++    10aa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    10b1:	e8 5a ff ff ff       	call   1010 <printf>
++}
++    10b6:	83 c4 14             	add    $0x14,%esp
++    10b9:	5b                   	pop    %ebx
++    10ba:	5d                   	pop    %ebp
++    10bb:	c3                   	ret    
++    10bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++  write(fd, s, strlen(s));
++    10c0:	c7 04 24 34 14 00 00 	movl   $0x1434,(%esp)
++    10c7:	e8 d4 00 00 00       	call   11a0 <strlen>
++    10cc:	c7 44 24 04 34 14 00 	movl   $0x1434,0x4(%esp)
++    10d3:	00 
++    10d4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    10db:	89 44 24 08          	mov    %eax,0x8(%esp)
++    10df:	e8 7e 02 00 00       	call   1362 <write>
++    exit();
++    10e4:	e8 59 02 00 00       	call   1342 <exit>
++      printf(1, "wait stopped early\n");
++    10e9:	c7 44 24 04 ff 13 00 	movl   $0x13ff,0x4(%esp)
++    10f0:	00 
++    10f1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    10f8:	e8 13 ff ff ff       	call   1010 <printf>
++      exit();
++    10fd:	e8 40 02 00 00       	call   1342 <exit>
++    printf(1, "wait got too many\n");
++    1102:	c7 44 24 04 13 14 00 	movl   $0x1413,0x4(%esp)
++    1109:	00 
++    110a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    1111:	e8 fa fe ff ff       	call   1010 <printf>
++    exit();
++    1116:	e8 27 02 00 00       	call   1342 <exit>
++    111b:	66 90                	xchg   %ax,%ax
++    111d:	66 90                	xchg   %ax,%ax
++    111f:	90                   	nop
++
++00001120 <strcpy>:
++#include "user.h"
++#include "x86.h"
++
++char*
++strcpy(char *s, char *t)
++{
++    1120:	55                   	push   %ebp
++    1121:	89 e5                	mov    %esp,%ebp
++    1123:	8b 45 08             	mov    0x8(%ebp),%eax
++    1126:	8b 4d 0c             	mov    0xc(%ebp),%ecx
++    1129:	53                   	push   %ebx
++  char *os;
++
++  os = s;
++  while((*s++ = *t++) != 0)
++    112a:	89 c2                	mov    %eax,%edx
++    112c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    1130:	83 c1 01             	add    $0x1,%ecx
++    1133:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
++    1137:	83 c2 01             	add    $0x1,%edx
++    113a:	84 db                	test   %bl,%bl
++    113c:	88 5a ff             	mov    %bl,-0x1(%edx)
++    113f:	75 ef                	jne    1130 <strcpy+0x10>
++    ;
++  return os;
++}
++    1141:	5b                   	pop    %ebx
++    1142:	5d                   	pop    %ebp
++    1143:	c3                   	ret    
++    1144:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    114a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
++
++00001150 <strcmp>:
++
++int
++strcmp(const char *p, const char *q)
++{
++    1150:	55                   	push   %ebp
++    1151:	89 e5                	mov    %esp,%ebp
++    1153:	8b 55 08             	mov    0x8(%ebp),%edx
++    1156:	53                   	push   %ebx
++    1157:	8b 4d 0c             	mov    0xc(%ebp),%ecx
++  while(*p && *p == *q)
++    115a:	0f b6 02             	movzbl (%edx),%eax
++    115d:	84 c0                	test   %al,%al
++    115f:	74 2d                	je     118e <strcmp+0x3e>
++    1161:	0f b6 19             	movzbl (%ecx),%ebx
++    1164:	38 d8                	cmp    %bl,%al
++    1166:	74 0e                	je     1176 <strcmp+0x26>
++    1168:	eb 2b                	jmp    1195 <strcmp+0x45>
++    116a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    1170:	38 c8                	cmp    %cl,%al
++    1172:	75 15                	jne    1189 <strcmp+0x39>
++    p++, q++;
++    1174:	89 d9                	mov    %ebx,%ecx
++    1176:	83 c2 01             	add    $0x1,%edx
++  while(*p && *p == *q)
++    1179:	0f b6 02             	movzbl (%edx),%eax
++    p++, q++;
++    117c:	8d 59 01             	lea    0x1(%ecx),%ebx
++  while(*p && *p == *q)
++    117f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
++    1183:	84 c0                	test   %al,%al
++    1185:	75 e9                	jne    1170 <strcmp+0x20>
++    1187:	31 c0                	xor    %eax,%eax
++  return (uchar)*p - (uchar)*q;
++    1189:	29 c8                	sub    %ecx,%eax
++}
++    118b:	5b                   	pop    %ebx
++    118c:	5d                   	pop    %ebp
++    118d:	c3                   	ret    
++    118e:	0f b6 09             	movzbl (%ecx),%ecx
++  while(*p && *p == *q)
++    1191:	31 c0                	xor    %eax,%eax
++    1193:	eb f4                	jmp    1189 <strcmp+0x39>
++    1195:	0f b6 cb             	movzbl %bl,%ecx
++    1198:	eb ef                	jmp    1189 <strcmp+0x39>
++    119a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++
++000011a0 <strlen>:
++
++uint
++strlen(char *s)
++{
++    11a0:	55                   	push   %ebp
++    11a1:	89 e5                	mov    %esp,%ebp
++    11a3:	8b 4d 08             	mov    0x8(%ebp),%ecx
++  int n;
++
++  for(n = 0; s[n]; n++)
++    11a6:	80 39 00             	cmpb   $0x0,(%ecx)
++    11a9:	74 12                	je     11bd <strlen+0x1d>
++    11ab:	31 d2                	xor    %edx,%edx
++    11ad:	8d 76 00             	lea    0x0(%esi),%esi
++    11b0:	83 c2 01             	add    $0x1,%edx
++    11b3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
++    11b7:	89 d0                	mov    %edx,%eax
++    11b9:	75 f5                	jne    11b0 <strlen+0x10>
++    ;
++  return n;
++}
++    11bb:	5d                   	pop    %ebp
++    11bc:	c3                   	ret    
++  for(n = 0; s[n]; n++)
++    11bd:	31 c0                	xor    %eax,%eax
++}
++    11bf:	5d                   	pop    %ebp
++    11c0:	c3                   	ret    
++    11c1:	eb 0d                	jmp    11d0 <memset>
++    11c3:	90                   	nop
++    11c4:	90                   	nop
++    11c5:	90                   	nop
++    11c6:	90                   	nop
++    11c7:	90                   	nop
++    11c8:	90                   	nop
++    11c9:	90                   	nop
++    11ca:	90                   	nop
++    11cb:	90                   	nop
++    11cc:	90                   	nop
++    11cd:	90                   	nop
++    11ce:	90                   	nop
++    11cf:	90                   	nop
++
++000011d0 <memset>:
++
++void*
++memset(void *dst, int c, uint n)
++{
++    11d0:	55                   	push   %ebp
++    11d1:	89 e5                	mov    %esp,%ebp
++    11d3:	8b 55 08             	mov    0x8(%ebp),%edx
++    11d6:	57                   	push   %edi
++}
++
++static inline void
++stosb(void *addr, int data, int cnt)
++{
++  asm volatile("cld; rep stosb" :
++    11d7:	8b 4d 10             	mov    0x10(%ebp),%ecx
++    11da:	8b 45 0c             	mov    0xc(%ebp),%eax
++    11dd:	89 d7                	mov    %edx,%edi
++    11df:	fc                   	cld    
++    11e0:	f3 aa                	rep stos %al,%es:(%edi)
++  stosb(dst, c, n);
++  return dst;
++}
++    11e2:	89 d0                	mov    %edx,%eax
++    11e4:	5f                   	pop    %edi
++    11e5:	5d                   	pop    %ebp
++    11e6:	c3                   	ret    
++    11e7:	89 f6                	mov    %esi,%esi
++    11e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++000011f0 <strchr>:
++
++char*
++strchr(const char *s, char c)
++{
++    11f0:	55                   	push   %ebp
++    11f1:	89 e5                	mov    %esp,%ebp
++    11f3:	8b 45 08             	mov    0x8(%ebp),%eax
++    11f6:	53                   	push   %ebx
++    11f7:	8b 55 0c             	mov    0xc(%ebp),%edx
++  for(; *s; s++)
++    11fa:	0f b6 18             	movzbl (%eax),%ebx
++    11fd:	84 db                	test   %bl,%bl
++    11ff:	74 1d                	je     121e <strchr+0x2e>
++    if(*s == c)
++    1201:	38 d3                	cmp    %dl,%bl
++    1203:	89 d1                	mov    %edx,%ecx
++    1205:	75 0d                	jne    1214 <strchr+0x24>
++    1207:	eb 17                	jmp    1220 <strchr+0x30>
++    1209:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++    1210:	38 ca                	cmp    %cl,%dl
++    1212:	74 0c                	je     1220 <strchr+0x30>
++  for(; *s; s++)
++    1214:	83 c0 01             	add    $0x1,%eax
++    1217:	0f b6 10             	movzbl (%eax),%edx
++    121a:	84 d2                	test   %dl,%dl
++    121c:	75 f2                	jne    1210 <strchr+0x20>
++      return (char*)s;
++  return 0;
++    121e:	31 c0                	xor    %eax,%eax
++}
++    1220:	5b                   	pop    %ebx
++    1221:	5d                   	pop    %ebp
++    1222:	c3                   	ret    
++    1223:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    1229:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++00001230 <gets>:
++
++char*
++gets(char *buf, int max)
++{
++    1230:	55                   	push   %ebp
++    1231:	89 e5                	mov    %esp,%ebp
++    1233:	57                   	push   %edi
++    1234:	56                   	push   %esi
++  int i, cc;
++  char c;
++
++  for(i=0; i+1 < max; ){
++    1235:	31 f6                	xor    %esi,%esi
++{
++    1237:	53                   	push   %ebx
++    1238:	83 ec 2c             	sub    $0x2c,%esp
++    cc = read(0, &c, 1);
++    123b:	8d 7d e7             	lea    -0x19(%ebp),%edi
++  for(i=0; i+1 < max; ){
++    123e:	eb 31                	jmp    1271 <gets+0x41>
++    cc = read(0, &c, 1);
++    1240:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1247:	00 
++    1248:	89 7c 24 04          	mov    %edi,0x4(%esp)
++    124c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
++    1253:	e8 02 01 00 00       	call   135a <read>
++    if(cc < 1)
++    1258:	85 c0                	test   %eax,%eax
++    125a:	7e 1d                	jle    1279 <gets+0x49>
++      break;
++    buf[i++] = c;
++    125c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
++  for(i=0; i+1 < max; ){
++    1260:	89 de                	mov    %ebx,%esi
++    buf[i++] = c;
++    1262:	8b 55 08             	mov    0x8(%ebp),%edx
++    if(c == '\n' || c == '\r')
++    1265:	3c 0d                	cmp    $0xd,%al
++    buf[i++] = c;
++    1267:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
++    if(c == '\n' || c == '\r')
++    126b:	74 0c                	je     1279 <gets+0x49>
++    126d:	3c 0a                	cmp    $0xa,%al
++    126f:	74 08                	je     1279 <gets+0x49>
++  for(i=0; i+1 < max; ){
++    1271:	8d 5e 01             	lea    0x1(%esi),%ebx
++    1274:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
++    1277:	7c c7                	jl     1240 <gets+0x10>
++      break;
++  }
++  buf[i] = '\0';
++    1279:	8b 45 08             	mov    0x8(%ebp),%eax
++    127c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
++  return buf;
++}
++    1280:	83 c4 2c             	add    $0x2c,%esp
++    1283:	5b                   	pop    %ebx
++    1284:	5e                   	pop    %esi
++    1285:	5f                   	pop    %edi
++    1286:	5d                   	pop    %ebp
++    1287:	c3                   	ret    
++    1288:	90                   	nop
++    1289:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++
++00001290 <stat>:
++
++int
++stat(char *n, struct stat *st)
++{
++    1290:	55                   	push   %ebp
++    1291:	89 e5                	mov    %esp,%ebp
++    1293:	56                   	push   %esi
++    1294:	53                   	push   %ebx
++    1295:	83 ec 10             	sub    $0x10,%esp
++  int fd;
++  int r;
++
++  fd = open(n, O_RDONLY);
++    1298:	8b 45 08             	mov    0x8(%ebp),%eax
++    129b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
++    12a2:	00 
++    12a3:	89 04 24             	mov    %eax,(%esp)
++    12a6:	e8 d7 00 00 00       	call   1382 <open>
++  if(fd < 0)
++    12ab:	85 c0                	test   %eax,%eax
++  fd = open(n, O_RDONLY);
++    12ad:	89 c3                	mov    %eax,%ebx
++  if(fd < 0)
++    12af:	78 27                	js     12d8 <stat+0x48>
++    return -1;
++  r = fstat(fd, st);
++    12b1:	8b 45 0c             	mov    0xc(%ebp),%eax
++    12b4:	89 1c 24             	mov    %ebx,(%esp)
++    12b7:	89 44 24 04          	mov    %eax,0x4(%esp)
++    12bb:	e8 da 00 00 00       	call   139a <fstat>
++  close(fd);
++    12c0:	89 1c 24             	mov    %ebx,(%esp)
++  r = fstat(fd, st);
++    12c3:	89 c6                	mov    %eax,%esi
++  close(fd);
++    12c5:	e8 a0 00 00 00       	call   136a <close>
++  return r;
++    12ca:	89 f0                	mov    %esi,%eax
++}
++    12cc:	83 c4 10             	add    $0x10,%esp
++    12cf:	5b                   	pop    %ebx
++    12d0:	5e                   	pop    %esi
++    12d1:	5d                   	pop    %ebp
++    12d2:	c3                   	ret    
++    12d3:	90                   	nop
++    12d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    return -1;
++    12d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++    12dd:	eb ed                	jmp    12cc <stat+0x3c>
++    12df:	90                   	nop
++
++000012e0 <atoi>:
++
++int
++atoi(const char *s)
++{
++    12e0:	55                   	push   %ebp
++    12e1:	89 e5                	mov    %esp,%ebp
++    12e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
++    12e6:	53                   	push   %ebx
++  int n;
++
++  n = 0;
++  while('0' <= *s && *s <= '9')
++    12e7:	0f be 11             	movsbl (%ecx),%edx
++    12ea:	8d 42 d0             	lea    -0x30(%edx),%eax
++    12ed:	3c 09                	cmp    $0x9,%al
++  n = 0;
++    12ef:	b8 00 00 00 00       	mov    $0x0,%eax
++  while('0' <= *s && *s <= '9')
++    12f4:	77 17                	ja     130d <atoi+0x2d>
++    12f6:	66 90                	xchg   %ax,%ax
++    n = n*10 + *s++ - '0';
++    12f8:	83 c1 01             	add    $0x1,%ecx
++    12fb:	8d 04 80             	lea    (%eax,%eax,4),%eax
++    12fe:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
++  while('0' <= *s && *s <= '9')
++    1302:	0f be 11             	movsbl (%ecx),%edx
++    1305:	8d 5a d0             	lea    -0x30(%edx),%ebx
++    1308:	80 fb 09             	cmp    $0x9,%bl
++    130b:	76 eb                	jbe    12f8 <atoi+0x18>
++  return n;
++}
++    130d:	5b                   	pop    %ebx
++    130e:	5d                   	pop    %ebp
++    130f:	c3                   	ret    
++
++00001310 <memmove>:
++
++void*
++memmove(void *vdst, void *vsrc, int n)
++{
++    1310:	55                   	push   %ebp
++  char *dst, *src;
++
++  dst = vdst;
++  src = vsrc;
++  while(n-- > 0)
++    1311:	31 d2                	xor    %edx,%edx
++{
++    1313:	89 e5                	mov    %esp,%ebp
++    1315:	56                   	push   %esi
++    1316:	8b 45 08             	mov    0x8(%ebp),%eax
++    1319:	53                   	push   %ebx
++    131a:	8b 5d 10             	mov    0x10(%ebp),%ebx
++    131d:	8b 75 0c             	mov    0xc(%ebp),%esi
++  while(n-- > 0)
++    1320:	85 db                	test   %ebx,%ebx
++    1322:	7e 12                	jle    1336 <memmove+0x26>
++    1324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    *dst++ = *src++;
++    1328:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
++    132c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
++    132f:	83 c2 01             	add    $0x1,%edx
++  while(n-- > 0)
++    1332:	39 da                	cmp    %ebx,%edx
++    1334:	75 f2                	jne    1328 <memmove+0x18>
++  return vdst;
++}
++    1336:	5b                   	pop    %ebx
++    1337:	5e                   	pop    %esi
++    1338:	5d                   	pop    %ebp
++    1339:	c3                   	ret    
++
++0000133a <fork>:
++  name: \
++    movl $SYS_ ## name, %eax; \
++    int $T_SYSCALL; \
++    ret
++
++SYSCALL(fork)
++    133a:	b8 01 00 00 00       	mov    $0x1,%eax
++    133f:	cd 40                	int    $0x40
++    1341:	c3                   	ret    
++
++00001342 <exit>:
++SYSCALL(exit)
++    1342:	b8 02 00 00 00       	mov    $0x2,%eax
++    1347:	cd 40                	int    $0x40
++    1349:	c3                   	ret    
++
++0000134a <wait>:
++SYSCALL(wait)
++    134a:	b8 03 00 00 00       	mov    $0x3,%eax
++    134f:	cd 40                	int    $0x40
++    1351:	c3                   	ret    
++
++00001352 <pipe>:
++SYSCALL(pipe)
++    1352:	b8 04 00 00 00       	mov    $0x4,%eax
++    1357:	cd 40                	int    $0x40
++    1359:	c3                   	ret    
++
++0000135a <read>:
++SYSCALL(read)
++    135a:	b8 05 00 00 00       	mov    $0x5,%eax
++    135f:	cd 40                	int    $0x40
++    1361:	c3                   	ret    
++
++00001362 <write>:
++SYSCALL(write)
++    1362:	b8 10 00 00 00       	mov    $0x10,%eax
++    1367:	cd 40                	int    $0x40
++    1369:	c3                   	ret    
++
++0000136a <close>:
++SYSCALL(close)
++    136a:	b8 15 00 00 00       	mov    $0x15,%eax
++    136f:	cd 40                	int    $0x40
++    1371:	c3                   	ret    
++
++00001372 <kill>:
++SYSCALL(kill)
++    1372:	b8 06 00 00 00       	mov    $0x6,%eax
++    1377:	cd 40                	int    $0x40
++    1379:	c3                   	ret    
++
++0000137a <exec>:
++SYSCALL(exec)
++    137a:	b8 07 00 00 00       	mov    $0x7,%eax
++    137f:	cd 40                	int    $0x40
++    1381:	c3                   	ret    
++
++00001382 <open>:
++SYSCALL(open)
++    1382:	b8 0f 00 00 00       	mov    $0xf,%eax
++    1387:	cd 40                	int    $0x40
++    1389:	c3                   	ret    
++
++0000138a <mknod>:
++SYSCALL(mknod)
++    138a:	b8 11 00 00 00       	mov    $0x11,%eax
++    138f:	cd 40                	int    $0x40
++    1391:	c3                   	ret    
++
++00001392 <unlink>:
++SYSCALL(unlink)
++    1392:	b8 12 00 00 00       	mov    $0x12,%eax
++    1397:	cd 40                	int    $0x40
++    1399:	c3                   	ret    
++
++0000139a <fstat>:
++SYSCALL(fstat)
++    139a:	b8 08 00 00 00       	mov    $0x8,%eax
++    139f:	cd 40                	int    $0x40
++    13a1:	c3                   	ret    
++
++000013a2 <link>:
++SYSCALL(link)
++    13a2:	b8 13 00 00 00       	mov    $0x13,%eax
++    13a7:	cd 40                	int    $0x40
++    13a9:	c3                   	ret    
++
++000013aa <mkdir>:
++SYSCALL(mkdir)
++    13aa:	b8 14 00 00 00       	mov    $0x14,%eax
++    13af:	cd 40                	int    $0x40
++    13b1:	c3                   	ret    
++
++000013b2 <chdir>:
++SYSCALL(chdir)
++    13b2:	b8 09 00 00 00       	mov    $0x9,%eax
++    13b7:	cd 40                	int    $0x40
++    13b9:	c3                   	ret    
++
++000013ba <dup>:
++SYSCALL(dup)
++    13ba:	b8 0a 00 00 00       	mov    $0xa,%eax
++    13bf:	cd 40                	int    $0x40
++    13c1:	c3                   	ret    
++
++000013c2 <getpid>:
++SYSCALL(getpid)
++    13c2:	b8 0b 00 00 00       	mov    $0xb,%eax
++    13c7:	cd 40                	int    $0x40
++    13c9:	c3                   	ret    
++
++000013ca <sbrk>:
++SYSCALL(sbrk)
++    13ca:	b8 0c 00 00 00       	mov    $0xc,%eax
++    13cf:	cd 40                	int    $0x40
++    13d1:	c3                   	ret    
++
++000013d2 <sleep>:
++SYSCALL(sleep)
++    13d2:	b8 0d 00 00 00       	mov    $0xd,%eax
++    13d7:	cd 40                	int    $0x40
++    13d9:	c3                   	ret    
++
++000013da <uptime>:
++SYSCALL(uptime)
++    13da:	b8 0e 00 00 00       	mov    $0xe,%eax
++    13df:	cd 40                	int    $0x40
++    13e1:	c3                   	ret    
++
++000013e2 <shm_open>:
++SYSCALL(shm_open)
++    13e2:	b8 16 00 00 00       	mov    $0x16,%eax
++    13e7:	cd 40                	int    $0x40
++    13e9:	c3                   	ret    
++
++000013ea <shm_close>:
++SYSCALL(shm_close)	
++    13ea:	b8 17 00 00 00       	mov    $0x17,%eax
++    13ef:	cd 40                	int    $0x40
++    13f1:	c3                   	ret    
+diff --git a/forktest.c b/forktest.c
+index a4b35ed..73f2fe8 100644
+--- a/forktest.c
++++ b/forktest.c
+@@ -8,7 +8,7 @@
+ #define N  1000
+ 
+ void
+-printf(int fd, const char *s, ...)
++printf(int fd, char *s, ...)
+ {
+   write(fd, s, strlen(s));
+ }
+@@ -25,24 +25,24 @@ forktest(void)
+     if(pid < 0)
+       break;
+     if(pid == 0)
+-      exit(4);
++      exit();
+   }
+ 
+   if(n == N){
+     printf(1, "fork claimed to work N times!\n", N);
+-    exit(3);
++    exit();
+   }
+ 
+   for(; n > 0; n--){
+-    if(wait(NULL) < 0){
++    if(wait() < 0){
+       printf(1, "wait stopped early\n");
+-      exit(2);
++      exit();
+     }
+   }
+ 
+-  if(wait(NULL) != -1){
++  if(wait() != -1){
+     printf(1, "wait got too many\n");
+-    exit(1);
++    exit();
+   }
+ 
+   printf(1, "fork test OK\n");
+@@ -52,5 +52,5 @@ int
+ main(void)
+ {
+   forktest();
+-  exit(0);
++  exit();
+ }
+diff --git a/forktest.d b/forktest.d
+new file mode 100644
+index 0000000..d31a0c2
+--- /dev/null
++++ b/forktest.d
+@@ -0,0 +1 @@
++forktest.o: forktest.c /usr/include/stdc-predef.h types.h stat.h user.h
+diff --git a/forktest.o b/forktest.o
+new file mode 100644
+index 0000000..ad946db
+Binary files /dev/null and b/forktest.o differ
+diff --git a/fs.c b/fs.c
+index f77275f..feb59fe 100644
+--- a/fs.c
++++ b/fs.c
+@@ -84,6 +84,7 @@ bfree(int dev, uint b)
+   struct buf *bp;
+   int bi, m;
+ 
++  readsb(dev, &sb);
+   bp = bread(dev, BBLOCK(b, sb));
+   bi = b % BPB;
+   m = 1 << (bi % 8);
+diff --git a/fs.d b/fs.d
+new file mode 100644
+index 0000000..a1d05cc
+--- /dev/null
++++ b/fs.d
+@@ -0,0 +1,2 @@
++fs.o: fs.c /usr/include/stdc-predef.h types.h defs.h param.h stat.h mmu.h \
++ proc.h spinlock.h sleeplock.h fs.h buf.h file.h
+diff --git a/fs.img b/fs.img
+new file mode 100644
+index 0000000..6ca46f9
+Binary files /dev/null and b/fs.img differ
+diff --git a/fs.o b/fs.o
+new file mode 100644
+index 0000000..e2776f5
+Binary files /dev/null and b/fs.o differ
+diff --git a/grep.asm b/grep.asm
+new file mode 100644
+index 0000000..7d34097
+--- /dev/null
++++ b/grep.asm
+@@ -0,0 +1,1546 @@
++
++_grep:     file format elf32-i386
++
++
++Disassembly of section .text:
++
++00001000 <main>:
++  }
++}
++
++int
++main(int argc, char *argv[])
++{
++    1000:	55                   	push   %ebp
++    1001:	89 e5                	mov    %esp,%ebp
++    1003:	57                   	push   %edi
++    1004:	56                   	push   %esi
++    1005:	53                   	push   %ebx
++    1006:	83 e4 f0             	and    $0xfffffff0,%esp
++    1009:	83 ec 10             	sub    $0x10,%esp
++    100c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
++  int fd, i;
++  char *pattern;
++
++  if(argc <= 1){
++    100f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
++    1013:	0f 8e 8b 00 00 00    	jle    10a4 <main+0xa4>
++    printf(2, "usage: grep pattern [file ...]\n");
++    exit();
++  }
++  pattern = argv[1];
++    1019:	8b 43 04             	mov    0x4(%ebx),%eax
++    101c:	83 c3 08             	add    $0x8,%ebx
++
++  if(argc <= 2){
++    101f:	be 02 00 00 00       	mov    $0x2,%esi
++    1024:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
++  pattern = argv[1];
++    1028:	89 44 24 0c          	mov    %eax,0xc(%esp)
++  if(argc <= 2){
++    102c:	74 61                	je     108f <main+0x8f>
++    102e:	66 90                	xchg   %ax,%ax
++    grep(pattern, 0);
++    exit();
++  }
++
++  for(i = 2; i < argc; i++){
++    if((fd = open(argv[i], 0)) < 0){
++    1030:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
++    1037:	00 
++    1038:	8b 03                	mov    (%ebx),%eax
++    103a:	89 04 24             	mov    %eax,(%esp)
++    103d:	e8 30 05 00 00       	call   1572 <open>
++    1042:	85 c0                	test   %eax,%eax
++    1044:	89 c7                	mov    %eax,%edi
++    1046:	78 28                	js     1070 <main+0x70>
++      printf(1, "grep: cannot open %s\n", argv[i]);
++      exit();
++    }
++    grep(pattern, fd);
++    1048:	89 44 24 04          	mov    %eax,0x4(%esp)
++    104c:	8b 44 24 0c          	mov    0xc(%esp),%eax
++  for(i = 2; i < argc; i++){
++    1050:	83 c6 01             	add    $0x1,%esi
++    1053:	83 c3 04             	add    $0x4,%ebx
++    grep(pattern, fd);
++    1056:	89 04 24             	mov    %eax,(%esp)
++    1059:	e8 a2 01 00 00       	call   1200 <grep>
++    close(fd);
++    105e:	89 3c 24             	mov    %edi,(%esp)
++    1061:	e8 f4 04 00 00       	call   155a <close>
++  for(i = 2; i < argc; i++){
++    1066:	39 75 08             	cmp    %esi,0x8(%ebp)
++    1069:	7f c5                	jg     1030 <main+0x30>
++  }
++  exit();
++    106b:	e8 c2 04 00 00       	call   1532 <exit>
++      printf(1, "grep: cannot open %s\n", argv[i]);
++    1070:	8b 03                	mov    (%ebx),%eax
++    1072:	c7 44 24 04 54 1a 00 	movl   $0x1a54,0x4(%esp)
++    1079:	00 
++    107a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    1081:	89 44 24 08          	mov    %eax,0x8(%esp)
++    1085:	e8 06 06 00 00       	call   1690 <printf>
++      exit();
++    108a:	e8 a3 04 00 00       	call   1532 <exit>
++    grep(pattern, 0);
++    108f:	89 04 24             	mov    %eax,(%esp)
++    1092:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
++    1099:	00 
++    109a:	e8 61 01 00 00       	call   1200 <grep>
++    exit();
++    109f:	e8 8e 04 00 00       	call   1532 <exit>
++    printf(2, "usage: grep pattern [file ...]\n");
++    10a4:	c7 44 24 04 34 1a 00 	movl   $0x1a34,0x4(%esp)
++    10ab:	00 
++    10ac:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
++    10b3:	e8 d8 05 00 00       	call   1690 <printf>
++    exit();
++    10b8:	e8 75 04 00 00       	call   1532 <exit>
++    10bd:	66 90                	xchg   %ax,%ax
++    10bf:	90                   	nop
++
++000010c0 <matchstar>:
++  return 0;
++}
++
++// matchstar: search for c*re at beginning of text
++int matchstar(int c, char *re, char *text)
++{
++    10c0:	55                   	push   %ebp
++    10c1:	89 e5                	mov    %esp,%ebp
++    10c3:	57                   	push   %edi
++    10c4:	56                   	push   %esi
++    10c5:	53                   	push   %ebx
++    10c6:	83 ec 1c             	sub    $0x1c,%esp
++    10c9:	8b 75 08             	mov    0x8(%ebp),%esi
++    10cc:	8b 7d 0c             	mov    0xc(%ebp),%edi
++    10cf:	8b 5d 10             	mov    0x10(%ebp),%ebx
++    10d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++  do{  // a * matches zero or more instances
++    if(matchhere(re, text))
++    10d8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++    10dc:	89 3c 24             	mov    %edi,(%esp)
++    10df:	e8 3c 00 00 00       	call   1120 <matchhere>
++    10e4:	85 c0                	test   %eax,%eax
++    10e6:	75 20                	jne    1108 <matchstar+0x48>
++      return 1;
++  }while(*text!='\0' && (*text++==c || c=='.'));
++    10e8:	0f be 13             	movsbl (%ebx),%edx
++    10eb:	84 d2                	test   %dl,%dl
++    10ed:	74 0c                	je     10fb <matchstar+0x3b>
++    10ef:	83 c3 01             	add    $0x1,%ebx
++    10f2:	39 f2                	cmp    %esi,%edx
++    10f4:	74 e2                	je     10d8 <matchstar+0x18>
++    10f6:	83 fe 2e             	cmp    $0x2e,%esi
++    10f9:	74 dd                	je     10d8 <matchstar+0x18>
++  return 0;
++}
++    10fb:	83 c4 1c             	add    $0x1c,%esp
++    10fe:	5b                   	pop    %ebx
++    10ff:	5e                   	pop    %esi
++    1100:	5f                   	pop    %edi
++    1101:	5d                   	pop    %ebp
++    1102:	c3                   	ret    
++    1103:	90                   	nop
++    1104:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    1108:	83 c4 1c             	add    $0x1c,%esp
++      return 1;
++    110b:	b8 01 00 00 00       	mov    $0x1,%eax
++}
++    1110:	5b                   	pop    %ebx
++    1111:	5e                   	pop    %esi
++    1112:	5f                   	pop    %edi
++    1113:	5d                   	pop    %ebp
++    1114:	c3                   	ret    
++    1115:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    1119:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++00001120 <matchhere>:
++{
++    1120:	55                   	push   %ebp
++    1121:	89 e5                	mov    %esp,%ebp
++    1123:	53                   	push   %ebx
++    1124:	83 ec 14             	sub    $0x14,%esp
++    1127:	8b 55 08             	mov    0x8(%ebp),%edx
++    112a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
++  if(re[0] == '\0')
++    112d:	0f be 02             	movsbl (%edx),%eax
++    1130:	84 c0                	test   %al,%al
++    1132:	75 20                	jne    1154 <matchhere+0x34>
++    1134:	eb 42                	jmp    1178 <matchhere+0x58>
++    1136:	66 90                	xchg   %ax,%ax
++  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
++    1138:	0f b6 19             	movzbl (%ecx),%ebx
++    113b:	84 db                	test   %bl,%bl
++    113d:	74 31                	je     1170 <matchhere+0x50>
++    113f:	3c 2e                	cmp    $0x2e,%al
++    1141:	74 04                	je     1147 <matchhere+0x27>
++    1143:	38 d8                	cmp    %bl,%al
++    1145:	75 29                	jne    1170 <matchhere+0x50>
++    return matchhere(re+1, text+1);
++    1147:	83 c2 01             	add    $0x1,%edx
++  if(re[0] == '\0')
++    114a:	0f be 02             	movsbl (%edx),%eax
++    return matchhere(re+1, text+1);
++    114d:	83 c1 01             	add    $0x1,%ecx
++  if(re[0] == '\0')
++    1150:	84 c0                	test   %al,%al
++    1152:	74 24                	je     1178 <matchhere+0x58>
++  if(re[1] == '*')
++    1154:	0f b6 5a 01          	movzbl 0x1(%edx),%ebx
++    1158:	80 fb 2a             	cmp    $0x2a,%bl
++    115b:	74 2b                	je     1188 <matchhere+0x68>
++  if(re[0] == '$' && re[1] == '\0')
++    115d:	3c 24                	cmp    $0x24,%al
++    115f:	75 d7                	jne    1138 <matchhere+0x18>
++    1161:	84 db                	test   %bl,%bl
++    1163:	74 3c                	je     11a1 <matchhere+0x81>
++  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
++    1165:	0f b6 19             	movzbl (%ecx),%ebx
++    1168:	84 db                	test   %bl,%bl
++    116a:	75 d7                	jne    1143 <matchhere+0x23>
++    116c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++  return 0;
++    1170:	31 c0                	xor    %eax,%eax
++}
++    1172:	83 c4 14             	add    $0x14,%esp
++    1175:	5b                   	pop    %ebx
++    1176:	5d                   	pop    %ebp
++    1177:	c3                   	ret    
++    1178:	83 c4 14             	add    $0x14,%esp
++    return 1;
++    117b:	b8 01 00 00 00       	mov    $0x1,%eax
++}
++    1180:	5b                   	pop    %ebx
++    1181:	5d                   	pop    %ebp
++    1182:	c3                   	ret    
++    1183:	90                   	nop
++    1184:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    return matchstar(re[0], re+2, text);
++    1188:	83 c2 02             	add    $0x2,%edx
++    118b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
++    118f:	89 54 24 04          	mov    %edx,0x4(%esp)
++    1193:	89 04 24             	mov    %eax,(%esp)
++    1196:	e8 25 ff ff ff       	call   10c0 <matchstar>
++}
++    119b:	83 c4 14             	add    $0x14,%esp
++    119e:	5b                   	pop    %ebx
++    119f:	5d                   	pop    %ebp
++    11a0:	c3                   	ret    
++    return *text == '\0';
++    11a1:	31 c0                	xor    %eax,%eax
++    11a3:	80 39 00             	cmpb   $0x0,(%ecx)
++    11a6:	0f 94 c0             	sete   %al
++    11a9:	eb c7                	jmp    1172 <matchhere+0x52>
++    11ab:	90                   	nop
++    11ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++
++000011b0 <match>:
++{
++    11b0:	55                   	push   %ebp
++    11b1:	89 e5                	mov    %esp,%ebp
++    11b3:	56                   	push   %esi
++    11b4:	53                   	push   %ebx
++    11b5:	83 ec 10             	sub    $0x10,%esp
++    11b8:	8b 75 08             	mov    0x8(%ebp),%esi
++    11bb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
++  if(re[0] == '^')
++    11be:	80 3e 5e             	cmpb   $0x5e,(%esi)
++    11c1:	75 0e                	jne    11d1 <match+0x21>
++    11c3:	eb 28                	jmp    11ed <match+0x3d>
++    11c5:	8d 76 00             	lea    0x0(%esi),%esi
++  }while(*text++ != '\0');
++    11c8:	83 c3 01             	add    $0x1,%ebx
++    11cb:	80 7b ff 00          	cmpb   $0x0,-0x1(%ebx)
++    11cf:	74 15                	je     11e6 <match+0x36>
++    if(matchhere(re, text))
++    11d1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++    11d5:	89 34 24             	mov    %esi,(%esp)
++    11d8:	e8 43 ff ff ff       	call   1120 <matchhere>
++    11dd:	85 c0                	test   %eax,%eax
++    11df:	74 e7                	je     11c8 <match+0x18>
++      return 1;
++    11e1:	b8 01 00 00 00       	mov    $0x1,%eax
++}
++    11e6:	83 c4 10             	add    $0x10,%esp
++    11e9:	5b                   	pop    %ebx
++    11ea:	5e                   	pop    %esi
++    11eb:	5d                   	pop    %ebp
++    11ec:	c3                   	ret    
++    return matchhere(re+1, text);
++    11ed:	83 c6 01             	add    $0x1,%esi
++    11f0:	89 75 08             	mov    %esi,0x8(%ebp)
++}
++    11f3:	83 c4 10             	add    $0x10,%esp
++    11f6:	5b                   	pop    %ebx
++    11f7:	5e                   	pop    %esi
++    11f8:	5d                   	pop    %ebp
++    return matchhere(re+1, text);
++    11f9:	e9 22 ff ff ff       	jmp    1120 <matchhere>
++    11fe:	66 90                	xchg   %ax,%ax
++
++00001200 <grep>:
++{
++    1200:	55                   	push   %ebp
++    1201:	89 e5                	mov    %esp,%ebp
++    1203:	57                   	push   %edi
++    1204:	56                   	push   %esi
++    1205:	53                   	push   %ebx
++    1206:	83 ec 1c             	sub    $0x1c,%esp
++    1209:	8b 75 08             	mov    0x8(%ebp),%esi
++  m = 0;
++    120c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
++    1213:	90                   	nop
++    1214:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
++    1218:	8b 55 e4             	mov    -0x1c(%ebp),%edx
++    121b:	b8 ff 03 00 00       	mov    $0x3ff,%eax
++    1220:	29 d0                	sub    %edx,%eax
++    1222:	89 44 24 08          	mov    %eax,0x8(%esp)
++    1226:	89 d0                	mov    %edx,%eax
++    1228:	05 40 1e 00 00       	add    $0x1e40,%eax
++    122d:	89 44 24 04          	mov    %eax,0x4(%esp)
++    1231:	8b 45 0c             	mov    0xc(%ebp),%eax
++    1234:	89 04 24             	mov    %eax,(%esp)
++    1237:	e8 0e 03 00 00       	call   154a <read>
++    123c:	85 c0                	test   %eax,%eax
++    123e:	0f 8e b8 00 00 00    	jle    12fc <grep+0xfc>
++    m += n;
++    1244:	01 45 e4             	add    %eax,-0x1c(%ebp)
++    p = buf;
++    1247:	bb 40 1e 00 00       	mov    $0x1e40,%ebx
++    buf[m] = '\0';
++    124c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
++    124f:	c6 80 40 1e 00 00 00 	movb   $0x0,0x1e40(%eax)
++    1256:	66 90                	xchg   %ax,%ax
++    while((q = strchr(p, '\n')) != 0){
++    1258:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
++    125f:	00 
++    1260:	89 1c 24             	mov    %ebx,(%esp)
++    1263:	e8 78 01 00 00       	call   13e0 <strchr>
++    1268:	85 c0                	test   %eax,%eax
++    126a:	89 c7                	mov    %eax,%edi
++    126c:	74 42                	je     12b0 <grep+0xb0>
++      *q = 0;
++    126e:	c6 07 00             	movb   $0x0,(%edi)
++      if(match(pattern, p)){
++    1271:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++    1275:	89 34 24             	mov    %esi,(%esp)
++    1278:	e8 33 ff ff ff       	call   11b0 <match>
++    127d:	85 c0                	test   %eax,%eax
++    127f:	75 07                	jne    1288 <grep+0x88>
++    1281:	8d 5f 01             	lea    0x1(%edi),%ebx
++    1284:	eb d2                	jmp    1258 <grep+0x58>
++    1286:	66 90                	xchg   %ax,%ax
++        *q = '\n';
++    1288:	c6 07 0a             	movb   $0xa,(%edi)
++        write(1, p, q+1 - p);
++    128b:	83 c7 01             	add    $0x1,%edi
++    128e:	89 f8                	mov    %edi,%eax
++    1290:	29 d8                	sub    %ebx,%eax
++    1292:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++    1296:	89 fb                	mov    %edi,%ebx
++    1298:	89 44 24 08          	mov    %eax,0x8(%esp)
++    129c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    12a3:	e8 aa 02 00 00       	call   1552 <write>
++    12a8:	eb ae                	jmp    1258 <grep+0x58>
++    12aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    if(p == buf)
++    12b0:	81 fb 40 1e 00 00    	cmp    $0x1e40,%ebx
++    12b6:	74 38                	je     12f0 <grep+0xf0>
++    if(m > 0){
++    12b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
++    12bb:	85 c0                	test   %eax,%eax
++    12bd:	0f 8e 55 ff ff ff    	jle    1218 <grep+0x18>
++      m -= p - buf;
++    12c3:	b8 40 1e 00 00       	mov    $0x1e40,%eax
++    12c8:	29 d8                	sub    %ebx,%eax
++    12ca:	01 45 e4             	add    %eax,-0x1c(%ebp)
++      memmove(buf, p, m);
++    12cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
++    12d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++    12d4:	c7 04 24 40 1e 00 00 	movl   $0x1e40,(%esp)
++    12db:	89 44 24 08          	mov    %eax,0x8(%esp)
++    12df:	e8 1c 02 00 00       	call   1500 <memmove>
++    12e4:	e9 2f ff ff ff       	jmp    1218 <grep+0x18>
++    12e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++      m = 0;
++    12f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
++    12f7:	e9 1c ff ff ff       	jmp    1218 <grep+0x18>
++}
++    12fc:	83 c4 1c             	add    $0x1c,%esp
++    12ff:	5b                   	pop    %ebx
++    1300:	5e                   	pop    %esi
++    1301:	5f                   	pop    %edi
++    1302:	5d                   	pop    %ebp
++    1303:	c3                   	ret    
++    1304:	66 90                	xchg   %ax,%ax
++    1306:	66 90                	xchg   %ax,%ax
++    1308:	66 90                	xchg   %ax,%ax
++    130a:	66 90                	xchg   %ax,%ax
++    130c:	66 90                	xchg   %ax,%ax
++    130e:	66 90                	xchg   %ax,%ax
++
++00001310 <strcpy>:
++#include "user.h"
++#include "x86.h"
++
++char*
++strcpy(char *s, char *t)
++{
++    1310:	55                   	push   %ebp
++    1311:	89 e5                	mov    %esp,%ebp
++    1313:	8b 45 08             	mov    0x8(%ebp),%eax
++    1316:	8b 4d 0c             	mov    0xc(%ebp),%ecx
++    1319:	53                   	push   %ebx
++  char *os;
++
++  os = s;
++  while((*s++ = *t++) != 0)
++    131a:	89 c2                	mov    %eax,%edx
++    131c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    1320:	83 c1 01             	add    $0x1,%ecx
++    1323:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
++    1327:	83 c2 01             	add    $0x1,%edx
++    132a:	84 db                	test   %bl,%bl
++    132c:	88 5a ff             	mov    %bl,-0x1(%edx)
++    132f:	75 ef                	jne    1320 <strcpy+0x10>
++    ;
++  return os;
++}
++    1331:	5b                   	pop    %ebx
++    1332:	5d                   	pop    %ebp
++    1333:	c3                   	ret    
++    1334:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    133a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
++
++00001340 <strcmp>:
++
++int
++strcmp(const char *p, const char *q)
++{
++    1340:	55                   	push   %ebp
++    1341:	89 e5                	mov    %esp,%ebp
++    1343:	8b 55 08             	mov    0x8(%ebp),%edx
++    1346:	53                   	push   %ebx
++    1347:	8b 4d 0c             	mov    0xc(%ebp),%ecx
++  while(*p && *p == *q)
++    134a:	0f b6 02             	movzbl (%edx),%eax
++    134d:	84 c0                	test   %al,%al
++    134f:	74 2d                	je     137e <strcmp+0x3e>
++    1351:	0f b6 19             	movzbl (%ecx),%ebx
++    1354:	38 d8                	cmp    %bl,%al
++    1356:	74 0e                	je     1366 <strcmp+0x26>
++    1358:	eb 2b                	jmp    1385 <strcmp+0x45>
++    135a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    1360:	38 c8                	cmp    %cl,%al
++    1362:	75 15                	jne    1379 <strcmp+0x39>
++    p++, q++;
++    1364:	89 d9                	mov    %ebx,%ecx
++    1366:	83 c2 01             	add    $0x1,%edx
++  while(*p && *p == *q)
++    1369:	0f b6 02             	movzbl (%edx),%eax
++    p++, q++;
++    136c:	8d 59 01             	lea    0x1(%ecx),%ebx
++  while(*p && *p == *q)
++    136f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
++    1373:	84 c0                	test   %al,%al
++    1375:	75 e9                	jne    1360 <strcmp+0x20>
++    1377:	31 c0                	xor    %eax,%eax
++  return (uchar)*p - (uchar)*q;
++    1379:	29 c8                	sub    %ecx,%eax
++}
++    137b:	5b                   	pop    %ebx
++    137c:	5d                   	pop    %ebp
++    137d:	c3                   	ret    
++    137e:	0f b6 09             	movzbl (%ecx),%ecx
++  while(*p && *p == *q)
++    1381:	31 c0                	xor    %eax,%eax
++    1383:	eb f4                	jmp    1379 <strcmp+0x39>
++    1385:	0f b6 cb             	movzbl %bl,%ecx
++    1388:	eb ef                	jmp    1379 <strcmp+0x39>
++    138a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++
++00001390 <strlen>:
++
++uint
++strlen(char *s)
++{
++    1390:	55                   	push   %ebp
++    1391:	89 e5                	mov    %esp,%ebp
++    1393:	8b 4d 08             	mov    0x8(%ebp),%ecx
++  int n;
++
++  for(n = 0; s[n]; n++)
++    1396:	80 39 00             	cmpb   $0x0,(%ecx)
++    1399:	74 12                	je     13ad <strlen+0x1d>
++    139b:	31 d2                	xor    %edx,%edx
++    139d:	8d 76 00             	lea    0x0(%esi),%esi
++    13a0:	83 c2 01             	add    $0x1,%edx
++    13a3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
++    13a7:	89 d0                	mov    %edx,%eax
++    13a9:	75 f5                	jne    13a0 <strlen+0x10>
++    ;
++  return n;
++}
++    13ab:	5d                   	pop    %ebp
++    13ac:	c3                   	ret    
++  for(n = 0; s[n]; n++)
++    13ad:	31 c0                	xor    %eax,%eax
++}
++    13af:	5d                   	pop    %ebp
++    13b0:	c3                   	ret    
++    13b1:	eb 0d                	jmp    13c0 <memset>
++    13b3:	90                   	nop
++    13b4:	90                   	nop
++    13b5:	90                   	nop
++    13b6:	90                   	nop
++    13b7:	90                   	nop
++    13b8:	90                   	nop
++    13b9:	90                   	nop
++    13ba:	90                   	nop
++    13bb:	90                   	nop
++    13bc:	90                   	nop
++    13bd:	90                   	nop
++    13be:	90                   	nop
++    13bf:	90                   	nop
++
++000013c0 <memset>:
++
++void*
++memset(void *dst, int c, uint n)
++{
++    13c0:	55                   	push   %ebp
++    13c1:	89 e5                	mov    %esp,%ebp
++    13c3:	8b 55 08             	mov    0x8(%ebp),%edx
++    13c6:	57                   	push   %edi
++}
++
++static inline void
++stosb(void *addr, int data, int cnt)
++{
++  asm volatile("cld; rep stosb" :
++    13c7:	8b 4d 10             	mov    0x10(%ebp),%ecx
++    13ca:	8b 45 0c             	mov    0xc(%ebp),%eax
++    13cd:	89 d7                	mov    %edx,%edi
++    13cf:	fc                   	cld    
++    13d0:	f3 aa                	rep stos %al,%es:(%edi)
++  stosb(dst, c, n);
++  return dst;
++}
++    13d2:	89 d0                	mov    %edx,%eax
++    13d4:	5f                   	pop    %edi
++    13d5:	5d                   	pop    %ebp
++    13d6:	c3                   	ret    
++    13d7:	89 f6                	mov    %esi,%esi
++    13d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++000013e0 <strchr>:
++
++char*
++strchr(const char *s, char c)
++{
++    13e0:	55                   	push   %ebp
++    13e1:	89 e5                	mov    %esp,%ebp
++    13e3:	8b 45 08             	mov    0x8(%ebp),%eax
++    13e6:	53                   	push   %ebx
++    13e7:	8b 55 0c             	mov    0xc(%ebp),%edx
++  for(; *s; s++)
++    13ea:	0f b6 18             	movzbl (%eax),%ebx
++    13ed:	84 db                	test   %bl,%bl
++    13ef:	74 1d                	je     140e <strchr+0x2e>
++    if(*s == c)
++    13f1:	38 d3                	cmp    %dl,%bl
++    13f3:	89 d1                	mov    %edx,%ecx
++    13f5:	75 0d                	jne    1404 <strchr+0x24>
++    13f7:	eb 17                	jmp    1410 <strchr+0x30>
++    13f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++    1400:	38 ca                	cmp    %cl,%dl
++    1402:	74 0c                	je     1410 <strchr+0x30>
++  for(; *s; s++)
++    1404:	83 c0 01             	add    $0x1,%eax
++    1407:	0f b6 10             	movzbl (%eax),%edx
++    140a:	84 d2                	test   %dl,%dl
++    140c:	75 f2                	jne    1400 <strchr+0x20>
++      return (char*)s;
++  return 0;
++    140e:	31 c0                	xor    %eax,%eax
++}
++    1410:	5b                   	pop    %ebx
++    1411:	5d                   	pop    %ebp
++    1412:	c3                   	ret    
++    1413:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    1419:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++00001420 <gets>:
++
++char*
++gets(char *buf, int max)
++{
++    1420:	55                   	push   %ebp
++    1421:	89 e5                	mov    %esp,%ebp
++    1423:	57                   	push   %edi
++    1424:	56                   	push   %esi
++  int i, cc;
++  char c;
++
++  for(i=0; i+1 < max; ){
++    1425:	31 f6                	xor    %esi,%esi
++{
++    1427:	53                   	push   %ebx
++    1428:	83 ec 2c             	sub    $0x2c,%esp
++    cc = read(0, &c, 1);
++    142b:	8d 7d e7             	lea    -0x19(%ebp),%edi
++  for(i=0; i+1 < max; ){
++    142e:	eb 31                	jmp    1461 <gets+0x41>
++    cc = read(0, &c, 1);
++    1430:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1437:	00 
++    1438:	89 7c 24 04          	mov    %edi,0x4(%esp)
++    143c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
++    1443:	e8 02 01 00 00       	call   154a <read>
++    if(cc < 1)
++    1448:	85 c0                	test   %eax,%eax
++    144a:	7e 1d                	jle    1469 <gets+0x49>
++      break;
++    buf[i++] = c;
++    144c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
++  for(i=0; i+1 < max; ){
++    1450:	89 de                	mov    %ebx,%esi
++    buf[i++] = c;
++    1452:	8b 55 08             	mov    0x8(%ebp),%edx
++    if(c == '\n' || c == '\r')
++    1455:	3c 0d                	cmp    $0xd,%al
++    buf[i++] = c;
++    1457:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
++    if(c == '\n' || c == '\r')
++    145b:	74 0c                	je     1469 <gets+0x49>
++    145d:	3c 0a                	cmp    $0xa,%al
++    145f:	74 08                	je     1469 <gets+0x49>
++  for(i=0; i+1 < max; ){
++    1461:	8d 5e 01             	lea    0x1(%esi),%ebx
++    1464:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
++    1467:	7c c7                	jl     1430 <gets+0x10>
++      break;
++  }
++  buf[i] = '\0';
++    1469:	8b 45 08             	mov    0x8(%ebp),%eax
++    146c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
++  return buf;
++}
++    1470:	83 c4 2c             	add    $0x2c,%esp
++    1473:	5b                   	pop    %ebx
++    1474:	5e                   	pop    %esi
++    1475:	5f                   	pop    %edi
++    1476:	5d                   	pop    %ebp
++    1477:	c3                   	ret    
++    1478:	90                   	nop
++    1479:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++
++00001480 <stat>:
++
++int
++stat(char *n, struct stat *st)
++{
++    1480:	55                   	push   %ebp
++    1481:	89 e5                	mov    %esp,%ebp
++    1483:	56                   	push   %esi
++    1484:	53                   	push   %ebx
++    1485:	83 ec 10             	sub    $0x10,%esp
++  int fd;
++  int r;
++
++  fd = open(n, O_RDONLY);
++    1488:	8b 45 08             	mov    0x8(%ebp),%eax
++    148b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
++    1492:	00 
++    1493:	89 04 24             	mov    %eax,(%esp)
++    1496:	e8 d7 00 00 00       	call   1572 <open>
++  if(fd < 0)
++    149b:	85 c0                	test   %eax,%eax
++  fd = open(n, O_RDONLY);
++    149d:	89 c3                	mov    %eax,%ebx
++  if(fd < 0)
++    149f:	78 27                	js     14c8 <stat+0x48>
++    return -1;
++  r = fstat(fd, st);
++    14a1:	8b 45 0c             	mov    0xc(%ebp),%eax
++    14a4:	89 1c 24             	mov    %ebx,(%esp)
++    14a7:	89 44 24 04          	mov    %eax,0x4(%esp)
++    14ab:	e8 da 00 00 00       	call   158a <fstat>
++  close(fd);
++    14b0:	89 1c 24             	mov    %ebx,(%esp)
++  r = fstat(fd, st);
++    14b3:	89 c6                	mov    %eax,%esi
++  close(fd);
++    14b5:	e8 a0 00 00 00       	call   155a <close>
++  return r;
++    14ba:	89 f0                	mov    %esi,%eax
++}
++    14bc:	83 c4 10             	add    $0x10,%esp
++    14bf:	5b                   	pop    %ebx
++    14c0:	5e                   	pop    %esi
++    14c1:	5d                   	pop    %ebp
++    14c2:	c3                   	ret    
++    14c3:	90                   	nop
++    14c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    return -1;
++    14c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++    14cd:	eb ed                	jmp    14bc <stat+0x3c>
++    14cf:	90                   	nop
++
++000014d0 <atoi>:
++
++int
++atoi(const char *s)
++{
++    14d0:	55                   	push   %ebp
++    14d1:	89 e5                	mov    %esp,%ebp
++    14d3:	8b 4d 08             	mov    0x8(%ebp),%ecx
++    14d6:	53                   	push   %ebx
++  int n;
++
++  n = 0;
++  while('0' <= *s && *s <= '9')
++    14d7:	0f be 11             	movsbl (%ecx),%edx
++    14da:	8d 42 d0             	lea    -0x30(%edx),%eax
++    14dd:	3c 09                	cmp    $0x9,%al
++  n = 0;
++    14df:	b8 00 00 00 00       	mov    $0x0,%eax
++  while('0' <= *s && *s <= '9')
++    14e4:	77 17                	ja     14fd <atoi+0x2d>
++    14e6:	66 90                	xchg   %ax,%ax
++    n = n*10 + *s++ - '0';
++    14e8:	83 c1 01             	add    $0x1,%ecx
++    14eb:	8d 04 80             	lea    (%eax,%eax,4),%eax
++    14ee:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
++  while('0' <= *s && *s <= '9')
++    14f2:	0f be 11             	movsbl (%ecx),%edx
++    14f5:	8d 5a d0             	lea    -0x30(%edx),%ebx
++    14f8:	80 fb 09             	cmp    $0x9,%bl
++    14fb:	76 eb                	jbe    14e8 <atoi+0x18>
++  return n;
++}
++    14fd:	5b                   	pop    %ebx
++    14fe:	5d                   	pop    %ebp
++    14ff:	c3                   	ret    
++
++00001500 <memmove>:
++
++void*
++memmove(void *vdst, void *vsrc, int n)
++{
++    1500:	55                   	push   %ebp
++  char *dst, *src;
++
++  dst = vdst;
++  src = vsrc;
++  while(n-- > 0)
++    1501:	31 d2                	xor    %edx,%edx
++{
++    1503:	89 e5                	mov    %esp,%ebp
++    1505:	56                   	push   %esi
++    1506:	8b 45 08             	mov    0x8(%ebp),%eax
++    1509:	53                   	push   %ebx
++    150a:	8b 5d 10             	mov    0x10(%ebp),%ebx
++    150d:	8b 75 0c             	mov    0xc(%ebp),%esi
++  while(n-- > 0)
++    1510:	85 db                	test   %ebx,%ebx
++    1512:	7e 12                	jle    1526 <memmove+0x26>
++    1514:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    *dst++ = *src++;
++    1518:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
++    151c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
++    151f:	83 c2 01             	add    $0x1,%edx
++  while(n-- > 0)
++    1522:	39 da                	cmp    %ebx,%edx
++    1524:	75 f2                	jne    1518 <memmove+0x18>
++  return vdst;
++}
++    1526:	5b                   	pop    %ebx
++    1527:	5e                   	pop    %esi
++    1528:	5d                   	pop    %ebp
++    1529:	c3                   	ret    
++
++0000152a <fork>:
++  name: \
++    movl $SYS_ ## name, %eax; \
++    int $T_SYSCALL; \
++    ret
++
++SYSCALL(fork)
++    152a:	b8 01 00 00 00       	mov    $0x1,%eax
++    152f:	cd 40                	int    $0x40
++    1531:	c3                   	ret    
++
++00001532 <exit>:
++SYSCALL(exit)
++    1532:	b8 02 00 00 00       	mov    $0x2,%eax
++    1537:	cd 40                	int    $0x40
++    1539:	c3                   	ret    
++
++0000153a <wait>:
++SYSCALL(wait)
++    153a:	b8 03 00 00 00       	mov    $0x3,%eax
++    153f:	cd 40                	int    $0x40
++    1541:	c3                   	ret    
++
++00001542 <pipe>:
++SYSCALL(pipe)
++    1542:	b8 04 00 00 00       	mov    $0x4,%eax
++    1547:	cd 40                	int    $0x40
++    1549:	c3                   	ret    
++
++0000154a <read>:
++SYSCALL(read)
++    154a:	b8 05 00 00 00       	mov    $0x5,%eax
++    154f:	cd 40                	int    $0x40
++    1551:	c3                   	ret    
++
++00001552 <write>:
++SYSCALL(write)
++    1552:	b8 10 00 00 00       	mov    $0x10,%eax
++    1557:	cd 40                	int    $0x40
++    1559:	c3                   	ret    
++
++0000155a <close>:
++SYSCALL(close)
++    155a:	b8 15 00 00 00       	mov    $0x15,%eax
++    155f:	cd 40                	int    $0x40
++    1561:	c3                   	ret    
++
++00001562 <kill>:
++SYSCALL(kill)
++    1562:	b8 06 00 00 00       	mov    $0x6,%eax
++    1567:	cd 40                	int    $0x40
++    1569:	c3                   	ret    
++
++0000156a <exec>:
++SYSCALL(exec)
++    156a:	b8 07 00 00 00       	mov    $0x7,%eax
++    156f:	cd 40                	int    $0x40
++    1571:	c3                   	ret    
++
++00001572 <open>:
++SYSCALL(open)
++    1572:	b8 0f 00 00 00       	mov    $0xf,%eax
++    1577:	cd 40                	int    $0x40
++    1579:	c3                   	ret    
++
++0000157a <mknod>:
++SYSCALL(mknod)
++    157a:	b8 11 00 00 00       	mov    $0x11,%eax
++    157f:	cd 40                	int    $0x40
++    1581:	c3                   	ret    
++
++00001582 <unlink>:
++SYSCALL(unlink)
++    1582:	b8 12 00 00 00       	mov    $0x12,%eax
++    1587:	cd 40                	int    $0x40
++    1589:	c3                   	ret    
++
++0000158a <fstat>:
++SYSCALL(fstat)
++    158a:	b8 08 00 00 00       	mov    $0x8,%eax
++    158f:	cd 40                	int    $0x40
++    1591:	c3                   	ret    
++
++00001592 <link>:
++SYSCALL(link)
++    1592:	b8 13 00 00 00       	mov    $0x13,%eax
++    1597:	cd 40                	int    $0x40
++    1599:	c3                   	ret    
++
++0000159a <mkdir>:
++SYSCALL(mkdir)
++    159a:	b8 14 00 00 00       	mov    $0x14,%eax
++    159f:	cd 40                	int    $0x40
++    15a1:	c3                   	ret    
++
++000015a2 <chdir>:
++SYSCALL(chdir)
++    15a2:	b8 09 00 00 00       	mov    $0x9,%eax
++    15a7:	cd 40                	int    $0x40
++    15a9:	c3                   	ret    
++
++000015aa <dup>:
++SYSCALL(dup)
++    15aa:	b8 0a 00 00 00       	mov    $0xa,%eax
++    15af:	cd 40                	int    $0x40
++    15b1:	c3                   	ret    
++
++000015b2 <getpid>:
++SYSCALL(getpid)
++    15b2:	b8 0b 00 00 00       	mov    $0xb,%eax
++    15b7:	cd 40                	int    $0x40
++    15b9:	c3                   	ret    
++
++000015ba <sbrk>:
++SYSCALL(sbrk)
++    15ba:	b8 0c 00 00 00       	mov    $0xc,%eax
++    15bf:	cd 40                	int    $0x40
++    15c1:	c3                   	ret    
++
++000015c2 <sleep>:
++SYSCALL(sleep)
++    15c2:	b8 0d 00 00 00       	mov    $0xd,%eax
++    15c7:	cd 40                	int    $0x40
++    15c9:	c3                   	ret    
++
++000015ca <uptime>:
++SYSCALL(uptime)
++    15ca:	b8 0e 00 00 00       	mov    $0xe,%eax
++    15cf:	cd 40                	int    $0x40
++    15d1:	c3                   	ret    
++
++000015d2 <shm_open>:
++SYSCALL(shm_open)
++    15d2:	b8 16 00 00 00       	mov    $0x16,%eax
++    15d7:	cd 40                	int    $0x40
++    15d9:	c3                   	ret    
++
++000015da <shm_close>:
++SYSCALL(shm_close)	
++    15da:	b8 17 00 00 00       	mov    $0x17,%eax
++    15df:	cd 40                	int    $0x40
++    15e1:	c3                   	ret    
++    15e2:	66 90                	xchg   %ax,%ax
++    15e4:	66 90                	xchg   %ax,%ax
++    15e6:	66 90                	xchg   %ax,%ax
++    15e8:	66 90                	xchg   %ax,%ax
++    15ea:	66 90                	xchg   %ax,%ax
++    15ec:	66 90                	xchg   %ax,%ax
++    15ee:	66 90                	xchg   %ax,%ax
++
++000015f0 <printint>:
++  write(fd, &c, 1);
++}
++
++static void
++printint(int fd, int xx, int base, int sgn)
++{
++    15f0:	55                   	push   %ebp
++    15f1:	89 e5                	mov    %esp,%ebp
++    15f3:	57                   	push   %edi
++    15f4:	56                   	push   %esi
++    15f5:	89 c6                	mov    %eax,%esi
++    15f7:	53                   	push   %ebx
++    15f8:	83 ec 4c             	sub    $0x4c,%esp
++  char buf[16];
++  int i, neg;
++  uint x;
++
++  neg = 0;
++  if(sgn && xx < 0){
++    15fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
++    15fe:	85 db                	test   %ebx,%ebx
++    1600:	74 09                	je     160b <printint+0x1b>
++    1602:	89 d0                	mov    %edx,%eax
++    1604:	c1 e8 1f             	shr    $0x1f,%eax
++    1607:	84 c0                	test   %al,%al
++    1609:	75 75                	jne    1680 <printint+0x90>
++    neg = 1;
++    x = -xx;
++  } else {
++    x = xx;
++    160b:	89 d0                	mov    %edx,%eax
++  neg = 0;
++    160d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
++    1614:	89 75 c0             	mov    %esi,-0x40(%ebp)
++  }
++
++  i = 0;
++    1617:	31 ff                	xor    %edi,%edi
++    1619:	89 ce                	mov    %ecx,%esi
++    161b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
++    161e:	eb 02                	jmp    1622 <printint+0x32>
++  do{
++    buf[i++] = digits[x % base];
++    1620:	89 cf                	mov    %ecx,%edi
++    1622:	31 d2                	xor    %edx,%edx
++    1624:	f7 f6                	div    %esi
++    1626:	8d 4f 01             	lea    0x1(%edi),%ecx
++    1629:	0f b6 92 71 1a 00 00 	movzbl 0x1a71(%edx),%edx
++  }while((x /= base) != 0);
++    1630:	85 c0                	test   %eax,%eax
++    buf[i++] = digits[x % base];
++    1632:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
++  }while((x /= base) != 0);
++    1635:	75 e9                	jne    1620 <printint+0x30>
++  if(neg)
++    1637:	8b 55 c4             	mov    -0x3c(%ebp),%edx
++    buf[i++] = digits[x % base];
++    163a:	89 c8                	mov    %ecx,%eax
++    163c:	8b 75 c0             	mov    -0x40(%ebp),%esi
++  if(neg)
++    163f:	85 d2                	test   %edx,%edx
++    1641:	74 08                	je     164b <printint+0x5b>
++    buf[i++] = '-';
++    1643:	8d 4f 02             	lea    0x2(%edi),%ecx
++    1646:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
++
++  while(--i >= 0)
++    164b:	8d 79 ff             	lea    -0x1(%ecx),%edi
++    164e:	66 90                	xchg   %ax,%ax
++    1650:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
++    1655:	83 ef 01             	sub    $0x1,%edi
++  write(fd, &c, 1);
++    1658:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    165f:	00 
++    1660:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++    1664:	89 34 24             	mov    %esi,(%esp)
++    1667:	88 45 d7             	mov    %al,-0x29(%ebp)
++    166a:	e8 e3 fe ff ff       	call   1552 <write>
++  while(--i >= 0)
++    166f:	83 ff ff             	cmp    $0xffffffff,%edi
++    1672:	75 dc                	jne    1650 <printint+0x60>
++    putc(fd, buf[i]);
++}
++    1674:	83 c4 4c             	add    $0x4c,%esp
++    1677:	5b                   	pop    %ebx
++    1678:	5e                   	pop    %esi
++    1679:	5f                   	pop    %edi
++    167a:	5d                   	pop    %ebp
++    167b:	c3                   	ret    
++    167c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    x = -xx;
++    1680:	89 d0                	mov    %edx,%eax
++    1682:	f7 d8                	neg    %eax
++    neg = 1;
++    1684:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
++    168b:	eb 87                	jmp    1614 <printint+0x24>
++    168d:	8d 76 00             	lea    0x0(%esi),%esi
++
++00001690 <printf>:
++
++// Print to the given fd. Only understands %d, %x, %p, %s.
++void
++printf(int fd, char *fmt, ...)
++{
++    1690:	55                   	push   %ebp
++    1691:	89 e5                	mov    %esp,%ebp
++    1693:	57                   	push   %edi
++  char *s;
++  int c, i, state;
++  uint *ap;
++
++  state = 0;
++    1694:	31 ff                	xor    %edi,%edi
++{
++    1696:	56                   	push   %esi
++    1697:	53                   	push   %ebx
++    1698:	83 ec 3c             	sub    $0x3c,%esp
++  ap = (uint*)(void*)&fmt + 1;
++  for(i = 0; fmt[i]; i++){
++    169b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
++  ap = (uint*)(void*)&fmt + 1;
++    169e:	8d 45 10             	lea    0x10(%ebp),%eax
++{
++    16a1:	8b 75 08             	mov    0x8(%ebp),%esi
++  ap = (uint*)(void*)&fmt + 1;
++    16a4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
++  for(i = 0; fmt[i]; i++){
++    16a7:	0f b6 13             	movzbl (%ebx),%edx
++    16aa:	83 c3 01             	add    $0x1,%ebx
++    16ad:	84 d2                	test   %dl,%dl
++    16af:	75 39                	jne    16ea <printf+0x5a>
++    16b1:	e9 c2 00 00 00       	jmp    1778 <printf+0xe8>
++    16b6:	66 90                	xchg   %ax,%ax
++    c = fmt[i] & 0xff;
++    if(state == 0){
++      if(c == '%'){
++    16b8:	83 fa 25             	cmp    $0x25,%edx
++    16bb:	0f 84 bf 00 00 00    	je     1780 <printf+0xf0>
++  write(fd, &c, 1);
++    16c1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
++    16c4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    16cb:	00 
++    16cc:	89 44 24 04          	mov    %eax,0x4(%esp)
++    16d0:	89 34 24             	mov    %esi,(%esp)
++        state = '%';
++      } else {
++        putc(fd, c);
++    16d3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
++  write(fd, &c, 1);
++    16d6:	e8 77 fe ff ff       	call   1552 <write>
++    16db:	83 c3 01             	add    $0x1,%ebx
++  for(i = 0; fmt[i]; i++){
++    16de:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
++    16e2:	84 d2                	test   %dl,%dl
++    16e4:	0f 84 8e 00 00 00    	je     1778 <printf+0xe8>
++    if(state == 0){
++    16ea:	85 ff                	test   %edi,%edi
++    c = fmt[i] & 0xff;
++    16ec:	0f be c2             	movsbl %dl,%eax
++    if(state == 0){
++    16ef:	74 c7                	je     16b8 <printf+0x28>
++      }
++    } else if(state == '%'){
++    16f1:	83 ff 25             	cmp    $0x25,%edi
++    16f4:	75 e5                	jne    16db <printf+0x4b>
++      if(c == 'd'){
++    16f6:	83 fa 64             	cmp    $0x64,%edx
++    16f9:	0f 84 31 01 00 00    	je     1830 <printf+0x1a0>
++        printint(fd, *ap, 10, 1);
++        ap++;
++      } else if(c == 'x' || c == 'p'){
++    16ff:	25 f7 00 00 00       	and    $0xf7,%eax
++    1704:	83 f8 70             	cmp    $0x70,%eax
++    1707:	0f 84 83 00 00 00    	je     1790 <printf+0x100>
++        printint(fd, *ap, 16, 0);
++        ap++;
++      } else if(c == 's'){
++    170d:	83 fa 73             	cmp    $0x73,%edx
++    1710:	0f 84 a2 00 00 00    	je     17b8 <printf+0x128>
++          s = "(null)";
++        while(*s != 0){
++          putc(fd, *s);
++          s++;
++        }
++      } else if(c == 'c'){
++    1716:	83 fa 63             	cmp    $0x63,%edx
++    1719:	0f 84 35 01 00 00    	je     1854 <printf+0x1c4>
++        putc(fd, *ap);
++        ap++;
++      } else if(c == '%'){
++    171f:	83 fa 25             	cmp    $0x25,%edx
++    1722:	0f 84 e0 00 00 00    	je     1808 <printf+0x178>
++  write(fd, &c, 1);
++    1728:	8d 45 e6             	lea    -0x1a(%ebp),%eax
++    172b:	83 c3 01             	add    $0x1,%ebx
++    172e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1735:	00 
++      } else {
++        // Unknown % sequence.  Print it to draw attention.
++        putc(fd, '%');
++        putc(fd, c);
++      }
++      state = 0;
++    1736:	31 ff                	xor    %edi,%edi
++  write(fd, &c, 1);
++    1738:	89 44 24 04          	mov    %eax,0x4(%esp)
++    173c:	89 34 24             	mov    %esi,(%esp)
++    173f:	89 55 d0             	mov    %edx,-0x30(%ebp)
++    1742:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
++    1746:	e8 07 fe ff ff       	call   1552 <write>
++        putc(fd, c);
++    174b:	8b 55 d0             	mov    -0x30(%ebp),%edx
++  write(fd, &c, 1);
++    174e:	8d 45 e7             	lea    -0x19(%ebp),%eax
++    1751:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1758:	00 
++    1759:	89 44 24 04          	mov    %eax,0x4(%esp)
++    175d:	89 34 24             	mov    %esi,(%esp)
++        putc(fd, c);
++    1760:	88 55 e7             	mov    %dl,-0x19(%ebp)
++  write(fd, &c, 1);
++    1763:	e8 ea fd ff ff       	call   1552 <write>
++  for(i = 0; fmt[i]; i++){
++    1768:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
++    176c:	84 d2                	test   %dl,%dl
++    176e:	0f 85 76 ff ff ff    	jne    16ea <printf+0x5a>
++    1774:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    }
++  }
++}
++    1778:	83 c4 3c             	add    $0x3c,%esp
++    177b:	5b                   	pop    %ebx
++    177c:	5e                   	pop    %esi
++    177d:	5f                   	pop    %edi
++    177e:	5d                   	pop    %ebp
++    177f:	c3                   	ret    
++        state = '%';
++    1780:	bf 25 00 00 00       	mov    $0x25,%edi
++    1785:	e9 51 ff ff ff       	jmp    16db <printf+0x4b>
++    178a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++        printint(fd, *ap, 16, 0);
++    1790:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++    1793:	b9 10 00 00 00       	mov    $0x10,%ecx
++      state = 0;
++    1798:	31 ff                	xor    %edi,%edi
++        printint(fd, *ap, 16, 0);
++    179a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
++    17a1:	8b 10                	mov    (%eax),%edx
++    17a3:	89 f0                	mov    %esi,%eax
++    17a5:	e8 46 fe ff ff       	call   15f0 <printint>
++        ap++;
++    17aa:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++    17ae:	e9 28 ff ff ff       	jmp    16db <printf+0x4b>
++    17b3:	90                   	nop
++    17b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++        s = (char*)*ap;
++    17b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++        ap++;
++    17bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++        s = (char*)*ap;
++    17bf:	8b 38                	mov    (%eax),%edi
++          s = "(null)";
++    17c1:	b8 6a 1a 00 00       	mov    $0x1a6a,%eax
++    17c6:	85 ff                	test   %edi,%edi
++    17c8:	0f 44 f8             	cmove  %eax,%edi
++        while(*s != 0){
++    17cb:	0f b6 07             	movzbl (%edi),%eax
++    17ce:	84 c0                	test   %al,%al
++    17d0:	74 2a                	je     17fc <printf+0x16c>
++    17d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    17d8:	88 45 e3             	mov    %al,-0x1d(%ebp)
++  write(fd, &c, 1);
++    17db:	8d 45 e3             	lea    -0x1d(%ebp),%eax
++          s++;
++    17de:	83 c7 01             	add    $0x1,%edi
++  write(fd, &c, 1);
++    17e1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    17e8:	00 
++    17e9:	89 44 24 04          	mov    %eax,0x4(%esp)
++    17ed:	89 34 24             	mov    %esi,(%esp)
++    17f0:	e8 5d fd ff ff       	call   1552 <write>
++        while(*s != 0){
++    17f5:	0f b6 07             	movzbl (%edi),%eax
++    17f8:	84 c0                	test   %al,%al
++    17fa:	75 dc                	jne    17d8 <printf+0x148>
++      state = 0;
++    17fc:	31 ff                	xor    %edi,%edi
++    17fe:	e9 d8 fe ff ff       	jmp    16db <printf+0x4b>
++    1803:	90                   	nop
++    1804:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++  write(fd, &c, 1);
++    1808:	8d 45 e5             	lea    -0x1b(%ebp),%eax
++      state = 0;
++    180b:	31 ff                	xor    %edi,%edi
++  write(fd, &c, 1);
++    180d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1814:	00 
++    1815:	89 44 24 04          	mov    %eax,0x4(%esp)
++    1819:	89 34 24             	mov    %esi,(%esp)
++    181c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
++    1820:	e8 2d fd ff ff       	call   1552 <write>
++    1825:	e9 b1 fe ff ff       	jmp    16db <printf+0x4b>
++    182a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++        printint(fd, *ap, 10, 1);
++    1830:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++    1833:	b9 0a 00 00 00       	mov    $0xa,%ecx
++      state = 0;
++    1838:	66 31 ff             	xor    %di,%di
++        printint(fd, *ap, 10, 1);
++    183b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    1842:	8b 10                	mov    (%eax),%edx
++    1844:	89 f0                	mov    %esi,%eax
++    1846:	e8 a5 fd ff ff       	call   15f0 <printint>
++        ap++;
++    184b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++    184f:	e9 87 fe ff ff       	jmp    16db <printf+0x4b>
++        putc(fd, *ap);
++    1854:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++      state = 0;
++    1857:	31 ff                	xor    %edi,%edi
++        putc(fd, *ap);
++    1859:	8b 00                	mov    (%eax),%eax
++  write(fd, &c, 1);
++    185b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1862:	00 
++    1863:	89 34 24             	mov    %esi,(%esp)
++        putc(fd, *ap);
++    1866:	88 45 e4             	mov    %al,-0x1c(%ebp)
++  write(fd, &c, 1);
++    1869:	8d 45 e4             	lea    -0x1c(%ebp),%eax
++    186c:	89 44 24 04          	mov    %eax,0x4(%esp)
++    1870:	e8 dd fc ff ff       	call   1552 <write>
++        ap++;
++    1875:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++    1879:	e9 5d fe ff ff       	jmp    16db <printf+0x4b>
++    187e:	66 90                	xchg   %ax,%ax
++
++00001880 <free>:
++static Header base;
++static Header *freep;
++
++void
++free(void *ap)
++{
++    1880:	55                   	push   %ebp
++  Header *bp, *p;
++
++  bp = (Header*)ap - 1;
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    1881:	a1 20 1e 00 00       	mov    0x1e20,%eax
++{
++    1886:	89 e5                	mov    %esp,%ebp
++    1888:	57                   	push   %edi
++    1889:	56                   	push   %esi
++    188a:	53                   	push   %ebx
++    188b:	8b 5d 08             	mov    0x8(%ebp),%ebx
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    188e:	8b 08                	mov    (%eax),%ecx
++  bp = (Header*)ap - 1;
++    1890:	8d 53 f8             	lea    -0x8(%ebx),%edx
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    1893:	39 d0                	cmp    %edx,%eax
++    1895:	72 11                	jb     18a8 <free+0x28>
++    1897:	90                   	nop
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    1898:	39 c8                	cmp    %ecx,%eax
++    189a:	72 04                	jb     18a0 <free+0x20>
++    189c:	39 ca                	cmp    %ecx,%edx
++    189e:	72 10                	jb     18b0 <free+0x30>
++    18a0:	89 c8                	mov    %ecx,%eax
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    18a2:	39 d0                	cmp    %edx,%eax
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    18a4:	8b 08                	mov    (%eax),%ecx
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    18a6:	73 f0                	jae    1898 <free+0x18>
++    18a8:	39 ca                	cmp    %ecx,%edx
++    18aa:	72 04                	jb     18b0 <free+0x30>
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    18ac:	39 c8                	cmp    %ecx,%eax
++    18ae:	72 f0                	jb     18a0 <free+0x20>
++      break;
++  if(bp + bp->s.size == p->s.ptr){
++    18b0:	8b 73 fc             	mov    -0x4(%ebx),%esi
++    18b3:	8d 3c f2             	lea    (%edx,%esi,8),%edi
++    18b6:	39 cf                	cmp    %ecx,%edi
++    18b8:	74 1e                	je     18d8 <free+0x58>
++    bp->s.size += p->s.ptr->s.size;
++    bp->s.ptr = p->s.ptr->s.ptr;
++  } else
++    bp->s.ptr = p->s.ptr;
++    18ba:	89 4b f8             	mov    %ecx,-0x8(%ebx)
++  if(p + p->s.size == bp){
++    18bd:	8b 48 04             	mov    0x4(%eax),%ecx
++    18c0:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
++    18c3:	39 f2                	cmp    %esi,%edx
++    18c5:	74 28                	je     18ef <free+0x6f>
++    p->s.size += bp->s.size;
++    p->s.ptr = bp->s.ptr;
++  } else
++    p->s.ptr = bp;
++    18c7:	89 10                	mov    %edx,(%eax)
++  freep = p;
++    18c9:	a3 20 1e 00 00       	mov    %eax,0x1e20
++}
++    18ce:	5b                   	pop    %ebx
++    18cf:	5e                   	pop    %esi
++    18d0:	5f                   	pop    %edi
++    18d1:	5d                   	pop    %ebp
++    18d2:	c3                   	ret    
++    18d3:	90                   	nop
++    18d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    bp->s.size += p->s.ptr->s.size;
++    18d8:	03 71 04             	add    0x4(%ecx),%esi
++    18db:	89 73 fc             	mov    %esi,-0x4(%ebx)
++    bp->s.ptr = p->s.ptr->s.ptr;
++    18de:	8b 08                	mov    (%eax),%ecx
++    18e0:	8b 09                	mov    (%ecx),%ecx
++    18e2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
++  if(p + p->s.size == bp){
++    18e5:	8b 48 04             	mov    0x4(%eax),%ecx
++    18e8:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
++    18eb:	39 f2                	cmp    %esi,%edx
++    18ed:	75 d8                	jne    18c7 <free+0x47>
++    p->s.size += bp->s.size;
++    18ef:	03 4b fc             	add    -0x4(%ebx),%ecx
++  freep = p;
++    18f2:	a3 20 1e 00 00       	mov    %eax,0x1e20
++    p->s.size += bp->s.size;
++    18f7:	89 48 04             	mov    %ecx,0x4(%eax)
++    p->s.ptr = bp->s.ptr;
++    18fa:	8b 53 f8             	mov    -0x8(%ebx),%edx
++    18fd:	89 10                	mov    %edx,(%eax)
++}
++    18ff:	5b                   	pop    %ebx
++    1900:	5e                   	pop    %esi
++    1901:	5f                   	pop    %edi
++    1902:	5d                   	pop    %ebp
++    1903:	c3                   	ret    
++    1904:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    190a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
++
++00001910 <malloc>:
++  return freep;
++}
++
++void*
++malloc(uint nbytes)
++{
++    1910:	55                   	push   %ebp
++    1911:	89 e5                	mov    %esp,%ebp
++    1913:	57                   	push   %edi
++    1914:	56                   	push   %esi
++    1915:	53                   	push   %ebx
++    1916:	83 ec 1c             	sub    $0x1c,%esp
++  Header *p, *prevp;
++  uint nunits;
++
++  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
++    1919:	8b 45 08             	mov    0x8(%ebp),%eax
++  if((prevp = freep) == 0){
++    191c:	8b 1d 20 1e 00 00    	mov    0x1e20,%ebx
++  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
++    1922:	8d 48 07             	lea    0x7(%eax),%ecx
++    1925:	c1 e9 03             	shr    $0x3,%ecx
++  if((prevp = freep) == 0){
++    1928:	85 db                	test   %ebx,%ebx
++  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
++    192a:	8d 71 01             	lea    0x1(%ecx),%esi
++  if((prevp = freep) == 0){
++    192d:	0f 84 9b 00 00 00    	je     19ce <malloc+0xbe>
++    1933:	8b 13                	mov    (%ebx),%edx
++    1935:	8b 7a 04             	mov    0x4(%edx),%edi
++    base.s.ptr = freep = prevp = &base;
++    base.s.size = 0;
++  }
++  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
++    if(p->s.size >= nunits){
++    1938:	39 fe                	cmp    %edi,%esi
++    193a:	76 64                	jbe    19a0 <malloc+0x90>
++    193c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
++  if(nu < 4096)
++    1943:	bb 00 80 00 00       	mov    $0x8000,%ebx
++    1948:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++    194b:	eb 0e                	jmp    195b <malloc+0x4b>
++    194d:	8d 76 00             	lea    0x0(%esi),%esi
++  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
++    1950:	8b 02                	mov    (%edx),%eax
++    if(p->s.size >= nunits){
++    1952:	8b 78 04             	mov    0x4(%eax),%edi
++    1955:	39 fe                	cmp    %edi,%esi
++    1957:	76 4f                	jbe    19a8 <malloc+0x98>
++    1959:	89 c2                	mov    %eax,%edx
++        p->s.size = nunits;
++      }
++      freep = prevp;
++      return (void*)(p + 1);
++    }
++    if(p == freep)
++    195b:	3b 15 20 1e 00 00    	cmp    0x1e20,%edx
++    1961:	75 ed                	jne    1950 <malloc+0x40>
++  if(nu < 4096)
++    1963:	8b 45 e4             	mov    -0x1c(%ebp),%eax
++    1966:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
++    196c:	bf 00 10 00 00       	mov    $0x1000,%edi
++    1971:	0f 43 fe             	cmovae %esi,%edi
++    1974:	0f 42 c3             	cmovb  %ebx,%eax
++  p = sbrk(nu * sizeof(Header));
++    1977:	89 04 24             	mov    %eax,(%esp)
++    197a:	e8 3b fc ff ff       	call   15ba <sbrk>
++  if(p == (char*)-1)
++    197f:	83 f8 ff             	cmp    $0xffffffff,%eax
++    1982:	74 18                	je     199c <malloc+0x8c>
++  hp->s.size = nu;
++    1984:	89 78 04             	mov    %edi,0x4(%eax)
++  free((void*)(hp + 1));
++    1987:	83 c0 08             	add    $0x8,%eax
++    198a:	89 04 24             	mov    %eax,(%esp)
++    198d:	e8 ee fe ff ff       	call   1880 <free>
++  return freep;
++    1992:	8b 15 20 1e 00 00    	mov    0x1e20,%edx
++      if((p = morecore(nunits)) == 0)
++    1998:	85 d2                	test   %edx,%edx
++    199a:	75 b4                	jne    1950 <malloc+0x40>
++        return 0;
++    199c:	31 c0                	xor    %eax,%eax
++    199e:	eb 20                	jmp    19c0 <malloc+0xb0>
++    if(p->s.size >= nunits){
++    19a0:	89 d0                	mov    %edx,%eax
++    19a2:	89 da                	mov    %ebx,%edx
++    19a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++      if(p->s.size == nunits)
++    19a8:	39 fe                	cmp    %edi,%esi
++    19aa:	74 1c                	je     19c8 <malloc+0xb8>
++        p->s.size -= nunits;
++    19ac:	29 f7                	sub    %esi,%edi
++    19ae:	89 78 04             	mov    %edi,0x4(%eax)
++        p += p->s.size;
++    19b1:	8d 04 f8             	lea    (%eax,%edi,8),%eax
++        p->s.size = nunits;
++    19b4:	89 70 04             	mov    %esi,0x4(%eax)
++      freep = prevp;
++    19b7:	89 15 20 1e 00 00    	mov    %edx,0x1e20
++      return (void*)(p + 1);
++    19bd:	83 c0 08             	add    $0x8,%eax
++  }
++}
++    19c0:	83 c4 1c             	add    $0x1c,%esp
++    19c3:	5b                   	pop    %ebx
++    19c4:	5e                   	pop    %esi
++    19c5:	5f                   	pop    %edi
++    19c6:	5d                   	pop    %ebp
++    19c7:	c3                   	ret    
++        prevp->s.ptr = p->s.ptr;
++    19c8:	8b 08                	mov    (%eax),%ecx
++    19ca:	89 0a                	mov    %ecx,(%edx)
++    19cc:	eb e9                	jmp    19b7 <malloc+0xa7>
++    base.s.ptr = freep = prevp = &base;
++    19ce:	c7 05 20 1e 00 00 24 	movl   $0x1e24,0x1e20
++    19d5:	1e 00 00 
++    base.s.size = 0;
++    19d8:	ba 24 1e 00 00       	mov    $0x1e24,%edx
++    base.s.ptr = freep = prevp = &base;
++    19dd:	c7 05 24 1e 00 00 24 	movl   $0x1e24,0x1e24
++    19e4:	1e 00 00 
++    base.s.size = 0;
++    19e7:	c7 05 28 1e 00 00 00 	movl   $0x0,0x1e28
++    19ee:	00 00 00 
++    19f1:	e9 46 ff ff ff       	jmp    193c <malloc+0x2c>
++    19f6:	66 90                	xchg   %ax,%ax
++    19f8:	66 90                	xchg   %ax,%ax
++    19fa:	66 90                	xchg   %ax,%ax
++    19fc:	66 90                	xchg   %ax,%ax
++    19fe:	66 90                	xchg   %ax,%ax
++
++00001a00 <uacquire>:
++#include "uspinlock.h"
++#include "x86.h"
++
++void
++uacquire(struct uspinlock *lk)
++{
++    1a00:	55                   	push   %ebp
++xchg(volatile uint *addr, uint newval)
++{
++  uint result;
++
++  // The + in "+m" denotes a read-modify-write operand.
++  asm volatile("lock; xchgl %0, %1" :
++    1a01:	b9 01 00 00 00       	mov    $0x1,%ecx
++    1a06:	89 e5                	mov    %esp,%ebp
++    1a08:	8b 55 08             	mov    0x8(%ebp),%edx
++    1a0b:	90                   	nop
++    1a0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    1a10:	89 c8                	mov    %ecx,%eax
++    1a12:	f0 87 02             	lock xchg %eax,(%edx)
++  // The xchg is atomic.
++  while(xchg(&lk->locked, 1) != 0)
++    1a15:	85 c0                	test   %eax,%eax
++    1a17:	75 f7                	jne    1a10 <uacquire+0x10>
++    ;
++
++  // Tell the C compiler and the processor to not move loads or stores
++  // past this point, to ensure that the critical section's memory
++  // references happen after the lock is acquired.
++  __sync_synchronize();
++    1a19:	0f ae f0             	mfence 
++}
++    1a1c:	5d                   	pop    %ebp
++    1a1d:	c3                   	ret    
++    1a1e:	66 90                	xchg   %ax,%ax
++
++00001a20 <urelease>:
++
++void urelease (struct uspinlock *lk) {
++    1a20:	55                   	push   %ebp
++    1a21:	89 e5                	mov    %esp,%ebp
++    1a23:	8b 45 08             	mov    0x8(%ebp),%eax
++  __sync_synchronize();
++    1a26:	0f ae f0             	mfence 
++
++  // Release the lock, equivalent to lk->locked = 0.
++  // This code can't use a C assignment, since it might
++  // not be atomic. A real OS would use C atomics here.
++  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
++    1a29:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
++}
++    1a2f:	5d                   	pop    %ebp
++    1a30:	c3                   	ret    
+diff --git a/grep.c b/grep.c
+index 4be3256..adc4835 100644
+--- a/grep.c
++++ b/grep.c
+@@ -43,24 +43,24 @@ main(int argc, char *argv[])
+ 
+   if(argc <= 1){
+     printf(2, "usage: grep pattern [file ...]\n");
+-    exit(1);
++    exit();
+   }
+   pattern = argv[1];
+ 
+   if(argc <= 2){
+     grep(pattern, 0);
+-    exit(2);
++    exit();
+   }
+ 
+   for(i = 2; i < argc; i++){
+     if((fd = open(argv[i], 0)) < 0){
+       printf(1, "grep: cannot open %s\n", argv[i]);
+-      exit(3);
++      exit();
+     }
+     grep(pattern, fd);
+     close(fd);
+   }
+-  exit(0);
++  exit();
+ }
+ 
+ // Regexp matcher from Kernighan & Pike,
+diff --git a/grep.d b/grep.d
+new file mode 100644
+index 0000000..15fc65b
+--- /dev/null
++++ b/grep.d
+@@ -0,0 +1 @@
++grep.o: grep.c /usr/include/stdc-predef.h types.h stat.h user.h
+diff --git a/grep.o b/grep.o
+new file mode 100644
+index 0000000..6698905
+Binary files /dev/null and b/grep.o differ
+diff --git a/grep.sym b/grep.sym
+new file mode 100644
+index 0000000..bee3097
+--- /dev/null
++++ b/grep.sym
+@@ -0,0 +1,67 @@
++00001000 .text
++00001a34 .rodata
++00001a84 .eh_frame
++00001e20 .bss
++00000000 .comment
++00000000 .debug_aranges
++00000000 .debug_info
++00000000 .debug_abbrev
++00000000 .debug_line
++00000000 .debug_str
++00000000 .debug_loc
++00000000 .debug_ranges
++00000000 grep.c
++00000000 ulib.c
++00000000 printf.c
++000015f0 printint
++00001a71 digits.1359
++00000000 umalloc.c
++00001e20 freep
++00001e24 base
++00000000 uspinlock.c
++00001310 strcpy
++00001690 printf
++00001500 memmove
++00001120 matchhere
++0000157a mknod
++000015d2 shm_open
++00001420 gets
++000015b2 getpid
++00001200 grep
++00001910 malloc
++000015c2 sleep
++00001542 pipe
++00001552 write
++0000158a fstat
++00001562 kill
++000015a2 chdir
++0000156a exec
++0000153a wait
++0000154a read
++00001582 unlink
++00001a00 uacquire
++0000152a fork
++000015ba sbrk
++000015da shm_close
++000015ca uptime
++00001e04 __bss_start
++000013c0 memset
++00001000 main
++000010c0 matchstar
++00001340 strcmp
++000015aa dup
++00001e40 buf
++00001480 stat
++00001e04 _edata
++00002240 _end
++000011b0 match
++00001592 link
++00001532 exit
++000014d0 atoi
++00001390 strlen
++00001572 open
++000013e0 strchr
++0000159a mkdir
++0000155a close
++00001a20 urelease
++00001880 free
+diff --git a/ide.d b/ide.d
+new file mode 100644
+index 0000000..21155b9
+--- /dev/null
++++ b/ide.d
+@@ -0,0 +1,2 @@
++ide.o: ide.c /usr/include/stdc-predef.h types.h defs.h param.h \
++ memlayout.h mmu.h proc.h x86.h traps.h spinlock.h sleeplock.h fs.h buf.h
+diff --git a/ide.o b/ide.o
+new file mode 100644
+index 0000000..751c026
+Binary files /dev/null and b/ide.o differ
+diff --git a/init.asm b/init.asm
+new file mode 100644
+index 0000000..30a3d54
+--- /dev/null
++++ b/init.asm
+@@ -0,0 +1,1275 @@
++
++_init:     file format elf32-i386
++
++
++Disassembly of section .text:
++
++00001000 <main>:
++
++char *argv[] = { "sh", 0 };
++
++int
++main(void)
++{
++    1000:	55                   	push   %ebp
++    1001:	89 e5                	mov    %esp,%ebp
++    1003:	53                   	push   %ebx
++    1004:	83 e4 f0             	and    $0xfffffff0,%esp
++    1007:	83 ec 10             	sub    $0x10,%esp
++  int pid, wpid;
++
++  if(open("console", O_RDWR) < 0){
++    100a:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
++    1011:	00 
++    1012:	c7 04 24 31 18 00 00 	movl   $0x1831,(%esp)
++    1019:	e8 54 03 00 00       	call   1372 <open>
++    101e:	85 c0                	test   %eax,%eax
++    1020:	0f 88 ac 00 00 00    	js     10d2 <main+0xd2>
++    mknod("console", 1, 1);
++    open("console", O_RDWR);
++  }
++  dup(0);  // stdout
++    1026:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
++    102d:	e8 78 03 00 00       	call   13aa <dup>
++  dup(0);  // stderr
++    1032:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
++    1039:	e8 6c 03 00 00       	call   13aa <dup>
++    103e:	66 90                	xchg   %ax,%ax
++
++  for(;;){
++    printf(1, "init: starting sh\n");
++    1040:	c7 44 24 04 39 18 00 	movl   $0x1839,0x4(%esp)
++    1047:	00 
++    1048:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    104f:	e8 3c 04 00 00       	call   1490 <printf>
++    pid = fork();
++    1054:	e8 d1 02 00 00       	call   132a <fork>
++    if(pid < 0){
++    1059:	85 c0                	test   %eax,%eax
++    pid = fork();
++    105b:	89 c3                	mov    %eax,%ebx
++    if(pid < 0){
++    105d:	78 2d                	js     108c <main+0x8c>
++    105f:	90                   	nop
++      printf(1, "init: fork failed\n");
++      exit();
++    }
++    if(pid == 0){
++    1060:	74 43                	je     10a5 <main+0xa5>
++    1062:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++      exec("sh", argv);
++      printf(1, "init: exec sh failed\n");
++      exit();
++    }
++    while((wpid=wait()) >= 0 && wpid != pid)
++    1068:	e8 cd 02 00 00       	call   133a <wait>
++    106d:	85 c0                	test   %eax,%eax
++    106f:	90                   	nop
++    1070:	78 ce                	js     1040 <main+0x40>
++    1072:	39 d8                	cmp    %ebx,%eax
++    1074:	74 ca                	je     1040 <main+0x40>
++      printf(1, "zombie!\n");
++    1076:	c7 44 24 04 78 18 00 	movl   $0x1878,0x4(%esp)
++    107d:	00 
++    107e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    1085:	e8 06 04 00 00       	call   1490 <printf>
++    108a:	eb dc                	jmp    1068 <main+0x68>
++      printf(1, "init: fork failed\n");
++    108c:	c7 44 24 04 4c 18 00 	movl   $0x184c,0x4(%esp)
++    1093:	00 
++    1094:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    109b:	e8 f0 03 00 00       	call   1490 <printf>
++      exit();
++    10a0:	e8 8d 02 00 00       	call   1332 <exit>
++      exec("sh", argv);
++    10a5:	c7 44 24 04 40 1b 00 	movl   $0x1b40,0x4(%esp)
++    10ac:	00 
++    10ad:	c7 04 24 5f 18 00 00 	movl   $0x185f,(%esp)
++    10b4:	e8 b1 02 00 00       	call   136a <exec>
++      printf(1, "init: exec sh failed\n");
++    10b9:	c7 44 24 04 62 18 00 	movl   $0x1862,0x4(%esp)
++    10c0:	00 
++    10c1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    10c8:	e8 c3 03 00 00       	call   1490 <printf>
++      exit();
++    10cd:	e8 60 02 00 00       	call   1332 <exit>
++    mknod("console", 1, 1);
++    10d2:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    10d9:	00 
++    10da:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
++    10e1:	00 
++    10e2:	c7 04 24 31 18 00 00 	movl   $0x1831,(%esp)
++    10e9:	e8 8c 02 00 00       	call   137a <mknod>
++    open("console", O_RDWR);
++    10ee:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
++    10f5:	00 
++    10f6:	c7 04 24 31 18 00 00 	movl   $0x1831,(%esp)
++    10fd:	e8 70 02 00 00       	call   1372 <open>
++    1102:	e9 1f ff ff ff       	jmp    1026 <main+0x26>
++    1107:	66 90                	xchg   %ax,%ax
++    1109:	66 90                	xchg   %ax,%ax
++    110b:	66 90                	xchg   %ax,%ax
++    110d:	66 90                	xchg   %ax,%ax
++    110f:	90                   	nop
++
++00001110 <strcpy>:
++#include "user.h"
++#include "x86.h"
++
++char*
++strcpy(char *s, char *t)
++{
++    1110:	55                   	push   %ebp
++    1111:	89 e5                	mov    %esp,%ebp
++    1113:	8b 45 08             	mov    0x8(%ebp),%eax
++    1116:	8b 4d 0c             	mov    0xc(%ebp),%ecx
++    1119:	53                   	push   %ebx
++  char *os;
++
++  os = s;
++  while((*s++ = *t++) != 0)
++    111a:	89 c2                	mov    %eax,%edx
++    111c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    1120:	83 c1 01             	add    $0x1,%ecx
++    1123:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
++    1127:	83 c2 01             	add    $0x1,%edx
++    112a:	84 db                	test   %bl,%bl
++    112c:	88 5a ff             	mov    %bl,-0x1(%edx)
++    112f:	75 ef                	jne    1120 <strcpy+0x10>
++    ;
++  return os;
++}
++    1131:	5b                   	pop    %ebx
++    1132:	5d                   	pop    %ebp
++    1133:	c3                   	ret    
++    1134:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    113a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
++
++00001140 <strcmp>:
++
++int
++strcmp(const char *p, const char *q)
++{
++    1140:	55                   	push   %ebp
++    1141:	89 e5                	mov    %esp,%ebp
++    1143:	8b 55 08             	mov    0x8(%ebp),%edx
++    1146:	53                   	push   %ebx
++    1147:	8b 4d 0c             	mov    0xc(%ebp),%ecx
++  while(*p && *p == *q)
++    114a:	0f b6 02             	movzbl (%edx),%eax
++    114d:	84 c0                	test   %al,%al
++    114f:	74 2d                	je     117e <strcmp+0x3e>
++    1151:	0f b6 19             	movzbl (%ecx),%ebx
++    1154:	38 d8                	cmp    %bl,%al
++    1156:	74 0e                	je     1166 <strcmp+0x26>
++    1158:	eb 2b                	jmp    1185 <strcmp+0x45>
++    115a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    1160:	38 c8                	cmp    %cl,%al
++    1162:	75 15                	jne    1179 <strcmp+0x39>
++    p++, q++;
++    1164:	89 d9                	mov    %ebx,%ecx
++    1166:	83 c2 01             	add    $0x1,%edx
++  while(*p && *p == *q)
++    1169:	0f b6 02             	movzbl (%edx),%eax
++    p++, q++;
++    116c:	8d 59 01             	lea    0x1(%ecx),%ebx
++  while(*p && *p == *q)
++    116f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
++    1173:	84 c0                	test   %al,%al
++    1175:	75 e9                	jne    1160 <strcmp+0x20>
++    1177:	31 c0                	xor    %eax,%eax
++  return (uchar)*p - (uchar)*q;
++    1179:	29 c8                	sub    %ecx,%eax
++}
++    117b:	5b                   	pop    %ebx
++    117c:	5d                   	pop    %ebp
++    117d:	c3                   	ret    
++    117e:	0f b6 09             	movzbl (%ecx),%ecx
++  while(*p && *p == *q)
++    1181:	31 c0                	xor    %eax,%eax
++    1183:	eb f4                	jmp    1179 <strcmp+0x39>
++    1185:	0f b6 cb             	movzbl %bl,%ecx
++    1188:	eb ef                	jmp    1179 <strcmp+0x39>
++    118a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++
++00001190 <strlen>:
++
++uint
++strlen(char *s)
++{
++    1190:	55                   	push   %ebp
++    1191:	89 e5                	mov    %esp,%ebp
++    1193:	8b 4d 08             	mov    0x8(%ebp),%ecx
++  int n;
++
++  for(n = 0; s[n]; n++)
++    1196:	80 39 00             	cmpb   $0x0,(%ecx)
++    1199:	74 12                	je     11ad <strlen+0x1d>
++    119b:	31 d2                	xor    %edx,%edx
++    119d:	8d 76 00             	lea    0x0(%esi),%esi
++    11a0:	83 c2 01             	add    $0x1,%edx
++    11a3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
++    11a7:	89 d0                	mov    %edx,%eax
++    11a9:	75 f5                	jne    11a0 <strlen+0x10>
++    ;
++  return n;
++}
++    11ab:	5d                   	pop    %ebp
++    11ac:	c3                   	ret    
++  for(n = 0; s[n]; n++)
++    11ad:	31 c0                	xor    %eax,%eax
++}
++    11af:	5d                   	pop    %ebp
++    11b0:	c3                   	ret    
++    11b1:	eb 0d                	jmp    11c0 <memset>
++    11b3:	90                   	nop
++    11b4:	90                   	nop
++    11b5:	90                   	nop
++    11b6:	90                   	nop
++    11b7:	90                   	nop
++    11b8:	90                   	nop
++    11b9:	90                   	nop
++    11ba:	90                   	nop
++    11bb:	90                   	nop
++    11bc:	90                   	nop
++    11bd:	90                   	nop
++    11be:	90                   	nop
++    11bf:	90                   	nop
++
++000011c0 <memset>:
++
++void*
++memset(void *dst, int c, uint n)
++{
++    11c0:	55                   	push   %ebp
++    11c1:	89 e5                	mov    %esp,%ebp
++    11c3:	8b 55 08             	mov    0x8(%ebp),%edx
++    11c6:	57                   	push   %edi
++}
++
++static inline void
++stosb(void *addr, int data, int cnt)
++{
++  asm volatile("cld; rep stosb" :
++    11c7:	8b 4d 10             	mov    0x10(%ebp),%ecx
++    11ca:	8b 45 0c             	mov    0xc(%ebp),%eax
++    11cd:	89 d7                	mov    %edx,%edi
++    11cf:	fc                   	cld    
++    11d0:	f3 aa                	rep stos %al,%es:(%edi)
++  stosb(dst, c, n);
++  return dst;
++}
++    11d2:	89 d0                	mov    %edx,%eax
++    11d4:	5f                   	pop    %edi
++    11d5:	5d                   	pop    %ebp
++    11d6:	c3                   	ret    
++    11d7:	89 f6                	mov    %esi,%esi
++    11d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++000011e0 <strchr>:
++
++char*
++strchr(const char *s, char c)
++{
++    11e0:	55                   	push   %ebp
++    11e1:	89 e5                	mov    %esp,%ebp
++    11e3:	8b 45 08             	mov    0x8(%ebp),%eax
++    11e6:	53                   	push   %ebx
++    11e7:	8b 55 0c             	mov    0xc(%ebp),%edx
++  for(; *s; s++)
++    11ea:	0f b6 18             	movzbl (%eax),%ebx
++    11ed:	84 db                	test   %bl,%bl
++    11ef:	74 1d                	je     120e <strchr+0x2e>
++    if(*s == c)
++    11f1:	38 d3                	cmp    %dl,%bl
++    11f3:	89 d1                	mov    %edx,%ecx
++    11f5:	75 0d                	jne    1204 <strchr+0x24>
++    11f7:	eb 17                	jmp    1210 <strchr+0x30>
++    11f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++    1200:	38 ca                	cmp    %cl,%dl
++    1202:	74 0c                	je     1210 <strchr+0x30>
++  for(; *s; s++)
++    1204:	83 c0 01             	add    $0x1,%eax
++    1207:	0f b6 10             	movzbl (%eax),%edx
++    120a:	84 d2                	test   %dl,%dl
++    120c:	75 f2                	jne    1200 <strchr+0x20>
++      return (char*)s;
++  return 0;
++    120e:	31 c0                	xor    %eax,%eax
++}
++    1210:	5b                   	pop    %ebx
++    1211:	5d                   	pop    %ebp
++    1212:	c3                   	ret    
++    1213:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    1219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++00001220 <gets>:
++
++char*
++gets(char *buf, int max)
++{
++    1220:	55                   	push   %ebp
++    1221:	89 e5                	mov    %esp,%ebp
++    1223:	57                   	push   %edi
++    1224:	56                   	push   %esi
++  int i, cc;
++  char c;
++
++  for(i=0; i+1 < max; ){
++    1225:	31 f6                	xor    %esi,%esi
++{
++    1227:	53                   	push   %ebx
++    1228:	83 ec 2c             	sub    $0x2c,%esp
++    cc = read(0, &c, 1);
++    122b:	8d 7d e7             	lea    -0x19(%ebp),%edi
++  for(i=0; i+1 < max; ){
++    122e:	eb 31                	jmp    1261 <gets+0x41>
++    cc = read(0, &c, 1);
++    1230:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1237:	00 
++    1238:	89 7c 24 04          	mov    %edi,0x4(%esp)
++    123c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
++    1243:	e8 02 01 00 00       	call   134a <read>
++    if(cc < 1)
++    1248:	85 c0                	test   %eax,%eax
++    124a:	7e 1d                	jle    1269 <gets+0x49>
++      break;
++    buf[i++] = c;
++    124c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
++  for(i=0; i+1 < max; ){
++    1250:	89 de                	mov    %ebx,%esi
++    buf[i++] = c;
++    1252:	8b 55 08             	mov    0x8(%ebp),%edx
++    if(c == '\n' || c == '\r')
++    1255:	3c 0d                	cmp    $0xd,%al
++    buf[i++] = c;
++    1257:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
++    if(c == '\n' || c == '\r')
++    125b:	74 0c                	je     1269 <gets+0x49>
++    125d:	3c 0a                	cmp    $0xa,%al
++    125f:	74 08                	je     1269 <gets+0x49>
++  for(i=0; i+1 < max; ){
++    1261:	8d 5e 01             	lea    0x1(%esi),%ebx
++    1264:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
++    1267:	7c c7                	jl     1230 <gets+0x10>
++      break;
++  }
++  buf[i] = '\0';
++    1269:	8b 45 08             	mov    0x8(%ebp),%eax
++    126c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
++  return buf;
++}
++    1270:	83 c4 2c             	add    $0x2c,%esp
++    1273:	5b                   	pop    %ebx
++    1274:	5e                   	pop    %esi
++    1275:	5f                   	pop    %edi
++    1276:	5d                   	pop    %ebp
++    1277:	c3                   	ret    
++    1278:	90                   	nop
++    1279:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++
++00001280 <stat>:
++
++int
++stat(char *n, struct stat *st)
++{
++    1280:	55                   	push   %ebp
++    1281:	89 e5                	mov    %esp,%ebp
++    1283:	56                   	push   %esi
++    1284:	53                   	push   %ebx
++    1285:	83 ec 10             	sub    $0x10,%esp
++  int fd;
++  int r;
++
++  fd = open(n, O_RDONLY);
++    1288:	8b 45 08             	mov    0x8(%ebp),%eax
++    128b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
++    1292:	00 
++    1293:	89 04 24             	mov    %eax,(%esp)
++    1296:	e8 d7 00 00 00       	call   1372 <open>
++  if(fd < 0)
++    129b:	85 c0                	test   %eax,%eax
++  fd = open(n, O_RDONLY);
++    129d:	89 c3                	mov    %eax,%ebx
++  if(fd < 0)
++    129f:	78 27                	js     12c8 <stat+0x48>
++    return -1;
++  r = fstat(fd, st);
++    12a1:	8b 45 0c             	mov    0xc(%ebp),%eax
++    12a4:	89 1c 24             	mov    %ebx,(%esp)
++    12a7:	89 44 24 04          	mov    %eax,0x4(%esp)
++    12ab:	e8 da 00 00 00       	call   138a <fstat>
++  close(fd);
++    12b0:	89 1c 24             	mov    %ebx,(%esp)
++  r = fstat(fd, st);
++    12b3:	89 c6                	mov    %eax,%esi
++  close(fd);
++    12b5:	e8 a0 00 00 00       	call   135a <close>
++  return r;
++    12ba:	89 f0                	mov    %esi,%eax
++}
++    12bc:	83 c4 10             	add    $0x10,%esp
++    12bf:	5b                   	pop    %ebx
++    12c0:	5e                   	pop    %esi
++    12c1:	5d                   	pop    %ebp
++    12c2:	c3                   	ret    
++    12c3:	90                   	nop
++    12c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    return -1;
++    12c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++    12cd:	eb ed                	jmp    12bc <stat+0x3c>
++    12cf:	90                   	nop
++
++000012d0 <atoi>:
++
++int
++atoi(const char *s)
++{
++    12d0:	55                   	push   %ebp
++    12d1:	89 e5                	mov    %esp,%ebp
++    12d3:	8b 4d 08             	mov    0x8(%ebp),%ecx
++    12d6:	53                   	push   %ebx
++  int n;
++
++  n = 0;
++  while('0' <= *s && *s <= '9')
++    12d7:	0f be 11             	movsbl (%ecx),%edx
++    12da:	8d 42 d0             	lea    -0x30(%edx),%eax
++    12dd:	3c 09                	cmp    $0x9,%al
++  n = 0;
++    12df:	b8 00 00 00 00       	mov    $0x0,%eax
++  while('0' <= *s && *s <= '9')
++    12e4:	77 17                	ja     12fd <atoi+0x2d>
++    12e6:	66 90                	xchg   %ax,%ax
++    n = n*10 + *s++ - '0';
++    12e8:	83 c1 01             	add    $0x1,%ecx
++    12eb:	8d 04 80             	lea    (%eax,%eax,4),%eax
++    12ee:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
++  while('0' <= *s && *s <= '9')
++    12f2:	0f be 11             	movsbl (%ecx),%edx
++    12f5:	8d 5a d0             	lea    -0x30(%edx),%ebx
++    12f8:	80 fb 09             	cmp    $0x9,%bl
++    12fb:	76 eb                	jbe    12e8 <atoi+0x18>
++  return n;
++}
++    12fd:	5b                   	pop    %ebx
++    12fe:	5d                   	pop    %ebp
++    12ff:	c3                   	ret    
++
++00001300 <memmove>:
++
++void*
++memmove(void *vdst, void *vsrc, int n)
++{
++    1300:	55                   	push   %ebp
++  char *dst, *src;
++
++  dst = vdst;
++  src = vsrc;
++  while(n-- > 0)
++    1301:	31 d2                	xor    %edx,%edx
++{
++    1303:	89 e5                	mov    %esp,%ebp
++    1305:	56                   	push   %esi
++    1306:	8b 45 08             	mov    0x8(%ebp),%eax
++    1309:	53                   	push   %ebx
++    130a:	8b 5d 10             	mov    0x10(%ebp),%ebx
++    130d:	8b 75 0c             	mov    0xc(%ebp),%esi
++  while(n-- > 0)
++    1310:	85 db                	test   %ebx,%ebx
++    1312:	7e 12                	jle    1326 <memmove+0x26>
++    1314:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    *dst++ = *src++;
++    1318:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
++    131c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
++    131f:	83 c2 01             	add    $0x1,%edx
++  while(n-- > 0)
++    1322:	39 da                	cmp    %ebx,%edx
++    1324:	75 f2                	jne    1318 <memmove+0x18>
++  return vdst;
++}
++    1326:	5b                   	pop    %ebx
++    1327:	5e                   	pop    %esi
++    1328:	5d                   	pop    %ebp
++    1329:	c3                   	ret    
++
++0000132a <fork>:
++  name: \
++    movl $SYS_ ## name, %eax; \
++    int $T_SYSCALL; \
++    ret
++
++SYSCALL(fork)
++    132a:	b8 01 00 00 00       	mov    $0x1,%eax
++    132f:	cd 40                	int    $0x40
++    1331:	c3                   	ret    
++
++00001332 <exit>:
++SYSCALL(exit)
++    1332:	b8 02 00 00 00       	mov    $0x2,%eax
++    1337:	cd 40                	int    $0x40
++    1339:	c3                   	ret    
++
++0000133a <wait>:
++SYSCALL(wait)
++    133a:	b8 03 00 00 00       	mov    $0x3,%eax
++    133f:	cd 40                	int    $0x40
++    1341:	c3                   	ret    
++
++00001342 <pipe>:
++SYSCALL(pipe)
++    1342:	b8 04 00 00 00       	mov    $0x4,%eax
++    1347:	cd 40                	int    $0x40
++    1349:	c3                   	ret    
++
++0000134a <read>:
++SYSCALL(read)
++    134a:	b8 05 00 00 00       	mov    $0x5,%eax
++    134f:	cd 40                	int    $0x40
++    1351:	c3                   	ret    
++
++00001352 <write>:
++SYSCALL(write)
++    1352:	b8 10 00 00 00       	mov    $0x10,%eax
++    1357:	cd 40                	int    $0x40
++    1359:	c3                   	ret    
++
++0000135a <close>:
++SYSCALL(close)
++    135a:	b8 15 00 00 00       	mov    $0x15,%eax
++    135f:	cd 40                	int    $0x40
++    1361:	c3                   	ret    
++
++00001362 <kill>:
++SYSCALL(kill)
++    1362:	b8 06 00 00 00       	mov    $0x6,%eax
++    1367:	cd 40                	int    $0x40
++    1369:	c3                   	ret    
++
++0000136a <exec>:
++SYSCALL(exec)
++    136a:	b8 07 00 00 00       	mov    $0x7,%eax
++    136f:	cd 40                	int    $0x40
++    1371:	c3                   	ret    
++
++00001372 <open>:
++SYSCALL(open)
++    1372:	b8 0f 00 00 00       	mov    $0xf,%eax
++    1377:	cd 40                	int    $0x40
++    1379:	c3                   	ret    
++
++0000137a <mknod>:
++SYSCALL(mknod)
++    137a:	b8 11 00 00 00       	mov    $0x11,%eax
++    137f:	cd 40                	int    $0x40
++    1381:	c3                   	ret    
++
++00001382 <unlink>:
++SYSCALL(unlink)
++    1382:	b8 12 00 00 00       	mov    $0x12,%eax
++    1387:	cd 40                	int    $0x40
++    1389:	c3                   	ret    
++
++0000138a <fstat>:
++SYSCALL(fstat)
++    138a:	b8 08 00 00 00       	mov    $0x8,%eax
++    138f:	cd 40                	int    $0x40
++    1391:	c3                   	ret    
++
++00001392 <link>:
++SYSCALL(link)
++    1392:	b8 13 00 00 00       	mov    $0x13,%eax
++    1397:	cd 40                	int    $0x40
++    1399:	c3                   	ret    
++
++0000139a <mkdir>:
++SYSCALL(mkdir)
++    139a:	b8 14 00 00 00       	mov    $0x14,%eax
++    139f:	cd 40                	int    $0x40
++    13a1:	c3                   	ret    
++
++000013a2 <chdir>:
++SYSCALL(chdir)
++    13a2:	b8 09 00 00 00       	mov    $0x9,%eax
++    13a7:	cd 40                	int    $0x40
++    13a9:	c3                   	ret    
++
++000013aa <dup>:
++SYSCALL(dup)
++    13aa:	b8 0a 00 00 00       	mov    $0xa,%eax
++    13af:	cd 40                	int    $0x40
++    13b1:	c3                   	ret    
++
++000013b2 <getpid>:
++SYSCALL(getpid)
++    13b2:	b8 0b 00 00 00       	mov    $0xb,%eax
++    13b7:	cd 40                	int    $0x40
++    13b9:	c3                   	ret    
++
++000013ba <sbrk>:
++SYSCALL(sbrk)
++    13ba:	b8 0c 00 00 00       	mov    $0xc,%eax
++    13bf:	cd 40                	int    $0x40
++    13c1:	c3                   	ret    
++
++000013c2 <sleep>:
++SYSCALL(sleep)
++    13c2:	b8 0d 00 00 00       	mov    $0xd,%eax
++    13c7:	cd 40                	int    $0x40
++    13c9:	c3                   	ret    
++
++000013ca <uptime>:
++SYSCALL(uptime)
++    13ca:	b8 0e 00 00 00       	mov    $0xe,%eax
++    13cf:	cd 40                	int    $0x40
++    13d1:	c3                   	ret    
++
++000013d2 <shm_open>:
++SYSCALL(shm_open)
++    13d2:	b8 16 00 00 00       	mov    $0x16,%eax
++    13d7:	cd 40                	int    $0x40
++    13d9:	c3                   	ret    
++
++000013da <shm_close>:
++SYSCALL(shm_close)	
++    13da:	b8 17 00 00 00       	mov    $0x17,%eax
++    13df:	cd 40                	int    $0x40
++    13e1:	c3                   	ret    
++    13e2:	66 90                	xchg   %ax,%ax
++    13e4:	66 90                	xchg   %ax,%ax
++    13e6:	66 90                	xchg   %ax,%ax
++    13e8:	66 90                	xchg   %ax,%ax
++    13ea:	66 90                	xchg   %ax,%ax
++    13ec:	66 90                	xchg   %ax,%ax
++    13ee:	66 90                	xchg   %ax,%ax
++
++000013f0 <printint>:
++  write(fd, &c, 1);
++}
++
++static void
++printint(int fd, int xx, int base, int sgn)
++{
++    13f0:	55                   	push   %ebp
++    13f1:	89 e5                	mov    %esp,%ebp
++    13f3:	57                   	push   %edi
++    13f4:	56                   	push   %esi
++    13f5:	89 c6                	mov    %eax,%esi
++    13f7:	53                   	push   %ebx
++    13f8:	83 ec 4c             	sub    $0x4c,%esp
++  char buf[16];
++  int i, neg;
++  uint x;
++
++  neg = 0;
++  if(sgn && xx < 0){
++    13fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
++    13fe:	85 db                	test   %ebx,%ebx
++    1400:	74 09                	je     140b <printint+0x1b>
++    1402:	89 d0                	mov    %edx,%eax
++    1404:	c1 e8 1f             	shr    $0x1f,%eax
++    1407:	84 c0                	test   %al,%al
++    1409:	75 75                	jne    1480 <printint+0x90>
++    neg = 1;
++    x = -xx;
++  } else {
++    x = xx;
++    140b:	89 d0                	mov    %edx,%eax
++  neg = 0;
++    140d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
++    1414:	89 75 c0             	mov    %esi,-0x40(%ebp)
++  }
++
++  i = 0;
++    1417:	31 ff                	xor    %edi,%edi
++    1419:	89 ce                	mov    %ecx,%esi
++    141b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
++    141e:	eb 02                	jmp    1422 <printint+0x32>
++  do{
++    buf[i++] = digits[x % base];
++    1420:	89 cf                	mov    %ecx,%edi
++    1422:	31 d2                	xor    %edx,%edx
++    1424:	f7 f6                	div    %esi
++    1426:	8d 4f 01             	lea    0x1(%edi),%ecx
++    1429:	0f b6 92 88 18 00 00 	movzbl 0x1888(%edx),%edx
++  }while((x /= base) != 0);
++    1430:	85 c0                	test   %eax,%eax
++    buf[i++] = digits[x % base];
++    1432:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
++  }while((x /= base) != 0);
++    1435:	75 e9                	jne    1420 <printint+0x30>
++  if(neg)
++    1437:	8b 55 c4             	mov    -0x3c(%ebp),%edx
++    buf[i++] = digits[x % base];
++    143a:	89 c8                	mov    %ecx,%eax
++    143c:	8b 75 c0             	mov    -0x40(%ebp),%esi
++  if(neg)
++    143f:	85 d2                	test   %edx,%edx
++    1441:	74 08                	je     144b <printint+0x5b>
++    buf[i++] = '-';
++    1443:	8d 4f 02             	lea    0x2(%edi),%ecx
++    1446:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
++
++  while(--i >= 0)
++    144b:	8d 79 ff             	lea    -0x1(%ecx),%edi
++    144e:	66 90                	xchg   %ax,%ax
++    1450:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
++    1455:	83 ef 01             	sub    $0x1,%edi
++  write(fd, &c, 1);
++    1458:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    145f:	00 
++    1460:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++    1464:	89 34 24             	mov    %esi,(%esp)
++    1467:	88 45 d7             	mov    %al,-0x29(%ebp)
++    146a:	e8 e3 fe ff ff       	call   1352 <write>
++  while(--i >= 0)
++    146f:	83 ff ff             	cmp    $0xffffffff,%edi
++    1472:	75 dc                	jne    1450 <printint+0x60>
++    putc(fd, buf[i]);
++}
++    1474:	83 c4 4c             	add    $0x4c,%esp
++    1477:	5b                   	pop    %ebx
++    1478:	5e                   	pop    %esi
++    1479:	5f                   	pop    %edi
++    147a:	5d                   	pop    %ebp
++    147b:	c3                   	ret    
++    147c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    x = -xx;
++    1480:	89 d0                	mov    %edx,%eax
++    1482:	f7 d8                	neg    %eax
++    neg = 1;
++    1484:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
++    148b:	eb 87                	jmp    1414 <printint+0x24>
++    148d:	8d 76 00             	lea    0x0(%esi),%esi
++
++00001490 <printf>:
++
++// Print to the given fd. Only understands %d, %x, %p, %s.
++void
++printf(int fd, char *fmt, ...)
++{
++    1490:	55                   	push   %ebp
++    1491:	89 e5                	mov    %esp,%ebp
++    1493:	57                   	push   %edi
++  char *s;
++  int c, i, state;
++  uint *ap;
++
++  state = 0;
++    1494:	31 ff                	xor    %edi,%edi
++{
++    1496:	56                   	push   %esi
++    1497:	53                   	push   %ebx
++    1498:	83 ec 3c             	sub    $0x3c,%esp
++  ap = (uint*)(void*)&fmt + 1;
++  for(i = 0; fmt[i]; i++){
++    149b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
++  ap = (uint*)(void*)&fmt + 1;
++    149e:	8d 45 10             	lea    0x10(%ebp),%eax
++{
++    14a1:	8b 75 08             	mov    0x8(%ebp),%esi
++  ap = (uint*)(void*)&fmt + 1;
++    14a4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
++  for(i = 0; fmt[i]; i++){
++    14a7:	0f b6 13             	movzbl (%ebx),%edx
++    14aa:	83 c3 01             	add    $0x1,%ebx
++    14ad:	84 d2                	test   %dl,%dl
++    14af:	75 39                	jne    14ea <printf+0x5a>
++    14b1:	e9 c2 00 00 00       	jmp    1578 <printf+0xe8>
++    14b6:	66 90                	xchg   %ax,%ax
++    c = fmt[i] & 0xff;
++    if(state == 0){
++      if(c == '%'){
++    14b8:	83 fa 25             	cmp    $0x25,%edx
++    14bb:	0f 84 bf 00 00 00    	je     1580 <printf+0xf0>
++  write(fd, &c, 1);
++    14c1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
++    14c4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    14cb:	00 
++    14cc:	89 44 24 04          	mov    %eax,0x4(%esp)
++    14d0:	89 34 24             	mov    %esi,(%esp)
++        state = '%';
++      } else {
++        putc(fd, c);
++    14d3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
++  write(fd, &c, 1);
++    14d6:	e8 77 fe ff ff       	call   1352 <write>
++    14db:	83 c3 01             	add    $0x1,%ebx
++  for(i = 0; fmt[i]; i++){
++    14de:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
++    14e2:	84 d2                	test   %dl,%dl
++    14e4:	0f 84 8e 00 00 00    	je     1578 <printf+0xe8>
++    if(state == 0){
++    14ea:	85 ff                	test   %edi,%edi
++    c = fmt[i] & 0xff;
++    14ec:	0f be c2             	movsbl %dl,%eax
++    if(state == 0){
++    14ef:	74 c7                	je     14b8 <printf+0x28>
++      }
++    } else if(state == '%'){
++    14f1:	83 ff 25             	cmp    $0x25,%edi
++    14f4:	75 e5                	jne    14db <printf+0x4b>
++      if(c == 'd'){
++    14f6:	83 fa 64             	cmp    $0x64,%edx
++    14f9:	0f 84 31 01 00 00    	je     1630 <printf+0x1a0>
++        printint(fd, *ap, 10, 1);
++        ap++;
++      } else if(c == 'x' || c == 'p'){
++    14ff:	25 f7 00 00 00       	and    $0xf7,%eax
++    1504:	83 f8 70             	cmp    $0x70,%eax
++    1507:	0f 84 83 00 00 00    	je     1590 <printf+0x100>
++        printint(fd, *ap, 16, 0);
++        ap++;
++      } else if(c == 's'){
++    150d:	83 fa 73             	cmp    $0x73,%edx
++    1510:	0f 84 a2 00 00 00    	je     15b8 <printf+0x128>
++          s = "(null)";
++        while(*s != 0){
++          putc(fd, *s);
++          s++;
++        }
++      } else if(c == 'c'){
++    1516:	83 fa 63             	cmp    $0x63,%edx
++    1519:	0f 84 35 01 00 00    	je     1654 <printf+0x1c4>
++        putc(fd, *ap);
++        ap++;
++      } else if(c == '%'){
++    151f:	83 fa 25             	cmp    $0x25,%edx
++    1522:	0f 84 e0 00 00 00    	je     1608 <printf+0x178>
++  write(fd, &c, 1);
++    1528:	8d 45 e6             	lea    -0x1a(%ebp),%eax
++    152b:	83 c3 01             	add    $0x1,%ebx
++    152e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1535:	00 
++      } else {
++        // Unknown % sequence.  Print it to draw attention.
++        putc(fd, '%');
++        putc(fd, c);
++      }
++      state = 0;
++    1536:	31 ff                	xor    %edi,%edi
++  write(fd, &c, 1);
++    1538:	89 44 24 04          	mov    %eax,0x4(%esp)
++    153c:	89 34 24             	mov    %esi,(%esp)
++    153f:	89 55 d0             	mov    %edx,-0x30(%ebp)
++    1542:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
++    1546:	e8 07 fe ff ff       	call   1352 <write>
++        putc(fd, c);
++    154b:	8b 55 d0             	mov    -0x30(%ebp),%edx
++  write(fd, &c, 1);
++    154e:	8d 45 e7             	lea    -0x19(%ebp),%eax
++    1551:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1558:	00 
++    1559:	89 44 24 04          	mov    %eax,0x4(%esp)
++    155d:	89 34 24             	mov    %esi,(%esp)
++        putc(fd, c);
++    1560:	88 55 e7             	mov    %dl,-0x19(%ebp)
++  write(fd, &c, 1);
++    1563:	e8 ea fd ff ff       	call   1352 <write>
++  for(i = 0; fmt[i]; i++){
++    1568:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
++    156c:	84 d2                	test   %dl,%dl
++    156e:	0f 85 76 ff ff ff    	jne    14ea <printf+0x5a>
++    1574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    }
++  }
++}
++    1578:	83 c4 3c             	add    $0x3c,%esp
++    157b:	5b                   	pop    %ebx
++    157c:	5e                   	pop    %esi
++    157d:	5f                   	pop    %edi
++    157e:	5d                   	pop    %ebp
++    157f:	c3                   	ret    
++        state = '%';
++    1580:	bf 25 00 00 00       	mov    $0x25,%edi
++    1585:	e9 51 ff ff ff       	jmp    14db <printf+0x4b>
++    158a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++        printint(fd, *ap, 16, 0);
++    1590:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++    1593:	b9 10 00 00 00       	mov    $0x10,%ecx
++      state = 0;
++    1598:	31 ff                	xor    %edi,%edi
++        printint(fd, *ap, 16, 0);
++    159a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
++    15a1:	8b 10                	mov    (%eax),%edx
++    15a3:	89 f0                	mov    %esi,%eax
++    15a5:	e8 46 fe ff ff       	call   13f0 <printint>
++        ap++;
++    15aa:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++    15ae:	e9 28 ff ff ff       	jmp    14db <printf+0x4b>
++    15b3:	90                   	nop
++    15b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++        s = (char*)*ap;
++    15b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++        ap++;
++    15bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++        s = (char*)*ap;
++    15bf:	8b 38                	mov    (%eax),%edi
++          s = "(null)";
++    15c1:	b8 81 18 00 00       	mov    $0x1881,%eax
++    15c6:	85 ff                	test   %edi,%edi
++    15c8:	0f 44 f8             	cmove  %eax,%edi
++        while(*s != 0){
++    15cb:	0f b6 07             	movzbl (%edi),%eax
++    15ce:	84 c0                	test   %al,%al
++    15d0:	74 2a                	je     15fc <printf+0x16c>
++    15d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    15d8:	88 45 e3             	mov    %al,-0x1d(%ebp)
++  write(fd, &c, 1);
++    15db:	8d 45 e3             	lea    -0x1d(%ebp),%eax
++          s++;
++    15de:	83 c7 01             	add    $0x1,%edi
++  write(fd, &c, 1);
++    15e1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    15e8:	00 
++    15e9:	89 44 24 04          	mov    %eax,0x4(%esp)
++    15ed:	89 34 24             	mov    %esi,(%esp)
++    15f0:	e8 5d fd ff ff       	call   1352 <write>
++        while(*s != 0){
++    15f5:	0f b6 07             	movzbl (%edi),%eax
++    15f8:	84 c0                	test   %al,%al
++    15fa:	75 dc                	jne    15d8 <printf+0x148>
++      state = 0;
++    15fc:	31 ff                	xor    %edi,%edi
++    15fe:	e9 d8 fe ff ff       	jmp    14db <printf+0x4b>
++    1603:	90                   	nop
++    1604:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++  write(fd, &c, 1);
++    1608:	8d 45 e5             	lea    -0x1b(%ebp),%eax
++      state = 0;
++    160b:	31 ff                	xor    %edi,%edi
++  write(fd, &c, 1);
++    160d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1614:	00 
++    1615:	89 44 24 04          	mov    %eax,0x4(%esp)
++    1619:	89 34 24             	mov    %esi,(%esp)
++    161c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
++    1620:	e8 2d fd ff ff       	call   1352 <write>
++    1625:	e9 b1 fe ff ff       	jmp    14db <printf+0x4b>
++    162a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++        printint(fd, *ap, 10, 1);
++    1630:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++    1633:	b9 0a 00 00 00       	mov    $0xa,%ecx
++      state = 0;
++    1638:	66 31 ff             	xor    %di,%di
++        printint(fd, *ap, 10, 1);
++    163b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++    1642:	8b 10                	mov    (%eax),%edx
++    1644:	89 f0                	mov    %esi,%eax
++    1646:	e8 a5 fd ff ff       	call   13f0 <printint>
++        ap++;
++    164b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++    164f:	e9 87 fe ff ff       	jmp    14db <printf+0x4b>
++        putc(fd, *ap);
++    1654:	8b 45 d4             	mov    -0x2c(%ebp),%eax
++      state = 0;
++    1657:	31 ff                	xor    %edi,%edi
++        putc(fd, *ap);
++    1659:	8b 00                	mov    (%eax),%eax
++  write(fd, &c, 1);
++    165b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1662:	00 
++    1663:	89 34 24             	mov    %esi,(%esp)
++        putc(fd, *ap);
++    1666:	88 45 e4             	mov    %al,-0x1c(%ebp)
++  write(fd, &c, 1);
++    1669:	8d 45 e4             	lea    -0x1c(%ebp),%eax
++    166c:	89 44 24 04          	mov    %eax,0x4(%esp)
++    1670:	e8 dd fc ff ff       	call   1352 <write>
++        ap++;
++    1675:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
++    1679:	e9 5d fe ff ff       	jmp    14db <printf+0x4b>
++    167e:	66 90                	xchg   %ax,%ax
++
++00001680 <free>:
++static Header base;
++static Header *freep;
++
++void
++free(void *ap)
++{
++    1680:	55                   	push   %ebp
++  Header *bp, *p;
++
++  bp = (Header*)ap - 1;
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    1681:	a1 48 1b 00 00       	mov    0x1b48,%eax
++{
++    1686:	89 e5                	mov    %esp,%ebp
++    1688:	57                   	push   %edi
++    1689:	56                   	push   %esi
++    168a:	53                   	push   %ebx
++    168b:	8b 5d 08             	mov    0x8(%ebp),%ebx
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    168e:	8b 08                	mov    (%eax),%ecx
++  bp = (Header*)ap - 1;
++    1690:	8d 53 f8             	lea    -0x8(%ebx),%edx
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    1693:	39 d0                	cmp    %edx,%eax
++    1695:	72 11                	jb     16a8 <free+0x28>
++    1697:	90                   	nop
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    1698:	39 c8                	cmp    %ecx,%eax
++    169a:	72 04                	jb     16a0 <free+0x20>
++    169c:	39 ca                	cmp    %ecx,%edx
++    169e:	72 10                	jb     16b0 <free+0x30>
++    16a0:	89 c8                	mov    %ecx,%eax
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    16a2:	39 d0                	cmp    %edx,%eax
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    16a4:	8b 08                	mov    (%eax),%ecx
++  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
++    16a6:	73 f0                	jae    1698 <free+0x18>
++    16a8:	39 ca                	cmp    %ecx,%edx
++    16aa:	72 04                	jb     16b0 <free+0x30>
++    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
++    16ac:	39 c8                	cmp    %ecx,%eax
++    16ae:	72 f0                	jb     16a0 <free+0x20>
++      break;
++  if(bp + bp->s.size == p->s.ptr){
++    16b0:	8b 73 fc             	mov    -0x4(%ebx),%esi
++    16b3:	8d 3c f2             	lea    (%edx,%esi,8),%edi
++    16b6:	39 cf                	cmp    %ecx,%edi
++    16b8:	74 1e                	je     16d8 <free+0x58>
++    bp->s.size += p->s.ptr->s.size;
++    bp->s.ptr = p->s.ptr->s.ptr;
++  } else
++    bp->s.ptr = p->s.ptr;
++    16ba:	89 4b f8             	mov    %ecx,-0x8(%ebx)
++  if(p + p->s.size == bp){
++    16bd:	8b 48 04             	mov    0x4(%eax),%ecx
++    16c0:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
++    16c3:	39 f2                	cmp    %esi,%edx
++    16c5:	74 28                	je     16ef <free+0x6f>
++    p->s.size += bp->s.size;
++    p->s.ptr = bp->s.ptr;
++  } else
++    p->s.ptr = bp;
++    16c7:	89 10                	mov    %edx,(%eax)
++  freep = p;
++    16c9:	a3 48 1b 00 00       	mov    %eax,0x1b48
++}
++    16ce:	5b                   	pop    %ebx
++    16cf:	5e                   	pop    %esi
++    16d0:	5f                   	pop    %edi
++    16d1:	5d                   	pop    %ebp
++    16d2:	c3                   	ret    
++    16d3:	90                   	nop
++    16d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    bp->s.size += p->s.ptr->s.size;
++    16d8:	03 71 04             	add    0x4(%ecx),%esi
++    16db:	89 73 fc             	mov    %esi,-0x4(%ebx)
++    bp->s.ptr = p->s.ptr->s.ptr;
++    16de:	8b 08                	mov    (%eax),%ecx
++    16e0:	8b 09                	mov    (%ecx),%ecx
++    16e2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
++  if(p + p->s.size == bp){
++    16e5:	8b 48 04             	mov    0x4(%eax),%ecx
++    16e8:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
++    16eb:	39 f2                	cmp    %esi,%edx
++    16ed:	75 d8                	jne    16c7 <free+0x47>
++    p->s.size += bp->s.size;
++    16ef:	03 4b fc             	add    -0x4(%ebx),%ecx
++  freep = p;
++    16f2:	a3 48 1b 00 00       	mov    %eax,0x1b48
++    p->s.size += bp->s.size;
++    16f7:	89 48 04             	mov    %ecx,0x4(%eax)
++    p->s.ptr = bp->s.ptr;
++    16fa:	8b 53 f8             	mov    -0x8(%ebx),%edx
++    16fd:	89 10                	mov    %edx,(%eax)
++}
++    16ff:	5b                   	pop    %ebx
++    1700:	5e                   	pop    %esi
++    1701:	5f                   	pop    %edi
++    1702:	5d                   	pop    %ebp
++    1703:	c3                   	ret    
++    1704:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    170a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
++
++00001710 <malloc>:
++  return freep;
++}
++
++void*
++malloc(uint nbytes)
++{
++    1710:	55                   	push   %ebp
++    1711:	89 e5                	mov    %esp,%ebp
++    1713:	57                   	push   %edi
++    1714:	56                   	push   %esi
++    1715:	53                   	push   %ebx
++    1716:	83 ec 1c             	sub    $0x1c,%esp
++  Header *p, *prevp;
++  uint nunits;
++
++  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
++    1719:	8b 45 08             	mov    0x8(%ebp),%eax
++  if((prevp = freep) == 0){
++    171c:	8b 1d 48 1b 00 00    	mov    0x1b48,%ebx
++  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
++    1722:	8d 48 07             	lea    0x7(%eax),%ecx
++    1725:	c1 e9 03             	shr    $0x3,%ecx
++  if((prevp = freep) == 0){
++    1728:	85 db                	test   %ebx,%ebx
++  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
++    172a:	8d 71 01             	lea    0x1(%ecx),%esi
++  if((prevp = freep) == 0){
++    172d:	0f 84 9b 00 00 00    	je     17ce <malloc+0xbe>
++    1733:	8b 13                	mov    (%ebx),%edx
++    1735:	8b 7a 04             	mov    0x4(%edx),%edi
++    base.s.ptr = freep = prevp = &base;
++    base.s.size = 0;
++  }
++  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
++    if(p->s.size >= nunits){
++    1738:	39 fe                	cmp    %edi,%esi
++    173a:	76 64                	jbe    17a0 <malloc+0x90>
++    173c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
++  if(nu < 4096)
++    1743:	bb 00 80 00 00       	mov    $0x8000,%ebx
++    1748:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++    174b:	eb 0e                	jmp    175b <malloc+0x4b>
++    174d:	8d 76 00             	lea    0x0(%esi),%esi
++  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
++    1750:	8b 02                	mov    (%edx),%eax
++    if(p->s.size >= nunits){
++    1752:	8b 78 04             	mov    0x4(%eax),%edi
++    1755:	39 fe                	cmp    %edi,%esi
++    1757:	76 4f                	jbe    17a8 <malloc+0x98>
++    1759:	89 c2                	mov    %eax,%edx
++        p->s.size = nunits;
++      }
++      freep = prevp;
++      return (void*)(p + 1);
++    }
++    if(p == freep)
++    175b:	3b 15 48 1b 00 00    	cmp    0x1b48,%edx
++    1761:	75 ed                	jne    1750 <malloc+0x40>
++  if(nu < 4096)
++    1763:	8b 45 e4             	mov    -0x1c(%ebp),%eax
++    1766:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
++    176c:	bf 00 10 00 00       	mov    $0x1000,%edi
++    1771:	0f 43 fe             	cmovae %esi,%edi
++    1774:	0f 42 c3             	cmovb  %ebx,%eax
++  p = sbrk(nu * sizeof(Header));
++    1777:	89 04 24             	mov    %eax,(%esp)
++    177a:	e8 3b fc ff ff       	call   13ba <sbrk>
++  if(p == (char*)-1)
++    177f:	83 f8 ff             	cmp    $0xffffffff,%eax
++    1782:	74 18                	je     179c <malloc+0x8c>
++  hp->s.size = nu;
++    1784:	89 78 04             	mov    %edi,0x4(%eax)
++  free((void*)(hp + 1));
++    1787:	83 c0 08             	add    $0x8,%eax
++    178a:	89 04 24             	mov    %eax,(%esp)
++    178d:	e8 ee fe ff ff       	call   1680 <free>
++  return freep;
++    1792:	8b 15 48 1b 00 00    	mov    0x1b48,%edx
++      if((p = morecore(nunits)) == 0)
++    1798:	85 d2                	test   %edx,%edx
++    179a:	75 b4                	jne    1750 <malloc+0x40>
++        return 0;
++    179c:	31 c0                	xor    %eax,%eax
++    179e:	eb 20                	jmp    17c0 <malloc+0xb0>
++    if(p->s.size >= nunits){
++    17a0:	89 d0                	mov    %edx,%eax
++    17a2:	89 da                	mov    %ebx,%edx
++    17a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++      if(p->s.size == nunits)
++    17a8:	39 fe                	cmp    %edi,%esi
++    17aa:	74 1c                	je     17c8 <malloc+0xb8>
++        p->s.size -= nunits;
++    17ac:	29 f7                	sub    %esi,%edi
++    17ae:	89 78 04             	mov    %edi,0x4(%eax)
++        p += p->s.size;
++    17b1:	8d 04 f8             	lea    (%eax,%edi,8),%eax
++        p->s.size = nunits;
++    17b4:	89 70 04             	mov    %esi,0x4(%eax)
++      freep = prevp;
++    17b7:	89 15 48 1b 00 00    	mov    %edx,0x1b48
++      return (void*)(p + 1);
++    17bd:	83 c0 08             	add    $0x8,%eax
++  }
++}
++    17c0:	83 c4 1c             	add    $0x1c,%esp
++    17c3:	5b                   	pop    %ebx
++    17c4:	5e                   	pop    %esi
++    17c5:	5f                   	pop    %edi
++    17c6:	5d                   	pop    %ebp
++    17c7:	c3                   	ret    
++        prevp->s.ptr = p->s.ptr;
++    17c8:	8b 08                	mov    (%eax),%ecx
++    17ca:	89 0a                	mov    %ecx,(%edx)
++    17cc:	eb e9                	jmp    17b7 <malloc+0xa7>
++    base.s.ptr = freep = prevp = &base;
++    17ce:	c7 05 48 1b 00 00 4c 	movl   $0x1b4c,0x1b48
++    17d5:	1b 00 00 
++    base.s.size = 0;
++    17d8:	ba 4c 1b 00 00       	mov    $0x1b4c,%edx
++    base.s.ptr = freep = prevp = &base;
++    17dd:	c7 05 4c 1b 00 00 4c 	movl   $0x1b4c,0x1b4c
++    17e4:	1b 00 00 
++    base.s.size = 0;
++    17e7:	c7 05 50 1b 00 00 00 	movl   $0x0,0x1b50
++    17ee:	00 00 00 
++    17f1:	e9 46 ff ff ff       	jmp    173c <malloc+0x2c>
++    17f6:	66 90                	xchg   %ax,%ax
++    17f8:	66 90                	xchg   %ax,%ax
++    17fa:	66 90                	xchg   %ax,%ax
++    17fc:	66 90                	xchg   %ax,%ax
++    17fe:	66 90                	xchg   %ax,%ax
++
++00001800 <uacquire>:
++#include "uspinlock.h"
++#include "x86.h"
++
++void
++uacquire(struct uspinlock *lk)
++{
++    1800:	55                   	push   %ebp
++xchg(volatile uint *addr, uint newval)
++{
++  uint result;
++
++  // The + in "+m" denotes a read-modify-write operand.
++  asm volatile("lock; xchgl %0, %1" :
++    1801:	b9 01 00 00 00       	mov    $0x1,%ecx
++    1806:	89 e5                	mov    %esp,%ebp
++    1808:	8b 55 08             	mov    0x8(%ebp),%edx
++    180b:	90                   	nop
++    180c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    1810:	89 c8                	mov    %ecx,%eax
++    1812:	f0 87 02             	lock xchg %eax,(%edx)
++  // The xchg is atomic.
++  while(xchg(&lk->locked, 1) != 0)
++    1815:	85 c0                	test   %eax,%eax
++    1817:	75 f7                	jne    1810 <uacquire+0x10>
++    ;
++
++  // Tell the C compiler and the processor to not move loads or stores
++  // past this point, to ensure that the critical section's memory
++  // references happen after the lock is acquired.
++  __sync_synchronize();
++    1819:	0f ae f0             	mfence 
++}
++    181c:	5d                   	pop    %ebp
++    181d:	c3                   	ret    
++    181e:	66 90                	xchg   %ax,%ax
++
++00001820 <urelease>:
++
++void urelease (struct uspinlock *lk) {
++    1820:	55                   	push   %ebp
++    1821:	89 e5                	mov    %esp,%ebp
++    1823:	8b 45 08             	mov    0x8(%ebp),%eax
++  __sync_synchronize();
++    1826:	0f ae f0             	mfence 
++
++  // Release the lock, equivalent to lk->locked = 0.
++  // This code can't use a C assignment, since it might
++  // not be atomic. A real OS would use C atomics here.
++  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
++    1829:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
++}
++    182f:	5d                   	pop    %ebp
++    1830:	c3                   	ret    
+diff --git a/init.c b/init.c
+index bc6547f..046b551 100644
+--- a/init.c
++++ b/init.c
+@@ -24,14 +24,14 @@ main(void)
+     pid = fork();
+     if(pid < 0){
+       printf(1, "init: fork failed\n");
+-      exit(2);
++      exit();
+     }
+     if(pid == 0){
+       exec("sh", argv);
+       printf(1, "init: exec sh failed\n");
+-      exit(1);
++      exit();
+     }
+-    while((wpid=wait(NULL)) >= 0 && wpid != pid)
++    while((wpid=wait()) >= 0 && wpid != pid)
+       printf(1, "zombie!\n");
+   }
+ }
+diff --git a/init.d b/init.d
+new file mode 100644
+index 0000000..ee304c8
+--- /dev/null
++++ b/init.d
+@@ -0,0 +1 @@
++init.o: init.c /usr/include/stdc-predef.h types.h stat.h user.h fcntl.h
+diff --git a/init.o b/init.o
+new file mode 100644
+index 0000000..8944bcf
+Binary files /dev/null and b/init.o differ
+diff --git a/init.sym b/init.sym
+new file mode 100644
+index 0000000..13cf85e
+--- /dev/null
++++ b/init.sym
+@@ -0,0 +1,64 @@
++00001000 .text
++00001831 .rodata
++0000189c .eh_frame
++00001b40 .data
++00001b48 .bss
++00000000 .comment
++00000000 .debug_aranges
++00000000 .debug_info
++00000000 .debug_abbrev
++00000000 .debug_line
++00000000 .debug_str
++00000000 .debug_loc
++00000000 .debug_ranges
++00000000 init.c
++00000000 ulib.c
++00000000 printf.c
++000013f0 printint
++00001888 digits.1359
++00000000 umalloc.c
++00001b48 freep
++00001b4c base
++00000000 uspinlock.c
++00001110 strcpy
++00001490 printf
++00001b40 argv
++00001300 memmove
++0000137a mknod
++000013d2 shm_open
++00001220 gets
++000013b2 getpid
++00001710 malloc
++000013c2 sleep
++00001342 pipe
++00001352 write
++0000138a fstat
++00001362 kill
++000013a2 chdir
++0000136a exec
++0000133a wait
++0000134a read
++00001382 unlink
++00001800 uacquire
++0000132a fork
++000013ba sbrk
++000013da shm_close
++000013ca uptime
++00001b48 __bss_start
++000011c0 memset
++00001000 main
++00001140 strcmp
++000013aa dup
++00001280 stat
++00001b48 _edata
++00001b54 _end
++00001392 link
++00001332 exit
++000012d0 atoi
++00001190 strlen
++00001372 open
++000011e0 strchr
++0000139a mkdir
++0000135a close
++00001820 urelease
++00001680 free
+diff --git a/initcode b/initcode
+new file mode 100644
+index 0000000..773d26c
+Binary files /dev/null and b/initcode differ
+diff --git a/initcode.asm b/initcode.asm
+new file mode 100644
+index 0000000..3d5dae2
+--- /dev/null
++++ b/initcode.asm
+@@ -0,0 +1,43 @@
++
++initcode.o:     file format elf32-i386
++
++
++Disassembly of section .text:
++
++00000000 <start>:
++
++
++# exec(init, argv)
++.globl start
++start:
++  pushl $argv
++   0:	68 24 00 00 00       	push   $0x24
++  pushl $init
++   5:	68 1c 00 00 00       	push   $0x1c
++  pushl $0  // where caller pc would be
++   a:	6a 00                	push   $0x0
++  movl $SYS_exec, %eax
++   c:	b8 07 00 00 00       	mov    $0x7,%eax
++  int $T_SYSCALL
++  11:	cd 40                	int    $0x40
++
++00000013 <exit>:
++
++# for(;;) exit();
++exit:
++  movl $SYS_exit, %eax
++  13:	b8 02 00 00 00       	mov    $0x2,%eax
++  int $T_SYSCALL
++  18:	cd 40                	int    $0x40
++  jmp exit
++  1a:	eb f7                	jmp    13 <exit>
++
++0000001c <init>:
++  1c:	2f                   	das    
++  1d:	69 6e 69 74 00 00 90 	imul   $0x90000074,0x69(%esi),%ebp
++
++00000024 <argv>:
++  24:	1c 00                	sbb    $0x0,%al
++  26:	00 00                	add    %al,(%eax)
++  28:	00 00                	add    %al,(%eax)
++	...
+diff --git a/initcode.d b/initcode.d
+new file mode 100644
+index 0000000..ab1af4d
+--- /dev/null
++++ b/initcode.d
+@@ -0,0 +1 @@
++initcode.o: initcode.S syscall.h traps.h
+diff --git a/initcode.o b/initcode.o
+new file mode 100644
+index 0000000..9105df8
+Binary files /dev/null and b/initcode.o differ
+diff --git a/initcode.out b/initcode.out
+new file mode 100644
+index 0000000..90fead8
+Binary files /dev/null and b/initcode.out differ
+diff --git a/ioapic.d b/ioapic.d
+new file mode 100644
+index 0000000..997e68a
+--- /dev/null
++++ b/ioapic.d
+@@ -0,0 +1 @@
++ioapic.o: ioapic.c /usr/include/stdc-predef.h types.h defs.h traps.h
+diff --git a/ioapic.o b/ioapic.o
+new file mode 100644
+index 0000000..06b0b45
+Binary files /dev/null and b/ioapic.o differ
+diff --git a/kalloc.d b/kalloc.d
+new file mode 100644
+index 0000000..512c5db
+--- /dev/null
++++ b/kalloc.d
+@@ -0,0 +1,2 @@
++kalloc.o: kalloc.c /usr/include/stdc-predef.h types.h defs.h param.h \
++ memlayout.h mmu.h spinlock.h
+diff --git a/kalloc.o b/kalloc.o
+new file mode 100644
+index 0000000..020978a
+Binary files /dev/null and b/kalloc.o differ
+diff --git a/kbd.d b/kbd.d
+new file mode 100644
+index 0000000..92532ba
+--- /dev/null
++++ b/kbd.d
+@@ -0,0 +1 @@
++kbd.o: kbd.c /usr/include/stdc-predef.h types.h x86.h defs.h kbd.h
+diff --git a/kbd.o b/kbd.o
+new file mode 100644
+index 0000000..4be9216
+Binary files /dev/null and b/kbd.o differ
+diff --git a/kernel b/kernel
+new file mode 100644
+index 0000000..2eb8aad
+Binary files /dev/null and b/kernel differ
+diff --git a/kernel.asm b/kernel.asm
+new file mode 100644
+index 0000000..16ad337
+--- /dev/null
++++ b/kernel.asm
+@@ -0,0 +1,14907 @@
++
++kernel:     file format elf32-i386
++
++
++Disassembly of section .text:
++
++80100000 <multiboot_header>:
++80100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
++80100006:	00 00                	add    %al,(%eax)
++80100008:	fe 4f 52             	decb   0x52(%edi)
++8010000b:	e4                   	.byte 0xe4
++
++8010000c <entry>:
++
++# Entering xv6 on boot processor, with paging off.
++.globl entry
++entry:
++  # Turn on page size extension for 4Mbyte pages
++  movl    %cr4, %eax
++8010000c:	0f 20 e0             	mov    %cr4,%eax
++  orl     $(CR4_PSE), %eax
++8010000f:	83 c8 10             	or     $0x10,%eax
++  movl    %eax, %cr4
++80100012:	0f 22 e0             	mov    %eax,%cr4
++  # Set page directory
++  movl    $(V2P_WO(entrypgdir)), %eax
++80100015:	b8 00 90 10 00       	mov    $0x109000,%eax
++  movl    %eax, %cr3
++8010001a:	0f 22 d8             	mov    %eax,%cr3
++  # Turn on paging.
++  movl    %cr0, %eax
++8010001d:	0f 20 c0             	mov    %cr0,%eax
++  orl     $(CR0_PG|CR0_WP), %eax
++80100020:	0d 00 00 01 80       	or     $0x80010000,%eax
++  movl    %eax, %cr0
++80100025:	0f 22 c0             	mov    %eax,%cr0
++
++  # Set up the stack pointer.
++  movl $(stack + KSTACKSIZE), %esp
++80100028:	bc c0 b5 10 80       	mov    $0x8010b5c0,%esp
++
++  # Jump to main(), and switch to executing at
++  # high addresses. The indirect call is needed because
++  # the assembler produces a PC-relative instruction
++  # for a direct jump.
++  mov $main, %eax
++8010002d:	b8 00 2e 10 80       	mov    $0x80102e00,%eax
++  jmp *%eax
++80100032:	ff e0                	jmp    *%eax
++80100034:	66 90                	xchg   %ax,%ax
++80100036:	66 90                	xchg   %ax,%ax
++80100038:	66 90                	xchg   %ax,%ax
++8010003a:	66 90                	xchg   %ax,%ax
++8010003c:	66 90                	xchg   %ax,%ax
++8010003e:	66 90                	xchg   %ax,%ax
++
++80100040 <binit>:
++  struct buf head;
++} bcache;
++
++void
++binit(void)
++{
++80100040:	55                   	push   %ebp
++80100041:	89 e5                	mov    %esp,%ebp
++80100043:	53                   	push   %ebx
++
++//PAGEBREAK!
++  // Create linked list of buffers
++  bcache.head.prev = &bcache.head;
++  bcache.head.next = &bcache.head;
++  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
++80100044:	bb f4 b5 10 80       	mov    $0x8010b5f4,%ebx
++{
++80100049:	83 ec 14             	sub    $0x14,%esp
++  initlock(&bcache.lock, "bcache");
++8010004c:	c7 44 24 04 20 6d 10 	movl   $0x80106d20,0x4(%esp)
++80100053:	80 
++80100054:	c7 04 24 c0 b5 10 80 	movl   $0x8010b5c0,(%esp)
++8010005b:	e8 00 40 00 00       	call   80104060 <initlock>
++  bcache.head.next = &bcache.head;
++80100060:	ba bc fc 10 80       	mov    $0x8010fcbc,%edx
++  bcache.head.prev = &bcache.head;
++80100065:	c7 05 0c fd 10 80 bc 	movl   $0x8010fcbc,0x8010fd0c
++8010006c:	fc 10 80 
++  bcache.head.next = &bcache.head;
++8010006f:	c7 05 10 fd 10 80 bc 	movl   $0x8010fcbc,0x8010fd10
++80100076:	fc 10 80 
++80100079:	eb 09                	jmp    80100084 <binit+0x44>
++8010007b:	90                   	nop
++8010007c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++80100080:	89 da                	mov    %ebx,%edx
++  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
++80100082:	89 c3                	mov    %eax,%ebx
++80100084:	8d 43 0c             	lea    0xc(%ebx),%eax
++    b->next = bcache.head.next;
++80100087:	89 53 54             	mov    %edx,0x54(%ebx)
++    b->prev = &bcache.head;
++8010008a:	c7 43 50 bc fc 10 80 	movl   $0x8010fcbc,0x50(%ebx)
++    initsleeplock(&b->lock, "buffer");
++80100091:	89 04 24             	mov    %eax,(%esp)
++80100094:	c7 44 24 04 27 6d 10 	movl   $0x80106d27,0x4(%esp)
++8010009b:	80 
++8010009c:	e8 af 3e 00 00       	call   80103f50 <initsleeplock>
++    bcache.head.next->prev = b;
++801000a1:	a1 10 fd 10 80       	mov    0x8010fd10,%eax
++801000a6:	89 58 50             	mov    %ebx,0x50(%eax)
++  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
++801000a9:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
++801000af:	3d bc fc 10 80       	cmp    $0x8010fcbc,%eax
++    bcache.head.next = b;
++801000b4:	89 1d 10 fd 10 80    	mov    %ebx,0x8010fd10
++  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
++801000ba:	75 c4                	jne    80100080 <binit+0x40>
++  }
++}
++801000bc:	83 c4 14             	add    $0x14,%esp
++801000bf:	5b                   	pop    %ebx
++801000c0:	5d                   	pop    %ebp
++801000c1:	c3                   	ret    
++801000c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++801000c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++801000d0 <bread>:
++}
++
++// Return a locked buf with the contents of the indicated block.
++struct buf*
++bread(uint dev, uint blockno)
++{
++801000d0:	55                   	push   %ebp
++801000d1:	89 e5                	mov    %esp,%ebp
++801000d3:	57                   	push   %edi
++801000d4:	56                   	push   %esi
++801000d5:	53                   	push   %ebx
++801000d6:	83 ec 1c             	sub    $0x1c,%esp
++801000d9:	8b 75 08             	mov    0x8(%ebp),%esi
++  acquire(&bcache.lock);
++801000dc:	c7 04 24 c0 b5 10 80 	movl   $0x8010b5c0,(%esp)
++{
++801000e3:	8b 7d 0c             	mov    0xc(%ebp),%edi
++  acquire(&bcache.lock);
++801000e6:	e8 65 40 00 00       	call   80104150 <acquire>
++  for(b = bcache.head.next; b != &bcache.head; b = b->next){
++801000eb:	8b 1d 10 fd 10 80    	mov    0x8010fd10,%ebx
++801000f1:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
++801000f7:	75 12                	jne    8010010b <bread+0x3b>
++801000f9:	eb 25                	jmp    80100120 <bread+0x50>
++801000fb:	90                   	nop
++801000fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++80100100:	8b 5b 54             	mov    0x54(%ebx),%ebx
++80100103:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
++80100109:	74 15                	je     80100120 <bread+0x50>
++    if(b->dev == dev && b->blockno == blockno){
++8010010b:	3b 73 04             	cmp    0x4(%ebx),%esi
++8010010e:	75 f0                	jne    80100100 <bread+0x30>
++80100110:	3b 7b 08             	cmp    0x8(%ebx),%edi
++80100113:	75 eb                	jne    80100100 <bread+0x30>
++      b->refcnt++;
++80100115:	83 43 4c 01          	addl   $0x1,0x4c(%ebx)
++80100119:	eb 3f                	jmp    8010015a <bread+0x8a>
++8010011b:	90                   	nop
++8010011c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
++80100120:	8b 1d 0c fd 10 80    	mov    0x8010fd0c,%ebx
++80100126:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
++8010012c:	75 0d                	jne    8010013b <bread+0x6b>
++8010012e:	eb 58                	jmp    80100188 <bread+0xb8>
++80100130:	8b 5b 50             	mov    0x50(%ebx),%ebx
++80100133:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
++80100139:	74 4d                	je     80100188 <bread+0xb8>
++    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
++8010013b:	8b 43 4c             	mov    0x4c(%ebx),%eax
++8010013e:	85 c0                	test   %eax,%eax
++80100140:	75 ee                	jne    80100130 <bread+0x60>
++80100142:	f6 03 04             	testb  $0x4,(%ebx)
++80100145:	75 e9                	jne    80100130 <bread+0x60>
++      b->dev = dev;
++80100147:	89 73 04             	mov    %esi,0x4(%ebx)
++      b->blockno = blockno;
++8010014a:	89 7b 08             	mov    %edi,0x8(%ebx)
++      b->flags = 0;
++8010014d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
++      b->refcnt = 1;
++80100153:	c7 43 4c 01 00 00 00 	movl   $0x1,0x4c(%ebx)
++      release(&bcache.lock);
++8010015a:	c7 04 24 c0 b5 10 80 	movl   $0x8010b5c0,(%esp)
++80100161:	e8 da 40 00 00       	call   80104240 <release>
++      acquiresleep(&b->lock);
++80100166:	8d 43 0c             	lea    0xc(%ebx),%eax
++80100169:	89 04 24             	mov    %eax,(%esp)
++8010016c:	e8 1f 3e 00 00       	call   80103f90 <acquiresleep>
++  struct buf *b;
++
++  b = bget(dev, blockno);
++  if((b->flags & B_VALID) == 0) {
++80100171:	f6 03 02             	testb  $0x2,(%ebx)
++80100174:	75 08                	jne    8010017e <bread+0xae>
++    iderw(b);
++80100176:	89 1c 24             	mov    %ebx,(%esp)
++80100179:	e8 b2 1f 00 00       	call   80102130 <iderw>
++  }
++  return b;
++}
++8010017e:	83 c4 1c             	add    $0x1c,%esp
++80100181:	89 d8                	mov    %ebx,%eax
++80100183:	5b                   	pop    %ebx
++80100184:	5e                   	pop    %esi
++80100185:	5f                   	pop    %edi
++80100186:	5d                   	pop    %ebp
++80100187:	c3                   	ret    
++  panic("bget: no buffers");
++80100188:	c7 04 24 2e 6d 10 80 	movl   $0x80106d2e,(%esp)
++8010018f:	e8 cc 01 00 00       	call   80100360 <panic>
++80100194:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++8010019a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
++
++801001a0 <bwrite>:
++
++// Write b's contents to disk.  Must be locked.
++void
++bwrite(struct buf *b)
++{
++801001a0:	55                   	push   %ebp
++801001a1:	89 e5                	mov    %esp,%ebp
++801001a3:	53                   	push   %ebx
++801001a4:	83 ec 14             	sub    $0x14,%esp
++801001a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
++  if(!holdingsleep(&b->lock))
++801001aa:	8d 43 0c             	lea    0xc(%ebx),%eax
++801001ad:	89 04 24             	mov    %eax,(%esp)
++801001b0:	e8 7b 3e 00 00       	call   80104030 <holdingsleep>
++801001b5:	85 c0                	test   %eax,%eax
++801001b7:	74 10                	je     801001c9 <bwrite+0x29>
++    panic("bwrite");
++  b->flags |= B_DIRTY;
++801001b9:	83 0b 04             	orl    $0x4,(%ebx)
++  iderw(b);
++801001bc:	89 5d 08             	mov    %ebx,0x8(%ebp)
++}
++801001bf:	83 c4 14             	add    $0x14,%esp
++801001c2:	5b                   	pop    %ebx
++801001c3:	5d                   	pop    %ebp
++  iderw(b);
++801001c4:	e9 67 1f 00 00       	jmp    80102130 <iderw>
++    panic("bwrite");
++801001c9:	c7 04 24 3f 6d 10 80 	movl   $0x80106d3f,(%esp)
++801001d0:	e8 8b 01 00 00       	call   80100360 <panic>
++801001d5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++801001d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++801001e0 <brelse>:
++
++// Release a locked buffer.
++// Move to the head of the MRU list.
++void
++brelse(struct buf *b)
++{
++801001e0:	55                   	push   %ebp
++801001e1:	89 e5                	mov    %esp,%ebp
++801001e3:	56                   	push   %esi
++801001e4:	53                   	push   %ebx
++801001e5:	83 ec 10             	sub    $0x10,%esp
++801001e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
++  if(!holdingsleep(&b->lock))
++801001eb:	8d 73 0c             	lea    0xc(%ebx),%esi
++801001ee:	89 34 24             	mov    %esi,(%esp)
++801001f1:	e8 3a 3e 00 00       	call   80104030 <holdingsleep>
++801001f6:	85 c0                	test   %eax,%eax
++801001f8:	74 5b                	je     80100255 <brelse+0x75>
++    panic("brelse");
++
++  releasesleep(&b->lock);
++801001fa:	89 34 24             	mov    %esi,(%esp)
++801001fd:	e8 ee 3d 00 00       	call   80103ff0 <releasesleep>
++
++  acquire(&bcache.lock);
++80100202:	c7 04 24 c0 b5 10 80 	movl   $0x8010b5c0,(%esp)
++80100209:	e8 42 3f 00 00       	call   80104150 <acquire>
++  b->refcnt--;
++  if (b->refcnt == 0) {
++8010020e:	83 6b 4c 01          	subl   $0x1,0x4c(%ebx)
++80100212:	75 2f                	jne    80100243 <brelse+0x63>
++    // no one is waiting for it.
++    b->next->prev = b->prev;
++80100214:	8b 43 54             	mov    0x54(%ebx),%eax
++80100217:	8b 53 50             	mov    0x50(%ebx),%edx
++8010021a:	89 50 50             	mov    %edx,0x50(%eax)
++    b->prev->next = b->next;
++8010021d:	8b 43 50             	mov    0x50(%ebx),%eax
++80100220:	8b 53 54             	mov    0x54(%ebx),%edx
++80100223:	89 50 54             	mov    %edx,0x54(%eax)
++    b->next = bcache.head.next;
++80100226:	a1 10 fd 10 80       	mov    0x8010fd10,%eax
++    b->prev = &bcache.head;
++8010022b:	c7 43 50 bc fc 10 80 	movl   $0x8010fcbc,0x50(%ebx)
++    b->next = bcache.head.next;
++80100232:	89 43 54             	mov    %eax,0x54(%ebx)
++    bcache.head.next->prev = b;
++80100235:	a1 10 fd 10 80       	mov    0x8010fd10,%eax
++8010023a:	89 58 50             	mov    %ebx,0x50(%eax)
++    bcache.head.next = b;
++8010023d:	89 1d 10 fd 10 80    	mov    %ebx,0x8010fd10
++  }
++  
++  release(&bcache.lock);
++80100243:	c7 45 08 c0 b5 10 80 	movl   $0x8010b5c0,0x8(%ebp)
++}
++8010024a:	83 c4 10             	add    $0x10,%esp
++8010024d:	5b                   	pop    %ebx
++8010024e:	5e                   	pop    %esi
++8010024f:	5d                   	pop    %ebp
++  release(&bcache.lock);
++80100250:	e9 eb 3f 00 00       	jmp    80104240 <release>
++    panic("brelse");
++80100255:	c7 04 24 46 6d 10 80 	movl   $0x80106d46,(%esp)
++8010025c:	e8 ff 00 00 00       	call   80100360 <panic>
++80100261:	66 90                	xchg   %ax,%ax
++80100263:	66 90                	xchg   %ax,%ax
++80100265:	66 90                	xchg   %ax,%ax
++80100267:	66 90                	xchg   %ax,%ax
++80100269:	66 90                	xchg   %ax,%ax
++8010026b:	66 90                	xchg   %ax,%ax
++8010026d:	66 90                	xchg   %ax,%ax
++8010026f:	90                   	nop
++
++80100270 <consoleread>:
++  }
++}
++
++int
++consoleread(struct inode *ip, char *dst, int n)
++{
++80100270:	55                   	push   %ebp
++80100271:	89 e5                	mov    %esp,%ebp
++80100273:	57                   	push   %edi
++80100274:	56                   	push   %esi
++80100275:	53                   	push   %ebx
++80100276:	83 ec 1c             	sub    $0x1c,%esp
++80100279:	8b 7d 08             	mov    0x8(%ebp),%edi
++8010027c:	8b 75 0c             	mov    0xc(%ebp),%esi
++  uint target;
++  int c;
++
++  iunlock(ip);
++8010027f:	89 3c 24             	mov    %edi,(%esp)
++80100282:	e8 19 15 00 00       	call   801017a0 <iunlock>
++  target = n;
++  acquire(&cons.lock);
++80100287:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
++8010028e:	e8 bd 3e 00 00       	call   80104150 <acquire>
++  while(n > 0){
++80100293:	8b 55 10             	mov    0x10(%ebp),%edx
++80100296:	85 d2                	test   %edx,%edx
++80100298:	0f 8e bc 00 00 00    	jle    8010035a <consoleread+0xea>
++8010029e:	8b 5d 10             	mov    0x10(%ebp),%ebx
++801002a1:	eb 25                	jmp    801002c8 <consoleread+0x58>
++801002a3:	90                   	nop
++801002a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    while(input.r == input.w){
++      if(myproc()->killed){
++801002a8:	e8 03 34 00 00       	call   801036b0 <myproc>
++801002ad:	8b 40 24             	mov    0x24(%eax),%eax
++801002b0:	85 c0                	test   %eax,%eax
++801002b2:	75 74                	jne    80100328 <consoleread+0xb8>
++        release(&cons.lock);
++        ilock(ip);
++        return -1;
++      }
++      sleep(&input.r, &cons.lock);
++801002b4:	c7 44 24 04 20 a5 10 	movl   $0x8010a520,0x4(%esp)
++801002bb:	80 
++801002bc:	c7 04 24 a0 ff 10 80 	movl   $0x8010ffa0,(%esp)
++801002c3:	e8 48 39 00 00       	call   80103c10 <sleep>
++    while(input.r == input.w){
++801002c8:	a1 a0 ff 10 80       	mov    0x8010ffa0,%eax
++801002cd:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
++801002d3:	74 d3                	je     801002a8 <consoleread+0x38>
++    }
++    c = input.buf[input.r++ % INPUT_BUF];
++801002d5:	8d 50 01             	lea    0x1(%eax),%edx
++801002d8:	89 15 a0 ff 10 80    	mov    %edx,0x8010ffa0
++801002de:	89 c2                	mov    %eax,%edx
++801002e0:	83 e2 7f             	and    $0x7f,%edx
++801002e3:	0f b6 8a 20 ff 10 80 	movzbl -0x7fef00e0(%edx),%ecx
++801002ea:	0f be d1             	movsbl %cl,%edx
++    if(c == C('D')){  // EOF
++801002ed:	83 fa 04             	cmp    $0x4,%edx
++801002f0:	74 57                	je     80100349 <consoleread+0xd9>
++        // caller gets a 0-byte result.
++        input.r--;
++      }
++      break;
++    }
++    *dst++ = c;
++801002f2:	83 c6 01             	add    $0x1,%esi
++    --n;
++801002f5:	83 eb 01             	sub    $0x1,%ebx
++    if(c == '\n')
++801002f8:	83 fa 0a             	cmp    $0xa,%edx
++    *dst++ = c;
++801002fb:	88 4e ff             	mov    %cl,-0x1(%esi)
++    if(c == '\n')
++801002fe:	74 53                	je     80100353 <consoleread+0xe3>
++  while(n > 0){
++80100300:	85 db                	test   %ebx,%ebx
++80100302:	75 c4                	jne    801002c8 <consoleread+0x58>
++80100304:	8b 45 10             	mov    0x10(%ebp),%eax
++      break;
++  }
++  release(&cons.lock);
++80100307:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
++8010030e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++80100311:	e8 2a 3f 00 00       	call   80104240 <release>
++  ilock(ip);
++80100316:	89 3c 24             	mov    %edi,(%esp)
++80100319:	e8 a2 13 00 00       	call   801016c0 <ilock>
++8010031e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
++
++  return target - n;
++80100321:	eb 1e                	jmp    80100341 <consoleread+0xd1>
++80100323:	90                   	nop
++80100324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++        release(&cons.lock);
++80100328:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
++8010032f:	e8 0c 3f 00 00       	call   80104240 <release>
++        ilock(ip);
++80100334:	89 3c 24             	mov    %edi,(%esp)
++80100337:	e8 84 13 00 00       	call   801016c0 <ilock>
++        return -1;
++8010033c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++}
++80100341:	83 c4 1c             	add    $0x1c,%esp
++80100344:	5b                   	pop    %ebx
++80100345:	5e                   	pop    %esi
++80100346:	5f                   	pop    %edi
++80100347:	5d                   	pop    %ebp
++80100348:	c3                   	ret    
++      if(n < target){
++80100349:	39 5d 10             	cmp    %ebx,0x10(%ebp)
++8010034c:	76 05                	jbe    80100353 <consoleread+0xe3>
++        input.r--;
++8010034e:	a3 a0 ff 10 80       	mov    %eax,0x8010ffa0
++80100353:	8b 45 10             	mov    0x10(%ebp),%eax
++80100356:	29 d8                	sub    %ebx,%eax
++80100358:	eb ad                	jmp    80100307 <consoleread+0x97>
++  while(n > 0){
++8010035a:	31 c0                	xor    %eax,%eax
++8010035c:	eb a9                	jmp    80100307 <consoleread+0x97>
++8010035e:	66 90                	xchg   %ax,%ax
++
++80100360 <panic>:
++{
++80100360:	55                   	push   %ebp
++80100361:	89 e5                	mov    %esp,%ebp
++80100363:	56                   	push   %esi
++80100364:	53                   	push   %ebx
++80100365:	83 ec 40             	sub    $0x40,%esp
++}
++
++static inline void
++cli(void)
++{
++  asm volatile("cli");
++80100368:	fa                   	cli    
++  cons.locking = 0;
++80100369:	c7 05 54 a5 10 80 00 	movl   $0x0,0x8010a554
++80100370:	00 00 00 
++  getcallerpcs(&s, pcs);
++80100373:	8d 5d d0             	lea    -0x30(%ebp),%ebx
++  cprintf("lapicid %d: panic: ", lapicid());
++80100376:	e8 f5 23 00 00       	call   80102770 <lapicid>
++8010037b:	8d 75 f8             	lea    -0x8(%ebp),%esi
++8010037e:	c7 04 24 4d 6d 10 80 	movl   $0x80106d4d,(%esp)
++80100385:	89 44 24 04          	mov    %eax,0x4(%esp)
++80100389:	e8 c2 02 00 00       	call   80100650 <cprintf>
++  cprintf(s);
++8010038e:	8b 45 08             	mov    0x8(%ebp),%eax
++80100391:	89 04 24             	mov    %eax,(%esp)
++80100394:	e8 b7 02 00 00       	call   80100650 <cprintf>
++  cprintf("\n");
++80100399:	c7 04 24 9f 76 10 80 	movl   $0x8010769f,(%esp)
++801003a0:	e8 ab 02 00 00       	call   80100650 <cprintf>
++  getcallerpcs(&s, pcs);
++801003a5:	8d 45 08             	lea    0x8(%ebp),%eax
++801003a8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++801003ac:	89 04 24             	mov    %eax,(%esp)
++801003af:	e8 cc 3c 00 00       	call   80104080 <getcallerpcs>
++801003b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    cprintf(" %p", pcs[i]);
++801003b8:	8b 03                	mov    (%ebx),%eax
++801003ba:	83 c3 04             	add    $0x4,%ebx
++801003bd:	c7 04 24 61 6d 10 80 	movl   $0x80106d61,(%esp)
++801003c4:	89 44 24 04          	mov    %eax,0x4(%esp)
++801003c8:	e8 83 02 00 00       	call   80100650 <cprintf>
++  for(i=0; i<10; i++)
++801003cd:	39 f3                	cmp    %esi,%ebx
++801003cf:	75 e7                	jne    801003b8 <panic+0x58>
++  panicked = 1; // freeze other CPU
++801003d1:	c7 05 58 a5 10 80 01 	movl   $0x1,0x8010a558
++801003d8:	00 00 00 
++801003db:	eb fe                	jmp    801003db <panic+0x7b>
++801003dd:	8d 76 00             	lea    0x0(%esi),%esi
++
++801003e0 <consputc>:
++  if(panicked){
++801003e0:	8b 15 58 a5 10 80    	mov    0x8010a558,%edx
++801003e6:	85 d2                	test   %edx,%edx
++801003e8:	74 06                	je     801003f0 <consputc+0x10>
++801003ea:	fa                   	cli    
++801003eb:	eb fe                	jmp    801003eb <consputc+0xb>
++801003ed:	8d 76 00             	lea    0x0(%esi),%esi
++{
++801003f0:	55                   	push   %ebp
++801003f1:	89 e5                	mov    %esp,%ebp
++801003f3:	57                   	push   %edi
++801003f4:	56                   	push   %esi
++801003f5:	53                   	push   %ebx
++801003f6:	89 c3                	mov    %eax,%ebx
++801003f8:	83 ec 1c             	sub    $0x1c,%esp
++  if(c == BACKSPACE){
++801003fb:	3d 00 01 00 00       	cmp    $0x100,%eax
++80100400:	0f 84 ac 00 00 00    	je     801004b2 <consputc+0xd2>
++    uartputc(c);
++80100406:	89 04 24             	mov    %eax,(%esp)
++80100409:	e8 d2 53 00 00       	call   801057e0 <uartputc>
++  asm volatile("out %0,%1" : : "a" (data), "d" (port));
++8010040e:	bf d4 03 00 00       	mov    $0x3d4,%edi
++80100413:	b8 0e 00 00 00       	mov    $0xe,%eax
++80100418:	89 fa                	mov    %edi,%edx
++8010041a:	ee                   	out    %al,(%dx)
++  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
++8010041b:	be d5 03 00 00       	mov    $0x3d5,%esi
++80100420:	89 f2                	mov    %esi,%edx
++80100422:	ec                   	in     (%dx),%al
++  pos = inb(CRTPORT+1) << 8;
++80100423:	0f b6 c8             	movzbl %al,%ecx
++  asm volatile("out %0,%1" : : "a" (data), "d" (port));
++80100426:	89 fa                	mov    %edi,%edx
++80100428:	c1 e1 08             	shl    $0x8,%ecx
++8010042b:	b8 0f 00 00 00       	mov    $0xf,%eax
++80100430:	ee                   	out    %al,(%dx)
++  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
++80100431:	89 f2                	mov    %esi,%edx
++80100433:	ec                   	in     (%dx),%al
++  pos |= inb(CRTPORT+1);
++80100434:	0f b6 c0             	movzbl %al,%eax
++80100437:	09 c1                	or     %eax,%ecx
++  if(c == '\n')
++80100439:	83 fb 0a             	cmp    $0xa,%ebx
++8010043c:	0f 84 0d 01 00 00    	je     8010054f <consputc+0x16f>
++  else if(c == BACKSPACE){
++80100442:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
++80100448:	0f 84 e8 00 00 00    	je     80100536 <consputc+0x156>
++    crt[pos++] = (c&0xff) | 0x0700;  // black on white
++8010044e:	0f b6 db             	movzbl %bl,%ebx
++80100451:	80 cf 07             	or     $0x7,%bh
++80100454:	8d 79 01             	lea    0x1(%ecx),%edi
++80100457:	66 89 9c 09 00 80 0b 	mov    %bx,-0x7ff48000(%ecx,%ecx,1)
++8010045e:	80 
++  if(pos < 0 || pos > 25*80)
++8010045f:	81 ff d0 07 00 00    	cmp    $0x7d0,%edi
++80100465:	0f 87 bf 00 00 00    	ja     8010052a <consputc+0x14a>
++  if((pos/80) >= 24){  // Scroll up.
++8010046b:	81 ff 7f 07 00 00    	cmp    $0x77f,%edi
++80100471:	7f 68                	jg     801004db <consputc+0xfb>
++80100473:	89 f8                	mov    %edi,%eax
++80100475:	89 fb                	mov    %edi,%ebx
++80100477:	c1 e8 08             	shr    $0x8,%eax
++8010047a:	89 c6                	mov    %eax,%esi
++8010047c:	8d 8c 3f 00 80 0b 80 	lea    -0x7ff48000(%edi,%edi,1),%ecx
++  asm volatile("out %0,%1" : : "a" (data), "d" (port));
++80100483:	bf d4 03 00 00       	mov    $0x3d4,%edi
++80100488:	b8 0e 00 00 00       	mov    $0xe,%eax
++8010048d:	89 fa                	mov    %edi,%edx
++8010048f:	ee                   	out    %al,(%dx)
++80100490:	89 f0                	mov    %esi,%eax
++80100492:	b2 d5                	mov    $0xd5,%dl
++80100494:	ee                   	out    %al,(%dx)
++80100495:	b8 0f 00 00 00       	mov    $0xf,%eax
++8010049a:	89 fa                	mov    %edi,%edx
++8010049c:	ee                   	out    %al,(%dx)
++8010049d:	89 d8                	mov    %ebx,%eax
++8010049f:	b2 d5                	mov    $0xd5,%dl
++801004a1:	ee                   	out    %al,(%dx)
++  crt[pos] = ' ' | 0x0700;
++801004a2:	b8 20 07 00 00       	mov    $0x720,%eax
++801004a7:	66 89 01             	mov    %ax,(%ecx)
++}
++801004aa:	83 c4 1c             	add    $0x1c,%esp
++801004ad:	5b                   	pop    %ebx
++801004ae:	5e                   	pop    %esi
++801004af:	5f                   	pop    %edi
++801004b0:	5d                   	pop    %ebp
++801004b1:	c3                   	ret    
++    uartputc('\b'); uartputc(' '); uartputc('\b');
++801004b2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
++801004b9:	e8 22 53 00 00       	call   801057e0 <uartputc>
++801004be:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
++801004c5:	e8 16 53 00 00       	call   801057e0 <uartputc>
++801004ca:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
++801004d1:	e8 0a 53 00 00       	call   801057e0 <uartputc>
++801004d6:	e9 33 ff ff ff       	jmp    8010040e <consputc+0x2e>
++    memmove(crt, crt+80, sizeof(crt[0])*23*80);
++801004db:	c7 44 24 08 60 0e 00 	movl   $0xe60,0x8(%esp)
++801004e2:	00 
++    pos -= 80;
++801004e3:	8d 5f b0             	lea    -0x50(%edi),%ebx
++    memmove(crt, crt+80, sizeof(crt[0])*23*80);
++801004e6:	c7 44 24 04 a0 80 0b 	movl   $0x800b80a0,0x4(%esp)
++801004ed:	80 
++    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
++801004ee:	8d b4 1b 00 80 0b 80 	lea    -0x7ff48000(%ebx,%ebx,1),%esi
++    memmove(crt, crt+80, sizeof(crt[0])*23*80);
++801004f5:	c7 04 24 00 80 0b 80 	movl   $0x800b8000,(%esp)
++801004fc:	e8 2f 3e 00 00       	call   80104330 <memmove>
++    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
++80100501:	b8 d0 07 00 00       	mov    $0x7d0,%eax
++80100506:	29 f8                	sub    %edi,%eax
++80100508:	01 c0                	add    %eax,%eax
++8010050a:	89 34 24             	mov    %esi,(%esp)
++8010050d:	89 44 24 08          	mov    %eax,0x8(%esp)
++80100511:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
++80100518:	00 
++80100519:	e8 72 3d 00 00       	call   80104290 <memset>
++8010051e:	89 f1                	mov    %esi,%ecx
++80100520:	be 07 00 00 00       	mov    $0x7,%esi
++80100525:	e9 59 ff ff ff       	jmp    80100483 <consputc+0xa3>
++    panic("pos under/overflow");
++8010052a:	c7 04 24 65 6d 10 80 	movl   $0x80106d65,(%esp)
++80100531:	e8 2a fe ff ff       	call   80100360 <panic>
++    if(pos > 0) --pos;
++80100536:	85 c9                	test   %ecx,%ecx
++80100538:	8d 79 ff             	lea    -0x1(%ecx),%edi
++8010053b:	0f 85 1e ff ff ff    	jne    8010045f <consputc+0x7f>
++80100541:	b9 00 80 0b 80       	mov    $0x800b8000,%ecx
++80100546:	31 db                	xor    %ebx,%ebx
++80100548:	31 f6                	xor    %esi,%esi
++8010054a:	e9 34 ff ff ff       	jmp    80100483 <consputc+0xa3>
++    pos += 80 - pos%80;
++8010054f:	89 c8                	mov    %ecx,%eax
++80100551:	ba 67 66 66 66       	mov    $0x66666667,%edx
++80100556:	f7 ea                	imul   %edx
++80100558:	c1 ea 05             	shr    $0x5,%edx
++8010055b:	8d 04 92             	lea    (%edx,%edx,4),%eax
++8010055e:	c1 e0 04             	shl    $0x4,%eax
++80100561:	8d 78 50             	lea    0x50(%eax),%edi
++80100564:	e9 f6 fe ff ff       	jmp    8010045f <consputc+0x7f>
++80100569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++
++80100570 <printint>:
++{
++80100570:	55                   	push   %ebp
++80100571:	89 e5                	mov    %esp,%ebp
++80100573:	57                   	push   %edi
++80100574:	56                   	push   %esi
++80100575:	89 d6                	mov    %edx,%esi
++80100577:	53                   	push   %ebx
++80100578:	83 ec 1c             	sub    $0x1c,%esp
++  if(sign && (sign = xx < 0))
++8010057b:	85 c9                	test   %ecx,%ecx
++8010057d:	74 61                	je     801005e0 <printint+0x70>
++8010057f:	85 c0                	test   %eax,%eax
++80100581:	79 5d                	jns    801005e0 <printint+0x70>
++    x = -xx;
++80100583:	f7 d8                	neg    %eax
++80100585:	bf 01 00 00 00       	mov    $0x1,%edi
++  i = 0;
++8010058a:	31 c9                	xor    %ecx,%ecx
++8010058c:	eb 04                	jmp    80100592 <printint+0x22>
++8010058e:	66 90                	xchg   %ax,%ax
++    buf[i++] = digits[x % base];
++80100590:	89 d9                	mov    %ebx,%ecx
++80100592:	31 d2                	xor    %edx,%edx
++80100594:	f7 f6                	div    %esi
++80100596:	8d 59 01             	lea    0x1(%ecx),%ebx
++80100599:	0f b6 92 90 6d 10 80 	movzbl -0x7fef9270(%edx),%edx
++  }while((x /= base) != 0);
++801005a0:	85 c0                	test   %eax,%eax
++    buf[i++] = digits[x % base];
++801005a2:	88 54 1d d7          	mov    %dl,-0x29(%ebp,%ebx,1)
++  }while((x /= base) != 0);
++801005a6:	75 e8                	jne    80100590 <printint+0x20>
++  if(sign)
++801005a8:	85 ff                	test   %edi,%edi
++    buf[i++] = digits[x % base];
++801005aa:	89 d8                	mov    %ebx,%eax
++  if(sign)
++801005ac:	74 08                	je     801005b6 <printint+0x46>
++    buf[i++] = '-';
++801005ae:	8d 59 02             	lea    0x2(%ecx),%ebx
++801005b1:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
++  while(--i >= 0)
++801005b6:	83 eb 01             	sub    $0x1,%ebx
++801005b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++    consputc(buf[i]);
++801005c0:	0f be 44 1d d8       	movsbl -0x28(%ebp,%ebx,1),%eax
++  while(--i >= 0)
++801005c5:	83 eb 01             	sub    $0x1,%ebx
++    consputc(buf[i]);
++801005c8:	e8 13 fe ff ff       	call   801003e0 <consputc>
++  while(--i >= 0)
++801005cd:	83 fb ff             	cmp    $0xffffffff,%ebx
++801005d0:	75 ee                	jne    801005c0 <printint+0x50>
++}
++801005d2:	83 c4 1c             	add    $0x1c,%esp
++801005d5:	5b                   	pop    %ebx
++801005d6:	5e                   	pop    %esi
++801005d7:	5f                   	pop    %edi
++801005d8:	5d                   	pop    %ebp
++801005d9:	c3                   	ret    
++801005da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    x = xx;
++801005e0:	31 ff                	xor    %edi,%edi
++801005e2:	eb a6                	jmp    8010058a <printint+0x1a>
++801005e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++801005ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
++
++801005f0 <consolewrite>:
++
++int
++consolewrite(struct inode *ip, char *buf, int n)
++{
++801005f0:	55                   	push   %ebp
++801005f1:	89 e5                	mov    %esp,%ebp
++801005f3:	57                   	push   %edi
++801005f4:	56                   	push   %esi
++801005f5:	53                   	push   %ebx
++801005f6:	83 ec 1c             	sub    $0x1c,%esp
++  int i;
++
++  iunlock(ip);
++801005f9:	8b 45 08             	mov    0x8(%ebp),%eax
++{
++801005fc:	8b 75 10             	mov    0x10(%ebp),%esi
++  iunlock(ip);
++801005ff:	89 04 24             	mov    %eax,(%esp)
++80100602:	e8 99 11 00 00       	call   801017a0 <iunlock>
++  acquire(&cons.lock);
++80100607:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
++8010060e:	e8 3d 3b 00 00       	call   80104150 <acquire>
++80100613:	8b 7d 0c             	mov    0xc(%ebp),%edi
++  for(i = 0; i < n; i++)
++80100616:	85 f6                	test   %esi,%esi
++80100618:	8d 1c 37             	lea    (%edi,%esi,1),%ebx
++8010061b:	7e 12                	jle    8010062f <consolewrite+0x3f>
++8010061d:	8d 76 00             	lea    0x0(%esi),%esi
++    consputc(buf[i] & 0xff);
++80100620:	0f b6 07             	movzbl (%edi),%eax
++80100623:	83 c7 01             	add    $0x1,%edi
++80100626:	e8 b5 fd ff ff       	call   801003e0 <consputc>
++  for(i = 0; i < n; i++)
++8010062b:	39 df                	cmp    %ebx,%edi
++8010062d:	75 f1                	jne    80100620 <consolewrite+0x30>
++  release(&cons.lock);
++8010062f:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
++80100636:	e8 05 3c 00 00       	call   80104240 <release>
++  ilock(ip);
++8010063b:	8b 45 08             	mov    0x8(%ebp),%eax
++8010063e:	89 04 24             	mov    %eax,(%esp)
++80100641:	e8 7a 10 00 00       	call   801016c0 <ilock>
++
++  return n;
++}
++80100646:	83 c4 1c             	add    $0x1c,%esp
++80100649:	89 f0                	mov    %esi,%eax
++8010064b:	5b                   	pop    %ebx
++8010064c:	5e                   	pop    %esi
++8010064d:	5f                   	pop    %edi
++8010064e:	5d                   	pop    %ebp
++8010064f:	c3                   	ret    
++
++80100650 <cprintf>:
++{
++80100650:	55                   	push   %ebp
++80100651:	89 e5                	mov    %esp,%ebp
++80100653:	57                   	push   %edi
++80100654:	56                   	push   %esi
++80100655:	53                   	push   %ebx
++80100656:	83 ec 1c             	sub    $0x1c,%esp
++  locking = cons.locking;
++80100659:	a1 54 a5 10 80       	mov    0x8010a554,%eax
++  if(locking)
++8010065e:	85 c0                	test   %eax,%eax
++  locking = cons.locking;
++80100660:	89 45 e0             	mov    %eax,-0x20(%ebp)
++  if(locking)
++80100663:	0f 85 27 01 00 00    	jne    80100790 <cprintf+0x140>
++  if (fmt == 0)
++80100669:	8b 45 08             	mov    0x8(%ebp),%eax
++8010066c:	85 c0                	test   %eax,%eax
++8010066e:	89 c1                	mov    %eax,%ecx
++80100670:	0f 84 2b 01 00 00    	je     801007a1 <cprintf+0x151>
++  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
++80100676:	0f b6 00             	movzbl (%eax),%eax
++80100679:	31 db                	xor    %ebx,%ebx
++8010067b:	89 cf                	mov    %ecx,%edi
++8010067d:	8d 75 0c             	lea    0xc(%ebp),%esi
++80100680:	85 c0                	test   %eax,%eax
++80100682:	75 4c                	jne    801006d0 <cprintf+0x80>
++80100684:	eb 5f                	jmp    801006e5 <cprintf+0x95>
++80100686:	66 90                	xchg   %ax,%ax
++    c = fmt[++i] & 0xff;
++80100688:	83 c3 01             	add    $0x1,%ebx
++8010068b:	0f b6 14 1f          	movzbl (%edi,%ebx,1),%edx
++    if(c == 0)
++8010068f:	85 d2                	test   %edx,%edx
++80100691:	74 52                	je     801006e5 <cprintf+0x95>
++    switch(c){
++80100693:	83 fa 70             	cmp    $0x70,%edx
++80100696:	74 72                	je     8010070a <cprintf+0xba>
++80100698:	7f 66                	jg     80100700 <cprintf+0xb0>
++8010069a:	83 fa 25             	cmp    $0x25,%edx
++8010069d:	8d 76 00             	lea    0x0(%esi),%esi
++801006a0:	0f 84 a2 00 00 00    	je     80100748 <cprintf+0xf8>
++801006a6:	83 fa 64             	cmp    $0x64,%edx
++801006a9:	75 7d                	jne    80100728 <cprintf+0xd8>
++      printint(*argp++, 10, 1);
++801006ab:	8d 46 04             	lea    0x4(%esi),%eax
++801006ae:	b9 01 00 00 00       	mov    $0x1,%ecx
++801006b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++801006b6:	8b 06                	mov    (%esi),%eax
++801006b8:	ba 0a 00 00 00       	mov    $0xa,%edx
++801006bd:	e8 ae fe ff ff       	call   80100570 <printint>
++801006c2:	8b 75 e4             	mov    -0x1c(%ebp),%esi
++  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
++801006c5:	83 c3 01             	add    $0x1,%ebx
++801006c8:	0f b6 04 1f          	movzbl (%edi,%ebx,1),%eax
++801006cc:	85 c0                	test   %eax,%eax
++801006ce:	74 15                	je     801006e5 <cprintf+0x95>
++    if(c != '%'){
++801006d0:	83 f8 25             	cmp    $0x25,%eax
++801006d3:	74 b3                	je     80100688 <cprintf+0x38>
++      consputc(c);
++801006d5:	e8 06 fd ff ff       	call   801003e0 <consputc>
++  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
++801006da:	83 c3 01             	add    $0x1,%ebx
++801006dd:	0f b6 04 1f          	movzbl (%edi,%ebx,1),%eax
++801006e1:	85 c0                	test   %eax,%eax
++801006e3:	75 eb                	jne    801006d0 <cprintf+0x80>
++  if(locking)
++801006e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
++801006e8:	85 c0                	test   %eax,%eax
++801006ea:	74 0c                	je     801006f8 <cprintf+0xa8>
++    release(&cons.lock);
++801006ec:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
++801006f3:	e8 48 3b 00 00       	call   80104240 <release>
++}
++801006f8:	83 c4 1c             	add    $0x1c,%esp
++801006fb:	5b                   	pop    %ebx
++801006fc:	5e                   	pop    %esi
++801006fd:	5f                   	pop    %edi
++801006fe:	5d                   	pop    %ebp
++801006ff:	c3                   	ret    
++    switch(c){
++80100700:	83 fa 73             	cmp    $0x73,%edx
++80100703:	74 53                	je     80100758 <cprintf+0x108>
++80100705:	83 fa 78             	cmp    $0x78,%edx
++80100708:	75 1e                	jne    80100728 <cprintf+0xd8>
++      printint(*argp++, 16, 0);
++8010070a:	8d 46 04             	lea    0x4(%esi),%eax
++8010070d:	31 c9                	xor    %ecx,%ecx
++8010070f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++80100712:	8b 06                	mov    (%esi),%eax
++80100714:	ba 10 00 00 00       	mov    $0x10,%edx
++80100719:	e8 52 fe ff ff       	call   80100570 <printint>
++8010071e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
++      break;
++80100721:	eb a2                	jmp    801006c5 <cprintf+0x75>
++80100723:	90                   	nop
++80100724:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++      consputc('%');
++80100728:	b8 25 00 00 00       	mov    $0x25,%eax
++8010072d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
++80100730:	e8 ab fc ff ff       	call   801003e0 <consputc>
++      consputc(c);
++80100735:	8b 55 e4             	mov    -0x1c(%ebp),%edx
++80100738:	89 d0                	mov    %edx,%eax
++8010073a:	e8 a1 fc ff ff       	call   801003e0 <consputc>
++8010073f:	eb 99                	jmp    801006da <cprintf+0x8a>
++80100741:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++      consputc('%');
++80100748:	b8 25 00 00 00       	mov    $0x25,%eax
++8010074d:	e8 8e fc ff ff       	call   801003e0 <consputc>
++      break;
++80100752:	e9 6e ff ff ff       	jmp    801006c5 <cprintf+0x75>
++80100757:	90                   	nop
++      if((s = (char*)*argp++) == 0)
++80100758:	8d 46 04             	lea    0x4(%esi),%eax
++8010075b:	8b 36                	mov    (%esi),%esi
++8010075d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++        s = "(null)";
++80100760:	b8 78 6d 10 80       	mov    $0x80106d78,%eax
++80100765:	85 f6                	test   %esi,%esi
++80100767:	0f 44 f0             	cmove  %eax,%esi
++      for(; *s; s++)
++8010076a:	0f be 06             	movsbl (%esi),%eax
++8010076d:	84 c0                	test   %al,%al
++8010076f:	74 16                	je     80100787 <cprintf+0x137>
++80100771:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++80100778:	83 c6 01             	add    $0x1,%esi
++        consputc(*s);
++8010077b:	e8 60 fc ff ff       	call   801003e0 <consputc>
++      for(; *s; s++)
++80100780:	0f be 06             	movsbl (%esi),%eax
++80100783:	84 c0                	test   %al,%al
++80100785:	75 f1                	jne    80100778 <cprintf+0x128>
++      if((s = (char*)*argp++) == 0)
++80100787:	8b 75 e4             	mov    -0x1c(%ebp),%esi
++8010078a:	e9 36 ff ff ff       	jmp    801006c5 <cprintf+0x75>
++8010078f:	90                   	nop
++    acquire(&cons.lock);
++80100790:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
++80100797:	e8 b4 39 00 00       	call   80104150 <acquire>
++8010079c:	e9 c8 fe ff ff       	jmp    80100669 <cprintf+0x19>
++    panic("null fmt");
++801007a1:	c7 04 24 7f 6d 10 80 	movl   $0x80106d7f,(%esp)
++801007a8:	e8 b3 fb ff ff       	call   80100360 <panic>
++801007ad:	8d 76 00             	lea    0x0(%esi),%esi
++
++801007b0 <consoleintr>:
++{
++801007b0:	55                   	push   %ebp
++801007b1:	89 e5                	mov    %esp,%ebp
++801007b3:	57                   	push   %edi
++801007b4:	56                   	push   %esi
++  int c, doprocdump = 0;
++801007b5:	31 f6                	xor    %esi,%esi
++{
++801007b7:	53                   	push   %ebx
++801007b8:	83 ec 1c             	sub    $0x1c,%esp
++801007bb:	8b 5d 08             	mov    0x8(%ebp),%ebx
++  acquire(&cons.lock);
++801007be:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
++801007c5:	e8 86 39 00 00       	call   80104150 <acquire>
++801007ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++  while((c = getc()) >= 0){
++801007d0:	ff d3                	call   *%ebx
++801007d2:	85 c0                	test   %eax,%eax
++801007d4:	89 c7                	mov    %eax,%edi
++801007d6:	78 48                	js     80100820 <consoleintr+0x70>
++    switch(c){
++801007d8:	83 ff 10             	cmp    $0x10,%edi
++801007db:	0f 84 2f 01 00 00    	je     80100910 <consoleintr+0x160>
++801007e1:	7e 5d                	jle    80100840 <consoleintr+0x90>
++801007e3:	83 ff 15             	cmp    $0x15,%edi
++801007e6:	0f 84 d4 00 00 00    	je     801008c0 <consoleintr+0x110>
++801007ec:	83 ff 7f             	cmp    $0x7f,%edi
++801007ef:	90                   	nop
++801007f0:	75 53                	jne    80100845 <consoleintr+0x95>
++      if(input.e != input.w){
++801007f2:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
++801007f7:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
++801007fd:	74 d1                	je     801007d0 <consoleintr+0x20>
++        input.e--;
++801007ff:	83 e8 01             	sub    $0x1,%eax
++80100802:	a3 a8 ff 10 80       	mov    %eax,0x8010ffa8
++        consputc(BACKSPACE);
++80100807:	b8 00 01 00 00       	mov    $0x100,%eax
++8010080c:	e8 cf fb ff ff       	call   801003e0 <consputc>
++  while((c = getc()) >= 0){
++80100811:	ff d3                	call   *%ebx
++80100813:	85 c0                	test   %eax,%eax
++80100815:	89 c7                	mov    %eax,%edi
++80100817:	79 bf                	jns    801007d8 <consoleintr+0x28>
++80100819:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++  release(&cons.lock);
++80100820:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
++80100827:	e8 14 3a 00 00       	call   80104240 <release>
++  if(doprocdump) {
++8010082c:	85 f6                	test   %esi,%esi
++8010082e:	0f 85 ec 00 00 00    	jne    80100920 <consoleintr+0x170>
++}
++80100834:	83 c4 1c             	add    $0x1c,%esp
++80100837:	5b                   	pop    %ebx
++80100838:	5e                   	pop    %esi
++80100839:	5f                   	pop    %edi
++8010083a:	5d                   	pop    %ebp
++8010083b:	c3                   	ret    
++8010083c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    switch(c){
++80100840:	83 ff 08             	cmp    $0x8,%edi
++80100843:	74 ad                	je     801007f2 <consoleintr+0x42>
++      if(c != 0 && input.e-input.r < INPUT_BUF){
++80100845:	85 ff                	test   %edi,%edi
++80100847:	74 87                	je     801007d0 <consoleintr+0x20>
++80100849:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
++8010084e:	89 c2                	mov    %eax,%edx
++80100850:	2b 15 a0 ff 10 80    	sub    0x8010ffa0,%edx
++80100856:	83 fa 7f             	cmp    $0x7f,%edx
++80100859:	0f 87 71 ff ff ff    	ja     801007d0 <consoleintr+0x20>
++        input.buf[input.e++ % INPUT_BUF] = c;
++8010085f:	8d 50 01             	lea    0x1(%eax),%edx
++80100862:	83 e0 7f             	and    $0x7f,%eax
++        c = (c == '\r') ? '\n' : c;
++80100865:	83 ff 0d             	cmp    $0xd,%edi
++        input.buf[input.e++ % INPUT_BUF] = c;
++80100868:	89 15 a8 ff 10 80    	mov    %edx,0x8010ffa8
++        c = (c == '\r') ? '\n' : c;
++8010086e:	0f 84 b8 00 00 00    	je     8010092c <consoleintr+0x17c>
++        input.buf[input.e++ % INPUT_BUF] = c;
++80100874:	89 f9                	mov    %edi,%ecx
++80100876:	88 88 20 ff 10 80    	mov    %cl,-0x7fef00e0(%eax)
++        consputc(c);
++8010087c:	89 f8                	mov    %edi,%eax
++8010087e:	e8 5d fb ff ff       	call   801003e0 <consputc>
++        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
++80100883:	83 ff 04             	cmp    $0x4,%edi
++80100886:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
++8010088b:	74 19                	je     801008a6 <consoleintr+0xf6>
++8010088d:	83 ff 0a             	cmp    $0xa,%edi
++80100890:	74 14                	je     801008a6 <consoleintr+0xf6>
++80100892:	8b 0d a0 ff 10 80    	mov    0x8010ffa0,%ecx
++80100898:	8d 91 80 00 00 00    	lea    0x80(%ecx),%edx
++8010089e:	39 d0                	cmp    %edx,%eax
++801008a0:	0f 85 2a ff ff ff    	jne    801007d0 <consoleintr+0x20>
++          wakeup(&input.r);
++801008a6:	c7 04 24 a0 ff 10 80 	movl   $0x8010ffa0,(%esp)
++          input.w = input.e;
++801008ad:	a3 a4 ff 10 80       	mov    %eax,0x8010ffa4
++          wakeup(&input.r);
++801008b2:	e8 e9 34 00 00       	call   80103da0 <wakeup>
++801008b7:	e9 14 ff ff ff       	jmp    801007d0 <consoleintr+0x20>
++801008bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++      while(input.e != input.w &&
++801008c0:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
++801008c5:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
++801008cb:	75 2b                	jne    801008f8 <consoleintr+0x148>
++801008cd:	e9 fe fe ff ff       	jmp    801007d0 <consoleintr+0x20>
++801008d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++        input.e--;
++801008d8:	a3 a8 ff 10 80       	mov    %eax,0x8010ffa8
++        consputc(BACKSPACE);
++801008dd:	b8 00 01 00 00       	mov    $0x100,%eax
++801008e2:	e8 f9 fa ff ff       	call   801003e0 <consputc>
++      while(input.e != input.w &&
++801008e7:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
++801008ec:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
++801008f2:	0f 84 d8 fe ff ff    	je     801007d0 <consoleintr+0x20>
++            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
++801008f8:	83 e8 01             	sub    $0x1,%eax
++801008fb:	89 c2                	mov    %eax,%edx
++801008fd:	83 e2 7f             	and    $0x7f,%edx
++      while(input.e != input.w &&
++80100900:	80 ba 20 ff 10 80 0a 	cmpb   $0xa,-0x7fef00e0(%edx)
++80100907:	75 cf                	jne    801008d8 <consoleintr+0x128>
++80100909:	e9 c2 fe ff ff       	jmp    801007d0 <consoleintr+0x20>
++8010090e:	66 90                	xchg   %ax,%ax
++      doprocdump = 1;
++80100910:	be 01 00 00 00       	mov    $0x1,%esi
++80100915:	e9 b6 fe ff ff       	jmp    801007d0 <consoleintr+0x20>
++8010091a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++}
++80100920:	83 c4 1c             	add    $0x1c,%esp
++80100923:	5b                   	pop    %ebx
++80100924:	5e                   	pop    %esi
++80100925:	5f                   	pop    %edi
++80100926:	5d                   	pop    %ebp
++    procdump();  // now call procdump() wo. cons.lock held
++80100927:	e9 54 35 00 00       	jmp    80103e80 <procdump>
++        input.buf[input.e++ % INPUT_BUF] = c;
++8010092c:	c6 80 20 ff 10 80 0a 	movb   $0xa,-0x7fef00e0(%eax)
++        consputc(c);
++80100933:	b8 0a 00 00 00       	mov    $0xa,%eax
++80100938:	e8 a3 fa ff ff       	call   801003e0 <consputc>
++8010093d:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
++80100942:	e9 5f ff ff ff       	jmp    801008a6 <consoleintr+0xf6>
++80100947:	89 f6                	mov    %esi,%esi
++80100949:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++80100950 <consoleinit>:
++
++void
++consoleinit(void)
++{
++80100950:	55                   	push   %ebp
++80100951:	89 e5                	mov    %esp,%ebp
++80100953:	83 ec 18             	sub    $0x18,%esp
++  initlock(&cons.lock, "console");
++80100956:	c7 44 24 04 88 6d 10 	movl   $0x80106d88,0x4(%esp)
++8010095d:	80 
++8010095e:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
++80100965:	e8 f6 36 00 00       	call   80104060 <initlock>
++
++  devsw[CONSOLE].write = consolewrite;
++  devsw[CONSOLE].read = consoleread;
++  cons.locking = 1;
++
++  ioapicenable(IRQ_KBD, 0);
++8010096a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
++80100971:	00 
++80100972:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
++  devsw[CONSOLE].write = consolewrite;
++80100979:	c7 05 6c 09 11 80 f0 	movl   $0x801005f0,0x8011096c
++80100980:	05 10 80 
++  devsw[CONSOLE].read = consoleread;
++80100983:	c7 05 68 09 11 80 70 	movl   $0x80100270,0x80110968
++8010098a:	02 10 80 
++  cons.locking = 1;
++8010098d:	c7 05 54 a5 10 80 01 	movl   $0x1,0x8010a554
++80100994:	00 00 00 
++  ioapicenable(IRQ_KBD, 0);
++80100997:	e8 24 19 00 00       	call   801022c0 <ioapicenable>
++}
++8010099c:	c9                   	leave  
++8010099d:	c3                   	ret    
++8010099e:	66 90                	xchg   %ax,%ax
++
++801009a0 <exec>:
++#include "x86.h"
++#include "elf.h"
++
++int
++exec(char *path, char **argv)
++{
++801009a0:	55                   	push   %ebp
++801009a1:	89 e5                	mov    %esp,%ebp
++801009a3:	57                   	push   %edi
++801009a4:	56                   	push   %esi
++801009a5:	53                   	push   %ebx
++801009a6:	81 ec 2c 01 00 00    	sub    $0x12c,%esp
++  uint argc, sz, sp, ustack[3+MAXARG+1];
++  struct elfhdr elf;
++  struct inode *ip;
++  struct proghdr ph;
++  pde_t *pgdir, *oldpgdir;
++  struct proc *curproc = myproc();
++801009ac:	e8 ff 2c 00 00       	call   801036b0 <myproc>
++801009b1:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
++
++  begin_op();
++801009b7:	e8 64 21 00 00       	call   80102b20 <begin_op>
++
++  if((ip = namei(path)) == 0){
++801009bc:	8b 45 08             	mov    0x8(%ebp),%eax
++801009bf:	89 04 24             	mov    %eax,(%esp)
++801009c2:	e8 49 15 00 00       	call   80101f10 <namei>
++801009c7:	85 c0                	test   %eax,%eax
++801009c9:	89 c3                	mov    %eax,%ebx
++801009cb:	0f 84 c2 01 00 00    	je     80100b93 <exec+0x1f3>
++    end_op();
++    cprintf("exec: fail\n");
++    return -1;
++  }
++  ilock(ip);
++801009d1:	89 04 24             	mov    %eax,(%esp)
++801009d4:	e8 e7 0c 00 00       	call   801016c0 <ilock>
++  pgdir = 0;
++
++  // Check ELF header
++  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
++801009d9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
++801009df:	c7 44 24 0c 34 00 00 	movl   $0x34,0xc(%esp)
++801009e6:	00 
++801009e7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
++801009ee:	00 
++801009ef:	89 44 24 04          	mov    %eax,0x4(%esp)
++801009f3:	89 1c 24             	mov    %ebx,(%esp)
++801009f6:	e8 75 0f 00 00       	call   80101970 <readi>
++801009fb:	83 f8 34             	cmp    $0x34,%eax
++801009fe:	74 20                	je     80100a20 <exec+0x80>
++
++ bad:
++  if(pgdir)
++    freevm(pgdir);
++  if(ip){
++    iunlockput(ip);
++80100a00:	89 1c 24             	mov    %ebx,(%esp)
++80100a03:	e8 18 0f 00 00       	call   80101920 <iunlockput>
++    end_op();
++80100a08:	e8 83 21 00 00       	call   80102b90 <end_op>
++  }
++  return -1;
++80100a0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++}
++80100a12:	81 c4 2c 01 00 00    	add    $0x12c,%esp
++80100a18:	5b                   	pop    %ebx
++80100a19:	5e                   	pop    %esi
++80100a1a:	5f                   	pop    %edi
++80100a1b:	5d                   	pop    %ebp
++80100a1c:	c3                   	ret    
++80100a1d:	8d 76 00             	lea    0x0(%esi),%esi
++  if(elf.magic != ELF_MAGIC)
++80100a20:	81 bd 24 ff ff ff 7f 	cmpl   $0x464c457f,-0xdc(%ebp)
++80100a27:	45 4c 46 
++80100a2a:	75 d4                	jne    80100a00 <exec+0x60>
++  if((pgdir = setupkvm()) == 0)
++80100a2c:	e8 bf 5f 00 00       	call   801069f0 <setupkvm>
++80100a31:	85 c0                	test   %eax,%eax
++80100a33:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
++80100a39:	74 c5                	je     80100a00 <exec+0x60>
++  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
++80100a3b:	66 83 bd 50 ff ff ff 	cmpw   $0x0,-0xb0(%ebp)
++80100a42:	00 
++80100a43:	8b b5 40 ff ff ff    	mov    -0xc0(%ebp),%esi
++  sz = 0;
++80100a49:	c7 85 ec fe ff ff 00 	movl   $0x0,-0x114(%ebp)
++80100a50:	00 00 00 
++  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
++80100a53:	0f 84 da 00 00 00    	je     80100b33 <exec+0x193>
++80100a59:	31 ff                	xor    %edi,%edi
++80100a5b:	eb 18                	jmp    80100a75 <exec+0xd5>
++80100a5d:	8d 76 00             	lea    0x0(%esi),%esi
++80100a60:	0f b7 85 50 ff ff ff 	movzwl -0xb0(%ebp),%eax
++80100a67:	83 c7 01             	add    $0x1,%edi
++80100a6a:	83 c6 20             	add    $0x20,%esi
++80100a6d:	39 f8                	cmp    %edi,%eax
++80100a6f:	0f 8e be 00 00 00    	jle    80100b33 <exec+0x193>
++    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
++80100a75:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
++80100a7b:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
++80100a82:	00 
++80100a83:	89 74 24 08          	mov    %esi,0x8(%esp)
++80100a87:	89 44 24 04          	mov    %eax,0x4(%esp)
++80100a8b:	89 1c 24             	mov    %ebx,(%esp)
++80100a8e:	e8 dd 0e 00 00       	call   80101970 <readi>
++80100a93:	83 f8 20             	cmp    $0x20,%eax
++80100a96:	0f 85 84 00 00 00    	jne    80100b20 <exec+0x180>
++    if(ph.type != ELF_PROG_LOAD)
++80100a9c:	83 bd 04 ff ff ff 01 	cmpl   $0x1,-0xfc(%ebp)
++80100aa3:	75 bb                	jne    80100a60 <exec+0xc0>
++    if(ph.memsz < ph.filesz)
++80100aa5:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
++80100aab:	3b 85 14 ff ff ff    	cmp    -0xec(%ebp),%eax
++80100ab1:	72 6d                	jb     80100b20 <exec+0x180>
++    if(ph.vaddr + ph.memsz < ph.vaddr)
++80100ab3:	03 85 0c ff ff ff    	add    -0xf4(%ebp),%eax
++80100ab9:	72 65                	jb     80100b20 <exec+0x180>
++    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
++80100abb:	89 44 24 08          	mov    %eax,0x8(%esp)
++80100abf:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
++80100ac5:	89 44 24 04          	mov    %eax,0x4(%esp)
++80100ac9:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
++80100acf:	89 04 24             	mov    %eax,(%esp)
++80100ad2:	e8 79 5d 00 00       	call   80106850 <allocuvm>
++80100ad7:	85 c0                	test   %eax,%eax
++80100ad9:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
++80100adf:	74 3f                	je     80100b20 <exec+0x180>
++    if(ph.vaddr % PGSIZE != 0)
++80100ae1:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
++80100ae7:	a9 ff 0f 00 00       	test   $0xfff,%eax
++80100aec:	75 32                	jne    80100b20 <exec+0x180>
++    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
++80100aee:	8b 95 14 ff ff ff    	mov    -0xec(%ebp),%edx
++80100af4:	89 44 24 04          	mov    %eax,0x4(%esp)
++80100af8:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
++80100afe:	89 5c 24 08          	mov    %ebx,0x8(%esp)
++80100b02:	89 54 24 10          	mov    %edx,0x10(%esp)
++80100b06:	8b 95 08 ff ff ff    	mov    -0xf8(%ebp),%edx
++80100b0c:	89 04 24             	mov    %eax,(%esp)
++80100b0f:	89 54 24 0c          	mov    %edx,0xc(%esp)
++80100b13:	e8 78 5c 00 00       	call   80106790 <loaduvm>
++80100b18:	85 c0                	test   %eax,%eax
++80100b1a:	0f 89 40 ff ff ff    	jns    80100a60 <exec+0xc0>
++    freevm(pgdir);
++80100b20:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
++80100b26:	89 04 24             	mov    %eax,(%esp)
++80100b29:	e8 42 5e 00 00       	call   80106970 <freevm>
++80100b2e:	e9 cd fe ff ff       	jmp    80100a00 <exec+0x60>
++  iunlockput(ip);
++80100b33:	89 1c 24             	mov    %ebx,(%esp)
++80100b36:	e8 e5 0d 00 00       	call   80101920 <iunlockput>
++80100b3b:	90                   	nop
++80100b3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++  end_op();
++80100b40:	e8 4b 20 00 00       	call   80102b90 <end_op>
++  sz = PGROUNDUP(sz);
++80100b45:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
++80100b4b:	05 ff 0f 00 00       	add    $0xfff,%eax
++80100b50:	25 00 f0 ff ff       	and    $0xfffff000,%eax
++  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
++80100b55:	8d 90 00 20 00 00    	lea    0x2000(%eax),%edx
++80100b5b:	89 44 24 04          	mov    %eax,0x4(%esp)
++80100b5f:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
++80100b65:	89 54 24 08          	mov    %edx,0x8(%esp)
++80100b69:	89 04 24             	mov    %eax,(%esp)
++80100b6c:	e8 df 5c 00 00       	call   80106850 <allocuvm>
++80100b71:	85 c0                	test   %eax,%eax
++80100b73:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
++80100b79:	75 33                	jne    80100bae <exec+0x20e>
++    freevm(pgdir);
++80100b7b:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
++80100b81:	89 04 24             	mov    %eax,(%esp)
++80100b84:	e8 e7 5d 00 00       	call   80106970 <freevm>
++  return -1;
++80100b89:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++80100b8e:	e9 7f fe ff ff       	jmp    80100a12 <exec+0x72>
++    end_op();
++80100b93:	e8 f8 1f 00 00       	call   80102b90 <end_op>
++    cprintf("exec: fail\n");
++80100b98:	c7 04 24 a1 6d 10 80 	movl   $0x80106da1,(%esp)
++80100b9f:	e8 ac fa ff ff       	call   80100650 <cprintf>
++    return -1;
++80100ba4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++80100ba9:	e9 64 fe ff ff       	jmp    80100a12 <exec+0x72>
++  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
++80100bae:	8b 9d e8 fe ff ff    	mov    -0x118(%ebp),%ebx
++80100bb4:	89 d8                	mov    %ebx,%eax
++80100bb6:	2d 00 20 00 00       	sub    $0x2000,%eax
++80100bbb:	89 44 24 04          	mov    %eax,0x4(%esp)
++80100bbf:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
++80100bc5:	89 04 24             	mov    %eax,(%esp)
++80100bc8:	e8 d3 5e 00 00       	call   80106aa0 <clearpteu>
++  for(argc = 0; argv[argc]; argc++) {
++80100bcd:	8b 45 0c             	mov    0xc(%ebp),%eax
++80100bd0:	8b 00                	mov    (%eax),%eax
++80100bd2:	85 c0                	test   %eax,%eax
++80100bd4:	0f 84 59 01 00 00    	je     80100d33 <exec+0x393>
++80100bda:	8b 4d 0c             	mov    0xc(%ebp),%ecx
++80100bdd:	31 d2                	xor    %edx,%edx
++80100bdf:	8d 71 04             	lea    0x4(%ecx),%esi
++80100be2:	89 cf                	mov    %ecx,%edi
++80100be4:	89 d1                	mov    %edx,%ecx
++80100be6:	89 f2                	mov    %esi,%edx
++80100be8:	89 fe                	mov    %edi,%esi
++80100bea:	89 cf                	mov    %ecx,%edi
++80100bec:	eb 0a                	jmp    80100bf8 <exec+0x258>
++80100bee:	66 90                	xchg   %ax,%ax
++80100bf0:	83 c2 04             	add    $0x4,%edx
++    if(argc >= MAXARG)
++80100bf3:	83 ff 20             	cmp    $0x20,%edi
++80100bf6:	74 83                	je     80100b7b <exec+0x1db>
++    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
++80100bf8:	89 04 24             	mov    %eax,(%esp)
++80100bfb:	89 95 ec fe ff ff    	mov    %edx,-0x114(%ebp)
++80100c01:	e8 aa 38 00 00       	call   801044b0 <strlen>
++80100c06:	f7 d0                	not    %eax
++80100c08:	01 c3                	add    %eax,%ebx
++    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
++80100c0a:	8b 06                	mov    (%esi),%eax
++    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
++80100c0c:	83 e3 fc             	and    $0xfffffffc,%ebx
++    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
++80100c0f:	89 04 24             	mov    %eax,(%esp)
++80100c12:	e8 99 38 00 00       	call   801044b0 <strlen>
++80100c17:	83 c0 01             	add    $0x1,%eax
++80100c1a:	89 44 24 0c          	mov    %eax,0xc(%esp)
++80100c1e:	8b 06                	mov    (%esi),%eax
++80100c20:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++80100c24:	89 44 24 08          	mov    %eax,0x8(%esp)
++80100c28:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
++80100c2e:	89 04 24             	mov    %eax,(%esp)
++80100c31:	e8 ca 5f 00 00       	call   80106c00 <copyout>
++80100c36:	85 c0                	test   %eax,%eax
++80100c38:	0f 88 3d ff ff ff    	js     80100b7b <exec+0x1db>
++  for(argc = 0; argv[argc]; argc++) {
++80100c3e:	8b 95 ec fe ff ff    	mov    -0x114(%ebp),%edx
++    ustack[3+argc] = sp;
++80100c44:	8d 8d 58 ff ff ff    	lea    -0xa8(%ebp),%ecx
++80100c4a:	89 9c bd 64 ff ff ff 	mov    %ebx,-0x9c(%ebp,%edi,4)
++  for(argc = 0; argv[argc]; argc++) {
++80100c51:	83 c7 01             	add    $0x1,%edi
++80100c54:	8b 02                	mov    (%edx),%eax
++80100c56:	89 d6                	mov    %edx,%esi
++80100c58:	85 c0                	test   %eax,%eax
++80100c5a:	75 94                	jne    80100bf0 <exec+0x250>
++80100c5c:	89 fa                	mov    %edi,%edx
++  ustack[3+argc] = 0;
++80100c5e:	c7 84 95 64 ff ff ff 	movl   $0x0,-0x9c(%ebp,%edx,4)
++80100c65:	00 00 00 00 
++  ustack[2] = sp - (argc+1)*4;  // argv pointer
++80100c69:	8d 04 95 04 00 00 00 	lea    0x4(,%edx,4),%eax
++  ustack[1] = argc;
++80100c70:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%ebp)
++  ustack[2] = sp - (argc+1)*4;  // argv pointer
++80100c76:	89 da                	mov    %ebx,%edx
++80100c78:	29 c2                	sub    %eax,%edx
++  sp -= (3+argc+1) * 4;
++80100c7a:	83 c0 0c             	add    $0xc,%eax
++80100c7d:	29 c3                	sub    %eax,%ebx
++  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
++80100c7f:	89 44 24 0c          	mov    %eax,0xc(%esp)
++80100c83:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
++80100c89:	89 4c 24 08          	mov    %ecx,0x8(%esp)
++80100c8d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++  ustack[0] = 0xffffffff;  // fake return PC
++80100c91:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
++80100c98:	ff ff ff 
++  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
++80100c9b:	89 04 24             	mov    %eax,(%esp)
++  ustack[2] = sp - (argc+1)*4;  // argv pointer
++80100c9e:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)
++  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
++80100ca4:	e8 57 5f 00 00       	call   80106c00 <copyout>
++80100ca9:	85 c0                	test   %eax,%eax
++80100cab:	0f 88 ca fe ff ff    	js     80100b7b <exec+0x1db>
++  for(last=s=path; *s; s++)
++80100cb1:	8b 45 08             	mov    0x8(%ebp),%eax
++80100cb4:	0f b6 10             	movzbl (%eax),%edx
++80100cb7:	84 d2                	test   %dl,%dl
++80100cb9:	74 19                	je     80100cd4 <exec+0x334>
++80100cbb:	8b 4d 08             	mov    0x8(%ebp),%ecx
++80100cbe:	83 c0 01             	add    $0x1,%eax
++      last = s+1;
++80100cc1:	80 fa 2f             	cmp    $0x2f,%dl
++  for(last=s=path; *s; s++)
++80100cc4:	0f b6 10             	movzbl (%eax),%edx
++      last = s+1;
++80100cc7:	0f 44 c8             	cmove  %eax,%ecx
++80100cca:	83 c0 01             	add    $0x1,%eax
++  for(last=s=path; *s; s++)
++80100ccd:	84 d2                	test   %dl,%dl
++80100ccf:	75 f0                	jne    80100cc1 <exec+0x321>
++80100cd1:	89 4d 08             	mov    %ecx,0x8(%ebp)
++  safestrcpy(curproc->name, last, sizeof(curproc->name));
++80100cd4:	8b bd f4 fe ff ff    	mov    -0x10c(%ebp),%edi
++80100cda:	8b 45 08             	mov    0x8(%ebp),%eax
++80100cdd:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
++80100ce4:	00 
++80100ce5:	89 44 24 04          	mov    %eax,0x4(%esp)
++80100ce9:	89 f8                	mov    %edi,%eax
++80100ceb:	83 c0 6c             	add    $0x6c,%eax
++80100cee:	89 04 24             	mov    %eax,(%esp)
++80100cf1:	e8 7a 37 00 00       	call   80104470 <safestrcpy>
++  curproc->pgdir = pgdir;
++80100cf6:	8b 8d f0 fe ff ff    	mov    -0x110(%ebp),%ecx
++  oldpgdir = curproc->pgdir;
++80100cfc:	8b 77 04             	mov    0x4(%edi),%esi
++  curproc->tf->eip = elf.entry;  // main
++80100cff:	8b 47 18             	mov    0x18(%edi),%eax
++  curproc->pgdir = pgdir;
++80100d02:	89 4f 04             	mov    %ecx,0x4(%edi)
++  curproc->sz = sz;
++80100d05:	8b 8d e8 fe ff ff    	mov    -0x118(%ebp),%ecx
++80100d0b:	89 0f                	mov    %ecx,(%edi)
++  curproc->tf->eip = elf.entry;  // main
++80100d0d:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
++80100d13:	89 50 38             	mov    %edx,0x38(%eax)
++  curproc->tf->esp = sp;
++80100d16:	8b 47 18             	mov    0x18(%edi),%eax
++80100d19:	89 58 44             	mov    %ebx,0x44(%eax)
++  switchuvm(curproc);
++80100d1c:	89 3c 24             	mov    %edi,(%esp)
++80100d1f:	e8 cc 58 00 00       	call   801065f0 <switchuvm>
++  freevm(oldpgdir);
++80100d24:	89 34 24             	mov    %esi,(%esp)
++80100d27:	e8 44 5c 00 00       	call   80106970 <freevm>
++  return 0;
++80100d2c:	31 c0                	xor    %eax,%eax
++80100d2e:	e9 df fc ff ff       	jmp    80100a12 <exec+0x72>
++  for(argc = 0; argv[argc]; argc++) {
++80100d33:	8b 9d e8 fe ff ff    	mov    -0x118(%ebp),%ebx
++80100d39:	31 d2                	xor    %edx,%edx
++80100d3b:	8d 8d 58 ff ff ff    	lea    -0xa8(%ebp),%ecx
++80100d41:	e9 18 ff ff ff       	jmp    80100c5e <exec+0x2be>
++80100d46:	66 90                	xchg   %ax,%ax
++80100d48:	66 90                	xchg   %ax,%ax
++80100d4a:	66 90                	xchg   %ax,%ax
++80100d4c:	66 90                	xchg   %ax,%ax
++80100d4e:	66 90                	xchg   %ax,%ax
++
++80100d50 <fileinit>:
++  struct file file[NFILE];
++} ftable;
++
++void
++fileinit(void)
++{
++80100d50:	55                   	push   %ebp
++80100d51:	89 e5                	mov    %esp,%ebp
++80100d53:	83 ec 18             	sub    $0x18,%esp
++  initlock(&ftable.lock, "ftable");
++80100d56:	c7 44 24 04 ad 6d 10 	movl   $0x80106dad,0x4(%esp)
++80100d5d:	80 
++80100d5e:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
++80100d65:	e8 f6 32 00 00       	call   80104060 <initlock>
++}
++80100d6a:	c9                   	leave  
++80100d6b:	c3                   	ret    
++80100d6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++
++80100d70 <filealloc>:
++
++// Allocate a file structure.
++struct file*
++filealloc(void)
++{
++80100d70:	55                   	push   %ebp
++80100d71:	89 e5                	mov    %esp,%ebp
++80100d73:	53                   	push   %ebx
++  struct file *f;
++
++  acquire(&ftable.lock);
++  for(f = ftable.file; f < ftable.file + NFILE; f++){
++80100d74:	bb f4 ff 10 80       	mov    $0x8010fff4,%ebx
++{
++80100d79:	83 ec 14             	sub    $0x14,%esp
++  acquire(&ftable.lock);
++80100d7c:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
++80100d83:	e8 c8 33 00 00       	call   80104150 <acquire>
++80100d88:	eb 11                	jmp    80100d9b <filealloc+0x2b>
++80100d8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++  for(f = ftable.file; f < ftable.file + NFILE; f++){
++80100d90:	83 c3 18             	add    $0x18,%ebx
++80100d93:	81 fb 54 09 11 80    	cmp    $0x80110954,%ebx
++80100d99:	74 25                	je     80100dc0 <filealloc+0x50>
++    if(f->ref == 0){
++80100d9b:	8b 43 04             	mov    0x4(%ebx),%eax
++80100d9e:	85 c0                	test   %eax,%eax
++80100da0:	75 ee                	jne    80100d90 <filealloc+0x20>
++      f->ref = 1;
++      release(&ftable.lock);
++80100da2:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
++      f->ref = 1;
++80100da9:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
++      release(&ftable.lock);
++80100db0:	e8 8b 34 00 00       	call   80104240 <release>
++      return f;
++    }
++  }
++  release(&ftable.lock);
++  return 0;
++}
++80100db5:	83 c4 14             	add    $0x14,%esp
++      return f;
++80100db8:	89 d8                	mov    %ebx,%eax
++}
++80100dba:	5b                   	pop    %ebx
++80100dbb:	5d                   	pop    %ebp
++80100dbc:	c3                   	ret    
++80100dbd:	8d 76 00             	lea    0x0(%esi),%esi
++  release(&ftable.lock);
++80100dc0:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
++80100dc7:	e8 74 34 00 00       	call   80104240 <release>
++}
++80100dcc:	83 c4 14             	add    $0x14,%esp
++  return 0;
++80100dcf:	31 c0                	xor    %eax,%eax
++}
++80100dd1:	5b                   	pop    %ebx
++80100dd2:	5d                   	pop    %ebp
++80100dd3:	c3                   	ret    
++80100dd4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++80100dda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
++
++80100de0 <filedup>:
++
++// Increment ref count for file f.
++struct file*
++filedup(struct file *f)
++{
++80100de0:	55                   	push   %ebp
++80100de1:	89 e5                	mov    %esp,%ebp
++80100de3:	53                   	push   %ebx
++80100de4:	83 ec 14             	sub    $0x14,%esp
++80100de7:	8b 5d 08             	mov    0x8(%ebp),%ebx
++  acquire(&ftable.lock);
++80100dea:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
++80100df1:	e8 5a 33 00 00       	call   80104150 <acquire>
++  if(f->ref < 1)
++80100df6:	8b 43 04             	mov    0x4(%ebx),%eax
++80100df9:	85 c0                	test   %eax,%eax
++80100dfb:	7e 1a                	jle    80100e17 <filedup+0x37>
++    panic("filedup");
++  f->ref++;
++80100dfd:	83 c0 01             	add    $0x1,%eax
++80100e00:	89 43 04             	mov    %eax,0x4(%ebx)
++  release(&ftable.lock);
++80100e03:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
++80100e0a:	e8 31 34 00 00       	call   80104240 <release>
++  return f;
++}
++80100e0f:	83 c4 14             	add    $0x14,%esp
++80100e12:	89 d8                	mov    %ebx,%eax
++80100e14:	5b                   	pop    %ebx
++80100e15:	5d                   	pop    %ebp
++80100e16:	c3                   	ret    
++    panic("filedup");
++80100e17:	c7 04 24 b4 6d 10 80 	movl   $0x80106db4,(%esp)
++80100e1e:	e8 3d f5 ff ff       	call   80100360 <panic>
++80100e23:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++80100e29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++80100e30 <fileclose>:
++
++// Close file f.  (Decrement ref count, close when reaches 0.)
++void
++fileclose(struct file *f)
++{
++80100e30:	55                   	push   %ebp
++80100e31:	89 e5                	mov    %esp,%ebp
++80100e33:	57                   	push   %edi
++80100e34:	56                   	push   %esi
++80100e35:	53                   	push   %ebx
++80100e36:	83 ec 1c             	sub    $0x1c,%esp
++80100e39:	8b 7d 08             	mov    0x8(%ebp),%edi
++  struct file ff;
++
++  acquire(&ftable.lock);
++80100e3c:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
++80100e43:	e8 08 33 00 00       	call   80104150 <acquire>
++  if(f->ref < 1)
++80100e48:	8b 57 04             	mov    0x4(%edi),%edx
++80100e4b:	85 d2                	test   %edx,%edx
++80100e4d:	0f 8e 89 00 00 00    	jle    80100edc <fileclose+0xac>
++    panic("fileclose");
++  if(--f->ref > 0){
++80100e53:	83 ea 01             	sub    $0x1,%edx
++80100e56:	85 d2                	test   %edx,%edx
++80100e58:	89 57 04             	mov    %edx,0x4(%edi)
++80100e5b:	74 13                	je     80100e70 <fileclose+0x40>
++    release(&ftable.lock);
++80100e5d:	c7 45 08 c0 ff 10 80 	movl   $0x8010ffc0,0x8(%ebp)
++  else if(ff.type == FD_INODE){
++    begin_op();
++    iput(ff.ip);
++    end_op();
++  }
++}
++80100e64:	83 c4 1c             	add    $0x1c,%esp
++80100e67:	5b                   	pop    %ebx
++80100e68:	5e                   	pop    %esi
++80100e69:	5f                   	pop    %edi
++80100e6a:	5d                   	pop    %ebp
++    release(&ftable.lock);
++80100e6b:	e9 d0 33 00 00       	jmp    80104240 <release>
++  ff = *f;
++80100e70:	0f b6 47 09          	movzbl 0x9(%edi),%eax
++80100e74:	8b 37                	mov    (%edi),%esi
++80100e76:	8b 5f 0c             	mov    0xc(%edi),%ebx
++  f->type = FD_NONE;
++80100e79:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
++  ff = *f;
++80100e7f:	88 45 e7             	mov    %al,-0x19(%ebp)
++80100e82:	8b 47 10             	mov    0x10(%edi),%eax
++  release(&ftable.lock);
++80100e85:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
++  ff = *f;
++80100e8c:	89 45 e0             	mov    %eax,-0x20(%ebp)
++  release(&ftable.lock);
++80100e8f:	e8 ac 33 00 00       	call   80104240 <release>
++  if(ff.type == FD_PIPE)
++80100e94:	83 fe 01             	cmp    $0x1,%esi
++80100e97:	74 0f                	je     80100ea8 <fileclose+0x78>
++  else if(ff.type == FD_INODE){
++80100e99:	83 fe 02             	cmp    $0x2,%esi
++80100e9c:	74 22                	je     80100ec0 <fileclose+0x90>
++}
++80100e9e:	83 c4 1c             	add    $0x1c,%esp
++80100ea1:	5b                   	pop    %ebx
++80100ea2:	5e                   	pop    %esi
++80100ea3:	5f                   	pop    %edi
++80100ea4:	5d                   	pop    %ebp
++80100ea5:	c3                   	ret    
++80100ea6:	66 90                	xchg   %ax,%ax
++    pipeclose(ff.pipe, ff.writable);
++80100ea8:	0f be 75 e7          	movsbl -0x19(%ebp),%esi
++80100eac:	89 1c 24             	mov    %ebx,(%esp)
++80100eaf:	89 74 24 04          	mov    %esi,0x4(%esp)
++80100eb3:	e8 b8 23 00 00       	call   80103270 <pipeclose>
++80100eb8:	eb e4                	jmp    80100e9e <fileclose+0x6e>
++80100eba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    begin_op();
++80100ec0:	e8 5b 1c 00 00       	call   80102b20 <begin_op>
++    iput(ff.ip);
++80100ec5:	8b 45 e0             	mov    -0x20(%ebp),%eax
++80100ec8:	89 04 24             	mov    %eax,(%esp)
++80100ecb:	e8 10 09 00 00       	call   801017e0 <iput>
++}
++80100ed0:	83 c4 1c             	add    $0x1c,%esp
++80100ed3:	5b                   	pop    %ebx
++80100ed4:	5e                   	pop    %esi
++80100ed5:	5f                   	pop    %edi
++80100ed6:	5d                   	pop    %ebp
++    end_op();
++80100ed7:	e9 b4 1c 00 00       	jmp    80102b90 <end_op>
++    panic("fileclose");
++80100edc:	c7 04 24 bc 6d 10 80 	movl   $0x80106dbc,(%esp)
++80100ee3:	e8 78 f4 ff ff       	call   80100360 <panic>
++80100ee8:	90                   	nop
++80100ee9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++
++80100ef0 <filestat>:
++
++// Get metadata about file f.
++int
++filestat(struct file *f, struct stat *st)
++{
++80100ef0:	55                   	push   %ebp
++80100ef1:	89 e5                	mov    %esp,%ebp
++80100ef3:	53                   	push   %ebx
++80100ef4:	83 ec 14             	sub    $0x14,%esp
++80100ef7:	8b 5d 08             	mov    0x8(%ebp),%ebx
++  if(f->type == FD_INODE){
++80100efa:	83 3b 02             	cmpl   $0x2,(%ebx)
++80100efd:	75 31                	jne    80100f30 <filestat+0x40>
++    ilock(f->ip);
++80100eff:	8b 43 10             	mov    0x10(%ebx),%eax
++80100f02:	89 04 24             	mov    %eax,(%esp)
++80100f05:	e8 b6 07 00 00       	call   801016c0 <ilock>
++    stati(f->ip, st);
++80100f0a:	8b 45 0c             	mov    0xc(%ebp),%eax
++80100f0d:	89 44 24 04          	mov    %eax,0x4(%esp)
++80100f11:	8b 43 10             	mov    0x10(%ebx),%eax
++80100f14:	89 04 24             	mov    %eax,(%esp)
++80100f17:	e8 24 0a 00 00       	call   80101940 <stati>
++    iunlock(f->ip);
++80100f1c:	8b 43 10             	mov    0x10(%ebx),%eax
++80100f1f:	89 04 24             	mov    %eax,(%esp)
++80100f22:	e8 79 08 00 00       	call   801017a0 <iunlock>
++    return 0;
++  }
++  return -1;
++}
++80100f27:	83 c4 14             	add    $0x14,%esp
++    return 0;
++80100f2a:	31 c0                	xor    %eax,%eax
++}
++80100f2c:	5b                   	pop    %ebx
++80100f2d:	5d                   	pop    %ebp
++80100f2e:	c3                   	ret    
++80100f2f:	90                   	nop
++80100f30:	83 c4 14             	add    $0x14,%esp
++  return -1;
++80100f33:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++}
++80100f38:	5b                   	pop    %ebx
++80100f39:	5d                   	pop    %ebp
++80100f3a:	c3                   	ret    
++80100f3b:	90                   	nop
++80100f3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++
++80100f40 <fileread>:
++
++// Read from file f.
++int
++fileread(struct file *f, char *addr, int n)
++{
++80100f40:	55                   	push   %ebp
++80100f41:	89 e5                	mov    %esp,%ebp
++80100f43:	57                   	push   %edi
++80100f44:	56                   	push   %esi
++80100f45:	53                   	push   %ebx
++80100f46:	83 ec 1c             	sub    $0x1c,%esp
++80100f49:	8b 5d 08             	mov    0x8(%ebp),%ebx
++80100f4c:	8b 75 0c             	mov    0xc(%ebp),%esi
++80100f4f:	8b 7d 10             	mov    0x10(%ebp),%edi
++  int r;
++
++  if(f->readable == 0)
++80100f52:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
++80100f56:	74 68                	je     80100fc0 <fileread+0x80>
++    return -1;
++  if(f->type == FD_PIPE)
++80100f58:	8b 03                	mov    (%ebx),%eax
++80100f5a:	83 f8 01             	cmp    $0x1,%eax
++80100f5d:	74 49                	je     80100fa8 <fileread+0x68>
++    return piperead(f->pipe, addr, n);
++  if(f->type == FD_INODE){
++80100f5f:	83 f8 02             	cmp    $0x2,%eax
++80100f62:	75 63                	jne    80100fc7 <fileread+0x87>
++    ilock(f->ip);
++80100f64:	8b 43 10             	mov    0x10(%ebx),%eax
++80100f67:	89 04 24             	mov    %eax,(%esp)
++80100f6a:	e8 51 07 00 00       	call   801016c0 <ilock>
++    if((r = readi(f->ip, addr, f->off, n)) > 0)
++80100f6f:	89 7c 24 0c          	mov    %edi,0xc(%esp)
++80100f73:	8b 43 14             	mov    0x14(%ebx),%eax
++80100f76:	89 74 24 04          	mov    %esi,0x4(%esp)
++80100f7a:	89 44 24 08          	mov    %eax,0x8(%esp)
++80100f7e:	8b 43 10             	mov    0x10(%ebx),%eax
++80100f81:	89 04 24             	mov    %eax,(%esp)
++80100f84:	e8 e7 09 00 00       	call   80101970 <readi>
++80100f89:	85 c0                	test   %eax,%eax
++80100f8b:	89 c6                	mov    %eax,%esi
++80100f8d:	7e 03                	jle    80100f92 <fileread+0x52>
++      f->off += r;
++80100f8f:	01 43 14             	add    %eax,0x14(%ebx)
++    iunlock(f->ip);
++80100f92:	8b 43 10             	mov    0x10(%ebx),%eax
++80100f95:	89 04 24             	mov    %eax,(%esp)
++80100f98:	e8 03 08 00 00       	call   801017a0 <iunlock>
++    if((r = readi(f->ip, addr, f->off, n)) > 0)
++80100f9d:	89 f0                	mov    %esi,%eax
++    return r;
++  }
++  panic("fileread");
++}
++80100f9f:	83 c4 1c             	add    $0x1c,%esp
++80100fa2:	5b                   	pop    %ebx
++80100fa3:	5e                   	pop    %esi
++80100fa4:	5f                   	pop    %edi
++80100fa5:	5d                   	pop    %ebp
++80100fa6:	c3                   	ret    
++80100fa7:	90                   	nop
++    return piperead(f->pipe, addr, n);
++80100fa8:	8b 43 0c             	mov    0xc(%ebx),%eax
++80100fab:	89 45 08             	mov    %eax,0x8(%ebp)
++}
++80100fae:	83 c4 1c             	add    $0x1c,%esp
++80100fb1:	5b                   	pop    %ebx
++80100fb2:	5e                   	pop    %esi
++80100fb3:	5f                   	pop    %edi
++80100fb4:	5d                   	pop    %ebp
++    return piperead(f->pipe, addr, n);
++80100fb5:	e9 36 24 00 00       	jmp    801033f0 <piperead>
++80100fba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    return -1;
++80100fc0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++80100fc5:	eb d8                	jmp    80100f9f <fileread+0x5f>
++  panic("fileread");
++80100fc7:	c7 04 24 c6 6d 10 80 	movl   $0x80106dc6,(%esp)
++80100fce:	e8 8d f3 ff ff       	call   80100360 <panic>
++80100fd3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++80100fd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++80100fe0 <filewrite>:
++
++//PAGEBREAK!
++// Write to file f.
++int
++filewrite(struct file *f, char *addr, int n)
++{
++80100fe0:	55                   	push   %ebp
++80100fe1:	89 e5                	mov    %esp,%ebp
++80100fe3:	57                   	push   %edi
++80100fe4:	56                   	push   %esi
++80100fe5:	53                   	push   %ebx
++80100fe6:	83 ec 2c             	sub    $0x2c,%esp
++80100fe9:	8b 45 0c             	mov    0xc(%ebp),%eax
++80100fec:	8b 7d 08             	mov    0x8(%ebp),%edi
++80100fef:	89 45 dc             	mov    %eax,-0x24(%ebp)
++80100ff2:	8b 45 10             	mov    0x10(%ebp),%eax
++  int r;
++
++  if(f->writable == 0)
++80100ff5:	80 7f 09 00          	cmpb   $0x0,0x9(%edi)
++{
++80100ff9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++  if(f->writable == 0)
++80100ffc:	0f 84 ae 00 00 00    	je     801010b0 <filewrite+0xd0>
++    return -1;
++  if(f->type == FD_PIPE)
++80101002:	8b 07                	mov    (%edi),%eax
++80101004:	83 f8 01             	cmp    $0x1,%eax
++80101007:	0f 84 c2 00 00 00    	je     801010cf <filewrite+0xef>
++    return pipewrite(f->pipe, addr, n);
++  if(f->type == FD_INODE){
++8010100d:	83 f8 02             	cmp    $0x2,%eax
++80101010:	0f 85 d7 00 00 00    	jne    801010ed <filewrite+0x10d>
++    // and 2 blocks of slop for non-aligned writes.
++    // this really belongs lower down, since writei()
++    // might be writing a device like the console.
++    int max = ((LOGSIZE-1-1-2) / 2) * 512;
++    int i = 0;
++    while(i < n){
++80101016:	8b 45 e4             	mov    -0x1c(%ebp),%eax
++80101019:	31 db                	xor    %ebx,%ebx
++8010101b:	85 c0                	test   %eax,%eax
++8010101d:	7f 31                	jg     80101050 <filewrite+0x70>
++8010101f:	e9 9c 00 00 00       	jmp    801010c0 <filewrite+0xe0>
++80101024:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++
++      begin_op();
++      ilock(f->ip);
++      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
++        f->off += r;
++      iunlock(f->ip);
++80101028:	8b 4f 10             	mov    0x10(%edi),%ecx
++        f->off += r;
++8010102b:	01 47 14             	add    %eax,0x14(%edi)
++8010102e:	89 45 e0             	mov    %eax,-0x20(%ebp)
++      iunlock(f->ip);
++80101031:	89 0c 24             	mov    %ecx,(%esp)
++80101034:	e8 67 07 00 00       	call   801017a0 <iunlock>
++      end_op();
++80101039:	e8 52 1b 00 00       	call   80102b90 <end_op>
++8010103e:	8b 45 e0             	mov    -0x20(%ebp),%eax
++
++      if(r < 0)
++        break;
++      if(r != n1)
++80101041:	39 f0                	cmp    %esi,%eax
++80101043:	0f 85 98 00 00 00    	jne    801010e1 <filewrite+0x101>
++        panic("short filewrite");
++      i += r;
++80101049:	01 c3                	add    %eax,%ebx
++    while(i < n){
++8010104b:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
++8010104e:	7e 70                	jle    801010c0 <filewrite+0xe0>
++      int n1 = n - i;
++80101050:	8b 75 e4             	mov    -0x1c(%ebp),%esi
++80101053:	b8 00 1a 00 00       	mov    $0x1a00,%eax
++80101058:	29 de                	sub    %ebx,%esi
++8010105a:	81 fe 00 1a 00 00    	cmp    $0x1a00,%esi
++80101060:	0f 4f f0             	cmovg  %eax,%esi
++      begin_op();
++80101063:	e8 b8 1a 00 00       	call   80102b20 <begin_op>
++      ilock(f->ip);
++80101068:	8b 47 10             	mov    0x10(%edi),%eax
++8010106b:	89 04 24             	mov    %eax,(%esp)
++8010106e:	e8 4d 06 00 00       	call   801016c0 <ilock>
++      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
++80101073:	89 74 24 0c          	mov    %esi,0xc(%esp)
++80101077:	8b 47 14             	mov    0x14(%edi),%eax
++8010107a:	89 44 24 08          	mov    %eax,0x8(%esp)
++8010107e:	8b 45 dc             	mov    -0x24(%ebp),%eax
++80101081:	01 d8                	add    %ebx,%eax
++80101083:	89 44 24 04          	mov    %eax,0x4(%esp)
++80101087:	8b 47 10             	mov    0x10(%edi),%eax
++8010108a:	89 04 24             	mov    %eax,(%esp)
++8010108d:	e8 de 09 00 00       	call   80101a70 <writei>
++80101092:	85 c0                	test   %eax,%eax
++80101094:	7f 92                	jg     80101028 <filewrite+0x48>
++      iunlock(f->ip);
++80101096:	8b 4f 10             	mov    0x10(%edi),%ecx
++80101099:	89 45 e0             	mov    %eax,-0x20(%ebp)
++8010109c:	89 0c 24             	mov    %ecx,(%esp)
++8010109f:	e8 fc 06 00 00       	call   801017a0 <iunlock>
++      end_op();
++801010a4:	e8 e7 1a 00 00       	call   80102b90 <end_op>
++      if(r < 0)
++801010a9:	8b 45 e0             	mov    -0x20(%ebp),%eax
++801010ac:	85 c0                	test   %eax,%eax
++801010ae:	74 91                	je     80101041 <filewrite+0x61>
++    }
++    return i == n ? n : -1;
++  }
++  panic("filewrite");
++}
++801010b0:	83 c4 2c             	add    $0x2c,%esp
++    return -1;
++801010b3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++}
++801010b8:	5b                   	pop    %ebx
++801010b9:	5e                   	pop    %esi
++801010ba:	5f                   	pop    %edi
++801010bb:	5d                   	pop    %ebp
++801010bc:	c3                   	ret    
++801010bd:	8d 76 00             	lea    0x0(%esi),%esi
++    return i == n ? n : -1;
++801010c0:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
++801010c3:	89 d8                	mov    %ebx,%eax
++801010c5:	75 e9                	jne    801010b0 <filewrite+0xd0>
++}
++801010c7:	83 c4 2c             	add    $0x2c,%esp
++801010ca:	5b                   	pop    %ebx
++801010cb:	5e                   	pop    %esi
++801010cc:	5f                   	pop    %edi
++801010cd:	5d                   	pop    %ebp
++801010ce:	c3                   	ret    
++    return pipewrite(f->pipe, addr, n);
++801010cf:	8b 47 0c             	mov    0xc(%edi),%eax
++801010d2:	89 45 08             	mov    %eax,0x8(%ebp)
++}
++801010d5:	83 c4 2c             	add    $0x2c,%esp
++801010d8:	5b                   	pop    %ebx
++801010d9:	5e                   	pop    %esi
++801010da:	5f                   	pop    %edi
++801010db:	5d                   	pop    %ebp
++    return pipewrite(f->pipe, addr, n);
++801010dc:	e9 1f 22 00 00       	jmp    80103300 <pipewrite>
++        panic("short filewrite");
++801010e1:	c7 04 24 cf 6d 10 80 	movl   $0x80106dcf,(%esp)
++801010e8:	e8 73 f2 ff ff       	call   80100360 <panic>
++  panic("filewrite");
++801010ed:	c7 04 24 d5 6d 10 80 	movl   $0x80106dd5,(%esp)
++801010f4:	e8 67 f2 ff ff       	call   80100360 <panic>
++801010f9:	66 90                	xchg   %ax,%ax
++801010fb:	66 90                	xchg   %ax,%ax
++801010fd:	66 90                	xchg   %ax,%ax
++801010ff:	90                   	nop
++
++80101100 <balloc>:
++// Blocks.
++
++// Allocate a zeroed disk block.
++static uint
++balloc(uint dev)
++{
++80101100:	55                   	push   %ebp
++80101101:	89 e5                	mov    %esp,%ebp
++80101103:	57                   	push   %edi
++80101104:	56                   	push   %esi
++80101105:	53                   	push   %ebx
++80101106:	83 ec 2c             	sub    $0x2c,%esp
++80101109:	89 45 d8             	mov    %eax,-0x28(%ebp)
++  int b, bi, m;
++  struct buf *bp;
++
++  bp = 0;
++  for(b = 0; b < sb.size; b += BPB){
++8010110c:	a1 c0 09 11 80       	mov    0x801109c0,%eax
++80101111:	85 c0                	test   %eax,%eax
++80101113:	0f 84 8c 00 00 00    	je     801011a5 <balloc+0xa5>
++80101119:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
++    bp = bread(dev, BBLOCK(b, sb));
++80101120:	8b 75 dc             	mov    -0x24(%ebp),%esi
++80101123:	89 f0                	mov    %esi,%eax
++80101125:	c1 f8 0c             	sar    $0xc,%eax
++80101128:	03 05 d8 09 11 80    	add    0x801109d8,%eax
++8010112e:	89 44 24 04          	mov    %eax,0x4(%esp)
++80101132:	8b 45 d8             	mov    -0x28(%ebp),%eax
++80101135:	89 04 24             	mov    %eax,(%esp)
++80101138:	e8 93 ef ff ff       	call   801000d0 <bread>
++8010113d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++80101140:	a1 c0 09 11 80       	mov    0x801109c0,%eax
++80101145:	89 45 e0             	mov    %eax,-0x20(%ebp)
++    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
++80101148:	31 c0                	xor    %eax,%eax
++8010114a:	eb 33                	jmp    8010117f <balloc+0x7f>
++8010114c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++      m = 1 << (bi % 8);
++      if((bp->data[bi/8] & m) == 0){  // Is block free?
++80101150:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
++80101153:	89 c2                	mov    %eax,%edx
++      m = 1 << (bi % 8);
++80101155:	89 c1                	mov    %eax,%ecx
++      if((bp->data[bi/8] & m) == 0){  // Is block free?
++80101157:	c1 fa 03             	sar    $0x3,%edx
++      m = 1 << (bi % 8);
++8010115a:	83 e1 07             	and    $0x7,%ecx
++8010115d:	bf 01 00 00 00       	mov    $0x1,%edi
++80101162:	d3 e7                	shl    %cl,%edi
++      if((bp->data[bi/8] & m) == 0){  // Is block free?
++80101164:	0f b6 5c 13 5c       	movzbl 0x5c(%ebx,%edx,1),%ebx
++      m = 1 << (bi % 8);
++80101169:	89 f9                	mov    %edi,%ecx
++      if((bp->data[bi/8] & m) == 0){  // Is block free?
++8010116b:	0f b6 fb             	movzbl %bl,%edi
++8010116e:	85 cf                	test   %ecx,%edi
++80101170:	74 46                	je     801011b8 <balloc+0xb8>
++    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
++80101172:	83 c0 01             	add    $0x1,%eax
++80101175:	83 c6 01             	add    $0x1,%esi
++80101178:	3d 00 10 00 00       	cmp    $0x1000,%eax
++8010117d:	74 05                	je     80101184 <balloc+0x84>
++8010117f:	3b 75 e0             	cmp    -0x20(%ebp),%esi
++80101182:	72 cc                	jb     80101150 <balloc+0x50>
++        brelse(bp);
++        bzero(dev, b + bi);
++        return b + bi;
++      }
++    }
++    brelse(bp);
++80101184:	8b 45 e4             	mov    -0x1c(%ebp),%eax
++80101187:	89 04 24             	mov    %eax,(%esp)
++8010118a:	e8 51 f0 ff ff       	call   801001e0 <brelse>
++  for(b = 0; b < sb.size; b += BPB){
++8010118f:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
++80101196:	8b 45 dc             	mov    -0x24(%ebp),%eax
++80101199:	3b 05 c0 09 11 80    	cmp    0x801109c0,%eax
++8010119f:	0f 82 7b ff ff ff    	jb     80101120 <balloc+0x20>
++  }
++  panic("balloc: out of blocks");
++801011a5:	c7 04 24 df 6d 10 80 	movl   $0x80106ddf,(%esp)
++801011ac:	e8 af f1 ff ff       	call   80100360 <panic>
++801011b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++        bp->data[bi/8] |= m;  // Mark block in use.
++801011b8:	09 d9                	or     %ebx,%ecx
++801011ba:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
++801011bd:	88 4c 13 5c          	mov    %cl,0x5c(%ebx,%edx,1)
++        log_write(bp);
++801011c1:	89 1c 24             	mov    %ebx,(%esp)
++801011c4:	e8 f7 1a 00 00       	call   80102cc0 <log_write>
++        brelse(bp);
++801011c9:	89 1c 24             	mov    %ebx,(%esp)
++801011cc:	e8 0f f0 ff ff       	call   801001e0 <brelse>
++  bp = bread(dev, bno);
++801011d1:	8b 45 d8             	mov    -0x28(%ebp),%eax
++801011d4:	89 74 24 04          	mov    %esi,0x4(%esp)
++801011d8:	89 04 24             	mov    %eax,(%esp)
++801011db:	e8 f0 ee ff ff       	call   801000d0 <bread>
++  memset(bp->data, 0, BSIZE);
++801011e0:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
++801011e7:	00 
++801011e8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
++801011ef:	00 
++  bp = bread(dev, bno);
++801011f0:	89 c3                	mov    %eax,%ebx
++  memset(bp->data, 0, BSIZE);
++801011f2:	8d 40 5c             	lea    0x5c(%eax),%eax
++801011f5:	89 04 24             	mov    %eax,(%esp)
++801011f8:	e8 93 30 00 00       	call   80104290 <memset>
++  log_write(bp);
++801011fd:	89 1c 24             	mov    %ebx,(%esp)
++80101200:	e8 bb 1a 00 00       	call   80102cc0 <log_write>
++  brelse(bp);
++80101205:	89 1c 24             	mov    %ebx,(%esp)
++80101208:	e8 d3 ef ff ff       	call   801001e0 <brelse>
++}
++8010120d:	83 c4 2c             	add    $0x2c,%esp
++80101210:	89 f0                	mov    %esi,%eax
++80101212:	5b                   	pop    %ebx
++80101213:	5e                   	pop    %esi
++80101214:	5f                   	pop    %edi
++80101215:	5d                   	pop    %ebp
++80101216:	c3                   	ret    
++80101217:	89 f6                	mov    %esi,%esi
++80101219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++80101220 <iget>:
++// Find the inode with number inum on device dev
++// and return the in-memory copy. Does not lock
++// the inode and does not read it from disk.
++static struct inode*
++iget(uint dev, uint inum)
++{
++80101220:	55                   	push   %ebp
++80101221:	89 e5                	mov    %esp,%ebp
++80101223:	57                   	push   %edi
++80101224:	89 c7                	mov    %eax,%edi
++80101226:	56                   	push   %esi
++  struct inode *ip, *empty;
++
++  acquire(&icache.lock);
++
++  // Is the inode already cached?
++  empty = 0;
++80101227:	31 f6                	xor    %esi,%esi
++{
++80101229:	53                   	push   %ebx
++  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
++8010122a:	bb 14 0a 11 80       	mov    $0x80110a14,%ebx
++{
++8010122f:	83 ec 1c             	sub    $0x1c,%esp
++  acquire(&icache.lock);
++80101232:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
++{
++80101239:	89 55 e4             	mov    %edx,-0x1c(%ebp)
++  acquire(&icache.lock);
++8010123c:	e8 0f 2f 00 00       	call   80104150 <acquire>
++  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
++80101241:	8b 55 e4             	mov    -0x1c(%ebp),%edx
++80101244:	eb 14                	jmp    8010125a <iget+0x3a>
++80101246:	66 90                	xchg   %ax,%ax
++    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
++      ip->ref++;
++      release(&icache.lock);
++      return ip;
++    }
++    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
++80101248:	85 f6                	test   %esi,%esi
++8010124a:	74 3c                	je     80101288 <iget+0x68>
++  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
++8010124c:	81 c3 90 00 00 00    	add    $0x90,%ebx
++80101252:	81 fb 34 26 11 80    	cmp    $0x80112634,%ebx
++80101258:	74 46                	je     801012a0 <iget+0x80>
++    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
++8010125a:	8b 4b 08             	mov    0x8(%ebx),%ecx
++8010125d:	85 c9                	test   %ecx,%ecx
++8010125f:	7e e7                	jle    80101248 <iget+0x28>
++80101261:	39 3b                	cmp    %edi,(%ebx)
++80101263:	75 e3                	jne    80101248 <iget+0x28>
++80101265:	39 53 04             	cmp    %edx,0x4(%ebx)
++80101268:	75 de                	jne    80101248 <iget+0x28>
++      ip->ref++;
++8010126a:	83 c1 01             	add    $0x1,%ecx
++      return ip;
++8010126d:	89 de                	mov    %ebx,%esi
++      release(&icache.lock);
++8010126f:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
++      ip->ref++;
++80101276:	89 4b 08             	mov    %ecx,0x8(%ebx)
++      release(&icache.lock);
++80101279:	e8 c2 2f 00 00       	call   80104240 <release>
++  ip->ref = 1;
++  ip->valid = 0;
++  release(&icache.lock);
++
++  return ip;
++}
++8010127e:	83 c4 1c             	add    $0x1c,%esp
++80101281:	89 f0                	mov    %esi,%eax
++80101283:	5b                   	pop    %ebx
++80101284:	5e                   	pop    %esi
++80101285:	5f                   	pop    %edi
++80101286:	5d                   	pop    %ebp
++80101287:	c3                   	ret    
++80101288:	85 c9                	test   %ecx,%ecx
++8010128a:	0f 44 f3             	cmove  %ebx,%esi
++  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
++8010128d:	81 c3 90 00 00 00    	add    $0x90,%ebx
++80101293:	81 fb 34 26 11 80    	cmp    $0x80112634,%ebx
++80101299:	75 bf                	jne    8010125a <iget+0x3a>
++8010129b:	90                   	nop
++8010129c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++  if(empty == 0)
++801012a0:	85 f6                	test   %esi,%esi
++801012a2:	74 29                	je     801012cd <iget+0xad>
++  ip->dev = dev;
++801012a4:	89 3e                	mov    %edi,(%esi)
++  ip->inum = inum;
++801012a6:	89 56 04             	mov    %edx,0x4(%esi)
++  ip->ref = 1;
++801012a9:	c7 46 08 01 00 00 00 	movl   $0x1,0x8(%esi)
++  ip->valid = 0;
++801012b0:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
++  release(&icache.lock);
++801012b7:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
++801012be:	e8 7d 2f 00 00       	call   80104240 <release>
++}
++801012c3:	83 c4 1c             	add    $0x1c,%esp
++801012c6:	89 f0                	mov    %esi,%eax
++801012c8:	5b                   	pop    %ebx
++801012c9:	5e                   	pop    %esi
++801012ca:	5f                   	pop    %edi
++801012cb:	5d                   	pop    %ebp
++801012cc:	c3                   	ret    
++    panic("iget: no inodes");
++801012cd:	c7 04 24 f5 6d 10 80 	movl   $0x80106df5,(%esp)
++801012d4:	e8 87 f0 ff ff       	call   80100360 <panic>
++801012d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++
++801012e0 <bmap>:
++
++// Return the disk block address of the nth block in inode ip.
++// If there is no such block, bmap allocates one.
++static uint
++bmap(struct inode *ip, uint bn)
++{
++801012e0:	55                   	push   %ebp
++801012e1:	89 e5                	mov    %esp,%ebp
++801012e3:	57                   	push   %edi
++801012e4:	56                   	push   %esi
++801012e5:	53                   	push   %ebx
++801012e6:	89 c3                	mov    %eax,%ebx
++801012e8:	83 ec 1c             	sub    $0x1c,%esp
++  uint addr, *a;
++  struct buf *bp;
++
++  if(bn < NDIRECT){
++801012eb:	83 fa 0b             	cmp    $0xb,%edx
++801012ee:	77 18                	ja     80101308 <bmap+0x28>
++801012f0:	8d 34 90             	lea    (%eax,%edx,4),%esi
++    if((addr = ip->addrs[bn]) == 0)
++801012f3:	8b 46 5c             	mov    0x5c(%esi),%eax
++801012f6:	85 c0                	test   %eax,%eax
++801012f8:	74 66                	je     80101360 <bmap+0x80>
++    brelse(bp);
++    return addr;
++  }
++
++  panic("bmap: out of range");
++}
++801012fa:	83 c4 1c             	add    $0x1c,%esp
++801012fd:	5b                   	pop    %ebx
++801012fe:	5e                   	pop    %esi
++801012ff:	5f                   	pop    %edi
++80101300:	5d                   	pop    %ebp
++80101301:	c3                   	ret    
++80101302:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++  bn -= NDIRECT;
++80101308:	8d 72 f4             	lea    -0xc(%edx),%esi
++  if(bn < NINDIRECT){
++8010130b:	83 fe 7f             	cmp    $0x7f,%esi
++8010130e:	77 77                	ja     80101387 <bmap+0xa7>
++    if((addr = ip->addrs[NDIRECT]) == 0)
++80101310:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
++80101316:	85 c0                	test   %eax,%eax
++80101318:	74 5e                	je     80101378 <bmap+0x98>
++    bp = bread(ip->dev, addr);
++8010131a:	89 44 24 04          	mov    %eax,0x4(%esp)
++8010131e:	8b 03                	mov    (%ebx),%eax
++80101320:	89 04 24             	mov    %eax,(%esp)
++80101323:	e8 a8 ed ff ff       	call   801000d0 <bread>
++    if((addr = a[bn]) == 0){
++80101328:	8d 54 b0 5c          	lea    0x5c(%eax,%esi,4),%edx
++    bp = bread(ip->dev, addr);
++8010132c:	89 c7                	mov    %eax,%edi
++    if((addr = a[bn]) == 0){
++8010132e:	8b 32                	mov    (%edx),%esi
++80101330:	85 f6                	test   %esi,%esi
++80101332:	75 19                	jne    8010134d <bmap+0x6d>
++      a[bn] = addr = balloc(ip->dev);
++80101334:	8b 03                	mov    (%ebx),%eax
++80101336:	89 55 e4             	mov    %edx,-0x1c(%ebp)
++80101339:	e8 c2 fd ff ff       	call   80101100 <balloc>
++8010133e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
++80101341:	89 02                	mov    %eax,(%edx)
++80101343:	89 c6                	mov    %eax,%esi
++      log_write(bp);
++80101345:	89 3c 24             	mov    %edi,(%esp)
++80101348:	e8 73 19 00 00       	call   80102cc0 <log_write>
++    brelse(bp);
++8010134d:	89 3c 24             	mov    %edi,(%esp)
++80101350:	e8 8b ee ff ff       	call   801001e0 <brelse>
++}
++80101355:	83 c4 1c             	add    $0x1c,%esp
++    brelse(bp);
++80101358:	89 f0                	mov    %esi,%eax
++}
++8010135a:	5b                   	pop    %ebx
++8010135b:	5e                   	pop    %esi
++8010135c:	5f                   	pop    %edi
++8010135d:	5d                   	pop    %ebp
++8010135e:	c3                   	ret    
++8010135f:	90                   	nop
++      ip->addrs[bn] = addr = balloc(ip->dev);
++80101360:	8b 03                	mov    (%ebx),%eax
++80101362:	e8 99 fd ff ff       	call   80101100 <balloc>
++80101367:	89 46 5c             	mov    %eax,0x5c(%esi)
++}
++8010136a:	83 c4 1c             	add    $0x1c,%esp
++8010136d:	5b                   	pop    %ebx
++8010136e:	5e                   	pop    %esi
++8010136f:	5f                   	pop    %edi
++80101370:	5d                   	pop    %ebp
++80101371:	c3                   	ret    
++80101372:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
++80101378:	8b 03                	mov    (%ebx),%eax
++8010137a:	e8 81 fd ff ff       	call   80101100 <balloc>
++8010137f:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
++80101385:	eb 93                	jmp    8010131a <bmap+0x3a>
++  panic("bmap: out of range");
++80101387:	c7 04 24 05 6e 10 80 	movl   $0x80106e05,(%esp)
++8010138e:	e8 cd ef ff ff       	call   80100360 <panic>
++80101393:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++80101399:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++801013a0 <readsb>:
++{
++801013a0:	55                   	push   %ebp
++801013a1:	89 e5                	mov    %esp,%ebp
++801013a3:	56                   	push   %esi
++801013a4:	53                   	push   %ebx
++801013a5:	83 ec 10             	sub    $0x10,%esp
++  bp = bread(dev, 1);
++801013a8:	8b 45 08             	mov    0x8(%ebp),%eax
++801013ab:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
++801013b2:	00 
++{
++801013b3:	8b 75 0c             	mov    0xc(%ebp),%esi
++  bp = bread(dev, 1);
++801013b6:	89 04 24             	mov    %eax,(%esp)
++801013b9:	e8 12 ed ff ff       	call   801000d0 <bread>
++  memmove(sb, bp->data, sizeof(*sb));
++801013be:	89 34 24             	mov    %esi,(%esp)
++801013c1:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
++801013c8:	00 
++  bp = bread(dev, 1);
++801013c9:	89 c3                	mov    %eax,%ebx
++  memmove(sb, bp->data, sizeof(*sb));
++801013cb:	8d 40 5c             	lea    0x5c(%eax),%eax
++801013ce:	89 44 24 04          	mov    %eax,0x4(%esp)
++801013d2:	e8 59 2f 00 00       	call   80104330 <memmove>
++  brelse(bp);
++801013d7:	89 5d 08             	mov    %ebx,0x8(%ebp)
++}
++801013da:	83 c4 10             	add    $0x10,%esp
++801013dd:	5b                   	pop    %ebx
++801013de:	5e                   	pop    %esi
++801013df:	5d                   	pop    %ebp
++  brelse(bp);
++801013e0:	e9 fb ed ff ff       	jmp    801001e0 <brelse>
++801013e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++801013e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++801013f0 <bfree>:
++{
++801013f0:	55                   	push   %ebp
++801013f1:	89 e5                	mov    %esp,%ebp
++801013f3:	57                   	push   %edi
++801013f4:	89 d7                	mov    %edx,%edi
++801013f6:	56                   	push   %esi
++801013f7:	53                   	push   %ebx
++801013f8:	89 c3                	mov    %eax,%ebx
++801013fa:	83 ec 1c             	sub    $0x1c,%esp
++  readsb(dev, &sb);
++801013fd:	89 04 24             	mov    %eax,(%esp)
++80101400:	c7 44 24 04 c0 09 11 	movl   $0x801109c0,0x4(%esp)
++80101407:	80 
++80101408:	e8 93 ff ff ff       	call   801013a0 <readsb>
++  bp = bread(dev, BBLOCK(b, sb));
++8010140d:	89 fa                	mov    %edi,%edx
++8010140f:	c1 ea 0c             	shr    $0xc,%edx
++80101412:	03 15 d8 09 11 80    	add    0x801109d8,%edx
++80101418:	89 1c 24             	mov    %ebx,(%esp)
++  m = 1 << (bi % 8);
++8010141b:	bb 01 00 00 00       	mov    $0x1,%ebx
++  bp = bread(dev, BBLOCK(b, sb));
++80101420:	89 54 24 04          	mov    %edx,0x4(%esp)
++80101424:	e8 a7 ec ff ff       	call   801000d0 <bread>
++  m = 1 << (bi % 8);
++80101429:	89 f9                	mov    %edi,%ecx
++  bi = b % BPB;
++8010142b:	81 e7 ff 0f 00 00    	and    $0xfff,%edi
++80101431:	89 fa                	mov    %edi,%edx
++  m = 1 << (bi % 8);
++80101433:	83 e1 07             	and    $0x7,%ecx
++  if((bp->data[bi/8] & m) == 0)
++80101436:	c1 fa 03             	sar    $0x3,%edx
++  m = 1 << (bi % 8);
++80101439:	d3 e3                	shl    %cl,%ebx
++  bp = bread(dev, BBLOCK(b, sb));
++8010143b:	89 c6                	mov    %eax,%esi
++  if((bp->data[bi/8] & m) == 0)
++8010143d:	0f b6 44 10 5c       	movzbl 0x5c(%eax,%edx,1),%eax
++80101442:	0f b6 c8             	movzbl %al,%ecx
++80101445:	85 d9                	test   %ebx,%ecx
++80101447:	74 20                	je     80101469 <bfree+0x79>
++  bp->data[bi/8] &= ~m;
++80101449:	f7 d3                	not    %ebx
++8010144b:	21 c3                	and    %eax,%ebx
++8010144d:	88 5c 16 5c          	mov    %bl,0x5c(%esi,%edx,1)
++  log_write(bp);
++80101451:	89 34 24             	mov    %esi,(%esp)
++80101454:	e8 67 18 00 00       	call   80102cc0 <log_write>
++  brelse(bp);
++80101459:	89 34 24             	mov    %esi,(%esp)
++8010145c:	e8 7f ed ff ff       	call   801001e0 <brelse>
++}
++80101461:	83 c4 1c             	add    $0x1c,%esp
++80101464:	5b                   	pop    %ebx
++80101465:	5e                   	pop    %esi
++80101466:	5f                   	pop    %edi
++80101467:	5d                   	pop    %ebp
++80101468:	c3                   	ret    
++    panic("freeing free block");
++80101469:	c7 04 24 18 6e 10 80 	movl   $0x80106e18,(%esp)
++80101470:	e8 eb ee ff ff       	call   80100360 <panic>
++80101475:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++80101479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++80101480 <iinit>:
++{
++80101480:	55                   	push   %ebp
++80101481:	89 e5                	mov    %esp,%ebp
++80101483:	53                   	push   %ebx
++80101484:	bb 20 0a 11 80       	mov    $0x80110a20,%ebx
++80101489:	83 ec 24             	sub    $0x24,%esp
++  initlock(&icache.lock, "icache");
++8010148c:	c7 44 24 04 2b 6e 10 	movl   $0x80106e2b,0x4(%esp)
++80101493:	80 
++80101494:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
++8010149b:	e8 c0 2b 00 00       	call   80104060 <initlock>
++    initsleeplock(&icache.inode[i].lock, "inode");
++801014a0:	89 1c 24             	mov    %ebx,(%esp)
++801014a3:	81 c3 90 00 00 00    	add    $0x90,%ebx
++801014a9:	c7 44 24 04 32 6e 10 	movl   $0x80106e32,0x4(%esp)
++801014b0:	80 
++801014b1:	e8 9a 2a 00 00       	call   80103f50 <initsleeplock>
++  for(i = 0; i < NINODE; i++) {
++801014b6:	81 fb 40 26 11 80    	cmp    $0x80112640,%ebx
++801014bc:	75 e2                	jne    801014a0 <iinit+0x20>
++  readsb(dev, &sb);
++801014be:	8b 45 08             	mov    0x8(%ebp),%eax
++801014c1:	c7 44 24 04 c0 09 11 	movl   $0x801109c0,0x4(%esp)
++801014c8:	80 
++801014c9:	89 04 24             	mov    %eax,(%esp)
++801014cc:	e8 cf fe ff ff       	call   801013a0 <readsb>
++  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
++801014d1:	a1 d8 09 11 80       	mov    0x801109d8,%eax
++801014d6:	c7 04 24 98 6e 10 80 	movl   $0x80106e98,(%esp)
++801014dd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
++801014e1:	a1 d4 09 11 80       	mov    0x801109d4,%eax
++801014e6:	89 44 24 18          	mov    %eax,0x18(%esp)
++801014ea:	a1 d0 09 11 80       	mov    0x801109d0,%eax
++801014ef:	89 44 24 14          	mov    %eax,0x14(%esp)
++801014f3:	a1 cc 09 11 80       	mov    0x801109cc,%eax
++801014f8:	89 44 24 10          	mov    %eax,0x10(%esp)
++801014fc:	a1 c8 09 11 80       	mov    0x801109c8,%eax
++80101501:	89 44 24 0c          	mov    %eax,0xc(%esp)
++80101505:	a1 c4 09 11 80       	mov    0x801109c4,%eax
++8010150a:	89 44 24 08          	mov    %eax,0x8(%esp)
++8010150e:	a1 c0 09 11 80       	mov    0x801109c0,%eax
++80101513:	89 44 24 04          	mov    %eax,0x4(%esp)
++80101517:	e8 34 f1 ff ff       	call   80100650 <cprintf>
++}
++8010151c:	83 c4 24             	add    $0x24,%esp
++8010151f:	5b                   	pop    %ebx
++80101520:	5d                   	pop    %ebp
++80101521:	c3                   	ret    
++80101522:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++80101529:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++80101530 <ialloc>:
++{
++80101530:	55                   	push   %ebp
++80101531:	89 e5                	mov    %esp,%ebp
++80101533:	57                   	push   %edi
++80101534:	56                   	push   %esi
++80101535:	53                   	push   %ebx
++80101536:	83 ec 2c             	sub    $0x2c,%esp
++80101539:	8b 45 0c             	mov    0xc(%ebp),%eax
++  for(inum = 1; inum < sb.ninodes; inum++){
++8010153c:	83 3d c8 09 11 80 01 	cmpl   $0x1,0x801109c8
++{
++80101543:	8b 7d 08             	mov    0x8(%ebp),%edi
++80101546:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++  for(inum = 1; inum < sb.ninodes; inum++){
++80101549:	0f 86 a2 00 00 00    	jbe    801015f1 <ialloc+0xc1>
++8010154f:	be 01 00 00 00       	mov    $0x1,%esi
++80101554:	bb 01 00 00 00       	mov    $0x1,%ebx
++80101559:	eb 1a                	jmp    80101575 <ialloc+0x45>
++8010155b:	90                   	nop
++8010155c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    brelse(bp);
++80101560:	89 14 24             	mov    %edx,(%esp)
++  for(inum = 1; inum < sb.ninodes; inum++){
++80101563:	83 c3 01             	add    $0x1,%ebx
++    brelse(bp);
++80101566:	e8 75 ec ff ff       	call   801001e0 <brelse>
++  for(inum = 1; inum < sb.ninodes; inum++){
++8010156b:	89 de                	mov    %ebx,%esi
++8010156d:	3b 1d c8 09 11 80    	cmp    0x801109c8,%ebx
++80101573:	73 7c                	jae    801015f1 <ialloc+0xc1>
++    bp = bread(dev, IBLOCK(inum, sb));
++80101575:	89 f0                	mov    %esi,%eax
++80101577:	c1 e8 03             	shr    $0x3,%eax
++8010157a:	03 05 d4 09 11 80    	add    0x801109d4,%eax
++80101580:	89 3c 24             	mov    %edi,(%esp)
++80101583:	89 44 24 04          	mov    %eax,0x4(%esp)
++80101587:	e8 44 eb ff ff       	call   801000d0 <bread>
++8010158c:	89 c2                	mov    %eax,%edx
++    dip = (struct dinode*)bp->data + inum%IPB;
++8010158e:	89 f0                	mov    %esi,%eax
++80101590:	83 e0 07             	and    $0x7,%eax
++80101593:	c1 e0 06             	shl    $0x6,%eax
++80101596:	8d 4c 02 5c          	lea    0x5c(%edx,%eax,1),%ecx
++    if(dip->type == 0){  // a free inode
++8010159a:	66 83 39 00          	cmpw   $0x0,(%ecx)
++8010159e:	75 c0                	jne    80101560 <ialloc+0x30>
++      memset(dip, 0, sizeof(*dip));
++801015a0:	89 0c 24             	mov    %ecx,(%esp)
++801015a3:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
++801015aa:	00 
++801015ab:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
++801015b2:	00 
++801015b3:	89 55 dc             	mov    %edx,-0x24(%ebp)
++801015b6:	89 4d e0             	mov    %ecx,-0x20(%ebp)
++801015b9:	e8 d2 2c 00 00       	call   80104290 <memset>
++      dip->type = type;
++801015be:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
++      log_write(bp);   // mark it allocated on the disk
++801015c2:	8b 55 dc             	mov    -0x24(%ebp),%edx
++      dip->type = type;
++801015c5:	8b 4d e0             	mov    -0x20(%ebp),%ecx
++      log_write(bp);   // mark it allocated on the disk
++801015c8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
++      dip->type = type;
++801015cb:	66 89 01             	mov    %ax,(%ecx)
++      log_write(bp);   // mark it allocated on the disk
++801015ce:	89 14 24             	mov    %edx,(%esp)
++801015d1:	e8 ea 16 00 00       	call   80102cc0 <log_write>
++      brelse(bp);
++801015d6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
++801015d9:	89 14 24             	mov    %edx,(%esp)
++801015dc:	e8 ff eb ff ff       	call   801001e0 <brelse>
++}
++801015e1:	83 c4 2c             	add    $0x2c,%esp
++      return iget(dev, inum);
++801015e4:	89 f2                	mov    %esi,%edx
++}
++801015e6:	5b                   	pop    %ebx
++      return iget(dev, inum);
++801015e7:	89 f8                	mov    %edi,%eax
++}
++801015e9:	5e                   	pop    %esi
++801015ea:	5f                   	pop    %edi
++801015eb:	5d                   	pop    %ebp
++      return iget(dev, inum);
++801015ec:	e9 2f fc ff ff       	jmp    80101220 <iget>
++  panic("ialloc: no inodes");
++801015f1:	c7 04 24 38 6e 10 80 	movl   $0x80106e38,(%esp)
++801015f8:	e8 63 ed ff ff       	call   80100360 <panic>
++801015fd:	8d 76 00             	lea    0x0(%esi),%esi
++
++80101600 <iupdate>:
++{
++80101600:	55                   	push   %ebp
++80101601:	89 e5                	mov    %esp,%ebp
++80101603:	56                   	push   %esi
++80101604:	53                   	push   %ebx
++80101605:	83 ec 10             	sub    $0x10,%esp
++80101608:	8b 5d 08             	mov    0x8(%ebp),%ebx
++  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
++8010160b:	8b 43 04             	mov    0x4(%ebx),%eax
++  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
++8010160e:	83 c3 5c             	add    $0x5c,%ebx
++  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
++80101611:	c1 e8 03             	shr    $0x3,%eax
++80101614:	03 05 d4 09 11 80    	add    0x801109d4,%eax
++8010161a:	89 44 24 04          	mov    %eax,0x4(%esp)
++8010161e:	8b 43 a4             	mov    -0x5c(%ebx),%eax
++80101621:	89 04 24             	mov    %eax,(%esp)
++80101624:	e8 a7 ea ff ff       	call   801000d0 <bread>
++  dip = (struct dinode*)bp->data + ip->inum%IPB;
++80101629:	8b 53 a8             	mov    -0x58(%ebx),%edx
++8010162c:	83 e2 07             	and    $0x7,%edx
++8010162f:	c1 e2 06             	shl    $0x6,%edx
++80101632:	8d 54 10 5c          	lea    0x5c(%eax,%edx,1),%edx
++  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
++80101636:	89 c6                	mov    %eax,%esi
++  dip->type = ip->type;
++80101638:	0f b7 43 f4          	movzwl -0xc(%ebx),%eax
++  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
++8010163c:	83 c2 0c             	add    $0xc,%edx
++  dip->type = ip->type;
++8010163f:	66 89 42 f4          	mov    %ax,-0xc(%edx)
++  dip->major = ip->major;
++80101643:	0f b7 43 f6          	movzwl -0xa(%ebx),%eax
++80101647:	66 89 42 f6          	mov    %ax,-0xa(%edx)
++  dip->minor = ip->minor;
++8010164b:	0f b7 43 f8          	movzwl -0x8(%ebx),%eax
++8010164f:	66 89 42 f8          	mov    %ax,-0x8(%edx)
++  dip->nlink = ip->nlink;
++80101653:	0f b7 43 fa          	movzwl -0x6(%ebx),%eax
++80101657:	66 89 42 fa          	mov    %ax,-0x6(%edx)
++  dip->size = ip->size;
++8010165b:	8b 43 fc             	mov    -0x4(%ebx),%eax
++8010165e:	89 42 fc             	mov    %eax,-0x4(%edx)
++  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
++80101661:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++80101665:	89 14 24             	mov    %edx,(%esp)
++80101668:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
++8010166f:	00 
++80101670:	e8 bb 2c 00 00       	call   80104330 <memmove>
++  log_write(bp);
++80101675:	89 34 24             	mov    %esi,(%esp)
++80101678:	e8 43 16 00 00       	call   80102cc0 <log_write>
++  brelse(bp);
++8010167d:	89 75 08             	mov    %esi,0x8(%ebp)
++}
++80101680:	83 c4 10             	add    $0x10,%esp
++80101683:	5b                   	pop    %ebx
++80101684:	5e                   	pop    %esi
++80101685:	5d                   	pop    %ebp
++  brelse(bp);
++80101686:	e9 55 eb ff ff       	jmp    801001e0 <brelse>
++8010168b:	90                   	nop
++8010168c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++
++80101690 <idup>:
++{
++80101690:	55                   	push   %ebp
++80101691:	89 e5                	mov    %esp,%ebp
++80101693:	53                   	push   %ebx
++80101694:	83 ec 14             	sub    $0x14,%esp
++80101697:	8b 5d 08             	mov    0x8(%ebp),%ebx
++  acquire(&icache.lock);
++8010169a:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
++801016a1:	e8 aa 2a 00 00       	call   80104150 <acquire>
++  ip->ref++;
++801016a6:	83 43 08 01          	addl   $0x1,0x8(%ebx)
++  release(&icache.lock);
++801016aa:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
++801016b1:	e8 8a 2b 00 00       	call   80104240 <release>
++}
++801016b6:	83 c4 14             	add    $0x14,%esp
++801016b9:	89 d8                	mov    %ebx,%eax
++801016bb:	5b                   	pop    %ebx
++801016bc:	5d                   	pop    %ebp
++801016bd:	c3                   	ret    
++801016be:	66 90                	xchg   %ax,%ax
++
++801016c0 <ilock>:
++{
++801016c0:	55                   	push   %ebp
++801016c1:	89 e5                	mov    %esp,%ebp
++801016c3:	56                   	push   %esi
++801016c4:	53                   	push   %ebx
++801016c5:	83 ec 10             	sub    $0x10,%esp
++801016c8:	8b 5d 08             	mov    0x8(%ebp),%ebx
++  if(ip == 0 || ip->ref < 1)
++801016cb:	85 db                	test   %ebx,%ebx
++801016cd:	0f 84 b3 00 00 00    	je     80101786 <ilock+0xc6>
++801016d3:	8b 53 08             	mov    0x8(%ebx),%edx
++801016d6:	85 d2                	test   %edx,%edx
++801016d8:	0f 8e a8 00 00 00    	jle    80101786 <ilock+0xc6>
++  acquiresleep(&ip->lock);
++801016de:	8d 43 0c             	lea    0xc(%ebx),%eax
++801016e1:	89 04 24             	mov    %eax,(%esp)
++801016e4:	e8 a7 28 00 00       	call   80103f90 <acquiresleep>
++  if(ip->valid == 0){
++801016e9:	8b 43 4c             	mov    0x4c(%ebx),%eax
++801016ec:	85 c0                	test   %eax,%eax
++801016ee:	74 08                	je     801016f8 <ilock+0x38>
++}
++801016f0:	83 c4 10             	add    $0x10,%esp
++801016f3:	5b                   	pop    %ebx
++801016f4:	5e                   	pop    %esi
++801016f5:	5d                   	pop    %ebp
++801016f6:	c3                   	ret    
++801016f7:	90                   	nop
++    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
++801016f8:	8b 43 04             	mov    0x4(%ebx),%eax
++801016fb:	c1 e8 03             	shr    $0x3,%eax
++801016fe:	03 05 d4 09 11 80    	add    0x801109d4,%eax
++80101704:	89 44 24 04          	mov    %eax,0x4(%esp)
++80101708:	8b 03                	mov    (%ebx),%eax
++8010170a:	89 04 24             	mov    %eax,(%esp)
++8010170d:	e8 be e9 ff ff       	call   801000d0 <bread>
++    dip = (struct dinode*)bp->data + ip->inum%IPB;
++80101712:	8b 53 04             	mov    0x4(%ebx),%edx
++80101715:	83 e2 07             	and    $0x7,%edx
++80101718:	c1 e2 06             	shl    $0x6,%edx
++8010171b:	8d 54 10 5c          	lea    0x5c(%eax,%edx,1),%edx
++    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
++8010171f:	89 c6                	mov    %eax,%esi
++    ip->type = dip->type;
++80101721:	0f b7 02             	movzwl (%edx),%eax
++    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
++80101724:	83 c2 0c             	add    $0xc,%edx
++    ip->type = dip->type;
++80101727:	66 89 43 50          	mov    %ax,0x50(%ebx)
++    ip->major = dip->major;
++8010172b:	0f b7 42 f6          	movzwl -0xa(%edx),%eax
++8010172f:	66 89 43 52          	mov    %ax,0x52(%ebx)
++    ip->minor = dip->minor;
++80101733:	0f b7 42 f8          	movzwl -0x8(%edx),%eax
++80101737:	66 89 43 54          	mov    %ax,0x54(%ebx)
++    ip->nlink = dip->nlink;
++8010173b:	0f b7 42 fa          	movzwl -0x6(%edx),%eax
++8010173f:	66 89 43 56          	mov    %ax,0x56(%ebx)
++    ip->size = dip->size;
++80101743:	8b 42 fc             	mov    -0x4(%edx),%eax
++80101746:	89 43 58             	mov    %eax,0x58(%ebx)
++    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
++80101749:	8d 43 5c             	lea    0x5c(%ebx),%eax
++8010174c:	89 54 24 04          	mov    %edx,0x4(%esp)
++80101750:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
++80101757:	00 
++80101758:	89 04 24             	mov    %eax,(%esp)
++8010175b:	e8 d0 2b 00 00       	call   80104330 <memmove>
++    brelse(bp);
++80101760:	89 34 24             	mov    %esi,(%esp)
++80101763:	e8 78 ea ff ff       	call   801001e0 <brelse>
++    if(ip->type == 0)
++80101768:	66 83 7b 50 00       	cmpw   $0x0,0x50(%ebx)
++    ip->valid = 1;
++8010176d:	c7 43 4c 01 00 00 00 	movl   $0x1,0x4c(%ebx)
++    if(ip->type == 0)
++80101774:	0f 85 76 ff ff ff    	jne    801016f0 <ilock+0x30>
++      panic("ilock: no type");
++8010177a:	c7 04 24 50 6e 10 80 	movl   $0x80106e50,(%esp)
++80101781:	e8 da eb ff ff       	call   80100360 <panic>
++    panic("ilock");
++80101786:	c7 04 24 4a 6e 10 80 	movl   $0x80106e4a,(%esp)
++8010178d:	e8 ce eb ff ff       	call   80100360 <panic>
++80101792:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++80101799:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++801017a0 <iunlock>:
++{
++801017a0:	55                   	push   %ebp
++801017a1:	89 e5                	mov    %esp,%ebp
++801017a3:	56                   	push   %esi
++801017a4:	53                   	push   %ebx
++801017a5:	83 ec 10             	sub    $0x10,%esp
++801017a8:	8b 5d 08             	mov    0x8(%ebp),%ebx
++  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
++801017ab:	85 db                	test   %ebx,%ebx
++801017ad:	74 24                	je     801017d3 <iunlock+0x33>
++801017af:	8d 73 0c             	lea    0xc(%ebx),%esi
++801017b2:	89 34 24             	mov    %esi,(%esp)
++801017b5:	e8 76 28 00 00       	call   80104030 <holdingsleep>
++801017ba:	85 c0                	test   %eax,%eax
++801017bc:	74 15                	je     801017d3 <iunlock+0x33>
++801017be:	8b 43 08             	mov    0x8(%ebx),%eax
++801017c1:	85 c0                	test   %eax,%eax
++801017c3:	7e 0e                	jle    801017d3 <iunlock+0x33>
++  releasesleep(&ip->lock);
++801017c5:	89 75 08             	mov    %esi,0x8(%ebp)
++}
++801017c8:	83 c4 10             	add    $0x10,%esp
++801017cb:	5b                   	pop    %ebx
++801017cc:	5e                   	pop    %esi
++801017cd:	5d                   	pop    %ebp
++  releasesleep(&ip->lock);
++801017ce:	e9 1d 28 00 00       	jmp    80103ff0 <releasesleep>
++    panic("iunlock");
++801017d3:	c7 04 24 5f 6e 10 80 	movl   $0x80106e5f,(%esp)
++801017da:	e8 81 eb ff ff       	call   80100360 <panic>
++801017df:	90                   	nop
++
++801017e0 <iput>:
++{
++801017e0:	55                   	push   %ebp
++801017e1:	89 e5                	mov    %esp,%ebp
++801017e3:	57                   	push   %edi
++801017e4:	56                   	push   %esi
++801017e5:	53                   	push   %ebx
++801017e6:	83 ec 1c             	sub    $0x1c,%esp
++801017e9:	8b 75 08             	mov    0x8(%ebp),%esi
++  acquiresleep(&ip->lock);
++801017ec:	8d 7e 0c             	lea    0xc(%esi),%edi
++801017ef:	89 3c 24             	mov    %edi,(%esp)
++801017f2:	e8 99 27 00 00       	call   80103f90 <acquiresleep>
++  if(ip->valid && ip->nlink == 0){
++801017f7:	8b 56 4c             	mov    0x4c(%esi),%edx
++801017fa:	85 d2                	test   %edx,%edx
++801017fc:	74 07                	je     80101805 <iput+0x25>
++801017fe:	66 83 7e 56 00       	cmpw   $0x0,0x56(%esi)
++80101803:	74 2b                	je     80101830 <iput+0x50>
++  releasesleep(&ip->lock);
++80101805:	89 3c 24             	mov    %edi,(%esp)
++80101808:	e8 e3 27 00 00       	call   80103ff0 <releasesleep>
++  acquire(&icache.lock);
++8010180d:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
++80101814:	e8 37 29 00 00       	call   80104150 <acquire>
++  ip->ref--;
++80101819:	83 6e 08 01          	subl   $0x1,0x8(%esi)
++  release(&icache.lock);
++8010181d:	c7 45 08 e0 09 11 80 	movl   $0x801109e0,0x8(%ebp)
++}
++80101824:	83 c4 1c             	add    $0x1c,%esp
++80101827:	5b                   	pop    %ebx
++80101828:	5e                   	pop    %esi
++80101829:	5f                   	pop    %edi
++8010182a:	5d                   	pop    %ebp
++  release(&icache.lock);
++8010182b:	e9 10 2a 00 00       	jmp    80104240 <release>
++    acquire(&icache.lock);
++80101830:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
++80101837:	e8 14 29 00 00       	call   80104150 <acquire>
++    int r = ip->ref;
++8010183c:	8b 5e 08             	mov    0x8(%esi),%ebx
++    release(&icache.lock);
++8010183f:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
++80101846:	e8 f5 29 00 00       	call   80104240 <release>
++    if(r == 1){
++8010184b:	83 fb 01             	cmp    $0x1,%ebx
++8010184e:	75 b5                	jne    80101805 <iput+0x25>
++80101850:	8d 4e 30             	lea    0x30(%esi),%ecx
++80101853:	89 f3                	mov    %esi,%ebx
++80101855:	89 7d e4             	mov    %edi,-0x1c(%ebp)
++80101858:	89 cf                	mov    %ecx,%edi
++8010185a:	eb 0b                	jmp    80101867 <iput+0x87>
++8010185c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++80101860:	83 c3 04             	add    $0x4,%ebx
++{
++  int i, j;
++  struct buf *bp;
++  uint *a;
++
++  for(i = 0; i < NDIRECT; i++){
++80101863:	39 fb                	cmp    %edi,%ebx
++80101865:	74 19                	je     80101880 <iput+0xa0>
++    if(ip->addrs[i]){
++80101867:	8b 53 5c             	mov    0x5c(%ebx),%edx
++8010186a:	85 d2                	test   %edx,%edx
++8010186c:	74 f2                	je     80101860 <iput+0x80>
++      bfree(ip->dev, ip->addrs[i]);
++8010186e:	8b 06                	mov    (%esi),%eax
++80101870:	e8 7b fb ff ff       	call   801013f0 <bfree>
++      ip->addrs[i] = 0;
++80101875:	c7 43 5c 00 00 00 00 	movl   $0x0,0x5c(%ebx)
++8010187c:	eb e2                	jmp    80101860 <iput+0x80>
++8010187e:	66 90                	xchg   %ax,%ax
++    }
++  }
++
++  if(ip->addrs[NDIRECT]){
++80101880:	8b 86 8c 00 00 00    	mov    0x8c(%esi),%eax
++80101886:	8b 7d e4             	mov    -0x1c(%ebp),%edi
++80101889:	85 c0                	test   %eax,%eax
++8010188b:	75 2b                	jne    801018b8 <iput+0xd8>
++    brelse(bp);
++    bfree(ip->dev, ip->addrs[NDIRECT]);
++    ip->addrs[NDIRECT] = 0;
++  }
++
++  ip->size = 0;
++8010188d:	c7 46 58 00 00 00 00 	movl   $0x0,0x58(%esi)
++  iupdate(ip);
++80101894:	89 34 24             	mov    %esi,(%esp)
++80101897:	e8 64 fd ff ff       	call   80101600 <iupdate>
++      ip->type = 0;
++8010189c:	31 c0                	xor    %eax,%eax
++8010189e:	66 89 46 50          	mov    %ax,0x50(%esi)
++      iupdate(ip);
++801018a2:	89 34 24             	mov    %esi,(%esp)
++801018a5:	e8 56 fd ff ff       	call   80101600 <iupdate>
++      ip->valid = 0;
++801018aa:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
++801018b1:	e9 4f ff ff ff       	jmp    80101805 <iput+0x25>
++801018b6:	66 90                	xchg   %ax,%ax
++    bp = bread(ip->dev, ip->addrs[NDIRECT]);
++801018b8:	89 44 24 04          	mov    %eax,0x4(%esp)
++801018bc:	8b 06                	mov    (%esi),%eax
++    for(j = 0; j < NINDIRECT; j++){
++801018be:	31 db                	xor    %ebx,%ebx
++    bp = bread(ip->dev, ip->addrs[NDIRECT]);
++801018c0:	89 04 24             	mov    %eax,(%esp)
++801018c3:	e8 08 e8 ff ff       	call   801000d0 <bread>
++    for(j = 0; j < NINDIRECT; j++){
++801018c8:	89 7d e0             	mov    %edi,-0x20(%ebp)
++    a = (uint*)bp->data;
++801018cb:	8d 48 5c             	lea    0x5c(%eax),%ecx
++    bp = bread(ip->dev, ip->addrs[NDIRECT]);
++801018ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++    for(j = 0; j < NINDIRECT; j++){
++801018d1:	89 cf                	mov    %ecx,%edi
++801018d3:	31 c0                	xor    %eax,%eax
++801018d5:	eb 0e                	jmp    801018e5 <iput+0x105>
++801018d7:	90                   	nop
++801018d8:	83 c3 01             	add    $0x1,%ebx
++801018db:	81 fb 80 00 00 00    	cmp    $0x80,%ebx
++801018e1:	89 d8                	mov    %ebx,%eax
++801018e3:	74 10                	je     801018f5 <iput+0x115>
++      if(a[j])
++801018e5:	8b 14 87             	mov    (%edi,%eax,4),%edx
++801018e8:	85 d2                	test   %edx,%edx
++801018ea:	74 ec                	je     801018d8 <iput+0xf8>
++        bfree(ip->dev, a[j]);
++801018ec:	8b 06                	mov    (%esi),%eax
++801018ee:	e8 fd fa ff ff       	call   801013f0 <bfree>
++801018f3:	eb e3                	jmp    801018d8 <iput+0xf8>
++    brelse(bp);
++801018f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
++801018f8:	8b 7d e0             	mov    -0x20(%ebp),%edi
++801018fb:	89 04 24             	mov    %eax,(%esp)
++801018fe:	e8 dd e8 ff ff       	call   801001e0 <brelse>
++    bfree(ip->dev, ip->addrs[NDIRECT]);
++80101903:	8b 96 8c 00 00 00    	mov    0x8c(%esi),%edx
++80101909:	8b 06                	mov    (%esi),%eax
++8010190b:	e8 e0 fa ff ff       	call   801013f0 <bfree>
++    ip->addrs[NDIRECT] = 0;
++80101910:	c7 86 8c 00 00 00 00 	movl   $0x0,0x8c(%esi)
++80101917:	00 00 00 
++8010191a:	e9 6e ff ff ff       	jmp    8010188d <iput+0xad>
++8010191f:	90                   	nop
++
++80101920 <iunlockput>:
++{
++80101920:	55                   	push   %ebp
++80101921:	89 e5                	mov    %esp,%ebp
++80101923:	53                   	push   %ebx
++80101924:	83 ec 14             	sub    $0x14,%esp
++80101927:	8b 5d 08             	mov    0x8(%ebp),%ebx
++  iunlock(ip);
++8010192a:	89 1c 24             	mov    %ebx,(%esp)
++8010192d:	e8 6e fe ff ff       	call   801017a0 <iunlock>
++  iput(ip);
++80101932:	89 5d 08             	mov    %ebx,0x8(%ebp)
++}
++80101935:	83 c4 14             	add    $0x14,%esp
++80101938:	5b                   	pop    %ebx
++80101939:	5d                   	pop    %ebp
++  iput(ip);
++8010193a:	e9 a1 fe ff ff       	jmp    801017e0 <iput>
++8010193f:	90                   	nop
++
++80101940 <stati>:
++
++// Copy stat information from inode.
++// Caller must hold ip->lock.
++void
++stati(struct inode *ip, struct stat *st)
++{
++80101940:	55                   	push   %ebp
++80101941:	89 e5                	mov    %esp,%ebp
++80101943:	8b 55 08             	mov    0x8(%ebp),%edx
++80101946:	8b 45 0c             	mov    0xc(%ebp),%eax
++  st->dev = ip->dev;
++80101949:	8b 0a                	mov    (%edx),%ecx
++8010194b:	89 48 04             	mov    %ecx,0x4(%eax)
++  st->ino = ip->inum;
++8010194e:	8b 4a 04             	mov    0x4(%edx),%ecx
++80101951:	89 48 08             	mov    %ecx,0x8(%eax)
++  st->type = ip->type;
++80101954:	0f b7 4a 50          	movzwl 0x50(%edx),%ecx
++80101958:	66 89 08             	mov    %cx,(%eax)
++  st->nlink = ip->nlink;
++8010195b:	0f b7 4a 56          	movzwl 0x56(%edx),%ecx
++8010195f:	66 89 48 0c          	mov    %cx,0xc(%eax)
++  st->size = ip->size;
++80101963:	8b 52 58             	mov    0x58(%edx),%edx
++80101966:	89 50 10             	mov    %edx,0x10(%eax)
++}
++80101969:	5d                   	pop    %ebp
++8010196a:	c3                   	ret    
++8010196b:	90                   	nop
++8010196c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++
++80101970 <readi>:
++//PAGEBREAK!
++// Read data from inode.
++// Caller must hold ip->lock.
++int
++readi(struct inode *ip, char *dst, uint off, uint n)
++{
++80101970:	55                   	push   %ebp
++80101971:	89 e5                	mov    %esp,%ebp
++80101973:	57                   	push   %edi
++80101974:	56                   	push   %esi
++80101975:	53                   	push   %ebx
++80101976:	83 ec 2c             	sub    $0x2c,%esp
++80101979:	8b 45 0c             	mov    0xc(%ebp),%eax
++8010197c:	8b 7d 08             	mov    0x8(%ebp),%edi
++8010197f:	8b 75 10             	mov    0x10(%ebp),%esi
++80101982:	89 45 e0             	mov    %eax,-0x20(%ebp)
++80101985:	8b 45 14             	mov    0x14(%ebp),%eax
++  uint tot, m;
++  struct buf *bp;
++
++  if(ip->type == T_DEV){
++80101988:	66 83 7f 50 03       	cmpw   $0x3,0x50(%edi)
++{
++8010198d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++  if(ip->type == T_DEV){
++80101990:	0f 84 aa 00 00 00    	je     80101a40 <readi+0xd0>
++    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
++      return -1;
++    return devsw[ip->major].read(ip, dst, n);
++  }
++
++  if(off > ip->size || off + n < off)
++80101996:	8b 47 58             	mov    0x58(%edi),%eax
++80101999:	39 f0                	cmp    %esi,%eax
++8010199b:	0f 82 c7 00 00 00    	jb     80101a68 <readi+0xf8>
++801019a1:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
++801019a4:	89 da                	mov    %ebx,%edx
++801019a6:	01 f2                	add    %esi,%edx
++801019a8:	0f 82 ba 00 00 00    	jb     80101a68 <readi+0xf8>
++    return -1;
++  if(off + n > ip->size)
++    n = ip->size - off;
++801019ae:	89 c1                	mov    %eax,%ecx
++801019b0:	29 f1                	sub    %esi,%ecx
++801019b2:	39 d0                	cmp    %edx,%eax
++801019b4:	0f 43 cb             	cmovae %ebx,%ecx
++
++  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
++801019b7:	31 c0                	xor    %eax,%eax
++801019b9:	85 c9                	test   %ecx,%ecx
++    n = ip->size - off;
++801019bb:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
++  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
++801019be:	74 70                	je     80101a30 <readi+0xc0>
++801019c0:	89 7d d8             	mov    %edi,-0x28(%ebp)
++801019c3:	89 c7                	mov    %eax,%edi
++801019c5:	8d 76 00             	lea    0x0(%esi),%esi
++    bp = bread(ip->dev, bmap(ip, off/BSIZE));
++801019c8:	8b 5d d8             	mov    -0x28(%ebp),%ebx
++801019cb:	89 f2                	mov    %esi,%edx
++801019cd:	c1 ea 09             	shr    $0x9,%edx
++801019d0:	89 d8                	mov    %ebx,%eax
++801019d2:	e8 09 f9 ff ff       	call   801012e0 <bmap>
++801019d7:	89 44 24 04          	mov    %eax,0x4(%esp)
++801019db:	8b 03                	mov    (%ebx),%eax
++    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
++80102c0d:	8b 04 9d cc 26 11 80 	mov    -0x7feed934(,%ebx,4),%eax
++  for (tail = 0; tail < log.lh.n; tail++) {
++80102c14:	83 c3 01             	add    $0x1,%ebx
++    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
++80102c17:	89 44 24 04          	mov    %eax,0x4(%esp)
++80102c1b:	a1 c4 26 11 80       	mov    0x801126c4,%eax
++80102c20:	89 04 24             	mov    %eax,(%esp)
++80102c23:	e8 a8 d4 ff ff       	call   801000d0 <bread>
++    memmove(to->data, from->data, BSIZE);
++80102c28:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
++80102c2f:	00 
++    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
++80102c30:	89 c7                	mov    %eax,%edi
++    memmove(to->data, from->data, BSIZE);
++80102c32:	8d 40 5c             	lea    0x5c(%eax),%eax
++80102c35:	89 44 24 04          	mov    %eax,0x4(%esp)
++80102c39:	8d 46 5c             	lea    0x5c(%esi),%eax
++80102c3c:	89 04 24             	mov    %eax,(%esp)
++80102c3f:	e8 ec 16 00 00       	call   80104330 <memmove>
++    bwrite(to);  // write the log
++80102c44:	89 34 24             	mov    %esi,(%esp)
++80102c47:	e8 54 d5 ff ff       	call   801001a0 <bwrite>
++    brelse(from);
++80102c4c:	89 3c 24             	mov    %edi,(%esp)
++80102c4f:	e8 8c d5 ff ff       	call   801001e0 <brelse>
++    brelse(to);
++80102c54:	89 34 24             	mov    %esi,(%esp)
++80102c57:	e8 84 d5 ff ff       	call   801001e0 <brelse>
++  for (tail = 0; tail < log.lh.n; tail++) {
++80102c5c:	3b 1d c8 26 11 80    	cmp    0x801126c8,%ebx
++80102c62:	7c 8c                	jl     80102bf0 <end_op+0x60>
++    write_log();     // Write modified blocks from cache to log
++    write_head();    // Write header to disk -- the real commit
++80102c64:	e8 a7 fd ff ff       	call   80102a10 <write_head>
++    install_trans(); // Now install writes to home locations
++80102c69:	e8 02 fd ff ff       	call   80102970 <install_trans>
++    log.lh.n = 0;
++80102c6e:	c7 05 c8 26 11 80 00 	movl   $0x0,0x801126c8
++80102c75:	00 00 00 
++    write_head();    // Erase the transaction from the log
++80102c78:	e8 93 fd ff ff       	call   80102a10 <write_head>
++    acquire(&log.lock);
++80102c7d:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
++80102c84:	e8 c7 14 00 00       	call   80104150 <acquire>
++    log.committing = 0;
++80102c89:	c7 05 c0 26 11 80 00 	movl   $0x0,0x801126c0
++80102c90:	00 00 00 
++    wakeup(&log);
++80102c93:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
++80102c9a:	e8 01 11 00 00       	call   80103da0 <wakeup>
++    release(&log.lock);
++80102c9f:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
++80102ca6:	e8 95 15 00 00       	call   80104240 <release>
++}
++80102cab:	83 c4 1c             	add    $0x1c,%esp
++80102cae:	5b                   	pop    %ebx
++80102caf:	5e                   	pop    %esi
++80102cb0:	5f                   	pop    %edi
++80102cb1:	5d                   	pop    %ebp
++80102cb2:	c3                   	ret    
++    panic("log.committing");
++80102cb3:	c7 04 24 c4 71 10 80 	movl   $0x801071c4,(%esp)
++80102cba:	e8 a1 d6 ff ff       	call   80100360 <panic>
++80102cbf:	90                   	nop
++
++80102cc0 <log_write>:
++//   modify bp->data[]
++//   log_write(bp)
++//   brelse(bp)
++void
++log_write(struct buf *b)
++{
++80102cc0:	55                   	push   %ebp
++80102cc1:	89 e5                	mov    %esp,%ebp
++80102cc3:	53                   	push   %ebx
++80102cc4:	83 ec 14             	sub    $0x14,%esp
++  int i;
++
++  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
++80102cc7:	a1 c8 26 11 80       	mov    0x801126c8,%eax
++{
++80102ccc:	8b 5d 08             	mov    0x8(%ebp),%ebx
++  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
++80102ccf:	83 f8 1d             	cmp    $0x1d,%eax
++80102cd2:	0f 8f 98 00 00 00    	jg     80102d70 <log_write+0xb0>
++80102cd8:	8b 0d b8 26 11 80    	mov    0x801126b8,%ecx
++80102cde:	8d 51 ff             	lea    -0x1(%ecx),%edx
++80102ce1:	39 d0                	cmp    %edx,%eax
++80102ce3:	0f 8d 87 00 00 00    	jge    80102d70 <log_write+0xb0>
++    panic("too big a transaction");
++  if (log.outstanding < 1)
++80102ce9:	a1 bc 26 11 80       	mov    0x801126bc,%eax
++80102cee:	85 c0                	test   %eax,%eax
++80102cf0:	0f 8e 86 00 00 00    	jle    80102d7c <log_write+0xbc>
++    panic("log_write outside of trans");
++
++  acquire(&log.lock);
++80102cf6:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
++80102cfd:	e8 4e 14 00 00       	call   80104150 <acquire>
++  for (i = 0; i < log.lh.n; i++) {
++80102d02:	8b 15 c8 26 11 80    	mov    0x801126c8,%edx
++80102d08:	83 fa 00             	cmp    $0x0,%edx
++80102d0b:	7e 54                	jle    80102d61 <log_write+0xa1>
++    if (log.lh.block[i] == b->blockno)   // log absorbtion
++80102d0d:	8b 4b 08             	mov    0x8(%ebx),%ecx
++  for (i = 0; i < log.lh.n; i++) {
++80102d10:	31 c0                	xor    %eax,%eax
++    if (log.lh.block[i] == b->blockno)   // log absorbtion
++80102d12:	39 0d cc 26 11 80    	cmp    %ecx,0x801126cc
++80102d18:	75 0f                	jne    80102d29 <log_write+0x69>
++80102d1a:	eb 3c                	jmp    80102d58 <log_write+0x98>
++80102d1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++80102d20:	39 0c 85 cc 26 11 80 	cmp    %ecx,-0x7feed934(,%eax,4)
++80102d27:	74 2f                	je     80102d58 <log_write+0x98>
++  for (i = 0; i < log.lh.n; i++) {
++80102d29:	83 c0 01             	add    $0x1,%eax
++80102d2c:	39 d0                	cmp    %edx,%eax
++80102d2e:	75 f0                	jne    80102d20 <log_write+0x60>
++      break;
++  }
++  log.lh.block[i] = b->blockno;
++80102d30:	89 0c 95 cc 26 11 80 	mov    %ecx,-0x7feed934(,%edx,4)
++  if (i == log.lh.n)
++    log.lh.n++;
++80102d37:	83 c2 01             	add    $0x1,%edx
++80102d3a:	89 15 c8 26 11 80    	mov    %edx,0x801126c8
++  b->flags |= B_DIRTY; // prevent eviction
++80102d40:	83 0b 04             	orl    $0x4,(%ebx)
++  release(&log.lock);
++80102d43:	c7 45 08 80 26 11 80 	movl   $0x80112680,0x8(%ebp)
++}
++80102d4a:	83 c4 14             	add    $0x14,%esp
++80102d4d:	5b                   	pop    %ebx
++80102d4e:	5d                   	pop    %ebp
++  release(&log.lock);
++80102d4f:	e9 ec 14 00 00       	jmp    80104240 <release>
++80102d54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++  log.lh.block[i] = b->blockno;
++80102d58:	89 0c 85 cc 26 11 80 	mov    %ecx,-0x7feed934(,%eax,4)
++80102d5f:	eb df                	jmp    80102d40 <log_write+0x80>
++80102d61:	8b 43 08             	mov    0x8(%ebx),%eax
++80102d64:	a3 cc 26 11 80       	mov    %eax,0x801126cc
++  if (i == log.lh.n)
++80102d69:	75 d5                	jne    80102d40 <log_write+0x80>
++80102d6b:	eb ca                	jmp    80102d37 <log_write+0x77>
++80102d6d:	8d 76 00             	lea    0x0(%esi),%esi
++    panic("too big a transaction");
++80102d70:	c7 04 24 d3 71 10 80 	movl   $0x801071d3,(%esp)
++80102d77:	e8 e4 d5 ff ff       	call   80100360 <panic>
++    panic("log_write outside of trans");
++80102d7c:	c7 04 24 e9 71 10 80 	movl   $0x801071e9,(%esp)
++80102d83:	e8 d8 d5 ff ff       	call   80100360 <panic>
++80102d88:	66 90                	xchg   %ax,%ax
++80102d8a:	66 90                	xchg   %ax,%ax
++80102d8c:	66 90                	xchg   %ax,%ax
++80102d8e:	66 90                	xchg   %ax,%ax
++
++80102d90 <mpmain>:
++}
++
++// Common CPU setup code.
++static void
++mpmain(void)
++{
++80102d90:	55                   	push   %ebp
++80102d91:	89 e5                	mov    %esp,%ebp
++80102d93:	53                   	push   %ebx
++80102d94:	83 ec 14             	sub    $0x14,%esp
++  cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
++80102d97:	e8 f4 08 00 00       	call   80103690 <cpuid>
++80102d9c:	89 c3                	mov    %eax,%ebx
++80102d9e:	e8 ed 08 00 00       	call   80103690 <cpuid>
++80102da3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
++80102da7:	c7 04 24 04 72 10 80 	movl   $0x80107204,(%esp)
++80102dae:	89 44 24 04          	mov    %eax,0x4(%esp)
++80102db2:	e8 99 d8 ff ff       	call   80100650 <cprintf>
++  idtinit();       // load idt register
++80102db7:	e8 54 27 00 00       	call   80105510 <idtinit>
++  xchg(&(mycpu()->started), 1); // tell startothers() we're up
++80102dbc:	e8 4f 08 00 00       	call   80103610 <mycpu>
++80102dc1:	89 c2                	mov    %eax,%edx
++xchg(volatile uint *addr, uint newval)
++{
++  uint result;
++
++  // The + in "+m" denotes a read-modify-write operand.
++  asm volatile("lock; xchgl %0, %1" :
++80102dc3:	b8 01 00 00 00       	mov    $0x1,%eax
++80102dc8:	f0 87 82 a0 00 00 00 	lock xchg %eax,0xa0(%edx)
++  scheduler();     // start running processes
++80102dcf:	e8 9c 0b 00 00       	call   80103970 <scheduler>
++80102dd4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++80102dda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
++
++80102de0 <mpenter>:
++{
++80102de0:	55                   	push   %ebp
++80102de1:	89 e5                	mov    %esp,%ebp
++80102de3:	83 ec 08             	sub    $0x8,%esp
++  switchkvm();
++80102de6:	e8 e5 37 00 00       	call   801065d0 <switchkvm>
++  seginit();
++80102deb:	e8 a0 36 00 00       	call   80106490 <seginit>
++  lapicinit();
++80102df0:	e8 8b f8 ff ff       	call   80102680 <lapicinit>
++  mpmain();
++80102df5:	e8 96 ff ff ff       	call   80102d90 <mpmain>
++80102dfa:	66 90                	xchg   %ax,%ax
++80102dfc:	66 90                	xchg   %ax,%ax
++80102dfe:	66 90                	xchg   %ax,%ax
++
++80102e00 <main>:
++{
++80102e00:	55                   	push   %ebp
++80102e01:	89 e5                	mov    %esp,%ebp
++80102e03:	53                   	push   %ebx
++  // The linker has placed the image of entryother.S in
++  // _binary_entryother_start.
++  code = P2V(0x7000);
++  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
++
++  for(c = cpus; c < cpus+ncpu; c++){
++80102e04:	bb 80 27 11 80       	mov    $0x80112780,%ebx
++{
++80102e09:	83 e4 f0             	and    $0xfffffff0,%esp
++80102e0c:	83 ec 10             	sub    $0x10,%esp
++  kinit1(end, P2V(4*1024*1024)); // phys page allocator
++80102e0f:	c7 44 24 04 00 00 40 	movl   $0x80400000,0x4(%esp)
++80102e16:	80 
++80102e17:	c7 04 24 f4 57 11 80 	movl   $0x801157f4,(%esp)
++80102e1e:	e8 cd f5 ff ff       	call   801023f0 <kinit1>
++  kvmalloc();      // kernel page table
++80102e23:	e8 58 3c 00 00       	call   80106a80 <kvmalloc>
++  mpinit();        // detect other processors
++80102e28:	e8 73 01 00 00       	call   80102fa0 <mpinit>
++80102e2d:	8d 76 00             	lea    0x0(%esi),%esi
++  lapicinit();     // interrupt controller
++80102e30:	e8 4b f8 ff ff       	call   80102680 <lapicinit>
++  seginit();       // segment descriptors
++80102e35:	e8 56 36 00 00       	call   80106490 <seginit>
++  picinit();       // disable pic
++80102e3a:	e8 21 03 00 00       	call   80103160 <picinit>
++80102e3f:	90                   	nop
++  ioapicinit();    // another interrupt controller
++80102e40:	e8 cb f3 ff ff       	call   80102210 <ioapicinit>
++  consoleinit();   // console hardware
++80102e45:	e8 06 db ff ff       	call   80100950 <consoleinit>
++  uartinit();      // serial port
++80102e4a:	e8 e1 29 00 00       	call   80105830 <uartinit>
++80102e4f:	90                   	nop
++  pinit();         // process table
++80102e50:	e8 9b 07 00 00       	call   801035f0 <pinit>
++  shminit();       // shared memory
++80102e55:	e8 36 3e 00 00       	call   80106c90 <shminit>
++  tvinit();        // trap vectors
++80102e5a:	e8 11 26 00 00       	call   80105470 <tvinit>
++80102e5f:	90                   	nop
++  binit();         // buffer cache
++80102e60:	e8 db d1 ff ff       	call   80100040 <binit>
++  fileinit();      // file table
++80102e65:	e8 e6 de ff ff       	call   80100d50 <fileinit>
++  ideinit();       // disk 
++80102e6a:	e8 a1 f1 ff ff       	call   80102010 <ideinit>
++  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
++80102e6f:	c7 44 24 08 8a 00 00 	movl   $0x8a,0x8(%esp)
++80102e76:	00 
++80102e77:	c7 44 24 04 8c a4 10 	movl   $0x8010a48c,0x4(%esp)
++80102e7e:	80 
++80102e7f:	c7 04 24 00 70 00 80 	movl   $0x80007000,(%esp)
++80102e86:	e8 a5 14 00 00       	call   80104330 <memmove>
++  for(c = cpus; c < cpus+ncpu; c++){
++80102e8b:	69 05 00 2d 11 80 b0 	imul   $0xb0,0x80112d00,%eax
++80102e92:	00 00 00 
++80102e95:	05 80 27 11 80       	add    $0x80112780,%eax
++80102e9a:	39 d8                	cmp    %ebx,%eax
++80102e9c:	76 65                	jbe    80102f03 <main+0x103>
++80102e9e:	66 90                	xchg   %ax,%ax
++    if(c == mycpu())  // We've started already.
++80102ea0:	e8 6b 07 00 00       	call   80103610 <mycpu>
++80102ea5:	39 d8                	cmp    %ebx,%eax
++80102ea7:	74 41                	je     80102eea <main+0xea>
++      continue;
++
++    // Tell entryother.S what stack to use, where to enter, and what
++    // pgdir to use. We cannot use kpgdir yet, because the AP processor
++    // is running in low  memory, so we use entrypgdir for the APs too.
++    stack = kalloc();
++80102ea9:	e8 02 f6 ff ff       	call   801024b0 <kalloc>
++    *(void**)(code-4) = stack + KSTACKSIZE;
++    *(void**)(code-8) = mpenter;
++80102eae:	c7 05 f8 6f 00 80 e0 	movl   $0x80102de0,0x80006ff8
++80102eb5:	2d 10 80 
++    *(int**)(code-12) = (void *) V2P(entrypgdir);
++80102eb8:	c7 05 f4 6f 00 80 00 	movl   $0x109000,0x80006ff4
++80102ebf:	90 10 00 
++    *(void**)(code-4) = stack + KSTACKSIZE;
++80102ec2:	05 00 10 00 00       	add    $0x1000,%eax
++80102ec7:	a3 fc 6f 00 80       	mov    %eax,0x80006ffc
++
++    lapicstartap(c->apicid, V2P(code));
++80102ecc:	0f b6 03             	movzbl (%ebx),%eax
++80102ecf:	c7 44 24 04 00 70 00 	movl   $0x7000,0x4(%esp)
++80102ed6:	00 
++80102ed7:	89 04 24             	mov    %eax,(%esp)
++80102eda:	e8 e1 f8 ff ff       	call   801027c0 <lapicstartap>
++80102edf:	90                   	nop
++
++    // wait for cpu to finish mpmain()
++    while(c->started == 0)
++80102ee0:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
++80102ee6:	85 c0                	test   %eax,%eax
++80102ee8:	74 f6                	je     80102ee0 <main+0xe0>
++  for(c = cpus; c < cpus+ncpu; c++){
++80102eea:	69 05 00 2d 11 80 b0 	imul   $0xb0,0x80112d00,%eax
++80102ef1:	00 00 00 
++80102ef4:	81 c3 b0 00 00 00    	add    $0xb0,%ebx
++80102efa:	05 80 27 11 80       	add    $0x80112780,%eax
++80102eff:	39 c3                	cmp    %eax,%ebx
++80102f01:	72 9d                	jb     80102ea0 <main+0xa0>
++  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
++80102f03:	c7 44 24 04 00 00 00 	movl   $0x8e000000,0x4(%esp)
++80102f0a:	8e 
++80102f0b:	c7 04 24 00 00 40 80 	movl   $0x80400000,(%esp)
++80102f12:	e8 49 f5 ff ff       	call   80102460 <kinit2>
++  userinit();      // first user process
++80102f17:	e8 c4 07 00 00       	call   801036e0 <userinit>
++  mpmain();        // finish this processor's setup
++80102f1c:	e8 6f fe ff ff       	call   80102d90 <mpmain>
++80102f21:	66 90                	xchg   %ax,%ax
++80102f23:	66 90                	xchg   %ax,%ax
++80102f25:	66 90                	xchg   %ax,%ax
++80102f27:	66 90                	xchg   %ax,%ax
++80102f29:	66 90                	xchg   %ax,%ax
++80102f2b:	66 90                	xchg   %ax,%ax
++80102f2d:	66 90                	xchg   %ax,%ax
++80102f2f:	90                   	nop
++
++80102f30 <mpsearch1>:
++}
++
++// Look for an MP structure in the len bytes at addr.
++static struct mp*
++mpsearch1(uint a, int len)
++{
++80102f30:	55                   	push   %ebp
++80102f31:	89 e5                	mov    %esp,%ebp
++80102f33:	56                   	push   %esi
++  uchar *e, *p, *addr;
++
++  addr = P2V(a);
++80102f34:	8d b0 00 00 00 80    	lea    -0x80000000(%eax),%esi
++{
++80102f3a:	53                   	push   %ebx
++  e = addr+len;
++80102f3b:	8d 1c 16             	lea    (%esi,%edx,1),%ebx
++{
++80102f3e:	83 ec 10             	sub    $0x10,%esp
++  for(p = addr; p < e; p += sizeof(struct mp))
++80102f41:	39 de                	cmp    %ebx,%esi
++80102f43:	73 3c                	jae    80102f81 <mpsearch1+0x51>
++80102f45:	8d 76 00             	lea    0x0(%esi),%esi
++    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
++80102f48:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
++80102f4f:	00 
++80102f50:	c7 44 24 04 18 72 10 	movl   $0x80107218,0x4(%esp)
++80102f57:	80 
++80102f58:	89 34 24             	mov    %esi,(%esp)
++80102f5b:	e8 80 13 00 00       	call   801042e0 <memcmp>
++80102f60:	85 c0                	test   %eax,%eax
++80102f62:	75 16                	jne    80102f7a <mpsearch1+0x4a>
++80102f64:	31 c9                	xor    %ecx,%ecx
++80102f66:	31 d2                	xor    %edx,%edx
++    sum += addr[i];
++80102f68:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
++  for(i=0; i<len; i++)
++80102f6c:	83 c2 01             	add    $0x1,%edx
++    sum += addr[i];
++80102f6f:	01 c1                	add    %eax,%ecx
++  for(i=0; i<len; i++)
++80102f71:	83 fa 10             	cmp    $0x10,%edx
++80102f74:	75 f2                	jne    80102f68 <mpsearch1+0x38>
++    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
++80102f76:	84 c9                	test   %cl,%cl
++80102f78:	74 10                	je     80102f8a <mpsearch1+0x5a>
++  for(p = addr; p < e; p += sizeof(struct mp))
++80102f7a:	83 c6 10             	add    $0x10,%esi
++80102f7d:	39 f3                	cmp    %esi,%ebx
++80102f7f:	77 c7                	ja     80102f48 <mpsearch1+0x18>
++      return (struct mp*)p;
++  return 0;
++}
++80102f81:	83 c4 10             	add    $0x10,%esp
++  return 0;
++80102f84:	31 c0                	xor    %eax,%eax
++}
++80102f86:	5b                   	pop    %ebx
++80102f87:	5e                   	pop    %esi
++80102f88:	5d                   	pop    %ebp
++80102f89:	c3                   	ret    
++80102f8a:	83 c4 10             	add    $0x10,%esp
++80102f8d:	89 f0                	mov    %esi,%eax
++80102f8f:	5b                   	pop    %ebx
++80102f90:	5e                   	pop    %esi
++80102f91:	5d                   	pop    %ebp
++80102f92:	c3                   	ret    
++80102f93:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++80102f99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
++
++80102fa0 <mpinit>:
++  return conf;
++}
++
++void
++mpinit(void)
++{
++80102fa0:	55                   	push   %ebp
++80102fa1:	89 e5                	mov    %esp,%ebp
++80102fa3:	57                   	push   %edi
++80102fa4:	56                   	push   %esi
++80102fa5:	53                   	push   %ebx
++80102fa6:	83 ec 1c             	sub    $0x1c,%esp
++  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
++80102fa9:	0f b6 05 0f 04 00 80 	movzbl 0x8000040f,%eax
++80102fb0:	0f b6 15 0e 04 00 80 	movzbl 0x8000040e,%edx
++80102fb7:	c1 e0 08             	shl    $0x8,%eax
++80102fba:	09 d0                	or     %edx,%eax
++80102fbc:	c1 e0 04             	shl    $0x4,%eax
++80102fbf:	85 c0                	test   %eax,%eax
++80102fc1:	75 1b                	jne    80102fde <mpinit+0x3e>
++    p = ((bda[0x14]<<8)|bda[0x13])*1024;
++80102fc3:	0f b6 05 14 04 00 80 	movzbl 0x80000414,%eax
++80102fca:	0f b6 15 13 04 00 80 	movzbl 0x80000413,%edx
++80102fd1:	c1 e0 08             	shl    $0x8,%eax
++80102fd4:	09 d0                	or     %edx,%eax
++80102fd6:	c1 e0 0a             	shl    $0xa,%eax
++    if((mp = mpsearch1(p-1024, 1024)))
++80102fd9:	2d 00 04 00 00       	sub    $0x400,%eax
++    if((mp = mpsearch1(p, 1024)))
++80102fde:	ba 00 04 00 00       	mov    $0x400,%edx
++80102fe3:	e8 48 ff ff ff       	call   80102f30 <mpsearch1>
++80102fe8:	85 c0                	test   %eax,%eax
++80102fea:	89 c7                	mov    %eax,%edi
++80102fec:	0f 84 22 01 00 00    	je     80103114 <mpinit+0x174>
++  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
++80102ff2:	8b 77 04             	mov    0x4(%edi),%esi
++80102ff5:	85 f6                	test   %esi,%esi
++80102ff7:	0f 84 30 01 00 00    	je     8010312d <mpinit+0x18d>
++  conf = (struct mpconf*) P2V((uint) mp->physaddr);
++80102ffd:	8d 86 00 00 00 80    	lea    -0x80000000(%esi),%eax
++  if(memcmp(conf, "PCMP", 4) != 0)
++80103003:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
++8010300a:	00 
++8010300b:	c7 44 24 04 1d 72 10 	movl   $0x8010721d,0x4(%esp)
++80103012:	80 
++80103013:	89 04 24             	mov    %eax,(%esp)
++  conf = (struct mpconf*) P2V((uint) mp->physaddr);
++80103016:	89 45 e4             	mov    %eax,-0x1c(%ebp)
++  if(memcmp(conf, "PCMP", 4) != 0)
++80103019:	e8 c2 12 00 00       	call   801042e0 <memcmp>
++8010301e:	85 c0                	test   %eax,%eax
++80103020:	0f 85 07 01 00 00    	jne    8010312d <mpinit+0x18d>
++  if(conf->version != 1 && conf->version != 4)
++80103026:	0f b6 86 06 00 00 80 	movzbl -0x7ffffffa(%esi),%eax
++8010302d:	3c 04                	cmp    $0x4,%al
++8010302f:	0f 85 0b 01 00 00    	jne    80103140 <mpinit+0x1a0>
++  if(sum((uchar*)conf, conf->length) != 0)
++80103035:	0f b7 86 04 00 00 80 	movzwl -0x7ffffffc(%esi),%eax
++  for(i=0; i<len; i++)
++8010303c:	85 c0                	test   %eax,%eax
++8010303e:	74 21                	je     80103061 <mpinit+0xc1>
++  sum = 0;
++80103040:	31 c9                	xor    %ecx,%ecx
++  for(i=0; i<len; i++)
++80103042:	31 d2                	xor    %edx,%edx
++80103044:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    sum += addr[i];
++80103048:	0f b6 9c 16 00 00 00 	movzbl -0x80000000(%esi,%edx,1),%ebx
++8010304f:	80 
++  for(i=0; i<len; i++)
++80103050:	83 c2 01             	add    $0x1,%edx
++    sum += addr[i];
++80103053:	01 d9                	add    %ebx,%ecx
++  for(i=0; i<len; i++)
++80103055:	39 d0                	cmp    %edx,%eax
++80103057:	7f ef                	jg     80103048 <mpinit+0xa8>
++  if(sum((uchar*)conf, conf->length) != 0)
++80103059:	84 c9                	test   %cl,%cl
++8010305b:	0f 85 cc 00 00 00    	jne    8010312d <mpinit+0x18d>
++  struct mp *mp;
++  struct mpconf *conf;
++  struct mpproc *proc;
++  struct mpioapic *ioapic;
++
++  if((conf = mpconfig(&mp)) == 0)
++80103061:	8b 45 e4             	mov    -0x1c(%ebp),%eax
++80103064:	85 c0                	test   %eax,%eax
++80103066:	0f 84 c1 00 00 00    	je     8010312d <mpinit+0x18d>
++    panic("Expect to run on an SMP");
++  ismp = 1;
++  lapic = (uint*)conf->lapicaddr;
++8010306c:	8b 86 24 00 00 80    	mov    -0x7fffffdc(%esi),%eax
++  ismp = 1;
++80103072:	bb 01 00 00 00       	mov    $0x1,%ebx
++  lapic = (uint*)conf->lapicaddr;
++80103077:	a3 7c 26 11 80       	mov    %eax,0x8011267c
++  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
++8010307c:	0f b7 96 04 00 00 80 	movzwl -0x7ffffffc(%esi),%edx
++80103083:	8d 86 2c 00 00 80    	lea    -0x7fffffd4(%esi),%eax
++80103089:	03 55 e4             	add    -0x1c(%ebp),%edx
++8010308c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++80103090:	39 c2                	cmp    %eax,%edx
++80103092:	76 1b                	jbe    801030af <mpinit+0x10f>
++80103094:	0f b6 08             	movzbl (%eax),%ecx
++    switch(*p){
++80103097:	80 f9 04             	cmp    $0x4,%cl
++8010309a:	77 74                	ja     80103110 <mpinit+0x170>
++8010309c:	ff 24 8d 5c 72 10 80 	jmp    *-0x7fef8da4(,%ecx,4)
++801030a3:	90                   	nop
++801030a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++      p += sizeof(struct mpioapic);
++      continue;
++    case MPBUS:
++    case MPIOINTR:
++    case MPLINTR:
++      p += 8;
++801030a8:	83 c0 08             	add    $0x8,%eax
++  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
++801030ab:	39 c2                	cmp    %eax,%edx
++801030ad:	77 e5                	ja     80103094 <mpinit+0xf4>
++    default:
++      ismp = 0;
++      break;
++    }
++  }
++  if(!ismp)
++801030af:	85 db                	test   %ebx,%ebx
++801030b1:	0f 84 93 00 00 00    	je     8010314a <mpinit+0x1aa>
++    panic("Didn't find a suitable machine");
++
++  if(mp->imcrp){
++801030b7:	80 7f 0c 00          	cmpb   $0x0,0xc(%edi)
++801030bb:	74 12                	je     801030cf <mpinit+0x12f>
++  asm volatile("out %0,%1" : : "a" (data), "d" (port));
++801030bd:	ba 22 00 00 00       	mov    $0x22,%edx
++801030c2:	b8 70 00 00 00       	mov    $0x70,%eax
++801030c7:	ee                   	out    %al,(%dx)
++  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
++801030c8:	b2 23                	mov    $0x23,%dl
++801030ca:	ec                   	in     (%dx),%al
++    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
++    // But it would on real hardware.
++    outb(0x22, 0x70);   // Select IMCR
++    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
++801030cb:	83 c8 01             	or     $0x1,%eax
++  asm volatile("out %0,%1" : : "a" (data), "d" (port));
++801030ce:	ee                   	out    %al,(%dx)
++  }
++}
++801030cf:	83 c4 1c             	add    $0x1c,%esp
++801030d2:	5b                   	pop    %ebx
++801030d3:	5e                   	pop    %esi
++801030d4:	5f                   	pop    %edi
++801030d5:	5d                   	pop    %ebp
++801030d6:	c3                   	ret    
++801030d7:	90                   	nop
++      if(ncpu < NCPU) {
++801030d8:	8b 35 00 2d 11 80    	mov    0x80112d00,%esi
++801030de:	83 fe 07             	cmp    $0x7,%esi
++801030e1:	7f 17                	jg     801030fa <mpinit+0x15a>
++        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
++801030e3:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
++801030e7:	69 f6 b0 00 00 00    	imul   $0xb0,%esi,%esi
++        ncpu++;
++801030ed:	83 05 00 2d 11 80 01 	addl   $0x1,0x80112d00
++        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
++801030f4:	88 8e 80 27 11 80    	mov    %cl,-0x7feed880(%esi)
++      p += sizeof(struct mpproc);
++801030fa:	83 c0 14             	add    $0x14,%eax
++      continue;
++801030fd:	eb 91                	jmp    80103090 <mpinit+0xf0>
++801030ff:	90                   	nop
++      ioapicid = ioapic->apicno;
++80103100:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
++      p += sizeof(struct mpioapic);
++80103104:	83 c0 08             	add    $0x8,%eax
++      ioapicid = ioapic->apicno;
++80103107:	88 0d 60 27 11 80    	mov    %cl,0x80112760
++      continue;
++8010310d:	eb 81                	jmp    80103090 <mpinit+0xf0>
++8010310f:	90                   	nop
++      ismp = 0;
++80103110:	31 db                	xor    %ebx,%ebx
++80103112:	eb 83                	jmp    80103097 <mpinit+0xf7>
++  return mpsearch1(0xF0000, 0x10000);
++80103114:	ba 00 00 01 00       	mov    $0x10000,%edx
++80103119:	b8 00 00 0f 00       	mov    $0xf0000,%eax
++8010311e:	e8 0d fe ff ff       	call   80102f30 <mpsearch1>
++  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
++80103123:	85 c0                	test   %eax,%eax
++  return mpsearch1(0xF0000, 0x10000);
++80103125:	89 c7                	mov    %eax,%edi
++  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
++80103127:	0f 85 c5 fe ff ff    	jne    80102ff2 <mpinit+0x52>
++    panic("Expect to run on an SMP");
++8010312d:	c7 04 24 22 72 10 80 	movl   $0x80107222,(%esp)
++80103134:	e8 27 d2 ff ff       	call   80100360 <panic>
++80103139:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
++  if(conf->version != 1 && conf->version != 4)
++80103140:	3c 01                	cmp    $0x1,%al
++80103142:	0f 84 ed fe ff ff    	je     80103035 <mpinit+0x95>
++80103148:	eb e3                	jmp    8010312d <mpinit+0x18d>
++    panic("Didn't find a suitable machine");
++8010314a:	c7 04 24 3c 72 10 80 	movl   $0x8010723c,(%esp)
++80103151:	e8 0a d2 ff ff       	call   80100360 <panic>
++80103156:	66 90                	xchg   %ax,%ax
++80103158:	66 90                	xchg   %ax,%ax
++8010315a:	66 90                	xchg   %ax,%ax
++8010315c:	66 90                	xchg   %ax,%ax
++8010315e:	66 90                	xchg   %ax,%ax
++
++80103160 <picinit>:
++#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
++
++// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
++void
++picinit(void)
++{
++80103160:	55                   	push   %ebp
++80103161:	ba 21 00 00 00       	mov    $0x21,%edx
++80103166:	89 e5                	mov    %esp,%ebp
++80103168:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++8010316d:	ee                   	out    %al,(%dx)
++8010316e:	b2 a1                	mov    $0xa1,%dl
++80103170:	ee                   	out    %al,(%dx)
++  // mask all interrupts
++  outb(IO_PIC1+1, 0xFF);
++  outb(IO_PIC2+1, 0xFF);
++}
++80103171:	5d                   	pop    %ebp
++80103172:	c3                   	ret    
++80103173:	66 90                	xchg   %ax,%ax
++80103175:	66 90                	xchg   %ax,%ax
++80103177:	66 90                	xchg   %ax,%ax
++80103179:	66 90                	xchg   %ax,%ax
++8010317b:	66 90                	xchg   %ax,%ax
++8010317d:	66 90                	xchg   %ax,%ax
++8010317f:	90                   	nop
++
++80103180 <pipealloc>:
++  int writeopen;  // write fd is still open
++};
++
++int
++pipealloc(struct file **f0, struct file **f1)
++{
++80103180:	55                   	push   %ebp
++80103181:	89 e5                	mov    %esp,%ebp
++80103183:	57                   	push   %edi
++80103184:	56                   	push   %esi
++80103185:	53                   	push   %ebx
++80103186:	83 ec 1c             	sub    $0x1c,%esp
++80103189:	8b 75 08             	mov    0x8(%ebp),%esi
++8010318c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
++  struct pipe *p;
++
++  p = 0;
++  *f0 = *f1 = 0;
++8010318f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
++80103195:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
++  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
++8010319b:	e8 d0 db ff ff       	call   80100d70 <filealloc>
++801031a0:	85 c0                	test   %eax,%eax
++801031a2:	89 06                	mov    %eax,(%esi)
++801031a4:	0f 84 a4 00 00 00    	je     8010324e <pipealloc+0xce>
++801031aa:	e8 c1 db ff ff       	call   80100d70 <filealloc>
++801031af:	85 c0                	test   %eax,%eax
++801031b1:	89 03                	mov    %eax,(%ebx)
++801031b3:	0f 84 87 00 00 00    	je     80103240 <pipealloc+0xc0>
++    goto bad;
++  if((p = (struct pipe*)kalloc()) == 0)
++801031b9:	e8 f2 f2 ff ff       	call   801024b0 <kalloc>
++801031be:	85 c0                	test   %eax,%eax
++801031c0:	89 c7                	mov    %eax,%edi
++801031c2:	74 7c                	je     80103240 <pipealloc+0xc0>
++    goto bad;
++  p->readopen = 1;
++801031c4:	c7 80 3c 02 00 00 01 	movl   $0x1,0x23c(%eax)
++801031cb:	00 00 00 
++  p->writeopen = 1;
++801031ce:	c7 80 40 02 00 00 01 	movl   $0x1,0x240(%eax)
++801031d5:	00 00 00 
++  p->nwrite = 0;
++801031d8:	c7 80 38 02 00 00 00 	movl   $0x0,0x238(%eax)
++801031df:	00 00 00 
++  p->nread = 0;
++801031e2:	c7 80 34 02 00 00 00 	movl   $0x0,0x234(%eax)
++801031e9:	00 00 00 
++  initlock(&p->lock, "pipe");
++801031ec:	89 04 24             	mov    %eax,(%esp)
++801031ef:	c7 44 24 04 70 72 10 	movl   $0x80107270,0x4(%esp)
++801031f6:	80 
++801031f7:	e8 64 0e 00 00       	call   80104060 <initlock>
++  (*f0)->type = FD_PIPE;
++801031fc:	8b 06                	mov    (%esi),%eax
++801031fe:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
++  (*f0)->readable = 1;
++80103204:	8b 06                	mov    (%esi),%eax
++80103206:	c6 40 08 01          	movb   $0x1,0x8(%eax)
++  (*f0)->writable = 0;
++8010320a:	8b 06                	mov    (%esi),%eax
++8010320c:	c6 40 09 00          	movb   $0x0,0x9(%eax)
++  (*f0)->pipe = p;
++80103210:	8b 06                	mov    (%esi),%eax
++80103212:	89 78 0c             	mov    %edi,0xc(%eax)
++  (*f1)->type = FD_PIPE;
++80103215:	8b 03                	mov    (%ebx),%eax
++80103217:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
++  (*f1)->readable = 0;
++8010321d:	8b 03                	mov    (%ebx),%eax
++8010321f:	c6 40 08 00          	movb   $0x0,0x8(%eax)
++  (*f1)->writable = 1;
++80103223:	8b 03                	mov    (%ebx),%eax
++80103225:	c6 40 09 01          	movb   $0x1,0x9(%eax)
++  (*f1)->pipe = p;
++80103229:	8b 03                	mov    (%ebx),%eax
++  return 0;
++8010322b:	31 db                	xor    %ebx,%ebx
++  (*f1)->pipe = p;
++8010322d:	89 78 0c             	mov    %edi,0xc(%eax)
++  if(*f0)
++    fileclose(*f0);
++  if(*f1)
++    fileclose(*f1);
++  return -1;
++}
++80103230:	83 c4 1c             	add    $0x1c,%esp
++80103233:	89 d8                	mov    %ebx,%eax
++80103235:	5b                   	pop    %ebx
++80103236:	5e                   	pop    %esi
++80103237:	5f                   	pop    %edi
++80103238:	5d                   	pop    %ebp
++80103239:	c3                   	ret    
++8010323a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++  if(*f0)
++80103240:	8b 06                	mov    (%esi),%eax
++80103242:	85 c0                	test   %eax,%eax
++80103244:	74 08                	je     8010324e <pipealloc+0xce>
++    fileclose(*f0);
++80103246:	89 04 24             	mov    %eax,(%esp)
++80103249:	e8 e2 db ff ff       	call   80100e30 <fileclose>
++  if(*f1)
++8010324e:	8b 03                	mov    (%ebx),%eax
++  return -1;
++80103250:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
++  if(*f1)
++80103255:	85 c0                	test   %eax,%eax
++80103257:	74 d7                	je     80103230 <pipealloc+0xb0>
++    fileclose(*f1);
++80103259:	89 04 24             	mov    %eax,(%esp)
++8010325c:	e8 cf db ff ff       	call   80100e30 <fileclose>
++}
++80103261:	83 c4 1c             	add    $0x1c,%esp
++80103264:	89 d8                	mov    %ebx,%eax
++80103266:	5b                   	pop    %ebx
++80103267:	5e                   	pop    %esi
++80103268:	5f                   	pop    %edi
++80103269:	5d                   	pop    %ebp
++8010326a:	c3                   	ret    
++8010326b:	90                   	nop
++8010326c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++
++80103270 <pipeclose>:
++
++void
++pipeclose(struct pipe *p, int writable)
++{
++80103270:	55                   	push   %ebp
++80103271:	89 e5                	mov    %esp,%ebp
++80103273:	56                   	push   %esi
++80103274:	53                   	push   %ebx
++80103275:	83 ec 10             	sub    $0x10,%esp
++80103278:	8b 5d 08             	mov    0x8(%ebp),%ebx
++8010327b:	8b 75 0c             	mov    0xc(%ebp),%esi
++  acquire(&p->lock);
++8010327e:	89 1c 24             	mov    %ebx,(%esp)
++80103281:	e8 ca 0e 00 00       	call   80104150 <acquire>
++  if(writable){
++80103286:	85 f6                	test   %esi,%esi
++80103288:	74 3e                	je     801032c8 <pipeclose+0x58>
++    p->writeopen = 0;
++    wakeup(&p->nread);
++8010328a:	8d 83 34 02 00 00    	lea    0x234(%ebx),%eax
++    p->writeopen = 0;
++80103290:	c7 83 40 02 00 00 00 	movl   $0x0,0x240(%ebx)
++80103297:	00 00 00 
++    wakeup(&p->nread);
++8010329a:	89 04 24             	mov    %eax,(%esp)
++8010329d:	e8 fe 0a 00 00       	call   80103da0 <wakeup>
++  } else {
++    p->readopen = 0;
++    wakeup(&p->nwrite);
++  }
++  if(p->readopen == 0 && p->writeopen == 0){
++801032a2:	8b 93 3c 02 00 00    	mov    0x23c(%ebx),%edx
++801032a8:	85 d2                	test   %edx,%edx
++801032aa:	75 0a                	jne    801032b6 <pipeclose+0x46>
++801032ac:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
++801032b2:	85 c0                	test   %eax,%eax
++801032b4:	74 32                	je     801032e8 <pipeclose+0x78>
++    release(&p->lock);
++    kfree((char*)p);
++  } else
++    release(&p->lock);
++801032b6:	89 5d 08             	mov    %ebx,0x8(%ebp)
++}
++801032b9:	83 c4 10             	add    $0x10,%esp
++801032bc:	5b                   	pop    %ebx
++801032bd:	5e                   	pop    %esi
++801032be:	5d                   	pop    %ebp
++    release(&p->lock);
++801032bf:	e9 7c 0f 00 00       	jmp    80104240 <release>
++801032c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    wakeup(&p->nwrite);
++801032c8:	8d 83 38 02 00 00    	lea    0x238(%ebx),%eax
++    p->readopen = 0;
++801032ce:	c7 83 3c 02 00 00 00 	movl   $0x0,0x23c(%ebx)
++801032d5:	00 00 00 
++    wakeup(&p->nwrite);
++801032d8:	89 04 24             	mov    %eax,(%esp)
++801032db:	e8 c0 0a 00 00       	call   80103da0 <wakeup>
++801032e0:	eb c0                	jmp    801032a2 <pipeclose+0x32>
++801032e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++    release(&p->lock);
++801032e8:	89 1c 24             	mov    %ebx,(%esp)
++801032eb:	e8 50 0f 00 00       	call   80104240 <release>
++    kfree((char*)p);
++801032f0:	89 5d 08             	mov    %ebx,0x8(%ebp)
++}
++801032f3:	83 c4 10             	add    $0x10,%esp
++801032f6:	5b                   	pop    %ebx
++801032f7:	5e                   	pop    %esi
++801032f8:	5d                   	pop    %ebp
++    kfree((char*)p);
++801032f9:	e9 02 f0 ff ff       	jmp    80102300 <kfree>
++801032fe:	66 90                	xchg   %ax,%ax
++
++80103300 <pipewrite>:
++
++//PAGEBREAK: 40
++int
++pipewrite(struct pipe *p, char *addr, int n)
++{
++80103300:	55                   	push   %ebp
++80103301:	89 e5                	mov    %esp,%ebp
++80103303:	57                   	push   %edi
++80103304:	56                   	push   %esi
++80103305:	53                   	push   %ebx
++80103306:	83 ec 1c             	sub    $0x1c,%esp
++80103309:	8b 5d 08             	mov    0x8(%ebp),%ebx
++  int i;
++
++  acquire(&p->lock);
++8010330c:	89 1c 24             	mov    %ebx,(%esp)
++8010330f:	e8 3c 0e 00 00       	call   80104150 <acquire>
++  for(i = 0; i < n; i++){
++80103314:	8b 4d 10             	mov    0x10(%ebp),%ecx
++80103317:	85 c9                	test   %ecx,%ecx
++80103319:	0f 8e b2 00 00 00    	jle    801033d1 <pipewrite+0xd1>
++8010331f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
++    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
++      if(p->readopen == 0 || myproc()->killed){
++        release(&p->lock);
++        return -1;
++      }
++      wakeup(&p->nread);
++80103322:	8d bb 34 02 00 00    	lea    0x234(%ebx),%edi
++80103328:	8b 83 38 02 00 00    	mov    0x238(%ebx),%eax
++      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
++8010332e:	8d b3 38 02 00 00    	lea    0x238(%ebx),%esi
++80103334:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
++80103337:	03 4d 10             	add    0x10(%ebp),%ecx
++8010333a:	89 4d e0             	mov    %ecx,-0x20(%ebp)
++    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
++8010333d:	8b 8b 34 02 00 00    	mov    0x234(%ebx),%ecx
++80103343:	81 c1 00 02 00 00    	add    $0x200,%ecx
++80103349:	39 c8                	cmp    %ecx,%eax
++8010334b:	74 38                	je     80103385 <pipewrite+0x85>
++8010334d:	eb 55                	jmp    801033a4 <pipewrite+0xa4>
++8010334f:	90                   	nop
++      if(p->readopen == 0 || myproc()->killed){
++80103350:	e8 5b 03 00 00       	call   801036b0 <myproc>
++80103355:	8b 40 24             	mov    0x24(%eax),%eax
++80103358:	85 c0                	test   %eax,%eax
++8010335a:	75 33                	jne    8010338f <pipewrite+0x8f>
++      wakeup(&p->nread);
++8010335c:	89 3c 24             	mov    %edi,(%esp)
++8010335f:	e8 3c 0a 00 00       	call   80103da0 <wakeup>
++      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
++80103364:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++80103368:	89 34 24             	mov    %esi,(%esp)
++8010336b:	e8 a0 08 00 00       	call   80103c10 <sleep>
++    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
++80103370:	8b 83 34 02 00 00    	mov    0x234(%ebx),%eax
++80103376:	8b 93 38 02 00 00    	mov    0x238(%ebx),%edx
++8010337c:	05 00 02 00 00       	add    $0x200,%eax
++80103381:	39 c2                	cmp    %eax,%edx
++80103383:	75 23                	jne    801033a8 <pipewrite+0xa8>
++      if(p->readopen == 0 || myproc()->killed){
++80103385:	8b 93 3c 02 00 00    	mov    0x23c(%ebx),%edx
++8010338b:	85 d2                	test   %edx,%edx
++8010338d:	75 c1                	jne    80103350 <pipewrite+0x50>
++        release(&p->lock);
++8010338f:	89 1c 24             	mov    %ebx,(%esp)
++80103392:	e8 a9 0e 00 00       	call   80104240 <release>
++        return -1;
++80103397:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++    p->data[p->nwrite++ % PIPESIZE] = addr[i];
++  }
++  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
++  release(&p->lock);
++  return n;
++}
++8010339c:	83 c4 1c             	add    $0x1c,%esp
++8010339f:	5b                   	pop    %ebx
++801033a0:	5e                   	pop    %esi
++801033a1:	5f                   	pop    %edi
++801033a2:	5d                   	pop    %ebp
++801033a3:	c3                   	ret    
++    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
++801033a4:	89 c2                	mov    %eax,%edx
++801033a6:	66 90                	xchg   %ax,%ax
++    p->data[p->nwrite++ % PIPESIZE] = addr[i];
++801033a8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
++801033ab:	8d 42 01             	lea    0x1(%edx),%eax
++801033ae:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
++801033b4:	89 83 38 02 00 00    	mov    %eax,0x238(%ebx)
++801033ba:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
++801033be:	0f b6 09             	movzbl (%ecx),%ecx
++801033c1:	88 4c 13 34          	mov    %cl,0x34(%ebx,%edx,1)
++  for(i = 0; i < n; i++){
++801033c5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
++801033c8:	3b 4d e0             	cmp    -0x20(%ebp),%ecx
++801033cb:	0f 85 6c ff ff ff    	jne    8010333d <pipewrite+0x3d>
++  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
++801033d1:	8d 83 34 02 00 00    	lea    0x234(%ebx),%eax
++801033d7:	89 04 24             	mov    %eax,(%esp)
++801033da:	e8 c1 09 00 00       	call   80103da0 <wakeup>
++  release(&p->lock);
++801033df:	89 1c 24             	mov    %ebx,(%esp)
++801033e2:	e8 59 0e 00 00       	call   80104240 <release>
++  return n;
++801033e7:	8b 45 10             	mov    0x10(%ebp),%eax
++801033ea:	eb b0                	jmp    8010339c <pipewrite+0x9c>
++801033ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++
++801033f0 <piperead>:
++
++int
++piperead(struct pipe *p, char *addr, int n)
++{
++801033f0:	55                   	push   %ebp
++801033f1:	89 e5                	mov    %esp,%ebp
++801033f3:	57                   	push   %edi
++801033f4:	56                   	push   %esi
++801033f5:	53                   	push   %ebx
++801033f6:	83 ec 1c             	sub    $0x1c,%esp
++801033f9:	8b 75 08             	mov    0x8(%ebp),%esi
++801033fc:	8b 7d 0c             	mov    0xc(%ebp),%edi
++  int i;
++
++  acquire(&p->lock);
++801033ff:	89 34 24             	mov    %esi,(%esp)
++80103402:	e8 49 0d 00 00       	call   80104150 <acquire>
++  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
++80103407:	8b 86 34 02 00 00    	mov    0x234(%esi),%eax
++8010340d:	3b 86 38 02 00 00    	cmp    0x238(%esi),%eax
++80103413:	75 5b                	jne    80103470 <piperead+0x80>
++80103415:	8b 9e 40 02 00 00    	mov    0x240(%esi),%ebx
++8010341b:	85 db                	test   %ebx,%ebx
++8010341d:	74 51                	je     80103470 <piperead+0x80>
++    if(myproc()->killed){
++      release(&p->lock);
++      return -1;
++    }
++    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
++8010341f:	8d 9e 34 02 00 00    	lea    0x234(%esi),%ebx
++80103425:	eb 25                	jmp    8010344c <piperead+0x5c>
++80103427:	90                   	nop
++80103428:	89 74 24 04          	mov    %esi,0x4(%esp)
++8010342c:	89 1c 24             	mov    %ebx,(%esp)
++8010342f:	e8 dc 07 00 00       	call   80103c10 <sleep>
++  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
++80103434:	8b 86 34 02 00 00    	mov    0x234(%esi),%eax
++8010343a:	3b 86 38 02 00 00    	cmp    0x238(%esi),%eax
++80103440:	75 2e                	jne    80103470 <piperead+0x80>
++80103442:	8b 96 40 02 00 00    	mov    0x240(%esi),%edx
++80103448:	85 d2                	test   %edx,%edx
++8010344a:	74 24                	je     80103470 <piperead+0x80>
++    if(myproc()->killed){
++8010344c:	e8 5f 02 00 00       	call   801036b0 <myproc>
++80103451:	8b 48 24             	mov    0x24(%eax),%ecx
++80103454:	85 c9                	test   %ecx,%ecx
++80103456:	74 d0                	je     80103428 <piperead+0x38>
++      release(&p->lock);
++80103458:	89 34 24             	mov    %esi,(%esp)
++8010345b:	e8 e0 0d 00 00       	call   80104240 <release>
++    addr[i] = p->data[p->nread++ % PIPESIZE];
++  }
++  wakeup(&p->nwrite);  //DOC: piperead-wakeup
++  release(&p->lock);
++  return i;
++}
++80103460:	83 c4 1c             	add    $0x1c,%esp
++      return -1;
++80103463:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
++}
++80103468:	5b                   	pop    %ebx
++80103469:	5e                   	pop    %esi
++8010346a:	5f                   	pop    %edi
++8010346b:	5d                   	pop    %ebp
++8010346c:	c3                   	ret    
++8010346d:	8d 76 00             	lea    0x0(%esi),%esi
++  for(i = 0; i < n; i++){  //DOC: piperead-copy
++80103470:	8b 55 10             	mov    0x10(%ebp),%edx
++    if(p->nread == p->nwrite)
++80103473:	31 db                	xor    %ebx,%ebx
++  for(i = 0; i < n; i++){  //DOC: piperead-copy
++80103475:	85 d2                	test   %edx,%edx
++80103477:	7f 2b                	jg     801034a4 <piperead+0xb4>
++80103479:	eb 31                	jmp    801034ac <piperead+0xbc>
++8010347b:	90                   	nop
++8010347c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    addr[i] = p->data[p->nread++ % PIPESIZE];
++80103480:	8d 48 01             	lea    0x1(%eax),%ecx
++80103483:	25 ff 01 00 00       	and    $0x1ff,%eax
++80103488:	89 8e 34 02 00 00    	mov    %ecx,0x234(%esi)
++8010348e:	0f b6 44 06 34       	movzbl 0x34(%esi,%eax,1),%eax
++80103493:	88 04 1f             	mov    %al,(%edi,%ebx,1)
++  for(i = 0; i < n; i++){  //DOC: piperead-copy
++80103496:	83 c3 01             	add    $0x1,%ebx
++80103499:	3b 5d 10             	cmp    0x10(%ebp),%ebx
++8010349c:	74 0e                	je     801034ac <piperead+0xbc>
++    if(p->nread == p->nwrite)
++8010349e:	8b 86 34 02 00 00    	mov    0x234(%esi),%eax
++801034a4:	3b 86 38 02 00 00    	cmp    0x238(%esi),%eax
++801034aa:	75 d4                	jne    80103480 <piperead+0x90>
++  wakeup(&p->nwrite);  //DOC: piperead-wakeup
++801034ac:	8d 86 38 02 00 00    	lea    0x238(%esi),%eax
++801034b2:	89 04 24             	mov    %eax,(%esp)
++801034b5:	e8 e6 08 00 00       	call   80103da0 <wakeup>
++  release(&p->lock);
++801034ba:	89 34 24             	mov    %esi,(%esp)
++801034bd:	e8 7e 0d 00 00       	call   80104240 <release>
++}
++801034c2:	83 c4 1c             	add    $0x1c,%esp
++  return i;
++801034c5:	89 d8                	mov    %ebx,%eax
++}
++801034c7:	5b                   	pop    %ebx
++801034c8:	5e                   	pop    %esi
++801034c9:	5f                   	pop    %edi
++801034ca:	5d                   	pop    %ebp
++801034cb:	c3                   	ret    
++801034cc:	66 90                	xchg   %ax,%ax
++801034ce:	66 90                	xchg   %ax,%ax
++
++801034d0 <allocproc>:
++// If found, change state to EMBRYO and initialize
++// state required to run in the kernel.
++// Otherwise return 0.
++static struct proc*
++allocproc(void)
++{
++801034d0:	55                   	push   %ebp
++801034d1:	89 e5                	mov    %esp,%ebp
++801034d3:	53                   	push   %ebx
++  struct proc *p;
++  char *sp;
++
++  acquire(&ptable.lock);
++
++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++801034d4:	bb 54 2d 11 80       	mov    $0x80112d54,%ebx
++{
++801034d9:	83 ec 14             	sub    $0x14,%esp
++  acquire(&ptable.lock);
++801034dc:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
++801034e3:	e8 68 0c 00 00       	call   80104150 <acquire>
++801034e8:	eb 11                	jmp    801034fb <allocproc+0x2b>
++801034ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++801034f0:	83 c3 7c             	add    $0x7c,%ebx
++801034f3:	81 fb 54 4c 11 80    	cmp    $0x80114c54,%ebx
++801034f9:	74 7d                	je     80103578 <allocproc+0xa8>
++    if(p->state == UNUSED)
++801034fb:	8b 43 0c             	mov    0xc(%ebx),%eax
++801034fe:	85 c0                	test   %eax,%eax
++80103500:	75 ee                	jne    801034f0 <allocproc+0x20>
++  release(&ptable.lock);
++  return 0;
++
++found:
++  p->state = EMBRYO;
++  p->pid = nextpid++;
++80103502:	a1 04 a0 10 80       	mov    0x8010a004,%eax
++
++  release(&ptable.lock);
++80103507:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
++  p->state = EMBRYO;
++8010350e:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
++  p->pid = nextpid++;
++80103515:	8d 50 01             	lea    0x1(%eax),%edx
++80103518:	89 15 04 a0 10 80    	mov    %edx,0x8010a004
++8010351e:	89 43 10             	mov    %eax,0x10(%ebx)
++  release(&ptable.lock);
++80103521:	e8 1a 0d 00 00       	call   80104240 <release>
++
++  // Allocate kernel stack.
++  if((p->kstack = kalloc()) == 0){
++80103526:	e8 85 ef ff ff       	call   801024b0 <kalloc>
++8010352b:	85 c0                	test   %eax,%eax
++8010352d:	89 43 08             	mov    %eax,0x8(%ebx)
++80103530:	74 5a                	je     8010358c <allocproc+0xbc>
++    return 0;
++  }
++  sp = p->kstack + KSTACKSIZE;
++
++  // Leave room for trap frame.
++  sp -= sizeof *p->tf;
++80103532:	8d 90 b4 0f 00 00    	lea    0xfb4(%eax),%edx
++  // Set up new context to start executing at forkret,
++  // which returns to trapret.
++  sp -= 4;
++  *(uint*)sp = (uint)trapret;
++
++  sp -= sizeof *p->context;
++80103538:	05 9c 0f 00 00       	add    $0xf9c,%eax
++  sp -= sizeof *p->tf;
++8010353d:	89 53 18             	mov    %edx,0x18(%ebx)
++  *(uint*)sp = (uint)trapret;
++80103540:	c7 40 14 65 54 10 80 	movl   $0x80105465,0x14(%eax)
++  p->context = (struct context*)sp;
++  memset(p->context, 0, sizeof *p->context);
++80103547:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
++8010354e:	00 
++8010354f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
++80103556:	00 
++80103557:	89 04 24             	mov    %eax,(%esp)
++  p->context = (struct context*)sp;
++8010355a:	89 43 1c             	mov    %eax,0x1c(%ebx)
++  memset(p->context, 0, sizeof *p->context);
++8010355d:	e8 2e 0d 00 00       	call   80104290 <memset>
++  p->context->eip = (uint)forkret;
++80103562:	8b 43 1c             	mov    0x1c(%ebx),%eax
++80103565:	c7 40 10 a0 35 10 80 	movl   $0x801035a0,0x10(%eax)
++
++  return p;
++8010356c:	89 d8                	mov    %ebx,%eax
++}
++8010356e:	83 c4 14             	add    $0x14,%esp
++80103571:	5b                   	pop    %ebx
++80103572:	5d                   	pop    %ebp
++80103573:	c3                   	ret    
++80103574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++  release(&ptable.lock);
++80103578:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
++  }while((x /= base) != 0);
++    1350:	85 c0                	test   %eax,%eax
++    buf[i++] = digits[x % base];
++    1352:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
++  }while((x /= base) != 0);
++    1355:	75 e9                	jne    1340 <printint+0x30>
++  if(neg)
++    1357:	8b 55 c4             	mov    -0x3c(%ebp),%edx
++    buf[i++] = digits[x % base];
++    135a:	89 c8                	mov    %ecx,%eax
++    135c:	8b 75 c0             	mov    -0x40(%ebp),%esi
++  if(neg)
++    135f:	85 d2                	test   %edx,%edx
++    1361:	74 08                	je     136b <printint+0x5b>
++    buf[i++] = '-';
++    1363:	8d 4f 02             	lea    0x2(%edi),%ecx
++    1366:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
++
++  while(--i >= 0)
++    136b:	8d 79 ff             	lea    -0x1(%ecx),%edi
++    136e:	66 90                	xchg   %ax,%ax
++    1370:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
++    1375:	83 ef 01             	sub    $0x1,%edi
++  write(fd, &c, 1);
++    1378:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    137f:	00 
++    1380:	89 5c 24 04          	mov    %ebx,0x4(%esp)
++    1384:	89 34 24             	mov    %esi,(%esp)
++    1387:	88 45 d7             	mov    %al,-0x29(%ebp)
++    138a:	e8 e3 fe ff ff       	call   1272 <write>
++  while(--i >= 0)
++    138f:	83 ff ff             	cmp    $0xffffffff,%edi
++    1392:	75 dc                	jne    1370 <printint+0x60>
++    putc(fd, buf[i]);
++}
++    1394:	83 c4 4c             	add    $0x4c,%esp
++    1397:	5b                   	pop    %ebx
++    1398:	5e                   	pop    %esi
++    1399:	5f                   	pop    %edi
++    139a:	5d                   	pop    %ebp
++    139b:	c3                   	ret    
++    139c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
++    x = -xx;
++    13a0:	89 d0                	mov    %edx,%eax
++    13a2:	f7 d8                	neg    %eax
++    neg = 1;
++    13a4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
++    13ab:	eb 87                	jmp    1334 <printint+0x24>
++    13ad:	8d 76 00             	lea    0x0(%esi),%esi
++
++000013b0 <printf>:
++
++// Print to the given fd. Only understands %d, %x, %p, %s.
++void
++printf(int fd, char *fmt, ...)
++{
++    13b0:	55                   	push   %ebp
++    13b1:	89 e5                	mov    %esp,%ebp
++    13b3:	57                   	push   %edi
++  char *s;
++  int c, i, state;
++  uint *ap;
++
++  state = 0;
++    13b4:	31 ff                	xor    %edi,%edi
++{
++    13b6:	56                   	push   %esi
++    13b7:	53                   	push   %ebx
++    13b8:	83 ec 3c             	sub    $0x3c,%esp
++  ap = (uint*)(void*)&fmt + 1;
++  for(i = 0; fmt[i]; i++){
++    13bb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
++  ap = (uint*)(void*)&fmt + 1;
++    13be:	8d 45 10             	lea    0x10(%ebp),%eax
++{
++    13c1:	8b 75 08             	mov    0x8(%ebp),%esi
++  ap = (uint*)(void*)&fmt + 1;
++    13c4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
++  for(i = 0; fmt[i]; i++){
++    13c7:	0f b6 13             	movzbl (%ebx),%edx
++    13ca:	83 c3 01             	add    $0x1,%ebx
++    13cd:	84 d2                	test   %dl,%dl
++    13cf:	75 39                	jne    140a <printf+0x5a>
++    13d1:	e9 c2 00 00 00       	jmp    1498 <printf+0xe8>
++    13d6:	66 90                	xchg   %ax,%ax
++    c = fmt[i] & 0xff;
++    if(state == 0){
++      if(c == '%'){
++    13d8:	83 fa 25             	cmp    $0x25,%edx
++    13db:	0f 84 bf 00 00 00    	je     14a0 <printf+0xf0>
++  write(fd, &c, 1);
++    13e1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
++    13e4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    13eb:	00 
++    13ec:	89 44 24 04          	mov    %eax,0x4(%esp)
++    13f0:	89 34 24             	mov    %esi,(%esp)
++        state = '%';
++      } else {
++        putc(fd, c);
++    13f3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
++  write(fd, &c, 1);
++    13f6:	e8 77 fe ff ff       	call   1272 <write>
++    13fb:	83 c3 01             	add    $0x1,%ebx
++  for(i = 0; fmt[i]; i++){
++    13fe:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
++    1402:	84 d2                	test   %dl,%dl
++    1404:	0f 84 8e 00 00 00    	je     1498 <printf+0xe8>
++    if(state == 0){
++    140a:	85 ff                	test   %edi,%edi
++    c = fmt[i] & 0xff;
++    140c:	0f be c2             	movsbl %dl,%eax
++    if(state == 0){
++    140f:	74 c7                	je     13d8 <printf+0x28>
++      }
++    } else if(state == '%'){
++    1411:	83 ff 25             	cmp    $0x25,%edi
++    1414:	75 e5                	jne    13fb <printf+0x4b>
++      if(c == 'd'){
++    1416:	83 fa 64             	cmp    $0x64,%edx
++    1419:	0f 84 31 01 00 00    	je     1550 <printf+0x1a0>
++        printint(fd, *ap, 10, 1);
++        ap++;
++      } else if(c == 'x' || c == 'p'){
++    141f:	25 f7 00 00 00       	and    $0xf7,%eax
++    1424:	83 f8 70             	cmp    $0x70,%eax
++    1427:	0f 84 83 00 00 00    	je     14b0 <printf+0x100>
++        printint(fd, *ap, 16, 0);
++        ap++;
++      } else if(c == 's'){
++    142d:	83 fa 73             	cmp    $0x73,%edx
++    1430:	0f 84 a2 00 00 00    	je     14d8 <printf+0x128>
++          s = "(null)";
++        while(*s != 0){
++          putc(fd, *s);
++          s++;
++        }
++      } else if(c == 'c'){
++    1436:	83 fa 63             	cmp    $0x63,%edx
++    1439:	0f 84 35 01 00 00    	je     1574 <printf+0x1c4>
++        putc(fd, *ap);
++        ap++;
++      } else if(c == '%'){
++    143f:	83 fa 25             	cmp    $0x25,%edx
++    1442:	0f 84 e0 00 00 00    	je     1528 <printf+0x178>
++  write(fd, &c, 1);
++    1448:	8d 45 e6             	lea    -0x1a(%ebp),%eax
++    144b:	83 c3 01             	add    $0x1,%ebx
++    144e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
++    1455:	00 
++      } else {
++        // Unknown % sequence.  Print it to draw attention.
++        putc(fd, '%');
++        putc(fd, c);
++      }
diff --git a/console.d b/console.d
new file mode 100644
index 0000000..7b5564c
--- /dev/null
+++ b/console.d
@@ -0,0 +1,3 @@
+console.o: console.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ traps.h spinlock.h sleeplock.h fs.h file.h memlayout.h mmu.h proc.h \
+ x86.h
diff --git a/console.o b/console.o
new file mode 100644
index 0000000..0ab1ff5
Binary files /dev/null and b/console.o differ
diff --git a/defs.h b/defs.h
index d1934ca..889539b 100644
--- a/defs.h
+++ b/defs.h
@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
 //PAGEBREAK: 16
 // proc.c
 int             cpuid(void);
-void            exit(int status);
+void            exit(void);
 int             fork(void);
 int             growproc(int);
 int             kill(int);
@@ -117,8 +117,7 @@ void            sched(void);
 void            setproc(struct proc*);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
-int             wait(int* status);
-int             waitpid(int pid, int* status, int options);
+int             wait(void);
 void            wakeup(void*);
 void            yield(void);
 
@@ -187,5 +186,14 @@ void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
 
+//made mappages visible (and removed static) to facilitate implementing shm
+int
+mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm);
+
+//shm.c
+void shminit(void);
+int shm_open(int id, char **pointer);
+int shm_close(int id);
+
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/echo.asm b/echo.asm
new file mode 100644
index 0000000..46b5f43
--- /dev/null
+++ b/echo.asm
@@ -0,0 +1,1220 @@
+
+_echo:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	57                   	push   %edi
+    1004:	56                   	push   %esi
+    1005:	53                   	push   %ebx
+    1006:	83 e4 f0             	and    $0xfffffff0,%esp
+    1009:	83 ec 10             	sub    $0x10,%esp
+    100c:	8b 75 08             	mov    0x8(%ebp),%esi
+    100f:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  int i;
+
+  for(i = 1; i < argc; i++)
+    1012:	83 fe 01             	cmp    $0x1,%esi
+    1015:	7e 58                	jle    106f <main+0x6f>
+    1017:	bb 01 00 00 00       	mov    $0x1,%ebx
+    101c:	eb 26                	jmp    1044 <main+0x44>
+    101e:	66 90                	xchg   %ax,%ax
+    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+    1020:	c7 44 24 0c a1 17 00 	movl   $0x17a1,0xc(%esp)
+    1027:	00 
+    1028:	8b 44 9f fc          	mov    -0x4(%edi,%ebx,4),%eax
+    102c:	c7 44 24 04 a3 17 00 	movl   $0x17a3,0x4(%esp)
+    1033:	00 
+    1034:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    103b:	89 44 24 08          	mov    %eax,0x8(%esp)
+    103f:	e8 bc 03 00 00       	call   1400 <printf>
+    1044:	83 c3 01             	add    $0x1,%ebx
+    1047:	39 f3                	cmp    %esi,%ebx
+    1049:	75 d5                	jne    1020 <main+0x20>
+    104b:	c7 44 24 0c a8 17 00 	movl   $0x17a8,0xc(%esp)
+    1052:	00 
+    1053:	8b 44 9f fc          	mov    -0x4(%edi,%ebx,4),%eax
+    1057:	c7 44 24 04 a3 17 00 	movl   $0x17a3,0x4(%esp)
+    105e:	00 
+    105f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1066:	89 44 24 08          	mov    %eax,0x8(%esp)
+    106a:	e8 91 03 00 00       	call   1400 <printf>
+  exit();
+    106f:	e8 2e 02 00 00       	call   12a2 <exit>
+    1074:	66 90                	xchg   %ax,%ax
+    1076:	66 90                	xchg   %ax,%ax
+    1078:	66 90                	xchg   %ax,%ax
+    107a:	66 90                	xchg   %ax,%ax
+    107c:	66 90                	xchg   %ax,%ax
+    107e:	66 90                	xchg   %ax,%ax
+
+00001080 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1080:	55                   	push   %ebp
+    1081:	89 e5                	mov    %esp,%ebp
+    1083:	8b 45 08             	mov    0x8(%ebp),%eax
+    1086:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1089:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    108a:	89 c2                	mov    %eax,%edx
+    108c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1090:	83 c1 01             	add    $0x1,%ecx
+    1093:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1097:	83 c2 01             	add    $0x1,%edx
+    109a:	84 db                	test   %bl,%bl
+    109c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    109f:	75 ef                	jne    1090 <strcpy+0x10>
+    ;
+  return os;
+}
+    10a1:	5b                   	pop    %ebx
+    10a2:	5d                   	pop    %ebp
+    10a3:	c3                   	ret    
+    10a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    10aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+000010b0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    10b0:	55                   	push   %ebp
+    10b1:	89 e5                	mov    %esp,%ebp
+    10b3:	8b 55 08             	mov    0x8(%ebp),%edx
+    10b6:	53                   	push   %ebx
+    10b7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    10ba:	0f b6 02             	movzbl (%edx),%eax
+    10bd:	84 c0                	test   %al,%al
+    10bf:	74 2d                	je     10ee <strcmp+0x3e>
+    10c1:	0f b6 19             	movzbl (%ecx),%ebx
+    10c4:	38 d8                	cmp    %bl,%al
+    10c6:	74 0e                	je     10d6 <strcmp+0x26>
+    10c8:	eb 2b                	jmp    10f5 <strcmp+0x45>
+    10ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    10d0:	38 c8                	cmp    %cl,%al
+    10d2:	75 15                	jne    10e9 <strcmp+0x39>
+    p++, q++;
+    10d4:	89 d9                	mov    %ebx,%ecx
+    10d6:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    10d9:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    10dc:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    10df:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    10e3:	84 c0                	test   %al,%al
+    10e5:	75 e9                	jne    10d0 <strcmp+0x20>
+    10e7:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    10e9:	29 c8                	sub    %ecx,%eax
+}
+    10eb:	5b                   	pop    %ebx
+    10ec:	5d                   	pop    %ebp
+    10ed:	c3                   	ret    
+    10ee:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    10f1:	31 c0                	xor    %eax,%eax
+    10f3:	eb f4                	jmp    10e9 <strcmp+0x39>
+    10f5:	0f b6 cb             	movzbl %bl,%ecx
+    10f8:	eb ef                	jmp    10e9 <strcmp+0x39>
+    10fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001100 <strlen>:
+
+uint
+strlen(char *s)
+{
+    1100:	55                   	push   %ebp
+    1101:	89 e5                	mov    %esp,%ebp
+    1103:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    1106:	80 39 00             	cmpb   $0x0,(%ecx)
+    1109:	74 12                	je     111d <strlen+0x1d>
+    110b:	31 d2                	xor    %edx,%edx
+    110d:	8d 76 00             	lea    0x0(%esi),%esi
+    1110:	83 c2 01             	add    $0x1,%edx
+    1113:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    1117:	89 d0                	mov    %edx,%eax
+    1119:	75 f5                	jne    1110 <strlen+0x10>
+    ;
+  return n;
+}
+    111b:	5d                   	pop    %ebp
+    111c:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    111d:	31 c0                	xor    %eax,%eax
+}
+    111f:	5d                   	pop    %ebp
+    1120:	c3                   	ret    
+    1121:	eb 0d                	jmp    1130 <memset>
+    1123:	90                   	nop
+    1124:	90                   	nop
+    1125:	90                   	nop
+    1126:	90                   	nop
+    1127:	90                   	nop
+    1128:	90                   	nop
+    1129:	90                   	nop
+    112a:	90                   	nop
+    112b:	90                   	nop
+    112c:	90                   	nop
+    112d:	90                   	nop
+    112e:	90                   	nop
+    112f:	90                   	nop
+
+00001130 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    1130:	55                   	push   %ebp
+    1131:	89 e5                	mov    %esp,%ebp
+    1133:	8b 55 08             	mov    0x8(%ebp),%edx
+    1136:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    1137:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    113a:	8b 45 0c             	mov    0xc(%ebp),%eax
+    113d:	89 d7                	mov    %edx,%edi
+    113f:	fc                   	cld    
+    1140:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    1142:	89 d0                	mov    %edx,%eax
+    1144:	5f                   	pop    %edi
+    1145:	5d                   	pop    %ebp
+    1146:	c3                   	ret    
+    1147:	89 f6                	mov    %esi,%esi
+    1149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001150 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    1150:	55                   	push   %ebp
+    1151:	89 e5                	mov    %esp,%ebp
+    1153:	8b 45 08             	mov    0x8(%ebp),%eax
+    1156:	53                   	push   %ebx
+    1157:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    115a:	0f b6 18             	movzbl (%eax),%ebx
+    115d:	84 db                	test   %bl,%bl
+    115f:	74 1d                	je     117e <strchr+0x2e>
+    if(*s == c)
+    1161:	38 d3                	cmp    %dl,%bl
+    1163:	89 d1                	mov    %edx,%ecx
+    1165:	75 0d                	jne    1174 <strchr+0x24>
+    1167:	eb 17                	jmp    1180 <strchr+0x30>
+    1169:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1170:	38 ca                	cmp    %cl,%dl
+    1172:	74 0c                	je     1180 <strchr+0x30>
+  for(; *s; s++)
+    1174:	83 c0 01             	add    $0x1,%eax
+    1177:	0f b6 10             	movzbl (%eax),%edx
+    117a:	84 d2                	test   %dl,%dl
+    117c:	75 f2                	jne    1170 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    117e:	31 c0                	xor    %eax,%eax
+}
+    1180:	5b                   	pop    %ebx
+    1181:	5d                   	pop    %ebp
+    1182:	c3                   	ret    
+    1183:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1189:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001190 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1190:	55                   	push   %ebp
+    1191:	89 e5                	mov    %esp,%ebp
+    1193:	57                   	push   %edi
+    1194:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1195:	31 f6                	xor    %esi,%esi
+{
+    1197:	53                   	push   %ebx
+    1198:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    119b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    119e:	eb 31                	jmp    11d1 <gets+0x41>
+    cc = read(0, &c, 1);
+    11a0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    11a7:	00 
+    11a8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    11ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    11b3:	e8 02 01 00 00       	call   12ba <read>
+    if(cc < 1)
+    11b8:	85 c0                	test   %eax,%eax
+    11ba:	7e 1d                	jle    11d9 <gets+0x49>
+      break;
+    buf[i++] = c;
+    11bc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    11c0:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    11c2:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    11c5:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    11c7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    11cb:	74 0c                	je     11d9 <gets+0x49>
+    11cd:	3c 0a                	cmp    $0xa,%al
+    11cf:	74 08                	je     11d9 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    11d1:	8d 5e 01             	lea    0x1(%esi),%ebx
+    11d4:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    11d7:	7c c7                	jl     11a0 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    11d9:	8b 45 08             	mov    0x8(%ebp),%eax
+    11dc:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    11e0:	83 c4 2c             	add    $0x2c,%esp
+    11e3:	5b                   	pop    %ebx
+    11e4:	5e                   	pop    %esi
+    11e5:	5f                   	pop    %edi
+    11e6:	5d                   	pop    %ebp
+    11e7:	c3                   	ret    
+    11e8:	90                   	nop
+    11e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000011f0 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    11f0:	55                   	push   %ebp
+    11f1:	89 e5                	mov    %esp,%ebp
+    11f3:	56                   	push   %esi
+    11f4:	53                   	push   %ebx
+    11f5:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    11f8:	8b 45 08             	mov    0x8(%ebp),%eax
+    11fb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1202:	00 
+    1203:	89 04 24             	mov    %eax,(%esp)
+    1206:	e8 d7 00 00 00       	call   12e2 <open>
+  if(fd < 0)
+    120b:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    120d:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    120f:	78 27                	js     1238 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    1211:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1214:	89 1c 24             	mov    %ebx,(%esp)
+    1217:	89 44 24 04          	mov    %eax,0x4(%esp)
+    121b:	e8 da 00 00 00       	call   12fa <fstat>
+  close(fd);
+    1220:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    1223:	89 c6                	mov    %eax,%esi
+  close(fd);
+    1225:	e8 a0 00 00 00       	call   12ca <close>
+  return r;
+    122a:	89 f0                	mov    %esi,%eax
+}
+    122c:	83 c4 10             	add    $0x10,%esp
+    122f:	5b                   	pop    %ebx
+    1230:	5e                   	pop    %esi
+    1231:	5d                   	pop    %ebp
+    1232:	c3                   	ret    
+    1233:	90                   	nop
+    1234:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    1238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    123d:	eb ed                	jmp    122c <stat+0x3c>
+    123f:	90                   	nop
+
+00001240 <atoi>:
+
+int
+atoi(const char *s)
+{
+    1240:	55                   	push   %ebp
+    1241:	89 e5                	mov    %esp,%ebp
+    1243:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    1246:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    1247:	0f be 11             	movsbl (%ecx),%edx
+    124a:	8d 42 d0             	lea    -0x30(%edx),%eax
+    124d:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    124f:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    1254:	77 17                	ja     126d <atoi+0x2d>
+    1256:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    1258:	83 c1 01             	add    $0x1,%ecx
+    125b:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    125e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1262:	0f be 11             	movsbl (%ecx),%edx
+    1265:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1268:	80 fb 09             	cmp    $0x9,%bl
+    126b:	76 eb                	jbe    1258 <atoi+0x18>
+  return n;
+}
+    126d:	5b                   	pop    %ebx
+    126e:	5d                   	pop    %ebp
+    126f:	c3                   	ret    
+
+00001270 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1270:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1271:	31 d2                	xor    %edx,%edx
+{
+    1273:	89 e5                	mov    %esp,%ebp
+    1275:	56                   	push   %esi
+    1276:	8b 45 08             	mov    0x8(%ebp),%eax
+    1279:	53                   	push   %ebx
+    127a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    127d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1280:	85 db                	test   %ebx,%ebx
+    1282:	7e 12                	jle    1296 <memmove+0x26>
+    1284:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1288:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    128c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    128f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1292:	39 da                	cmp    %ebx,%edx
+    1294:	75 f2                	jne    1288 <memmove+0x18>
+  return vdst;
+}
+    1296:	5b                   	pop    %ebx
+    1297:	5e                   	pop    %esi
+    1298:	5d                   	pop    %ebp
+    1299:	c3                   	ret    
+
+0000129a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    129a:	b8 01 00 00 00       	mov    $0x1,%eax
+    129f:	cd 40                	int    $0x40
+    12a1:	c3                   	ret    
+
+000012a2 <exit>:
+SYSCALL(exit)
+    12a2:	b8 02 00 00 00       	mov    $0x2,%eax
+    12a7:	cd 40                	int    $0x40
+    12a9:	c3                   	ret    
+
+000012aa <wait>:
+SYSCALL(wait)
+    12aa:	b8 03 00 00 00       	mov    $0x3,%eax
+    12af:	cd 40                	int    $0x40
+    12b1:	c3                   	ret    
+
+000012b2 <pipe>:
+SYSCALL(pipe)
+    12b2:	b8 04 00 00 00       	mov    $0x4,%eax
+    12b7:	cd 40                	int    $0x40
+    12b9:	c3                   	ret    
+
+000012ba <read>:
+SYSCALL(read)
+    12ba:	b8 05 00 00 00       	mov    $0x5,%eax
+    12bf:	cd 40                	int    $0x40
+    12c1:	c3                   	ret    
+
+000012c2 <write>:
+SYSCALL(write)
+    12c2:	b8 10 00 00 00       	mov    $0x10,%eax
+    12c7:	cd 40                	int    $0x40
+    12c9:	c3                   	ret    
+
+000012ca <close>:
+SYSCALL(close)
+    12ca:	b8 15 00 00 00       	mov    $0x15,%eax
+    12cf:	cd 40                	int    $0x40
+    12d1:	c3                   	ret    
+
+000012d2 <kill>:
+SYSCALL(kill)
+    12d2:	b8 06 00 00 00       	mov    $0x6,%eax
+    12d7:	cd 40                	int    $0x40
+    12d9:	c3                   	ret    
+
+000012da <exec>:
+SYSCALL(exec)
+    12da:	b8 07 00 00 00       	mov    $0x7,%eax
+    12df:	cd 40                	int    $0x40
+    12e1:	c3                   	ret    
+
+000012e2 <open>:
+SYSCALL(open)
+    12e2:	b8 0f 00 00 00       	mov    $0xf,%eax
+    12e7:	cd 40                	int    $0x40
+    12e9:	c3                   	ret    
+
+000012ea <mknod>:
+SYSCALL(mknod)
+    12ea:	b8 11 00 00 00       	mov    $0x11,%eax
+    12ef:	cd 40                	int    $0x40
+    12f1:	c3                   	ret    
+
+000012f2 <unlink>:
+SYSCALL(unlink)
+    12f2:	b8 12 00 00 00       	mov    $0x12,%eax
+    12f7:	cd 40                	int    $0x40
+    12f9:	c3                   	ret    
+
+000012fa <fstat>:
+SYSCALL(fstat)
+    12fa:	b8 08 00 00 00       	mov    $0x8,%eax
+    12ff:	cd 40                	int    $0x40
+    1301:	c3                   	ret    
+
+00001302 <link>:
+SYSCALL(link)
+    1302:	b8 13 00 00 00       	mov    $0x13,%eax
+    1307:	cd 40                	int    $0x40
+    1309:	c3                   	ret    
+
+0000130a <mkdir>:
+SYSCALL(mkdir)
+    130a:	b8 14 00 00 00       	mov    $0x14,%eax
+    130f:	cd 40                	int    $0x40
+    1311:	c3                   	ret    
+
+00001312 <chdir>:
+SYSCALL(chdir)
+    1312:	b8 09 00 00 00       	mov    $0x9,%eax
+    1317:	cd 40                	int    $0x40
+    1319:	c3                   	ret    
+
+0000131a <dup>:
+SYSCALL(dup)
+    131a:	b8 0a 00 00 00       	mov    $0xa,%eax
+    131f:	cd 40                	int    $0x40
+    1321:	c3                   	ret    
+
+00001322 <getpid>:
+SYSCALL(getpid)
+    1322:	b8 0b 00 00 00       	mov    $0xb,%eax
+    1327:	cd 40                	int    $0x40
+    1329:	c3                   	ret    
+
+0000132a <sbrk>:
+SYSCALL(sbrk)
+    132a:	b8 0c 00 00 00       	mov    $0xc,%eax
+    132f:	cd 40                	int    $0x40
+    1331:	c3                   	ret    
+
+00001332 <sleep>:
+SYSCALL(sleep)
+    1332:	b8 0d 00 00 00       	mov    $0xd,%eax
+    1337:	cd 40                	int    $0x40
+    1339:	c3                   	ret    
+
+0000133a <uptime>:
+SYSCALL(uptime)
+    133a:	b8 0e 00 00 00       	mov    $0xe,%eax
+    133f:	cd 40                	int    $0x40
+    1341:	c3                   	ret    
+
+00001342 <shm_open>:
+SYSCALL(shm_open)
+    1342:	b8 16 00 00 00       	mov    $0x16,%eax
+    1347:	cd 40                	int    $0x40
+    1349:	c3                   	ret    
+
+0000134a <shm_close>:
+SYSCALL(shm_close)	
+    134a:	b8 17 00 00 00       	mov    $0x17,%eax
+    134f:	cd 40                	int    $0x40
+    1351:	c3                   	ret    
+    1352:	66 90                	xchg   %ax,%ax
+    1354:	66 90                	xchg   %ax,%ax
+    1356:	66 90                	xchg   %ax,%ax
+    1358:	66 90                	xchg   %ax,%ax
+    135a:	66 90                	xchg   %ax,%ax
+    135c:	66 90                	xchg   %ax,%ax
+    135e:	66 90                	xchg   %ax,%ax
+
+00001360 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1360:	55                   	push   %ebp
+    1361:	89 e5                	mov    %esp,%ebp
+    1363:	57                   	push   %edi
+    1364:	56                   	push   %esi
+    1365:	89 c6                	mov    %eax,%esi
+    1367:	53                   	push   %ebx
+    1368:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    136b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    136e:	85 db                	test   %ebx,%ebx
+    1370:	74 09                	je     137b <printint+0x1b>
+    1372:	89 d0                	mov    %edx,%eax
+    1374:	c1 e8 1f             	shr    $0x1f,%eax
+    1377:	84 c0                	test   %al,%al
+    1379:	75 75                	jne    13f0 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    137b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    137d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1384:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1387:	31 ff                	xor    %edi,%edi
+    1389:	89 ce                	mov    %ecx,%esi
+    138b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    138e:	eb 02                	jmp    1392 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1390:	89 cf                	mov    %ecx,%edi
+    1392:	31 d2                	xor    %edx,%edx
+    1394:	f7 f6                	div    %esi
+    1396:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1399:	0f b6 92 b1 17 00 00 	movzbl 0x17b1(%edx),%edx
+  }while((x /= base) != 0);
+    13a0:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    13a2:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    13a5:	75 e9                	jne    1390 <printint+0x30>
+  if(neg)
+    13a7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    13aa:	89 c8                	mov    %ecx,%eax
+    13ac:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    13af:	85 d2                	test   %edx,%edx
+    13b1:	74 08                	je     13bb <printint+0x5b>
+    buf[i++] = '-';
+    13b3:	8d 4f 02             	lea    0x2(%edi),%ecx
+    13b6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    13bb:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    13be:	66 90                	xchg   %ax,%ax
+    13c0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    13c5:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    13c8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    13cf:	00 
+    13d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    13d4:	89 34 24             	mov    %esi,(%esp)
+    13d7:	88 45 d7             	mov    %al,-0x29(%ebp)
+    13da:	e8 e3 fe ff ff       	call   12c2 <write>
+  while(--i >= 0)
+    13df:	83 ff ff             	cmp    $0xffffffff,%edi
+    13e2:	75 dc                	jne    13c0 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    13e4:	83 c4 4c             	add    $0x4c,%esp
+    13e7:	5b                   	pop    %ebx
+    13e8:	5e                   	pop    %esi
+    13e9:	5f                   	pop    %edi
+    13ea:	5d                   	pop    %ebp
+    13eb:	c3                   	ret    
+    13ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    13f0:	89 d0                	mov    %edx,%eax
+    13f2:	f7 d8                	neg    %eax
+    neg = 1;
+    13f4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    13fb:	eb 87                	jmp    1384 <printint+0x24>
+    13fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+00001400 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    1400:	55                   	push   %ebp
+    1401:	89 e5                	mov    %esp,%ebp
+    1403:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    1404:	31 ff                	xor    %edi,%edi
+{
+    1406:	56                   	push   %esi
+    1407:	53                   	push   %ebx
+    1408:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    140b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    140e:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    1411:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    1414:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    1417:	0f b6 13             	movzbl (%ebx),%edx
+    141a:	83 c3 01             	add    $0x1,%ebx
+    141d:	84 d2                	test   %dl,%dl
+    141f:	75 39                	jne    145a <printf+0x5a>
+    1421:	e9 c2 00 00 00       	jmp    14e8 <printf+0xe8>
+    1426:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    1428:	83 fa 25             	cmp    $0x25,%edx
+    142b:	0f 84 bf 00 00 00    	je     14f0 <printf+0xf0>
+  write(fd, &c, 1);
+    1431:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    1434:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    143b:	00 
+    143c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1440:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    1443:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    1446:	e8 77 fe ff ff       	call   12c2 <write>
+    144b:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    144e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    1452:	84 d2                	test   %dl,%dl
+    1454:	0f 84 8e 00 00 00    	je     14e8 <printf+0xe8>
+    if(state == 0){
+    145a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    145c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    145f:	74 c7                	je     1428 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1461:	83 ff 25             	cmp    $0x25,%edi
+    1464:	75 e5                	jne    144b <printf+0x4b>
+      if(c == 'd'){
+    1466:	83 fa 64             	cmp    $0x64,%edx
+    1469:	0f 84 31 01 00 00    	je     15a0 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    146f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1474:	83 f8 70             	cmp    $0x70,%eax
+    1477:	0f 84 83 00 00 00    	je     1500 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    147d:	83 fa 73             	cmp    $0x73,%edx
+    1480:	0f 84 a2 00 00 00    	je     1528 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1486:	83 fa 63             	cmp    $0x63,%edx
+    1489:	0f 84 35 01 00 00    	je     15c4 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    148f:	83 fa 25             	cmp    $0x25,%edx
+    1492:	0f 84 e0 00 00 00    	je     1578 <printf+0x178>
+  write(fd, &c, 1);
+    1498:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    149b:	83 c3 01             	add    $0x1,%ebx
+    149e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14a5:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    14a6:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    14a8:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14ac:	89 34 24             	mov    %esi,(%esp)
+    14af:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    14b2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    14b6:	e8 07 fe ff ff       	call   12c2 <write>
+        putc(fd, c);
+    14bb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    14be:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    14c1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14c8:	00 
+    14c9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14cd:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    14d0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    14d3:	e8 ea fd ff ff       	call   12c2 <write>
+  for(i = 0; fmt[i]; i++){
+    14d8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    14dc:	84 d2                	test   %dl,%dl
+    14de:	0f 85 76 ff ff ff    	jne    145a <printf+0x5a>
+    14e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    14e8:	83 c4 3c             	add    $0x3c,%esp
+    14eb:	5b                   	pop    %ebx
+    14ec:	5e                   	pop    %esi
+    14ed:	5f                   	pop    %edi
+    14ee:	5d                   	pop    %ebp
+    14ef:	c3                   	ret    
+        state = '%';
+    14f0:	bf 25 00 00 00       	mov    $0x25,%edi
+    14f5:	e9 51 ff ff ff       	jmp    144b <printf+0x4b>
+    14fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    1500:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1503:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    1508:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    150a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1511:	8b 10                	mov    (%eax),%edx
+    1513:	89 f0                	mov    %esi,%eax
+    1515:	e8 46 fe ff ff       	call   1360 <printint>
+        ap++;
+    151a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    151e:	e9 28 ff ff ff       	jmp    144b <printf+0x4b>
+    1523:	90                   	nop
+    1524:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    1528:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    152b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    152f:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    1531:	b8 aa 17 00 00       	mov    $0x17aa,%eax
+    1536:	85 ff                	test   %edi,%edi
+    1538:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    153b:	0f b6 07             	movzbl (%edi),%eax
+    153e:	84 c0                	test   %al,%al
+    1540:	74 2a                	je     156c <printf+0x16c>
+    1542:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1548:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    154b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    154e:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    1551:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1558:	00 
+    1559:	89 44 24 04          	mov    %eax,0x4(%esp)
+    155d:	89 34 24             	mov    %esi,(%esp)
+    1560:	e8 5d fd ff ff       	call   12c2 <write>
+        while(*s != 0){
+    1565:	0f b6 07             	movzbl (%edi),%eax
+    1568:	84 c0                	test   %al,%al
+    156a:	75 dc                	jne    1548 <printf+0x148>
+      state = 0;
+    156c:	31 ff                	xor    %edi,%edi
+    156e:	e9 d8 fe ff ff       	jmp    144b <printf+0x4b>
+    1573:	90                   	nop
+    1574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1578:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    157b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    157d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1584:	00 
+    1585:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1589:	89 34 24             	mov    %esi,(%esp)
+    158c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1590:	e8 2d fd ff ff       	call   12c2 <write>
+    1595:	e9 b1 fe ff ff       	jmp    144b <printf+0x4b>
+    159a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    15a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    15a3:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    15a8:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    15ab:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    15b2:	8b 10                	mov    (%eax),%edx
+    15b4:	89 f0                	mov    %esi,%eax
+    15b6:	e8 a5 fd ff ff       	call   1360 <printint>
+        ap++;
+    15bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15bf:	e9 87 fe ff ff       	jmp    144b <printf+0x4b>
+        putc(fd, *ap);
+    15c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    15c7:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    15c9:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    15cb:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    15d2:	00 
+    15d3:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    15d6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    15d9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    15dc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15e0:	e8 dd fc ff ff       	call   12c2 <write>
+        ap++;
+    15e5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15e9:	e9 5d fe ff ff       	jmp    144b <printf+0x4b>
+    15ee:	66 90                	xchg   %ax,%ax
+
+000015f0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    15f0:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15f1:	a1 6c 1a 00 00       	mov    0x1a6c,%eax
+{
+    15f6:	89 e5                	mov    %esp,%ebp
+    15f8:	57                   	push   %edi
+    15f9:	56                   	push   %esi
+    15fa:	53                   	push   %ebx
+    15fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15fe:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    1600:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1603:	39 d0                	cmp    %edx,%eax
+    1605:	72 11                	jb     1618 <free+0x28>
+    1607:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1608:	39 c8                	cmp    %ecx,%eax
+    160a:	72 04                	jb     1610 <free+0x20>
+    160c:	39 ca                	cmp    %ecx,%edx
+    160e:	72 10                	jb     1620 <free+0x30>
+    1610:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1612:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1614:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1616:	73 f0                	jae    1608 <free+0x18>
+    1618:	39 ca                	cmp    %ecx,%edx
+    161a:	72 04                	jb     1620 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    161c:	39 c8                	cmp    %ecx,%eax
+    161e:	72 f0                	jb     1610 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    1620:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    1623:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    1626:	39 cf                	cmp    %ecx,%edi
+    1628:	74 1e                	je     1648 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    162a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    162d:	8b 48 04             	mov    0x4(%eax),%ecx
+    1630:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    1633:	39 f2                	cmp    %esi,%edx
+    1635:	74 28                	je     165f <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    1637:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    1639:	a3 6c 1a 00 00       	mov    %eax,0x1a6c
+}
+    163e:	5b                   	pop    %ebx
+    163f:	5e                   	pop    %esi
+    1640:	5f                   	pop    %edi
+    1641:	5d                   	pop    %ebp
+    1642:	c3                   	ret    
+    1643:	90                   	nop
+    1644:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    1648:	03 71 04             	add    0x4(%ecx),%esi
+    164b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    164e:	8b 08                	mov    (%eax),%ecx
+    1650:	8b 09                	mov    (%ecx),%ecx
+    1652:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    1655:	8b 48 04             	mov    0x4(%eax),%ecx
+    1658:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    165b:	39 f2                	cmp    %esi,%edx
+    165d:	75 d8                	jne    1637 <free+0x47>
+    p->s.size += bp->s.size;
+    165f:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    1662:	a3 6c 1a 00 00       	mov    %eax,0x1a6c
+    p->s.size += bp->s.size;
+    1667:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    166a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    166d:	89 10                	mov    %edx,(%eax)
+}
+    166f:	5b                   	pop    %ebx
+    1670:	5e                   	pop    %esi
+    1671:	5f                   	pop    %edi
+    1672:	5d                   	pop    %ebp
+    1673:	c3                   	ret    
+    1674:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    167a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001680 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1680:	55                   	push   %ebp
+    1681:	89 e5                	mov    %esp,%ebp
+    1683:	57                   	push   %edi
+    1684:	56                   	push   %esi
+    1685:	53                   	push   %ebx
+    1686:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1689:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    168c:	8b 1d 6c 1a 00 00    	mov    0x1a6c,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1692:	8d 48 07             	lea    0x7(%eax),%ecx
+    1695:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1698:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    169a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    169d:	0f 84 9b 00 00 00    	je     173e <malloc+0xbe>
+    16a3:	8b 13                	mov    (%ebx),%edx
+    16a5:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    16a8:	39 fe                	cmp    %edi,%esi
+    16aa:	76 64                	jbe    1710 <malloc+0x90>
+    16ac:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    16b3:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    16b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    16bb:	eb 0e                	jmp    16cb <malloc+0x4b>
+    16bd:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    16c0:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    16c2:	8b 78 04             	mov    0x4(%eax),%edi
+    16c5:	39 fe                	cmp    %edi,%esi
+    16c7:	76 4f                	jbe    1718 <malloc+0x98>
+    16c9:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    16cb:	3b 15 6c 1a 00 00    	cmp    0x1a6c,%edx
+    16d1:	75 ed                	jne    16c0 <malloc+0x40>
+  if(nu < 4096)
+    16d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    16d6:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    16dc:	bf 00 10 00 00       	mov    $0x1000,%edi
+    16e1:	0f 43 fe             	cmovae %esi,%edi
+    16e4:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    16e7:	89 04 24             	mov    %eax,(%esp)
+    16ea:	e8 3b fc ff ff       	call   132a <sbrk>
+  if(p == (char*)-1)
+    16ef:	83 f8 ff             	cmp    $0xffffffff,%eax
+    16f2:	74 18                	je     170c <malloc+0x8c>
+  hp->s.size = nu;
+    16f4:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    16f7:	83 c0 08             	add    $0x8,%eax
+    16fa:	89 04 24             	mov    %eax,(%esp)
+    16fd:	e8 ee fe ff ff       	call   15f0 <free>
+  return freep;
+    1702:	8b 15 6c 1a 00 00    	mov    0x1a6c,%edx
+      if((p = morecore(nunits)) == 0)
+    1708:	85 d2                	test   %edx,%edx
+    170a:	75 b4                	jne    16c0 <malloc+0x40>
+        return 0;
+    170c:	31 c0                	xor    %eax,%eax
+    170e:	eb 20                	jmp    1730 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    1710:	89 d0                	mov    %edx,%eax
+    1712:	89 da                	mov    %ebx,%edx
+    1714:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    1718:	39 fe                	cmp    %edi,%esi
+    171a:	74 1c                	je     1738 <malloc+0xb8>
+        p->s.size -= nunits;
+    171c:	29 f7                	sub    %esi,%edi
+    171e:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    1721:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    1724:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    1727:	89 15 6c 1a 00 00    	mov    %edx,0x1a6c
+      return (void*)(p + 1);
+    172d:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    1730:	83 c4 1c             	add    $0x1c,%esp
+    1733:	5b                   	pop    %ebx
+    1734:	5e                   	pop    %esi
+    1735:	5f                   	pop    %edi
+    1736:	5d                   	pop    %ebp
+    1737:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    1738:	8b 08                	mov    (%eax),%ecx
+    173a:	89 0a                	mov    %ecx,(%edx)
+    173c:	eb e9                	jmp    1727 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    173e:	c7 05 6c 1a 00 00 70 	movl   $0x1a70,0x1a6c
+    1745:	1a 00 00 
+    base.s.size = 0;
+    1748:	ba 70 1a 00 00       	mov    $0x1a70,%edx
+    base.s.ptr = freep = prevp = &base;
+    174d:	c7 05 70 1a 00 00 70 	movl   $0x1a70,0x1a70
+    1754:	1a 00 00 
+    base.s.size = 0;
+    1757:	c7 05 74 1a 00 00 00 	movl   $0x0,0x1a74
+    175e:	00 00 00 
+    1761:	e9 46 ff ff ff       	jmp    16ac <malloc+0x2c>
+    1766:	66 90                	xchg   %ax,%ax
+    1768:	66 90                	xchg   %ax,%ax
+    176a:	66 90                	xchg   %ax,%ax
+    176c:	66 90                	xchg   %ax,%ax
+    176e:	66 90                	xchg   %ax,%ax
+
+00001770 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1770:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1771:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1776:	89 e5                	mov    %esp,%ebp
+    1778:	8b 55 08             	mov    0x8(%ebp),%edx
+    177b:	90                   	nop
+    177c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1780:	89 c8                	mov    %ecx,%eax
+    1782:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1785:	85 c0                	test   %eax,%eax
+    1787:	75 f7                	jne    1780 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1789:	0f ae f0             	mfence 
+}
+    178c:	5d                   	pop    %ebp
+    178d:	c3                   	ret    
+    178e:	66 90                	xchg   %ax,%ax
+
+00001790 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1790:	55                   	push   %ebp
+    1791:	89 e5                	mov    %esp,%ebp
+    1793:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1796:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1799:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    179f:	5d                   	pop    %ebp
+    17a0:	c3                   	ret    
diff --git a/echo.c b/echo.c
index eed68a0..806dee0 100644
--- a/echo.c
+++ b/echo.c
@@ -9,5 +9,5 @@ main(int argc, char *argv[])
 
   for(i = 1; i < argc; i++)
     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
-  exit(0);
+  exit();
 }
diff --git a/echo.d b/echo.d
new file mode 100644
index 0000000..16a6098
--- /dev/null
+++ b/echo.d
@@ -0,0 +1 @@
+echo.o: echo.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/echo.o b/echo.o
new file mode 100644
index 0000000..d8ef948
Binary files /dev/null and b/echo.o differ
diff --git a/echo.sym b/echo.sym
new file mode 100644
index 0000000..5c2052d
--- /dev/null
+++ b/echo.sym
@@ -0,0 +1,62 @@
+00001000 .text
+000017a1 .rodata
+000017c4 .eh_frame
+00001a6c .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 echo.c
+00000000 ulib.c
+00000000 printf.c
+00001360 printint
+000017b1 digits.1359
+00000000 umalloc.c
+00001a6c freep
+00001a70 base
+00000000 uspinlock.c
+00001080 strcpy
+00001400 printf
+00001270 memmove
+000012ea mknod
+00001342 shm_open
+00001190 gets
+00001322 getpid
+00001680 malloc
+00001332 sleep
+000012b2 pipe
+000012c2 write
+000012fa fstat
+000012d2 kill
+00001312 chdir
+000012da exec
+000012aa wait
+000012ba read
+000012f2 unlink
+00001770 uacquire
+0000129a fork
+0000132a sbrk
+0000134a shm_close
+0000133a uptime
+00001a6c __bss_start
+00001130 memset
+00001000 main
+000010b0 strcmp
+0000131a dup
+000011f0 stat
+00001a6c _edata
+00001a78 _end
+00001302 link
+000012a2 exit
+00001240 atoi
+00001100 strlen
+000012e2 open
+00001150 strchr
+0000130a mkdir
+000012ca close
+00001790 urelease
+000015f0 free
diff --git a/entry.o b/entry.o
new file mode 100644
index 0000000..1444bf9
Binary files /dev/null and b/entry.o differ
diff --git a/entryother b/entryother
new file mode 100644
index 0000000..a7673de
Binary files /dev/null and b/entryother differ
diff --git a/entryother.asm b/entryother.asm
new file mode 100644
index 0000000..c845a5d
--- /dev/null
+++ b/entryother.asm
@@ -0,0 +1,125 @@
+
+bootblockother.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00007000 <start>:
+# This code combines elements of bootasm.S and entry.S.
+
+.code16           
+.globl start
+start:
+  cli            
+    7000:	fa                   	cli    
+
+  # Zero data segment registers DS, ES, and SS.
+  xorw    %ax,%ax
+    7001:	31 c0                	xor    %eax,%eax
+  movw    %ax,%ds
+    7003:	8e d8                	mov    %eax,%ds
+  movw    %ax,%es
+    7005:	8e c0                	mov    %eax,%es
+  movw    %ax,%ss
+    7007:	8e d0                	mov    %eax,%ss
+
+  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+  # virtual addresses map directly to physical addresses so that the
+  # effective memory map doesn't change during the transition.
+  lgdt    gdtdesc
+    7009:	0f 01 16             	lgdtl  (%esi)
+    700c:	84 70 0f             	test   %dh,0xf(%eax)
+  movl    %cr0, %eax
+    700f:	20 c0                	and    %al,%al
+  orl     $CR0_PE, %eax
+    7011:	66 83 c8 01          	or     $0x1,%ax
+  movl    %eax, %cr0
+    7015:	0f 22 c0             	mov    %eax,%cr0
+
+  # Complete the transition to 32-bit protected mode by using a long jmp
+  # to reload %cs and %eip.  The segment descriptors are set up with no
+  # translation, so that the mapping is still the identity mapping.
+  ljmpl    $(SEG_KCODE<<3), $(start32)
+    7018:	66 ea 20 70 00 00    	ljmpw  $0x0,$0x7020
+    701e:	08 00                	or     %al,(%eax)
+
+00007020 <start32>:
+
+//PAGEBREAK!
+.code32  # Tell assembler to generate 32-bit code now.
+start32:
+  # Set up the protected-mode data segment registers
+  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+    7020:	66 b8 10 00          	mov    $0x10,%ax
+  movw    %ax, %ds                # -> DS: Data Segment
+    7024:	8e d8                	mov    %eax,%ds
+  movw    %ax, %es                # -> ES: Extra Segment
+    7026:	8e c0                	mov    %eax,%es
+  movw    %ax, %ss                # -> SS: Stack Segment
+    7028:	8e d0                	mov    %eax,%ss
+  movw    $0, %ax                 # Zero segments not ready for use
+    702a:	66 b8 00 00          	mov    $0x0,%ax
+  movw    %ax, %fs                # -> FS
+    702e:	8e e0                	mov    %eax,%fs
+  movw    %ax, %gs                # -> GS
+    7030:	8e e8                	mov    %eax,%gs
+
+  # Turn on page size extension for 4Mbyte pages
+  movl    %cr4, %eax
+    7032:	0f 20 e0             	mov    %cr4,%eax
+  orl     $(CR4_PSE), %eax
+    7035:	83 c8 10             	or     $0x10,%eax
+  movl    %eax, %cr4
+    7038:	0f 22 e0             	mov    %eax,%cr4
+  # Use entrypgdir as our initial page table
+  movl    (start-12), %eax
+    703b:	a1 f4 6f 00 00       	mov    0x6ff4,%eax
+  movl    %eax, %cr3
+    7040:	0f 22 d8             	mov    %eax,%cr3
+  # Turn on paging.
+  movl    %cr0, %eax
+    7043:	0f 20 c0             	mov    %cr0,%eax
+  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
+    7046:	0d 01 00 01 80       	or     $0x80010001,%eax
+  movl    %eax, %cr0
+    704b:	0f 22 c0             	mov    %eax,%cr0
+
+  # Switch to the stack allocated by startothers()
+  movl    (start-4), %esp
+    704e:	8b 25 fc 6f 00 00    	mov    0x6ffc,%esp
+  # Call mpenter()
+  call	 *(start-8)
+    7054:	ff 15 f8 6f 00 00    	call   *0x6ff8
+
+  movw    $0x8a00, %ax
+    705a:	66 b8 00 8a          	mov    $0x8a00,%ax
+  movw    %ax, %dx
+    705e:	66 89 c2             	mov    %ax,%dx
+  outw    %ax, %dx
+    7061:	66 ef                	out    %ax,(%dx)
+  movw    $0x8ae0, %ax
+    7063:	66 b8 e0 8a          	mov    $0x8ae0,%ax
+  outw    %ax, %dx
+    7067:	66 ef                	out    %ax,(%dx)
+
+00007069 <spin>:
+spin:
+  jmp     spin
+    7069:	eb fe                	jmp    7069 <spin>
+    706b:	90                   	nop
+
+0000706c <gdt>:
+	...
+    7074:	ff                   	(bad)  
+    7075:	ff 00                	incl   (%eax)
+    7077:	00 00                	add    %al,(%eax)
+    7079:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
+    7080:	00                   	.byte 0x0
+    7081:	92                   	xchg   %eax,%edx
+    7082:	cf                   	iret   
+	...
+
+00007084 <gdtdesc>:
+    7084:	17                   	pop    %ss
+    7085:	00 6c 70 00          	add    %ch,0x0(%eax,%esi,2)
+	...
diff --git a/entryother.d b/entryother.d
new file mode 100644
index 0000000..a140303
--- /dev/null
+++ b/entryother.d
@@ -0,0 +1 @@
+entryother.o: entryother.S asm.h memlayout.h mmu.h
diff --git a/entryother.o b/entryother.o
new file mode 100644
index 0000000..3867d5d
Binary files /dev/null and b/entryother.o differ
diff --git a/exec.d b/exec.d
new file mode 100644
index 0000000..0400275
--- /dev/null
+++ b/exec.d
@@ -0,0 +1,2 @@
+exec.o: exec.c /usr/include/stdc-predef.h types.h param.h memlayout.h \
+ mmu.h proc.h defs.h x86.h elf.h
diff --git a/exec.o b/exec.o
new file mode 100644
index 0000000..cac0f43
Binary files /dev/null and b/exec.o differ
diff --git a/file.c b/file.c
index 24b32c2..95cadb3 100644
--- a/file.c
+++ b/file.c
@@ -130,7 +130,7 @@ filewrite(struct file *f, char *addr, int n)
     // and 2 blocks of slop for non-aligned writes.
     // this really belongs lower down, since writei()
     // might be writing a device like the console.
-    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
+    int max = ((LOGSIZE-1-1-2) / 2) * 512;
     int i = 0;
     while(i < n){
       int n1 = n - i;
diff --git a/file.d b/file.d
new file mode 100644
index 0000000..fea73d1
--- /dev/null
+++ b/file.d
@@ -0,0 +1,2 @@
+file.o: file.c /usr/include/stdc-predef.h types.h defs.h param.h fs.h \
+ spinlock.h sleeplock.h file.h
diff --git a/file.o b/file.o
new file mode 100644
index 0000000..3cb61d5
Binary files /dev/null and b/file.o differ
diff --git a/forktest.asm b/forktest.asm
new file mode 100644
index 0000000..7cba8fd
--- /dev/null
+++ b/forktest.asm
@@ -0,0 +1,652 @@
+
+_forktest:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+  printf(1, "fork test OK\n");
+}
+
+int
+main(void)
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	83 e4 f0             	and    $0xfffffff0,%esp
+  forktest();
+    1006:	e8 35 00 00 00       	call   1040 <forktest>
+  exit();
+    100b:	e8 32 03 00 00       	call   1342 <exit>
+
+00001010 <printf>:
+{
+    1010:	55                   	push   %ebp
+    1011:	89 e5                	mov    %esp,%ebp
+    1013:	53                   	push   %ebx
+    1014:	83 ec 14             	sub    $0x14,%esp
+    1017:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  write(fd, s, strlen(s));
+    101a:	89 1c 24             	mov    %ebx,(%esp)
+    101d:	e8 7e 01 00 00       	call   11a0 <strlen>
+    1022:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1026:	89 44 24 08          	mov    %eax,0x8(%esp)
+    102a:	8b 45 08             	mov    0x8(%ebp),%eax
+    102d:	89 04 24             	mov    %eax,(%esp)
+    1030:	e8 2d 03 00 00       	call   1362 <write>
+}
+    1035:	83 c4 14             	add    $0x14,%esp
+    1038:	5b                   	pop    %ebx
+    1039:	5d                   	pop    %ebp
+    103a:	c3                   	ret    
+    103b:	90                   	nop
+    103c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00001040 <forktest>:
+{
+    1040:	55                   	push   %ebp
+    1041:	89 e5                	mov    %esp,%ebp
+    1043:	53                   	push   %ebx
+  for(n=0; n<N; n++){
+    1044:	31 db                	xor    %ebx,%ebx
+{
+    1046:	83 ec 14             	sub    $0x14,%esp
+  printf(1, "fork test\n");
+    1049:	c7 44 24 04 f4 13 00 	movl   $0x13f4,0x4(%esp)
+    1050:	00 
+    1051:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1058:	e8 b3 ff ff ff       	call   1010 <printf>
+    105d:	eb 13                	jmp    1072 <forktest+0x32>
+    105f:	90                   	nop
+    if(pid == 0)
+    1060:	0f 84 97 00 00 00    	je     10fd <forktest+0xbd>
+  for(n=0; n<N; n++){
+    1066:	83 c3 01             	add    $0x1,%ebx
+    1069:	81 fb e8 03 00 00    	cmp    $0x3e8,%ebx
+    106f:	90                   	nop
+    1070:	74 4e                	je     10c0 <forktest+0x80>
+    pid = fork();
+    1072:	e8 c3 02 00 00       	call   133a <fork>
+    if(pid < 0)
+    1077:	85 c0                	test   %eax,%eax
+    1079:	79 e5                	jns    1060 <forktest+0x20>
+  for(; n > 0; n--){
+    107b:	85 db                	test   %ebx,%ebx
+    107d:	8d 76 00             	lea    0x0(%esi),%esi
+    1080:	74 15                	je     1097 <forktest+0x57>
+    1082:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(wait() < 0){
+    1088:	e8 bd 02 00 00       	call   134a <wait>
+    108d:	85 c0                	test   %eax,%eax
+    108f:	90                   	nop
+    1090:	78 57                	js     10e9 <forktest+0xa9>
+  for(; n > 0; n--){
+    1092:	83 eb 01             	sub    $0x1,%ebx
+    1095:	75 f1                	jne    1088 <forktest+0x48>
+  if(wait() != -1){
+    1097:	e8 ae 02 00 00       	call   134a <wait>
+    109c:	83 f8 ff             	cmp    $0xffffffff,%eax
+    109f:	90                   	nop
+    10a0:	75 60                	jne    1102 <forktest+0xc2>
+  printf(1, "fork test OK\n");
+    10a2:	c7 44 24 04 26 14 00 	movl   $0x1426,0x4(%esp)
+    10a9:	00 
+    10aa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10b1:	e8 5a ff ff ff       	call   1010 <printf>
+}
+    10b6:	83 c4 14             	add    $0x14,%esp
+    10b9:	5b                   	pop    %ebx
+    10ba:	5d                   	pop    %ebp
+    10bb:	c3                   	ret    
+    10bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, s, strlen(s));
+    10c0:	c7 04 24 34 14 00 00 	movl   $0x1434,(%esp)
+    10c7:	e8 d4 00 00 00       	call   11a0 <strlen>
+    10cc:	c7 44 24 04 34 14 00 	movl   $0x1434,0x4(%esp)
+    10d3:	00 
+    10d4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10db:	89 44 24 08          	mov    %eax,0x8(%esp)
+    10df:	e8 7e 02 00 00       	call   1362 <write>
+    exit();
+    10e4:	e8 59 02 00 00       	call   1342 <exit>
+      printf(1, "wait stopped early\n");
+    10e9:	c7 44 24 04 ff 13 00 	movl   $0x13ff,0x4(%esp)
+    10f0:	00 
+    10f1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10f8:	e8 13 ff ff ff       	call   1010 <printf>
+      exit();
+    10fd:	e8 40 02 00 00       	call   1342 <exit>
+    printf(1, "wait got too many\n");
+    1102:	c7 44 24 04 13 14 00 	movl   $0x1413,0x4(%esp)
+    1109:	00 
+    110a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1111:	e8 fa fe ff ff       	call   1010 <printf>
+    exit();
+    1116:	e8 27 02 00 00       	call   1342 <exit>
+    111b:	66 90                	xchg   %ax,%ax
+    111d:	66 90                	xchg   %ax,%ax
+    111f:	90                   	nop
+
+00001120 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1120:	55                   	push   %ebp
+    1121:	89 e5                	mov    %esp,%ebp
+    1123:	8b 45 08             	mov    0x8(%ebp),%eax
+    1126:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1129:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    112a:	89 c2                	mov    %eax,%edx
+    112c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1130:	83 c1 01             	add    $0x1,%ecx
+    1133:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1137:	83 c2 01             	add    $0x1,%edx
+    113a:	84 db                	test   %bl,%bl
+    113c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    113f:	75 ef                	jne    1130 <strcpy+0x10>
+    ;
+  return os;
+}
+    1141:	5b                   	pop    %ebx
+    1142:	5d                   	pop    %ebp
+    1143:	c3                   	ret    
+    1144:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    114a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001150 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1150:	55                   	push   %ebp
+    1151:	89 e5                	mov    %esp,%ebp
+    1153:	8b 55 08             	mov    0x8(%ebp),%edx
+    1156:	53                   	push   %ebx
+    1157:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    115a:	0f b6 02             	movzbl (%edx),%eax
+    115d:	84 c0                	test   %al,%al
+    115f:	74 2d                	je     118e <strcmp+0x3e>
+    1161:	0f b6 19             	movzbl (%ecx),%ebx
+    1164:	38 d8                	cmp    %bl,%al
+    1166:	74 0e                	je     1176 <strcmp+0x26>
+    1168:	eb 2b                	jmp    1195 <strcmp+0x45>
+    116a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1170:	38 c8                	cmp    %cl,%al
+    1172:	75 15                	jne    1189 <strcmp+0x39>
+    p++, q++;
+    1174:	89 d9                	mov    %ebx,%ecx
+    1176:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    1179:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    117c:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    117f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    1183:	84 c0                	test   %al,%al
+    1185:	75 e9                	jne    1170 <strcmp+0x20>
+    1187:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    1189:	29 c8                	sub    %ecx,%eax
+}
+    118b:	5b                   	pop    %ebx
+    118c:	5d                   	pop    %ebp
+    118d:	c3                   	ret    
+    118e:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    1191:	31 c0                	xor    %eax,%eax
+    1193:	eb f4                	jmp    1189 <strcmp+0x39>
+    1195:	0f b6 cb             	movzbl %bl,%ecx
+    1198:	eb ef                	jmp    1189 <strcmp+0x39>
+    119a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000011a0 <strlen>:
+
+uint
+strlen(char *s)
+{
+    11a0:	55                   	push   %ebp
+    11a1:	89 e5                	mov    %esp,%ebp
+    11a3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    11a6:	80 39 00             	cmpb   $0x0,(%ecx)
+    11a9:	74 12                	je     11bd <strlen+0x1d>
+    11ab:	31 d2                	xor    %edx,%edx
+    11ad:	8d 76 00             	lea    0x0(%esi),%esi
+    11b0:	83 c2 01             	add    $0x1,%edx
+    11b3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    11b7:	89 d0                	mov    %edx,%eax
+    11b9:	75 f5                	jne    11b0 <strlen+0x10>
+    ;
+  return n;
+}
+    11bb:	5d                   	pop    %ebp
+    11bc:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    11bd:	31 c0                	xor    %eax,%eax
+}
+    11bf:	5d                   	pop    %ebp
+    11c0:	c3                   	ret    
+    11c1:	eb 0d                	jmp    11d0 <memset>
+    11c3:	90                   	nop
+    11c4:	90                   	nop
+    11c5:	90                   	nop
+    11c6:	90                   	nop
+    11c7:	90                   	nop
+    11c8:	90                   	nop
+    11c9:	90                   	nop
+    11ca:	90                   	nop
+    11cb:	90                   	nop
+    11cc:	90                   	nop
+    11cd:	90                   	nop
+    11ce:	90                   	nop
+    11cf:	90                   	nop
+
+000011d0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    11d0:	55                   	push   %ebp
+    11d1:	89 e5                	mov    %esp,%ebp
+    11d3:	8b 55 08             	mov    0x8(%ebp),%edx
+    11d6:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    11d7:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    11da:	8b 45 0c             	mov    0xc(%ebp),%eax
+    11dd:	89 d7                	mov    %edx,%edi
+    11df:	fc                   	cld    
+    11e0:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    11e2:	89 d0                	mov    %edx,%eax
+    11e4:	5f                   	pop    %edi
+    11e5:	5d                   	pop    %ebp
+    11e6:	c3                   	ret    
+    11e7:	89 f6                	mov    %esi,%esi
+    11e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+000011f0 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    11f0:	55                   	push   %ebp
+    11f1:	89 e5                	mov    %esp,%ebp
+    11f3:	8b 45 08             	mov    0x8(%ebp),%eax
+    11f6:	53                   	push   %ebx
+    11f7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    11fa:	0f b6 18             	movzbl (%eax),%ebx
+    11fd:	84 db                	test   %bl,%bl
+    11ff:	74 1d                	je     121e <strchr+0x2e>
+    if(*s == c)
+    1201:	38 d3                	cmp    %dl,%bl
+    1203:	89 d1                	mov    %edx,%ecx
+    1205:	75 0d                	jne    1214 <strchr+0x24>
+    1207:	eb 17                	jmp    1220 <strchr+0x30>
+    1209:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1210:	38 ca                	cmp    %cl,%dl
+    1212:	74 0c                	je     1220 <strchr+0x30>
+  for(; *s; s++)
+    1214:	83 c0 01             	add    $0x1,%eax
+    1217:	0f b6 10             	movzbl (%eax),%edx
+    121a:	84 d2                	test   %dl,%dl
+    121c:	75 f2                	jne    1210 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    121e:	31 c0                	xor    %eax,%eax
+}
+    1220:	5b                   	pop    %ebx
+    1221:	5d                   	pop    %ebp
+    1222:	c3                   	ret    
+    1223:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1229:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001230 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1230:	55                   	push   %ebp
+    1231:	89 e5                	mov    %esp,%ebp
+    1233:	57                   	push   %edi
+    1234:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1235:	31 f6                	xor    %esi,%esi
+{
+    1237:	53                   	push   %ebx
+    1238:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    123b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    123e:	eb 31                	jmp    1271 <gets+0x41>
+    cc = read(0, &c, 1);
+    1240:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1247:	00 
+    1248:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    124c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1253:	e8 02 01 00 00       	call   135a <read>
+    if(cc < 1)
+    1258:	85 c0                	test   %eax,%eax
+    125a:	7e 1d                	jle    1279 <gets+0x49>
+      break;
+    buf[i++] = c;
+    125c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    1260:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    1262:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    1265:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    1267:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    126b:	74 0c                	je     1279 <gets+0x49>
+    126d:	3c 0a                	cmp    $0xa,%al
+    126f:	74 08                	je     1279 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    1271:	8d 5e 01             	lea    0x1(%esi),%ebx
+    1274:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    1277:	7c c7                	jl     1240 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    1279:	8b 45 08             	mov    0x8(%ebp),%eax
+    127c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    1280:	83 c4 2c             	add    $0x2c,%esp
+    1283:	5b                   	pop    %ebx
+    1284:	5e                   	pop    %esi
+    1285:	5f                   	pop    %edi
+    1286:	5d                   	pop    %ebp
+    1287:	c3                   	ret    
+    1288:	90                   	nop
+    1289:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001290 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    1290:	55                   	push   %ebp
+    1291:	89 e5                	mov    %esp,%ebp
+    1293:	56                   	push   %esi
+    1294:	53                   	push   %ebx
+    1295:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    1298:	8b 45 08             	mov    0x8(%ebp),%eax
+    129b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    12a2:	00 
+    12a3:	89 04 24             	mov    %eax,(%esp)
+    12a6:	e8 d7 00 00 00       	call   1382 <open>
+  if(fd < 0)
+    12ab:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    12ad:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    12af:	78 27                	js     12d8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    12b1:	8b 45 0c             	mov    0xc(%ebp),%eax
+    12b4:	89 1c 24             	mov    %ebx,(%esp)
+    12b7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    12bb:	e8 da 00 00 00       	call   139a <fstat>
+  close(fd);
+    12c0:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    12c3:	89 c6                	mov    %eax,%esi
+  close(fd);
+    12c5:	e8 a0 00 00 00       	call   136a <close>
+  return r;
+    12ca:	89 f0                	mov    %esi,%eax
+}
+    12cc:	83 c4 10             	add    $0x10,%esp
+    12cf:	5b                   	pop    %ebx
+    12d0:	5e                   	pop    %esi
+    12d1:	5d                   	pop    %ebp
+    12d2:	c3                   	ret    
+    12d3:	90                   	nop
+    12d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    12d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    12dd:	eb ed                	jmp    12cc <stat+0x3c>
+    12df:	90                   	nop
+
+000012e0 <atoi>:
+
+int
+atoi(const char *s)
+{
+    12e0:	55                   	push   %ebp
+    12e1:	89 e5                	mov    %esp,%ebp
+    12e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    12e6:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    12e7:	0f be 11             	movsbl (%ecx),%edx
+    12ea:	8d 42 d0             	lea    -0x30(%edx),%eax
+    12ed:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    12ef:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    12f4:	77 17                	ja     130d <atoi+0x2d>
+    12f6:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    12f8:	83 c1 01             	add    $0x1,%ecx
+    12fb:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    12fe:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1302:	0f be 11             	movsbl (%ecx),%edx
+    1305:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1308:	80 fb 09             	cmp    $0x9,%bl
+    130b:	76 eb                	jbe    12f8 <atoi+0x18>
+  return n;
+}
+    130d:	5b                   	pop    %ebx
+    130e:	5d                   	pop    %ebp
+    130f:	c3                   	ret    
+
+00001310 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1310:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1311:	31 d2                	xor    %edx,%edx
+{
+    1313:	89 e5                	mov    %esp,%ebp
+    1315:	56                   	push   %esi
+    1316:	8b 45 08             	mov    0x8(%ebp),%eax
+    1319:	53                   	push   %ebx
+    131a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    131d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1320:	85 db                	test   %ebx,%ebx
+    1322:	7e 12                	jle    1336 <memmove+0x26>
+    1324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1328:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    132c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    132f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1332:	39 da                	cmp    %ebx,%edx
+    1334:	75 f2                	jne    1328 <memmove+0x18>
+  return vdst;
+}
+    1336:	5b                   	pop    %ebx
+    1337:	5e                   	pop    %esi
+    1338:	5d                   	pop    %ebp
+    1339:	c3                   	ret    
+
+0000133a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    133a:	b8 01 00 00 00       	mov    $0x1,%eax
+    133f:	cd 40                	int    $0x40
+    1341:	c3                   	ret    
+
+00001342 <exit>:
+SYSCALL(exit)
+    1342:	b8 02 00 00 00       	mov    $0x2,%eax
+    1347:	cd 40                	int    $0x40
+    1349:	c3                   	ret    
+
+0000134a <wait>:
+SYSCALL(wait)
+    134a:	b8 03 00 00 00       	mov    $0x3,%eax
+    134f:	cd 40                	int    $0x40
+    1351:	c3                   	ret    
+
+00001352 <pipe>:
+SYSCALL(pipe)
+    1352:	b8 04 00 00 00       	mov    $0x4,%eax
+    1357:	cd 40                	int    $0x40
+    1359:	c3                   	ret    
+
+0000135a <read>:
+SYSCALL(read)
+    135a:	b8 05 00 00 00       	mov    $0x5,%eax
+    135f:	cd 40                	int    $0x40
+    1361:	c3                   	ret    
+
+00001362 <write>:
+SYSCALL(write)
+    1362:	b8 10 00 00 00       	mov    $0x10,%eax
+    1367:	cd 40                	int    $0x40
+    1369:	c3                   	ret    
+
+0000136a <close>:
+SYSCALL(close)
+    136a:	b8 15 00 00 00       	mov    $0x15,%eax
+    136f:	cd 40                	int    $0x40
+    1371:	c3                   	ret    
+
+00001372 <kill>:
+SYSCALL(kill)
+    1372:	b8 06 00 00 00       	mov    $0x6,%eax
+    1377:	cd 40                	int    $0x40
+    1379:	c3                   	ret    
+
+0000137a <exec>:
+SYSCALL(exec)
+    137a:	b8 07 00 00 00       	mov    $0x7,%eax
+    137f:	cd 40                	int    $0x40
+    1381:	c3                   	ret    
+
+00001382 <open>:
+SYSCALL(open)
+    1382:	b8 0f 00 00 00       	mov    $0xf,%eax
+    1387:	cd 40                	int    $0x40
+    1389:	c3                   	ret    
+
+0000138a <mknod>:
+SYSCALL(mknod)
+    138a:	b8 11 00 00 00       	mov    $0x11,%eax
+    138f:	cd 40                	int    $0x40
+    1391:	c3                   	ret    
+
+00001392 <unlink>:
+SYSCALL(unlink)
+    1392:	b8 12 00 00 00       	mov    $0x12,%eax
+    1397:	cd 40                	int    $0x40
+    1399:	c3                   	ret    
+
+0000139a <fstat>:
+SYSCALL(fstat)
+    139a:	b8 08 00 00 00       	mov    $0x8,%eax
+    139f:	cd 40                	int    $0x40
+    13a1:	c3                   	ret    
+
+000013a2 <link>:
+SYSCALL(link)
+    13a2:	b8 13 00 00 00       	mov    $0x13,%eax
+    13a7:	cd 40                	int    $0x40
+    13a9:	c3                   	ret    
+
+000013aa <mkdir>:
+SYSCALL(mkdir)
+    13aa:	b8 14 00 00 00       	mov    $0x14,%eax
+    13af:	cd 40                	int    $0x40
+    13b1:	c3                   	ret    
+
+000013b2 <chdir>:
+SYSCALL(chdir)
+    13b2:	b8 09 00 00 00       	mov    $0x9,%eax
+    13b7:	cd 40                	int    $0x40
+    13b9:	c3                   	ret    
+
+000013ba <dup>:
+SYSCALL(dup)
+    13ba:	b8 0a 00 00 00       	mov    $0xa,%eax
+    13bf:	cd 40                	int    $0x40
+    13c1:	c3                   	ret    
+
+000013c2 <getpid>:
+SYSCALL(getpid)
+    13c2:	b8 0b 00 00 00       	mov    $0xb,%eax
+    13c7:	cd 40                	int    $0x40
+    13c9:	c3                   	ret    
+
+000013ca <sbrk>:
+SYSCALL(sbrk)
+    13ca:	b8 0c 00 00 00       	mov    $0xc,%eax
+    13cf:	cd 40                	int    $0x40
+    13d1:	c3                   	ret    
+
+000013d2 <sleep>:
+SYSCALL(sleep)
+    13d2:	b8 0d 00 00 00       	mov    $0xd,%eax
+    13d7:	cd 40                	int    $0x40
+    13d9:	c3                   	ret    
+
+000013da <uptime>:
+SYSCALL(uptime)
+    13da:	b8 0e 00 00 00       	mov    $0xe,%eax
+    13df:	cd 40                	int    $0x40
+    13e1:	c3                   	ret    
+
+000013e2 <shm_open>:
+SYSCALL(shm_open)
+    13e2:	b8 16 00 00 00       	mov    $0x16,%eax
+    13e7:	cd 40                	int    $0x40
+    13e9:	c3                   	ret    
+
+000013ea <shm_close>:
+SYSCALL(shm_close)	
+    13ea:	b8 17 00 00 00       	mov    $0x17,%eax
+    13ef:	cd 40                	int    $0x40
+    13f1:	c3                   	ret    
diff --git a/forktest.c b/forktest.c
index a4b35ed..73f2fe8 100644
--- a/forktest.c
+++ b/forktest.c
@@ -8,7 +8,7 @@
 #define N  1000
 
 void
-printf(int fd, const char *s, ...)
+printf(int fd, char *s, ...)
 {
   write(fd, s, strlen(s));
 }
@@ -25,24 +25,24 @@ forktest(void)
     if(pid < 0)
       break;
     if(pid == 0)
-      exit(4);
+      exit();
   }
 
   if(n == N){
     printf(1, "fork claimed to work N times!\n", N);
-    exit(3);
+    exit();
   }
 
   for(; n > 0; n--){
-    if(wait(NULL) < 0){
+    if(wait() < 0){
       printf(1, "wait stopped early\n");
-      exit(2);
+      exit();
     }
   }
 
-  if(wait(NULL) != -1){
+  if(wait() != -1){
     printf(1, "wait got too many\n");
-    exit(1);
+    exit();
   }
 
   printf(1, "fork test OK\n");
@@ -52,5 +52,5 @@ int
 main(void)
 {
   forktest();
-  exit(0);
+  exit();
 }
diff --git a/forktest.d b/forktest.d
new file mode 100644
index 0000000..d31a0c2
--- /dev/null
+++ b/forktest.d
@@ -0,0 +1 @@
+forktest.o: forktest.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/forktest.o b/forktest.o
new file mode 100644
index 0000000..be2042a
Binary files /dev/null and b/forktest.o differ
diff --git a/fs.c b/fs.c
index f77275f..feb59fe 100644
--- a/fs.c
+++ b/fs.c
@@ -84,6 +84,7 @@ bfree(int dev, uint b)
   struct buf *bp;
   int bi, m;
 
+  readsb(dev, &sb);
   bp = bread(dev, BBLOCK(b, sb));
   bi = b % BPB;
   m = 1 << (bi % 8);
diff --git a/fs.d b/fs.d
new file mode 100644
index 0000000..a1d05cc
--- /dev/null
+++ b/fs.d
@@ -0,0 +1,2 @@
+fs.o: fs.c /usr/include/stdc-predef.h types.h defs.h param.h stat.h mmu.h \
+ proc.h spinlock.h sleeplock.h fs.h buf.h file.h
diff --git a/fs.img b/fs.img
new file mode 100644
index 0000000..b082f9e
Binary files /dev/null and b/fs.img differ
diff --git a/fs.o b/fs.o
new file mode 100644
index 0000000..6c7da81
Binary files /dev/null and b/fs.o differ
diff --git a/grep.asm b/grep.asm
new file mode 100644
index 0000000..7d34097
--- /dev/null
+++ b/grep.asm
@@ -0,0 +1,1546 @@
+
+_grep:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+  }
+}
+
+int
+main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	57                   	push   %edi
+    1004:	56                   	push   %esi
+    1005:	53                   	push   %ebx
+    1006:	83 e4 f0             	and    $0xfffffff0,%esp
+    1009:	83 ec 10             	sub    $0x10,%esp
+    100c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  int fd, i;
+  char *pattern;
+
+  if(argc <= 1){
+    100f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+    1013:	0f 8e 8b 00 00 00    	jle    10a4 <main+0xa4>
+    printf(2, "usage: grep pattern [file ...]\n");
+    exit();
+  }
+  pattern = argv[1];
+    1019:	8b 43 04             	mov    0x4(%ebx),%eax
+    101c:	83 c3 08             	add    $0x8,%ebx
+
+  if(argc <= 2){
+    101f:	be 02 00 00 00       	mov    $0x2,%esi
+    1024:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
+  pattern = argv[1];
+    1028:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  if(argc <= 2){
+    102c:	74 61                	je     108f <main+0x8f>
+    102e:	66 90                	xchg   %ax,%ax
+    grep(pattern, 0);
+    exit();
+  }
+
+  for(i = 2; i < argc; i++){
+    if((fd = open(argv[i], 0)) < 0){
+    1030:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1037:	00 
+    1038:	8b 03                	mov    (%ebx),%eax
+    103a:	89 04 24             	mov    %eax,(%esp)
+    103d:	e8 30 05 00 00       	call   1572 <open>
+    1042:	85 c0                	test   %eax,%eax
+    1044:	89 c7                	mov    %eax,%edi
+    1046:	78 28                	js     1070 <main+0x70>
+      printf(1, "grep: cannot open %s\n", argv[i]);
+      exit();
+    }
+    grep(pattern, fd);
+    1048:	89 44 24 04          	mov    %eax,0x4(%esp)
+    104c:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  for(i = 2; i < argc; i++){
+    1050:	83 c6 01             	add    $0x1,%esi
+    1053:	83 c3 04             	add    $0x4,%ebx
+    grep(pattern, fd);
+    1056:	89 04 24             	mov    %eax,(%esp)
+    1059:	e8 a2 01 00 00       	call   1200 <grep>
+    close(fd);
+    105e:	89 3c 24             	mov    %edi,(%esp)
+    1061:	e8 f4 04 00 00       	call   155a <close>
+  for(i = 2; i < argc; i++){
+    1066:	39 75 08             	cmp    %esi,0x8(%ebp)
+    1069:	7f c5                	jg     1030 <main+0x30>
+  }
+  exit();
+    106b:	e8 c2 04 00 00       	call   1532 <exit>
+      printf(1, "grep: cannot open %s\n", argv[i]);
+    1070:	8b 03                	mov    (%ebx),%eax
+    1072:	c7 44 24 04 54 1a 00 	movl   $0x1a54,0x4(%esp)
+    1079:	00 
+    107a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1081:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1085:	e8 06 06 00 00       	call   1690 <printf>
+      exit();
+    108a:	e8 a3 04 00 00       	call   1532 <exit>
+    grep(pattern, 0);
+    108f:	89 04 24             	mov    %eax,(%esp)
+    1092:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1099:	00 
+    109a:	e8 61 01 00 00       	call   1200 <grep>
+    exit();
+    109f:	e8 8e 04 00 00       	call   1532 <exit>
+    printf(2, "usage: grep pattern [file ...]\n");
+    10a4:	c7 44 24 04 34 1a 00 	movl   $0x1a34,0x4(%esp)
+    10ab:	00 
+    10ac:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    10b3:	e8 d8 05 00 00       	call   1690 <printf>
+    exit();
+    10b8:	e8 75 04 00 00       	call   1532 <exit>
+    10bd:	66 90                	xchg   %ax,%ax
+    10bf:	90                   	nop
+
+000010c0 <matchstar>:
+  return 0;
+}
+
+// matchstar: search for c*re at beginning of text
+int matchstar(int c, char *re, char *text)
+{
+    10c0:	55                   	push   %ebp
+    10c1:	89 e5                	mov    %esp,%ebp
+    10c3:	57                   	push   %edi
+    10c4:	56                   	push   %esi
+    10c5:	53                   	push   %ebx
+    10c6:	83 ec 1c             	sub    $0x1c,%esp
+    10c9:	8b 75 08             	mov    0x8(%ebp),%esi
+    10cc:	8b 7d 0c             	mov    0xc(%ebp),%edi
+    10cf:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    10d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  do{  // a * matches zero or more instances
+    if(matchhere(re, text))
+    10d8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    10dc:	89 3c 24             	mov    %edi,(%esp)
+    10df:	e8 3c 00 00 00       	call   1120 <matchhere>
+    10e4:	85 c0                	test   %eax,%eax
+    10e6:	75 20                	jne    1108 <matchstar+0x48>
+      return 1;
+  }while(*text!='\0' && (*text++==c || c=='.'));
+    10e8:	0f be 13             	movsbl (%ebx),%edx
+    10eb:	84 d2                	test   %dl,%dl
+    10ed:	74 0c                	je     10fb <matchstar+0x3b>
+    10ef:	83 c3 01             	add    $0x1,%ebx
+    10f2:	39 f2                	cmp    %esi,%edx
+    10f4:	74 e2                	je     10d8 <matchstar+0x18>
+    10f6:	83 fe 2e             	cmp    $0x2e,%esi
+    10f9:	74 dd                	je     10d8 <matchstar+0x18>
+  return 0;
+}
+    10fb:	83 c4 1c             	add    $0x1c,%esp
+    10fe:	5b                   	pop    %ebx
+    10ff:	5e                   	pop    %esi
+    1100:	5f                   	pop    %edi
+    1101:	5d                   	pop    %ebp
+    1102:	c3                   	ret    
+    1103:	90                   	nop
+    1104:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1108:	83 c4 1c             	add    $0x1c,%esp
+      return 1;
+    110b:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+    1110:	5b                   	pop    %ebx
+    1111:	5e                   	pop    %esi
+    1112:	5f                   	pop    %edi
+    1113:	5d                   	pop    %ebp
+    1114:	c3                   	ret    
+    1115:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1119:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001120 <matchhere>:
+{
+    1120:	55                   	push   %ebp
+    1121:	89 e5                	mov    %esp,%ebp
+    1123:	53                   	push   %ebx
+    1124:	83 ec 14             	sub    $0x14,%esp
+    1127:	8b 55 08             	mov    0x8(%ebp),%edx
+    112a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  if(re[0] == '\0')
+    112d:	0f be 02             	movsbl (%edx),%eax
+    1130:	84 c0                	test   %al,%al
+    1132:	75 20                	jne    1154 <matchhere+0x34>
+    1134:	eb 42                	jmp    1178 <matchhere+0x58>
+    1136:	66 90                	xchg   %ax,%ax
+  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+    1138:	0f b6 19             	movzbl (%ecx),%ebx
+    113b:	84 db                	test   %bl,%bl
+    113d:	74 31                	je     1170 <matchhere+0x50>
+    113f:	3c 2e                	cmp    $0x2e,%al
+    1141:	74 04                	je     1147 <matchhere+0x27>
+    1143:	38 d8                	cmp    %bl,%al
+    1145:	75 29                	jne    1170 <matchhere+0x50>
+    return matchhere(re+1, text+1);
+    1147:	83 c2 01             	add    $0x1,%edx
+  if(re[0] == '\0')
+    114a:	0f be 02             	movsbl (%edx),%eax
+    return matchhere(re+1, text+1);
+    114d:	83 c1 01             	add    $0x1,%ecx
+  if(re[0] == '\0')
+    1150:	84 c0                	test   %al,%al
+    1152:	74 24                	je     1178 <matchhere+0x58>
+  if(re[1] == '*')
+    1154:	0f b6 5a 01          	movzbl 0x1(%edx),%ebx
+    1158:	80 fb 2a             	cmp    $0x2a,%bl
+    115b:	74 2b                	je     1188 <matchhere+0x68>
+  if(re[0] == '$' && re[1] == '\0')
+    115d:	3c 24                	cmp    $0x24,%al
+    115f:	75 d7                	jne    1138 <matchhere+0x18>
+    1161:	84 db                	test   %bl,%bl
+    1163:	74 3c                	je     11a1 <matchhere+0x81>
+  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+    1165:	0f b6 19             	movzbl (%ecx),%ebx
+    1168:	84 db                	test   %bl,%bl
+    116a:	75 d7                	jne    1143 <matchhere+0x23>
+    116c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+    1170:	31 c0                	xor    %eax,%eax
+}
+    1172:	83 c4 14             	add    $0x14,%esp
+    1175:	5b                   	pop    %ebx
+    1176:	5d                   	pop    %ebp
+    1177:	c3                   	ret    
+    1178:	83 c4 14             	add    $0x14,%esp
+    return 1;
+    117b:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+    1180:	5b                   	pop    %ebx
+    1181:	5d                   	pop    %ebp
+    1182:	c3                   	ret    
+    1183:	90                   	nop
+    1184:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return matchstar(re[0], re+2, text);
+    1188:	83 c2 02             	add    $0x2,%edx
+    118b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+    118f:	89 54 24 04          	mov    %edx,0x4(%esp)
+    1193:	89 04 24             	mov    %eax,(%esp)
+    1196:	e8 25 ff ff ff       	call   10c0 <matchstar>
+}
+    119b:	83 c4 14             	add    $0x14,%esp
+    119e:	5b                   	pop    %ebx
+    119f:	5d                   	pop    %ebp
+    11a0:	c3                   	ret    
+    return *text == '\0';
+    11a1:	31 c0                	xor    %eax,%eax
+    11a3:	80 39 00             	cmpb   $0x0,(%ecx)
+    11a6:	0f 94 c0             	sete   %al
+    11a9:	eb c7                	jmp    1172 <matchhere+0x52>
+    11ab:	90                   	nop
+    11ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000011b0 <match>:
+{
+    11b0:	55                   	push   %ebp
+    11b1:	89 e5                	mov    %esp,%ebp
+    11b3:	56                   	push   %esi
+    11b4:	53                   	push   %ebx
+    11b5:	83 ec 10             	sub    $0x10,%esp
+    11b8:	8b 75 08             	mov    0x8(%ebp),%esi
+    11bb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  if(re[0] == '^')
+    11be:	80 3e 5e             	cmpb   $0x5e,(%esi)
+    11c1:	75 0e                	jne    11d1 <match+0x21>
+    11c3:	eb 28                	jmp    11ed <match+0x3d>
+    11c5:	8d 76 00             	lea    0x0(%esi),%esi
+  }while(*text++ != '\0');
+    11c8:	83 c3 01             	add    $0x1,%ebx
+    11cb:	80 7b ff 00          	cmpb   $0x0,-0x1(%ebx)
+    11cf:	74 15                	je     11e6 <match+0x36>
+    if(matchhere(re, text))
+    11d1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    11d5:	89 34 24             	mov    %esi,(%esp)
+    11d8:	e8 43 ff ff ff       	call   1120 <matchhere>
+    11dd:	85 c0                	test   %eax,%eax
+    11df:	74 e7                	je     11c8 <match+0x18>
+      return 1;
+    11e1:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+    11e6:	83 c4 10             	add    $0x10,%esp
+    11e9:	5b                   	pop    %ebx
+    11ea:	5e                   	pop    %esi
+    11eb:	5d                   	pop    %ebp
+    11ec:	c3                   	ret    
+    return matchhere(re+1, text);
+    11ed:	83 c6 01             	add    $0x1,%esi
+    11f0:	89 75 08             	mov    %esi,0x8(%ebp)
+}
+    11f3:	83 c4 10             	add    $0x10,%esp
+    11f6:	5b                   	pop    %ebx
+    11f7:	5e                   	pop    %esi
+    11f8:	5d                   	pop    %ebp
+    return matchhere(re+1, text);
+    11f9:	e9 22 ff ff ff       	jmp    1120 <matchhere>
+    11fe:	66 90                	xchg   %ax,%ax
+
+00001200 <grep>:
+{
+    1200:	55                   	push   %ebp
+    1201:	89 e5                	mov    %esp,%ebp
+    1203:	57                   	push   %edi
+    1204:	56                   	push   %esi
+    1205:	53                   	push   %ebx
+    1206:	83 ec 1c             	sub    $0x1c,%esp
+    1209:	8b 75 08             	mov    0x8(%ebp),%esi
+  m = 0;
+    120c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+    1213:	90                   	nop
+    1214:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+    1218:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+    121b:	b8 ff 03 00 00       	mov    $0x3ff,%eax
+    1220:	29 d0                	sub    %edx,%eax
+    1222:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1226:	89 d0                	mov    %edx,%eax
+    1228:	05 40 1e 00 00       	add    $0x1e40,%eax
+    122d:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1231:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1234:	89 04 24             	mov    %eax,(%esp)
+    1237:	e8 0e 03 00 00       	call   154a <read>
+    123c:	85 c0                	test   %eax,%eax
+    123e:	0f 8e b8 00 00 00    	jle    12fc <grep+0xfc>
+    m += n;
+    1244:	01 45 e4             	add    %eax,-0x1c(%ebp)
+    p = buf;
+    1247:	bb 40 1e 00 00       	mov    $0x1e40,%ebx
+    buf[m] = '\0';
+    124c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    124f:	c6 80 40 1e 00 00 00 	movb   $0x0,0x1e40(%eax)
+    1256:	66 90                	xchg   %ax,%ax
+    while((q = strchr(p, '\n')) != 0){
+    1258:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
+    125f:	00 
+    1260:	89 1c 24             	mov    %ebx,(%esp)
+    1263:	e8 78 01 00 00       	call   13e0 <strchr>
+    1268:	85 c0                	test   %eax,%eax
+    126a:	89 c7                	mov    %eax,%edi
+    126c:	74 42                	je     12b0 <grep+0xb0>
+      *q = 0;
+    126e:	c6 07 00             	movb   $0x0,(%edi)
+      if(match(pattern, p)){
+    1271:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1275:	89 34 24             	mov    %esi,(%esp)
+    1278:	e8 33 ff ff ff       	call   11b0 <match>
+    127d:	85 c0                	test   %eax,%eax
+    127f:	75 07                	jne    1288 <grep+0x88>
+    1281:	8d 5f 01             	lea    0x1(%edi),%ebx
+    1284:	eb d2                	jmp    1258 <grep+0x58>
+    1286:	66 90                	xchg   %ax,%ax
+        *q = '\n';
+    1288:	c6 07 0a             	movb   $0xa,(%edi)
+        write(1, p, q+1 - p);
+    128b:	83 c7 01             	add    $0x1,%edi
+    128e:	89 f8                	mov    %edi,%eax
+    1290:	29 d8                	sub    %ebx,%eax
+    1292:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1296:	89 fb                	mov    %edi,%ebx
+    1298:	89 44 24 08          	mov    %eax,0x8(%esp)
+    129c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    12a3:	e8 aa 02 00 00       	call   1552 <write>
+    12a8:	eb ae                	jmp    1258 <grep+0x58>
+    12aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(p == buf)
+    12b0:	81 fb 40 1e 00 00    	cmp    $0x1e40,%ebx
+    12b6:	74 38                	je     12f0 <grep+0xf0>
+    if(m > 0){
+    12b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    12bb:	85 c0                	test   %eax,%eax
+    12bd:	0f 8e 55 ff ff ff    	jle    1218 <grep+0x18>
+      m -= p - buf;
+    12c3:	b8 40 1e 00 00       	mov    $0x1e40,%eax
+    12c8:	29 d8                	sub    %ebx,%eax
+    12ca:	01 45 e4             	add    %eax,-0x1c(%ebp)
+      memmove(buf, p, m);
+    12cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    12d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    12d4:	c7 04 24 40 1e 00 00 	movl   $0x1e40,(%esp)
+    12db:	89 44 24 08          	mov    %eax,0x8(%esp)
+    12df:	e8 1c 02 00 00       	call   1500 <memmove>
+    12e4:	e9 2f ff ff ff       	jmp    1218 <grep+0x18>
+    12e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      m = 0;
+    12f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+    12f7:	e9 1c ff ff ff       	jmp    1218 <grep+0x18>
+}
+    12fc:	83 c4 1c             	add    $0x1c,%esp
+    12ff:	5b                   	pop    %ebx
+    1300:	5e                   	pop    %esi
+    1301:	5f                   	pop    %edi
+    1302:	5d                   	pop    %ebp
+    1303:	c3                   	ret    
+    1304:	66 90                	xchg   %ax,%ax
+    1306:	66 90                	xchg   %ax,%ax
+    1308:	66 90                	xchg   %ax,%ax
+    130a:	66 90                	xchg   %ax,%ax
+    130c:	66 90                	xchg   %ax,%ax
+    130e:	66 90                	xchg   %ax,%ax
+
+00001310 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1310:	55                   	push   %ebp
+    1311:	89 e5                	mov    %esp,%ebp
+    1313:	8b 45 08             	mov    0x8(%ebp),%eax
+    1316:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1319:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    131a:	89 c2                	mov    %eax,%edx
+    131c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1320:	83 c1 01             	add    $0x1,%ecx
+    1323:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1327:	83 c2 01             	add    $0x1,%edx
+    132a:	84 db                	test   %bl,%bl
+    132c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    132f:	75 ef                	jne    1320 <strcpy+0x10>
+    ;
+  return os;
+}
+    1331:	5b                   	pop    %ebx
+    1332:	5d                   	pop    %ebp
+    1333:	c3                   	ret    
+    1334:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    133a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001340 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1340:	55                   	push   %ebp
+    1341:	89 e5                	mov    %esp,%ebp
+    1343:	8b 55 08             	mov    0x8(%ebp),%edx
+    1346:	53                   	push   %ebx
+    1347:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    134a:	0f b6 02             	movzbl (%edx),%eax
+    134d:	84 c0                	test   %al,%al
+    134f:	74 2d                	je     137e <strcmp+0x3e>
+    1351:	0f b6 19             	movzbl (%ecx),%ebx
+    1354:	38 d8                	cmp    %bl,%al
+    1356:	74 0e                	je     1366 <strcmp+0x26>
+    1358:	eb 2b                	jmp    1385 <strcmp+0x45>
+    135a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1360:	38 c8                	cmp    %cl,%al
+    1362:	75 15                	jne    1379 <strcmp+0x39>
+    p++, q++;
+    1364:	89 d9                	mov    %ebx,%ecx
+    1366:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    1369:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    136c:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    136f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    1373:	84 c0                	test   %al,%al
+    1375:	75 e9                	jne    1360 <strcmp+0x20>
+    1377:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    1379:	29 c8                	sub    %ecx,%eax
+}
+    137b:	5b                   	pop    %ebx
+    137c:	5d                   	pop    %ebp
+    137d:	c3                   	ret    
+    137e:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    1381:	31 c0                	xor    %eax,%eax
+    1383:	eb f4                	jmp    1379 <strcmp+0x39>
+    1385:	0f b6 cb             	movzbl %bl,%ecx
+    1388:	eb ef                	jmp    1379 <strcmp+0x39>
+    138a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001390 <strlen>:
+
+uint
+strlen(char *s)
+{
+    1390:	55                   	push   %ebp
+    1391:	89 e5                	mov    %esp,%ebp
+    1393:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    1396:	80 39 00             	cmpb   $0x0,(%ecx)
+    1399:	74 12                	je     13ad <strlen+0x1d>
+    139b:	31 d2                	xor    %edx,%edx
+    139d:	8d 76 00             	lea    0x0(%esi),%esi
+    13a0:	83 c2 01             	add    $0x1,%edx
+    13a3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    13a7:	89 d0                	mov    %edx,%eax
+    13a9:	75 f5                	jne    13a0 <strlen+0x10>
+    ;
+  return n;
+}
+    13ab:	5d                   	pop    %ebp
+    13ac:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    13ad:	31 c0                	xor    %eax,%eax
+}
+    13af:	5d                   	pop    %ebp
+    13b0:	c3                   	ret    
+    13b1:	eb 0d                	jmp    13c0 <memset>
+    13b3:	90                   	nop
+    13b4:	90                   	nop
+    13b5:	90                   	nop
+    13b6:	90                   	nop
+    13b7:	90                   	nop
+    13b8:	90                   	nop
+    13b9:	90                   	nop
+    13ba:	90                   	nop
+    13bb:	90                   	nop
+    13bc:	90                   	nop
+    13bd:	90                   	nop
+    13be:	90                   	nop
+    13bf:	90                   	nop
+
+000013c0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    13c0:	55                   	push   %ebp
+    13c1:	89 e5                	mov    %esp,%ebp
+    13c3:	8b 55 08             	mov    0x8(%ebp),%edx
+    13c6:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    13c7:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    13ca:	8b 45 0c             	mov    0xc(%ebp),%eax
+    13cd:	89 d7                	mov    %edx,%edi
+    13cf:	fc                   	cld    
+    13d0:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    13d2:	89 d0                	mov    %edx,%eax
+    13d4:	5f                   	pop    %edi
+    13d5:	5d                   	pop    %ebp
+    13d6:	c3                   	ret    
+    13d7:	89 f6                	mov    %esi,%esi
+    13d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+000013e0 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    13e0:	55                   	push   %ebp
+    13e1:	89 e5                	mov    %esp,%ebp
+    13e3:	8b 45 08             	mov    0x8(%ebp),%eax
+    13e6:	53                   	push   %ebx
+    13e7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    13ea:	0f b6 18             	movzbl (%eax),%ebx
+    13ed:	84 db                	test   %bl,%bl
+    13ef:	74 1d                	je     140e <strchr+0x2e>
+    if(*s == c)
+    13f1:	38 d3                	cmp    %dl,%bl
+    13f3:	89 d1                	mov    %edx,%ecx
+    13f5:	75 0d                	jne    1404 <strchr+0x24>
+    13f7:	eb 17                	jmp    1410 <strchr+0x30>
+    13f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1400:	38 ca                	cmp    %cl,%dl
+    1402:	74 0c                	je     1410 <strchr+0x30>
+  for(; *s; s++)
+    1404:	83 c0 01             	add    $0x1,%eax
+    1407:	0f b6 10             	movzbl (%eax),%edx
+    140a:	84 d2                	test   %dl,%dl
+    140c:	75 f2                	jne    1400 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    140e:	31 c0                	xor    %eax,%eax
+}
+    1410:	5b                   	pop    %ebx
+    1411:	5d                   	pop    %ebp
+    1412:	c3                   	ret    
+    1413:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1419:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001420 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1420:	55                   	push   %ebp
+    1421:	89 e5                	mov    %esp,%ebp
+    1423:	57                   	push   %edi
+    1424:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1425:	31 f6                	xor    %esi,%esi
+{
+    1427:	53                   	push   %ebx
+    1428:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    142b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    142e:	eb 31                	jmp    1461 <gets+0x41>
+    cc = read(0, &c, 1);
+    1430:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1437:	00 
+    1438:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    143c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1443:	e8 02 01 00 00       	call   154a <read>
+    if(cc < 1)
+    1448:	85 c0                	test   %eax,%eax
+    144a:	7e 1d                	jle    1469 <gets+0x49>
+      break;
+    buf[i++] = c;
+    144c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    1450:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    1452:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    1455:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    1457:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    145b:	74 0c                	je     1469 <gets+0x49>
+    145d:	3c 0a                	cmp    $0xa,%al
+    145f:	74 08                	je     1469 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    1461:	8d 5e 01             	lea    0x1(%esi),%ebx
+    1464:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    1467:	7c c7                	jl     1430 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    1469:	8b 45 08             	mov    0x8(%ebp),%eax
+    146c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    1470:	83 c4 2c             	add    $0x2c,%esp
+    1473:	5b                   	pop    %ebx
+    1474:	5e                   	pop    %esi
+    1475:	5f                   	pop    %edi
+    1476:	5d                   	pop    %ebp
+    1477:	c3                   	ret    
+    1478:	90                   	nop
+    1479:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001480 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    1480:	55                   	push   %ebp
+    1481:	89 e5                	mov    %esp,%ebp
+    1483:	56                   	push   %esi
+    1484:	53                   	push   %ebx
+    1485:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    1488:	8b 45 08             	mov    0x8(%ebp),%eax
+    148b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1492:	00 
+    1493:	89 04 24             	mov    %eax,(%esp)
+    1496:	e8 d7 00 00 00       	call   1572 <open>
+  if(fd < 0)
+    149b:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    149d:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    149f:	78 27                	js     14c8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    14a1:	8b 45 0c             	mov    0xc(%ebp),%eax
+    14a4:	89 1c 24             	mov    %ebx,(%esp)
+    14a7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14ab:	e8 da 00 00 00       	call   158a <fstat>
+  close(fd);
+    14b0:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    14b3:	89 c6                	mov    %eax,%esi
+  close(fd);
+    14b5:	e8 a0 00 00 00       	call   155a <close>
+  return r;
+    14ba:	89 f0                	mov    %esi,%eax
+}
+    14bc:	83 c4 10             	add    $0x10,%esp
+    14bf:	5b                   	pop    %ebx
+    14c0:	5e                   	pop    %esi
+    14c1:	5d                   	pop    %ebp
+    14c2:	c3                   	ret    
+    14c3:	90                   	nop
+    14c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    14c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    14cd:	eb ed                	jmp    14bc <stat+0x3c>
+    14cf:	90                   	nop
+
+000014d0 <atoi>:
+
+int
+atoi(const char *s)
+{
+    14d0:	55                   	push   %ebp
+    14d1:	89 e5                	mov    %esp,%ebp
+    14d3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    14d6:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    14d7:	0f be 11             	movsbl (%ecx),%edx
+    14da:	8d 42 d0             	lea    -0x30(%edx),%eax
+    14dd:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    14df:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    14e4:	77 17                	ja     14fd <atoi+0x2d>
+    14e6:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    14e8:	83 c1 01             	add    $0x1,%ecx
+    14eb:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    14ee:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    14f2:	0f be 11             	movsbl (%ecx),%edx
+    14f5:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    14f8:	80 fb 09             	cmp    $0x9,%bl
+    14fb:	76 eb                	jbe    14e8 <atoi+0x18>
+  return n;
+}
+    14fd:	5b                   	pop    %ebx
+    14fe:	5d                   	pop    %ebp
+    14ff:	c3                   	ret    
+
+00001500 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1500:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1501:	31 d2                	xor    %edx,%edx
+{
+    1503:	89 e5                	mov    %esp,%ebp
+    1505:	56                   	push   %esi
+    1506:	8b 45 08             	mov    0x8(%ebp),%eax
+    1509:	53                   	push   %ebx
+    150a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    150d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1510:	85 db                	test   %ebx,%ebx
+    1512:	7e 12                	jle    1526 <memmove+0x26>
+    1514:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1518:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    151c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    151f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1522:	39 da                	cmp    %ebx,%edx
+    1524:	75 f2                	jne    1518 <memmove+0x18>
+  return vdst;
+}
+    1526:	5b                   	pop    %ebx
+    1527:	5e                   	pop    %esi
+    1528:	5d                   	pop    %ebp
+    1529:	c3                   	ret    
+
+0000152a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    152a:	b8 01 00 00 00       	mov    $0x1,%eax
+    152f:	cd 40                	int    $0x40
+    1531:	c3                   	ret    
+
+00001532 <exit>:
+SYSCALL(exit)
+    1532:	b8 02 00 00 00       	mov    $0x2,%eax
+    1537:	cd 40                	int    $0x40
+    1539:	c3                   	ret    
+
+0000153a <wait>:
+SYSCALL(wait)
+    153a:	b8 03 00 00 00       	mov    $0x3,%eax
+    153f:	cd 40                	int    $0x40
+    1541:	c3                   	ret    
+
+00001542 <pipe>:
+SYSCALL(pipe)
+    1542:	b8 04 00 00 00       	mov    $0x4,%eax
+    1547:	cd 40                	int    $0x40
+    1549:	c3                   	ret    
+
+0000154a <read>:
+SYSCALL(read)
+    154a:	b8 05 00 00 00       	mov    $0x5,%eax
+    154f:	cd 40                	int    $0x40
+    1551:	c3                   	ret    
+
+00001552 <write>:
+SYSCALL(write)
+    1552:	b8 10 00 00 00       	mov    $0x10,%eax
+    1557:	cd 40                	int    $0x40
+    1559:	c3                   	ret    
+
+0000155a <close>:
+SYSCALL(close)
+    155a:	b8 15 00 00 00       	mov    $0x15,%eax
+    155f:	cd 40                	int    $0x40
+    1561:	c3                   	ret    
+
+00001562 <kill>:
+SYSCALL(kill)
+    1562:	b8 06 00 00 00       	mov    $0x6,%eax
+    1567:	cd 40                	int    $0x40
+    1569:	c3                   	ret    
+
+0000156a <exec>:
+SYSCALL(exec)
+    156a:	b8 07 00 00 00       	mov    $0x7,%eax
+    156f:	cd 40                	int    $0x40
+    1571:	c3                   	ret    
+
+00001572 <open>:
+SYSCALL(open)
+    1572:	b8 0f 00 00 00       	mov    $0xf,%eax
+    1577:	cd 40                	int    $0x40
+    1579:	c3                   	ret    
+
+0000157a <mknod>:
+SYSCALL(mknod)
+    157a:	b8 11 00 00 00       	mov    $0x11,%eax
+    157f:	cd 40                	int    $0x40
+    1581:	c3                   	ret    
+
+00001582 <unlink>:
+SYSCALL(unlink)
+    1582:	b8 12 00 00 00       	mov    $0x12,%eax
+    1587:	cd 40                	int    $0x40
+    1589:	c3                   	ret    
+
+0000158a <fstat>:
+SYSCALL(fstat)
+    158a:	b8 08 00 00 00       	mov    $0x8,%eax
+    158f:	cd 40                	int    $0x40
+    1591:	c3                   	ret    
+
+00001592 <link>:
+SYSCALL(link)
+    1592:	b8 13 00 00 00       	mov    $0x13,%eax
+    1597:	cd 40                	int    $0x40
+    1599:	c3                   	ret    
+
+0000159a <mkdir>:
+SYSCALL(mkdir)
+    159a:	b8 14 00 00 00       	mov    $0x14,%eax
+    159f:	cd 40                	int    $0x40
+    15a1:	c3                   	ret    
+
+000015a2 <chdir>:
+SYSCALL(chdir)
+    15a2:	b8 09 00 00 00       	mov    $0x9,%eax
+    15a7:	cd 40                	int    $0x40
+    15a9:	c3                   	ret    
+
+000015aa <dup>:
+SYSCALL(dup)
+    15aa:	b8 0a 00 00 00       	mov    $0xa,%eax
+    15af:	cd 40                	int    $0x40
+    15b1:	c3                   	ret    
+
+000015b2 <getpid>:
+SYSCALL(getpid)
+    15b2:	b8 0b 00 00 00       	mov    $0xb,%eax
+    15b7:	cd 40                	int    $0x40
+    15b9:	c3                   	ret    
+
+000015ba <sbrk>:
+SYSCALL(sbrk)
+    15ba:	b8 0c 00 00 00       	mov    $0xc,%eax
+    15bf:	cd 40                	int    $0x40
+    15c1:	c3                   	ret    
+
+000015c2 <sleep>:
+SYSCALL(sleep)
+    15c2:	b8 0d 00 00 00       	mov    $0xd,%eax
+    15c7:	cd 40                	int    $0x40
+    15c9:	c3                   	ret    
+
+000015ca <uptime>:
+SYSCALL(uptime)
+    15ca:	b8 0e 00 00 00       	mov    $0xe,%eax
+    15cf:	cd 40                	int    $0x40
+    15d1:	c3                   	ret    
+
+000015d2 <shm_open>:
+SYSCALL(shm_open)
+    15d2:	b8 16 00 00 00       	mov    $0x16,%eax
+    15d7:	cd 40                	int    $0x40
+    15d9:	c3                   	ret    
+
+000015da <shm_close>:
+SYSCALL(shm_close)	
+    15da:	b8 17 00 00 00       	mov    $0x17,%eax
+    15df:	cd 40                	int    $0x40
+    15e1:	c3                   	ret    
+    15e2:	66 90                	xchg   %ax,%ax
+    15e4:	66 90                	xchg   %ax,%ax
+    15e6:	66 90                	xchg   %ax,%ax
+    15e8:	66 90                	xchg   %ax,%ax
+    15ea:	66 90                	xchg   %ax,%ax
+    15ec:	66 90                	xchg   %ax,%ax
+    15ee:	66 90                	xchg   %ax,%ax
+
+000015f0 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    15f0:	55                   	push   %ebp
+    15f1:	89 e5                	mov    %esp,%ebp
+    15f3:	57                   	push   %edi
+    15f4:	56                   	push   %esi
+    15f5:	89 c6                	mov    %eax,%esi
+    15f7:	53                   	push   %ebx
+    15f8:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    15fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    15fe:	85 db                	test   %ebx,%ebx
+    1600:	74 09                	je     160b <printint+0x1b>
+    1602:	89 d0                	mov    %edx,%eax
+    1604:	c1 e8 1f             	shr    $0x1f,%eax
+    1607:	84 c0                	test   %al,%al
+    1609:	75 75                	jne    1680 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    160b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    160d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1614:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1617:	31 ff                	xor    %edi,%edi
+    1619:	89 ce                	mov    %ecx,%esi
+    161b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    161e:	eb 02                	jmp    1622 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1620:	89 cf                	mov    %ecx,%edi
+    1622:	31 d2                	xor    %edx,%edx
+    1624:	f7 f6                	div    %esi
+    1626:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1629:	0f b6 92 71 1a 00 00 	movzbl 0x1a71(%edx),%edx
+  }while((x /= base) != 0);
+    1630:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1632:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1635:	75 e9                	jne    1620 <printint+0x30>
+  if(neg)
+    1637:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    163a:	89 c8                	mov    %ecx,%eax
+    163c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    163f:	85 d2                	test   %edx,%edx
+    1641:	74 08                	je     164b <printint+0x5b>
+    buf[i++] = '-';
+    1643:	8d 4f 02             	lea    0x2(%edi),%ecx
+    1646:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    164b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    164e:	66 90                	xchg   %ax,%ax
+    1650:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    1655:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    1658:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    165f:	00 
+    1660:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1664:	89 34 24             	mov    %esi,(%esp)
+    1667:	88 45 d7             	mov    %al,-0x29(%ebp)
+    166a:	e8 e3 fe ff ff       	call   1552 <write>
+  while(--i >= 0)
+    166f:	83 ff ff             	cmp    $0xffffffff,%edi
+    1672:	75 dc                	jne    1650 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    1674:	83 c4 4c             	add    $0x4c,%esp
+    1677:	5b                   	pop    %ebx
+    1678:	5e                   	pop    %esi
+    1679:	5f                   	pop    %edi
+    167a:	5d                   	pop    %ebp
+    167b:	c3                   	ret    
+    167c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    1680:	89 d0                	mov    %edx,%eax
+    1682:	f7 d8                	neg    %eax
+    neg = 1;
+    1684:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    168b:	eb 87                	jmp    1614 <printint+0x24>
+    168d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00001690 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    1690:	55                   	push   %ebp
+    1691:	89 e5                	mov    %esp,%ebp
+    1693:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    1694:	31 ff                	xor    %edi,%edi
+{
+    1696:	56                   	push   %esi
+    1697:	53                   	push   %ebx
+    1698:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    169b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    169e:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    16a1:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    16a4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    16a7:	0f b6 13             	movzbl (%ebx),%edx
+    16aa:	83 c3 01             	add    $0x1,%ebx
+    16ad:	84 d2                	test   %dl,%dl
+    16af:	75 39                	jne    16ea <printf+0x5a>
+    16b1:	e9 c2 00 00 00       	jmp    1778 <printf+0xe8>
+    16b6:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    16b8:	83 fa 25             	cmp    $0x25,%edx
+    16bb:	0f 84 bf 00 00 00    	je     1780 <printf+0xf0>
+  write(fd, &c, 1);
+    16c1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    16c4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    16cb:	00 
+    16cc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    16d0:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    16d3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    16d6:	e8 77 fe ff ff       	call   1552 <write>
+    16db:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    16de:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    16e2:	84 d2                	test   %dl,%dl
+    16e4:	0f 84 8e 00 00 00    	je     1778 <printf+0xe8>
+    if(state == 0){
+    16ea:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    16ec:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    16ef:	74 c7                	je     16b8 <printf+0x28>
+      }
+    } else if(state == '%'){
+    16f1:	83 ff 25             	cmp    $0x25,%edi
+    16f4:	75 e5                	jne    16db <printf+0x4b>
+      if(c == 'd'){
+    16f6:	83 fa 64             	cmp    $0x64,%edx
+    16f9:	0f 84 31 01 00 00    	je     1830 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    16ff:	25 f7 00 00 00       	and    $0xf7,%eax
+    1704:	83 f8 70             	cmp    $0x70,%eax
+    1707:	0f 84 83 00 00 00    	je     1790 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    170d:	83 fa 73             	cmp    $0x73,%edx
+    1710:	0f 84 a2 00 00 00    	je     17b8 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1716:	83 fa 63             	cmp    $0x63,%edx
+    1719:	0f 84 35 01 00 00    	je     1854 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    171f:	83 fa 25             	cmp    $0x25,%edx
+    1722:	0f 84 e0 00 00 00    	je     1808 <printf+0x178>
+  write(fd, &c, 1);
+    1728:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    172b:	83 c3 01             	add    $0x1,%ebx
+    172e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1735:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    1736:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    1738:	89 44 24 04          	mov    %eax,0x4(%esp)
+    173c:	89 34 24             	mov    %esi,(%esp)
+    173f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    1742:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    1746:	e8 07 fe ff ff       	call   1552 <write>
+        putc(fd, c);
+    174b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    174e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    1751:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1758:	00 
+    1759:	89 44 24 04          	mov    %eax,0x4(%esp)
+    175d:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    1760:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    1763:	e8 ea fd ff ff       	call   1552 <write>
+  for(i = 0; fmt[i]; i++){
+    1768:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    176c:	84 d2                	test   %dl,%dl
+    176e:	0f 85 76 ff ff ff    	jne    16ea <printf+0x5a>
+    1774:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    1778:	83 c4 3c             	add    $0x3c,%esp
+    177b:	5b                   	pop    %ebx
+    177c:	5e                   	pop    %esi
+    177d:	5f                   	pop    %edi
+    177e:	5d                   	pop    %ebp
+    177f:	c3                   	ret    
+        state = '%';
+    1780:	bf 25 00 00 00       	mov    $0x25,%edi
+    1785:	e9 51 ff ff ff       	jmp    16db <printf+0x4b>
+    178a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    1790:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1793:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    1798:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    179a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    17a1:	8b 10                	mov    (%eax),%edx
+    17a3:	89 f0                	mov    %esi,%eax
+    17a5:	e8 46 fe ff ff       	call   15f0 <printint>
+        ap++;
+    17aa:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    17ae:	e9 28 ff ff ff       	jmp    16db <printf+0x4b>
+    17b3:	90                   	nop
+    17b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    17b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    17bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    17bf:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    17c1:	b8 6a 1a 00 00       	mov    $0x1a6a,%eax
+    17c6:	85 ff                	test   %edi,%edi
+    17c8:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    17cb:	0f b6 07             	movzbl (%edi),%eax
+    17ce:	84 c0                	test   %al,%al
+    17d0:	74 2a                	je     17fc <printf+0x16c>
+    17d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    17d8:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    17db:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    17de:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    17e1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    17e8:	00 
+    17e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    17ed:	89 34 24             	mov    %esi,(%esp)
+    17f0:	e8 5d fd ff ff       	call   1552 <write>
+        while(*s != 0){
+    17f5:	0f b6 07             	movzbl (%edi),%eax
+    17f8:	84 c0                	test   %al,%al
+    17fa:	75 dc                	jne    17d8 <printf+0x148>
+      state = 0;
+    17fc:	31 ff                	xor    %edi,%edi
+    17fe:	e9 d8 fe ff ff       	jmp    16db <printf+0x4b>
+    1803:	90                   	nop
+    1804:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1808:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    180b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    180d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1814:	00 
+    1815:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1819:	89 34 24             	mov    %esi,(%esp)
+    181c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1820:	e8 2d fd ff ff       	call   1552 <write>
+    1825:	e9 b1 fe ff ff       	jmp    16db <printf+0x4b>
+    182a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    1830:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1833:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    1838:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    183b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1842:	8b 10                	mov    (%eax),%edx
+    1844:	89 f0                	mov    %esi,%eax
+    1846:	e8 a5 fd ff ff       	call   15f0 <printint>
+        ap++;
+    184b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    184f:	e9 87 fe ff ff       	jmp    16db <printf+0x4b>
+        putc(fd, *ap);
+    1854:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    1857:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    1859:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    185b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1862:	00 
+    1863:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    1866:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    1869:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    186c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1870:	e8 dd fc ff ff       	call   1552 <write>
+        ap++;
+    1875:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    1879:	e9 5d fe ff ff       	jmp    16db <printf+0x4b>
+    187e:	66 90                	xchg   %ax,%ax
+
+00001880 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    1880:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1881:	a1 20 1e 00 00       	mov    0x1e20,%eax
+{
+    1886:	89 e5                	mov    %esp,%ebp
+    1888:	57                   	push   %edi
+    1889:	56                   	push   %esi
+    188a:	53                   	push   %ebx
+    188b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    188e:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    1890:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1893:	39 d0                	cmp    %edx,%eax
+    1895:	72 11                	jb     18a8 <free+0x28>
+    1897:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1898:	39 c8                	cmp    %ecx,%eax
+    189a:	72 04                	jb     18a0 <free+0x20>
+    189c:	39 ca                	cmp    %ecx,%edx
+    189e:	72 10                	jb     18b0 <free+0x30>
+    18a0:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    18a2:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    18a4:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    18a6:	73 f0                	jae    1898 <free+0x18>
+    18a8:	39 ca                	cmp    %ecx,%edx
+    18aa:	72 04                	jb     18b0 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    18ac:	39 c8                	cmp    %ecx,%eax
+    18ae:	72 f0                	jb     18a0 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    18b0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    18b3:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    18b6:	39 cf                	cmp    %ecx,%edi
+    18b8:	74 1e                	je     18d8 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    18ba:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    18bd:	8b 48 04             	mov    0x4(%eax),%ecx
+    18c0:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    18c3:	39 f2                	cmp    %esi,%edx
+    18c5:	74 28                	je     18ef <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    18c7:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    18c9:	a3 20 1e 00 00       	mov    %eax,0x1e20
+}
+    18ce:	5b                   	pop    %ebx
+    18cf:	5e                   	pop    %esi
+    18d0:	5f                   	pop    %edi
+    18d1:	5d                   	pop    %ebp
+    18d2:	c3                   	ret    
+    18d3:	90                   	nop
+    18d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    18d8:	03 71 04             	add    0x4(%ecx),%esi
+    18db:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    18de:	8b 08                	mov    (%eax),%ecx
+    18e0:	8b 09                	mov    (%ecx),%ecx
+    18e2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    18e5:	8b 48 04             	mov    0x4(%eax),%ecx
+    18e8:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    18eb:	39 f2                	cmp    %esi,%edx
+    18ed:	75 d8                	jne    18c7 <free+0x47>
+    p->s.size += bp->s.size;
+    18ef:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    18f2:	a3 20 1e 00 00       	mov    %eax,0x1e20
+    p->s.size += bp->s.size;
+    18f7:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    18fa:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    18fd:	89 10                	mov    %edx,(%eax)
+}
+    18ff:	5b                   	pop    %ebx
+    1900:	5e                   	pop    %esi
+    1901:	5f                   	pop    %edi
+    1902:	5d                   	pop    %ebp
+    1903:	c3                   	ret    
+    1904:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    190a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001910 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1910:	55                   	push   %ebp
+    1911:	89 e5                	mov    %esp,%ebp
+    1913:	57                   	push   %edi
+    1914:	56                   	push   %esi
+    1915:	53                   	push   %ebx
+    1916:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1919:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    191c:	8b 1d 20 1e 00 00    	mov    0x1e20,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1922:	8d 48 07             	lea    0x7(%eax),%ecx
+    1925:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1928:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    192a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    192d:	0f 84 9b 00 00 00    	je     19ce <malloc+0xbe>
+    1933:	8b 13                	mov    (%ebx),%edx
+    1935:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    1938:	39 fe                	cmp    %edi,%esi
+    193a:	76 64                	jbe    19a0 <malloc+0x90>
+    193c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    1943:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    1948:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    194b:	eb 0e                	jmp    195b <malloc+0x4b>
+    194d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1950:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    1952:	8b 78 04             	mov    0x4(%eax),%edi
+    1955:	39 fe                	cmp    %edi,%esi
+    1957:	76 4f                	jbe    19a8 <malloc+0x98>
+    1959:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    195b:	3b 15 20 1e 00 00    	cmp    0x1e20,%edx
+    1961:	75 ed                	jne    1950 <malloc+0x40>
+  if(nu < 4096)
+    1963:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1966:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    196c:	bf 00 10 00 00       	mov    $0x1000,%edi
+    1971:	0f 43 fe             	cmovae %esi,%edi
+    1974:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    1977:	89 04 24             	mov    %eax,(%esp)
+    197a:	e8 3b fc ff ff       	call   15ba <sbrk>
+  if(p == (char*)-1)
+    197f:	83 f8 ff             	cmp    $0xffffffff,%eax
+    1982:	74 18                	je     199c <malloc+0x8c>
+  hp->s.size = nu;
+    1984:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    1987:	83 c0 08             	add    $0x8,%eax
+    198a:	89 04 24             	mov    %eax,(%esp)
+    198d:	e8 ee fe ff ff       	call   1880 <free>
+  return freep;
+    1992:	8b 15 20 1e 00 00    	mov    0x1e20,%edx
+      if((p = morecore(nunits)) == 0)
+    1998:	85 d2                	test   %edx,%edx
+    199a:	75 b4                	jne    1950 <malloc+0x40>
+        return 0;
+    199c:	31 c0                	xor    %eax,%eax
+    199e:	eb 20                	jmp    19c0 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    19a0:	89 d0                	mov    %edx,%eax
+    19a2:	89 da                	mov    %ebx,%edx
+    19a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    19a8:	39 fe                	cmp    %edi,%esi
+    19aa:	74 1c                	je     19c8 <malloc+0xb8>
+        p->s.size -= nunits;
+    19ac:	29 f7                	sub    %esi,%edi
+    19ae:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    19b1:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    19b4:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    19b7:	89 15 20 1e 00 00    	mov    %edx,0x1e20
+      return (void*)(p + 1);
+    19bd:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    19c0:	83 c4 1c             	add    $0x1c,%esp
+    19c3:	5b                   	pop    %ebx
+    19c4:	5e                   	pop    %esi
+    19c5:	5f                   	pop    %edi
+    19c6:	5d                   	pop    %ebp
+    19c7:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    19c8:	8b 08                	mov    (%eax),%ecx
+    19ca:	89 0a                	mov    %ecx,(%edx)
+    19cc:	eb e9                	jmp    19b7 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    19ce:	c7 05 20 1e 00 00 24 	movl   $0x1e24,0x1e20
+    19d5:	1e 00 00 
+    base.s.size = 0;
+    19d8:	ba 24 1e 00 00       	mov    $0x1e24,%edx
+    base.s.ptr = freep = prevp = &base;
+    19dd:	c7 05 24 1e 00 00 24 	movl   $0x1e24,0x1e24
+    19e4:	1e 00 00 
+    base.s.size = 0;
+    19e7:	c7 05 28 1e 00 00 00 	movl   $0x0,0x1e28
+    19ee:	00 00 00 
+    19f1:	e9 46 ff ff ff       	jmp    193c <malloc+0x2c>
+    19f6:	66 90                	xchg   %ax,%ax
+    19f8:	66 90                	xchg   %ax,%ax
+    19fa:	66 90                	xchg   %ax,%ax
+    19fc:	66 90                	xchg   %ax,%ax
+    19fe:	66 90                	xchg   %ax,%ax
+
+00001a00 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1a00:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1a01:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1a06:	89 e5                	mov    %esp,%ebp
+    1a08:	8b 55 08             	mov    0x8(%ebp),%edx
+    1a0b:	90                   	nop
+    1a0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1a10:	89 c8                	mov    %ecx,%eax
+    1a12:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1a15:	85 c0                	test   %eax,%eax
+    1a17:	75 f7                	jne    1a10 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1a19:	0f ae f0             	mfence 
+}
+    1a1c:	5d                   	pop    %ebp
+    1a1d:	c3                   	ret    
+    1a1e:	66 90                	xchg   %ax,%ax
+
+00001a20 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1a20:	55                   	push   %ebp
+    1a21:	89 e5                	mov    %esp,%ebp
+    1a23:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1a26:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1a29:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    1a2f:	5d                   	pop    %ebp
+    1a30:	c3                   	ret    
diff --git a/grep.c b/grep.c
index 4be3256..adc4835 100644
--- a/grep.c
+++ b/grep.c
@@ -43,24 +43,24 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     printf(2, "usage: grep pattern [file ...]\n");
-    exit(1);
+    exit();
   }
   pattern = argv[1];
 
   if(argc <= 2){
     grep(pattern, 0);
-    exit(2);
+    exit();
   }
 
   for(i = 2; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "grep: cannot open %s\n", argv[i]);
-      exit(3);
+      exit();
     }
     grep(pattern, fd);
     close(fd);
   }
-  exit(0);
+  exit();
 }
 
 // Regexp matcher from Kernighan & Pike,
diff --git a/grep.d b/grep.d
new file mode 100644
index 0000000..15fc65b
--- /dev/null
+++ b/grep.d
@@ -0,0 +1 @@
+grep.o: grep.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/grep.o b/grep.o
new file mode 100644
index 0000000..6d08969
Binary files /dev/null and b/grep.o differ
diff --git a/grep.sym b/grep.sym
new file mode 100644
index 0000000..bee3097
--- /dev/null
+++ b/grep.sym
@@ -0,0 +1,67 @@
+00001000 .text
+00001a34 .rodata
+00001a84 .eh_frame
+00001e20 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 grep.c
+00000000 ulib.c
+00000000 printf.c
+000015f0 printint
+00001a71 digits.1359
+00000000 umalloc.c
+00001e20 freep
+00001e24 base
+00000000 uspinlock.c
+00001310 strcpy
+00001690 printf
+00001500 memmove
+00001120 matchhere
+0000157a mknod
+000015d2 shm_open
+00001420 gets
+000015b2 getpid
+00001200 grep
+00001910 malloc
+000015c2 sleep
+00001542 pipe
+00001552 write
+0000158a fstat
+00001562 kill
+000015a2 chdir
+0000156a exec
+0000153a wait
+0000154a read
+00001582 unlink
+00001a00 uacquire
+0000152a fork
+000015ba sbrk
+000015da shm_close
+000015ca uptime
+00001e04 __bss_start
+000013c0 memset
+00001000 main
+000010c0 matchstar
+00001340 strcmp
+000015aa dup
+00001e40 buf
+00001480 stat
+00001e04 _edata
+00002240 _end
+000011b0 match
+00001592 link
+00001532 exit
+000014d0 atoi
+00001390 strlen
+00001572 open
+000013e0 strchr
+0000159a mkdir
+0000155a close
+00001a20 urelease
+00001880 free
diff --git a/ide.d b/ide.d
new file mode 100644
index 0000000..21155b9
--- /dev/null
+++ b/ide.d
@@ -0,0 +1,2 @@
+ide.o: ide.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h proc.h x86.h traps.h spinlock.h sleeplock.h fs.h buf.h
diff --git a/ide.o b/ide.o
new file mode 100644
index 0000000..82f147e
Binary files /dev/null and b/ide.o differ
diff --git a/init.asm b/init.asm
new file mode 100644
index 0000000..30a3d54
--- /dev/null
+++ b/init.asm
@@ -0,0 +1,1275 @@
+
+_init:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+
+char *argv[] = { "sh", 0 };
+
+int
+main(void)
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	53                   	push   %ebx
+    1004:	83 e4 f0             	and    $0xfffffff0,%esp
+    1007:	83 ec 10             	sub    $0x10,%esp
+  int pid, wpid;
+
+  if(open("console", O_RDWR) < 0){
+    100a:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+    1011:	00 
+    1012:	c7 04 24 31 18 00 00 	movl   $0x1831,(%esp)
+    1019:	e8 54 03 00 00       	call   1372 <open>
+    101e:	85 c0                	test   %eax,%eax
+    1020:	0f 88 ac 00 00 00    	js     10d2 <main+0xd2>
+    mknod("console", 1, 1);
+    open("console", O_RDWR);
+  }
+  dup(0);  // stdout
+    1026:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    102d:	e8 78 03 00 00       	call   13aa <dup>
+  dup(0);  // stderr
+    1032:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1039:	e8 6c 03 00 00       	call   13aa <dup>
+    103e:	66 90                	xchg   %ax,%ax
+
+  for(;;){
+    printf(1, "init: starting sh\n");
+    1040:	c7 44 24 04 39 18 00 	movl   $0x1839,0x4(%esp)
+    1047:	00 
+    1048:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    104f:	e8 3c 04 00 00       	call   1490 <printf>
+    pid = fork();
+    1054:	e8 d1 02 00 00       	call   132a <fork>
+    if(pid < 0){
+    1059:	85 c0                	test   %eax,%eax
+    pid = fork();
+    105b:	89 c3                	mov    %eax,%ebx
+    if(pid < 0){
+    105d:	78 2d                	js     108c <main+0x8c>
+    105f:	90                   	nop
+      printf(1, "init: fork failed\n");
+      exit();
+    }
+    if(pid == 0){
+    1060:	74 43                	je     10a5 <main+0xa5>
+    1062:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      exec("sh", argv);
+      printf(1, "init: exec sh failed\n");
+      exit();
+    }
+    while((wpid=wait()) >= 0 && wpid != pid)
+    1068:	e8 cd 02 00 00       	call   133a <wait>
+    106d:	85 c0                	test   %eax,%eax
+    106f:	90                   	nop
+    1070:	78 ce                	js     1040 <main+0x40>
+    1072:	39 d8                	cmp    %ebx,%eax
+    1074:	74 ca                	je     1040 <main+0x40>
+      printf(1, "zombie!\n");
+    1076:	c7 44 24 04 78 18 00 	movl   $0x1878,0x4(%esp)
+    107d:	00 
+    107e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1085:	e8 06 04 00 00       	call   1490 <printf>
+    108a:	eb dc                	jmp    1068 <main+0x68>
+      printf(1, "init: fork failed\n");
+    108c:	c7 44 24 04 4c 18 00 	movl   $0x184c,0x4(%esp)
+    1093:	00 
+    1094:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    109b:	e8 f0 03 00 00       	call   1490 <printf>
+      exit();
+    10a0:	e8 8d 02 00 00       	call   1332 <exit>
+      exec("sh", argv);
+    10a5:	c7 44 24 04 40 1b 00 	movl   $0x1b40,0x4(%esp)
+    10ac:	00 
+    10ad:	c7 04 24 5f 18 00 00 	movl   $0x185f,(%esp)
+    10b4:	e8 b1 02 00 00       	call   136a <exec>
+      printf(1, "init: exec sh failed\n");
+    10b9:	c7 44 24 04 62 18 00 	movl   $0x1862,0x4(%esp)
+    10c0:	00 
+    10c1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10c8:	e8 c3 03 00 00       	call   1490 <printf>
+      exit();
+    10cd:	e8 60 02 00 00       	call   1332 <exit>
+    mknod("console", 1, 1);
+    10d2:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    10d9:	00 
+    10da:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+    10e1:	00 
+    10e2:	c7 04 24 31 18 00 00 	movl   $0x1831,(%esp)
+    10e9:	e8 8c 02 00 00       	call   137a <mknod>
+    open("console", O_RDWR);
+    10ee:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+    10f5:	00 
+    10f6:	c7 04 24 31 18 00 00 	movl   $0x1831,(%esp)
+    10fd:	e8 70 02 00 00       	call   1372 <open>
+    1102:	e9 1f ff ff ff       	jmp    1026 <main+0x26>
+    1107:	66 90                	xchg   %ax,%ax
+    1109:	66 90                	xchg   %ax,%ax
+    110b:	66 90                	xchg   %ax,%ax
+    110d:	66 90                	xchg   %ax,%ax
+    110f:	90                   	nop
+
+00001110 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1110:	55                   	push   %ebp
+    1111:	89 e5                	mov    %esp,%ebp
+    1113:	8b 45 08             	mov    0x8(%ebp),%eax
+    1116:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1119:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    111a:	89 c2                	mov    %eax,%edx
+    111c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1120:	83 c1 01             	add    $0x1,%ecx
+    1123:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1127:	83 c2 01             	add    $0x1,%edx
+    112a:	84 db                	test   %bl,%bl
+    112c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    112f:	75 ef                	jne    1120 <strcpy+0x10>
+    ;
+  return os;
+}
+    1131:	5b                   	pop    %ebx
+    1132:	5d                   	pop    %ebp
+    1133:	c3                   	ret    
+    1134:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    113a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001140 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1140:	55                   	push   %ebp
+    1141:	89 e5                	mov    %esp,%ebp
+    1143:	8b 55 08             	mov    0x8(%ebp),%edx
+    1146:	53                   	push   %ebx
+    1147:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    114a:	0f b6 02             	movzbl (%edx),%eax
+    114d:	84 c0                	test   %al,%al
+    114f:	74 2d                	je     117e <strcmp+0x3e>
+    1151:	0f b6 19             	movzbl (%ecx),%ebx
+    1154:	38 d8                	cmp    %bl,%al
+    1156:	74 0e                	je     1166 <strcmp+0x26>
+    1158:	eb 2b                	jmp    1185 <strcmp+0x45>
+    115a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1160:	38 c8                	cmp    %cl,%al
+    1162:	75 15                	jne    1179 <strcmp+0x39>
+    p++, q++;
+    1164:	89 d9                	mov    %ebx,%ecx
+    1166:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    1169:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    116c:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    116f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    1173:	84 c0                	test   %al,%al
+    1175:	75 e9                	jne    1160 <strcmp+0x20>
+    1177:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    1179:	29 c8                	sub    %ecx,%eax
+}
+    117b:	5b                   	pop    %ebx
+    117c:	5d                   	pop    %ebp
+    117d:	c3                   	ret    
+    117e:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    1181:	31 c0                	xor    %eax,%eax
+    1183:	eb f4                	jmp    1179 <strcmp+0x39>
+    1185:	0f b6 cb             	movzbl %bl,%ecx
+    1188:	eb ef                	jmp    1179 <strcmp+0x39>
+    118a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001190 <strlen>:
+
+uint
+strlen(char *s)
+{
+    1190:	55                   	push   %ebp
+    1191:	89 e5                	mov    %esp,%ebp
+    1193:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    1196:	80 39 00             	cmpb   $0x0,(%ecx)
+    1199:	74 12                	je     11ad <strlen+0x1d>
+    119b:	31 d2                	xor    %edx,%edx
+    119d:	8d 76 00             	lea    0x0(%esi),%esi
+    11a0:	83 c2 01             	add    $0x1,%edx
+    11a3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    11a7:	89 d0                	mov    %edx,%eax
+    11a9:	75 f5                	jne    11a0 <strlen+0x10>
+    ;
+  return n;
+}
+    11ab:	5d                   	pop    %ebp
+    11ac:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    11ad:	31 c0                	xor    %eax,%eax
+}
+    11af:	5d                   	pop    %ebp
+    11b0:	c3                   	ret    
+    11b1:	eb 0d                	jmp    11c0 <memset>
+    11b3:	90                   	nop
+    11b4:	90                   	nop
+    11b5:	90                   	nop
+    11b6:	90                   	nop
+    11b7:	90                   	nop
+    11b8:	90                   	nop
+    11b9:	90                   	nop
+    11ba:	90                   	nop
+    11bb:	90                   	nop
+    11bc:	90                   	nop
+    11bd:	90                   	nop
+    11be:	90                   	nop
+    11bf:	90                   	nop
+
+000011c0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    11c0:	55                   	push   %ebp
+    11c1:	89 e5                	mov    %esp,%ebp
+    11c3:	8b 55 08             	mov    0x8(%ebp),%edx
+    11c6:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    11c7:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    11ca:	8b 45 0c             	mov    0xc(%ebp),%eax
+    11cd:	89 d7                	mov    %edx,%edi
+    11cf:	fc                   	cld    
+    11d0:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    11d2:	89 d0                	mov    %edx,%eax
+    11d4:	5f                   	pop    %edi
+    11d5:	5d                   	pop    %ebp
+    11d6:	c3                   	ret    
+    11d7:	89 f6                	mov    %esi,%esi
+    11d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+000011e0 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    11e0:	55                   	push   %ebp
+    11e1:	89 e5                	mov    %esp,%ebp
+    11e3:	8b 45 08             	mov    0x8(%ebp),%eax
+    11e6:	53                   	push   %ebx
+    11e7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    11ea:	0f b6 18             	movzbl (%eax),%ebx
+    11ed:	84 db                	test   %bl,%bl
+    11ef:	74 1d                	je     120e <strchr+0x2e>
+    if(*s == c)
+    11f1:	38 d3                	cmp    %dl,%bl
+    11f3:	89 d1                	mov    %edx,%ecx
+    11f5:	75 0d                	jne    1204 <strchr+0x24>
+    11f7:	eb 17                	jmp    1210 <strchr+0x30>
+    11f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1200:	38 ca                	cmp    %cl,%dl
+    1202:	74 0c                	je     1210 <strchr+0x30>
+  for(; *s; s++)
+    1204:	83 c0 01             	add    $0x1,%eax
+    1207:	0f b6 10             	movzbl (%eax),%edx
+    120a:	84 d2                	test   %dl,%dl
+    120c:	75 f2                	jne    1200 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    120e:	31 c0                	xor    %eax,%eax
+}
+    1210:	5b                   	pop    %ebx
+    1211:	5d                   	pop    %ebp
+    1212:	c3                   	ret    
+    1213:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001220 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1220:	55                   	push   %ebp
+    1221:	89 e5                	mov    %esp,%ebp
+    1223:	57                   	push   %edi
+    1224:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1225:	31 f6                	xor    %esi,%esi
+{
+    1227:	53                   	push   %ebx
+    1228:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    122b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    122e:	eb 31                	jmp    1261 <gets+0x41>
+    cc = read(0, &c, 1);
+    1230:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1237:	00 
+    1238:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    123c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1243:	e8 02 01 00 00       	call   134a <read>
+    if(cc < 1)
+    1248:	85 c0                	test   %eax,%eax
+    124a:	7e 1d                	jle    1269 <gets+0x49>
+      break;
+    buf[i++] = c;
+    124c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    1250:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    1252:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    1255:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    1257:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    125b:	74 0c                	je     1269 <gets+0x49>
+    125d:	3c 0a                	cmp    $0xa,%al
+    125f:	74 08                	je     1269 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    1261:	8d 5e 01             	lea    0x1(%esi),%ebx
+    1264:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    1267:	7c c7                	jl     1230 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    1269:	8b 45 08             	mov    0x8(%ebp),%eax
+    126c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    1270:	83 c4 2c             	add    $0x2c,%esp
+    1273:	5b                   	pop    %ebx
+    1274:	5e                   	pop    %esi
+    1275:	5f                   	pop    %edi
+    1276:	5d                   	pop    %ebp
+    1277:	c3                   	ret    
+    1278:	90                   	nop
+    1279:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001280 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    1280:	55                   	push   %ebp
+    1281:	89 e5                	mov    %esp,%ebp
+    1283:	56                   	push   %esi
+    1284:	53                   	push   %ebx
+    1285:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    1288:	8b 45 08             	mov    0x8(%ebp),%eax
+    128b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1292:	00 
+    1293:	89 04 24             	mov    %eax,(%esp)
+    1296:	e8 d7 00 00 00       	call   1372 <open>
+  if(fd < 0)
+    129b:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    129d:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    129f:	78 27                	js     12c8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    12a1:	8b 45 0c             	mov    0xc(%ebp),%eax
+    12a4:	89 1c 24             	mov    %ebx,(%esp)
+    12a7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    12ab:	e8 da 00 00 00       	call   138a <fstat>
+  close(fd);
+    12b0:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    12b3:	89 c6                	mov    %eax,%esi
+  close(fd);
+    12b5:	e8 a0 00 00 00       	call   135a <close>
+  return r;
+    12ba:	89 f0                	mov    %esi,%eax
+}
+    12bc:	83 c4 10             	add    $0x10,%esp
+    12bf:	5b                   	pop    %ebx
+    12c0:	5e                   	pop    %esi
+    12c1:	5d                   	pop    %ebp
+    12c2:	c3                   	ret    
+    12c3:	90                   	nop
+    12c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    12c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    12cd:	eb ed                	jmp    12bc <stat+0x3c>
+    12cf:	90                   	nop
+
+000012d0 <atoi>:
+
+int
+atoi(const char *s)
+{
+    12d0:	55                   	push   %ebp
+    12d1:	89 e5                	mov    %esp,%ebp
+    12d3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    12d6:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    12d7:	0f be 11             	movsbl (%ecx),%edx
+    12da:	8d 42 d0             	lea    -0x30(%edx),%eax
+    12dd:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    12df:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    12e4:	77 17                	ja     12fd <atoi+0x2d>
+    12e6:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    12e8:	83 c1 01             	add    $0x1,%ecx
+    12eb:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    12ee:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    12f2:	0f be 11             	movsbl (%ecx),%edx
+    12f5:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    12f8:	80 fb 09             	cmp    $0x9,%bl
+    12fb:	76 eb                	jbe    12e8 <atoi+0x18>
+  return n;
+}
+    12fd:	5b                   	pop    %ebx
+    12fe:	5d                   	pop    %ebp
+    12ff:	c3                   	ret    
+
+00001300 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1300:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1301:	31 d2                	xor    %edx,%edx
+{
+    1303:	89 e5                	mov    %esp,%ebp
+    1305:	56                   	push   %esi
+    1306:	8b 45 08             	mov    0x8(%ebp),%eax
+    1309:	53                   	push   %ebx
+    130a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    130d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1310:	85 db                	test   %ebx,%ebx
+    1312:	7e 12                	jle    1326 <memmove+0x26>
+    1314:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1318:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    131c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    131f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1322:	39 da                	cmp    %ebx,%edx
+    1324:	75 f2                	jne    1318 <memmove+0x18>
+  return vdst;
+}
+    1326:	5b                   	pop    %ebx
+    1327:	5e                   	pop    %esi
+    1328:	5d                   	pop    %ebp
+    1329:	c3                   	ret    
+
+0000132a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    132a:	b8 01 00 00 00       	mov    $0x1,%eax
+    132f:	cd 40                	int    $0x40
+    1331:	c3                   	ret    
+
+00001332 <exit>:
+SYSCALL(exit)
+    1332:	b8 02 00 00 00       	mov    $0x2,%eax
+    1337:	cd 40                	int    $0x40
+    1339:	c3                   	ret    
+
+0000133a <wait>:
+SYSCALL(wait)
+    133a:	b8 03 00 00 00       	mov    $0x3,%eax
+    133f:	cd 40                	int    $0x40
+    1341:	c3                   	ret    
+
+00001342 <pipe>:
+SYSCALL(pipe)
+    1342:	b8 04 00 00 00       	mov    $0x4,%eax
+    1347:	cd 40                	int    $0x40
+    1349:	c3                   	ret    
+
+0000134a <read>:
+SYSCALL(read)
+    134a:	b8 05 00 00 00       	mov    $0x5,%eax
+    134f:	cd 40                	int    $0x40
+    1351:	c3                   	ret    
+
+00001352 <write>:
+SYSCALL(write)
+    1352:	b8 10 00 00 00       	mov    $0x10,%eax
+    1357:	cd 40                	int    $0x40
+    1359:	c3                   	ret    
+
+0000135a <close>:
+SYSCALL(close)
+    135a:	b8 15 00 00 00       	mov    $0x15,%eax
+    135f:	cd 40                	int    $0x40
+    1361:	c3                   	ret    
+
+00001362 <kill>:
+SYSCALL(kill)
+    1362:	b8 06 00 00 00       	mov    $0x6,%eax
+    1367:	cd 40                	int    $0x40
+    1369:	c3                   	ret    
+
+0000136a <exec>:
+SYSCALL(exec)
+    136a:	b8 07 00 00 00       	mov    $0x7,%eax
+    136f:	cd 40                	int    $0x40
+    1371:	c3                   	ret    
+
+00001372 <open>:
+SYSCALL(open)
+    1372:	b8 0f 00 00 00       	mov    $0xf,%eax
+    1377:	cd 40                	int    $0x40
+    1379:	c3                   	ret    
+
+0000137a <mknod>:
+SYSCALL(mknod)
+    137a:	b8 11 00 00 00       	mov    $0x11,%eax
+    137f:	cd 40                	int    $0x40
+    1381:	c3                   	ret    
+
+00001382 <unlink>:
+SYSCALL(unlink)
+    1382:	b8 12 00 00 00       	mov    $0x12,%eax
+    1387:	cd 40                	int    $0x40
+    1389:	c3                   	ret    
+
+0000138a <fstat>:
+SYSCALL(fstat)
+    138a:	b8 08 00 00 00       	mov    $0x8,%eax
+    138f:	cd 40                	int    $0x40
+    1391:	c3                   	ret    
+
+00001392 <link>:
+SYSCALL(link)
+    1392:	b8 13 00 00 00       	mov    $0x13,%eax
+    1397:	cd 40                	int    $0x40
+    1399:	c3                   	ret    
+
+0000139a <mkdir>:
+SYSCALL(mkdir)
+    139a:	b8 14 00 00 00       	mov    $0x14,%eax
+    139f:	cd 40                	int    $0x40
+    13a1:	c3                   	ret    
+
+000013a2 <chdir>:
+SYSCALL(chdir)
+    13a2:	b8 09 00 00 00       	mov    $0x9,%eax
+    13a7:	cd 40                	int    $0x40
+    13a9:	c3                   	ret    
+
+000013aa <dup>:
+SYSCALL(dup)
+    13aa:	b8 0a 00 00 00       	mov    $0xa,%eax
+    13af:	cd 40                	int    $0x40
+    13b1:	c3                   	ret    
+
+000013b2 <getpid>:
+SYSCALL(getpid)
+    13b2:	b8 0b 00 00 00       	mov    $0xb,%eax
+    13b7:	cd 40                	int    $0x40
+    13b9:	c3                   	ret    
+
+000013ba <sbrk>:
+SYSCALL(sbrk)
+    13ba:	b8 0c 00 00 00       	mov    $0xc,%eax
+    13bf:	cd 40                	int    $0x40
+    13c1:	c3                   	ret    
+
+000013c2 <sleep>:
+SYSCALL(sleep)
+    13c2:	b8 0d 00 00 00       	mov    $0xd,%eax
+    13c7:	cd 40                	int    $0x40
+    13c9:	c3                   	ret    
+
+000013ca <uptime>:
+SYSCALL(uptime)
+    13ca:	b8 0e 00 00 00       	mov    $0xe,%eax
+    13cf:	cd 40                	int    $0x40
+    13d1:	c3                   	ret    
+
+000013d2 <shm_open>:
+SYSCALL(shm_open)
+    13d2:	b8 16 00 00 00       	mov    $0x16,%eax
+    13d7:	cd 40                	int    $0x40
+    13d9:	c3                   	ret    
+
+000013da <shm_close>:
+SYSCALL(shm_close)	
+    13da:	b8 17 00 00 00       	mov    $0x17,%eax
+    13df:	cd 40                	int    $0x40
+    13e1:	c3                   	ret    
+    13e2:	66 90                	xchg   %ax,%ax
+    13e4:	66 90                	xchg   %ax,%ax
+    13e6:	66 90                	xchg   %ax,%ax
+    13e8:	66 90                	xchg   %ax,%ax
+    13ea:	66 90                	xchg   %ax,%ax
+    13ec:	66 90                	xchg   %ax,%ax
+    13ee:	66 90                	xchg   %ax,%ax
+
+000013f0 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    13f0:	55                   	push   %ebp
+    13f1:	89 e5                	mov    %esp,%ebp
+    13f3:	57                   	push   %edi
+    13f4:	56                   	push   %esi
+    13f5:	89 c6                	mov    %eax,%esi
+    13f7:	53                   	push   %ebx
+    13f8:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    13fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    13fe:	85 db                	test   %ebx,%ebx
+    1400:	74 09                	je     140b <printint+0x1b>
+    1402:	89 d0                	mov    %edx,%eax
+    1404:	c1 e8 1f             	shr    $0x1f,%eax
+    1407:	84 c0                	test   %al,%al
+    1409:	75 75                	jne    1480 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    140b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    140d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1414:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1417:	31 ff                	xor    %edi,%edi
+    1419:	89 ce                	mov    %ecx,%esi
+    141b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    141e:	eb 02                	jmp    1422 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1420:	89 cf                	mov    %ecx,%edi
+    1422:	31 d2                	xor    %edx,%edx
+    1424:	f7 f6                	div    %esi
+    1426:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1429:	0f b6 92 88 18 00 00 	movzbl 0x1888(%edx),%edx
+  }while((x /= base) != 0);
+    1430:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1432:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1435:	75 e9                	jne    1420 <printint+0x30>
+  if(neg)
+    1437:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    143a:	89 c8                	mov    %ecx,%eax
+    143c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    143f:	85 d2                	test   %edx,%edx
+    1441:	74 08                	je     144b <printint+0x5b>
+    buf[i++] = '-';
+    1443:	8d 4f 02             	lea    0x2(%edi),%ecx
+    1446:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    144b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    144e:	66 90                	xchg   %ax,%ax
+    1450:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    1455:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    1458:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    145f:	00 
+    1460:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1464:	89 34 24             	mov    %esi,(%esp)
+    1467:	88 45 d7             	mov    %al,-0x29(%ebp)
+    146a:	e8 e3 fe ff ff       	call   1352 <write>
+  while(--i >= 0)
+    146f:	83 ff ff             	cmp    $0xffffffff,%edi
+    1472:	75 dc                	jne    1450 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    1474:	83 c4 4c             	add    $0x4c,%esp
+    1477:	5b                   	pop    %ebx
+    1478:	5e                   	pop    %esi
+    1479:	5f                   	pop    %edi
+    147a:	5d                   	pop    %ebp
+    147b:	c3                   	ret    
+    147c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    1480:	89 d0                	mov    %edx,%eax
+    1482:	f7 d8                	neg    %eax
+    neg = 1;
+    1484:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    148b:	eb 87                	jmp    1414 <printint+0x24>
+    148d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00001490 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    1490:	55                   	push   %ebp
+    1491:	89 e5                	mov    %esp,%ebp
+    1493:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    1494:	31 ff                	xor    %edi,%edi
+{
+    1496:	56                   	push   %esi
+    1497:	53                   	push   %ebx
+    1498:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    149b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    149e:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    14a1:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    14a4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    14a7:	0f b6 13             	movzbl (%ebx),%edx
+    14aa:	83 c3 01             	add    $0x1,%ebx
+    14ad:	84 d2                	test   %dl,%dl
+    14af:	75 39                	jne    14ea <printf+0x5a>
+    14b1:	e9 c2 00 00 00       	jmp    1578 <printf+0xe8>
+    14b6:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    14b8:	83 fa 25             	cmp    $0x25,%edx
+    14bb:	0f 84 bf 00 00 00    	je     1580 <printf+0xf0>
+  write(fd, &c, 1);
+    14c1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    14c4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14cb:	00 
+    14cc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14d0:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    14d3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    14d6:	e8 77 fe ff ff       	call   1352 <write>
+    14db:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    14de:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    14e2:	84 d2                	test   %dl,%dl
+    14e4:	0f 84 8e 00 00 00    	je     1578 <printf+0xe8>
+    if(state == 0){
+    14ea:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    14ec:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    14ef:	74 c7                	je     14b8 <printf+0x28>
+      }
+    } else if(state == '%'){
+    14f1:	83 ff 25             	cmp    $0x25,%edi
+    14f4:	75 e5                	jne    14db <printf+0x4b>
+      if(c == 'd'){
+    14f6:	83 fa 64             	cmp    $0x64,%edx
+    14f9:	0f 84 31 01 00 00    	je     1630 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    14ff:	25 f7 00 00 00       	and    $0xf7,%eax
+    1504:	83 f8 70             	cmp    $0x70,%eax
+    1507:	0f 84 83 00 00 00    	je     1590 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    150d:	83 fa 73             	cmp    $0x73,%edx
+    1510:	0f 84 a2 00 00 00    	je     15b8 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1516:	83 fa 63             	cmp    $0x63,%edx
+    1519:	0f 84 35 01 00 00    	je     1654 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    151f:	83 fa 25             	cmp    $0x25,%edx
+    1522:	0f 84 e0 00 00 00    	je     1608 <printf+0x178>
+  write(fd, &c, 1);
+    1528:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    152b:	83 c3 01             	add    $0x1,%ebx
+    152e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1535:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    1536:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    1538:	89 44 24 04          	mov    %eax,0x4(%esp)
+    153c:	89 34 24             	mov    %esi,(%esp)
+    153f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    1542:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    1546:	e8 07 fe ff ff       	call   1352 <write>
+        putc(fd, c);
+    154b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    154e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    1551:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1558:	00 
+    1559:	89 44 24 04          	mov    %eax,0x4(%esp)
+    155d:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    1560:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    1563:	e8 ea fd ff ff       	call   1352 <write>
+  for(i = 0; fmt[i]; i++){
+    1568:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    156c:	84 d2                	test   %dl,%dl
+    156e:	0f 85 76 ff ff ff    	jne    14ea <printf+0x5a>
+    1574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    1578:	83 c4 3c             	add    $0x3c,%esp
+    157b:	5b                   	pop    %ebx
+    157c:	5e                   	pop    %esi
+    157d:	5f                   	pop    %edi
+    157e:	5d                   	pop    %ebp
+    157f:	c3                   	ret    
+        state = '%';
+    1580:	bf 25 00 00 00       	mov    $0x25,%edi
+    1585:	e9 51 ff ff ff       	jmp    14db <printf+0x4b>
+    158a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    1590:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1593:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    1598:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    159a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    15a1:	8b 10                	mov    (%eax),%edx
+    15a3:	89 f0                	mov    %esi,%eax
+    15a5:	e8 46 fe ff ff       	call   13f0 <printint>
+        ap++;
+    15aa:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15ae:	e9 28 ff ff ff       	jmp    14db <printf+0x4b>
+    15b3:	90                   	nop
+    15b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    15b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    15bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    15bf:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    15c1:	b8 81 18 00 00       	mov    $0x1881,%eax
+    15c6:	85 ff                	test   %edi,%edi
+    15c8:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    15cb:	0f b6 07             	movzbl (%edi),%eax
+    15ce:	84 c0                	test   %al,%al
+    15d0:	74 2a                	je     15fc <printf+0x16c>
+    15d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    15d8:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    15db:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    15de:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    15e1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    15e8:	00 
+    15e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15ed:	89 34 24             	mov    %esi,(%esp)
+    15f0:	e8 5d fd ff ff       	call   1352 <write>
+        while(*s != 0){
+    15f5:	0f b6 07             	movzbl (%edi),%eax
+    15f8:	84 c0                	test   %al,%al
+    15fa:	75 dc                	jne    15d8 <printf+0x148>
+      state = 0;
+    15fc:	31 ff                	xor    %edi,%edi
+    15fe:	e9 d8 fe ff ff       	jmp    14db <printf+0x4b>
+    1603:	90                   	nop
+    1604:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1608:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    160b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    160d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1614:	00 
+    1615:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1619:	89 34 24             	mov    %esi,(%esp)
+    161c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1620:	e8 2d fd ff ff       	call   1352 <write>
+    1625:	e9 b1 fe ff ff       	jmp    14db <printf+0x4b>
+    162a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    1630:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1633:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    1638:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    163b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1642:	8b 10                	mov    (%eax),%edx
+    1644:	89 f0                	mov    %esi,%eax
+    1646:	e8 a5 fd ff ff       	call   13f0 <printint>
+        ap++;
+    164b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    164f:	e9 87 fe ff ff       	jmp    14db <printf+0x4b>
+        putc(fd, *ap);
+    1654:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    1657:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    1659:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    165b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1662:	00 
+    1663:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    1666:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    1669:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    166c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1670:	e8 dd fc ff ff       	call   1352 <write>
+        ap++;
+    1675:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    1679:	e9 5d fe ff ff       	jmp    14db <printf+0x4b>
+    167e:	66 90                	xchg   %ax,%ax
+
+00001680 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    1680:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1681:	a1 48 1b 00 00       	mov    0x1b48,%eax
+{
+    1686:	89 e5                	mov    %esp,%ebp
+    1688:	57                   	push   %edi
+    1689:	56                   	push   %esi
+    168a:	53                   	push   %ebx
+    168b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    168e:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    1690:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1693:	39 d0                	cmp    %edx,%eax
+    1695:	72 11                	jb     16a8 <free+0x28>
+    1697:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1698:	39 c8                	cmp    %ecx,%eax
+    169a:	72 04                	jb     16a0 <free+0x20>
+    169c:	39 ca                	cmp    %ecx,%edx
+    169e:	72 10                	jb     16b0 <free+0x30>
+    16a0:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16a2:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16a4:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16a6:	73 f0                	jae    1698 <free+0x18>
+    16a8:	39 ca                	cmp    %ecx,%edx
+    16aa:	72 04                	jb     16b0 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16ac:	39 c8                	cmp    %ecx,%eax
+    16ae:	72 f0                	jb     16a0 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    16b0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    16b3:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    16b6:	39 cf                	cmp    %ecx,%edi
+    16b8:	74 1e                	je     16d8 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    16ba:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    16bd:	8b 48 04             	mov    0x4(%eax),%ecx
+    16c0:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    16c3:	39 f2                	cmp    %esi,%edx
+    16c5:	74 28                	je     16ef <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    16c7:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    16c9:	a3 48 1b 00 00       	mov    %eax,0x1b48
+}
+    16ce:	5b                   	pop    %ebx
+    16cf:	5e                   	pop    %esi
+    16d0:	5f                   	pop    %edi
+    16d1:	5d                   	pop    %ebp
+    16d2:	c3                   	ret    
+    16d3:	90                   	nop
+    16d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    16d8:	03 71 04             	add    0x4(%ecx),%esi
+    16db:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    16de:	8b 08                	mov    (%eax),%ecx
+    16e0:	8b 09                	mov    (%ecx),%ecx
+    16e2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    16e5:	8b 48 04             	mov    0x4(%eax),%ecx
+    16e8:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    16eb:	39 f2                	cmp    %esi,%edx
+    16ed:	75 d8                	jne    16c7 <free+0x47>
+    p->s.size += bp->s.size;
+    16ef:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    16f2:	a3 48 1b 00 00       	mov    %eax,0x1b48
+    p->s.size += bp->s.size;
+    16f7:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    16fa:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    16fd:	89 10                	mov    %edx,(%eax)
+}
+    16ff:	5b                   	pop    %ebx
+    1700:	5e                   	pop    %esi
+    1701:	5f                   	pop    %edi
+    1702:	5d                   	pop    %ebp
+    1703:	c3                   	ret    
+    1704:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    170a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001710 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1710:	55                   	push   %ebp
+    1711:	89 e5                	mov    %esp,%ebp
+    1713:	57                   	push   %edi
+    1714:	56                   	push   %esi
+    1715:	53                   	push   %ebx
+    1716:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1719:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    171c:	8b 1d 48 1b 00 00    	mov    0x1b48,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1722:	8d 48 07             	lea    0x7(%eax),%ecx
+    1725:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1728:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    172a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    172d:	0f 84 9b 00 00 00    	je     17ce <malloc+0xbe>
+    1733:	8b 13                	mov    (%ebx),%edx
+    1735:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    1738:	39 fe                	cmp    %edi,%esi
+    173a:	76 64                	jbe    17a0 <malloc+0x90>
+    173c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    1743:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    1748:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    174b:	eb 0e                	jmp    175b <malloc+0x4b>
+    174d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1750:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    1752:	8b 78 04             	mov    0x4(%eax),%edi
+    1755:	39 fe                	cmp    %edi,%esi
+    1757:	76 4f                	jbe    17a8 <malloc+0x98>
+    1759:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    175b:	3b 15 48 1b 00 00    	cmp    0x1b48,%edx
+    1761:	75 ed                	jne    1750 <malloc+0x40>
+  if(nu < 4096)
+    1763:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1766:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    176c:	bf 00 10 00 00       	mov    $0x1000,%edi
+    1771:	0f 43 fe             	cmovae %esi,%edi
+    1774:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    1777:	89 04 24             	mov    %eax,(%esp)
+    177a:	e8 3b fc ff ff       	call   13ba <sbrk>
+  if(p == (char*)-1)
+    177f:	83 f8 ff             	cmp    $0xffffffff,%eax
+    1782:	74 18                	je     179c <malloc+0x8c>
+  hp->s.size = nu;
+    1784:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    1787:	83 c0 08             	add    $0x8,%eax
+    178a:	89 04 24             	mov    %eax,(%esp)
+    178d:	e8 ee fe ff ff       	call   1680 <free>
+  return freep;
+    1792:	8b 15 48 1b 00 00    	mov    0x1b48,%edx
+      if((p = morecore(nunits)) == 0)
+    1798:	85 d2                	test   %edx,%edx
+    179a:	75 b4                	jne    1750 <malloc+0x40>
+        return 0;
+    179c:	31 c0                	xor    %eax,%eax
+    179e:	eb 20                	jmp    17c0 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    17a0:	89 d0                	mov    %edx,%eax
+    17a2:	89 da                	mov    %ebx,%edx
+    17a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    17a8:	39 fe                	cmp    %edi,%esi
+    17aa:	74 1c                	je     17c8 <malloc+0xb8>
+        p->s.size -= nunits;
+    17ac:	29 f7                	sub    %esi,%edi
+    17ae:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    17b1:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    17b4:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    17b7:	89 15 48 1b 00 00    	mov    %edx,0x1b48
+      return (void*)(p + 1);
+    17bd:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    17c0:	83 c4 1c             	add    $0x1c,%esp
+    17c3:	5b                   	pop    %ebx
+    17c4:	5e                   	pop    %esi
+    17c5:	5f                   	pop    %edi
+    17c6:	5d                   	pop    %ebp
+    17c7:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    17c8:	8b 08                	mov    (%eax),%ecx
+    17ca:	89 0a                	mov    %ecx,(%edx)
+    17cc:	eb e9                	jmp    17b7 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    17ce:	c7 05 48 1b 00 00 4c 	movl   $0x1b4c,0x1b48
+    17d5:	1b 00 00 
+    base.s.size = 0;
+    17d8:	ba 4c 1b 00 00       	mov    $0x1b4c,%edx
+    base.s.ptr = freep = prevp = &base;
+    17dd:	c7 05 4c 1b 00 00 4c 	movl   $0x1b4c,0x1b4c
+    17e4:	1b 00 00 
+    base.s.size = 0;
+    17e7:	c7 05 50 1b 00 00 00 	movl   $0x0,0x1b50
+    17ee:	00 00 00 
+    17f1:	e9 46 ff ff ff       	jmp    173c <malloc+0x2c>
+    17f6:	66 90                	xchg   %ax,%ax
+    17f8:	66 90                	xchg   %ax,%ax
+    17fa:	66 90                	xchg   %ax,%ax
+    17fc:	66 90                	xchg   %ax,%ax
+    17fe:	66 90                	xchg   %ax,%ax
+
+00001800 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1800:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1801:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1806:	89 e5                	mov    %esp,%ebp
+    1808:	8b 55 08             	mov    0x8(%ebp),%edx
+    180b:	90                   	nop
+    180c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1810:	89 c8                	mov    %ecx,%eax
+    1812:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1815:	85 c0                	test   %eax,%eax
+    1817:	75 f7                	jne    1810 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1819:	0f ae f0             	mfence 
+}
+    181c:	5d                   	pop    %ebp
+    181d:	c3                   	ret    
+    181e:	66 90                	xchg   %ax,%ax
+
+00001820 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1820:	55                   	push   %ebp
+    1821:	89 e5                	mov    %esp,%ebp
+    1823:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1826:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1829:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    182f:	5d                   	pop    %ebp
+    1830:	c3                   	ret    
diff --git a/init.c b/init.c
index bc6547f..046b551 100644
--- a/init.c
+++ b/init.c
@@ -24,14 +24,14 @@ main(void)
     pid = fork();
     if(pid < 0){
       printf(1, "init: fork failed\n");
-      exit(2);
+      exit();
     }
     if(pid == 0){
       exec("sh", argv);
       printf(1, "init: exec sh failed\n");
-      exit(1);
+      exit();
     }
-    while((wpid=wait(NULL)) >= 0 && wpid != pid)
+    while((wpid=wait()) >= 0 && wpid != pid)
       printf(1, "zombie!\n");
   }
 }
diff --git a/init.d b/init.d
new file mode 100644
index 0000000..ee304c8
--- /dev/null
+++ b/init.d
@@ -0,0 +1 @@
+init.o: init.c /usr/include/stdc-predef.h types.h stat.h user.h fcntl.h
diff --git a/init.o b/init.o
new file mode 100644
index 0000000..6771c67
Binary files /dev/null and b/init.o differ
diff --git a/init.sym b/init.sym
new file mode 100644
index 0000000..13cf85e
--- /dev/null
+++ b/init.sym
@@ -0,0 +1,64 @@
+00001000 .text
+00001831 .rodata
+0000189c .eh_frame
+00001b40 .data
+00001b48 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 init.c
+00000000 ulib.c
+00000000 printf.c
+000013f0 printint
+00001888 digits.1359
+00000000 umalloc.c
+00001b48 freep
+00001b4c base
+00000000 uspinlock.c
+00001110 strcpy
+00001490 printf
+00001b40 argv
+00001300 memmove
+0000137a mknod
+000013d2 shm_open
+00001220 gets
+000013b2 getpid
+00001710 malloc
+000013c2 sleep
+00001342 pipe
+00001352 write
+0000138a fstat
+00001362 kill
+000013a2 chdir
+0000136a exec
+0000133a wait
+0000134a read
+00001382 unlink
+00001800 uacquire
+0000132a fork
+000013ba sbrk
+000013da shm_close
+000013ca uptime
+00001b48 __bss_start
+000011c0 memset
+00001000 main
+00001140 strcmp
+000013aa dup
+00001280 stat
+00001b48 _edata
+00001b54 _end
+00001392 link
+00001332 exit
+000012d0 atoi
+00001190 strlen
+00001372 open
+000011e0 strchr
+0000139a mkdir
+0000135a close
+00001820 urelease
+00001680 free
diff --git a/initcode b/initcode
new file mode 100644
index 0000000..773d26c
Binary files /dev/null and b/initcode differ
diff --git a/initcode.asm b/initcode.asm
new file mode 100644
index 0000000..3d5dae2
--- /dev/null
+++ b/initcode.asm
@@ -0,0 +1,43 @@
+
+initcode.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <start>:
+
+
+# exec(init, argv)
+.globl start
+start:
+  pushl $argv
+   0:	68 24 00 00 00       	push   $0x24
+  pushl $init
+   5:	68 1c 00 00 00       	push   $0x1c
+  pushl $0  // where caller pc would be
+   a:	6a 00                	push   $0x0
+  movl $SYS_exec, %eax
+   c:	b8 07 00 00 00       	mov    $0x7,%eax
+  int $T_SYSCALL
+  11:	cd 40                	int    $0x40
+
+00000013 <exit>:
+
+# for(;;) exit();
+exit:
+  movl $SYS_exit, %eax
+  13:	b8 02 00 00 00       	mov    $0x2,%eax
+  int $T_SYSCALL
+  18:	cd 40                	int    $0x40
+  jmp exit
+  1a:	eb f7                	jmp    13 <exit>
+
+0000001c <init>:
+  1c:	2f                   	das    
+  1d:	69 6e 69 74 00 00 90 	imul   $0x90000074,0x69(%esi),%ebp
+
+00000024 <argv>:
+  24:	1c 00                	sbb    $0x0,%al
+  26:	00 00                	add    %al,(%eax)
+  28:	00 00                	add    %al,(%eax)
+	...
diff --git a/initcode.d b/initcode.d
new file mode 100644
index 0000000..ab1af4d
--- /dev/null
+++ b/initcode.d
@@ -0,0 +1 @@
+initcode.o: initcode.S syscall.h traps.h
diff --git a/initcode.o b/initcode.o
new file mode 100644
index 0000000..4cae5c8
Binary files /dev/null and b/initcode.o differ
diff --git a/initcode.out b/initcode.out
new file mode 100644
index 0000000..78dea88
Binary files /dev/null and b/initcode.out differ
diff --git a/ioapic.d b/ioapic.d
new file mode 100644
index 0000000..997e68a
--- /dev/null
+++ b/ioapic.d
@@ -0,0 +1 @@
+ioapic.o: ioapic.c /usr/include/stdc-predef.h types.h defs.h traps.h
diff --git a/ioapic.o b/ioapic.o
new file mode 100644
index 0000000..1946c49
Binary files /dev/null and b/ioapic.o differ
diff --git a/kalloc.d b/kalloc.d
new file mode 100644
index 0000000..512c5db
--- /dev/null
+++ b/kalloc.d
@@ -0,0 +1,2 @@
+kalloc.o: kalloc.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h spinlock.h
diff --git a/kalloc.o b/kalloc.o
new file mode 100644
index 0000000..8e48885
Binary files /dev/null and b/kalloc.o differ
diff --git a/kbd.d b/kbd.d
new file mode 100644
index 0000000..92532ba
--- /dev/null
+++ b/kbd.d
@@ -0,0 +1 @@
+kbd.o: kbd.c /usr/include/stdc-predef.h types.h x86.h defs.h kbd.h
diff --git a/kbd.o b/kbd.o
new file mode 100644
index 0000000..c7e5245
Binary files /dev/null and b/kbd.o differ
diff --git a/kernel b/kernel
new file mode 100644
index 0000000..73a6592
Binary files /dev/null and b/kernel differ
diff --git a/kernel.asm b/kernel.asm
new file mode 100644
index 0000000..16ad337
--- /dev/null
+++ b/kernel.asm
@@ -0,0 +1,14907 @@
+
+kernel:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+80100000 <multiboot_header>:
+80100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
+80100006:	00 00                	add    %al,(%eax)
+80100008:	fe 4f 52             	decb   0x52(%edi)
+8010000b:	e4                   	.byte 0xe4
+
+8010000c <entry>:
+
+# Entering xv6 on boot processor, with paging off.
+.globl entry
+entry:
+  # Turn on page size extension for 4Mbyte pages
+  movl    %cr4, %eax
+8010000c:	0f 20 e0             	mov    %cr4,%eax
+  orl     $(CR4_PSE), %eax
+8010000f:	83 c8 10             	or     $0x10,%eax
+  movl    %eax, %cr4
+80100012:	0f 22 e0             	mov    %eax,%cr4
+  # Set page directory
+  movl    $(V2P_WO(entrypgdir)), %eax
+80100015:	b8 00 90 10 00       	mov    $0x109000,%eax
+  movl    %eax, %cr3
+8010001a:	0f 22 d8             	mov    %eax,%cr3
+  # Turn on paging.
+  movl    %cr0, %eax
+8010001d:	0f 20 c0             	mov    %cr0,%eax
+  orl     $(CR0_PG|CR0_WP), %eax
+80100020:	0d 00 00 01 80       	or     $0x80010000,%eax
+  movl    %eax, %cr0
+80100025:	0f 22 c0             	mov    %eax,%cr0
+
+  # Set up the stack pointer.
+  movl $(stack + KSTACKSIZE), %esp
+80100028:	bc c0 b5 10 80       	mov    $0x8010b5c0,%esp
+
+  # Jump to main(), and switch to executing at
+  # high addresses. The indirect call is needed because
+  # the assembler produces a PC-relative instruction
+  # for a direct jump.
+  mov $main, %eax
+8010002d:	b8 00 2e 10 80       	mov    $0x80102e00,%eax
+  jmp *%eax
+80100032:	ff e0                	jmp    *%eax
+80100034:	66 90                	xchg   %ax,%ax
+80100036:	66 90                	xchg   %ax,%ax
+80100038:	66 90                	xchg   %ax,%ax
+8010003a:	66 90                	xchg   %ax,%ax
+8010003c:	66 90                	xchg   %ax,%ax
+8010003e:	66 90                	xchg   %ax,%ax
+
+80100040 <binit>:
+  struct buf head;
+} bcache;
+
+void
+binit(void)
+{
+80100040:	55                   	push   %ebp
+80100041:	89 e5                	mov    %esp,%ebp
+80100043:	53                   	push   %ebx
+
+//PAGEBREAK!
+  // Create linked list of buffers
+  bcache.head.prev = &bcache.head;
+  bcache.head.next = &bcache.head;
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+80100044:	bb f4 b5 10 80       	mov    $0x8010b5f4,%ebx
+{
+80100049:	83 ec 14             	sub    $0x14,%esp
+  initlock(&bcache.lock, "bcache");
+8010004c:	c7 44 24 04 20 6d 10 	movl   $0x80106d20,0x4(%esp)
+80100053:	80 
+80100054:	c7 04 24 c0 b5 10 80 	movl   $0x8010b5c0,(%esp)
+8010005b:	e8 00 40 00 00       	call   80104060 <initlock>
+  bcache.head.next = &bcache.head;
+80100060:	ba bc fc 10 80       	mov    $0x8010fcbc,%edx
+  bcache.head.prev = &bcache.head;
+80100065:	c7 05 0c fd 10 80 bc 	movl   $0x8010fcbc,0x8010fd0c
+8010006c:	fc 10 80 
+  bcache.head.next = &bcache.head;
+8010006f:	c7 05 10 fd 10 80 bc 	movl   $0x8010fcbc,0x8010fd10
+80100076:	fc 10 80 
+80100079:	eb 09                	jmp    80100084 <binit+0x44>
+8010007b:	90                   	nop
+8010007c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80100080:	89 da                	mov    %ebx,%edx
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+80100082:	89 c3                	mov    %eax,%ebx
+80100084:	8d 43 0c             	lea    0xc(%ebx),%eax
+    b->next = bcache.head.next;
+80100087:	89 53 54             	mov    %edx,0x54(%ebx)
+    b->prev = &bcache.head;
+8010008a:	c7 43 50 bc fc 10 80 	movl   $0x8010fcbc,0x50(%ebx)
+    initsleeplock(&b->lock, "buffer");
+80100091:	89 04 24             	mov    %eax,(%esp)
+80100094:	c7 44 24 04 27 6d 10 	movl   $0x80106d27,0x4(%esp)
+8010009b:	80 
+8010009c:	e8 af 3e 00 00       	call   80103f50 <initsleeplock>
+    bcache.head.next->prev = b;
+801000a1:	a1 10 fd 10 80       	mov    0x8010fd10,%eax
+801000a6:	89 58 50             	mov    %ebx,0x50(%eax)
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+801000a9:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
+801000af:	3d bc fc 10 80       	cmp    $0x8010fcbc,%eax
+    bcache.head.next = b;
+801000b4:	89 1d 10 fd 10 80    	mov    %ebx,0x8010fd10
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+801000ba:	75 c4                	jne    80100080 <binit+0x40>
+  }
+}
+801000bc:	83 c4 14             	add    $0x14,%esp
+801000bf:	5b                   	pop    %ebx
+801000c0:	5d                   	pop    %ebp
+801000c1:	c3                   	ret    
+801000c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801000c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801000d0 <bread>:
+}
+
+// Return a locked buf with the contents of the indicated block.
+struct buf*
+bread(uint dev, uint blockno)
+{
+801000d0:	55                   	push   %ebp
+801000d1:	89 e5                	mov    %esp,%ebp
+801000d3:	57                   	push   %edi
+801000d4:	56                   	push   %esi
+801000d5:	53                   	push   %ebx
+801000d6:	83 ec 1c             	sub    $0x1c,%esp
+801000d9:	8b 75 08             	mov    0x8(%ebp),%esi
+  acquire(&bcache.lock);
+801000dc:	c7 04 24 c0 b5 10 80 	movl   $0x8010b5c0,(%esp)
+{
+801000e3:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  acquire(&bcache.lock);
+801000e6:	e8 65 40 00 00       	call   80104150 <acquire>
+  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+801000eb:	8b 1d 10 fd 10 80    	mov    0x8010fd10,%ebx
+801000f1:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
+801000f7:	75 12                	jne    8010010b <bread+0x3b>
+801000f9:	eb 25                	jmp    80100120 <bread+0x50>
+801000fb:	90                   	nop
+801000fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80100100:	8b 5b 54             	mov    0x54(%ebx),%ebx
+80100103:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
+80100109:	74 15                	je     80100120 <bread+0x50>
+    if(b->dev == dev && b->blockno == blockno){
+8010010b:	3b 73 04             	cmp    0x4(%ebx),%esi
+8010010e:	75 f0                	jne    80100100 <bread+0x30>
+80100110:	3b 7b 08             	cmp    0x8(%ebx),%edi
+80100113:	75 eb                	jne    80100100 <bread+0x30>
+      b->refcnt++;
+80100115:	83 43 4c 01          	addl   $0x1,0x4c(%ebx)
+80100119:	eb 3f                	jmp    8010015a <bread+0x8a>
+8010011b:	90                   	nop
+8010011c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+80100120:	8b 1d 0c fd 10 80    	mov    0x8010fd0c,%ebx
+80100126:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
+8010012c:	75 0d                	jne    8010013b <bread+0x6b>
+8010012e:	eb 58                	jmp    80100188 <bread+0xb8>
+80100130:	8b 5b 50             	mov    0x50(%ebx),%ebx
+80100133:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
+80100139:	74 4d                	je     80100188 <bread+0xb8>
+    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
+8010013b:	8b 43 4c             	mov    0x4c(%ebx),%eax
+8010013e:	85 c0                	test   %eax,%eax
+80100140:	75 ee                	jne    80100130 <bread+0x60>
+80100142:	f6 03 04             	testb  $0x4,(%ebx)
+80100145:	75 e9                	jne    80100130 <bread+0x60>
+      b->dev = dev;
+80100147:	89 73 04             	mov    %esi,0x4(%ebx)
+      b->blockno = blockno;
+8010014a:	89 7b 08             	mov    %edi,0x8(%ebx)
+      b->flags = 0;
+8010014d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+      b->refcnt = 1;
+80100153:	c7 43 4c 01 00 00 00 	movl   $0x1,0x4c(%ebx)
+      release(&bcache.lock);
+8010015a:	c7 04 24 c0 b5 10 80 	movl   $0x8010b5c0,(%esp)
+80100161:	e8 da 40 00 00       	call   80104240 <release>
+      acquiresleep(&b->lock);
+80100166:	8d 43 0c             	lea    0xc(%ebx),%eax
+80100169:	89 04 24             	mov    %eax,(%esp)
+8010016c:	e8 1f 3e 00 00       	call   80103f90 <acquiresleep>
+  struct buf *b;
+
+  b = bget(dev, blockno);
+  if((b->flags & B_VALID) == 0) {
+80100171:	f6 03 02             	testb  $0x2,(%ebx)
+80100174:	75 08                	jne    8010017e <bread+0xae>
+    iderw(b);
+80100176:	89 1c 24             	mov    %ebx,(%esp)
+80100179:	e8 b2 1f 00 00       	call   80102130 <iderw>
+  }
+  return b;
+}
+8010017e:	83 c4 1c             	add    $0x1c,%esp
+80100181:	89 d8                	mov    %ebx,%eax
+80100183:	5b                   	pop    %ebx
+80100184:	5e                   	pop    %esi
+80100185:	5f                   	pop    %edi
+80100186:	5d                   	pop    %ebp
+80100187:	c3                   	ret    
+  panic("bget: no buffers");
+80100188:	c7 04 24 2e 6d 10 80 	movl   $0x80106d2e,(%esp)
+8010018f:	e8 cc 01 00 00       	call   80100360 <panic>
+80100194:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+8010019a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+801001a0 <bwrite>:
+
+// Write b's contents to disk.  Must be locked.
+void
+bwrite(struct buf *b)
+{
+801001a0:	55                   	push   %ebp
+801001a1:	89 e5                	mov    %esp,%ebp
+801001a3:	53                   	push   %ebx
+801001a4:	83 ec 14             	sub    $0x14,%esp
+801001a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(!holdingsleep(&b->lock))
+801001aa:	8d 43 0c             	lea    0xc(%ebx),%eax
+801001ad:	89 04 24             	mov    %eax,(%esp)
+801001b0:	e8 7b 3e 00 00       	call   80104030 <holdingsleep>
+801001b5:	85 c0                	test   %eax,%eax
+801001b7:	74 10                	je     801001c9 <bwrite+0x29>
+    panic("bwrite");
+  b->flags |= B_DIRTY;
+801001b9:	83 0b 04             	orl    $0x4,(%ebx)
+  iderw(b);
+801001bc:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+801001bf:	83 c4 14             	add    $0x14,%esp
+801001c2:	5b                   	pop    %ebx
+801001c3:	5d                   	pop    %ebp
+  iderw(b);
+801001c4:	e9 67 1f 00 00       	jmp    80102130 <iderw>
+    panic("bwrite");
+801001c9:	c7 04 24 3f 6d 10 80 	movl   $0x80106d3f,(%esp)
+801001d0:	e8 8b 01 00 00       	call   80100360 <panic>
+801001d5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801001d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801001e0 <brelse>:
+
+// Release a locked buffer.
+// Move to the head of the MRU list.
+void
+brelse(struct buf *b)
+{
+801001e0:	55                   	push   %ebp
+801001e1:	89 e5                	mov    %esp,%ebp
+801001e3:	56                   	push   %esi
+801001e4:	53                   	push   %ebx
+801001e5:	83 ec 10             	sub    $0x10,%esp
+801001e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(!holdingsleep(&b->lock))
+801001eb:	8d 73 0c             	lea    0xc(%ebx),%esi
+801001ee:	89 34 24             	mov    %esi,(%esp)
+801001f1:	e8 3a 3e 00 00       	call   80104030 <holdingsleep>
+801001f6:	85 c0                	test   %eax,%eax
+801001f8:	74 5b                	je     80100255 <brelse+0x75>
+    panic("brelse");
+
+  releasesleep(&b->lock);
+801001fa:	89 34 24             	mov    %esi,(%esp)
+801001fd:	e8 ee 3d 00 00       	call   80103ff0 <releasesleep>
+
+  acquire(&bcache.lock);
+80100202:	c7 04 24 c0 b5 10 80 	movl   $0x8010b5c0,(%esp)
+80100209:	e8 42 3f 00 00       	call   80104150 <acquire>
+  b->refcnt--;
+  if (b->refcnt == 0) {
+8010020e:	83 6b 4c 01          	subl   $0x1,0x4c(%ebx)
+80100212:	75 2f                	jne    80100243 <brelse+0x63>
+    // no one is waiting for it.
+    b->next->prev = b->prev;
+80100214:	8b 43 54             	mov    0x54(%ebx),%eax
+80100217:	8b 53 50             	mov    0x50(%ebx),%edx
+8010021a:	89 50 50             	mov    %edx,0x50(%eax)
+    b->prev->next = b->next;
+8010021d:	8b 43 50             	mov    0x50(%ebx),%eax
+80100220:	8b 53 54             	mov    0x54(%ebx),%edx
+80100223:	89 50 54             	mov    %edx,0x54(%eax)
+    b->next = bcache.head.next;
+80100226:	a1 10 fd 10 80       	mov    0x8010fd10,%eax
+    b->prev = &bcache.head;
+8010022b:	c7 43 50 bc fc 10 80 	movl   $0x8010fcbc,0x50(%ebx)
+    b->next = bcache.head.next;
+80100232:	89 43 54             	mov    %eax,0x54(%ebx)
+    bcache.head.next->prev = b;
+80100235:	a1 10 fd 10 80       	mov    0x8010fd10,%eax
+8010023a:	89 58 50             	mov    %ebx,0x50(%eax)
+    bcache.head.next = b;
+8010023d:	89 1d 10 fd 10 80    	mov    %ebx,0x8010fd10
+  }
+  
+  release(&bcache.lock);
+80100243:	c7 45 08 c0 b5 10 80 	movl   $0x8010b5c0,0x8(%ebp)
+}
+8010024a:	83 c4 10             	add    $0x10,%esp
+8010024d:	5b                   	pop    %ebx
+8010024e:	5e                   	pop    %esi
+8010024f:	5d                   	pop    %ebp
+  release(&bcache.lock);
+80100250:	e9 eb 3f 00 00       	jmp    80104240 <release>
+    panic("brelse");
+80100255:	c7 04 24 46 6d 10 80 	movl   $0x80106d46,(%esp)
+8010025c:	e8 ff 00 00 00       	call   80100360 <panic>
+80100261:	66 90                	xchg   %ax,%ax
+80100263:	66 90                	xchg   %ax,%ax
+80100265:	66 90                	xchg   %ax,%ax
+80100267:	66 90                	xchg   %ax,%ax
+80100269:	66 90                	xchg   %ax,%ax
+8010026b:	66 90                	xchg   %ax,%ax
+8010026d:	66 90                	xchg   %ax,%ax
+8010026f:	90                   	nop
+
+80100270 <consoleread>:
+  }
+}
+
+int
+consoleread(struct inode *ip, char *dst, int n)
+{
+80100270:	55                   	push   %ebp
+80100271:	89 e5                	mov    %esp,%ebp
+80100273:	57                   	push   %edi
+80100274:	56                   	push   %esi
+80100275:	53                   	push   %ebx
+80100276:	83 ec 1c             	sub    $0x1c,%esp
+80100279:	8b 7d 08             	mov    0x8(%ebp),%edi
+8010027c:	8b 75 0c             	mov    0xc(%ebp),%esi
+  uint target;
+  int c;
+
+  iunlock(ip);
+8010027f:	89 3c 24             	mov    %edi,(%esp)
+80100282:	e8 19 15 00 00       	call   801017a0 <iunlock>
+  target = n;
+  acquire(&cons.lock);
+80100287:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+8010028e:	e8 bd 3e 00 00       	call   80104150 <acquire>
+  while(n > 0){
+80100293:	8b 55 10             	mov    0x10(%ebp),%edx
+80100296:	85 d2                	test   %edx,%edx
+80100298:	0f 8e bc 00 00 00    	jle    8010035a <consoleread+0xea>
+8010029e:	8b 5d 10             	mov    0x10(%ebp),%ebx
+801002a1:	eb 25                	jmp    801002c8 <consoleread+0x58>
+801002a3:	90                   	nop
+801002a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    while(input.r == input.w){
+      if(myproc()->killed){
+801002a8:	e8 03 34 00 00       	call   801036b0 <myproc>
+801002ad:	8b 40 24             	mov    0x24(%eax),%eax
+801002b0:	85 c0                	test   %eax,%eax
+801002b2:	75 74                	jne    80100328 <consoleread+0xb8>
+        release(&cons.lock);
+        ilock(ip);
+        return -1;
+      }
+      sleep(&input.r, &cons.lock);
+801002b4:	c7 44 24 04 20 a5 10 	movl   $0x8010a520,0x4(%esp)
+801002bb:	80 
+801002bc:	c7 04 24 a0 ff 10 80 	movl   $0x8010ffa0,(%esp)
+801002c3:	e8 48 39 00 00       	call   80103c10 <sleep>
+    while(input.r == input.w){
+801002c8:	a1 a0 ff 10 80       	mov    0x8010ffa0,%eax
+801002cd:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
+801002d3:	74 d3                	je     801002a8 <consoleread+0x38>
+    }
+    c = input.buf[input.r++ % INPUT_BUF];
+801002d5:	8d 50 01             	lea    0x1(%eax),%edx
+801002d8:	89 15 a0 ff 10 80    	mov    %edx,0x8010ffa0
+801002de:	89 c2                	mov    %eax,%edx
+801002e0:	83 e2 7f             	and    $0x7f,%edx
+801002e3:	0f b6 8a 20 ff 10 80 	movzbl -0x7fef00e0(%edx),%ecx
+801002ea:	0f be d1             	movsbl %cl,%edx
+    if(c == C('D')){  // EOF
+801002ed:	83 fa 04             	cmp    $0x4,%edx
+801002f0:	74 57                	je     80100349 <consoleread+0xd9>
+        // caller gets a 0-byte result.
+        input.r--;
+      }
+      break;
+    }
+    *dst++ = c;
+801002f2:	83 c6 01             	add    $0x1,%esi
+    --n;
+801002f5:	83 eb 01             	sub    $0x1,%ebx
+    if(c == '\n')
+801002f8:	83 fa 0a             	cmp    $0xa,%edx
+    *dst++ = c;
+801002fb:	88 4e ff             	mov    %cl,-0x1(%esi)
+    if(c == '\n')
+801002fe:	74 53                	je     80100353 <consoleread+0xe3>
+  while(n > 0){
+80100300:	85 db                	test   %ebx,%ebx
+80100302:	75 c4                	jne    801002c8 <consoleread+0x58>
+80100304:	8b 45 10             	mov    0x10(%ebp),%eax
+      break;
+  }
+  release(&cons.lock);
+80100307:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+8010030e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80100311:	e8 2a 3f 00 00       	call   80104240 <release>
+  ilock(ip);
+80100316:	89 3c 24             	mov    %edi,(%esp)
+80100319:	e8 a2 13 00 00       	call   801016c0 <ilock>
+8010031e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+
+  return target - n;
+80100321:	eb 1e                	jmp    80100341 <consoleread+0xd1>
+80100323:	90                   	nop
+80100324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        release(&cons.lock);
+80100328:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+8010032f:	e8 0c 3f 00 00       	call   80104240 <release>
+        ilock(ip);
+80100334:	89 3c 24             	mov    %edi,(%esp)
+80100337:	e8 84 13 00 00       	call   801016c0 <ilock>
+        return -1;
+8010033c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80100341:	83 c4 1c             	add    $0x1c,%esp
+80100344:	5b                   	pop    %ebx
+80100345:	5e                   	pop    %esi
+80100346:	5f                   	pop    %edi
+80100347:	5d                   	pop    %ebp
+80100348:	c3                   	ret    
+      if(n < target){
+80100349:	39 5d 10             	cmp    %ebx,0x10(%ebp)
+8010034c:	76 05                	jbe    80100353 <consoleread+0xe3>
+        input.r--;
+8010034e:	a3 a0 ff 10 80       	mov    %eax,0x8010ffa0
+80100353:	8b 45 10             	mov    0x10(%ebp),%eax
+80100356:	29 d8                	sub    %ebx,%eax
+80100358:	eb ad                	jmp    80100307 <consoleread+0x97>
+  while(n > 0){
+8010035a:	31 c0                	xor    %eax,%eax
+8010035c:	eb a9                	jmp    80100307 <consoleread+0x97>
+8010035e:	66 90                	xchg   %ax,%ax
+
+80100360 <panic>:
+{
+80100360:	55                   	push   %ebp
+80100361:	89 e5                	mov    %esp,%ebp
+80100363:	56                   	push   %esi
+80100364:	53                   	push   %ebx
+80100365:	83 ec 40             	sub    $0x40,%esp
+}
+
+static inline void
+cli(void)
+{
+  asm volatile("cli");
+80100368:	fa                   	cli    
+  cons.locking = 0;
+80100369:	c7 05 54 a5 10 80 00 	movl   $0x0,0x8010a554
+80100370:	00 00 00 
+  getcallerpcs(&s, pcs);
+80100373:	8d 5d d0             	lea    -0x30(%ebp),%ebx
+  cprintf("lapicid %d: panic: ", lapicid());
+80100376:	e8 f5 23 00 00       	call   80102770 <lapicid>
+8010037b:	8d 75 f8             	lea    -0x8(%ebp),%esi
+8010037e:	c7 04 24 4d 6d 10 80 	movl   $0x80106d4d,(%esp)
+80100385:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100389:	e8 c2 02 00 00       	call   80100650 <cprintf>
+  cprintf(s);
+8010038e:	8b 45 08             	mov    0x8(%ebp),%eax
+80100391:	89 04 24             	mov    %eax,(%esp)
+80100394:	e8 b7 02 00 00       	call   80100650 <cprintf>
+  cprintf("\n");
+80100399:	c7 04 24 9f 76 10 80 	movl   $0x8010769f,(%esp)
+801003a0:	e8 ab 02 00 00       	call   80100650 <cprintf>
+  getcallerpcs(&s, pcs);
+801003a5:	8d 45 08             	lea    0x8(%ebp),%eax
+801003a8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+801003ac:	89 04 24             	mov    %eax,(%esp)
+801003af:	e8 cc 3c 00 00       	call   80104080 <getcallerpcs>
+801003b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    cprintf(" %p", pcs[i]);
+801003b8:	8b 03                	mov    (%ebx),%eax
+801003ba:	83 c3 04             	add    $0x4,%ebx
+801003bd:	c7 04 24 61 6d 10 80 	movl   $0x80106d61,(%esp)
+801003c4:	89 44 24 04          	mov    %eax,0x4(%esp)
+801003c8:	e8 83 02 00 00       	call   80100650 <cprintf>
+  for(i=0; i<10; i++)
+801003cd:	39 f3                	cmp    %esi,%ebx
+801003cf:	75 e7                	jne    801003b8 <panic+0x58>
+  panicked = 1; // freeze other CPU
+801003d1:	c7 05 58 a5 10 80 01 	movl   $0x1,0x8010a558
+801003d8:	00 00 00 
+801003db:	eb fe                	jmp    801003db <panic+0x7b>
+801003dd:	8d 76 00             	lea    0x0(%esi),%esi
+
+801003e0 <consputc>:
+  if(panicked){
+801003e0:	8b 15 58 a5 10 80    	mov    0x8010a558,%edx
+801003e6:	85 d2                	test   %edx,%edx
+801003e8:	74 06                	je     801003f0 <consputc+0x10>
+801003ea:	fa                   	cli    
+801003eb:	eb fe                	jmp    801003eb <consputc+0xb>
+801003ed:	8d 76 00             	lea    0x0(%esi),%esi
+{
+801003f0:	55                   	push   %ebp
+801003f1:	89 e5                	mov    %esp,%ebp
+801003f3:	57                   	push   %edi
+801003f4:	56                   	push   %esi
+801003f5:	53                   	push   %ebx
+801003f6:	89 c3                	mov    %eax,%ebx
+801003f8:	83 ec 1c             	sub    $0x1c,%esp
+  if(c == BACKSPACE){
+801003fb:	3d 00 01 00 00       	cmp    $0x100,%eax
+80100400:	0f 84 ac 00 00 00    	je     801004b2 <consputc+0xd2>
+    uartputc(c);
+80100406:	89 04 24             	mov    %eax,(%esp)
+80100409:	e8 d2 53 00 00       	call   801057e0 <uartputc>
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+8010040e:	bf d4 03 00 00       	mov    $0x3d4,%edi
+80100413:	b8 0e 00 00 00       	mov    $0xe,%eax
+80100418:	89 fa                	mov    %edi,%edx
+8010041a:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+8010041b:	be d5 03 00 00       	mov    $0x3d5,%esi
+80100420:	89 f2                	mov    %esi,%edx
+80100422:	ec                   	in     (%dx),%al
+  pos = inb(CRTPORT+1) << 8;
+80100423:	0f b6 c8             	movzbl %al,%ecx
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80100426:	89 fa                	mov    %edi,%edx
+80100428:	c1 e1 08             	shl    $0x8,%ecx
+8010042b:	b8 0f 00 00 00       	mov    $0xf,%eax
+80100430:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80100431:	89 f2                	mov    %esi,%edx
+80100433:	ec                   	in     (%dx),%al
+  pos |= inb(CRTPORT+1);
+80100434:	0f b6 c0             	movzbl %al,%eax
+80100437:	09 c1                	or     %eax,%ecx
+  if(c == '\n')
+80100439:	83 fb 0a             	cmp    $0xa,%ebx
+8010043c:	0f 84 0d 01 00 00    	je     8010054f <consputc+0x16f>
+  else if(c == BACKSPACE){
+80100442:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
+80100448:	0f 84 e8 00 00 00    	je     80100536 <consputc+0x156>
+    crt[pos++] = (c&0xff) | 0x0700;  // black on white
+8010044e:	0f b6 db             	movzbl %bl,%ebx
+80100451:	80 cf 07             	or     $0x7,%bh
+80100454:	8d 79 01             	lea    0x1(%ecx),%edi
+80100457:	66 89 9c 09 00 80 0b 	mov    %bx,-0x7ff48000(%ecx,%ecx,1)
+8010045e:	80 
+  if(pos < 0 || pos > 25*80)
+8010045f:	81 ff d0 07 00 00    	cmp    $0x7d0,%edi
+80100465:	0f 87 bf 00 00 00    	ja     8010052a <consputc+0x14a>
+  if((pos/80) >= 24){  // Scroll up.
+8010046b:	81 ff 7f 07 00 00    	cmp    $0x77f,%edi
+80100471:	7f 68                	jg     801004db <consputc+0xfb>
+80100473:	89 f8                	mov    %edi,%eax
+80100475:	89 fb                	mov    %edi,%ebx
+80100477:	c1 e8 08             	shr    $0x8,%eax
+8010047a:	89 c6                	mov    %eax,%esi
+8010047c:	8d 8c 3f 00 80 0b 80 	lea    -0x7ff48000(%edi,%edi,1),%ecx
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80100483:	bf d4 03 00 00       	mov    $0x3d4,%edi
+80100488:	b8 0e 00 00 00       	mov    $0xe,%eax
+8010048d:	89 fa                	mov    %edi,%edx
+8010048f:	ee                   	out    %al,(%dx)
+80100490:	89 f0                	mov    %esi,%eax
+80100492:	b2 d5                	mov    $0xd5,%dl
+80100494:	ee                   	out    %al,(%dx)
+80100495:	b8 0f 00 00 00       	mov    $0xf,%eax
+8010049a:	89 fa                	mov    %edi,%edx
+8010049c:	ee                   	out    %al,(%dx)
+8010049d:	89 d8                	mov    %ebx,%eax
+8010049f:	b2 d5                	mov    $0xd5,%dl
+801004a1:	ee                   	out    %al,(%dx)
+  crt[pos] = ' ' | 0x0700;
+801004a2:	b8 20 07 00 00       	mov    $0x720,%eax
+801004a7:	66 89 01             	mov    %ax,(%ecx)
+}
+801004aa:	83 c4 1c             	add    $0x1c,%esp
+801004ad:	5b                   	pop    %ebx
+801004ae:	5e                   	pop    %esi
+801004af:	5f                   	pop    %edi
+801004b0:	5d                   	pop    %ebp
+801004b1:	c3                   	ret    
+    uartputc('\b'); uartputc(' '); uartputc('\b');
+801004b2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+801004b9:	e8 22 53 00 00       	call   801057e0 <uartputc>
+801004be:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+801004c5:	e8 16 53 00 00       	call   801057e0 <uartputc>
+801004ca:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+801004d1:	e8 0a 53 00 00       	call   801057e0 <uartputc>
+801004d6:	e9 33 ff ff ff       	jmp    8010040e <consputc+0x2e>
+    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+801004db:	c7 44 24 08 60 0e 00 	movl   $0xe60,0x8(%esp)
+801004e2:	00 
+    pos -= 80;
+801004e3:	8d 5f b0             	lea    -0x50(%edi),%ebx
+    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+801004e6:	c7 44 24 04 a0 80 0b 	movl   $0x800b80a0,0x4(%esp)
+801004ed:	80 
+    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+801004ee:	8d b4 1b 00 80 0b 80 	lea    -0x7ff48000(%ebx,%ebx,1),%esi
+    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+801004f5:	c7 04 24 00 80 0b 80 	movl   $0x800b8000,(%esp)
+801004fc:	e8 2f 3e 00 00       	call   80104330 <memmove>
+    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+80100501:	b8 d0 07 00 00       	mov    $0x7d0,%eax
+80100506:	29 f8                	sub    %edi,%eax
+80100508:	01 c0                	add    %eax,%eax
+8010050a:	89 34 24             	mov    %esi,(%esp)
+8010050d:	89 44 24 08          	mov    %eax,0x8(%esp)
+80100511:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80100518:	00 
+80100519:	e8 72 3d 00 00       	call   80104290 <memset>
+8010051e:	89 f1                	mov    %esi,%ecx
+80100520:	be 07 00 00 00       	mov    $0x7,%esi
+80100525:	e9 59 ff ff ff       	jmp    80100483 <consputc+0xa3>
+    panic("pos under/overflow");
+8010052a:	c7 04 24 65 6d 10 80 	movl   $0x80106d65,(%esp)
+80100531:	e8 2a fe ff ff       	call   80100360 <panic>
+    if(pos > 0) --pos;
+80100536:	85 c9                	test   %ecx,%ecx
+80100538:	8d 79 ff             	lea    -0x1(%ecx),%edi
+8010053b:	0f 85 1e ff ff ff    	jne    8010045f <consputc+0x7f>
+80100541:	b9 00 80 0b 80       	mov    $0x800b8000,%ecx
+80100546:	31 db                	xor    %ebx,%ebx
+80100548:	31 f6                	xor    %esi,%esi
+8010054a:	e9 34 ff ff ff       	jmp    80100483 <consputc+0xa3>
+    pos += 80 - pos%80;
+8010054f:	89 c8                	mov    %ecx,%eax
+80100551:	ba 67 66 66 66       	mov    $0x66666667,%edx
+80100556:	f7 ea                	imul   %edx
+80100558:	c1 ea 05             	shr    $0x5,%edx
+8010055b:	8d 04 92             	lea    (%edx,%edx,4),%eax
+8010055e:	c1 e0 04             	shl    $0x4,%eax
+80100561:	8d 78 50             	lea    0x50(%eax),%edi
+80100564:	e9 f6 fe ff ff       	jmp    8010045f <consputc+0x7f>
+80100569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80100570 <printint>:
+{
+80100570:	55                   	push   %ebp
+80100571:	89 e5                	mov    %esp,%ebp
+80100573:	57                   	push   %edi
+80100574:	56                   	push   %esi
+80100575:	89 d6                	mov    %edx,%esi
+80100577:	53                   	push   %ebx
+80100578:	83 ec 1c             	sub    $0x1c,%esp
+  if(sign && (sign = xx < 0))
+8010057b:	85 c9                	test   %ecx,%ecx
+8010057d:	74 61                	je     801005e0 <printint+0x70>
+8010057f:	85 c0                	test   %eax,%eax
+80100581:	79 5d                	jns    801005e0 <printint+0x70>
+    x = -xx;
+80100583:	f7 d8                	neg    %eax
+80100585:	bf 01 00 00 00       	mov    $0x1,%edi
+  i = 0;
+8010058a:	31 c9                	xor    %ecx,%ecx
+8010058c:	eb 04                	jmp    80100592 <printint+0x22>
+8010058e:	66 90                	xchg   %ax,%ax
+    buf[i++] = digits[x % base];
+80100590:	89 d9                	mov    %ebx,%ecx
+80100592:	31 d2                	xor    %edx,%edx
+80100594:	f7 f6                	div    %esi
+80100596:	8d 59 01             	lea    0x1(%ecx),%ebx
+80100599:	0f b6 92 90 6d 10 80 	movzbl -0x7fef9270(%edx),%edx
+  }while((x /= base) != 0);
+801005a0:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+801005a2:	88 54 1d d7          	mov    %dl,-0x29(%ebp,%ebx,1)
+  }while((x /= base) != 0);
+801005a6:	75 e8                	jne    80100590 <printint+0x20>
+  if(sign)
+801005a8:	85 ff                	test   %edi,%edi
+    buf[i++] = digits[x % base];
+801005aa:	89 d8                	mov    %ebx,%eax
+  if(sign)
+801005ac:	74 08                	je     801005b6 <printint+0x46>
+    buf[i++] = '-';
+801005ae:	8d 59 02             	lea    0x2(%ecx),%ebx
+801005b1:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+  while(--i >= 0)
+801005b6:	83 eb 01             	sub    $0x1,%ebx
+801005b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    consputc(buf[i]);
+801005c0:	0f be 44 1d d8       	movsbl -0x28(%ebp,%ebx,1),%eax
+  while(--i >= 0)
+801005c5:	83 eb 01             	sub    $0x1,%ebx
+    consputc(buf[i]);
+801005c8:	e8 13 fe ff ff       	call   801003e0 <consputc>
+  while(--i >= 0)
+801005cd:	83 fb ff             	cmp    $0xffffffff,%ebx
+801005d0:	75 ee                	jne    801005c0 <printint+0x50>
+}
+801005d2:	83 c4 1c             	add    $0x1c,%esp
+801005d5:	5b                   	pop    %ebx
+801005d6:	5e                   	pop    %esi
+801005d7:	5f                   	pop    %edi
+801005d8:	5d                   	pop    %ebp
+801005d9:	c3                   	ret    
+801005da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    x = xx;
+801005e0:	31 ff                	xor    %edi,%edi
+801005e2:	eb a6                	jmp    8010058a <printint+0x1a>
+801005e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+801005ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+801005f0 <consolewrite>:
+
+int
+consolewrite(struct inode *ip, char *buf, int n)
+{
+801005f0:	55                   	push   %ebp
+801005f1:	89 e5                	mov    %esp,%ebp
+801005f3:	57                   	push   %edi
+801005f4:	56                   	push   %esi
+801005f5:	53                   	push   %ebx
+801005f6:	83 ec 1c             	sub    $0x1c,%esp
+  int i;
+
+  iunlock(ip);
+801005f9:	8b 45 08             	mov    0x8(%ebp),%eax
+{
+801005fc:	8b 75 10             	mov    0x10(%ebp),%esi
+  iunlock(ip);
+801005ff:	89 04 24             	mov    %eax,(%esp)
+80100602:	e8 99 11 00 00       	call   801017a0 <iunlock>
+  acquire(&cons.lock);
+80100607:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+8010060e:	e8 3d 3b 00 00       	call   80104150 <acquire>
+80100613:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  for(i = 0; i < n; i++)
+80100616:	85 f6                	test   %esi,%esi
+80100618:	8d 1c 37             	lea    (%edi,%esi,1),%ebx
+8010061b:	7e 12                	jle    8010062f <consolewrite+0x3f>
+8010061d:	8d 76 00             	lea    0x0(%esi),%esi
+    consputc(buf[i] & 0xff);
+80100620:	0f b6 07             	movzbl (%edi),%eax
+80100623:	83 c7 01             	add    $0x1,%edi
+80100626:	e8 b5 fd ff ff       	call   801003e0 <consputc>
+  for(i = 0; i < n; i++)
+8010062b:	39 df                	cmp    %ebx,%edi
+8010062d:	75 f1                	jne    80100620 <consolewrite+0x30>
+  release(&cons.lock);
+8010062f:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+80100636:	e8 05 3c 00 00       	call   80104240 <release>
+  ilock(ip);
+8010063b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010063e:	89 04 24             	mov    %eax,(%esp)
+80100641:	e8 7a 10 00 00       	call   801016c0 <ilock>
+
+  return n;
+}
+80100646:	83 c4 1c             	add    $0x1c,%esp
+80100649:	89 f0                	mov    %esi,%eax
+8010064b:	5b                   	pop    %ebx
+8010064c:	5e                   	pop    %esi
+8010064d:	5f                   	pop    %edi
+8010064e:	5d                   	pop    %ebp
+8010064f:	c3                   	ret    
+
+80100650 <cprintf>:
+{
+80100650:	55                   	push   %ebp
+80100651:	89 e5                	mov    %esp,%ebp
+80100653:	57                   	push   %edi
+80100654:	56                   	push   %esi
+80100655:	53                   	push   %ebx
+80100656:	83 ec 1c             	sub    $0x1c,%esp
+  locking = cons.locking;
+80100659:	a1 54 a5 10 80       	mov    0x8010a554,%eax
+  if(locking)
+8010065e:	85 c0                	test   %eax,%eax
+  locking = cons.locking;
+80100660:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  if(locking)
+80100663:	0f 85 27 01 00 00    	jne    80100790 <cprintf+0x140>
+  if (fmt == 0)
+80100669:	8b 45 08             	mov    0x8(%ebp),%eax
+8010066c:	85 c0                	test   %eax,%eax
+8010066e:	89 c1                	mov    %eax,%ecx
+80100670:	0f 84 2b 01 00 00    	je     801007a1 <cprintf+0x151>
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+80100676:	0f b6 00             	movzbl (%eax),%eax
+80100679:	31 db                	xor    %ebx,%ebx
+8010067b:	89 cf                	mov    %ecx,%edi
+8010067d:	8d 75 0c             	lea    0xc(%ebp),%esi
+80100680:	85 c0                	test   %eax,%eax
+80100682:	75 4c                	jne    801006d0 <cprintf+0x80>
+80100684:	eb 5f                	jmp    801006e5 <cprintf+0x95>
+80100686:	66 90                	xchg   %ax,%ax
+    c = fmt[++i] & 0xff;
+80100688:	83 c3 01             	add    $0x1,%ebx
+8010068b:	0f b6 14 1f          	movzbl (%edi,%ebx,1),%edx
+    if(c == 0)
+8010068f:	85 d2                	test   %edx,%edx
+80100691:	74 52                	je     801006e5 <cprintf+0x95>
+    switch(c){
+80100693:	83 fa 70             	cmp    $0x70,%edx
+80100696:	74 72                	je     8010070a <cprintf+0xba>
+80100698:	7f 66                	jg     80100700 <cprintf+0xb0>
+8010069a:	83 fa 25             	cmp    $0x25,%edx
+8010069d:	8d 76 00             	lea    0x0(%esi),%esi
+801006a0:	0f 84 a2 00 00 00    	je     80100748 <cprintf+0xf8>
+801006a6:	83 fa 64             	cmp    $0x64,%edx
+801006a9:	75 7d                	jne    80100728 <cprintf+0xd8>
+      printint(*argp++, 10, 1);
+801006ab:	8d 46 04             	lea    0x4(%esi),%eax
+801006ae:	b9 01 00 00 00       	mov    $0x1,%ecx
+801006b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+801006b6:	8b 06                	mov    (%esi),%eax
+801006b8:	ba 0a 00 00 00       	mov    $0xa,%edx
+801006bd:	e8 ae fe ff ff       	call   80100570 <printint>
+801006c2:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+801006c5:	83 c3 01             	add    $0x1,%ebx
+801006c8:	0f b6 04 1f          	movzbl (%edi,%ebx,1),%eax
+801006cc:	85 c0                	test   %eax,%eax
+801006ce:	74 15                	je     801006e5 <cprintf+0x95>
+    if(c != '%'){
+801006d0:	83 f8 25             	cmp    $0x25,%eax
+801006d3:	74 b3                	je     80100688 <cprintf+0x38>
+      consputc(c);
+801006d5:	e8 06 fd ff ff       	call   801003e0 <consputc>
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+801006da:	83 c3 01             	add    $0x1,%ebx
+801006dd:	0f b6 04 1f          	movzbl (%edi,%ebx,1),%eax
+801006e1:	85 c0                	test   %eax,%eax
+801006e3:	75 eb                	jne    801006d0 <cprintf+0x80>
+  if(locking)
+801006e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801006e8:	85 c0                	test   %eax,%eax
+801006ea:	74 0c                	je     801006f8 <cprintf+0xa8>
+    release(&cons.lock);
+801006ec:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+801006f3:	e8 48 3b 00 00       	call   80104240 <release>
+}
+801006f8:	83 c4 1c             	add    $0x1c,%esp
+801006fb:	5b                   	pop    %ebx
+801006fc:	5e                   	pop    %esi
+801006fd:	5f                   	pop    %edi
+801006fe:	5d                   	pop    %ebp
+801006ff:	c3                   	ret    
+    switch(c){
+80100700:	83 fa 73             	cmp    $0x73,%edx
+80100703:	74 53                	je     80100758 <cprintf+0x108>
+80100705:	83 fa 78             	cmp    $0x78,%edx
+80100708:	75 1e                	jne    80100728 <cprintf+0xd8>
+      printint(*argp++, 16, 0);
+8010070a:	8d 46 04             	lea    0x4(%esi),%eax
+8010070d:	31 c9                	xor    %ecx,%ecx
+8010070f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80100712:	8b 06                	mov    (%esi),%eax
+80100714:	ba 10 00 00 00       	mov    $0x10,%edx
+80100719:	e8 52 fe ff ff       	call   80100570 <printint>
+8010071e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+      break;
+80100721:	eb a2                	jmp    801006c5 <cprintf+0x75>
+80100723:	90                   	nop
+80100724:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      consputc('%');
+80100728:	b8 25 00 00 00       	mov    $0x25,%eax
+8010072d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+80100730:	e8 ab fc ff ff       	call   801003e0 <consputc>
+      consputc(c);
+80100735:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80100738:	89 d0                	mov    %edx,%eax
+8010073a:	e8 a1 fc ff ff       	call   801003e0 <consputc>
+8010073f:	eb 99                	jmp    801006da <cprintf+0x8a>
+80100741:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      consputc('%');
+80100748:	b8 25 00 00 00       	mov    $0x25,%eax
+8010074d:	e8 8e fc ff ff       	call   801003e0 <consputc>
+      break;
+80100752:	e9 6e ff ff ff       	jmp    801006c5 <cprintf+0x75>
+80100757:	90                   	nop
+      if((s = (char*)*argp++) == 0)
+80100758:	8d 46 04             	lea    0x4(%esi),%eax
+8010075b:	8b 36                	mov    (%esi),%esi
+8010075d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        s = "(null)";
+80100760:	b8 78 6d 10 80       	mov    $0x80106d78,%eax
+80100765:	85 f6                	test   %esi,%esi
+80100767:	0f 44 f0             	cmove  %eax,%esi
+      for(; *s; s++)
+8010076a:	0f be 06             	movsbl (%esi),%eax
+8010076d:	84 c0                	test   %al,%al
+8010076f:	74 16                	je     80100787 <cprintf+0x137>
+80100771:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80100778:	83 c6 01             	add    $0x1,%esi
+        consputc(*s);
+8010077b:	e8 60 fc ff ff       	call   801003e0 <consputc>
+      for(; *s; s++)
+80100780:	0f be 06             	movsbl (%esi),%eax
+80100783:	84 c0                	test   %al,%al
+80100785:	75 f1                	jne    80100778 <cprintf+0x128>
+      if((s = (char*)*argp++) == 0)
+80100787:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+8010078a:	e9 36 ff ff ff       	jmp    801006c5 <cprintf+0x75>
+8010078f:	90                   	nop
+    acquire(&cons.lock);
+80100790:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+80100797:	e8 b4 39 00 00       	call   80104150 <acquire>
+8010079c:	e9 c8 fe ff ff       	jmp    80100669 <cprintf+0x19>
+    panic("null fmt");
+801007a1:	c7 04 24 7f 6d 10 80 	movl   $0x80106d7f,(%esp)
+801007a8:	e8 b3 fb ff ff       	call   80100360 <panic>
+801007ad:	8d 76 00             	lea    0x0(%esi),%esi
+
+801007b0 <consoleintr>:
+{
+801007b0:	55                   	push   %ebp
+801007b1:	89 e5                	mov    %esp,%ebp
+801007b3:	57                   	push   %edi
+801007b4:	56                   	push   %esi
+  int c, doprocdump = 0;
+801007b5:	31 f6                	xor    %esi,%esi
+{
+801007b7:	53                   	push   %ebx
+801007b8:	83 ec 1c             	sub    $0x1c,%esp
+801007bb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&cons.lock);
+801007be:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+801007c5:	e8 86 39 00 00       	call   80104150 <acquire>
+801007ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  while((c = getc()) >= 0){
+801007d0:	ff d3                	call   *%ebx
+801007d2:	85 c0                	test   %eax,%eax
+801007d4:	89 c7                	mov    %eax,%edi
+801007d6:	78 48                	js     80100820 <consoleintr+0x70>
+    switch(c){
+801007d8:	83 ff 10             	cmp    $0x10,%edi
+801007db:	0f 84 2f 01 00 00    	je     80100910 <consoleintr+0x160>
+801007e1:	7e 5d                	jle    80100840 <consoleintr+0x90>
+801007e3:	83 ff 15             	cmp    $0x15,%edi
+801007e6:	0f 84 d4 00 00 00    	je     801008c0 <consoleintr+0x110>
+801007ec:	83 ff 7f             	cmp    $0x7f,%edi
+801007ef:	90                   	nop
+801007f0:	75 53                	jne    80100845 <consoleintr+0x95>
+      if(input.e != input.w){
+801007f2:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+801007f7:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
+801007fd:	74 d1                	je     801007d0 <consoleintr+0x20>
+        input.e--;
+801007ff:	83 e8 01             	sub    $0x1,%eax
+80100802:	a3 a8 ff 10 80       	mov    %eax,0x8010ffa8
+        consputc(BACKSPACE);
+80100807:	b8 00 01 00 00       	mov    $0x100,%eax
+8010080c:	e8 cf fb ff ff       	call   801003e0 <consputc>
+  while((c = getc()) >= 0){
+80100811:	ff d3                	call   *%ebx
+80100813:	85 c0                	test   %eax,%eax
+80100815:	89 c7                	mov    %eax,%edi
+80100817:	79 bf                	jns    801007d8 <consoleintr+0x28>
+80100819:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  release(&cons.lock);
+80100820:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+80100827:	e8 14 3a 00 00       	call   80104240 <release>
+  if(doprocdump) {
+8010082c:	85 f6                	test   %esi,%esi
+8010082e:	0f 85 ec 00 00 00    	jne    80100920 <consoleintr+0x170>
+}
+80100834:	83 c4 1c             	add    $0x1c,%esp
+80100837:	5b                   	pop    %ebx
+80100838:	5e                   	pop    %esi
+80100839:	5f                   	pop    %edi
+8010083a:	5d                   	pop    %ebp
+8010083b:	c3                   	ret    
+8010083c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    switch(c){
+80100840:	83 ff 08             	cmp    $0x8,%edi
+80100843:	74 ad                	je     801007f2 <consoleintr+0x42>
+      if(c != 0 && input.e-input.r < INPUT_BUF){
+80100845:	85 ff                	test   %edi,%edi
+80100847:	74 87                	je     801007d0 <consoleintr+0x20>
+80100849:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+8010084e:	89 c2                	mov    %eax,%edx
+80100850:	2b 15 a0 ff 10 80    	sub    0x8010ffa0,%edx
+80100856:	83 fa 7f             	cmp    $0x7f,%edx
+80100859:	0f 87 71 ff ff ff    	ja     801007d0 <consoleintr+0x20>
+        input.buf[input.e++ % INPUT_BUF] = c;
+8010085f:	8d 50 01             	lea    0x1(%eax),%edx
+80100862:	83 e0 7f             	and    $0x7f,%eax
+        c = (c == '\r') ? '\n' : c;
+80100865:	83 ff 0d             	cmp    $0xd,%edi
+        input.buf[input.e++ % INPUT_BUF] = c;
+80100868:	89 15 a8 ff 10 80    	mov    %edx,0x8010ffa8
+        c = (c == '\r') ? '\n' : c;
+8010086e:	0f 84 b8 00 00 00    	je     8010092c <consoleintr+0x17c>
+        input.buf[input.e++ % INPUT_BUF] = c;
+80100874:	89 f9                	mov    %edi,%ecx
+80100876:	88 88 20 ff 10 80    	mov    %cl,-0x7fef00e0(%eax)
+        consputc(c);
+8010087c:	89 f8                	mov    %edi,%eax
+8010087e:	e8 5d fb ff ff       	call   801003e0 <consputc>
+        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
+80100883:	83 ff 04             	cmp    $0x4,%edi
+80100886:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+8010088b:	74 19                	je     801008a6 <consoleintr+0xf6>
+8010088d:	83 ff 0a             	cmp    $0xa,%edi
+80100890:	74 14                	je     801008a6 <consoleintr+0xf6>
+80100892:	8b 0d a0 ff 10 80    	mov    0x8010ffa0,%ecx
+80100898:	8d 91 80 00 00 00    	lea    0x80(%ecx),%edx
+8010089e:	39 d0                	cmp    %edx,%eax
+801008a0:	0f 85 2a ff ff ff    	jne    801007d0 <consoleintr+0x20>
+          wakeup(&input.r);
+801008a6:	c7 04 24 a0 ff 10 80 	movl   $0x8010ffa0,(%esp)
+          input.w = input.e;
+801008ad:	a3 a4 ff 10 80       	mov    %eax,0x8010ffa4
+          wakeup(&input.r);
+801008b2:	e8 e9 34 00 00       	call   80103da0 <wakeup>
+801008b7:	e9 14 ff ff ff       	jmp    801007d0 <consoleintr+0x20>
+801008bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      while(input.e != input.w &&
+801008c0:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+801008c5:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
+801008cb:	75 2b                	jne    801008f8 <consoleintr+0x148>
+801008cd:	e9 fe fe ff ff       	jmp    801007d0 <consoleintr+0x20>
+801008d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        input.e--;
+801008d8:	a3 a8 ff 10 80       	mov    %eax,0x8010ffa8
+        consputc(BACKSPACE);
+801008dd:	b8 00 01 00 00       	mov    $0x100,%eax
+801008e2:	e8 f9 fa ff ff       	call   801003e0 <consputc>
+      while(input.e != input.w &&
+801008e7:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+801008ec:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
+801008f2:	0f 84 d8 fe ff ff    	je     801007d0 <consoleintr+0x20>
+            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+801008f8:	83 e8 01             	sub    $0x1,%eax
+801008fb:	89 c2                	mov    %eax,%edx
+801008fd:	83 e2 7f             	and    $0x7f,%edx
+      while(input.e != input.w &&
+80100900:	80 ba 20 ff 10 80 0a 	cmpb   $0xa,-0x7fef00e0(%edx)
+80100907:	75 cf                	jne    801008d8 <consoleintr+0x128>
+80100909:	e9 c2 fe ff ff       	jmp    801007d0 <consoleintr+0x20>
+8010090e:	66 90                	xchg   %ax,%ax
+      doprocdump = 1;
+80100910:	be 01 00 00 00       	mov    $0x1,%esi
+80100915:	e9 b6 fe ff ff       	jmp    801007d0 <consoleintr+0x20>
+8010091a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+}
+80100920:	83 c4 1c             	add    $0x1c,%esp
+80100923:	5b                   	pop    %ebx
+80100924:	5e                   	pop    %esi
+80100925:	5f                   	pop    %edi
+80100926:	5d                   	pop    %ebp
+    procdump();  // now call procdump() wo. cons.lock held
+80100927:	e9 54 35 00 00       	jmp    80103e80 <procdump>
+        input.buf[input.e++ % INPUT_BUF] = c;
+8010092c:	c6 80 20 ff 10 80 0a 	movb   $0xa,-0x7fef00e0(%eax)
+        consputc(c);
+80100933:	b8 0a 00 00 00       	mov    $0xa,%eax
+80100938:	e8 a3 fa ff ff       	call   801003e0 <consputc>
+8010093d:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+80100942:	e9 5f ff ff ff       	jmp    801008a6 <consoleintr+0xf6>
+80100947:	89 f6                	mov    %esi,%esi
+80100949:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80100950 <consoleinit>:
+
+void
+consoleinit(void)
+{
+80100950:	55                   	push   %ebp
+80100951:	89 e5                	mov    %esp,%ebp
+80100953:	83 ec 18             	sub    $0x18,%esp
+  initlock(&cons.lock, "console");
+80100956:	c7 44 24 04 88 6d 10 	movl   $0x80106d88,0x4(%esp)
+8010095d:	80 
+8010095e:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+80100965:	e8 f6 36 00 00       	call   80104060 <initlock>
+
+  devsw[CONSOLE].write = consolewrite;
+  devsw[CONSOLE].read = consoleread;
+  cons.locking = 1;
+
+  ioapicenable(IRQ_KBD, 0);
+8010096a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80100971:	00 
+80100972:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  devsw[CONSOLE].write = consolewrite;
+80100979:	c7 05 6c 09 11 80 f0 	movl   $0x801005f0,0x8011096c
+80100980:	05 10 80 
+  devsw[CONSOLE].read = consoleread;
+80100983:	c7 05 68 09 11 80 70 	movl   $0x80100270,0x80110968
+8010098a:	02 10 80 
+  cons.locking = 1;
+8010098d:	c7 05 54 a5 10 80 01 	movl   $0x1,0x8010a554
+80100994:	00 00 00 
+  ioapicenable(IRQ_KBD, 0);
+80100997:	e8 24 19 00 00       	call   801022c0 <ioapicenable>
+}
+8010099c:	c9                   	leave  
+8010099d:	c3                   	ret    
+8010099e:	66 90                	xchg   %ax,%ax
+
+801009a0 <exec>:
+#include "x86.h"
+#include "elf.h"
+
+int
+exec(char *path, char **argv)
+{
+801009a0:	55                   	push   %ebp
+801009a1:	89 e5                	mov    %esp,%ebp
+801009a3:	57                   	push   %edi
+801009a4:	56                   	push   %esi
+801009a5:	53                   	push   %ebx
+801009a6:	81 ec 2c 01 00 00    	sub    $0x12c,%esp
+  uint argc, sz, sp, ustack[3+MAXARG+1];
+  struct elfhdr elf;
+  struct inode *ip;
+  struct proghdr ph;
+  pde_t *pgdir, *oldpgdir;
+  struct proc *curproc = myproc();
+801009ac:	e8 ff 2c 00 00       	call   801036b0 <myproc>
+801009b1:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
+
+  begin_op();
+801009b7:	e8 64 21 00 00       	call   80102b20 <begin_op>
+
+  if((ip = namei(path)) == 0){
+801009bc:	8b 45 08             	mov    0x8(%ebp),%eax
+801009bf:	89 04 24             	mov    %eax,(%esp)
+801009c2:	e8 49 15 00 00       	call   80101f10 <namei>
+801009c7:	85 c0                	test   %eax,%eax
+801009c9:	89 c3                	mov    %eax,%ebx
+801009cb:	0f 84 c2 01 00 00    	je     80100b93 <exec+0x1f3>
+    end_op();
+    cprintf("exec: fail\n");
+    return -1;
+  }
+  ilock(ip);
+801009d1:	89 04 24             	mov    %eax,(%esp)
+801009d4:	e8 e7 0c 00 00       	call   801016c0 <ilock>
+  pgdir = 0;
+
+  // Check ELF header
+  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
+801009d9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
+801009df:	c7 44 24 0c 34 00 00 	movl   $0x34,0xc(%esp)
+801009e6:	00 
+801009e7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+801009ee:	00 
+801009ef:	89 44 24 04          	mov    %eax,0x4(%esp)
+801009f3:	89 1c 24             	mov    %ebx,(%esp)
+801009f6:	e8 75 0f 00 00       	call   80101970 <readi>
+801009fb:	83 f8 34             	cmp    $0x34,%eax
+801009fe:	74 20                	je     80100a20 <exec+0x80>
+
+ bad:
+  if(pgdir)
+    freevm(pgdir);
+  if(ip){
+    iunlockput(ip);
+80100a00:	89 1c 24             	mov    %ebx,(%esp)
+80100a03:	e8 18 0f 00 00       	call   80101920 <iunlockput>
+    end_op();
+80100a08:	e8 83 21 00 00       	call   80102b90 <end_op>
+  }
+  return -1;
+80100a0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80100a12:	81 c4 2c 01 00 00    	add    $0x12c,%esp
+80100a18:	5b                   	pop    %ebx
+80100a19:	5e                   	pop    %esi
+80100a1a:	5f                   	pop    %edi
+80100a1b:	5d                   	pop    %ebp
+80100a1c:	c3                   	ret    
+80100a1d:	8d 76 00             	lea    0x0(%esi),%esi
+  if(elf.magic != ELF_MAGIC)
+80100a20:	81 bd 24 ff ff ff 7f 	cmpl   $0x464c457f,-0xdc(%ebp)
+80100a27:	45 4c 46 
+80100a2a:	75 d4                	jne    80100a00 <exec+0x60>
+  if((pgdir = setupkvm()) == 0)
+80100a2c:	e8 bf 5f 00 00       	call   801069f0 <setupkvm>
+80100a31:	85 c0                	test   %eax,%eax
+80100a33:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
+80100a39:	74 c5                	je     80100a00 <exec+0x60>
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+80100a3b:	66 83 bd 50 ff ff ff 	cmpw   $0x0,-0xb0(%ebp)
+80100a42:	00 
+80100a43:	8b b5 40 ff ff ff    	mov    -0xc0(%ebp),%esi
+  sz = 0;
+80100a49:	c7 85 ec fe ff ff 00 	movl   $0x0,-0x114(%ebp)
+80100a50:	00 00 00 
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+80100a53:	0f 84 da 00 00 00    	je     80100b33 <exec+0x193>
+80100a59:	31 ff                	xor    %edi,%edi
+80100a5b:	eb 18                	jmp    80100a75 <exec+0xd5>
+80100a5d:	8d 76 00             	lea    0x0(%esi),%esi
+80100a60:	0f b7 85 50 ff ff ff 	movzwl -0xb0(%ebp),%eax
+80100a67:	83 c7 01             	add    $0x1,%edi
+80100a6a:	83 c6 20             	add    $0x20,%esi
+80100a6d:	39 f8                	cmp    %edi,%eax
+80100a6f:	0f 8e be 00 00 00    	jle    80100b33 <exec+0x193>
+    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
+80100a75:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
+80100a7b:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
+80100a82:	00 
+80100a83:	89 74 24 08          	mov    %esi,0x8(%esp)
+80100a87:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100a8b:	89 1c 24             	mov    %ebx,(%esp)
+80100a8e:	e8 dd 0e 00 00       	call   80101970 <readi>
+80100a93:	83 f8 20             	cmp    $0x20,%eax
+80100a96:	0f 85 84 00 00 00    	jne    80100b20 <exec+0x180>
+    if(ph.type != ELF_PROG_LOAD)
+80100a9c:	83 bd 04 ff ff ff 01 	cmpl   $0x1,-0xfc(%ebp)
+80100aa3:	75 bb                	jne    80100a60 <exec+0xc0>
+    if(ph.memsz < ph.filesz)
+80100aa5:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
+80100aab:	3b 85 14 ff ff ff    	cmp    -0xec(%ebp),%eax
+80100ab1:	72 6d                	jb     80100b20 <exec+0x180>
+    if(ph.vaddr + ph.memsz < ph.vaddr)
+80100ab3:	03 85 0c ff ff ff    	add    -0xf4(%ebp),%eax
+80100ab9:	72 65                	jb     80100b20 <exec+0x180>
+    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+80100abb:	89 44 24 08          	mov    %eax,0x8(%esp)
+80100abf:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
+80100ac5:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100ac9:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100acf:	89 04 24             	mov    %eax,(%esp)
+80100ad2:	e8 79 5d 00 00       	call   80106850 <allocuvm>
+80100ad7:	85 c0                	test   %eax,%eax
+80100ad9:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
+80100adf:	74 3f                	je     80100b20 <exec+0x180>
+    if(ph.vaddr % PGSIZE != 0)
+80100ae1:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
+80100ae7:	a9 ff 0f 00 00       	test   $0xfff,%eax
+80100aec:	75 32                	jne    80100b20 <exec+0x180>
+    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+80100aee:	8b 95 14 ff ff ff    	mov    -0xec(%ebp),%edx
+80100af4:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100af8:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100afe:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+80100b02:	89 54 24 10          	mov    %edx,0x10(%esp)
+80100b06:	8b 95 08 ff ff ff    	mov    -0xf8(%ebp),%edx
+80100b0c:	89 04 24             	mov    %eax,(%esp)
+80100b0f:	89 54 24 0c          	mov    %edx,0xc(%esp)
+80100b13:	e8 78 5c 00 00       	call   80106790 <loaduvm>
+80100b18:	85 c0                	test   %eax,%eax
+80100b1a:	0f 89 40 ff ff ff    	jns    80100a60 <exec+0xc0>
+    freevm(pgdir);
+80100b20:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100b26:	89 04 24             	mov    %eax,(%esp)
+80100b29:	e8 42 5e 00 00       	call   80106970 <freevm>
+80100b2e:	e9 cd fe ff ff       	jmp    80100a00 <exec+0x60>
+  iunlockput(ip);
+80100b33:	89 1c 24             	mov    %ebx,(%esp)
+80100b36:	e8 e5 0d 00 00       	call   80101920 <iunlockput>
+80100b3b:	90                   	nop
+80100b3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  end_op();
+80100b40:	e8 4b 20 00 00       	call   80102b90 <end_op>
+  sz = PGROUNDUP(sz);
+80100b45:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
+80100b4b:	05 ff 0f 00 00       	add    $0xfff,%eax
+80100b50:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+80100b55:	8d 90 00 20 00 00    	lea    0x2000(%eax),%edx
+80100b5b:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100b5f:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100b65:	89 54 24 08          	mov    %edx,0x8(%esp)
+80100b69:	89 04 24             	mov    %eax,(%esp)
+80100b6c:	e8 df 5c 00 00       	call   80106850 <allocuvm>
+80100b71:	85 c0                	test   %eax,%eax
+80100b73:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
+80100b79:	75 33                	jne    80100bae <exec+0x20e>
+    freevm(pgdir);
+80100b7b:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100b81:	89 04 24             	mov    %eax,(%esp)
+80100b84:	e8 e7 5d 00 00       	call   80106970 <freevm>
+  return -1;
+80100b89:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80100b8e:	e9 7f fe ff ff       	jmp    80100a12 <exec+0x72>
+    end_op();
+80100b93:	e8 f8 1f 00 00       	call   80102b90 <end_op>
+    cprintf("exec: fail\n");
+80100b98:	c7 04 24 a1 6d 10 80 	movl   $0x80106da1,(%esp)
+80100b9f:	e8 ac fa ff ff       	call   80100650 <cprintf>
+    return -1;
+80100ba4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80100ba9:	e9 64 fe ff ff       	jmp    80100a12 <exec+0x72>
+  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+80100bae:	8b 9d e8 fe ff ff    	mov    -0x118(%ebp),%ebx
+80100bb4:	89 d8                	mov    %ebx,%eax
+80100bb6:	2d 00 20 00 00       	sub    $0x2000,%eax
+80100bbb:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100bbf:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100bc5:	89 04 24             	mov    %eax,(%esp)
+80100bc8:	e8 d3 5e 00 00       	call   80106aa0 <clearpteu>
+  for(argc = 0; argv[argc]; argc++) {
+80100bcd:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100bd0:	8b 00                	mov    (%eax),%eax
+80100bd2:	85 c0                	test   %eax,%eax
+80100bd4:	0f 84 59 01 00 00    	je     80100d33 <exec+0x393>
+80100bda:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+80100bdd:	31 d2                	xor    %edx,%edx
+80100bdf:	8d 71 04             	lea    0x4(%ecx),%esi
+80100be2:	89 cf                	mov    %ecx,%edi
+80100be4:	89 d1                	mov    %edx,%ecx
+80100be6:	89 f2                	mov    %esi,%edx
+80100be8:	89 fe                	mov    %edi,%esi
+80100bea:	89 cf                	mov    %ecx,%edi
+80100bec:	eb 0a                	jmp    80100bf8 <exec+0x258>
+80100bee:	66 90                	xchg   %ax,%ax
+80100bf0:	83 c2 04             	add    $0x4,%edx
+    if(argc >= MAXARG)
+80100bf3:	83 ff 20             	cmp    $0x20,%edi
+80100bf6:	74 83                	je     80100b7b <exec+0x1db>
+    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+80100bf8:	89 04 24             	mov    %eax,(%esp)
+80100bfb:	89 95 ec fe ff ff    	mov    %edx,-0x114(%ebp)
+80100c01:	e8 aa 38 00 00       	call   801044b0 <strlen>
+80100c06:	f7 d0                	not    %eax
+80100c08:	01 c3                	add    %eax,%ebx
+    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+80100c0a:	8b 06                	mov    (%esi),%eax
+    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+80100c0c:	83 e3 fc             	and    $0xfffffffc,%ebx
+    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+80100c0f:	89 04 24             	mov    %eax,(%esp)
+80100c12:	e8 99 38 00 00       	call   801044b0 <strlen>
+80100c17:	83 c0 01             	add    $0x1,%eax
+80100c1a:	89 44 24 0c          	mov    %eax,0xc(%esp)
+80100c1e:	8b 06                	mov    (%esi),%eax
+80100c20:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80100c24:	89 44 24 08          	mov    %eax,0x8(%esp)
+80100c28:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100c2e:	89 04 24             	mov    %eax,(%esp)
+80100c31:	e8 ca 5f 00 00       	call   80106c00 <copyout>
+80100c36:	85 c0                	test   %eax,%eax
+80100c38:	0f 88 3d ff ff ff    	js     80100b7b <exec+0x1db>
+  for(argc = 0; argv[argc]; argc++) {
+80100c3e:	8b 95 ec fe ff ff    	mov    -0x114(%ebp),%edx
+    ustack[3+argc] = sp;
+80100c44:	8d 8d 58 ff ff ff    	lea    -0xa8(%ebp),%ecx
+80100c4a:	89 9c bd 64 ff ff ff 	mov    %ebx,-0x9c(%ebp,%edi,4)
+  for(argc = 0; argv[argc]; argc++) {
+80100c51:	83 c7 01             	add    $0x1,%edi
+80100c54:	8b 02                	mov    (%edx),%eax
+80100c56:	89 d6                	mov    %edx,%esi
+80100c58:	85 c0                	test   %eax,%eax
+80100c5a:	75 94                	jne    80100bf0 <exec+0x250>
+80100c5c:	89 fa                	mov    %edi,%edx
+  ustack[3+argc] = 0;
+80100c5e:	c7 84 95 64 ff ff ff 	movl   $0x0,-0x9c(%ebp,%edx,4)
+80100c65:	00 00 00 00 
+  ustack[2] = sp - (argc+1)*4;  // argv pointer
+80100c69:	8d 04 95 04 00 00 00 	lea    0x4(,%edx,4),%eax
+  ustack[1] = argc;
+80100c70:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%ebp)
+  ustack[2] = sp - (argc+1)*4;  // argv pointer
+80100c76:	89 da                	mov    %ebx,%edx
+80100c78:	29 c2                	sub    %eax,%edx
+  sp -= (3+argc+1) * 4;
+80100c7a:	83 c0 0c             	add    $0xc,%eax
+80100c7d:	29 c3                	sub    %eax,%ebx
+  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+80100c7f:	89 44 24 0c          	mov    %eax,0xc(%esp)
+80100c83:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100c89:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+80100c8d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+  ustack[0] = 0xffffffff;  // fake return PC
+80100c91:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
+80100c98:	ff ff ff 
+  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+80100c9b:	89 04 24             	mov    %eax,(%esp)
+  ustack[2] = sp - (argc+1)*4;  // argv pointer
+80100c9e:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)
+  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+80100ca4:	e8 57 5f 00 00       	call   80106c00 <copyout>
+80100ca9:	85 c0                	test   %eax,%eax
+80100cab:	0f 88 ca fe ff ff    	js     80100b7b <exec+0x1db>
+  for(last=s=path; *s; s++)
+80100cb1:	8b 45 08             	mov    0x8(%ebp),%eax
+80100cb4:	0f b6 10             	movzbl (%eax),%edx
+80100cb7:	84 d2                	test   %dl,%dl
+80100cb9:	74 19                	je     80100cd4 <exec+0x334>
+80100cbb:	8b 4d 08             	mov    0x8(%ebp),%ecx
+80100cbe:	83 c0 01             	add    $0x1,%eax
+      last = s+1;
+80100cc1:	80 fa 2f             	cmp    $0x2f,%dl
+  for(last=s=path; *s; s++)
+80100cc4:	0f b6 10             	movzbl (%eax),%edx
+      last = s+1;
+80100cc7:	0f 44 c8             	cmove  %eax,%ecx
+80100cca:	83 c0 01             	add    $0x1,%eax
+  for(last=s=path; *s; s++)
+80100ccd:	84 d2                	test   %dl,%dl
+80100ccf:	75 f0                	jne    80100cc1 <exec+0x321>
+80100cd1:	89 4d 08             	mov    %ecx,0x8(%ebp)
+  safestrcpy(curproc->name, last, sizeof(curproc->name));
+80100cd4:	8b bd f4 fe ff ff    	mov    -0x10c(%ebp),%edi
+80100cda:	8b 45 08             	mov    0x8(%ebp),%eax
+80100cdd:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+80100ce4:	00 
+80100ce5:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100ce9:	89 f8                	mov    %edi,%eax
+80100ceb:	83 c0 6c             	add    $0x6c,%eax
+80100cee:	89 04 24             	mov    %eax,(%esp)
+80100cf1:	e8 7a 37 00 00       	call   80104470 <safestrcpy>
+  curproc->pgdir = pgdir;
+80100cf6:	8b 8d f0 fe ff ff    	mov    -0x110(%ebp),%ecx
+  oldpgdir = curproc->pgdir;
+80100cfc:	8b 77 04             	mov    0x4(%edi),%esi
+  curproc->tf->eip = elf.entry;  // main
+80100cff:	8b 47 18             	mov    0x18(%edi),%eax
+  curproc->pgdir = pgdir;
+80100d02:	89 4f 04             	mov    %ecx,0x4(%edi)
+  curproc->sz = sz;
+80100d05:	8b 8d e8 fe ff ff    	mov    -0x118(%ebp),%ecx
+80100d0b:	89 0f                	mov    %ecx,(%edi)
+  curproc->tf->eip = elf.entry;  // main
+80100d0d:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
+80100d13:	89 50 38             	mov    %edx,0x38(%eax)
+  curproc->tf->esp = sp;
+80100d16:	8b 47 18             	mov    0x18(%edi),%eax
+80100d19:	89 58 44             	mov    %ebx,0x44(%eax)
+  switchuvm(curproc);
+80100d1c:	89 3c 24             	mov    %edi,(%esp)
+80100d1f:	e8 cc 58 00 00       	call   801065f0 <switchuvm>
+  freevm(oldpgdir);
+80100d24:	89 34 24             	mov    %esi,(%esp)
+80100d27:	e8 44 5c 00 00       	call   80106970 <freevm>
+  return 0;
+80100d2c:	31 c0                	xor    %eax,%eax
+80100d2e:	e9 df fc ff ff       	jmp    80100a12 <exec+0x72>
+  for(argc = 0; argv[argc]; argc++) {
+80100d33:	8b 9d e8 fe ff ff    	mov    -0x118(%ebp),%ebx
+80100d39:	31 d2                	xor    %edx,%edx
+80100d3b:	8d 8d 58 ff ff ff    	lea    -0xa8(%ebp),%ecx
+80100d41:	e9 18 ff ff ff       	jmp    80100c5e <exec+0x2be>
+80100d46:	66 90                	xchg   %ax,%ax
+80100d48:	66 90                	xchg   %ax,%ax
+80100d4a:	66 90                	xchg   %ax,%ax
+80100d4c:	66 90                	xchg   %ax,%ax
+80100d4e:	66 90                	xchg   %ax,%ax
+
+80100d50 <fileinit>:
+  struct file file[NFILE];
+} ftable;
+
+void
+fileinit(void)
+{
+80100d50:	55                   	push   %ebp
+80100d51:	89 e5                	mov    %esp,%ebp
+80100d53:	83 ec 18             	sub    $0x18,%esp
+  initlock(&ftable.lock, "ftable");
+80100d56:	c7 44 24 04 ad 6d 10 	movl   $0x80106dad,0x4(%esp)
+80100d5d:	80 
+80100d5e:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+80100d65:	e8 f6 32 00 00       	call   80104060 <initlock>
+}
+80100d6a:	c9                   	leave  
+80100d6b:	c3                   	ret    
+80100d6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80100d70 <filealloc>:
+
+// Allocate a file structure.
+struct file*
+filealloc(void)
+{
+80100d70:	55                   	push   %ebp
+80100d71:	89 e5                	mov    %esp,%ebp
+80100d73:	53                   	push   %ebx
+  struct file *f;
+
+  acquire(&ftable.lock);
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+80100d74:	bb f4 ff 10 80       	mov    $0x8010fff4,%ebx
+{
+80100d79:	83 ec 14             	sub    $0x14,%esp
+  acquire(&ftable.lock);
+80100d7c:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+80100d83:	e8 c8 33 00 00       	call   80104150 <acquire>
+80100d88:	eb 11                	jmp    80100d9b <filealloc+0x2b>
+80100d8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+80100d90:	83 c3 18             	add    $0x18,%ebx
+80100d93:	81 fb 54 09 11 80    	cmp    $0x80110954,%ebx
+80100d99:	74 25                	je     80100dc0 <filealloc+0x50>
+    if(f->ref == 0){
+80100d9b:	8b 43 04             	mov    0x4(%ebx),%eax
+80100d9e:	85 c0                	test   %eax,%eax
+80100da0:	75 ee                	jne    80100d90 <filealloc+0x20>
+      f->ref = 1;
+      release(&ftable.lock);
+80100da2:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+      f->ref = 1;
+80100da9:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
+      release(&ftable.lock);
+80100db0:	e8 8b 34 00 00       	call   80104240 <release>
+      return f;
+    }
+  }
+  release(&ftable.lock);
+  return 0;
+}
+80100db5:	83 c4 14             	add    $0x14,%esp
+      return f;
+80100db8:	89 d8                	mov    %ebx,%eax
+}
+80100dba:	5b                   	pop    %ebx
+80100dbb:	5d                   	pop    %ebp
+80100dbc:	c3                   	ret    
+80100dbd:	8d 76 00             	lea    0x0(%esi),%esi
+  release(&ftable.lock);
+80100dc0:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+80100dc7:	e8 74 34 00 00       	call   80104240 <release>
+}
+80100dcc:	83 c4 14             	add    $0x14,%esp
+  return 0;
+80100dcf:	31 c0                	xor    %eax,%eax
+}
+80100dd1:	5b                   	pop    %ebx
+80100dd2:	5d                   	pop    %ebp
+80100dd3:	c3                   	ret    
+80100dd4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80100dda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+80100de0 <filedup>:
+
+// Increment ref count for file f.
+struct file*
+filedup(struct file *f)
+{
+80100de0:	55                   	push   %ebp
+80100de1:	89 e5                	mov    %esp,%ebp
+80100de3:	53                   	push   %ebx
+80100de4:	83 ec 14             	sub    $0x14,%esp
+80100de7:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&ftable.lock);
+80100dea:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+80100df1:	e8 5a 33 00 00       	call   80104150 <acquire>
+  if(f->ref < 1)
+80100df6:	8b 43 04             	mov    0x4(%ebx),%eax
+80100df9:	85 c0                	test   %eax,%eax
+80100dfb:	7e 1a                	jle    80100e17 <filedup+0x37>
+    panic("filedup");
+  f->ref++;
+80100dfd:	83 c0 01             	add    $0x1,%eax
+80100e00:	89 43 04             	mov    %eax,0x4(%ebx)
+  release(&ftable.lock);
+80100e03:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+80100e0a:	e8 31 34 00 00       	call   80104240 <release>
+  return f;
+}
+80100e0f:	83 c4 14             	add    $0x14,%esp
+80100e12:	89 d8                	mov    %ebx,%eax
+80100e14:	5b                   	pop    %ebx
+80100e15:	5d                   	pop    %ebp
+80100e16:	c3                   	ret    
+    panic("filedup");
+80100e17:	c7 04 24 b4 6d 10 80 	movl   $0x80106db4,(%esp)
+80100e1e:	e8 3d f5 ff ff       	call   80100360 <panic>
+80100e23:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80100e29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80100e30 <fileclose>:
+
+// Close file f.  (Decrement ref count, close when reaches 0.)
+void
+fileclose(struct file *f)
+{
+80100e30:	55                   	push   %ebp
+80100e31:	89 e5                	mov    %esp,%ebp
+80100e33:	57                   	push   %edi
+80100e34:	56                   	push   %esi
+80100e35:	53                   	push   %ebx
+80100e36:	83 ec 1c             	sub    $0x1c,%esp
+80100e39:	8b 7d 08             	mov    0x8(%ebp),%edi
+  struct file ff;
+
+  acquire(&ftable.lock);
+80100e3c:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+80100e43:	e8 08 33 00 00       	call   80104150 <acquire>
+  if(f->ref < 1)
+80100e48:	8b 57 04             	mov    0x4(%edi),%edx
+80100e4b:	85 d2                	test   %edx,%edx
+80100e4d:	0f 8e 89 00 00 00    	jle    80100edc <fileclose+0xac>
+    panic("fileclose");
+  if(--f->ref > 0){
+80100e53:	83 ea 01             	sub    $0x1,%edx
+80100e56:	85 d2                	test   %edx,%edx
+80100e58:	89 57 04             	mov    %edx,0x4(%edi)
+80100e5b:	74 13                	je     80100e70 <fileclose+0x40>
+    release(&ftable.lock);
+80100e5d:	c7 45 08 c0 ff 10 80 	movl   $0x8010ffc0,0x8(%ebp)
+  else if(ff.type == FD_INODE){
+    begin_op();
+    iput(ff.ip);
+    end_op();
+  }
+}
+80100e64:	83 c4 1c             	add    $0x1c,%esp
+80100e67:	5b                   	pop    %ebx
+80100e68:	5e                   	pop    %esi
+80100e69:	5f                   	pop    %edi
+80100e6a:	5d                   	pop    %ebp
+    release(&ftable.lock);
+80100e6b:	e9 d0 33 00 00       	jmp    80104240 <release>
+  ff = *f;
+80100e70:	0f b6 47 09          	movzbl 0x9(%edi),%eax
+80100e74:	8b 37                	mov    (%edi),%esi
+80100e76:	8b 5f 0c             	mov    0xc(%edi),%ebx
+  f->type = FD_NONE;
+80100e79:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
+  ff = *f;
+80100e7f:	88 45 e7             	mov    %al,-0x19(%ebp)
+80100e82:	8b 47 10             	mov    0x10(%edi),%eax
+  release(&ftable.lock);
+80100e85:	c7 04 24 c0 ff 10 80 	movl   $0x8010ffc0,(%esp)
+  ff = *f;
+80100e8c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  release(&ftable.lock);
+80100e8f:	e8 ac 33 00 00       	call   80104240 <release>
+  if(ff.type == FD_PIPE)
+80100e94:	83 fe 01             	cmp    $0x1,%esi
+80100e97:	74 0f                	je     80100ea8 <fileclose+0x78>
+  else if(ff.type == FD_INODE){
+80100e99:	83 fe 02             	cmp    $0x2,%esi
+80100e9c:	74 22                	je     80100ec0 <fileclose+0x90>
+}
+80100e9e:	83 c4 1c             	add    $0x1c,%esp
+80100ea1:	5b                   	pop    %ebx
+80100ea2:	5e                   	pop    %esi
+80100ea3:	5f                   	pop    %edi
+80100ea4:	5d                   	pop    %ebp
+80100ea5:	c3                   	ret    
+80100ea6:	66 90                	xchg   %ax,%ax
+    pipeclose(ff.pipe, ff.writable);
+80100ea8:	0f be 75 e7          	movsbl -0x19(%ebp),%esi
+80100eac:	89 1c 24             	mov    %ebx,(%esp)
+80100eaf:	89 74 24 04          	mov    %esi,0x4(%esp)
+80100eb3:	e8 b8 23 00 00       	call   80103270 <pipeclose>
+80100eb8:	eb e4                	jmp    80100e9e <fileclose+0x6e>
+80100eba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    begin_op();
+80100ec0:	e8 5b 1c 00 00       	call   80102b20 <begin_op>
+    iput(ff.ip);
+80100ec5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80100ec8:	89 04 24             	mov    %eax,(%esp)
+80100ecb:	e8 10 09 00 00       	call   801017e0 <iput>
+}
+80100ed0:	83 c4 1c             	add    $0x1c,%esp
+80100ed3:	5b                   	pop    %ebx
+80100ed4:	5e                   	pop    %esi
+80100ed5:	5f                   	pop    %edi
+80100ed6:	5d                   	pop    %ebp
+    end_op();
+80100ed7:	e9 b4 1c 00 00       	jmp    80102b90 <end_op>
+    panic("fileclose");
+80100edc:	c7 04 24 bc 6d 10 80 	movl   $0x80106dbc,(%esp)
+80100ee3:	e8 78 f4 ff ff       	call   80100360 <panic>
+80100ee8:	90                   	nop
+80100ee9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80100ef0 <filestat>:
+
+// Get metadata about file f.
+int
+filestat(struct file *f, struct stat *st)
+{
+80100ef0:	55                   	push   %ebp
+80100ef1:	89 e5                	mov    %esp,%ebp
+80100ef3:	53                   	push   %ebx
+80100ef4:	83 ec 14             	sub    $0x14,%esp
+80100ef7:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(f->type == FD_INODE){
+80100efa:	83 3b 02             	cmpl   $0x2,(%ebx)
+80100efd:	75 31                	jne    80100f30 <filestat+0x40>
+    ilock(f->ip);
+80100eff:	8b 43 10             	mov    0x10(%ebx),%eax
+80100f02:	89 04 24             	mov    %eax,(%esp)
+80100f05:	e8 b6 07 00 00       	call   801016c0 <ilock>
+    stati(f->ip, st);
+80100f0a:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100f0d:	89 44 24 04          	mov    %eax,0x4(%esp)
+80100f11:	8b 43 10             	mov    0x10(%ebx),%eax
+80100f14:	89 04 24             	mov    %eax,(%esp)
+80100f17:	e8 24 0a 00 00       	call   80101940 <stati>
+    iunlock(f->ip);
+80100f1c:	8b 43 10             	mov    0x10(%ebx),%eax
+80100f1f:	89 04 24             	mov    %eax,(%esp)
+80100f22:	e8 79 08 00 00       	call   801017a0 <iunlock>
+    return 0;
+  }
+  return -1;
+}
+80100f27:	83 c4 14             	add    $0x14,%esp
+    return 0;
+80100f2a:	31 c0                	xor    %eax,%eax
+}
+80100f2c:	5b                   	pop    %ebx
+80100f2d:	5d                   	pop    %ebp
+80100f2e:	c3                   	ret    
+80100f2f:	90                   	nop
+80100f30:	83 c4 14             	add    $0x14,%esp
+  return -1;
+80100f33:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80100f38:	5b                   	pop    %ebx
+80100f39:	5d                   	pop    %ebp
+80100f3a:	c3                   	ret    
+80100f3b:	90                   	nop
+80100f3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80100f40 <fileread>:
+
+// Read from file f.
+int
+fileread(struct file *f, char *addr, int n)
+{
+80100f40:	55                   	push   %ebp
+80100f41:	89 e5                	mov    %esp,%ebp
+80100f43:	57                   	push   %edi
+80100f44:	56                   	push   %esi
+80100f45:	53                   	push   %ebx
+80100f46:	83 ec 1c             	sub    $0x1c,%esp
+80100f49:	8b 5d 08             	mov    0x8(%ebp),%ebx
+80100f4c:	8b 75 0c             	mov    0xc(%ebp),%esi
+80100f4f:	8b 7d 10             	mov    0x10(%ebp),%edi
+  int r;
+
+  if(f->readable == 0)
+80100f52:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
+80100f56:	74 68                	je     80100fc0 <fileread+0x80>
+    return -1;
+  if(f->type == FD_PIPE)
+80100f58:	8b 03                	mov    (%ebx),%eax
+80100f5a:	83 f8 01             	cmp    $0x1,%eax
+80100f5d:	74 49                	je     80100fa8 <fileread+0x68>
+    return piperead(f->pipe, addr, n);
+  if(f->type == FD_INODE){
+80100f5f:	83 f8 02             	cmp    $0x2,%eax
+80100f62:	75 63                	jne    80100fc7 <fileread+0x87>
+    ilock(f->ip);
+80100f64:	8b 43 10             	mov    0x10(%ebx),%eax
+80100f67:	89 04 24             	mov    %eax,(%esp)
+80100f6a:	e8 51 07 00 00       	call   801016c0 <ilock>
+    if((r = readi(f->ip, addr, f->off, n)) > 0)
+80100f6f:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+80100f73:	8b 43 14             	mov    0x14(%ebx),%eax
+80100f76:	89 74 24 04          	mov    %esi,0x4(%esp)
+80100f7a:	89 44 24 08          	mov    %eax,0x8(%esp)
+80100f7e:	8b 43 10             	mov    0x10(%ebx),%eax
+80100f81:	89 04 24             	mov    %eax,(%esp)
+80100f84:	e8 e7 09 00 00       	call   80101970 <readi>
+80100f89:	85 c0                	test   %eax,%eax
+80100f8b:	89 c6                	mov    %eax,%esi
+80100f8d:	7e 03                	jle    80100f92 <fileread+0x52>
+      f->off += r;
+80100f8f:	01 43 14             	add    %eax,0x14(%ebx)
+    iunlock(f->ip);
+80100f92:	8b 43 10             	mov    0x10(%ebx),%eax
+80100f95:	89 04 24             	mov    %eax,(%esp)
+80100f98:	e8 03 08 00 00       	call   801017a0 <iunlock>
+    if((r = readi(f->ip, addr, f->off, n)) > 0)
+80100f9d:	89 f0                	mov    %esi,%eax
+    return r;
+  }
+  panic("fileread");
+}
+80100f9f:	83 c4 1c             	add    $0x1c,%esp
+80100fa2:	5b                   	pop    %ebx
+80100fa3:	5e                   	pop    %esi
+80100fa4:	5f                   	pop    %edi
+80100fa5:	5d                   	pop    %ebp
+80100fa6:	c3                   	ret    
+80100fa7:	90                   	nop
+    return piperead(f->pipe, addr, n);
+80100fa8:	8b 43 0c             	mov    0xc(%ebx),%eax
+80100fab:	89 45 08             	mov    %eax,0x8(%ebp)
+}
+80100fae:	83 c4 1c             	add    $0x1c,%esp
+80100fb1:	5b                   	pop    %ebx
+80100fb2:	5e                   	pop    %esi
+80100fb3:	5f                   	pop    %edi
+80100fb4:	5d                   	pop    %ebp
+    return piperead(f->pipe, addr, n);
+80100fb5:	e9 36 24 00 00       	jmp    801033f0 <piperead>
+80100fba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    return -1;
+80100fc0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80100fc5:	eb d8                	jmp    80100f9f <fileread+0x5f>
+  panic("fileread");
+80100fc7:	c7 04 24 c6 6d 10 80 	movl   $0x80106dc6,(%esp)
+80100fce:	e8 8d f3 ff ff       	call   80100360 <panic>
+80100fd3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80100fd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80100fe0 <filewrite>:
+
+//PAGEBREAK!
+// Write to file f.
+int
+filewrite(struct file *f, char *addr, int n)
+{
+80100fe0:	55                   	push   %ebp
+80100fe1:	89 e5                	mov    %esp,%ebp
+80100fe3:	57                   	push   %edi
+80100fe4:	56                   	push   %esi
+80100fe5:	53                   	push   %ebx
+80100fe6:	83 ec 2c             	sub    $0x2c,%esp
+80100fe9:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100fec:	8b 7d 08             	mov    0x8(%ebp),%edi
+80100fef:	89 45 dc             	mov    %eax,-0x24(%ebp)
+80100ff2:	8b 45 10             	mov    0x10(%ebp),%eax
+  int r;
+
+  if(f->writable == 0)
+80100ff5:	80 7f 09 00          	cmpb   $0x0,0x9(%edi)
+{
+80100ff9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(f->writable == 0)
+80100ffc:	0f 84 ae 00 00 00    	je     801010b0 <filewrite+0xd0>
+    return -1;
+  if(f->type == FD_PIPE)
+80101002:	8b 07                	mov    (%edi),%eax
+80101004:	83 f8 01             	cmp    $0x1,%eax
+80101007:	0f 84 c2 00 00 00    	je     801010cf <filewrite+0xef>
+    return pipewrite(f->pipe, addr, n);
+  if(f->type == FD_INODE){
+8010100d:	83 f8 02             	cmp    $0x2,%eax
+80101010:	0f 85 d7 00 00 00    	jne    801010ed <filewrite+0x10d>
+    // and 2 blocks of slop for non-aligned writes.
+    // this really belongs lower down, since writei()
+    // might be writing a device like the console.
+    int max = ((LOGSIZE-1-1-2) / 2) * 512;
+    int i = 0;
+    while(i < n){
+80101016:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80101019:	31 db                	xor    %ebx,%ebx
+8010101b:	85 c0                	test   %eax,%eax
+8010101d:	7f 31                	jg     80101050 <filewrite+0x70>
+8010101f:	e9 9c 00 00 00       	jmp    801010c0 <filewrite+0xe0>
+80101024:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+      begin_op();
+      ilock(f->ip);
+      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+        f->off += r;
+      iunlock(f->ip);
+80101028:	8b 4f 10             	mov    0x10(%edi),%ecx
+        f->off += r;
+8010102b:	01 47 14             	add    %eax,0x14(%edi)
+8010102e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+      iunlock(f->ip);
+80101031:	89 0c 24             	mov    %ecx,(%esp)
+80101034:	e8 67 07 00 00       	call   801017a0 <iunlock>
+      end_op();
+80101039:	e8 52 1b 00 00       	call   80102b90 <end_op>
+8010103e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+
+      if(r < 0)
+        break;
+      if(r != n1)
+80101041:	39 f0                	cmp    %esi,%eax
+80101043:	0f 85 98 00 00 00    	jne    801010e1 <filewrite+0x101>
+        panic("short filewrite");
+      i += r;
+80101049:	01 c3                	add    %eax,%ebx
+    while(i < n){
+8010104b:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
+8010104e:	7e 70                	jle    801010c0 <filewrite+0xe0>
+      int n1 = n - i;
+80101050:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+80101053:	b8 00 1a 00 00       	mov    $0x1a00,%eax
+80101058:	29 de                	sub    %ebx,%esi
+8010105a:	81 fe 00 1a 00 00    	cmp    $0x1a00,%esi
+80101060:	0f 4f f0             	cmovg  %eax,%esi
+      begin_op();
+80101063:	e8 b8 1a 00 00       	call   80102b20 <begin_op>
+      ilock(f->ip);
+80101068:	8b 47 10             	mov    0x10(%edi),%eax
+8010106b:	89 04 24             	mov    %eax,(%esp)
+8010106e:	e8 4d 06 00 00       	call   801016c0 <ilock>
+      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+80101073:	89 74 24 0c          	mov    %esi,0xc(%esp)
+80101077:	8b 47 14             	mov    0x14(%edi),%eax
+8010107a:	89 44 24 08          	mov    %eax,0x8(%esp)
+8010107e:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80101081:	01 d8                	add    %ebx,%eax
+80101083:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101087:	8b 47 10             	mov    0x10(%edi),%eax
+8010108a:	89 04 24             	mov    %eax,(%esp)
+8010108d:	e8 de 09 00 00       	call   80101a70 <writei>
+80101092:	85 c0                	test   %eax,%eax
+80101094:	7f 92                	jg     80101028 <filewrite+0x48>
+      iunlock(f->ip);
+80101096:	8b 4f 10             	mov    0x10(%edi),%ecx
+80101099:	89 45 e0             	mov    %eax,-0x20(%ebp)
+8010109c:	89 0c 24             	mov    %ecx,(%esp)
+8010109f:	e8 fc 06 00 00       	call   801017a0 <iunlock>
+      end_op();
+801010a4:	e8 e7 1a 00 00       	call   80102b90 <end_op>
+      if(r < 0)
+801010a9:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801010ac:	85 c0                	test   %eax,%eax
+801010ae:	74 91                	je     80101041 <filewrite+0x61>
+    }
+    return i == n ? n : -1;
+  }
+  panic("filewrite");
+}
+801010b0:	83 c4 2c             	add    $0x2c,%esp
+    return -1;
+801010b3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801010b8:	5b                   	pop    %ebx
+801010b9:	5e                   	pop    %esi
+801010ba:	5f                   	pop    %edi
+801010bb:	5d                   	pop    %ebp
+801010bc:	c3                   	ret    
+801010bd:	8d 76 00             	lea    0x0(%esi),%esi
+    return i == n ? n : -1;
+801010c0:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
+801010c3:	89 d8                	mov    %ebx,%eax
+801010c5:	75 e9                	jne    801010b0 <filewrite+0xd0>
+}
+801010c7:	83 c4 2c             	add    $0x2c,%esp
+801010ca:	5b                   	pop    %ebx
+801010cb:	5e                   	pop    %esi
+801010cc:	5f                   	pop    %edi
+801010cd:	5d                   	pop    %ebp
+801010ce:	c3                   	ret    
+    return pipewrite(f->pipe, addr, n);
+801010cf:	8b 47 0c             	mov    0xc(%edi),%eax
+801010d2:	89 45 08             	mov    %eax,0x8(%ebp)
+}
+801010d5:	83 c4 2c             	add    $0x2c,%esp
+801010d8:	5b                   	pop    %ebx
+801010d9:	5e                   	pop    %esi
+801010da:	5f                   	pop    %edi
+801010db:	5d                   	pop    %ebp
+    return pipewrite(f->pipe, addr, n);
+801010dc:	e9 1f 22 00 00       	jmp    80103300 <pipewrite>
+        panic("short filewrite");
+801010e1:	c7 04 24 cf 6d 10 80 	movl   $0x80106dcf,(%esp)
+801010e8:	e8 73 f2 ff ff       	call   80100360 <panic>
+  panic("filewrite");
+801010ed:	c7 04 24 d5 6d 10 80 	movl   $0x80106dd5,(%esp)
+801010f4:	e8 67 f2 ff ff       	call   80100360 <panic>
+801010f9:	66 90                	xchg   %ax,%ax
+801010fb:	66 90                	xchg   %ax,%ax
+801010fd:	66 90                	xchg   %ax,%ax
+801010ff:	90                   	nop
+
+80101100 <balloc>:
+// Blocks.
+
+// Allocate a zeroed disk block.
+static uint
+balloc(uint dev)
+{
+80101100:	55                   	push   %ebp
+80101101:	89 e5                	mov    %esp,%ebp
+80101103:	57                   	push   %edi
+80101104:	56                   	push   %esi
+80101105:	53                   	push   %ebx
+80101106:	83 ec 2c             	sub    $0x2c,%esp
+80101109:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  int b, bi, m;
+  struct buf *bp;
+
+  bp = 0;
+  for(b = 0; b < sb.size; b += BPB){
+8010110c:	a1 c0 09 11 80       	mov    0x801109c0,%eax
+80101111:	85 c0                	test   %eax,%eax
+80101113:	0f 84 8c 00 00 00    	je     801011a5 <balloc+0xa5>
+80101119:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+    bp = bread(dev, BBLOCK(b, sb));
+80101120:	8b 75 dc             	mov    -0x24(%ebp),%esi
+80101123:	89 f0                	mov    %esi,%eax
+80101125:	c1 f8 0c             	sar    $0xc,%eax
+80101128:	03 05 d8 09 11 80    	add    0x801109d8,%eax
+8010112e:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101132:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80101135:	89 04 24             	mov    %eax,(%esp)
+80101138:	e8 93 ef ff ff       	call   801000d0 <bread>
+8010113d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80101140:	a1 c0 09 11 80       	mov    0x801109c0,%eax
+80101145:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+80101148:	31 c0                	xor    %eax,%eax
+8010114a:	eb 33                	jmp    8010117f <balloc+0x7f>
+8010114c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      m = 1 << (bi % 8);
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+80101150:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+80101153:	89 c2                	mov    %eax,%edx
+      m = 1 << (bi % 8);
+80101155:	89 c1                	mov    %eax,%ecx
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+80101157:	c1 fa 03             	sar    $0x3,%edx
+      m = 1 << (bi % 8);
+8010115a:	83 e1 07             	and    $0x7,%ecx
+8010115d:	bf 01 00 00 00       	mov    $0x1,%edi
+80101162:	d3 e7                	shl    %cl,%edi
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+80101164:	0f b6 5c 13 5c       	movzbl 0x5c(%ebx,%edx,1),%ebx
+      m = 1 << (bi % 8);
+80101169:	89 f9                	mov    %edi,%ecx
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+8010116b:	0f b6 fb             	movzbl %bl,%edi
+8010116e:	85 cf                	test   %ecx,%edi
+80101170:	74 46                	je     801011b8 <balloc+0xb8>
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+80101172:	83 c0 01             	add    $0x1,%eax
+80101175:	83 c6 01             	add    $0x1,%esi
+80101178:	3d 00 10 00 00       	cmp    $0x1000,%eax
+8010117d:	74 05                	je     80101184 <balloc+0x84>
+8010117f:	3b 75 e0             	cmp    -0x20(%ebp),%esi
+80101182:	72 cc                	jb     80101150 <balloc+0x50>
+        brelse(bp);
+        bzero(dev, b + bi);
+        return b + bi;
+      }
+    }
+    brelse(bp);
+80101184:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80101187:	89 04 24             	mov    %eax,(%esp)
+8010118a:	e8 51 f0 ff ff       	call   801001e0 <brelse>
+  for(b = 0; b < sb.size; b += BPB){
+8010118f:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
+80101196:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80101199:	3b 05 c0 09 11 80    	cmp    0x801109c0,%eax
+8010119f:	0f 82 7b ff ff ff    	jb     80101120 <balloc+0x20>
+  }
+  panic("balloc: out of blocks");
+801011a5:	c7 04 24 df 6d 10 80 	movl   $0x80106ddf,(%esp)
+801011ac:	e8 af f1 ff ff       	call   80100360 <panic>
+801011b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        bp->data[bi/8] |= m;  // Mark block in use.
+801011b8:	09 d9                	or     %ebx,%ecx
+801011ba:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+801011bd:	88 4c 13 5c          	mov    %cl,0x5c(%ebx,%edx,1)
+        log_write(bp);
+801011c1:	89 1c 24             	mov    %ebx,(%esp)
+801011c4:	e8 f7 1a 00 00       	call   80102cc0 <log_write>
+        brelse(bp);
+801011c9:	89 1c 24             	mov    %ebx,(%esp)
+801011cc:	e8 0f f0 ff ff       	call   801001e0 <brelse>
+  bp = bread(dev, bno);
+801011d1:	8b 45 d8             	mov    -0x28(%ebp),%eax
+801011d4:	89 74 24 04          	mov    %esi,0x4(%esp)
+801011d8:	89 04 24             	mov    %eax,(%esp)
+801011db:	e8 f0 ee ff ff       	call   801000d0 <bread>
+  memset(bp->data, 0, BSIZE);
+801011e0:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+801011e7:	00 
+801011e8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+801011ef:	00 
+  bp = bread(dev, bno);
+801011f0:	89 c3                	mov    %eax,%ebx
+  memset(bp->data, 0, BSIZE);
+801011f2:	8d 40 5c             	lea    0x5c(%eax),%eax
+801011f5:	89 04 24             	mov    %eax,(%esp)
+801011f8:	e8 93 30 00 00       	call   80104290 <memset>
+  log_write(bp);
+801011fd:	89 1c 24             	mov    %ebx,(%esp)
+80101200:	e8 bb 1a 00 00       	call   80102cc0 <log_write>
+  brelse(bp);
+80101205:	89 1c 24             	mov    %ebx,(%esp)
+80101208:	e8 d3 ef ff ff       	call   801001e0 <brelse>
+}
+8010120d:	83 c4 2c             	add    $0x2c,%esp
+80101210:	89 f0                	mov    %esi,%eax
+80101212:	5b                   	pop    %ebx
+80101213:	5e                   	pop    %esi
+80101214:	5f                   	pop    %edi
+80101215:	5d                   	pop    %ebp
+80101216:	c3                   	ret    
+80101217:	89 f6                	mov    %esi,%esi
+80101219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80101220 <iget>:
+// Find the inode with number inum on device dev
+// and return the in-memory copy. Does not lock
+// the inode and does not read it from disk.
+static struct inode*
+iget(uint dev, uint inum)
+{
+80101220:	55                   	push   %ebp
+80101221:	89 e5                	mov    %esp,%ebp
+80101223:	57                   	push   %edi
+80101224:	89 c7                	mov    %eax,%edi
+80101226:	56                   	push   %esi
+  struct inode *ip, *empty;
+
+  acquire(&icache.lock);
+
+  // Is the inode already cached?
+  empty = 0;
+80101227:	31 f6                	xor    %esi,%esi
+{
+80101229:	53                   	push   %ebx
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+8010122a:	bb 14 0a 11 80       	mov    $0x80110a14,%ebx
+{
+8010122f:	83 ec 1c             	sub    $0x1c,%esp
+  acquire(&icache.lock);
+80101232:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+{
+80101239:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  acquire(&icache.lock);
+8010123c:	e8 0f 2f 00 00       	call   80104150 <acquire>
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+80101241:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80101244:	eb 14                	jmp    8010125a <iget+0x3a>
+80101246:	66 90                	xchg   %ax,%ax
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+      ip->ref++;
+      release(&icache.lock);
+      return ip;
+    }
+    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+80101248:	85 f6                	test   %esi,%esi
+8010124a:	74 3c                	je     80101288 <iget+0x68>
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+8010124c:	81 c3 90 00 00 00    	add    $0x90,%ebx
+80101252:	81 fb 34 26 11 80    	cmp    $0x80112634,%ebx
+80101258:	74 46                	je     801012a0 <iget+0x80>
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+8010125a:	8b 4b 08             	mov    0x8(%ebx),%ecx
+8010125d:	85 c9                	test   %ecx,%ecx
+8010125f:	7e e7                	jle    80101248 <iget+0x28>
+80101261:	39 3b                	cmp    %edi,(%ebx)
+80101263:	75 e3                	jne    80101248 <iget+0x28>
+80101265:	39 53 04             	cmp    %edx,0x4(%ebx)
+80101268:	75 de                	jne    80101248 <iget+0x28>
+      ip->ref++;
+8010126a:	83 c1 01             	add    $0x1,%ecx
+      return ip;
+8010126d:	89 de                	mov    %ebx,%esi
+      release(&icache.lock);
+8010126f:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+      ip->ref++;
+80101276:	89 4b 08             	mov    %ecx,0x8(%ebx)
+      release(&icache.lock);
+80101279:	e8 c2 2f 00 00       	call   80104240 <release>
+  ip->ref = 1;
+  ip->valid = 0;
+  release(&icache.lock);
+
+  return ip;
+}
+8010127e:	83 c4 1c             	add    $0x1c,%esp
+80101281:	89 f0                	mov    %esi,%eax
+80101283:	5b                   	pop    %ebx
+80101284:	5e                   	pop    %esi
+80101285:	5f                   	pop    %edi
+80101286:	5d                   	pop    %ebp
+80101287:	c3                   	ret    
+80101288:	85 c9                	test   %ecx,%ecx
+8010128a:	0f 44 f3             	cmove  %ebx,%esi
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+8010128d:	81 c3 90 00 00 00    	add    $0x90,%ebx
+80101293:	81 fb 34 26 11 80    	cmp    $0x80112634,%ebx
+80101299:	75 bf                	jne    8010125a <iget+0x3a>
+8010129b:	90                   	nop
+8010129c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  if(empty == 0)
+801012a0:	85 f6                	test   %esi,%esi
+801012a2:	74 29                	je     801012cd <iget+0xad>
+  ip->dev = dev;
+801012a4:	89 3e                	mov    %edi,(%esi)
+  ip->inum = inum;
+801012a6:	89 56 04             	mov    %edx,0x4(%esi)
+  ip->ref = 1;
+801012a9:	c7 46 08 01 00 00 00 	movl   $0x1,0x8(%esi)
+  ip->valid = 0;
+801012b0:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
+  release(&icache.lock);
+801012b7:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+801012be:	e8 7d 2f 00 00       	call   80104240 <release>
+}
+801012c3:	83 c4 1c             	add    $0x1c,%esp
+801012c6:	89 f0                	mov    %esi,%eax
+801012c8:	5b                   	pop    %ebx
+801012c9:	5e                   	pop    %esi
+801012ca:	5f                   	pop    %edi
+801012cb:	5d                   	pop    %ebp
+801012cc:	c3                   	ret    
+    panic("iget: no inodes");
+801012cd:	c7 04 24 f5 6d 10 80 	movl   $0x80106df5,(%esp)
+801012d4:	e8 87 f0 ff ff       	call   80100360 <panic>
+801012d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+801012e0 <bmap>:
+
+// Return the disk block address of the nth block in inode ip.
+// If there is no such block, bmap allocates one.
+static uint
+bmap(struct inode *ip, uint bn)
+{
+801012e0:	55                   	push   %ebp
+801012e1:	89 e5                	mov    %esp,%ebp
+801012e3:	57                   	push   %edi
+801012e4:	56                   	push   %esi
+801012e5:	53                   	push   %ebx
+801012e6:	89 c3                	mov    %eax,%ebx
+801012e8:	83 ec 1c             	sub    $0x1c,%esp
+  uint addr, *a;
+  struct buf *bp;
+
+  if(bn < NDIRECT){
+801012eb:	83 fa 0b             	cmp    $0xb,%edx
+801012ee:	77 18                	ja     80101308 <bmap+0x28>
+801012f0:	8d 34 90             	lea    (%eax,%edx,4),%esi
+    if((addr = ip->addrs[bn]) == 0)
+801012f3:	8b 46 5c             	mov    0x5c(%esi),%eax
+801012f6:	85 c0                	test   %eax,%eax
+801012f8:	74 66                	je     80101360 <bmap+0x80>
+    brelse(bp);
+    return addr;
+  }
+
+  panic("bmap: out of range");
+}
+801012fa:	83 c4 1c             	add    $0x1c,%esp
+801012fd:	5b                   	pop    %ebx
+801012fe:	5e                   	pop    %esi
+801012ff:	5f                   	pop    %edi
+80101300:	5d                   	pop    %ebp
+80101301:	c3                   	ret    
+80101302:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  bn -= NDIRECT;
+80101308:	8d 72 f4             	lea    -0xc(%edx),%esi
+  if(bn < NINDIRECT){
+8010130b:	83 fe 7f             	cmp    $0x7f,%esi
+8010130e:	77 77                	ja     80101387 <bmap+0xa7>
+    if((addr = ip->addrs[NDIRECT]) == 0)
+80101310:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
+80101316:	85 c0                	test   %eax,%eax
+80101318:	74 5e                	je     80101378 <bmap+0x98>
+    bp = bread(ip->dev, addr);
+8010131a:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010131e:	8b 03                	mov    (%ebx),%eax
+80101320:	89 04 24             	mov    %eax,(%esp)
+80101323:	e8 a8 ed ff ff       	call   801000d0 <bread>
+    if((addr = a[bn]) == 0){
+80101328:	8d 54 b0 5c          	lea    0x5c(%eax,%esi,4),%edx
+    bp = bread(ip->dev, addr);
+8010132c:	89 c7                	mov    %eax,%edi
+    if((addr = a[bn]) == 0){
+8010132e:	8b 32                	mov    (%edx),%esi
+80101330:	85 f6                	test   %esi,%esi
+80101332:	75 19                	jne    8010134d <bmap+0x6d>
+      a[bn] = addr = balloc(ip->dev);
+80101334:	8b 03                	mov    (%ebx),%eax
+80101336:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+80101339:	e8 c2 fd ff ff       	call   80101100 <balloc>
+8010133e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80101341:	89 02                	mov    %eax,(%edx)
+80101343:	89 c6                	mov    %eax,%esi
+      log_write(bp);
+80101345:	89 3c 24             	mov    %edi,(%esp)
+80101348:	e8 73 19 00 00       	call   80102cc0 <log_write>
+    brelse(bp);
+8010134d:	89 3c 24             	mov    %edi,(%esp)
+80101350:	e8 8b ee ff ff       	call   801001e0 <brelse>
+}
+80101355:	83 c4 1c             	add    $0x1c,%esp
+    brelse(bp);
+80101358:	89 f0                	mov    %esi,%eax
+}
+8010135a:	5b                   	pop    %ebx
+8010135b:	5e                   	pop    %esi
+8010135c:	5f                   	pop    %edi
+8010135d:	5d                   	pop    %ebp
+8010135e:	c3                   	ret    
+8010135f:	90                   	nop
+      ip->addrs[bn] = addr = balloc(ip->dev);
+80101360:	8b 03                	mov    (%ebx),%eax
+80101362:	e8 99 fd ff ff       	call   80101100 <balloc>
+80101367:	89 46 5c             	mov    %eax,0x5c(%esi)
+}
+8010136a:	83 c4 1c             	add    $0x1c,%esp
+8010136d:	5b                   	pop    %ebx
+8010136e:	5e                   	pop    %esi
+8010136f:	5f                   	pop    %edi
+80101370:	5d                   	pop    %ebp
+80101371:	c3                   	ret    
+80101372:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+80101378:	8b 03                	mov    (%ebx),%eax
+8010137a:	e8 81 fd ff ff       	call   80101100 <balloc>
+8010137f:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
+80101385:	eb 93                	jmp    8010131a <bmap+0x3a>
+  panic("bmap: out of range");
+80101387:	c7 04 24 05 6e 10 80 	movl   $0x80106e05,(%esp)
+8010138e:	e8 cd ef ff ff       	call   80100360 <panic>
+80101393:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80101399:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801013a0 <readsb>:
+{
+801013a0:	55                   	push   %ebp
+801013a1:	89 e5                	mov    %esp,%ebp
+801013a3:	56                   	push   %esi
+801013a4:	53                   	push   %ebx
+801013a5:	83 ec 10             	sub    $0x10,%esp
+  bp = bread(dev, 1);
+801013a8:	8b 45 08             	mov    0x8(%ebp),%eax
+801013ab:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+801013b2:	00 
+{
+801013b3:	8b 75 0c             	mov    0xc(%ebp),%esi
+  bp = bread(dev, 1);
+801013b6:	89 04 24             	mov    %eax,(%esp)
+801013b9:	e8 12 ed ff ff       	call   801000d0 <bread>
+  memmove(sb, bp->data, sizeof(*sb));
+801013be:	89 34 24             	mov    %esi,(%esp)
+801013c1:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
+801013c8:	00 
+  bp = bread(dev, 1);
+801013c9:	89 c3                	mov    %eax,%ebx
+  memmove(sb, bp->data, sizeof(*sb));
+801013cb:	8d 40 5c             	lea    0x5c(%eax),%eax
+801013ce:	89 44 24 04          	mov    %eax,0x4(%esp)
+801013d2:	e8 59 2f 00 00       	call   80104330 <memmove>
+  brelse(bp);
+801013d7:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+801013da:	83 c4 10             	add    $0x10,%esp
+801013dd:	5b                   	pop    %ebx
+801013de:	5e                   	pop    %esi
+801013df:	5d                   	pop    %ebp
+  brelse(bp);
+801013e0:	e9 fb ed ff ff       	jmp    801001e0 <brelse>
+801013e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801013e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801013f0 <bfree>:
+{
+801013f0:	55                   	push   %ebp
+801013f1:	89 e5                	mov    %esp,%ebp
+801013f3:	57                   	push   %edi
+801013f4:	89 d7                	mov    %edx,%edi
+801013f6:	56                   	push   %esi
+801013f7:	53                   	push   %ebx
+801013f8:	89 c3                	mov    %eax,%ebx
+801013fa:	83 ec 1c             	sub    $0x1c,%esp
+  readsb(dev, &sb);
+801013fd:	89 04 24             	mov    %eax,(%esp)
+80101400:	c7 44 24 04 c0 09 11 	movl   $0x801109c0,0x4(%esp)
+80101407:	80 
+80101408:	e8 93 ff ff ff       	call   801013a0 <readsb>
+  bp = bread(dev, BBLOCK(b, sb));
+8010140d:	89 fa                	mov    %edi,%edx
+8010140f:	c1 ea 0c             	shr    $0xc,%edx
+80101412:	03 15 d8 09 11 80    	add    0x801109d8,%edx
+80101418:	89 1c 24             	mov    %ebx,(%esp)
+  m = 1 << (bi % 8);
+8010141b:	bb 01 00 00 00       	mov    $0x1,%ebx
+  bp = bread(dev, BBLOCK(b, sb));
+80101420:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101424:	e8 a7 ec ff ff       	call   801000d0 <bread>
+  m = 1 << (bi % 8);
+80101429:	89 f9                	mov    %edi,%ecx
+  bi = b % BPB;
+8010142b:	81 e7 ff 0f 00 00    	and    $0xfff,%edi
+80101431:	89 fa                	mov    %edi,%edx
+  m = 1 << (bi % 8);
+80101433:	83 e1 07             	and    $0x7,%ecx
+  if((bp->data[bi/8] & m) == 0)
+80101436:	c1 fa 03             	sar    $0x3,%edx
+  m = 1 << (bi % 8);
+80101439:	d3 e3                	shl    %cl,%ebx
+  bp = bread(dev, BBLOCK(b, sb));
+8010143b:	89 c6                	mov    %eax,%esi
+  if((bp->data[bi/8] & m) == 0)
+8010143d:	0f b6 44 10 5c       	movzbl 0x5c(%eax,%edx,1),%eax
+80101442:	0f b6 c8             	movzbl %al,%ecx
+80101445:	85 d9                	test   %ebx,%ecx
+80101447:	74 20                	je     80101469 <bfree+0x79>
+  bp->data[bi/8] &= ~m;
+80101449:	f7 d3                	not    %ebx
+8010144b:	21 c3                	and    %eax,%ebx
+8010144d:	88 5c 16 5c          	mov    %bl,0x5c(%esi,%edx,1)
+  log_write(bp);
+80101451:	89 34 24             	mov    %esi,(%esp)
+80101454:	e8 67 18 00 00       	call   80102cc0 <log_write>
+  brelse(bp);
+80101459:	89 34 24             	mov    %esi,(%esp)
+8010145c:	e8 7f ed ff ff       	call   801001e0 <brelse>
+}
+80101461:	83 c4 1c             	add    $0x1c,%esp
+80101464:	5b                   	pop    %ebx
+80101465:	5e                   	pop    %esi
+80101466:	5f                   	pop    %edi
+80101467:	5d                   	pop    %ebp
+80101468:	c3                   	ret    
+    panic("freeing free block");
+80101469:	c7 04 24 18 6e 10 80 	movl   $0x80106e18,(%esp)
+80101470:	e8 eb ee ff ff       	call   80100360 <panic>
+80101475:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80101479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80101480 <iinit>:
+{
+80101480:	55                   	push   %ebp
+80101481:	89 e5                	mov    %esp,%ebp
+80101483:	53                   	push   %ebx
+80101484:	bb 20 0a 11 80       	mov    $0x80110a20,%ebx
+80101489:	83 ec 24             	sub    $0x24,%esp
+  initlock(&icache.lock, "icache");
+8010148c:	c7 44 24 04 2b 6e 10 	movl   $0x80106e2b,0x4(%esp)
+80101493:	80 
+80101494:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+8010149b:	e8 c0 2b 00 00       	call   80104060 <initlock>
+    initsleeplock(&icache.inode[i].lock, "inode");
+801014a0:	89 1c 24             	mov    %ebx,(%esp)
+801014a3:	81 c3 90 00 00 00    	add    $0x90,%ebx
+801014a9:	c7 44 24 04 32 6e 10 	movl   $0x80106e32,0x4(%esp)
+801014b0:	80 
+801014b1:	e8 9a 2a 00 00       	call   80103f50 <initsleeplock>
+  for(i = 0; i < NINODE; i++) {
+801014b6:	81 fb 40 26 11 80    	cmp    $0x80112640,%ebx
+801014bc:	75 e2                	jne    801014a0 <iinit+0x20>
+  readsb(dev, &sb);
+801014be:	8b 45 08             	mov    0x8(%ebp),%eax
+801014c1:	c7 44 24 04 c0 09 11 	movl   $0x801109c0,0x4(%esp)
+801014c8:	80 
+801014c9:	89 04 24             	mov    %eax,(%esp)
+801014cc:	e8 cf fe ff ff       	call   801013a0 <readsb>
+  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
+801014d1:	a1 d8 09 11 80       	mov    0x801109d8,%eax
+801014d6:	c7 04 24 98 6e 10 80 	movl   $0x80106e98,(%esp)
+801014dd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
+801014e1:	a1 d4 09 11 80       	mov    0x801109d4,%eax
+801014e6:	89 44 24 18          	mov    %eax,0x18(%esp)
+801014ea:	a1 d0 09 11 80       	mov    0x801109d0,%eax
+801014ef:	89 44 24 14          	mov    %eax,0x14(%esp)
+801014f3:	a1 cc 09 11 80       	mov    0x801109cc,%eax
+801014f8:	89 44 24 10          	mov    %eax,0x10(%esp)
+801014fc:	a1 c8 09 11 80       	mov    0x801109c8,%eax
+80101501:	89 44 24 0c          	mov    %eax,0xc(%esp)
+80101505:	a1 c4 09 11 80       	mov    0x801109c4,%eax
+8010150a:	89 44 24 08          	mov    %eax,0x8(%esp)
+8010150e:	a1 c0 09 11 80       	mov    0x801109c0,%eax
+80101513:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101517:	e8 34 f1 ff ff       	call   80100650 <cprintf>
+}
+8010151c:	83 c4 24             	add    $0x24,%esp
+8010151f:	5b                   	pop    %ebx
+80101520:	5d                   	pop    %ebp
+80101521:	c3                   	ret    
+80101522:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101529:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80101530 <ialloc>:
+{
+80101530:	55                   	push   %ebp
+80101531:	89 e5                	mov    %esp,%ebp
+80101533:	57                   	push   %edi
+80101534:	56                   	push   %esi
+80101535:	53                   	push   %ebx
+80101536:	83 ec 2c             	sub    $0x2c,%esp
+80101539:	8b 45 0c             	mov    0xc(%ebp),%eax
+  for(inum = 1; inum < sb.ninodes; inum++){
+8010153c:	83 3d c8 09 11 80 01 	cmpl   $0x1,0x801109c8
+{
+80101543:	8b 7d 08             	mov    0x8(%ebp),%edi
+80101546:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  for(inum = 1; inum < sb.ninodes; inum++){
+80101549:	0f 86 a2 00 00 00    	jbe    801015f1 <ialloc+0xc1>
+8010154f:	be 01 00 00 00       	mov    $0x1,%esi
+80101554:	bb 01 00 00 00       	mov    $0x1,%ebx
+80101559:	eb 1a                	jmp    80101575 <ialloc+0x45>
+8010155b:	90                   	nop
+8010155c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    brelse(bp);
+80101560:	89 14 24             	mov    %edx,(%esp)
+  for(inum = 1; inum < sb.ninodes; inum++){
+80101563:	83 c3 01             	add    $0x1,%ebx
+    brelse(bp);
+80101566:	e8 75 ec ff ff       	call   801001e0 <brelse>
+  for(inum = 1; inum < sb.ninodes; inum++){
+8010156b:	89 de                	mov    %ebx,%esi
+8010156d:	3b 1d c8 09 11 80    	cmp    0x801109c8,%ebx
+80101573:	73 7c                	jae    801015f1 <ialloc+0xc1>
+    bp = bread(dev, IBLOCK(inum, sb));
+80101575:	89 f0                	mov    %esi,%eax
+80101577:	c1 e8 03             	shr    $0x3,%eax
+8010157a:	03 05 d4 09 11 80    	add    0x801109d4,%eax
+80101580:	89 3c 24             	mov    %edi,(%esp)
+80101583:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101587:	e8 44 eb ff ff       	call   801000d0 <bread>
+8010158c:	89 c2                	mov    %eax,%edx
+    dip = (struct dinode*)bp->data + inum%IPB;
+8010158e:	89 f0                	mov    %esi,%eax
+80101590:	83 e0 07             	and    $0x7,%eax
+80101593:	c1 e0 06             	shl    $0x6,%eax
+80101596:	8d 4c 02 5c          	lea    0x5c(%edx,%eax,1),%ecx
+    if(dip->type == 0){  // a free inode
+8010159a:	66 83 39 00          	cmpw   $0x0,(%ecx)
+8010159e:	75 c0                	jne    80101560 <ialloc+0x30>
+      memset(dip, 0, sizeof(*dip));
+801015a0:	89 0c 24             	mov    %ecx,(%esp)
+801015a3:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
+801015aa:	00 
+801015ab:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+801015b2:	00 
+801015b3:	89 55 dc             	mov    %edx,-0x24(%ebp)
+801015b6:	89 4d e0             	mov    %ecx,-0x20(%ebp)
+801015b9:	e8 d2 2c 00 00       	call   80104290 <memset>
+      dip->type = type;
+801015be:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
+      log_write(bp);   // mark it allocated on the disk
+801015c2:	8b 55 dc             	mov    -0x24(%ebp),%edx
+      dip->type = type;
+801015c5:	8b 4d e0             	mov    -0x20(%ebp),%ecx
+      log_write(bp);   // mark it allocated on the disk
+801015c8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+      dip->type = type;
+801015cb:	66 89 01             	mov    %ax,(%ecx)
+      log_write(bp);   // mark it allocated on the disk
+801015ce:	89 14 24             	mov    %edx,(%esp)
+801015d1:	e8 ea 16 00 00       	call   80102cc0 <log_write>
+      brelse(bp);
+801015d6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+801015d9:	89 14 24             	mov    %edx,(%esp)
+801015dc:	e8 ff eb ff ff       	call   801001e0 <brelse>
+}
+801015e1:	83 c4 2c             	add    $0x2c,%esp
+      return iget(dev, inum);
+801015e4:	89 f2                	mov    %esi,%edx
+}
+801015e6:	5b                   	pop    %ebx
+      return iget(dev, inum);
+801015e7:	89 f8                	mov    %edi,%eax
+}
+801015e9:	5e                   	pop    %esi
+801015ea:	5f                   	pop    %edi
+801015eb:	5d                   	pop    %ebp
+      return iget(dev, inum);
+801015ec:	e9 2f fc ff ff       	jmp    80101220 <iget>
+  panic("ialloc: no inodes");
+801015f1:	c7 04 24 38 6e 10 80 	movl   $0x80106e38,(%esp)
+801015f8:	e8 63 ed ff ff       	call   80100360 <panic>
+801015fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+80101600 <iupdate>:
+{
+80101600:	55                   	push   %ebp
+80101601:	89 e5                	mov    %esp,%ebp
+80101603:	56                   	push   %esi
+80101604:	53                   	push   %ebx
+80101605:	83 ec 10             	sub    $0x10,%esp
+80101608:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+8010160b:	8b 43 04             	mov    0x4(%ebx),%eax
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+8010160e:	83 c3 5c             	add    $0x5c,%ebx
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+80101611:	c1 e8 03             	shr    $0x3,%eax
+80101614:	03 05 d4 09 11 80    	add    0x801109d4,%eax
+8010161a:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010161e:	8b 43 a4             	mov    -0x5c(%ebx),%eax
+80101621:	89 04 24             	mov    %eax,(%esp)
+80101624:	e8 a7 ea ff ff       	call   801000d0 <bread>
+  dip = (struct dinode*)bp->data + ip->inum%IPB;
+80101629:	8b 53 a8             	mov    -0x58(%ebx),%edx
+8010162c:	83 e2 07             	and    $0x7,%edx
+8010162f:	c1 e2 06             	shl    $0x6,%edx
+80101632:	8d 54 10 5c          	lea    0x5c(%eax,%edx,1),%edx
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+80101636:	89 c6                	mov    %eax,%esi
+  dip->type = ip->type;
+80101638:	0f b7 43 f4          	movzwl -0xc(%ebx),%eax
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+8010163c:	83 c2 0c             	add    $0xc,%edx
+  dip->type = ip->type;
+8010163f:	66 89 42 f4          	mov    %ax,-0xc(%edx)
+  dip->major = ip->major;
+80101643:	0f b7 43 f6          	movzwl -0xa(%ebx),%eax
+80101647:	66 89 42 f6          	mov    %ax,-0xa(%edx)
+  dip->minor = ip->minor;
+8010164b:	0f b7 43 f8          	movzwl -0x8(%ebx),%eax
+8010164f:	66 89 42 f8          	mov    %ax,-0x8(%edx)
+  dip->nlink = ip->nlink;
+80101653:	0f b7 43 fa          	movzwl -0x6(%ebx),%eax
+80101657:	66 89 42 fa          	mov    %ax,-0x6(%edx)
+  dip->size = ip->size;
+8010165b:	8b 43 fc             	mov    -0x4(%ebx),%eax
+8010165e:	89 42 fc             	mov    %eax,-0x4(%edx)
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+80101661:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80101665:	89 14 24             	mov    %edx,(%esp)
+80101668:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
+8010166f:	00 
+80101670:	e8 bb 2c 00 00       	call   80104330 <memmove>
+  log_write(bp);
+80101675:	89 34 24             	mov    %esi,(%esp)
+80101678:	e8 43 16 00 00       	call   80102cc0 <log_write>
+  brelse(bp);
+8010167d:	89 75 08             	mov    %esi,0x8(%ebp)
+}
+80101680:	83 c4 10             	add    $0x10,%esp
+80101683:	5b                   	pop    %ebx
+80101684:	5e                   	pop    %esi
+80101685:	5d                   	pop    %ebp
+  brelse(bp);
+80101686:	e9 55 eb ff ff       	jmp    801001e0 <brelse>
+8010168b:	90                   	nop
+8010168c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80101690 <idup>:
+{
+80101690:	55                   	push   %ebp
+80101691:	89 e5                	mov    %esp,%ebp
+80101693:	53                   	push   %ebx
+80101694:	83 ec 14             	sub    $0x14,%esp
+80101697:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&icache.lock);
+8010169a:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+801016a1:	e8 aa 2a 00 00       	call   80104150 <acquire>
+  ip->ref++;
+801016a6:	83 43 08 01          	addl   $0x1,0x8(%ebx)
+  release(&icache.lock);
+801016aa:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+801016b1:	e8 8a 2b 00 00       	call   80104240 <release>
+}
+801016b6:	83 c4 14             	add    $0x14,%esp
+801016b9:	89 d8                	mov    %ebx,%eax
+801016bb:	5b                   	pop    %ebx
+801016bc:	5d                   	pop    %ebp
+801016bd:	c3                   	ret    
+801016be:	66 90                	xchg   %ax,%ax
+
+801016c0 <ilock>:
+{
+801016c0:	55                   	push   %ebp
+801016c1:	89 e5                	mov    %esp,%ebp
+801016c3:	56                   	push   %esi
+801016c4:	53                   	push   %ebx
+801016c5:	83 ec 10             	sub    $0x10,%esp
+801016c8:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(ip == 0 || ip->ref < 1)
+801016cb:	85 db                	test   %ebx,%ebx
+801016cd:	0f 84 b3 00 00 00    	je     80101786 <ilock+0xc6>
+801016d3:	8b 53 08             	mov    0x8(%ebx),%edx
+801016d6:	85 d2                	test   %edx,%edx
+801016d8:	0f 8e a8 00 00 00    	jle    80101786 <ilock+0xc6>
+  acquiresleep(&ip->lock);
+801016de:	8d 43 0c             	lea    0xc(%ebx),%eax
+801016e1:	89 04 24             	mov    %eax,(%esp)
+801016e4:	e8 a7 28 00 00       	call   80103f90 <acquiresleep>
+  if(ip->valid == 0){
+801016e9:	8b 43 4c             	mov    0x4c(%ebx),%eax
+801016ec:	85 c0                	test   %eax,%eax
+801016ee:	74 08                	je     801016f8 <ilock+0x38>
+}
+801016f0:	83 c4 10             	add    $0x10,%esp
+801016f3:	5b                   	pop    %ebx
+801016f4:	5e                   	pop    %esi
+801016f5:	5d                   	pop    %ebp
+801016f6:	c3                   	ret    
+801016f7:	90                   	nop
+    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+801016f8:	8b 43 04             	mov    0x4(%ebx),%eax
+801016fb:	c1 e8 03             	shr    $0x3,%eax
+801016fe:	03 05 d4 09 11 80    	add    0x801109d4,%eax
+80101704:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101708:	8b 03                	mov    (%ebx),%eax
+8010170a:	89 04 24             	mov    %eax,(%esp)
+8010170d:	e8 be e9 ff ff       	call   801000d0 <bread>
+    dip = (struct dinode*)bp->data + ip->inum%IPB;
+80101712:	8b 53 04             	mov    0x4(%ebx),%edx
+80101715:	83 e2 07             	and    $0x7,%edx
+80101718:	c1 e2 06             	shl    $0x6,%edx
+8010171b:	8d 54 10 5c          	lea    0x5c(%eax,%edx,1),%edx
+    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+8010171f:	89 c6                	mov    %eax,%esi
+    ip->type = dip->type;
+80101721:	0f b7 02             	movzwl (%edx),%eax
+    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+80101724:	83 c2 0c             	add    $0xc,%edx
+    ip->type = dip->type;
+80101727:	66 89 43 50          	mov    %ax,0x50(%ebx)
+    ip->major = dip->major;
+8010172b:	0f b7 42 f6          	movzwl -0xa(%edx),%eax
+8010172f:	66 89 43 52          	mov    %ax,0x52(%ebx)
+    ip->minor = dip->minor;
+80101733:	0f b7 42 f8          	movzwl -0x8(%edx),%eax
+80101737:	66 89 43 54          	mov    %ax,0x54(%ebx)
+    ip->nlink = dip->nlink;
+8010173b:	0f b7 42 fa          	movzwl -0x6(%edx),%eax
+8010173f:	66 89 43 56          	mov    %ax,0x56(%ebx)
+    ip->size = dip->size;
+80101743:	8b 42 fc             	mov    -0x4(%edx),%eax
+80101746:	89 43 58             	mov    %eax,0x58(%ebx)
+    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+80101749:	8d 43 5c             	lea    0x5c(%ebx),%eax
+8010174c:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101750:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
+80101757:	00 
+80101758:	89 04 24             	mov    %eax,(%esp)
+8010175b:	e8 d0 2b 00 00       	call   80104330 <memmove>
+    brelse(bp);
+80101760:	89 34 24             	mov    %esi,(%esp)
+80101763:	e8 78 ea ff ff       	call   801001e0 <brelse>
+    if(ip->type == 0)
+80101768:	66 83 7b 50 00       	cmpw   $0x0,0x50(%ebx)
+    ip->valid = 1;
+8010176d:	c7 43 4c 01 00 00 00 	movl   $0x1,0x4c(%ebx)
+    if(ip->type == 0)
+80101774:	0f 85 76 ff ff ff    	jne    801016f0 <ilock+0x30>
+      panic("ilock: no type");
+8010177a:	c7 04 24 50 6e 10 80 	movl   $0x80106e50,(%esp)
+80101781:	e8 da eb ff ff       	call   80100360 <panic>
+    panic("ilock");
+80101786:	c7 04 24 4a 6e 10 80 	movl   $0x80106e4a,(%esp)
+8010178d:	e8 ce eb ff ff       	call   80100360 <panic>
+80101792:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101799:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801017a0 <iunlock>:
+{
+801017a0:	55                   	push   %ebp
+801017a1:	89 e5                	mov    %esp,%ebp
+801017a3:	56                   	push   %esi
+801017a4:	53                   	push   %ebx
+801017a5:	83 ec 10             	sub    $0x10,%esp
+801017a8:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+801017ab:	85 db                	test   %ebx,%ebx
+801017ad:	74 24                	je     801017d3 <iunlock+0x33>
+801017af:	8d 73 0c             	lea    0xc(%ebx),%esi
+801017b2:	89 34 24             	mov    %esi,(%esp)
+801017b5:	e8 76 28 00 00       	call   80104030 <holdingsleep>
+801017ba:	85 c0                	test   %eax,%eax
+801017bc:	74 15                	je     801017d3 <iunlock+0x33>
+801017be:	8b 43 08             	mov    0x8(%ebx),%eax
+801017c1:	85 c0                	test   %eax,%eax
+801017c3:	7e 0e                	jle    801017d3 <iunlock+0x33>
+  releasesleep(&ip->lock);
+801017c5:	89 75 08             	mov    %esi,0x8(%ebp)
+}
+801017c8:	83 c4 10             	add    $0x10,%esp
+801017cb:	5b                   	pop    %ebx
+801017cc:	5e                   	pop    %esi
+801017cd:	5d                   	pop    %ebp
+  releasesleep(&ip->lock);
+801017ce:	e9 1d 28 00 00       	jmp    80103ff0 <releasesleep>
+    panic("iunlock");
+801017d3:	c7 04 24 5f 6e 10 80 	movl   $0x80106e5f,(%esp)
+801017da:	e8 81 eb ff ff       	call   80100360 <panic>
+801017df:	90                   	nop
+
+801017e0 <iput>:
+{
+801017e0:	55                   	push   %ebp
+801017e1:	89 e5                	mov    %esp,%ebp
+801017e3:	57                   	push   %edi
+801017e4:	56                   	push   %esi
+801017e5:	53                   	push   %ebx
+801017e6:	83 ec 1c             	sub    $0x1c,%esp
+801017e9:	8b 75 08             	mov    0x8(%ebp),%esi
+  acquiresleep(&ip->lock);
+801017ec:	8d 7e 0c             	lea    0xc(%esi),%edi
+801017ef:	89 3c 24             	mov    %edi,(%esp)
+801017f2:	e8 99 27 00 00       	call   80103f90 <acquiresleep>
+  if(ip->valid && ip->nlink == 0){
+801017f7:	8b 56 4c             	mov    0x4c(%esi),%edx
+801017fa:	85 d2                	test   %edx,%edx
+801017fc:	74 07                	je     80101805 <iput+0x25>
+801017fe:	66 83 7e 56 00       	cmpw   $0x0,0x56(%esi)
+80101803:	74 2b                	je     80101830 <iput+0x50>
+  releasesleep(&ip->lock);
+80101805:	89 3c 24             	mov    %edi,(%esp)
+80101808:	e8 e3 27 00 00       	call   80103ff0 <releasesleep>
+  acquire(&icache.lock);
+8010180d:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+80101814:	e8 37 29 00 00       	call   80104150 <acquire>
+  ip->ref--;
+80101819:	83 6e 08 01          	subl   $0x1,0x8(%esi)
+  release(&icache.lock);
+8010181d:	c7 45 08 e0 09 11 80 	movl   $0x801109e0,0x8(%ebp)
+}
+80101824:	83 c4 1c             	add    $0x1c,%esp
+80101827:	5b                   	pop    %ebx
+80101828:	5e                   	pop    %esi
+80101829:	5f                   	pop    %edi
+8010182a:	5d                   	pop    %ebp
+  release(&icache.lock);
+8010182b:	e9 10 2a 00 00       	jmp    80104240 <release>
+    acquire(&icache.lock);
+80101830:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+80101837:	e8 14 29 00 00       	call   80104150 <acquire>
+    int r = ip->ref;
+8010183c:	8b 5e 08             	mov    0x8(%esi),%ebx
+    release(&icache.lock);
+8010183f:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+80101846:	e8 f5 29 00 00       	call   80104240 <release>
+    if(r == 1){
+8010184b:	83 fb 01             	cmp    $0x1,%ebx
+8010184e:	75 b5                	jne    80101805 <iput+0x25>
+80101850:	8d 4e 30             	lea    0x30(%esi),%ecx
+80101853:	89 f3                	mov    %esi,%ebx
+80101855:	89 7d e4             	mov    %edi,-0x1c(%ebp)
+80101858:	89 cf                	mov    %ecx,%edi
+8010185a:	eb 0b                	jmp    80101867 <iput+0x87>
+8010185c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80101860:	83 c3 04             	add    $0x4,%ebx
+{
+  int i, j;
+  struct buf *bp;
+  uint *a;
+
+  for(i = 0; i < NDIRECT; i++){
+80101863:	39 fb                	cmp    %edi,%ebx
+80101865:	74 19                	je     80101880 <iput+0xa0>
+    if(ip->addrs[i]){
+80101867:	8b 53 5c             	mov    0x5c(%ebx),%edx
+8010186a:	85 d2                	test   %edx,%edx
+8010186c:	74 f2                	je     80101860 <iput+0x80>
+      bfree(ip->dev, ip->addrs[i]);
+8010186e:	8b 06                	mov    (%esi),%eax
+80101870:	e8 7b fb ff ff       	call   801013f0 <bfree>
+      ip->addrs[i] = 0;
+80101875:	c7 43 5c 00 00 00 00 	movl   $0x0,0x5c(%ebx)
+8010187c:	eb e2                	jmp    80101860 <iput+0x80>
+8010187e:	66 90                	xchg   %ax,%ax
+    }
+  }
+
+  if(ip->addrs[NDIRECT]){
+80101880:	8b 86 8c 00 00 00    	mov    0x8c(%esi),%eax
+80101886:	8b 7d e4             	mov    -0x1c(%ebp),%edi
+80101889:	85 c0                	test   %eax,%eax
+8010188b:	75 2b                	jne    801018b8 <iput+0xd8>
+    brelse(bp);
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+    ip->addrs[NDIRECT] = 0;
+  }
+
+  ip->size = 0;
+8010188d:	c7 46 58 00 00 00 00 	movl   $0x0,0x58(%esi)
+  iupdate(ip);
+80101894:	89 34 24             	mov    %esi,(%esp)
+80101897:	e8 64 fd ff ff       	call   80101600 <iupdate>
+      ip->type = 0;
+8010189c:	31 c0                	xor    %eax,%eax
+8010189e:	66 89 46 50          	mov    %ax,0x50(%esi)
+      iupdate(ip);
+801018a2:	89 34 24             	mov    %esi,(%esp)
+801018a5:	e8 56 fd ff ff       	call   80101600 <iupdate>
+      ip->valid = 0;
+801018aa:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
+801018b1:	e9 4f ff ff ff       	jmp    80101805 <iput+0x25>
+801018b6:	66 90                	xchg   %ax,%ax
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+801018b8:	89 44 24 04          	mov    %eax,0x4(%esp)
+801018bc:	8b 06                	mov    (%esi),%eax
+    for(j = 0; j < NINDIRECT; j++){
+801018be:	31 db                	xor    %ebx,%ebx
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+801018c0:	89 04 24             	mov    %eax,(%esp)
+801018c3:	e8 08 e8 ff ff       	call   801000d0 <bread>
+    for(j = 0; j < NINDIRECT; j++){
+801018c8:	89 7d e0             	mov    %edi,-0x20(%ebp)
+    a = (uint*)bp->data;
+801018cb:	8d 48 5c             	lea    0x5c(%eax),%ecx
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+801018ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    for(j = 0; j < NINDIRECT; j++){
+801018d1:	89 cf                	mov    %ecx,%edi
+801018d3:	31 c0                	xor    %eax,%eax
+801018d5:	eb 0e                	jmp    801018e5 <iput+0x105>
+801018d7:	90                   	nop
+801018d8:	83 c3 01             	add    $0x1,%ebx
+801018db:	81 fb 80 00 00 00    	cmp    $0x80,%ebx
+801018e1:	89 d8                	mov    %ebx,%eax
+801018e3:	74 10                	je     801018f5 <iput+0x115>
+      if(a[j])
+801018e5:	8b 14 87             	mov    (%edi,%eax,4),%edx
+801018e8:	85 d2                	test   %edx,%edx
+801018ea:	74 ec                	je     801018d8 <iput+0xf8>
+        bfree(ip->dev, a[j]);
+801018ec:	8b 06                	mov    (%esi),%eax
+801018ee:	e8 fd fa ff ff       	call   801013f0 <bfree>
+801018f3:	eb e3                	jmp    801018d8 <iput+0xf8>
+    brelse(bp);
+801018f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+801018f8:	8b 7d e0             	mov    -0x20(%ebp),%edi
+801018fb:	89 04 24             	mov    %eax,(%esp)
+801018fe:	e8 dd e8 ff ff       	call   801001e0 <brelse>
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+80101903:	8b 96 8c 00 00 00    	mov    0x8c(%esi),%edx
+80101909:	8b 06                	mov    (%esi),%eax
+8010190b:	e8 e0 fa ff ff       	call   801013f0 <bfree>
+    ip->addrs[NDIRECT] = 0;
+80101910:	c7 86 8c 00 00 00 00 	movl   $0x0,0x8c(%esi)
+80101917:	00 00 00 
+8010191a:	e9 6e ff ff ff       	jmp    8010188d <iput+0xad>
+8010191f:	90                   	nop
+
+80101920 <iunlockput>:
+{
+80101920:	55                   	push   %ebp
+80101921:	89 e5                	mov    %esp,%ebp
+80101923:	53                   	push   %ebx
+80101924:	83 ec 14             	sub    $0x14,%esp
+80101927:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  iunlock(ip);
+8010192a:	89 1c 24             	mov    %ebx,(%esp)
+8010192d:	e8 6e fe ff ff       	call   801017a0 <iunlock>
+  iput(ip);
+80101932:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+80101935:	83 c4 14             	add    $0x14,%esp
+80101938:	5b                   	pop    %ebx
+80101939:	5d                   	pop    %ebp
+  iput(ip);
+8010193a:	e9 a1 fe ff ff       	jmp    801017e0 <iput>
+8010193f:	90                   	nop
+
+80101940 <stati>:
+
+// Copy stat information from inode.
+// Caller must hold ip->lock.
+void
+stati(struct inode *ip, struct stat *st)
+{
+80101940:	55                   	push   %ebp
+80101941:	89 e5                	mov    %esp,%ebp
+80101943:	8b 55 08             	mov    0x8(%ebp),%edx
+80101946:	8b 45 0c             	mov    0xc(%ebp),%eax
+  st->dev = ip->dev;
+80101949:	8b 0a                	mov    (%edx),%ecx
+8010194b:	89 48 04             	mov    %ecx,0x4(%eax)
+  st->ino = ip->inum;
+8010194e:	8b 4a 04             	mov    0x4(%edx),%ecx
+80101951:	89 48 08             	mov    %ecx,0x8(%eax)
+  st->type = ip->type;
+80101954:	0f b7 4a 50          	movzwl 0x50(%edx),%ecx
+80101958:	66 89 08             	mov    %cx,(%eax)
+  st->nlink = ip->nlink;
+8010195b:	0f b7 4a 56          	movzwl 0x56(%edx),%ecx
+8010195f:	66 89 48 0c          	mov    %cx,0xc(%eax)
+  st->size = ip->size;
+80101963:	8b 52 58             	mov    0x58(%edx),%edx
+80101966:	89 50 10             	mov    %edx,0x10(%eax)
+}
+80101969:	5d                   	pop    %ebp
+8010196a:	c3                   	ret    
+8010196b:	90                   	nop
+8010196c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80101970 <readi>:
+//PAGEBREAK!
+// Read data from inode.
+// Caller must hold ip->lock.
+int
+readi(struct inode *ip, char *dst, uint off, uint n)
+{
+80101970:	55                   	push   %ebp
+80101971:	89 e5                	mov    %esp,%ebp
+80101973:	57                   	push   %edi
+80101974:	56                   	push   %esi
+80101975:	53                   	push   %ebx
+80101976:	83 ec 2c             	sub    $0x2c,%esp
+80101979:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010197c:	8b 7d 08             	mov    0x8(%ebp),%edi
+8010197f:	8b 75 10             	mov    0x10(%ebp),%esi
+80101982:	89 45 e0             	mov    %eax,-0x20(%ebp)
+80101985:	8b 45 14             	mov    0x14(%ebp),%eax
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+80101988:	66 83 7f 50 03       	cmpw   $0x3,0x50(%edi)
+{
+8010198d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(ip->type == T_DEV){
+80101990:	0f 84 aa 00 00 00    	je     80101a40 <readi+0xd0>
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+      return -1;
+    return devsw[ip->major].read(ip, dst, n);
+  }
+
+  if(off > ip->size || off + n < off)
+80101996:	8b 47 58             	mov    0x58(%edi),%eax
+80101999:	39 f0                	cmp    %esi,%eax
+8010199b:	0f 82 c7 00 00 00    	jb     80101a68 <readi+0xf8>
+801019a1:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+801019a4:	89 da                	mov    %ebx,%edx
+801019a6:	01 f2                	add    %esi,%edx
+801019a8:	0f 82 ba 00 00 00    	jb     80101a68 <readi+0xf8>
+    return -1;
+  if(off + n > ip->size)
+    n = ip->size - off;
+801019ae:	89 c1                	mov    %eax,%ecx
+801019b0:	29 f1                	sub    %esi,%ecx
+801019b2:	39 d0                	cmp    %edx,%eax
+801019b4:	0f 43 cb             	cmovae %ebx,%ecx
+
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+801019b7:	31 c0                	xor    %eax,%eax
+801019b9:	85 c9                	test   %ecx,%ecx
+    n = ip->size - off;
+801019bb:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+801019be:	74 70                	je     80101a30 <readi+0xc0>
+801019c0:	89 7d d8             	mov    %edi,-0x28(%ebp)
+801019c3:	89 c7                	mov    %eax,%edi
+801019c5:	8d 76 00             	lea    0x0(%esi),%esi
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+801019c8:	8b 5d d8             	mov    -0x28(%ebp),%ebx
+801019cb:	89 f2                	mov    %esi,%edx
+801019cd:	c1 ea 09             	shr    $0x9,%edx
+801019d0:	89 d8                	mov    %ebx,%eax
+801019d2:	e8 09 f9 ff ff       	call   801012e0 <bmap>
+801019d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+801019db:	8b 03                	mov    (%ebx),%eax
+    m = min(n - tot, BSIZE - off%BSIZE);
+801019dd:	bb 00 02 00 00       	mov    $0x200,%ebx
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+801019e2:	89 04 24             	mov    %eax,(%esp)
+801019e5:	e8 e6 e6 ff ff       	call   801000d0 <bread>
+    m = min(n - tot, BSIZE - off%BSIZE);
+801019ea:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+801019ed:	29 f9                	sub    %edi,%ecx
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+801019ef:	89 c2                	mov    %eax,%edx
+    m = min(n - tot, BSIZE - off%BSIZE);
+801019f1:	89 f0                	mov    %esi,%eax
+801019f3:	25 ff 01 00 00       	and    $0x1ff,%eax
+801019f8:	29 c3                	sub    %eax,%ebx
+    memmove(dst, bp->data + off%BSIZE, m);
+801019fa:	8d 44 02 5c          	lea    0x5c(%edx,%eax,1),%eax
+    m = min(n - tot, BSIZE - off%BSIZE);
+801019fe:	39 cb                	cmp    %ecx,%ebx
+    memmove(dst, bp->data + off%BSIZE, m);
+80101a00:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101a04:	8b 45 e0             	mov    -0x20(%ebp),%eax
+    m = min(n - tot, BSIZE - off%BSIZE);
+80101a07:	0f 47 d9             	cmova  %ecx,%ebx
+    memmove(dst, bp->data + off%BSIZE, m);
+80101a0a:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+80101a0e:	01 df                	add    %ebx,%edi
+80101a10:	01 de                	add    %ebx,%esi
+    memmove(dst, bp->data + off%BSIZE, m);
+80101a12:	89 55 dc             	mov    %edx,-0x24(%ebp)
+80101a15:	89 04 24             	mov    %eax,(%esp)
+80101a18:	e8 13 29 00 00       	call   80104330 <memmove>
+    brelse(bp);
+80101a1d:	8b 55 dc             	mov    -0x24(%ebp),%edx
+80101a20:	89 14 24             	mov    %edx,(%esp)
+80101a23:	e8 b8 e7 ff ff       	call   801001e0 <brelse>
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+80101a28:	01 5d e0             	add    %ebx,-0x20(%ebp)
+80101a2b:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
+80101a2e:	77 98                	ja     801019c8 <readi+0x58>
+  }
+  return n;
+80101a30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+80101a33:	83 c4 2c             	add    $0x2c,%esp
+80101a36:	5b                   	pop    %ebx
+80101a37:	5e                   	pop    %esi
+80101a38:	5f                   	pop    %edi
+80101a39:	5d                   	pop    %ebp
+80101a3a:	c3                   	ret    
+80101a3b:	90                   	nop
+80101a3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+80101a40:	0f bf 47 52          	movswl 0x52(%edi),%eax
+80101a44:	66 83 f8 09          	cmp    $0x9,%ax
+80101a48:	77 1e                	ja     80101a68 <readi+0xf8>
+80101a4a:	8b 04 c5 60 09 11 80 	mov    -0x7feef6a0(,%eax,8),%eax
+80101a51:	85 c0                	test   %eax,%eax
+80101a53:	74 13                	je     80101a68 <readi+0xf8>
+    return devsw[ip->major].read(ip, dst, n);
+80101a55:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+80101a58:	89 75 10             	mov    %esi,0x10(%ebp)
+}
+80101a5b:	83 c4 2c             	add    $0x2c,%esp
+80101a5e:	5b                   	pop    %ebx
+80101a5f:	5e                   	pop    %esi
+80101a60:	5f                   	pop    %edi
+80101a61:	5d                   	pop    %ebp
+    return devsw[ip->major].read(ip, dst, n);
+80101a62:	ff e0                	jmp    *%eax
+80101a64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      return -1;
+80101a68:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101a6d:	eb c4                	jmp    80101a33 <readi+0xc3>
+80101a6f:	90                   	nop
+
+80101a70 <writei>:
+// PAGEBREAK!
+// Write data to inode.
+// Caller must hold ip->lock.
+int
+writei(struct inode *ip, char *src, uint off, uint n)
+{
+80101a70:	55                   	push   %ebp
+80101a71:	89 e5                	mov    %esp,%ebp
+80101a73:	57                   	push   %edi
+80101a74:	56                   	push   %esi
+80101a75:	53                   	push   %ebx
+80101a76:	83 ec 2c             	sub    $0x2c,%esp
+80101a79:	8b 45 08             	mov    0x8(%ebp),%eax
+80101a7c:	8b 75 0c             	mov    0xc(%ebp),%esi
+80101a7f:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+80101a82:	66 83 78 50 03       	cmpw   $0x3,0x50(%eax)
+{
+80101a87:	89 75 dc             	mov    %esi,-0x24(%ebp)
+80101a8a:	8b 75 10             	mov    0x10(%ebp),%esi
+80101a8d:	89 45 d8             	mov    %eax,-0x28(%ebp)
+80101a90:	89 4d e0             	mov    %ecx,-0x20(%ebp)
+  if(ip->type == T_DEV){
+80101a93:	0f 84 b7 00 00 00    	je     80101b50 <writei+0xe0>
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+      return -1;
+    return devsw[ip->major].write(ip, src, n);
+  }
+
+  if(off > ip->size || off + n < off)
+80101a99:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80101a9c:	39 70 58             	cmp    %esi,0x58(%eax)
+80101a9f:	0f 82 e3 00 00 00    	jb     80101b88 <writei+0x118>
+80101aa5:	8b 4d e0             	mov    -0x20(%ebp),%ecx
+80101aa8:	89 c8                	mov    %ecx,%eax
+80101aaa:	01 f0                	add    %esi,%eax
+80101aac:	0f 82 d6 00 00 00    	jb     80101b88 <writei+0x118>
+    return -1;
+  if(off + n > MAXFILE*BSIZE)
+80101ab2:	3d 00 18 01 00       	cmp    $0x11800,%eax
+80101ab7:	0f 87 cb 00 00 00    	ja     80101b88 <writei+0x118>
+    return -1;
+
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+80101abd:	85 c9                	test   %ecx,%ecx
+80101abf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+80101ac6:	74 77                	je     80101b3f <writei+0xcf>
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+80101ac8:	8b 7d d8             	mov    -0x28(%ebp),%edi
+80101acb:	89 f2                	mov    %esi,%edx
+    m = min(n - tot, BSIZE - off%BSIZE);
+80101acd:	bb 00 02 00 00       	mov    $0x200,%ebx
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+80101ad2:	c1 ea 09             	shr    $0x9,%edx
+80101ad5:	89 f8                	mov    %edi,%eax
+80101ad7:	e8 04 f8 ff ff       	call   801012e0 <bmap>
+80101adc:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101ae0:	8b 07                	mov    (%edi),%eax
+80101ae2:	89 04 24             	mov    %eax,(%esp)
+80101ae5:	e8 e6 e5 ff ff       	call   801000d0 <bread>
+    m = min(n - tot, BSIZE - off%BSIZE);
+80101aea:	8b 4d e0             	mov    -0x20(%ebp),%ecx
+80101aed:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
+    memmove(bp->data + off%BSIZE, src, m);
+80101af0:	8b 55 dc             	mov    -0x24(%ebp),%edx
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+80101af3:	89 c7                	mov    %eax,%edi
+    m = min(n - tot, BSIZE - off%BSIZE);
+80101af5:	89 f0                	mov    %esi,%eax
+80101af7:	25 ff 01 00 00       	and    $0x1ff,%eax
+80101afc:	29 c3                	sub    %eax,%ebx
+80101afe:	39 cb                	cmp    %ecx,%ebx
+80101b00:	0f 47 d9             	cmova  %ecx,%ebx
+    memmove(bp->data + off%BSIZE, src, m);
+80101b03:	8d 44 07 5c          	lea    0x5c(%edi,%eax,1),%eax
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+80101b07:	01 de                	add    %ebx,%esi
+    memmove(bp->data + off%BSIZE, src, m);
+80101b09:	89 54 24 04          	mov    %edx,0x4(%esp)
+80101b0d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+80101b11:	89 04 24             	mov    %eax,(%esp)
+80101b14:	e8 17 28 00 00       	call   80104330 <memmove>
+    log_write(bp);
+80101b19:	89 3c 24             	mov    %edi,(%esp)
+80101b1c:	e8 9f 11 00 00       	call   80102cc0 <log_write>
+    brelse(bp);
+80101b21:	89 3c 24             	mov    %edi,(%esp)
+80101b24:	e8 b7 e6 ff ff       	call   801001e0 <brelse>
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+80101b29:	01 5d e4             	add    %ebx,-0x1c(%ebp)
+80101b2c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80101b2f:	01 5d dc             	add    %ebx,-0x24(%ebp)
+80101b32:	39 45 e0             	cmp    %eax,-0x20(%ebp)
+80101b35:	77 91                	ja     80101ac8 <writei+0x58>
+  }
+
+  if(n > 0 && off > ip->size){
+80101b37:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80101b3a:	39 70 58             	cmp    %esi,0x58(%eax)
+80101b3d:	72 39                	jb     80101b78 <writei+0x108>
+    ip->size = off;
+    iupdate(ip);
+  }
+  return n;
+80101b3f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+}
+80101b42:	83 c4 2c             	add    $0x2c,%esp
+80101b45:	5b                   	pop    %ebx
+80101b46:	5e                   	pop    %esi
+80101b47:	5f                   	pop    %edi
+80101b48:	5d                   	pop    %ebp
+80101b49:	c3                   	ret    
+80101b4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+80101b50:	0f bf 40 52          	movswl 0x52(%eax),%eax
+80101b54:	66 83 f8 09          	cmp    $0x9,%ax
+80101b58:	77 2e                	ja     80101b88 <writei+0x118>
+80101b5a:	8b 04 c5 64 09 11 80 	mov    -0x7feef69c(,%eax,8),%eax
+80101b61:	85 c0                	test   %eax,%eax
+80101b63:	74 23                	je     80101b88 <writei+0x118>
+    return devsw[ip->major].write(ip, src, n);
+80101b65:	89 4d 10             	mov    %ecx,0x10(%ebp)
+}
+80101b68:	83 c4 2c             	add    $0x2c,%esp
+80101b6b:	5b                   	pop    %ebx
+80101b6c:	5e                   	pop    %esi
+80101b6d:	5f                   	pop    %edi
+80101b6e:	5d                   	pop    %ebp
+    return devsw[ip->major].write(ip, src, n);
+80101b6f:	ff e0                	jmp    *%eax
+80101b71:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    ip->size = off;
+80101b78:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80101b7b:	89 70 58             	mov    %esi,0x58(%eax)
+    iupdate(ip);
+80101b7e:	89 04 24             	mov    %eax,(%esp)
+80101b81:	e8 7a fa ff ff       	call   80101600 <iupdate>
+80101b86:	eb b7                	jmp    80101b3f <writei+0xcf>
+}
+80101b88:	83 c4 2c             	add    $0x2c,%esp
+      return -1;
+80101b8b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80101b90:	5b                   	pop    %ebx
+80101b91:	5e                   	pop    %esi
+80101b92:	5f                   	pop    %edi
+80101b93:	5d                   	pop    %ebp
+80101b94:	c3                   	ret    
+80101b95:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80101b99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80101ba0 <namecmp>:
+//PAGEBREAK!
+// Directories
+
+int
+namecmp(const char *s, const char *t)
+{
+80101ba0:	55                   	push   %ebp
+80101ba1:	89 e5                	mov    %esp,%ebp
+80101ba3:	83 ec 18             	sub    $0x18,%esp
+  return strncmp(s, t, DIRSIZ);
+80101ba6:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101ba9:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
+80101bb0:	00 
+80101bb1:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101bb5:	8b 45 08             	mov    0x8(%ebp),%eax
+80101bb8:	89 04 24             	mov    %eax,(%esp)
+80101bbb:	e8 f0 27 00 00       	call   801043b0 <strncmp>
+}
+80101bc0:	c9                   	leave  
+80101bc1:	c3                   	ret    
+80101bc2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101bc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80101bd0 <dirlookup>:
+
+// Look for a directory entry in a directory.
+// If found, set *poff to byte offset of entry.
+struct inode*
+dirlookup(struct inode *dp, char *name, uint *poff)
+{
+80101bd0:	55                   	push   %ebp
+80101bd1:	89 e5                	mov    %esp,%ebp
+80101bd3:	57                   	push   %edi
+80101bd4:	56                   	push   %esi
+80101bd5:	53                   	push   %ebx
+80101bd6:	83 ec 2c             	sub    $0x2c,%esp
+80101bd9:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  uint off, inum;
+  struct dirent de;
+
+  if(dp->type != T_DIR)
+80101bdc:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
+80101be1:	0f 85 97 00 00 00    	jne    80101c7e <dirlookup+0xae>
+    panic("dirlookup not DIR");
+
+  for(off = 0; off < dp->size; off += sizeof(de)){
+80101be7:	8b 53 58             	mov    0x58(%ebx),%edx
+80101bea:	31 ff                	xor    %edi,%edi
+80101bec:	8d 75 d8             	lea    -0x28(%ebp),%esi
+80101bef:	85 d2                	test   %edx,%edx
+80101bf1:	75 0d                	jne    80101c00 <dirlookup+0x30>
+80101bf3:	eb 73                	jmp    80101c68 <dirlookup+0x98>
+80101bf5:	8d 76 00             	lea    0x0(%esi),%esi
+80101bf8:	83 c7 10             	add    $0x10,%edi
+80101bfb:	39 7b 58             	cmp    %edi,0x58(%ebx)
+80101bfe:	76 68                	jbe    80101c68 <dirlookup+0x98>
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80101c00:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
+80101c07:	00 
+80101c08:	89 7c 24 08          	mov    %edi,0x8(%esp)
+80101c0c:	89 74 24 04          	mov    %esi,0x4(%esp)
+80101c10:	89 1c 24             	mov    %ebx,(%esp)
+80101c13:	e8 58 fd ff ff       	call   80101970 <readi>
+80101c18:	83 f8 10             	cmp    $0x10,%eax
+80101c1b:	75 55                	jne    80101c72 <dirlookup+0xa2>
+      panic("dirlookup read");
+    if(de.inum == 0)
+80101c1d:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
+80101c22:	74 d4                	je     80101bf8 <dirlookup+0x28>
+  return strncmp(s, t, DIRSIZ);
+80101c24:	8d 45 da             	lea    -0x26(%ebp),%eax
+80101c27:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101c2b:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101c2e:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
+80101c35:	00 
+80101c36:	89 04 24             	mov    %eax,(%esp)
+80101c39:	e8 72 27 00 00       	call   801043b0 <strncmp>
+      continue;
+    if(namecmp(name, de.name) == 0){
+80101c3e:	85 c0                	test   %eax,%eax
+80101c40:	75 b6                	jne    80101bf8 <dirlookup+0x28>
+      // entry matches path element
+      if(poff)
+80101c42:	8b 45 10             	mov    0x10(%ebp),%eax
+80101c45:	85 c0                	test   %eax,%eax
+80101c47:	74 05                	je     80101c4e <dirlookup+0x7e>
+        *poff = off;
+80101c49:	8b 45 10             	mov    0x10(%ebp),%eax
+80101c4c:	89 38                	mov    %edi,(%eax)
+      inum = de.inum;
+80101c4e:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
+      return iget(dp->dev, inum);
+80101c52:	8b 03                	mov    (%ebx),%eax
+80101c54:	e8 c7 f5 ff ff       	call   80101220 <iget>
+    }
+  }
+
+  return 0;
+}
+80101c59:	83 c4 2c             	add    $0x2c,%esp
+80101c5c:	5b                   	pop    %ebx
+80101c5d:	5e                   	pop    %esi
+80101c5e:	5f                   	pop    %edi
+80101c5f:	5d                   	pop    %ebp
+80101c60:	c3                   	ret    
+80101c61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101c68:	83 c4 2c             	add    $0x2c,%esp
+  return 0;
+80101c6b:	31 c0                	xor    %eax,%eax
+}
+80101c6d:	5b                   	pop    %ebx
+80101c6e:	5e                   	pop    %esi
+80101c6f:	5f                   	pop    %edi
+80101c70:	5d                   	pop    %ebp
+80101c71:	c3                   	ret    
+      panic("dirlookup read");
+80101c72:	c7 04 24 79 6e 10 80 	movl   $0x80106e79,(%esp)
+80101c79:	e8 e2 e6 ff ff       	call   80100360 <panic>
+    panic("dirlookup not DIR");
+80101c7e:	c7 04 24 67 6e 10 80 	movl   $0x80106e67,(%esp)
+80101c85:	e8 d6 e6 ff ff       	call   80100360 <panic>
+80101c8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80101c90 <namex>:
+// If parent != 0, return the inode for the parent and copy the final
+// path element into name, which must have room for DIRSIZ bytes.
+// Must be called inside a transaction since it calls iput().
+static struct inode*
+namex(char *path, int nameiparent, char *name)
+{
+80101c90:	55                   	push   %ebp
+80101c91:	89 e5                	mov    %esp,%ebp
+80101c93:	57                   	push   %edi
+80101c94:	89 cf                	mov    %ecx,%edi
+80101c96:	56                   	push   %esi
+80101c97:	53                   	push   %ebx
+80101c98:	89 c3                	mov    %eax,%ebx
+80101c9a:	83 ec 2c             	sub    $0x2c,%esp
+  struct inode *ip, *next;
+
+  if(*path == '/')
+80101c9d:	80 38 2f             	cmpb   $0x2f,(%eax)
+{
+80101ca0:	89 55 e0             	mov    %edx,-0x20(%ebp)
+  if(*path == '/')
+80101ca3:	0f 84 51 01 00 00    	je     80101dfa <namex+0x16a>
+    ip = iget(ROOTDEV, ROOTINO);
+  else
+    ip = idup(myproc()->cwd);
+80101ca9:	e8 02 1a 00 00       	call   801036b0 <myproc>
+80101cae:	8b 70 68             	mov    0x68(%eax),%esi
+  acquire(&icache.lock);
+80101cb1:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+80101cb8:	e8 93 24 00 00       	call   80104150 <acquire>
+  ip->ref++;
+80101cbd:	83 46 08 01          	addl   $0x1,0x8(%esi)
+  release(&icache.lock);
+80101cc1:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+80101cc8:	e8 73 25 00 00       	call   80104240 <release>
+80101ccd:	eb 04                	jmp    80101cd3 <namex+0x43>
+80101ccf:	90                   	nop
+    path++;
+80101cd0:	83 c3 01             	add    $0x1,%ebx
+  while(*path == '/')
+80101cd3:	0f b6 03             	movzbl (%ebx),%eax
+80101cd6:	3c 2f                	cmp    $0x2f,%al
+80101cd8:	74 f6                	je     80101cd0 <namex+0x40>
+  if(*path == 0)
+80101cda:	84 c0                	test   %al,%al
+80101cdc:	0f 84 ed 00 00 00    	je     80101dcf <namex+0x13f>
+  while(*path != '/' && *path != 0)
+80101ce2:	0f b6 03             	movzbl (%ebx),%eax
+80101ce5:	89 da                	mov    %ebx,%edx
+80101ce7:	84 c0                	test   %al,%al
+80101ce9:	0f 84 b1 00 00 00    	je     80101da0 <namex+0x110>
+80101cef:	3c 2f                	cmp    $0x2f,%al
+80101cf1:	75 0f                	jne    80101d02 <namex+0x72>
+80101cf3:	e9 a8 00 00 00       	jmp    80101da0 <namex+0x110>
+80101cf8:	3c 2f                	cmp    $0x2f,%al
+80101cfa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80101d00:	74 0a                	je     80101d0c <namex+0x7c>
+    path++;
+80101d02:	83 c2 01             	add    $0x1,%edx
+  while(*path != '/' && *path != 0)
+80101d05:	0f b6 02             	movzbl (%edx),%eax
+80101d08:	84 c0                	test   %al,%al
+80101d0a:	75 ec                	jne    80101cf8 <namex+0x68>
+80101d0c:	89 d1                	mov    %edx,%ecx
+80101d0e:	29 d9                	sub    %ebx,%ecx
+  if(len >= DIRSIZ)
+80101d10:	83 f9 0d             	cmp    $0xd,%ecx
+80101d13:	0f 8e 8f 00 00 00    	jle    80101da8 <namex+0x118>
+    memmove(name, s, DIRSIZ);
+80101d19:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80101d1d:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
+80101d24:	00 
+80101d25:	89 3c 24             	mov    %edi,(%esp)
+80101d28:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+80101d2b:	e8 00 26 00 00       	call   80104330 <memmove>
+    path++;
+80101d30:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80101d33:	89 d3                	mov    %edx,%ebx
+  while(*path == '/')
+80101d35:	80 3a 2f             	cmpb   $0x2f,(%edx)
+80101d38:	75 0e                	jne    80101d48 <namex+0xb8>
+80101d3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    path++;
+80101d40:	83 c3 01             	add    $0x1,%ebx
+  while(*path == '/')
+80101d43:	80 3b 2f             	cmpb   $0x2f,(%ebx)
+80101d46:	74 f8                	je     80101d40 <namex+0xb0>
+
+  while((path = skipelem(path, name)) != 0){
+    ilock(ip);
+80101d48:	89 34 24             	mov    %esi,(%esp)
+80101d4b:	e8 70 f9 ff ff       	call   801016c0 <ilock>
+    if(ip->type != T_DIR){
+80101d50:	66 83 7e 50 01       	cmpw   $0x1,0x50(%esi)
+80101d55:	0f 85 85 00 00 00    	jne    80101de0 <namex+0x150>
+      iunlockput(ip);
+      return 0;
+    }
+    if(nameiparent && *path == '\0'){
+80101d5b:	8b 55 e0             	mov    -0x20(%ebp),%edx
+80101d5e:	85 d2                	test   %edx,%edx
+80101d60:	74 09                	je     80101d6b <namex+0xdb>
+80101d62:	80 3b 00             	cmpb   $0x0,(%ebx)
+80101d65:	0f 84 a5 00 00 00    	je     80101e10 <namex+0x180>
+      // Stop one level early.
+      iunlock(ip);
+      return ip;
+    }
+    if((next = dirlookup(ip, name, 0)) == 0){
+80101d6b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+80101d72:	00 
+80101d73:	89 7c 24 04          	mov    %edi,0x4(%esp)
+80101d77:	89 34 24             	mov    %esi,(%esp)
+80101d7a:	e8 51 fe ff ff       	call   80101bd0 <dirlookup>
+80101d7f:	85 c0                	test   %eax,%eax
+80101d81:	74 5d                	je     80101de0 <namex+0x150>
+  iunlock(ip);
+80101d83:	89 34 24             	mov    %esi,(%esp)
+80101d86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80101d89:	e8 12 fa ff ff       	call   801017a0 <iunlock>
+  iput(ip);
+80101d8e:	89 34 24             	mov    %esi,(%esp)
+80101d91:	e8 4a fa ff ff       	call   801017e0 <iput>
+      iunlockput(ip);
+      return 0;
+    }
+    iunlockput(ip);
+    ip = next;
+80101d96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80101d99:	89 c6                	mov    %eax,%esi
+80101d9b:	e9 33 ff ff ff       	jmp    80101cd3 <namex+0x43>
+  while(*path != '/' && *path != 0)
+80101da0:	31 c9                	xor    %ecx,%ecx
+80101da2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    memmove(name, s, len);
+80101da8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+80101dac:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80101db0:	89 3c 24             	mov    %edi,(%esp)
+80101db3:	89 55 dc             	mov    %edx,-0x24(%ebp)
+80101db6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+80101db9:	e8 72 25 00 00       	call   80104330 <memmove>
+    name[len] = 0;
+80101dbe:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+80101dc1:	8b 55 dc             	mov    -0x24(%ebp),%edx
+80101dc4:	c6 04 0f 00          	movb   $0x0,(%edi,%ecx,1)
+80101dc8:	89 d3                	mov    %edx,%ebx
+80101dca:	e9 66 ff ff ff       	jmp    80101d35 <namex+0xa5>
+  }
+  if(nameiparent){
+80101dcf:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80101dd2:	85 c0                	test   %eax,%eax
+80101dd4:	75 4c                	jne    80101e22 <namex+0x192>
+80101dd6:	89 f0                	mov    %esi,%eax
+    iput(ip);
+    return 0;
+  }
+  return ip;
+}
+80101dd8:	83 c4 2c             	add    $0x2c,%esp
+80101ddb:	5b                   	pop    %ebx
+80101ddc:	5e                   	pop    %esi
+80101ddd:	5f                   	pop    %edi
+80101dde:	5d                   	pop    %ebp
+80101ddf:	c3                   	ret    
+  iunlock(ip);
+80101de0:	89 34 24             	mov    %esi,(%esp)
+80101de3:	e8 b8 f9 ff ff       	call   801017a0 <iunlock>
+  iput(ip);
+80101de8:	89 34 24             	mov    %esi,(%esp)
+80101deb:	e8 f0 f9 ff ff       	call   801017e0 <iput>
+}
+80101df0:	83 c4 2c             	add    $0x2c,%esp
+      return 0;
+80101df3:	31 c0                	xor    %eax,%eax
+}
+80101df5:	5b                   	pop    %ebx
+80101df6:	5e                   	pop    %esi
+80101df7:	5f                   	pop    %edi
+80101df8:	5d                   	pop    %ebp
+80101df9:	c3                   	ret    
+    ip = iget(ROOTDEV, ROOTINO);
+80101dfa:	ba 01 00 00 00       	mov    $0x1,%edx
+80101dff:	b8 01 00 00 00       	mov    $0x1,%eax
+80101e04:	e8 17 f4 ff ff       	call   80101220 <iget>
+80101e09:	89 c6                	mov    %eax,%esi
+80101e0b:	e9 c3 fe ff ff       	jmp    80101cd3 <namex+0x43>
+      iunlock(ip);
+80101e10:	89 34 24             	mov    %esi,(%esp)
+80101e13:	e8 88 f9 ff ff       	call   801017a0 <iunlock>
+}
+80101e18:	83 c4 2c             	add    $0x2c,%esp
+      return ip;
+80101e1b:	89 f0                	mov    %esi,%eax
+}
+80101e1d:	5b                   	pop    %ebx
+80101e1e:	5e                   	pop    %esi
+80101e1f:	5f                   	pop    %edi
+80101e20:	5d                   	pop    %ebp
+80101e21:	c3                   	ret    
+    iput(ip);
+80101e22:	89 34 24             	mov    %esi,(%esp)
+80101e25:	e8 b6 f9 ff ff       	call   801017e0 <iput>
+    return 0;
+80101e2a:	31 c0                	xor    %eax,%eax
+80101e2c:	eb aa                	jmp    80101dd8 <namex+0x148>
+80101e2e:	66 90                	xchg   %ax,%ax
+
+80101e30 <dirlink>:
+{
+80101e30:	55                   	push   %ebp
+80101e31:	89 e5                	mov    %esp,%ebp
+80101e33:	57                   	push   %edi
+80101e34:	56                   	push   %esi
+80101e35:	53                   	push   %ebx
+80101e36:	83 ec 2c             	sub    $0x2c,%esp
+80101e39:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if((ip = dirlookup(dp, name, 0)) != 0){
+80101e3c:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101e3f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+80101e46:	00 
+80101e47:	89 1c 24             	mov    %ebx,(%esp)
+80101e4a:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101e4e:	e8 7d fd ff ff       	call   80101bd0 <dirlookup>
+80101e53:	85 c0                	test   %eax,%eax
+80101e55:	0f 85 8b 00 00 00    	jne    80101ee6 <dirlink+0xb6>
+  for(off = 0; off < dp->size; off += sizeof(de)){
+80101e5b:	8b 43 58             	mov    0x58(%ebx),%eax
+80101e5e:	31 ff                	xor    %edi,%edi
+80101e60:	8d 75 d8             	lea    -0x28(%ebp),%esi
+80101e63:	85 c0                	test   %eax,%eax
+80101e65:	75 13                	jne    80101e7a <dirlink+0x4a>
+80101e67:	eb 35                	jmp    80101e9e <dirlink+0x6e>
+80101e69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101e70:	8d 57 10             	lea    0x10(%edi),%edx
+80101e73:	39 53 58             	cmp    %edx,0x58(%ebx)
+80101e76:	89 d7                	mov    %edx,%edi
+80101e78:	76 24                	jbe    80101e9e <dirlink+0x6e>
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80101e7a:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
+80101e81:	00 
+80101e82:	89 7c 24 08          	mov    %edi,0x8(%esp)
+80101e86:	89 74 24 04          	mov    %esi,0x4(%esp)
+80101e8a:	89 1c 24             	mov    %ebx,(%esp)
+80101e8d:	e8 de fa ff ff       	call   80101970 <readi>
+80101e92:	83 f8 10             	cmp    $0x10,%eax
+80101e95:	75 5e                	jne    80101ef5 <dirlink+0xc5>
+    if(de.inum == 0)
+80101e97:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
+80101e9c:	75 d2                	jne    80101e70 <dirlink+0x40>
+  strncpy(de.name, name, DIRSIZ);
+80101e9e:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101ea1:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
+80101ea8:	00 
+80101ea9:	89 44 24 04          	mov    %eax,0x4(%esp)
+80101ead:	8d 45 da             	lea    -0x26(%ebp),%eax
+80101eb0:	89 04 24             	mov    %eax,(%esp)
+80101eb3:	e8 68 25 00 00       	call   80104420 <strncpy>
+  de.inum = inum;
+80101eb8:	8b 45 10             	mov    0x10(%ebp),%eax
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80101ebb:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
+80101ec2:	00 
+80101ec3:	89 7c 24 08          	mov    %edi,0x8(%esp)
+80101ec7:	89 74 24 04          	mov    %esi,0x4(%esp)
+80101ecb:	89 1c 24             	mov    %ebx,(%esp)
+  de.inum = inum;
+80101ece:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80101ed2:	e8 99 fb ff ff       	call   80101a70 <writei>
+80101ed7:	83 f8 10             	cmp    $0x10,%eax
+80101eda:	75 25                	jne    80101f01 <dirlink+0xd1>
+  return 0;
+80101edc:	31 c0                	xor    %eax,%eax
+}
+80101ede:	83 c4 2c             	add    $0x2c,%esp
+80101ee1:	5b                   	pop    %ebx
+80101ee2:	5e                   	pop    %esi
+80101ee3:	5f                   	pop    %edi
+80101ee4:	5d                   	pop    %ebp
+80101ee5:	c3                   	ret    
+    iput(ip);
+80101ee6:	89 04 24             	mov    %eax,(%esp)
+80101ee9:	e8 f2 f8 ff ff       	call   801017e0 <iput>
+    return -1;
+80101eee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101ef3:	eb e9                	jmp    80101ede <dirlink+0xae>
+      panic("dirlink read");
+80101ef5:	c7 04 24 88 6e 10 80 	movl   $0x80106e88,(%esp)
+80101efc:	e8 5f e4 ff ff       	call   80100360 <panic>
+    panic("dirlink");
+80101f01:	c7 04 24 86 74 10 80 	movl   $0x80107486,(%esp)
+80101f08:	e8 53 e4 ff ff       	call   80100360 <panic>
+80101f0d:	8d 76 00             	lea    0x0(%esi),%esi
+
+80101f10 <namei>:
+
+struct inode*
+namei(char *path)
+{
+80101f10:	55                   	push   %ebp
+  char name[DIRSIZ];
+  return namex(path, 0, name);
+80101f11:	31 d2                	xor    %edx,%edx
+{
+80101f13:	89 e5                	mov    %esp,%ebp
+80101f15:	83 ec 18             	sub    $0x18,%esp
+  return namex(path, 0, name);
+80101f18:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f1b:	8d 4d ea             	lea    -0x16(%ebp),%ecx
+80101f1e:	e8 6d fd ff ff       	call   80101c90 <namex>
+}
+80101f23:	c9                   	leave  
+80101f24:	c3                   	ret    
+80101f25:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80101f29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80101f30 <nameiparent>:
+
+struct inode*
+nameiparent(char *path, char *name)
+{
+80101f30:	55                   	push   %ebp
+  return namex(path, 1, name);
+80101f31:	ba 01 00 00 00       	mov    $0x1,%edx
+{
+80101f36:	89 e5                	mov    %esp,%ebp
+  return namex(path, 1, name);
+80101f38:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+80101f3b:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+80101f3e:	5d                   	pop    %ebp
+  return namex(path, 1, name);
+80101f3f:	e9 4c fd ff ff       	jmp    80101c90 <namex>
+80101f44:	66 90                	xchg   %ax,%ax
+80101f46:	66 90                	xchg   %ax,%ax
+80101f48:	66 90                	xchg   %ax,%ax
+80101f4a:	66 90                	xchg   %ax,%ax
+80101f4c:	66 90                	xchg   %ax,%ax
+80101f4e:	66 90                	xchg   %ax,%ax
+
+80101f50 <idestart>:
+}
+
+// Start the request for b.  Caller must hold idelock.
+static void
+idestart(struct buf *b)
+{
+80101f50:	55                   	push   %ebp
+80101f51:	89 e5                	mov    %esp,%ebp
+80101f53:	56                   	push   %esi
+80101f54:	89 c6                	mov    %eax,%esi
+80101f56:	53                   	push   %ebx
+80101f57:	83 ec 10             	sub    $0x10,%esp
+  if(b == 0)
+80101f5a:	85 c0                	test   %eax,%eax
+80101f5c:	0f 84 99 00 00 00    	je     80101ffb <idestart+0xab>
+    panic("idestart");
+  if(b->blockno >= FSSIZE)
+80101f62:	8b 48 08             	mov    0x8(%eax),%ecx
+80101f65:	81 f9 e7 03 00 00    	cmp    $0x3e7,%ecx
+80101f6b:	0f 87 7e 00 00 00    	ja     80101fef <idestart+0x9f>
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80101f71:	ba f7 01 00 00       	mov    $0x1f7,%edx
+80101f76:	66 90                	xchg   %ax,%ax
+80101f78:	ec                   	in     (%dx),%al
+  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+80101f79:	83 e0 c0             	and    $0xffffffc0,%eax
+80101f7c:	3c 40                	cmp    $0x40,%al
+80101f7e:	75 f8                	jne    80101f78 <idestart+0x28>
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80101f80:	31 db                	xor    %ebx,%ebx
+80101f82:	ba f6 03 00 00       	mov    $0x3f6,%edx
+80101f87:	89 d8                	mov    %ebx,%eax
+80101f89:	ee                   	out    %al,(%dx)
+80101f8a:	ba f2 01 00 00       	mov    $0x1f2,%edx
+80101f8f:	b8 01 00 00 00       	mov    $0x1,%eax
+80101f94:	ee                   	out    %al,(%dx)
+80101f95:	0f b6 c1             	movzbl %cl,%eax
+80101f98:	b2 f3                	mov    $0xf3,%dl
+80101f9a:	ee                   	out    %al,(%dx)
+
+  idewait(0);
+  outb(0x3f6, 0);  // generate interrupt
+  outb(0x1f2, sector_per_block);  // number of sectors
+  outb(0x1f3, sector & 0xff);
+  outb(0x1f4, (sector >> 8) & 0xff);
+80101f9b:	89 c8                	mov    %ecx,%eax
+80101f9d:	b2 f4                	mov    $0xf4,%dl
+80101f9f:	c1 f8 08             	sar    $0x8,%eax
+80101fa2:	ee                   	out    %al,(%dx)
+80101fa3:	b2 f5                	mov    $0xf5,%dl
+80101fa5:	89 d8                	mov    %ebx,%eax
+80101fa7:	ee                   	out    %al,(%dx)
+  outb(0x1f5, (sector >> 16) & 0xff);
+  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
+80101fa8:	0f b6 46 04          	movzbl 0x4(%esi),%eax
+80101fac:	b2 f6                	mov    $0xf6,%dl
+80101fae:	83 e0 01             	and    $0x1,%eax
+80101fb1:	c1 e0 04             	shl    $0x4,%eax
+80101fb4:	83 c8 e0             	or     $0xffffffe0,%eax
+80101fb7:	ee                   	out    %al,(%dx)
+  if(b->flags & B_DIRTY){
+80101fb8:	f6 06 04             	testb  $0x4,(%esi)
+80101fbb:	75 13                	jne    80101fd0 <idestart+0x80>
+80101fbd:	ba f7 01 00 00       	mov    $0x1f7,%edx
+80101fc2:	b8 20 00 00 00       	mov    $0x20,%eax
+80101fc7:	ee                   	out    %al,(%dx)
+    outb(0x1f7, write_cmd);
+    outsl(0x1f0, b->data, BSIZE/4);
+  } else {
+    outb(0x1f7, read_cmd);
+  }
+}
+80101fc8:	83 c4 10             	add    $0x10,%esp
+80101fcb:	5b                   	pop    %ebx
+80101fcc:	5e                   	pop    %esi
+80101fcd:	5d                   	pop    %ebp
+80101fce:	c3                   	ret    
+80101fcf:	90                   	nop
+80101fd0:	b2 f7                	mov    $0xf7,%dl
+80101fd2:	b8 30 00 00 00       	mov    $0x30,%eax
+80101fd7:	ee                   	out    %al,(%dx)
+  asm volatile("cld; rep outsl" :
+80101fd8:	b9 80 00 00 00       	mov    $0x80,%ecx
+    outsl(0x1f0, b->data, BSIZE/4);
+80101fdd:	83 c6 5c             	add    $0x5c,%esi
+80101fe0:	ba f0 01 00 00       	mov    $0x1f0,%edx
+80101fe5:	fc                   	cld    
+80101fe6:	f3 6f                	rep outsl %ds:(%esi),(%dx)
+}
+80101fe8:	83 c4 10             	add    $0x10,%esp
+80101feb:	5b                   	pop    %ebx
+80101fec:	5e                   	pop    %esi
+80101fed:	5d                   	pop    %ebp
+80101fee:	c3                   	ret    
+    panic("incorrect blockno");
+80101fef:	c7 04 24 f4 6e 10 80 	movl   $0x80106ef4,(%esp)
+80101ff6:	e8 65 e3 ff ff       	call   80100360 <panic>
+    panic("idestart");
+80101ffb:	c7 04 24 eb 6e 10 80 	movl   $0x80106eeb,(%esp)
+80102002:	e8 59 e3 ff ff       	call   80100360 <panic>
+80102007:	89 f6                	mov    %esi,%esi
+80102009:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80102010 <ideinit>:
+{
+80102010:	55                   	push   %ebp
+80102011:	89 e5                	mov    %esp,%ebp
+80102013:	83 ec 18             	sub    $0x18,%esp
+  initlock(&idelock, "ide");
+80102016:	c7 44 24 04 06 6f 10 	movl   $0x80106f06,0x4(%esp)
+8010201d:	80 
+8010201e:	c7 04 24 80 a5 10 80 	movl   $0x8010a580,(%esp)
+80102025:	e8 36 20 00 00       	call   80104060 <initlock>
+  ioapicenable(IRQ_IDE, ncpu - 1);
+8010202a:	a1 00 2d 11 80       	mov    0x80112d00,%eax
+8010202f:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
+80102036:	83 e8 01             	sub    $0x1,%eax
+80102039:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010203d:	e8 7e 02 00 00       	call   801022c0 <ioapicenable>
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102042:	ba f7 01 00 00       	mov    $0x1f7,%edx
+80102047:	90                   	nop
+80102048:	ec                   	in     (%dx),%al
+  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+80102049:	83 e0 c0             	and    $0xffffffc0,%eax
+8010204c:	3c 40                	cmp    $0x40,%al
+8010204e:	75 f8                	jne    80102048 <ideinit+0x38>
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102050:	ba f6 01 00 00       	mov    $0x1f6,%edx
+80102055:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
+8010205a:	ee                   	out    %al,(%dx)
+8010205b:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102060:	b2 f7                	mov    $0xf7,%dl
+80102062:	eb 09                	jmp    8010206d <ideinit+0x5d>
+80102064:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  for(i=0; i<1000; i++){
+80102068:	83 e9 01             	sub    $0x1,%ecx
+8010206b:	74 0f                	je     8010207c <ideinit+0x6c>
+8010206d:	ec                   	in     (%dx),%al
+    if(inb(0x1f7) != 0){
+8010206e:	84 c0                	test   %al,%al
+80102070:	74 f6                	je     80102068 <ideinit+0x58>
+      havedisk1 = 1;
+80102072:	c7 05 60 a5 10 80 01 	movl   $0x1,0x8010a560
+80102079:	00 00 00 
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+8010207c:	ba f6 01 00 00       	mov    $0x1f6,%edx
+80102081:	b8 e0 ff ff ff       	mov    $0xffffffe0,%eax
+80102086:	ee                   	out    %al,(%dx)
+}
+80102087:	c9                   	leave  
+80102088:	c3                   	ret    
+80102089:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80102090 <ideintr>:
+
+// Interrupt handler.
+void
+ideintr(void)
+{
+80102090:	55                   	push   %ebp
+80102091:	89 e5                	mov    %esp,%ebp
+80102093:	57                   	push   %edi
+80102094:	56                   	push   %esi
+80102095:	53                   	push   %ebx
+80102096:	83 ec 1c             	sub    $0x1c,%esp
+  struct buf *b;
+
+  // First queued buffer is the active request.
+  acquire(&idelock);
+80102099:	c7 04 24 80 a5 10 80 	movl   $0x8010a580,(%esp)
+801020a0:	e8 ab 20 00 00       	call   80104150 <acquire>
+
+  if((b = idequeue) == 0){
+801020a5:	8b 1d 64 a5 10 80    	mov    0x8010a564,%ebx
+801020ab:	85 db                	test   %ebx,%ebx
+801020ad:	74 30                	je     801020df <ideintr+0x4f>
+    release(&idelock);
+    return;
+  }
+  idequeue = b->qnext;
+801020af:	8b 43 58             	mov    0x58(%ebx),%eax
+801020b2:	a3 64 a5 10 80       	mov    %eax,0x8010a564
+
+  // Read data if needed.
+  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
+801020b7:	8b 33                	mov    (%ebx),%esi
+801020b9:	f7 c6 04 00 00 00    	test   $0x4,%esi
+801020bf:	74 37                	je     801020f8 <ideintr+0x68>
+    insl(0x1f0, b->data, BSIZE/4);
+
+  // Wake process waiting for this buf.
+  b->flags |= B_VALID;
+  b->flags &= ~B_DIRTY;
+801020c1:	83 e6 fb             	and    $0xfffffffb,%esi
+801020c4:	83 ce 02             	or     $0x2,%esi
+801020c7:	89 33                	mov    %esi,(%ebx)
+  wakeup(b);
+801020c9:	89 1c 24             	mov    %ebx,(%esp)
+801020cc:	e8 cf 1c 00 00       	call   80103da0 <wakeup>
+
+  // Start disk on next buf in queue.
+  if(idequeue != 0)
+801020d1:	a1 64 a5 10 80       	mov    0x8010a564,%eax
+801020d6:	85 c0                	test   %eax,%eax
+801020d8:	74 05                	je     801020df <ideintr+0x4f>
+    idestart(idequeue);
+801020da:	e8 71 fe ff ff       	call   80101f50 <idestart>
+    release(&idelock);
+801020df:	c7 04 24 80 a5 10 80 	movl   $0x8010a580,(%esp)
+801020e6:	e8 55 21 00 00       	call   80104240 <release>
+
+  release(&idelock);
+}
+801020eb:	83 c4 1c             	add    $0x1c,%esp
+801020ee:	5b                   	pop    %ebx
+801020ef:	5e                   	pop    %esi
+801020f0:	5f                   	pop    %edi
+801020f1:	5d                   	pop    %ebp
+801020f2:	c3                   	ret    
+801020f3:	90                   	nop
+801020f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801020f8:	ba f7 01 00 00       	mov    $0x1f7,%edx
+801020fd:	8d 76 00             	lea    0x0(%esi),%esi
+80102100:	ec                   	in     (%dx),%al
+  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+80102101:	89 c1                	mov    %eax,%ecx
+80102103:	83 e1 c0             	and    $0xffffffc0,%ecx
+80102106:	80 f9 40             	cmp    $0x40,%cl
+80102109:	75 f5                	jne    80102100 <ideintr+0x70>
+  if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
+8010210b:	a8 21                	test   $0x21,%al
+8010210d:	75 b2                	jne    801020c1 <ideintr+0x31>
+    insl(0x1f0, b->data, BSIZE/4);
+8010210f:	8d 7b 5c             	lea    0x5c(%ebx),%edi
+  asm volatile("cld; rep insl" :
+80102112:	b9 80 00 00 00       	mov    $0x80,%ecx
+80102117:	ba f0 01 00 00       	mov    $0x1f0,%edx
+8010211c:	fc                   	cld    
+8010211d:	f3 6d                	rep insl (%dx),%es:(%edi)
+8010211f:	8b 33                	mov    (%ebx),%esi
+80102121:	eb 9e                	jmp    801020c1 <ideintr+0x31>
+80102123:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80102129:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80102130 <iderw>:
+// Sync buf with disk.
+// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+// Else if B_VALID is not set, read buf from disk, set B_VALID.
+void
+iderw(struct buf *b)
+{
+80102130:	55                   	push   %ebp
+80102131:	89 e5                	mov    %esp,%ebp
+80102133:	53                   	push   %ebx
+80102134:	83 ec 14             	sub    $0x14,%esp
+80102137:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  struct buf **pp;
+
+  if(!holdingsleep(&b->lock))
+8010213a:	8d 43 0c             	lea    0xc(%ebx),%eax
+8010213d:	89 04 24             	mov    %eax,(%esp)
+80102140:	e8 eb 1e 00 00       	call   80104030 <holdingsleep>
+80102145:	85 c0                	test   %eax,%eax
+80102147:	0f 84 9e 00 00 00    	je     801021eb <iderw+0xbb>
+    panic("iderw: buf not locked");
+  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+8010214d:	8b 03                	mov    (%ebx),%eax
+8010214f:	83 e0 06             	and    $0x6,%eax
+80102152:	83 f8 02             	cmp    $0x2,%eax
+80102155:	0f 84 a8 00 00 00    	je     80102203 <iderw+0xd3>
+    panic("iderw: nothing to do");
+  if(b->dev != 0 && !havedisk1)
+8010215b:	8b 53 04             	mov    0x4(%ebx),%edx
+8010215e:	85 d2                	test   %edx,%edx
+80102160:	74 0d                	je     8010216f <iderw+0x3f>
+80102162:	a1 60 a5 10 80       	mov    0x8010a560,%eax
+80102167:	85 c0                	test   %eax,%eax
+80102169:	0f 84 88 00 00 00    	je     801021f7 <iderw+0xc7>
+    panic("iderw: ide disk 1 not present");
+
+  acquire(&idelock);  //DOC:acquire-lock
+8010216f:	c7 04 24 80 a5 10 80 	movl   $0x8010a580,(%esp)
+80102176:	e8 d5 1f 00 00       	call   80104150 <acquire>
+
+  // Append b to idequeue.
+  b->qnext = 0;
+  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+8010217b:	a1 64 a5 10 80       	mov    0x8010a564,%eax
+  b->qnext = 0;
+80102180:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%ebx)
+  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+80102187:	85 c0                	test   %eax,%eax
+80102189:	75 07                	jne    80102192 <iderw+0x62>
+8010218b:	eb 4e                	jmp    801021db <iderw+0xab>
+8010218d:	8d 76 00             	lea    0x0(%esi),%esi
+80102190:	89 d0                	mov    %edx,%eax
+80102192:	8b 50 58             	mov    0x58(%eax),%edx
+80102195:	85 d2                	test   %edx,%edx
+80102197:	75 f7                	jne    80102190 <iderw+0x60>
+80102199:	83 c0 58             	add    $0x58,%eax
+    ;
+  *pp = b;
+8010219c:	89 18                	mov    %ebx,(%eax)
+
+  // Start disk if necessary.
+  if(idequeue == b)
+8010219e:	39 1d 64 a5 10 80    	cmp    %ebx,0x8010a564
+801021a4:	74 3c                	je     801021e2 <iderw+0xb2>
+    idestart(b);
+
+  // Wait for request to finish.
+  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+801021a6:	8b 03                	mov    (%ebx),%eax
+801021a8:	83 e0 06             	and    $0x6,%eax
+801021ab:	83 f8 02             	cmp    $0x2,%eax
+801021ae:	74 1a                	je     801021ca <iderw+0x9a>
+    sleep(b, &idelock);
+801021b0:	c7 44 24 04 80 a5 10 	movl   $0x8010a580,0x4(%esp)
+801021b7:	80 
+801021b8:	89 1c 24             	mov    %ebx,(%esp)
+801021bb:	e8 50 1a 00 00       	call   80103c10 <sleep>
+  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+801021c0:	8b 13                	mov    (%ebx),%edx
+801021c2:	83 e2 06             	and    $0x6,%edx
+801021c5:	83 fa 02             	cmp    $0x2,%edx
+801021c8:	75 e6                	jne    801021b0 <iderw+0x80>
+  }
+
+
+  release(&idelock);
+801021ca:	c7 45 08 80 a5 10 80 	movl   $0x8010a580,0x8(%ebp)
+}
+801021d1:	83 c4 14             	add    $0x14,%esp
+801021d4:	5b                   	pop    %ebx
+801021d5:	5d                   	pop    %ebp
+  release(&idelock);
+801021d6:	e9 65 20 00 00       	jmp    80104240 <release>
+  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+801021db:	b8 64 a5 10 80       	mov    $0x8010a564,%eax
+801021e0:	eb ba                	jmp    8010219c <iderw+0x6c>
+    idestart(b);
+801021e2:	89 d8                	mov    %ebx,%eax
+801021e4:	e8 67 fd ff ff       	call   80101f50 <idestart>
+801021e9:	eb bb                	jmp    801021a6 <iderw+0x76>
+    panic("iderw: buf not locked");
+801021eb:	c7 04 24 0a 6f 10 80 	movl   $0x80106f0a,(%esp)
+801021f2:	e8 69 e1 ff ff       	call   80100360 <panic>
+    panic("iderw: ide disk 1 not present");
+801021f7:	c7 04 24 35 6f 10 80 	movl   $0x80106f35,(%esp)
+801021fe:	e8 5d e1 ff ff       	call   80100360 <panic>
+    panic("iderw: nothing to do");
+80102203:	c7 04 24 20 6f 10 80 	movl   $0x80106f20,(%esp)
+8010220a:	e8 51 e1 ff ff       	call   80100360 <panic>
+8010220f:	90                   	nop
+
+80102210 <ioapicinit>:
+  ioapic->data = data;
+}
+
+void
+ioapicinit(void)
+{
+80102210:	55                   	push   %ebp
+80102211:	89 e5                	mov    %esp,%ebp
+80102213:	56                   	push   %esi
+80102214:	53                   	push   %ebx
+80102215:	83 ec 10             	sub    $0x10,%esp
+  int i, id, maxintr;
+
+  ioapic = (volatile struct ioapic*)IOAPIC;
+80102218:	c7 05 34 26 11 80 00 	movl   $0xfec00000,0x80112634
+8010221f:	00 c0 fe 
+  ioapic->reg = reg;
+80102222:	c7 05 00 00 c0 fe 01 	movl   $0x1,0xfec00000
+80102229:	00 00 00 
+  return ioapic->data;
+8010222c:	8b 15 34 26 11 80    	mov    0x80112634,%edx
+80102232:	8b 42 10             	mov    0x10(%edx),%eax
+  ioapic->reg = reg;
+80102235:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
+  return ioapic->data;
+8010223b:	8b 1d 34 26 11 80    	mov    0x80112634,%ebx
+  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
+  id = ioapicread(REG_ID) >> 24;
+  if(id != ioapicid)
+80102241:	0f b6 15 60 27 11 80 	movzbl 0x80112760,%edx
+  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
+80102248:	c1 e8 10             	shr    $0x10,%eax
+8010224b:	0f b6 f0             	movzbl %al,%esi
+  return ioapic->data;
+8010224e:	8b 43 10             	mov    0x10(%ebx),%eax
+  id = ioapicread(REG_ID) >> 24;
+80102251:	c1 e8 18             	shr    $0x18,%eax
+  if(id != ioapicid)
+80102254:	39 c2                	cmp    %eax,%edx
+80102256:	74 12                	je     8010226a <ioapicinit+0x5a>
+    cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
+80102258:	c7 04 24 54 6f 10 80 	movl   $0x80106f54,(%esp)
+8010225f:	e8 ec e3 ff ff       	call   80100650 <cprintf>
+80102264:	8b 1d 34 26 11 80    	mov    0x80112634,%ebx
+8010226a:	ba 10 00 00 00       	mov    $0x10,%edx
+8010226f:	31 c0                	xor    %eax,%eax
+80102271:	eb 07                	jmp    8010227a <ioapicinit+0x6a>
+80102273:	90                   	nop
+80102274:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80102278:	89 cb                	mov    %ecx,%ebx
+  ioapic->reg = reg;
+8010227a:	89 13                	mov    %edx,(%ebx)
+  ioapic->data = data;
+8010227c:	8b 1d 34 26 11 80    	mov    0x80112634,%ebx
+80102282:	8d 48 20             	lea    0x20(%eax),%ecx
+
+  // Mark all interrupts edge-triggered, active high, disabled,
+  // and not routed to any CPUs.
+  for(i = 0; i <= maxintr; i++){
+    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
+80102285:	81 c9 00 00 01 00    	or     $0x10000,%ecx
+  for(i = 0; i <= maxintr; i++){
+8010228b:	83 c0 01             	add    $0x1,%eax
+  ioapic->data = data;
+8010228e:	89 4b 10             	mov    %ecx,0x10(%ebx)
+80102291:	8d 4a 01             	lea    0x1(%edx),%ecx
+80102294:	83 c2 02             	add    $0x2,%edx
+  ioapic->reg = reg;
+80102297:	89 0b                	mov    %ecx,(%ebx)
+  ioapic->data = data;
+80102299:	8b 0d 34 26 11 80    	mov    0x80112634,%ecx
+  for(i = 0; i <= maxintr; i++){
+8010229f:	39 c6                	cmp    %eax,%esi
+  ioapic->data = data;
+801022a1:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
+  for(i = 0; i <= maxintr; i++){
+801022a8:	7d ce                	jge    80102278 <ioapicinit+0x68>
+    ioapicwrite(REG_TABLE+2*i+1, 0);
+  }
+}
+801022aa:	83 c4 10             	add    $0x10,%esp
+801022ad:	5b                   	pop    %ebx
+801022ae:	5e                   	pop    %esi
+801022af:	5d                   	pop    %ebp
+801022b0:	c3                   	ret    
+801022b1:	eb 0d                	jmp    801022c0 <ioapicenable>
+801022b3:	90                   	nop
+801022b4:	90                   	nop
+801022b5:	90                   	nop
+801022b6:	90                   	nop
+801022b7:	90                   	nop
+801022b8:	90                   	nop
+801022b9:	90                   	nop
+801022ba:	90                   	nop
+801022bb:	90                   	nop
+801022bc:	90                   	nop
+801022bd:	90                   	nop
+801022be:	90                   	nop
+801022bf:	90                   	nop
+
+801022c0 <ioapicenable>:
+
+void
+ioapicenable(int irq, int cpunum)
+{
+801022c0:	55                   	push   %ebp
+801022c1:	89 e5                	mov    %esp,%ebp
+801022c3:	8b 55 08             	mov    0x8(%ebp),%edx
+801022c6:	53                   	push   %ebx
+801022c7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  // Mark interrupt edge-triggered, active high,
+  // enabled, and routed to the given cpunum,
+  // which happens to be that cpu's APIC ID.
+  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
+801022ca:	8d 5a 20             	lea    0x20(%edx),%ebx
+801022cd:	8d 4c 12 10          	lea    0x10(%edx,%edx,1),%ecx
+  ioapic->reg = reg;
+801022d1:	8b 15 34 26 11 80    	mov    0x80112634,%edx
+  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
+801022d7:	c1 e0 18             	shl    $0x18,%eax
+  ioapic->reg = reg;
+801022da:	89 0a                	mov    %ecx,(%edx)
+  ioapic->data = data;
+801022dc:	8b 15 34 26 11 80    	mov    0x80112634,%edx
+  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
+801022e2:	83 c1 01             	add    $0x1,%ecx
+  ioapic->data = data;
+801022e5:	89 5a 10             	mov    %ebx,0x10(%edx)
+  ioapic->reg = reg;
+801022e8:	89 0a                	mov    %ecx,(%edx)
+  ioapic->data = data;
+801022ea:	8b 15 34 26 11 80    	mov    0x80112634,%edx
+801022f0:	89 42 10             	mov    %eax,0x10(%edx)
+}
+801022f3:	5b                   	pop    %ebx
+801022f4:	5d                   	pop    %ebp
+801022f5:	c3                   	ret    
+801022f6:	66 90                	xchg   %ax,%ax
+801022f8:	66 90                	xchg   %ax,%ax
+801022fa:	66 90                	xchg   %ax,%ax
+801022fc:	66 90                	xchg   %ax,%ax
+801022fe:	66 90                	xchg   %ax,%ax
+
+80102300 <kfree>:
+// which normally should have been returned by a
+// call to kalloc().  (The exception is when
+// initializing the allocator; see kinit above.)
+void
+kfree(char *v)
+{
+80102300:	55                   	push   %ebp
+80102301:	89 e5                	mov    %esp,%ebp
+80102303:	53                   	push   %ebx
+80102304:	83 ec 14             	sub    $0x14,%esp
+80102307:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  struct run *r;
+
+  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
+8010230a:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
+80102310:	75 7c                	jne    8010238e <kfree+0x8e>
+80102312:	81 fb f4 57 11 80    	cmp    $0x801157f4,%ebx
+80102318:	72 74                	jb     8010238e <kfree+0x8e>
+8010231a:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
+80102320:	3d ff ff ff 0d       	cmp    $0xdffffff,%eax
+80102325:	77 67                	ja     8010238e <kfree+0x8e>
+    panic("kfree");
+
+  // Fill with junk to catch dangling refs.
+  memset(v, 1, PGSIZE);
+80102327:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+8010232e:	00 
+8010232f:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+80102336:	00 
+80102337:	89 1c 24             	mov    %ebx,(%esp)
+8010233a:	e8 51 1f 00 00       	call   80104290 <memset>
+
+  if(kmem.use_lock)
+8010233f:	8b 15 74 26 11 80    	mov    0x80112674,%edx
+80102345:	85 d2                	test   %edx,%edx
+80102347:	75 37                	jne    80102380 <kfree+0x80>
+    acquire(&kmem.lock);
+  r = (struct run*)v;
+  r->next = kmem.freelist;
+80102349:	a1 78 26 11 80       	mov    0x80112678,%eax
+8010234e:	89 03                	mov    %eax,(%ebx)
+  kmem.freelist = r;
+  if(kmem.use_lock)
+80102350:	a1 74 26 11 80       	mov    0x80112674,%eax
+  kmem.freelist = r;
+80102355:	89 1d 78 26 11 80    	mov    %ebx,0x80112678
+  if(kmem.use_lock)
+8010235b:	85 c0                	test   %eax,%eax
+8010235d:	75 09                	jne    80102368 <kfree+0x68>
+    release(&kmem.lock);
+}
+8010235f:	83 c4 14             	add    $0x14,%esp
+80102362:	5b                   	pop    %ebx
+80102363:	5d                   	pop    %ebp
+80102364:	c3                   	ret    
+80102365:	8d 76 00             	lea    0x0(%esi),%esi
+    release(&kmem.lock);
+80102368:	c7 45 08 40 26 11 80 	movl   $0x80112640,0x8(%ebp)
+}
+8010236f:	83 c4 14             	add    $0x14,%esp
+80102372:	5b                   	pop    %ebx
+80102373:	5d                   	pop    %ebp
+    release(&kmem.lock);
+80102374:	e9 c7 1e 00 00       	jmp    80104240 <release>
+80102379:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    acquire(&kmem.lock);
+80102380:	c7 04 24 40 26 11 80 	movl   $0x80112640,(%esp)
+80102387:	e8 c4 1d 00 00       	call   80104150 <acquire>
+8010238c:	eb bb                	jmp    80102349 <kfree+0x49>
+    panic("kfree");
+8010238e:	c7 04 24 86 6f 10 80 	movl   $0x80106f86,(%esp)
+80102395:	e8 c6 df ff ff       	call   80100360 <panic>
+8010239a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+801023a0 <freerange>:
+{
+801023a0:	55                   	push   %ebp
+801023a1:	89 e5                	mov    %esp,%ebp
+801023a3:	56                   	push   %esi
+801023a4:	53                   	push   %ebx
+801023a5:	83 ec 10             	sub    $0x10,%esp
+  p = (char*)PGROUNDUP((uint)vstart);
+801023a8:	8b 45 08             	mov    0x8(%ebp),%eax
+{
+801023ab:	8b 75 0c             	mov    0xc(%ebp),%esi
+  p = (char*)PGROUNDUP((uint)vstart);
+801023ae:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
+801023b4:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+801023ba:	8d 9a 00 10 00 00    	lea    0x1000(%edx),%ebx
+801023c0:	39 de                	cmp    %ebx,%esi
+801023c2:	73 08                	jae    801023cc <freerange+0x2c>
+801023c4:	eb 18                	jmp    801023de <freerange+0x3e>
+801023c6:	66 90                	xchg   %ax,%ax
+801023c8:	89 da                	mov    %ebx,%edx
+801023ca:	89 c3                	mov    %eax,%ebx
+    kfree(p);
+801023cc:	89 14 24             	mov    %edx,(%esp)
+801023cf:	e8 2c ff ff ff       	call   80102300 <kfree>
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+801023d4:	8d 83 00 10 00 00    	lea    0x1000(%ebx),%eax
+801023da:	39 f0                	cmp    %esi,%eax
+801023dc:	76 ea                	jbe    801023c8 <freerange+0x28>
+}
+801023de:	83 c4 10             	add    $0x10,%esp
+801023e1:	5b                   	pop    %ebx
+801023e2:	5e                   	pop    %esi
+801023e3:	5d                   	pop    %ebp
+801023e4:	c3                   	ret    
+801023e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801023e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801023f0 <kinit1>:
+{
+801023f0:	55                   	push   %ebp
+801023f1:	89 e5                	mov    %esp,%ebp
+801023f3:	56                   	push   %esi
+801023f4:	53                   	push   %ebx
+801023f5:	83 ec 10             	sub    $0x10,%esp
+801023f8:	8b 75 0c             	mov    0xc(%ebp),%esi
+  initlock(&kmem.lock, "kmem");
+801023fb:	c7 44 24 04 8c 6f 10 	movl   $0x80106f8c,0x4(%esp)
+80102402:	80 
+80102403:	c7 04 24 40 26 11 80 	movl   $0x80112640,(%esp)
+8010240a:	e8 51 1c 00 00       	call   80104060 <initlock>
+  p = (char*)PGROUNDUP((uint)vstart);
+8010240f:	8b 45 08             	mov    0x8(%ebp),%eax
+  kmem.use_lock = 0;
+80102412:	c7 05 74 26 11 80 00 	movl   $0x0,0x80112674
+80102419:	00 00 00 
+  p = (char*)PGROUNDUP((uint)vstart);
+8010241c:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
+80102422:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+80102428:	8d 9a 00 10 00 00    	lea    0x1000(%edx),%ebx
+8010242e:	39 de                	cmp    %ebx,%esi
+80102430:	73 0a                	jae    8010243c <kinit1+0x4c>
+80102432:	eb 1a                	jmp    8010244e <kinit1+0x5e>
+80102434:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80102438:	89 da                	mov    %ebx,%edx
+8010243a:	89 c3                	mov    %eax,%ebx
+    kfree(p);
+8010243c:	89 14 24             	mov    %edx,(%esp)
+8010243f:	e8 bc fe ff ff       	call   80102300 <kfree>
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+80102444:	8d 83 00 10 00 00    	lea    0x1000(%ebx),%eax
+8010244a:	39 c6                	cmp    %eax,%esi
+8010244c:	73 ea                	jae    80102438 <kinit1+0x48>
+}
+8010244e:	83 c4 10             	add    $0x10,%esp
+80102451:	5b                   	pop    %ebx
+80102452:	5e                   	pop    %esi
+80102453:	5d                   	pop    %ebp
+80102454:	c3                   	ret    
+80102455:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80102459:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80102460 <kinit2>:
+{
+80102460:	55                   	push   %ebp
+80102461:	89 e5                	mov    %esp,%ebp
+80102463:	56                   	push   %esi
+80102464:	53                   	push   %ebx
+80102465:	83 ec 10             	sub    $0x10,%esp
+  p = (char*)PGROUNDUP((uint)vstart);
+80102468:	8b 45 08             	mov    0x8(%ebp),%eax
+{
+8010246b:	8b 75 0c             	mov    0xc(%ebp),%esi
+  p = (char*)PGROUNDUP((uint)vstart);
+8010246e:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
+80102474:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+8010247a:	8d 9a 00 10 00 00    	lea    0x1000(%edx),%ebx
+80102480:	39 de                	cmp    %ebx,%esi
+80102482:	73 08                	jae    8010248c <kinit2+0x2c>
+80102484:	eb 18                	jmp    8010249e <kinit2+0x3e>
+80102486:	66 90                	xchg   %ax,%ax
+80102488:	89 da                	mov    %ebx,%edx
+8010248a:	89 c3                	mov    %eax,%ebx
+    kfree(p);
+8010248c:	89 14 24             	mov    %edx,(%esp)
+8010248f:	e8 6c fe ff ff       	call   80102300 <kfree>
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+80102494:	8d 83 00 10 00 00    	lea    0x1000(%ebx),%eax
+8010249a:	39 c6                	cmp    %eax,%esi
+8010249c:	73 ea                	jae    80102488 <kinit2+0x28>
+  kmem.use_lock = 1;
+8010249e:	c7 05 74 26 11 80 01 	movl   $0x1,0x80112674
+801024a5:	00 00 00 
+}
+801024a8:	83 c4 10             	add    $0x10,%esp
+801024ab:	5b                   	pop    %ebx
+801024ac:	5e                   	pop    %esi
+801024ad:	5d                   	pop    %ebp
+801024ae:	c3                   	ret    
+801024af:	90                   	nop
+
+801024b0 <kalloc>:
+// Allocate one 4096-byte page of physical memory.
+// Returns a pointer that the kernel can use.
+// Returns 0 if the memory cannot be allocated.
+char*
+kalloc(void)
+{
+801024b0:	55                   	push   %ebp
+801024b1:	89 e5                	mov    %esp,%ebp
+801024b3:	53                   	push   %ebx
+801024b4:	83 ec 14             	sub    $0x14,%esp
+  struct run *r;
+
+  if(kmem.use_lock)
+801024b7:	a1 74 26 11 80       	mov    0x80112674,%eax
+801024bc:	85 c0                	test   %eax,%eax
+801024be:	75 30                	jne    801024f0 <kalloc+0x40>
+    acquire(&kmem.lock);
+  r = kmem.freelist;
+801024c0:	8b 1d 78 26 11 80    	mov    0x80112678,%ebx
+  if(r)
+801024c6:	85 db                	test   %ebx,%ebx
+801024c8:	74 08                	je     801024d2 <kalloc+0x22>
+    kmem.freelist = r->next;
+801024ca:	8b 13                	mov    (%ebx),%edx
+801024cc:	89 15 78 26 11 80    	mov    %edx,0x80112678
+  if(kmem.use_lock)
+801024d2:	85 c0                	test   %eax,%eax
+801024d4:	74 0c                	je     801024e2 <kalloc+0x32>
+    release(&kmem.lock);
+801024d6:	c7 04 24 40 26 11 80 	movl   $0x80112640,(%esp)
+801024dd:	e8 5e 1d 00 00       	call   80104240 <release>
+  return (char*)r;
+}
+801024e2:	83 c4 14             	add    $0x14,%esp
+801024e5:	89 d8                	mov    %ebx,%eax
+801024e7:	5b                   	pop    %ebx
+801024e8:	5d                   	pop    %ebp
+801024e9:	c3                   	ret    
+801024ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    acquire(&kmem.lock);
+801024f0:	c7 04 24 40 26 11 80 	movl   $0x80112640,(%esp)
+801024f7:	e8 54 1c 00 00       	call   80104150 <acquire>
+801024fc:	a1 74 26 11 80       	mov    0x80112674,%eax
+80102501:	eb bd                	jmp    801024c0 <kalloc+0x10>
+80102503:	66 90                	xchg   %ax,%ax
+80102505:	66 90                	xchg   %ax,%ax
+80102507:	66 90                	xchg   %ax,%ax
+80102509:	66 90                	xchg   %ax,%ax
+8010250b:	66 90                	xchg   %ax,%ax
+8010250d:	66 90                	xchg   %ax,%ax
+8010250f:	90                   	nop
+
+80102510 <kbdgetc>:
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102510:	ba 64 00 00 00       	mov    $0x64,%edx
+80102515:	ec                   	in     (%dx),%al
+    normalmap, shiftmap, ctlmap, ctlmap
+  };
+  uint st, data, c;
+
+  st = inb(KBSTATP);
+  if((st & KBS_DIB) == 0)
+80102516:	a8 01                	test   $0x1,%al
+80102518:	0f 84 ba 00 00 00    	je     801025d8 <kbdgetc+0xc8>
+8010251e:	b2 60                	mov    $0x60,%dl
+80102520:	ec                   	in     (%dx),%al
+    return -1;
+  data = inb(KBDATAP);
+80102521:	0f b6 c8             	movzbl %al,%ecx
+
+  if(data == 0xE0){
+80102524:	81 f9 e0 00 00 00    	cmp    $0xe0,%ecx
+8010252a:	0f 84 88 00 00 00    	je     801025b8 <kbdgetc+0xa8>
+    shift |= E0ESC;
+    return 0;
+  } else if(data & 0x80){
+80102530:	84 c0                	test   %al,%al
+80102532:	79 2c                	jns    80102560 <kbdgetc+0x50>
+    // Key released
+    data = (shift & E0ESC ? data : data & 0x7F);
+80102534:	8b 15 b4 a5 10 80    	mov    0x8010a5b4,%edx
+8010253a:	f6 c2 40             	test   $0x40,%dl
+8010253d:	75 05                	jne    80102544 <kbdgetc+0x34>
+8010253f:	89 c1                	mov    %eax,%ecx
+80102541:	83 e1 7f             	and    $0x7f,%ecx
+    shift &= ~(shiftcode[data] | E0ESC);
+80102544:	0f b6 81 c0 70 10 80 	movzbl -0x7fef8f40(%ecx),%eax
+8010254b:	83 c8 40             	or     $0x40,%eax
+8010254e:	0f b6 c0             	movzbl %al,%eax
+80102551:	f7 d0                	not    %eax
+80102553:	21 d0                	and    %edx,%eax
+80102555:	a3 b4 a5 10 80       	mov    %eax,0x8010a5b4
+    return 0;
+8010255a:	31 c0                	xor    %eax,%eax
+8010255c:	c3                   	ret    
+8010255d:	8d 76 00             	lea    0x0(%esi),%esi
+{
+80102560:	55                   	push   %ebp
+80102561:	89 e5                	mov    %esp,%ebp
+80102563:	53                   	push   %ebx
+80102564:	8b 1d b4 a5 10 80    	mov    0x8010a5b4,%ebx
+  } else if(shift & E0ESC){
+8010256a:	f6 c3 40             	test   $0x40,%bl
+8010256d:	74 09                	je     80102578 <kbdgetc+0x68>
+    // Last character was an E0 escape; or with 0x80
+    data |= 0x80;
+8010256f:	83 c8 80             	or     $0xffffff80,%eax
+    shift &= ~E0ESC;
+80102572:	83 e3 bf             	and    $0xffffffbf,%ebx
+    data |= 0x80;
+80102575:	0f b6 c8             	movzbl %al,%ecx
+  }
+
+  shift |= shiftcode[data];
+80102578:	0f b6 91 c0 70 10 80 	movzbl -0x7fef8f40(%ecx),%edx
+  shift ^= togglecode[data];
+8010257f:	0f b6 81 c0 6f 10 80 	movzbl -0x7fef9040(%ecx),%eax
+  shift |= shiftcode[data];
+80102586:	09 da                	or     %ebx,%edx
+  shift ^= togglecode[data];
+80102588:	31 c2                	xor    %eax,%edx
+  c = charcode[shift & (CTL | SHIFT)][data];
+8010258a:	89 d0                	mov    %edx,%eax
+8010258c:	83 e0 03             	and    $0x3,%eax
+8010258f:	8b 04 85 a0 6f 10 80 	mov    -0x7fef9060(,%eax,4),%eax
+  shift ^= togglecode[data];
+80102596:	89 15 b4 a5 10 80    	mov    %edx,0x8010a5b4
+  if(shift & CAPSLOCK){
+8010259c:	83 e2 08             	and    $0x8,%edx
+  c = charcode[shift & (CTL | SHIFT)][data];
+8010259f:	0f b6 04 08          	movzbl (%eax,%ecx,1),%eax
+  if(shift & CAPSLOCK){
+801025a3:	74 0b                	je     801025b0 <kbdgetc+0xa0>
+    if('a' <= c && c <= 'z')
+801025a5:	8d 50 9f             	lea    -0x61(%eax),%edx
+801025a8:	83 fa 19             	cmp    $0x19,%edx
+801025ab:	77 1b                	ja     801025c8 <kbdgetc+0xb8>
+      c += 'A' - 'a';
+801025ad:	83 e8 20             	sub    $0x20,%eax
+    else if('A' <= c && c <= 'Z')
+      c += 'a' - 'A';
+  }
+  return c;
+}
+801025b0:	5b                   	pop    %ebx
+801025b1:	5d                   	pop    %ebp
+801025b2:	c3                   	ret    
+801025b3:	90                   	nop
+801025b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    shift |= E0ESC;
+801025b8:	83 0d b4 a5 10 80 40 	orl    $0x40,0x8010a5b4
+    return 0;
+801025bf:	31 c0                	xor    %eax,%eax
+801025c1:	c3                   	ret    
+801025c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    else if('A' <= c && c <= 'Z')
+801025c8:	8d 48 bf             	lea    -0x41(%eax),%ecx
+      c += 'a' - 'A';
+801025cb:	8d 50 20             	lea    0x20(%eax),%edx
+801025ce:	83 f9 19             	cmp    $0x19,%ecx
+801025d1:	0f 46 c2             	cmovbe %edx,%eax
+  return c;
+801025d4:	eb da                	jmp    801025b0 <kbdgetc+0xa0>
+801025d6:	66 90                	xchg   %ax,%ax
+    return -1;
+801025d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801025dd:	c3                   	ret    
+801025de:	66 90                	xchg   %ax,%ax
+
+801025e0 <kbdintr>:
+
+void
+kbdintr(void)
+{
+801025e0:	55                   	push   %ebp
+801025e1:	89 e5                	mov    %esp,%ebp
+801025e3:	83 ec 18             	sub    $0x18,%esp
+  consoleintr(kbdgetc);
+801025e6:	c7 04 24 10 25 10 80 	movl   $0x80102510,(%esp)
+801025ed:	e8 be e1 ff ff       	call   801007b0 <consoleintr>
+}
+801025f2:	c9                   	leave  
+801025f3:	c3                   	ret    
+801025f4:	66 90                	xchg   %ax,%ax
+801025f6:	66 90                	xchg   %ax,%ax
+801025f8:	66 90                	xchg   %ax,%ax
+801025fa:	66 90                	xchg   %ax,%ax
+801025fc:	66 90                	xchg   %ax,%ax
+801025fe:	66 90                	xchg   %ax,%ax
+
+80102600 <fill_rtcdate>:
+
+  return inb(CMOS_RETURN);
+}
+
+static void fill_rtcdate(struct rtcdate *r)
+{
+80102600:	55                   	push   %ebp
+80102601:	89 c1                	mov    %eax,%ecx
+80102603:	89 e5                	mov    %esp,%ebp
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102605:	ba 70 00 00 00       	mov    $0x70,%edx
+8010260a:	53                   	push   %ebx
+8010260b:	31 c0                	xor    %eax,%eax
+8010260d:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+8010260e:	bb 71 00 00 00       	mov    $0x71,%ebx
+80102613:	89 da                	mov    %ebx,%edx
+80102615:	ec                   	in     (%dx),%al
+  return inb(CMOS_RETURN);
+80102616:	0f b6 c0             	movzbl %al,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102619:	b2 70                	mov    $0x70,%dl
+8010261b:	89 01                	mov    %eax,(%ecx)
+8010261d:	b8 02 00 00 00       	mov    $0x2,%eax
+80102622:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102623:	89 da                	mov    %ebx,%edx
+80102625:	ec                   	in     (%dx),%al
+80102626:	0f b6 c0             	movzbl %al,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102629:	b2 70                	mov    $0x70,%dl
+8010262b:	89 41 04             	mov    %eax,0x4(%ecx)
+8010262e:	b8 04 00 00 00       	mov    $0x4,%eax
+80102633:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102634:	89 da                	mov    %ebx,%edx
+80102636:	ec                   	in     (%dx),%al
+80102637:	0f b6 c0             	movzbl %al,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+8010263a:	b2 70                	mov    $0x70,%dl
+8010263c:	89 41 08             	mov    %eax,0x8(%ecx)
+8010263f:	b8 07 00 00 00       	mov    $0x7,%eax
+80102644:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102645:	89 da                	mov    %ebx,%edx
+80102647:	ec                   	in     (%dx),%al
+80102648:	0f b6 c0             	movzbl %al,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+8010264b:	b2 70                	mov    $0x70,%dl
+8010264d:	89 41 0c             	mov    %eax,0xc(%ecx)
+80102650:	b8 08 00 00 00       	mov    $0x8,%eax
+80102655:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102656:	89 da                	mov    %ebx,%edx
+80102658:	ec                   	in     (%dx),%al
+80102659:	0f b6 c0             	movzbl %al,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+8010265c:	b2 70                	mov    $0x70,%dl
+8010265e:	89 41 10             	mov    %eax,0x10(%ecx)
+80102661:	b8 09 00 00 00       	mov    $0x9,%eax
+80102666:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102667:	89 da                	mov    %ebx,%edx
+80102669:	ec                   	in     (%dx),%al
+8010266a:	0f b6 d8             	movzbl %al,%ebx
+8010266d:	89 59 14             	mov    %ebx,0x14(%ecx)
+  r->minute = cmos_read(MINS);
+  r->hour   = cmos_read(HOURS);
+  r->day    = cmos_read(DAY);
+  r->month  = cmos_read(MONTH);
+  r->year   = cmos_read(YEAR);
+}
+80102670:	5b                   	pop    %ebx
+80102671:	5d                   	pop    %ebp
+80102672:	c3                   	ret    
+80102673:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80102679:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80102680 <lapicinit>:
+  if(!lapic)
+80102680:	a1 7c 26 11 80       	mov    0x8011267c,%eax
+{
+80102685:	55                   	push   %ebp
+80102686:	89 e5                	mov    %esp,%ebp
+  if(!lapic)
+80102688:	85 c0                	test   %eax,%eax
+8010268a:	0f 84 c0 00 00 00    	je     80102750 <lapicinit+0xd0>
+  lapic[index] = value;
+80102690:	c7 80 f0 00 00 00 3f 	movl   $0x13f,0xf0(%eax)
+80102697:	01 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+8010269a:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+8010269d:	c7 80 e0 03 00 00 0b 	movl   $0xb,0x3e0(%eax)
+801026a4:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+801026a7:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+801026aa:	c7 80 20 03 00 00 20 	movl   $0x20020,0x320(%eax)
+801026b1:	00 02 00 
+  lapic[ID];  // wait for write to finish, by reading
+801026b4:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+801026b7:	c7 80 80 03 00 00 80 	movl   $0x989680,0x380(%eax)
+801026be:	96 98 00 
+  lapic[ID];  // wait for write to finish, by reading
+801026c1:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+801026c4:	c7 80 50 03 00 00 00 	movl   $0x10000,0x350(%eax)
+801026cb:	00 01 00 
+  lapic[ID];  // wait for write to finish, by reading
+801026ce:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+801026d1:	c7 80 60 03 00 00 00 	movl   $0x10000,0x360(%eax)
+801026d8:	00 01 00 
+  lapic[ID];  // wait for write to finish, by reading
+801026db:	8b 50 20             	mov    0x20(%eax),%edx
+  if(((lapic[VER]>>16) & 0xFF) >= 4)
+801026de:	8b 50 30             	mov    0x30(%eax),%edx
+801026e1:	c1 ea 10             	shr    $0x10,%edx
+801026e4:	80 fa 03             	cmp    $0x3,%dl
+801026e7:	77 6f                	ja     80102758 <lapicinit+0xd8>
+  lapic[index] = value;
+801026e9:	c7 80 70 03 00 00 33 	movl   $0x33,0x370(%eax)
+801026f0:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+801026f3:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+801026f6:	c7 80 80 02 00 00 00 	movl   $0x0,0x280(%eax)
+801026fd:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+80102700:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+80102703:	c7 80 80 02 00 00 00 	movl   $0x0,0x280(%eax)
+8010270a:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+8010270d:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+80102710:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
+80102717:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+8010271a:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+8010271d:	c7 80 10 03 00 00 00 	movl   $0x0,0x310(%eax)
+80102724:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+80102727:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+8010272a:	c7 80 00 03 00 00 00 	movl   $0x88500,0x300(%eax)
+80102731:	85 08 00 
+  lapic[ID];  // wait for write to finish, by reading
+80102734:	8b 50 20             	mov    0x20(%eax),%edx
+80102737:	90                   	nop
+  while(lapic[ICRLO] & DELIVS)
+80102738:	8b 90 00 03 00 00    	mov    0x300(%eax),%edx
+8010273e:	80 e6 10             	and    $0x10,%dh
+80102741:	75 f5                	jne    80102738 <lapicinit+0xb8>
+  lapic[index] = value;
+80102743:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
+8010274a:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+8010274d:	8b 40 20             	mov    0x20(%eax),%eax
+}
+80102750:	5d                   	pop    %ebp
+80102751:	c3                   	ret    
+80102752:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  lapic[index] = value;
+80102758:	c7 80 40 03 00 00 00 	movl   $0x10000,0x340(%eax)
+8010275f:	00 01 00 
+  lapic[ID];  // wait for write to finish, by reading
+80102762:	8b 50 20             	mov    0x20(%eax),%edx
+80102765:	eb 82                	jmp    801026e9 <lapicinit+0x69>
+80102767:	89 f6                	mov    %esi,%esi
+80102769:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80102770 <lapicid>:
+  if (!lapic)
+80102770:	a1 7c 26 11 80       	mov    0x8011267c,%eax
+{
+80102775:	55                   	push   %ebp
+80102776:	89 e5                	mov    %esp,%ebp
+  if (!lapic)
+80102778:	85 c0                	test   %eax,%eax
+8010277a:	74 0c                	je     80102788 <lapicid+0x18>
+  return lapic[ID] >> 24;
+8010277c:	8b 40 20             	mov    0x20(%eax),%eax
+}
+8010277f:	5d                   	pop    %ebp
+  return lapic[ID] >> 24;
+80102780:	c1 e8 18             	shr    $0x18,%eax
+}
+80102783:	c3                   	ret    
+80102784:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return 0;
+80102788:	31 c0                	xor    %eax,%eax
+}
+8010278a:	5d                   	pop    %ebp
+8010278b:	c3                   	ret    
+8010278c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80102790 <lapiceoi>:
+  if(lapic)
+80102790:	a1 7c 26 11 80       	mov    0x8011267c,%eax
+{
+80102795:	55                   	push   %ebp
+80102796:	89 e5                	mov    %esp,%ebp
+  if(lapic)
+80102798:	85 c0                	test   %eax,%eax
+8010279a:	74 0d                	je     801027a9 <lapiceoi+0x19>
+  lapic[index] = value;
+8010279c:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
+801027a3:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+801027a6:	8b 40 20             	mov    0x20(%eax),%eax
+}
+801027a9:	5d                   	pop    %ebp
+801027aa:	c3                   	ret    
+801027ab:	90                   	nop
+801027ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+801027b0 <microdelay>:
+{
+801027b0:	55                   	push   %ebp
+801027b1:	89 e5                	mov    %esp,%ebp
+}
+801027b3:	5d                   	pop    %ebp
+801027b4:	c3                   	ret    
+801027b5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801027b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801027c0 <lapicstartap>:
+{
+801027c0:	55                   	push   %ebp
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801027c1:	ba 70 00 00 00       	mov    $0x70,%edx
+801027c6:	89 e5                	mov    %esp,%ebp
+801027c8:	b8 0f 00 00 00       	mov    $0xf,%eax
+801027cd:	53                   	push   %ebx
+801027ce:	8b 4d 08             	mov    0x8(%ebp),%ecx
+801027d1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+801027d4:	ee                   	out    %al,(%dx)
+801027d5:	b8 0a 00 00 00       	mov    $0xa,%eax
+801027da:	b2 71                	mov    $0x71,%dl
+801027dc:	ee                   	out    %al,(%dx)
+  wrv[0] = 0;
+801027dd:	31 c0                	xor    %eax,%eax
+801027df:	66 a3 67 04 00 80    	mov    %ax,0x80000467
+  wrv[1] = addr >> 4;
+801027e5:	89 d8                	mov    %ebx,%eax
+801027e7:	c1 e8 04             	shr    $0x4,%eax
+801027ea:	66 a3 69 04 00 80    	mov    %ax,0x80000469
+  lapic[index] = value;
+801027f0:	a1 7c 26 11 80       	mov    0x8011267c,%eax
+  lapicw(ICRHI, apicid<<24);
+801027f5:	c1 e1 18             	shl    $0x18,%ecx
+    lapicw(ICRLO, STARTUP | (addr>>12));
+801027f8:	c1 eb 0c             	shr    $0xc,%ebx
+  lapic[index] = value;
+801027fb:	89 88 10 03 00 00    	mov    %ecx,0x310(%eax)
+  lapic[ID];  // wait for write to finish, by reading
+80102801:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+80102804:	c7 80 00 03 00 00 00 	movl   $0xc500,0x300(%eax)
+8010280b:	c5 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+8010280e:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+80102811:	c7 80 00 03 00 00 00 	movl   $0x8500,0x300(%eax)
+80102818:	85 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+8010281b:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+8010281e:	89 88 10 03 00 00    	mov    %ecx,0x310(%eax)
+  lapic[ID];  // wait for write to finish, by reading
+80102824:	8b 50 20             	mov    0x20(%eax),%edx
+    lapicw(ICRLO, STARTUP | (addr>>12));
+80102827:	89 da                	mov    %ebx,%edx
+80102829:	80 ce 06             	or     $0x6,%dh
+  lapic[index] = value;
+8010282c:	89 90 00 03 00 00    	mov    %edx,0x300(%eax)
+  lapic[ID];  // wait for write to finish, by reading
+80102832:	8b 58 20             	mov    0x20(%eax),%ebx
+  lapic[index] = value;
+80102835:	89 88 10 03 00 00    	mov    %ecx,0x310(%eax)
+  lapic[ID];  // wait for write to finish, by reading
+8010283b:	8b 48 20             	mov    0x20(%eax),%ecx
+  lapic[index] = value;
+8010283e:	89 90 00 03 00 00    	mov    %edx,0x300(%eax)
+  lapic[ID];  // wait for write to finish, by reading
+80102844:	8b 40 20             	mov    0x20(%eax),%eax
+}
+80102847:	5b                   	pop    %ebx
+80102848:	5d                   	pop    %ebp
+80102849:	c3                   	ret    
+8010284a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80102850 <cmostime>:
+
+// qemu seems to use 24-hour GWT and the values are BCD encoded
+void cmostime(struct rtcdate *r)
+{
+80102850:	55                   	push   %ebp
+80102851:	ba 70 00 00 00       	mov    $0x70,%edx
+80102856:	89 e5                	mov    %esp,%ebp
+80102858:	b8 0b 00 00 00       	mov    $0xb,%eax
+8010285d:	57                   	push   %edi
+8010285e:	56                   	push   %esi
+8010285f:	53                   	push   %ebx
+80102860:	83 ec 4c             	sub    $0x4c,%esp
+80102863:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102864:	b2 71                	mov    $0x71,%dl
+80102866:	ec                   	in     (%dx),%al
+80102867:	88 45 b7             	mov    %al,-0x49(%ebp)
+8010286a:	8d 5d b8             	lea    -0x48(%ebp),%ebx
+  struct rtcdate t1, t2;
+  int sb, bcd;
+
+  sb = cmos_read(CMOS_STATB);
+
+  bcd = (sb & (1 << 2)) == 0;
+8010286d:	80 65 b7 04          	andb   $0x4,-0x49(%ebp)
+80102871:	8d 7d d0             	lea    -0x30(%ebp),%edi
+80102874:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102878:	be 70 00 00 00       	mov    $0x70,%esi
+
+  // make sure CMOS doesn't modify time while we read it
+  for(;;) {
+    fill_rtcdate(&t1);
+8010287d:	89 d8                	mov    %ebx,%eax
+8010287f:	e8 7c fd ff ff       	call   80102600 <fill_rtcdate>
+80102884:	b8 0a 00 00 00       	mov    $0xa,%eax
+80102889:	89 f2                	mov    %esi,%edx
+8010288b:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+8010288c:	ba 71 00 00 00       	mov    $0x71,%edx
+80102891:	ec                   	in     (%dx),%al
+    if(cmos_read(CMOS_STATA) & CMOS_UIP)
+80102892:	84 c0                	test   %al,%al
+80102894:	78 e7                	js     8010287d <cmostime+0x2d>
+        continue;
+    fill_rtcdate(&t2);
+80102896:	89 f8                	mov    %edi,%eax
+80102898:	e8 63 fd ff ff       	call   80102600 <fill_rtcdate>
+    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
+8010289d:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
+801028a4:	00 
+801028a5:	89 7c 24 04          	mov    %edi,0x4(%esp)
+801028a9:	89 1c 24             	mov    %ebx,(%esp)
+801028ac:	e8 2f 1a 00 00       	call   801042e0 <memcmp>
+801028b1:	85 c0                	test   %eax,%eax
+801028b3:	75 c3                	jne    80102878 <cmostime+0x28>
+      break;
+  }
+
+  // convert
+  if(bcd) {
+801028b5:	80 7d b7 00          	cmpb   $0x0,-0x49(%ebp)
+801028b9:	75 78                	jne    80102933 <cmostime+0xe3>
+#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
+    CONV(second);
+801028bb:	8b 45 b8             	mov    -0x48(%ebp),%eax
+801028be:	89 c2                	mov    %eax,%edx
+801028c0:	83 e0 0f             	and    $0xf,%eax
+801028c3:	c1 ea 04             	shr    $0x4,%edx
+801028c6:	8d 14 92             	lea    (%edx,%edx,4),%edx
+801028c9:	8d 04 50             	lea    (%eax,%edx,2),%eax
+801028cc:	89 45 b8             	mov    %eax,-0x48(%ebp)
+    CONV(minute);
+801028cf:	8b 45 bc             	mov    -0x44(%ebp),%eax
+801028d2:	89 c2                	mov    %eax,%edx
+801028d4:	83 e0 0f             	and    $0xf,%eax
+801028d7:	c1 ea 04             	shr    $0x4,%edx
+801028da:	8d 14 92             	lea    (%edx,%edx,4),%edx
+801028dd:	8d 04 50             	lea    (%eax,%edx,2),%eax
+801028e0:	89 45 bc             	mov    %eax,-0x44(%ebp)
+    CONV(hour  );
+801028e3:	8b 45 c0             	mov    -0x40(%ebp),%eax
+801028e6:	89 c2                	mov    %eax,%edx
+801028e8:	83 e0 0f             	and    $0xf,%eax
+801028eb:	c1 ea 04             	shr    $0x4,%edx
+801028ee:	8d 14 92             	lea    (%edx,%edx,4),%edx
+801028f1:	8d 04 50             	lea    (%eax,%edx,2),%eax
+801028f4:	89 45 c0             	mov    %eax,-0x40(%ebp)
+    CONV(day   );
+801028f7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+801028fa:	89 c2                	mov    %eax,%edx
+801028fc:	83 e0 0f             	and    $0xf,%eax
+801028ff:	c1 ea 04             	shr    $0x4,%edx
+80102902:	8d 14 92             	lea    (%edx,%edx,4),%edx
+80102905:	8d 04 50             	lea    (%eax,%edx,2),%eax
+80102908:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+    CONV(month );
+8010290b:	8b 45 c8             	mov    -0x38(%ebp),%eax
+8010290e:	89 c2                	mov    %eax,%edx
+80102910:	83 e0 0f             	and    $0xf,%eax
+80102913:	c1 ea 04             	shr    $0x4,%edx
+80102916:	8d 14 92             	lea    (%edx,%edx,4),%edx
+80102919:	8d 04 50             	lea    (%eax,%edx,2),%eax
+8010291c:	89 45 c8             	mov    %eax,-0x38(%ebp)
+    CONV(year  );
+8010291f:	8b 45 cc             	mov    -0x34(%ebp),%eax
+80102922:	89 c2                	mov    %eax,%edx
+80102924:	83 e0 0f             	and    $0xf,%eax
+80102927:	c1 ea 04             	shr    $0x4,%edx
+8010292a:	8d 14 92             	lea    (%edx,%edx,4),%edx
+8010292d:	8d 04 50             	lea    (%eax,%edx,2),%eax
+80102930:	89 45 cc             	mov    %eax,-0x34(%ebp)
+#undef     CONV
+  }
+
+  *r = t1;
+80102933:	8b 4d 08             	mov    0x8(%ebp),%ecx
+80102936:	8b 45 b8             	mov    -0x48(%ebp),%eax
+80102939:	89 01                	mov    %eax,(%ecx)
+8010293b:	8b 45 bc             	mov    -0x44(%ebp),%eax
+8010293e:	89 41 04             	mov    %eax,0x4(%ecx)
+80102941:	8b 45 c0             	mov    -0x40(%ebp),%eax
+80102944:	89 41 08             	mov    %eax,0x8(%ecx)
+80102947:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+8010294a:	89 41 0c             	mov    %eax,0xc(%ecx)
+8010294d:	8b 45 c8             	mov    -0x38(%ebp),%eax
+80102950:	89 41 10             	mov    %eax,0x10(%ecx)
+80102953:	8b 45 cc             	mov    -0x34(%ebp),%eax
+80102956:	89 41 14             	mov    %eax,0x14(%ecx)
+  r->year += 2000;
+80102959:	81 41 14 d0 07 00 00 	addl   $0x7d0,0x14(%ecx)
+}
+80102960:	83 c4 4c             	add    $0x4c,%esp
+80102963:	5b                   	pop    %ebx
+80102964:	5e                   	pop    %esi
+80102965:	5f                   	pop    %edi
+80102966:	5d                   	pop    %ebp
+80102967:	c3                   	ret    
+80102968:	66 90                	xchg   %ax,%ax
+8010296a:	66 90                	xchg   %ax,%ax
+8010296c:	66 90                	xchg   %ax,%ax
+8010296e:	66 90                	xchg   %ax,%ax
+
+80102970 <install_trans>:
+}
+
+// Copy committed blocks from log to their home location
+static void
+install_trans(void)
+{
+80102970:	55                   	push   %ebp
+80102971:	89 e5                	mov    %esp,%ebp
+80102973:	57                   	push   %edi
+80102974:	56                   	push   %esi
+80102975:	53                   	push   %ebx
+  int tail;
+
+  for (tail = 0; tail < log.lh.n; tail++) {
+80102976:	31 db                	xor    %ebx,%ebx
+{
+80102978:	83 ec 1c             	sub    $0x1c,%esp
+  for (tail = 0; tail < log.lh.n; tail++) {
+8010297b:	a1 c8 26 11 80       	mov    0x801126c8,%eax
+80102980:	85 c0                	test   %eax,%eax
+80102982:	7e 78                	jle    801029fc <install_trans+0x8c>
+80102984:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
+80102988:	a1 b4 26 11 80       	mov    0x801126b4,%eax
+8010298d:	01 d8                	add    %ebx,%eax
+8010298f:	83 c0 01             	add    $0x1,%eax
+80102992:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102996:	a1 c4 26 11 80       	mov    0x801126c4,%eax
+8010299b:	89 04 24             	mov    %eax,(%esp)
+8010299e:	e8 2d d7 ff ff       	call   801000d0 <bread>
+801029a3:	89 c7                	mov    %eax,%edi
+    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+801029a5:	8b 04 9d cc 26 11 80 	mov    -0x7feed934(,%ebx,4),%eax
+  for (tail = 0; tail < log.lh.n; tail++) {
+801029ac:	83 c3 01             	add    $0x1,%ebx
+    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+801029af:	89 44 24 04          	mov    %eax,0x4(%esp)
+801029b3:	a1 c4 26 11 80       	mov    0x801126c4,%eax
+801029b8:	89 04 24             	mov    %eax,(%esp)
+801029bb:	e8 10 d7 ff ff       	call   801000d0 <bread>
+    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+801029c0:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+801029c7:	00 
+    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+801029c8:	89 c6                	mov    %eax,%esi
+    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+801029ca:	8d 47 5c             	lea    0x5c(%edi),%eax
+801029cd:	89 44 24 04          	mov    %eax,0x4(%esp)
+801029d1:	8d 46 5c             	lea    0x5c(%esi),%eax
+801029d4:	89 04 24             	mov    %eax,(%esp)
+801029d7:	e8 54 19 00 00       	call   80104330 <memmove>
+    bwrite(dbuf);  // write dst to disk
+801029dc:	89 34 24             	mov    %esi,(%esp)
+801029df:	e8 bc d7 ff ff       	call   801001a0 <bwrite>
+    brelse(lbuf);
+801029e4:	89 3c 24             	mov    %edi,(%esp)
+801029e7:	e8 f4 d7 ff ff       	call   801001e0 <brelse>
+    brelse(dbuf);
+801029ec:	89 34 24             	mov    %esi,(%esp)
+801029ef:	e8 ec d7 ff ff       	call   801001e0 <brelse>
+  for (tail = 0; tail < log.lh.n; tail++) {
+801029f4:	39 1d c8 26 11 80    	cmp    %ebx,0x801126c8
+801029fa:	7f 8c                	jg     80102988 <install_trans+0x18>
+  }
+}
+801029fc:	83 c4 1c             	add    $0x1c,%esp
+801029ff:	5b                   	pop    %ebx
+80102a00:	5e                   	pop    %esi
+80102a01:	5f                   	pop    %edi
+80102a02:	5d                   	pop    %ebp
+80102a03:	c3                   	ret    
+80102a04:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80102a0a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+80102a10 <write_head>:
+// Write in-memory log header to disk.
+// This is the true point at which the
+// current transaction commits.
+static void
+write_head(void)
+{
+80102a10:	55                   	push   %ebp
+80102a11:	89 e5                	mov    %esp,%ebp
+80102a13:	57                   	push   %edi
+80102a14:	56                   	push   %esi
+80102a15:	53                   	push   %ebx
+80102a16:	83 ec 1c             	sub    $0x1c,%esp
+  struct buf *buf = bread(log.dev, log.start);
+80102a19:	a1 b4 26 11 80       	mov    0x801126b4,%eax
+80102a1e:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102a22:	a1 c4 26 11 80       	mov    0x801126c4,%eax
+80102a27:	89 04 24             	mov    %eax,(%esp)
+80102a2a:	e8 a1 d6 ff ff       	call   801000d0 <bread>
+  struct logheader *hb = (struct logheader *) (buf->data);
+  int i;
+  hb->n = log.lh.n;
+80102a2f:	8b 1d c8 26 11 80    	mov    0x801126c8,%ebx
+  for (i = 0; i < log.lh.n; i++) {
+80102a35:	31 d2                	xor    %edx,%edx
+80102a37:	85 db                	test   %ebx,%ebx
+  struct buf *buf = bread(log.dev, log.start);
+80102a39:	89 c7                	mov    %eax,%edi
+  hb->n = log.lh.n;
+80102a3b:	89 58 5c             	mov    %ebx,0x5c(%eax)
+80102a3e:	8d 70 5c             	lea    0x5c(%eax),%esi
+  for (i = 0; i < log.lh.n; i++) {
+80102a41:	7e 17                	jle    80102a5a <write_head+0x4a>
+80102a43:	90                   	nop
+80102a44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    hb->block[i] = log.lh.block[i];
+80102a48:	8b 0c 95 cc 26 11 80 	mov    -0x7feed934(,%edx,4),%ecx
+80102a4f:	89 4c 96 04          	mov    %ecx,0x4(%esi,%edx,4)
+  for (i = 0; i < log.lh.n; i++) {
+80102a53:	83 c2 01             	add    $0x1,%edx
+80102a56:	39 da                	cmp    %ebx,%edx
+80102a58:	75 ee                	jne    80102a48 <write_head+0x38>
+  }
+  bwrite(buf);
+80102a5a:	89 3c 24             	mov    %edi,(%esp)
+80102a5d:	e8 3e d7 ff ff       	call   801001a0 <bwrite>
+  brelse(buf);
+80102a62:	89 3c 24             	mov    %edi,(%esp)
+80102a65:	e8 76 d7 ff ff       	call   801001e0 <brelse>
+}
+80102a6a:	83 c4 1c             	add    $0x1c,%esp
+80102a6d:	5b                   	pop    %ebx
+80102a6e:	5e                   	pop    %esi
+80102a6f:	5f                   	pop    %edi
+80102a70:	5d                   	pop    %ebp
+80102a71:	c3                   	ret    
+80102a72:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80102a79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80102a80 <initlog>:
+{
+80102a80:	55                   	push   %ebp
+80102a81:	89 e5                	mov    %esp,%ebp
+80102a83:	56                   	push   %esi
+80102a84:	53                   	push   %ebx
+80102a85:	83 ec 30             	sub    $0x30,%esp
+80102a88:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  initlock(&log.lock, "log");
+80102a8b:	c7 44 24 04 c0 71 10 	movl   $0x801071c0,0x4(%esp)
+80102a92:	80 
+80102a93:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102a9a:	e8 c1 15 00 00       	call   80104060 <initlock>
+  readsb(dev, &sb);
+80102a9f:	8d 45 dc             	lea    -0x24(%ebp),%eax
+80102aa2:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102aa6:	89 1c 24             	mov    %ebx,(%esp)
+80102aa9:	e8 f2 e8 ff ff       	call   801013a0 <readsb>
+  log.start = sb.logstart;
+80102aae:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  log.size = sb.nlog;
+80102ab1:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  struct buf *buf = bread(log.dev, log.start);
+80102ab4:	89 1c 24             	mov    %ebx,(%esp)
+  log.dev = dev;
+80102ab7:	89 1d c4 26 11 80    	mov    %ebx,0x801126c4
+  struct buf *buf = bread(log.dev, log.start);
+80102abd:	89 44 24 04          	mov    %eax,0x4(%esp)
+  log.size = sb.nlog;
+80102ac1:	89 15 b8 26 11 80    	mov    %edx,0x801126b8
+  log.start = sb.logstart;
+80102ac7:	a3 b4 26 11 80       	mov    %eax,0x801126b4
+  struct buf *buf = bread(log.dev, log.start);
+80102acc:	e8 ff d5 ff ff       	call   801000d0 <bread>
+  for (i = 0; i < log.lh.n; i++) {
+80102ad1:	31 d2                	xor    %edx,%edx
+  log.lh.n = lh->n;
+80102ad3:	8b 58 5c             	mov    0x5c(%eax),%ebx
+80102ad6:	8d 70 5c             	lea    0x5c(%eax),%esi
+  for (i = 0; i < log.lh.n; i++) {
+80102ad9:	85 db                	test   %ebx,%ebx
+  log.lh.n = lh->n;
+80102adb:	89 1d c8 26 11 80    	mov    %ebx,0x801126c8
+  for (i = 0; i < log.lh.n; i++) {
+80102ae1:	7e 17                	jle    80102afa <initlog+0x7a>
+80102ae3:	90                   	nop
+80102ae4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    log.lh.block[i] = lh->block[i];
+80102ae8:	8b 4c 96 04          	mov    0x4(%esi,%edx,4),%ecx
+80102aec:	89 0c 95 cc 26 11 80 	mov    %ecx,-0x7feed934(,%edx,4)
+  for (i = 0; i < log.lh.n; i++) {
+80102af3:	83 c2 01             	add    $0x1,%edx
+80102af6:	39 da                	cmp    %ebx,%edx
+80102af8:	75 ee                	jne    80102ae8 <initlog+0x68>
+  brelse(buf);
+80102afa:	89 04 24             	mov    %eax,(%esp)
+80102afd:	e8 de d6 ff ff       	call   801001e0 <brelse>
+
+static void
+recover_from_log(void)
+{
+  read_head();
+  install_trans(); // if committed, copy from log to disk
+80102b02:	e8 69 fe ff ff       	call   80102970 <install_trans>
+  log.lh.n = 0;
+80102b07:	c7 05 c8 26 11 80 00 	movl   $0x0,0x801126c8
+80102b0e:	00 00 00 
+  write_head(); // clear the log
+80102b11:	e8 fa fe ff ff       	call   80102a10 <write_head>
+}
+80102b16:	83 c4 30             	add    $0x30,%esp
+80102b19:	5b                   	pop    %ebx
+80102b1a:	5e                   	pop    %esi
+80102b1b:	5d                   	pop    %ebp
+80102b1c:	c3                   	ret    
+80102b1d:	8d 76 00             	lea    0x0(%esi),%esi
+
+80102b20 <begin_op>:
+}
+
+// called at the start of each FS system call.
+void
+begin_op(void)
+{
+80102b20:	55                   	push   %ebp
+80102b21:	89 e5                	mov    %esp,%ebp
+80102b23:	83 ec 18             	sub    $0x18,%esp
+  acquire(&log.lock);
+80102b26:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102b2d:	e8 1e 16 00 00       	call   80104150 <acquire>
+80102b32:	eb 18                	jmp    80102b4c <begin_op+0x2c>
+80102b34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  while(1){
+    if(log.committing){
+      sleep(&log, &log.lock);
+80102b38:	c7 44 24 04 80 26 11 	movl   $0x80112680,0x4(%esp)
+80102b3f:	80 
+80102b40:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102b47:	e8 c4 10 00 00       	call   80103c10 <sleep>
+    if(log.committing){
+80102b4c:	a1 c0 26 11 80       	mov    0x801126c0,%eax
+80102b51:	85 c0                	test   %eax,%eax
+80102b53:	75 e3                	jne    80102b38 <begin_op+0x18>
+    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
+80102b55:	a1 bc 26 11 80       	mov    0x801126bc,%eax
+80102b5a:	8b 15 c8 26 11 80    	mov    0x801126c8,%edx
+80102b60:	83 c0 01             	add    $0x1,%eax
+80102b63:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
+80102b66:	8d 14 4a             	lea    (%edx,%ecx,2),%edx
+80102b69:	83 fa 1e             	cmp    $0x1e,%edx
+80102b6c:	7f ca                	jg     80102b38 <begin_op+0x18>
+      // this op might exhaust log space; wait for commit.
+      sleep(&log, &log.lock);
+    } else {
+      log.outstanding += 1;
+      release(&log.lock);
+80102b6e:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+      log.outstanding += 1;
+80102b75:	a3 bc 26 11 80       	mov    %eax,0x801126bc
+      release(&log.lock);
+80102b7a:	e8 c1 16 00 00       	call   80104240 <release>
+      break;
+    }
+  }
+}
+80102b7f:	c9                   	leave  
+80102b80:	c3                   	ret    
+80102b81:	eb 0d                	jmp    80102b90 <end_op>
+80102b83:	90                   	nop
+80102b84:	90                   	nop
+80102b85:	90                   	nop
+80102b86:	90                   	nop
+80102b87:	90                   	nop
+80102b88:	90                   	nop
+80102b89:	90                   	nop
+80102b8a:	90                   	nop
+80102b8b:	90                   	nop
+80102b8c:	90                   	nop
+80102b8d:	90                   	nop
+80102b8e:	90                   	nop
+80102b8f:	90                   	nop
+
+80102b90 <end_op>:
+
+// called at the end of each FS system call.
+// commits if this was the last outstanding operation.
+void
+end_op(void)
+{
+80102b90:	55                   	push   %ebp
+80102b91:	89 e5                	mov    %esp,%ebp
+80102b93:	57                   	push   %edi
+80102b94:	56                   	push   %esi
+80102b95:	53                   	push   %ebx
+80102b96:	83 ec 1c             	sub    $0x1c,%esp
+  int do_commit = 0;
+
+  acquire(&log.lock);
+80102b99:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102ba0:	e8 ab 15 00 00       	call   80104150 <acquire>
+  log.outstanding -= 1;
+80102ba5:	a1 bc 26 11 80       	mov    0x801126bc,%eax
+  if(log.committing)
+80102baa:	8b 15 c0 26 11 80    	mov    0x801126c0,%edx
+  log.outstanding -= 1;
+80102bb0:	83 e8 01             	sub    $0x1,%eax
+  if(log.committing)
+80102bb3:	85 d2                	test   %edx,%edx
+  log.outstanding -= 1;
+80102bb5:	a3 bc 26 11 80       	mov    %eax,0x801126bc
+  if(log.committing)
+80102bba:	0f 85 f3 00 00 00    	jne    80102cb3 <end_op+0x123>
+    panic("log.committing");
+  if(log.outstanding == 0){
+80102bc0:	85 c0                	test   %eax,%eax
+80102bc2:	0f 85 cb 00 00 00    	jne    80102c93 <end_op+0x103>
+    // begin_op() may be waiting for log space,
+    // and decrementing log.outstanding has decreased
+    // the amount of reserved space.
+    wakeup(&log);
+  }
+  release(&log.lock);
+80102bc8:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+}
+
+static void
+commit()
+{
+  if (log.lh.n > 0) {
+80102bcf:	31 db                	xor    %ebx,%ebx
+    log.committing = 1;
+80102bd1:	c7 05 c0 26 11 80 01 	movl   $0x1,0x801126c0
+80102bd8:	00 00 00 
+  release(&log.lock);
+80102bdb:	e8 60 16 00 00       	call   80104240 <release>
+  if (log.lh.n > 0) {
+80102be0:	a1 c8 26 11 80       	mov    0x801126c8,%eax
+80102be5:	85 c0                	test   %eax,%eax
+80102be7:	0f 8e 90 00 00 00    	jle    80102c7d <end_op+0xed>
+80102bed:	8d 76 00             	lea    0x0(%esi),%esi
+    struct buf *to = bread(log.dev, log.start+tail+1); // log block
+80102bf0:	a1 b4 26 11 80       	mov    0x801126b4,%eax
+80102bf5:	01 d8                	add    %ebx,%eax
+80102bf7:	83 c0 01             	add    $0x1,%eax
+80102bfa:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102bfe:	a1 c4 26 11 80       	mov    0x801126c4,%eax
+80102c03:	89 04 24             	mov    %eax,(%esp)
+80102c06:	e8 c5 d4 ff ff       	call   801000d0 <bread>
+80102c0b:	89 c6                	mov    %eax,%esi
+    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+80102c0d:	8b 04 9d cc 26 11 80 	mov    -0x7feed934(,%ebx,4),%eax
+  for (tail = 0; tail < log.lh.n; tail++) {
+80102c14:	83 c3 01             	add    $0x1,%ebx
+    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+80102c17:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102c1b:	a1 c4 26 11 80       	mov    0x801126c4,%eax
+80102c20:	89 04 24             	mov    %eax,(%esp)
+80102c23:	e8 a8 d4 ff ff       	call   801000d0 <bread>
+    memmove(to->data, from->data, BSIZE);
+80102c28:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+80102c2f:	00 
+    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+80102c30:	89 c7                	mov    %eax,%edi
+    memmove(to->data, from->data, BSIZE);
+80102c32:	8d 40 5c             	lea    0x5c(%eax),%eax
+80102c35:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102c39:	8d 46 5c             	lea    0x5c(%esi),%eax
+80102c3c:	89 04 24             	mov    %eax,(%esp)
+80102c3f:	e8 ec 16 00 00       	call   80104330 <memmove>
+    bwrite(to);  // write the log
+80102c44:	89 34 24             	mov    %esi,(%esp)
+80102c47:	e8 54 d5 ff ff       	call   801001a0 <bwrite>
+    brelse(from);
+80102c4c:	89 3c 24             	mov    %edi,(%esp)
+80102c4f:	e8 8c d5 ff ff       	call   801001e0 <brelse>
+    brelse(to);
+80102c54:	89 34 24             	mov    %esi,(%esp)
+80102c57:	e8 84 d5 ff ff       	call   801001e0 <brelse>
+  for (tail = 0; tail < log.lh.n; tail++) {
+80102c5c:	3b 1d c8 26 11 80    	cmp    0x801126c8,%ebx
+80102c62:	7c 8c                	jl     80102bf0 <end_op+0x60>
+    write_log();     // Write modified blocks from cache to log
+    write_head();    // Write header to disk -- the real commit
+80102c64:	e8 a7 fd ff ff       	call   80102a10 <write_head>
+    install_trans(); // Now install writes to home locations
+80102c69:	e8 02 fd ff ff       	call   80102970 <install_trans>
+    log.lh.n = 0;
+80102c6e:	c7 05 c8 26 11 80 00 	movl   $0x0,0x801126c8
+80102c75:	00 00 00 
+    write_head();    // Erase the transaction from the log
+80102c78:	e8 93 fd ff ff       	call   80102a10 <write_head>
+    acquire(&log.lock);
+80102c7d:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102c84:	e8 c7 14 00 00       	call   80104150 <acquire>
+    log.committing = 0;
+80102c89:	c7 05 c0 26 11 80 00 	movl   $0x0,0x801126c0
+80102c90:	00 00 00 
+    wakeup(&log);
+80102c93:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102c9a:	e8 01 11 00 00       	call   80103da0 <wakeup>
+    release(&log.lock);
+80102c9f:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102ca6:	e8 95 15 00 00       	call   80104240 <release>
+}
+80102cab:	83 c4 1c             	add    $0x1c,%esp
+80102cae:	5b                   	pop    %ebx
+80102caf:	5e                   	pop    %esi
+80102cb0:	5f                   	pop    %edi
+80102cb1:	5d                   	pop    %ebp
+80102cb2:	c3                   	ret    
+    panic("log.committing");
+80102cb3:	c7 04 24 c4 71 10 80 	movl   $0x801071c4,(%esp)
+80102cba:	e8 a1 d6 ff ff       	call   80100360 <panic>
+80102cbf:	90                   	nop
+
+80102cc0 <log_write>:
+//   modify bp->data[]
+//   log_write(bp)
+//   brelse(bp)
+void
+log_write(struct buf *b)
+{
+80102cc0:	55                   	push   %ebp
+80102cc1:	89 e5                	mov    %esp,%ebp
+80102cc3:	53                   	push   %ebx
+80102cc4:	83 ec 14             	sub    $0x14,%esp
+  int i;
+
+  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+80102cc7:	a1 c8 26 11 80       	mov    0x801126c8,%eax
+{
+80102ccc:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+80102ccf:	83 f8 1d             	cmp    $0x1d,%eax
+80102cd2:	0f 8f 98 00 00 00    	jg     80102d70 <log_write+0xb0>
+80102cd8:	8b 0d b8 26 11 80    	mov    0x801126b8,%ecx
+80102cde:	8d 51 ff             	lea    -0x1(%ecx),%edx
+80102ce1:	39 d0                	cmp    %edx,%eax
+80102ce3:	0f 8d 87 00 00 00    	jge    80102d70 <log_write+0xb0>
+    panic("too big a transaction");
+  if (log.outstanding < 1)
+80102ce9:	a1 bc 26 11 80       	mov    0x801126bc,%eax
+80102cee:	85 c0                	test   %eax,%eax
+80102cf0:	0f 8e 86 00 00 00    	jle    80102d7c <log_write+0xbc>
+    panic("log_write outside of trans");
+
+  acquire(&log.lock);
+80102cf6:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102cfd:	e8 4e 14 00 00       	call   80104150 <acquire>
+  for (i = 0; i < log.lh.n; i++) {
+80102d02:	8b 15 c8 26 11 80    	mov    0x801126c8,%edx
+80102d08:	83 fa 00             	cmp    $0x0,%edx
+80102d0b:	7e 54                	jle    80102d61 <log_write+0xa1>
+    if (log.lh.block[i] == b->blockno)   // log absorbtion
+80102d0d:	8b 4b 08             	mov    0x8(%ebx),%ecx
+  for (i = 0; i < log.lh.n; i++) {
+80102d10:	31 c0                	xor    %eax,%eax
+    if (log.lh.block[i] == b->blockno)   // log absorbtion
+80102d12:	39 0d cc 26 11 80    	cmp    %ecx,0x801126cc
+80102d18:	75 0f                	jne    80102d29 <log_write+0x69>
+80102d1a:	eb 3c                	jmp    80102d58 <log_write+0x98>
+80102d1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80102d20:	39 0c 85 cc 26 11 80 	cmp    %ecx,-0x7feed934(,%eax,4)
+80102d27:	74 2f                	je     80102d58 <log_write+0x98>
+  for (i = 0; i < log.lh.n; i++) {
+80102d29:	83 c0 01             	add    $0x1,%eax
+80102d2c:	39 d0                	cmp    %edx,%eax
+80102d2e:	75 f0                	jne    80102d20 <log_write+0x60>
+      break;
+  }
+  log.lh.block[i] = b->blockno;
+80102d30:	89 0c 95 cc 26 11 80 	mov    %ecx,-0x7feed934(,%edx,4)
+  if (i == log.lh.n)
+    log.lh.n++;
+80102d37:	83 c2 01             	add    $0x1,%edx
+80102d3a:	89 15 c8 26 11 80    	mov    %edx,0x801126c8
+  b->flags |= B_DIRTY; // prevent eviction
+80102d40:	83 0b 04             	orl    $0x4,(%ebx)
+  release(&log.lock);
+80102d43:	c7 45 08 80 26 11 80 	movl   $0x80112680,0x8(%ebp)
+}
+80102d4a:	83 c4 14             	add    $0x14,%esp
+80102d4d:	5b                   	pop    %ebx
+80102d4e:	5d                   	pop    %ebp
+  release(&log.lock);
+80102d4f:	e9 ec 14 00 00       	jmp    80104240 <release>
+80102d54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  log.lh.block[i] = b->blockno;
+80102d58:	89 0c 85 cc 26 11 80 	mov    %ecx,-0x7feed934(,%eax,4)
+80102d5f:	eb df                	jmp    80102d40 <log_write+0x80>
+80102d61:	8b 43 08             	mov    0x8(%ebx),%eax
+80102d64:	a3 cc 26 11 80       	mov    %eax,0x801126cc
+  if (i == log.lh.n)
+80102d69:	75 d5                	jne    80102d40 <log_write+0x80>
+80102d6b:	eb ca                	jmp    80102d37 <log_write+0x77>
+80102d6d:	8d 76 00             	lea    0x0(%esi),%esi
+    panic("too big a transaction");
+80102d70:	c7 04 24 d3 71 10 80 	movl   $0x801071d3,(%esp)
+80102d77:	e8 e4 d5 ff ff       	call   80100360 <panic>
+    panic("log_write outside of trans");
+80102d7c:	c7 04 24 e9 71 10 80 	movl   $0x801071e9,(%esp)
+80102d83:	e8 d8 d5 ff ff       	call   80100360 <panic>
+80102d88:	66 90                	xchg   %ax,%ax
+80102d8a:	66 90                	xchg   %ax,%ax
+80102d8c:	66 90                	xchg   %ax,%ax
+80102d8e:	66 90                	xchg   %ax,%ax
+
+80102d90 <mpmain>:
+}
+
+// Common CPU setup code.
+static void
+mpmain(void)
+{
+80102d90:	55                   	push   %ebp
+80102d91:	89 e5                	mov    %esp,%ebp
+80102d93:	53                   	push   %ebx
+80102d94:	83 ec 14             	sub    $0x14,%esp
+  cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
+80102d97:	e8 f4 08 00 00       	call   80103690 <cpuid>
+80102d9c:	89 c3                	mov    %eax,%ebx
+80102d9e:	e8 ed 08 00 00       	call   80103690 <cpuid>
+80102da3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+80102da7:	c7 04 24 04 72 10 80 	movl   $0x80107204,(%esp)
+80102dae:	89 44 24 04          	mov    %eax,0x4(%esp)
+80102db2:	e8 99 d8 ff ff       	call   80100650 <cprintf>
+  idtinit();       // load idt register
+80102db7:	e8 54 27 00 00       	call   80105510 <idtinit>
+  xchg(&(mycpu()->started), 1); // tell startothers() we're up
+80102dbc:	e8 4f 08 00 00       	call   80103610 <mycpu>
+80102dc1:	89 c2                	mov    %eax,%edx
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+80102dc3:	b8 01 00 00 00       	mov    $0x1,%eax
+80102dc8:	f0 87 82 a0 00 00 00 	lock xchg %eax,0xa0(%edx)
+  scheduler();     // start running processes
+80102dcf:	e8 9c 0b 00 00       	call   80103970 <scheduler>
+80102dd4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80102dda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+80102de0 <mpenter>:
+{
+80102de0:	55                   	push   %ebp
+80102de1:	89 e5                	mov    %esp,%ebp
+80102de3:	83 ec 08             	sub    $0x8,%esp
+  switchkvm();
+80102de6:	e8 e5 37 00 00       	call   801065d0 <switchkvm>
+  seginit();
+80102deb:	e8 a0 36 00 00       	call   80106490 <seginit>
+  lapicinit();
+80102df0:	e8 8b f8 ff ff       	call   80102680 <lapicinit>
+  mpmain();
+80102df5:	e8 96 ff ff ff       	call   80102d90 <mpmain>
+80102dfa:	66 90                	xchg   %ax,%ax
+80102dfc:	66 90                	xchg   %ax,%ax
+80102dfe:	66 90                	xchg   %ax,%ax
+
+80102e00 <main>:
+{
+80102e00:	55                   	push   %ebp
+80102e01:	89 e5                	mov    %esp,%ebp
+80102e03:	53                   	push   %ebx
+  // The linker has placed the image of entryother.S in
+  // _binary_entryother_start.
+  code = P2V(0x7000);
+  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+
+  for(c = cpus; c < cpus+ncpu; c++){
+80102e04:	bb 80 27 11 80       	mov    $0x80112780,%ebx
+{
+80102e09:	83 e4 f0             	and    $0xfffffff0,%esp
+80102e0c:	83 ec 10             	sub    $0x10,%esp
+  kinit1(end, P2V(4*1024*1024)); // phys page allocator
+80102e0f:	c7 44 24 04 00 00 40 	movl   $0x80400000,0x4(%esp)
+80102e16:	80 
+80102e17:	c7 04 24 f4 57 11 80 	movl   $0x801157f4,(%esp)
+80102e1e:	e8 cd f5 ff ff       	call   801023f0 <kinit1>
+  kvmalloc();      // kernel page table
+80102e23:	e8 58 3c 00 00       	call   80106a80 <kvmalloc>
+  mpinit();        // detect other processors
+80102e28:	e8 73 01 00 00       	call   80102fa0 <mpinit>
+80102e2d:	8d 76 00             	lea    0x0(%esi),%esi
+  lapicinit();     // interrupt controller
+80102e30:	e8 4b f8 ff ff       	call   80102680 <lapicinit>
+  seginit();       // segment descriptors
+80102e35:	e8 56 36 00 00       	call   80106490 <seginit>
+  picinit();       // disable pic
+80102e3a:	e8 21 03 00 00       	call   80103160 <picinit>
+80102e3f:	90                   	nop
+  ioapicinit();    // another interrupt controller
+80102e40:	e8 cb f3 ff ff       	call   80102210 <ioapicinit>
+  consoleinit();   // console hardware
+80102e45:	e8 06 db ff ff       	call   80100950 <consoleinit>
+  uartinit();      // serial port
+80102e4a:	e8 e1 29 00 00       	call   80105830 <uartinit>
+80102e4f:	90                   	nop
+  pinit();         // process table
+80102e50:	e8 9b 07 00 00       	call   801035f0 <pinit>
+  shminit();       // shared memory
+80102e55:	e8 36 3e 00 00       	call   80106c90 <shminit>
+  tvinit();        // trap vectors
+80102e5a:	e8 11 26 00 00       	call   80105470 <tvinit>
+80102e5f:	90                   	nop
+  binit();         // buffer cache
+80102e60:	e8 db d1 ff ff       	call   80100040 <binit>
+  fileinit();      // file table
+80102e65:	e8 e6 de ff ff       	call   80100d50 <fileinit>
+  ideinit();       // disk 
+80102e6a:	e8 a1 f1 ff ff       	call   80102010 <ideinit>
+  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+80102e6f:	c7 44 24 08 8a 00 00 	movl   $0x8a,0x8(%esp)
+80102e76:	00 
+80102e77:	c7 44 24 04 8c a4 10 	movl   $0x8010a48c,0x4(%esp)
+80102e7e:	80 
+80102e7f:	c7 04 24 00 70 00 80 	movl   $0x80007000,(%esp)
+80102e86:	e8 a5 14 00 00       	call   80104330 <memmove>
+  for(c = cpus; c < cpus+ncpu; c++){
+80102e8b:	69 05 00 2d 11 80 b0 	imul   $0xb0,0x80112d00,%eax
+80102e92:	00 00 00 
+80102e95:	05 80 27 11 80       	add    $0x80112780,%eax
+80102e9a:	39 d8                	cmp    %ebx,%eax
+80102e9c:	76 65                	jbe    80102f03 <main+0x103>
+80102e9e:	66 90                	xchg   %ax,%ax
+    if(c == mycpu())  // We've started already.
+80102ea0:	e8 6b 07 00 00       	call   80103610 <mycpu>
+80102ea5:	39 d8                	cmp    %ebx,%eax
+80102ea7:	74 41                	je     80102eea <main+0xea>
+      continue;
+
+    // Tell entryother.S what stack to use, where to enter, and what
+    // pgdir to use. We cannot use kpgdir yet, because the AP processor
+    // is running in low  memory, so we use entrypgdir for the APs too.
+    stack = kalloc();
+80102ea9:	e8 02 f6 ff ff       	call   801024b0 <kalloc>
+    *(void**)(code-4) = stack + KSTACKSIZE;
+    *(void**)(code-8) = mpenter;
+80102eae:	c7 05 f8 6f 00 80 e0 	movl   $0x80102de0,0x80006ff8
+80102eb5:	2d 10 80 
+    *(int**)(code-12) = (void *) V2P(entrypgdir);
+80102eb8:	c7 05 f4 6f 00 80 00 	movl   $0x109000,0x80006ff4
+80102ebf:	90 10 00 
+    *(void**)(code-4) = stack + KSTACKSIZE;
+80102ec2:	05 00 10 00 00       	add    $0x1000,%eax
+80102ec7:	a3 fc 6f 00 80       	mov    %eax,0x80006ffc
+
+    lapicstartap(c->apicid, V2P(code));
+80102ecc:	0f b6 03             	movzbl (%ebx),%eax
+80102ecf:	c7 44 24 04 00 70 00 	movl   $0x7000,0x4(%esp)
+80102ed6:	00 
+80102ed7:	89 04 24             	mov    %eax,(%esp)
+80102eda:	e8 e1 f8 ff ff       	call   801027c0 <lapicstartap>
+80102edf:	90                   	nop
+
+    // wait for cpu to finish mpmain()
+    while(c->started == 0)
+80102ee0:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
+80102ee6:	85 c0                	test   %eax,%eax
+80102ee8:	74 f6                	je     80102ee0 <main+0xe0>
+  for(c = cpus; c < cpus+ncpu; c++){
+80102eea:	69 05 00 2d 11 80 b0 	imul   $0xb0,0x80112d00,%eax
+80102ef1:	00 00 00 
+80102ef4:	81 c3 b0 00 00 00    	add    $0xb0,%ebx
+80102efa:	05 80 27 11 80       	add    $0x80112780,%eax
+80102eff:	39 c3                	cmp    %eax,%ebx
+80102f01:	72 9d                	jb     80102ea0 <main+0xa0>
+  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+80102f03:	c7 44 24 04 00 00 00 	movl   $0x8e000000,0x4(%esp)
+80102f0a:	8e 
+80102f0b:	c7 04 24 00 00 40 80 	movl   $0x80400000,(%esp)
+80102f12:	e8 49 f5 ff ff       	call   80102460 <kinit2>
+  userinit();      // first user process
+80102f17:	e8 c4 07 00 00       	call   801036e0 <userinit>
+  mpmain();        // finish this processor's setup
+80102f1c:	e8 6f fe ff ff       	call   80102d90 <mpmain>
+80102f21:	66 90                	xchg   %ax,%ax
+80102f23:	66 90                	xchg   %ax,%ax
+80102f25:	66 90                	xchg   %ax,%ax
+80102f27:	66 90                	xchg   %ax,%ax
+80102f29:	66 90                	xchg   %ax,%ax
+80102f2b:	66 90                	xchg   %ax,%ax
+80102f2d:	66 90                	xchg   %ax,%ax
+80102f2f:	90                   	nop
+
+80102f30 <mpsearch1>:
+}
+
+// Look for an MP structure in the len bytes at addr.
+static struct mp*
+mpsearch1(uint a, int len)
+{
+80102f30:	55                   	push   %ebp
+80102f31:	89 e5                	mov    %esp,%ebp
+80102f33:	56                   	push   %esi
+  uchar *e, *p, *addr;
+
+  addr = P2V(a);
+80102f34:	8d b0 00 00 00 80    	lea    -0x80000000(%eax),%esi
+{
+80102f3a:	53                   	push   %ebx
+  e = addr+len;
+80102f3b:	8d 1c 16             	lea    (%esi,%edx,1),%ebx
+{
+80102f3e:	83 ec 10             	sub    $0x10,%esp
+  for(p = addr; p < e; p += sizeof(struct mp))
+80102f41:	39 de                	cmp    %ebx,%esi
+80102f43:	73 3c                	jae    80102f81 <mpsearch1+0x51>
+80102f45:	8d 76 00             	lea    0x0(%esi),%esi
+    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+80102f48:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
+80102f4f:	00 
+80102f50:	c7 44 24 04 18 72 10 	movl   $0x80107218,0x4(%esp)
+80102f57:	80 
+80102f58:	89 34 24             	mov    %esi,(%esp)
+80102f5b:	e8 80 13 00 00       	call   801042e0 <memcmp>
+80102f60:	85 c0                	test   %eax,%eax
+80102f62:	75 16                	jne    80102f7a <mpsearch1+0x4a>
+80102f64:	31 c9                	xor    %ecx,%ecx
+80102f66:	31 d2                	xor    %edx,%edx
+    sum += addr[i];
+80102f68:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
+  for(i=0; i<len; i++)
+80102f6c:	83 c2 01             	add    $0x1,%edx
+    sum += addr[i];
+80102f6f:	01 c1                	add    %eax,%ecx
+  for(i=0; i<len; i++)
+80102f71:	83 fa 10             	cmp    $0x10,%edx
+80102f74:	75 f2                	jne    80102f68 <mpsearch1+0x38>
+    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+80102f76:	84 c9                	test   %cl,%cl
+80102f78:	74 10                	je     80102f8a <mpsearch1+0x5a>
+  for(p = addr; p < e; p += sizeof(struct mp))
+80102f7a:	83 c6 10             	add    $0x10,%esi
+80102f7d:	39 f3                	cmp    %esi,%ebx
+80102f7f:	77 c7                	ja     80102f48 <mpsearch1+0x18>
+      return (struct mp*)p;
+  return 0;
+}
+80102f81:	83 c4 10             	add    $0x10,%esp
+  return 0;
+80102f84:	31 c0                	xor    %eax,%eax
+}
+80102f86:	5b                   	pop    %ebx
+80102f87:	5e                   	pop    %esi
+80102f88:	5d                   	pop    %ebp
+80102f89:	c3                   	ret    
+80102f8a:	83 c4 10             	add    $0x10,%esp
+80102f8d:	89 f0                	mov    %esi,%eax
+80102f8f:	5b                   	pop    %ebx
+80102f90:	5e                   	pop    %esi
+80102f91:	5d                   	pop    %ebp
+80102f92:	c3                   	ret    
+80102f93:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80102f99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80102fa0 <mpinit>:
+  return conf;
+}
+
+void
+mpinit(void)
+{
+80102fa0:	55                   	push   %ebp
+80102fa1:	89 e5                	mov    %esp,%ebp
+80102fa3:	57                   	push   %edi
+80102fa4:	56                   	push   %esi
+80102fa5:	53                   	push   %ebx
+80102fa6:	83 ec 1c             	sub    $0x1c,%esp
+  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
+80102fa9:	0f b6 05 0f 04 00 80 	movzbl 0x8000040f,%eax
+80102fb0:	0f b6 15 0e 04 00 80 	movzbl 0x8000040e,%edx
+80102fb7:	c1 e0 08             	shl    $0x8,%eax
+80102fba:	09 d0                	or     %edx,%eax
+80102fbc:	c1 e0 04             	shl    $0x4,%eax
+80102fbf:	85 c0                	test   %eax,%eax
+80102fc1:	75 1b                	jne    80102fde <mpinit+0x3e>
+    p = ((bda[0x14]<<8)|bda[0x13])*1024;
+80102fc3:	0f b6 05 14 04 00 80 	movzbl 0x80000414,%eax
+80102fca:	0f b6 15 13 04 00 80 	movzbl 0x80000413,%edx
+80102fd1:	c1 e0 08             	shl    $0x8,%eax
+80102fd4:	09 d0                	or     %edx,%eax
+80102fd6:	c1 e0 0a             	shl    $0xa,%eax
+    if((mp = mpsearch1(p-1024, 1024)))
+80102fd9:	2d 00 04 00 00       	sub    $0x400,%eax
+    if((mp = mpsearch1(p, 1024)))
+80102fde:	ba 00 04 00 00       	mov    $0x400,%edx
+80102fe3:	e8 48 ff ff ff       	call   80102f30 <mpsearch1>
+80102fe8:	85 c0                	test   %eax,%eax
+80102fea:	89 c7                	mov    %eax,%edi
+80102fec:	0f 84 22 01 00 00    	je     80103114 <mpinit+0x174>
+  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+80102ff2:	8b 77 04             	mov    0x4(%edi),%esi
+80102ff5:	85 f6                	test   %esi,%esi
+80102ff7:	0f 84 30 01 00 00    	je     8010312d <mpinit+0x18d>
+  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+80102ffd:	8d 86 00 00 00 80    	lea    -0x80000000(%esi),%eax
+  if(memcmp(conf, "PCMP", 4) != 0)
+80103003:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
+8010300a:	00 
+8010300b:	c7 44 24 04 1d 72 10 	movl   $0x8010721d,0x4(%esp)
+80103012:	80 
+80103013:	89 04 24             	mov    %eax,(%esp)
+  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+80103016:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(memcmp(conf, "PCMP", 4) != 0)
+80103019:	e8 c2 12 00 00       	call   801042e0 <memcmp>
+8010301e:	85 c0                	test   %eax,%eax
+80103020:	0f 85 07 01 00 00    	jne    8010312d <mpinit+0x18d>
+  if(conf->version != 1 && conf->version != 4)
+80103026:	0f b6 86 06 00 00 80 	movzbl -0x7ffffffa(%esi),%eax
+8010302d:	3c 04                	cmp    $0x4,%al
+8010302f:	0f 85 0b 01 00 00    	jne    80103140 <mpinit+0x1a0>
+  if(sum((uchar*)conf, conf->length) != 0)
+80103035:	0f b7 86 04 00 00 80 	movzwl -0x7ffffffc(%esi),%eax
+  for(i=0; i<len; i++)
+8010303c:	85 c0                	test   %eax,%eax
+8010303e:	74 21                	je     80103061 <mpinit+0xc1>
+  sum = 0;
+80103040:	31 c9                	xor    %ecx,%ecx
+  for(i=0; i<len; i++)
+80103042:	31 d2                	xor    %edx,%edx
+80103044:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    sum += addr[i];
+80103048:	0f b6 9c 16 00 00 00 	movzbl -0x80000000(%esi,%edx,1),%ebx
+8010304f:	80 
+  for(i=0; i<len; i++)
+80103050:	83 c2 01             	add    $0x1,%edx
+    sum += addr[i];
+80103053:	01 d9                	add    %ebx,%ecx
+  for(i=0; i<len; i++)
+80103055:	39 d0                	cmp    %edx,%eax
+80103057:	7f ef                	jg     80103048 <mpinit+0xa8>
+  if(sum((uchar*)conf, conf->length) != 0)
+80103059:	84 c9                	test   %cl,%cl
+8010305b:	0f 85 cc 00 00 00    	jne    8010312d <mpinit+0x18d>
+  struct mp *mp;
+  struct mpconf *conf;
+  struct mpproc *proc;
+  struct mpioapic *ioapic;
+
+  if((conf = mpconfig(&mp)) == 0)
+80103061:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80103064:	85 c0                	test   %eax,%eax
+80103066:	0f 84 c1 00 00 00    	je     8010312d <mpinit+0x18d>
+    panic("Expect to run on an SMP");
+  ismp = 1;
+  lapic = (uint*)conf->lapicaddr;
+8010306c:	8b 86 24 00 00 80    	mov    -0x7fffffdc(%esi),%eax
+  ismp = 1;
+80103072:	bb 01 00 00 00       	mov    $0x1,%ebx
+  lapic = (uint*)conf->lapicaddr;
+80103077:	a3 7c 26 11 80       	mov    %eax,0x8011267c
+  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+8010307c:	0f b7 96 04 00 00 80 	movzwl -0x7ffffffc(%esi),%edx
+80103083:	8d 86 2c 00 00 80    	lea    -0x7fffffd4(%esi),%eax
+80103089:	03 55 e4             	add    -0x1c(%ebp),%edx
+8010308c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80103090:	39 c2                	cmp    %eax,%edx
+80103092:	76 1b                	jbe    801030af <mpinit+0x10f>
+80103094:	0f b6 08             	movzbl (%eax),%ecx
+    switch(*p){
+80103097:	80 f9 04             	cmp    $0x4,%cl
+8010309a:	77 74                	ja     80103110 <mpinit+0x170>
+8010309c:	ff 24 8d 5c 72 10 80 	jmp    *-0x7fef8da4(,%ecx,4)
+801030a3:	90                   	nop
+801030a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      p += sizeof(struct mpioapic);
+      continue;
+    case MPBUS:
+    case MPIOINTR:
+    case MPLINTR:
+      p += 8;
+801030a8:	83 c0 08             	add    $0x8,%eax
+  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+801030ab:	39 c2                	cmp    %eax,%edx
+801030ad:	77 e5                	ja     80103094 <mpinit+0xf4>
+    default:
+      ismp = 0;
+      break;
+    }
+  }
+  if(!ismp)
+801030af:	85 db                	test   %ebx,%ebx
+801030b1:	0f 84 93 00 00 00    	je     8010314a <mpinit+0x1aa>
+    panic("Didn't find a suitable machine");
+
+  if(mp->imcrp){
+801030b7:	80 7f 0c 00          	cmpb   $0x0,0xc(%edi)
+801030bb:	74 12                	je     801030cf <mpinit+0x12f>
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801030bd:	ba 22 00 00 00       	mov    $0x22,%edx
+801030c2:	b8 70 00 00 00       	mov    $0x70,%eax
+801030c7:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801030c8:	b2 23                	mov    $0x23,%dl
+801030ca:	ec                   	in     (%dx),%al
+    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
+    // But it would on real hardware.
+    outb(0x22, 0x70);   // Select IMCR
+    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
+801030cb:	83 c8 01             	or     $0x1,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801030ce:	ee                   	out    %al,(%dx)
+  }
+}
+801030cf:	83 c4 1c             	add    $0x1c,%esp
+801030d2:	5b                   	pop    %ebx
+801030d3:	5e                   	pop    %esi
+801030d4:	5f                   	pop    %edi
+801030d5:	5d                   	pop    %ebp
+801030d6:	c3                   	ret    
+801030d7:	90                   	nop
+      if(ncpu < NCPU) {
+801030d8:	8b 35 00 2d 11 80    	mov    0x80112d00,%esi
+801030de:	83 fe 07             	cmp    $0x7,%esi
+801030e1:	7f 17                	jg     801030fa <mpinit+0x15a>
+        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+801030e3:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
+801030e7:	69 f6 b0 00 00 00    	imul   $0xb0,%esi,%esi
+        ncpu++;
+801030ed:	83 05 00 2d 11 80 01 	addl   $0x1,0x80112d00
+        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+801030f4:	88 8e 80 27 11 80    	mov    %cl,-0x7feed880(%esi)
+      p += sizeof(struct mpproc);
+801030fa:	83 c0 14             	add    $0x14,%eax
+      continue;
+801030fd:	eb 91                	jmp    80103090 <mpinit+0xf0>
+801030ff:	90                   	nop
+      ioapicid = ioapic->apicno;
+80103100:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
+      p += sizeof(struct mpioapic);
+80103104:	83 c0 08             	add    $0x8,%eax
+      ioapicid = ioapic->apicno;
+80103107:	88 0d 60 27 11 80    	mov    %cl,0x80112760
+      continue;
+8010310d:	eb 81                	jmp    80103090 <mpinit+0xf0>
+8010310f:	90                   	nop
+      ismp = 0;
+80103110:	31 db                	xor    %ebx,%ebx
+80103112:	eb 83                	jmp    80103097 <mpinit+0xf7>
+  return mpsearch1(0xF0000, 0x10000);
+80103114:	ba 00 00 01 00       	mov    $0x10000,%edx
+80103119:	b8 00 00 0f 00       	mov    $0xf0000,%eax
+8010311e:	e8 0d fe ff ff       	call   80102f30 <mpsearch1>
+  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+80103123:	85 c0                	test   %eax,%eax
+  return mpsearch1(0xF0000, 0x10000);
+80103125:	89 c7                	mov    %eax,%edi
+  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+80103127:	0f 85 c5 fe ff ff    	jne    80102ff2 <mpinit+0x52>
+    panic("Expect to run on an SMP");
+8010312d:	c7 04 24 22 72 10 80 	movl   $0x80107222,(%esp)
+80103134:	e8 27 d2 ff ff       	call   80100360 <panic>
+80103139:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  if(conf->version != 1 && conf->version != 4)
+80103140:	3c 01                	cmp    $0x1,%al
+80103142:	0f 84 ed fe ff ff    	je     80103035 <mpinit+0x95>
+80103148:	eb e3                	jmp    8010312d <mpinit+0x18d>
+    panic("Didn't find a suitable machine");
+8010314a:	c7 04 24 3c 72 10 80 	movl   $0x8010723c,(%esp)
+80103151:	e8 0a d2 ff ff       	call   80100360 <panic>
+80103156:	66 90                	xchg   %ax,%ax
+80103158:	66 90                	xchg   %ax,%ax
+8010315a:	66 90                	xchg   %ax,%ax
+8010315c:	66 90                	xchg   %ax,%ax
+8010315e:	66 90                	xchg   %ax,%ax
+
+80103160 <picinit>:
+#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
+
+// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
+void
+picinit(void)
+{
+80103160:	55                   	push   %ebp
+80103161:	ba 21 00 00 00       	mov    $0x21,%edx
+80103166:	89 e5                	mov    %esp,%ebp
+80103168:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010316d:	ee                   	out    %al,(%dx)
+8010316e:	b2 a1                	mov    $0xa1,%dl
+80103170:	ee                   	out    %al,(%dx)
+  // mask all interrupts
+  outb(IO_PIC1+1, 0xFF);
+  outb(IO_PIC2+1, 0xFF);
+}
+80103171:	5d                   	pop    %ebp
+80103172:	c3                   	ret    
+80103173:	66 90                	xchg   %ax,%ax
+80103175:	66 90                	xchg   %ax,%ax
+80103177:	66 90                	xchg   %ax,%ax
+80103179:	66 90                	xchg   %ax,%ax
+8010317b:	66 90                	xchg   %ax,%ax
+8010317d:	66 90                	xchg   %ax,%ax
+8010317f:	90                   	nop
+
+80103180 <pipealloc>:
+  int writeopen;  // write fd is still open
+};
+
+int
+pipealloc(struct file **f0, struct file **f1)
+{
+80103180:	55                   	push   %ebp
+80103181:	89 e5                	mov    %esp,%ebp
+80103183:	57                   	push   %edi
+80103184:	56                   	push   %esi
+80103185:	53                   	push   %ebx
+80103186:	83 ec 1c             	sub    $0x1c,%esp
+80103189:	8b 75 08             	mov    0x8(%ebp),%esi
+8010318c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  struct pipe *p;
+
+  p = 0;
+  *f0 = *f1 = 0;
+8010318f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+80103195:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
+  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
+8010319b:	e8 d0 db ff ff       	call   80100d70 <filealloc>
+801031a0:	85 c0                	test   %eax,%eax
+801031a2:	89 06                	mov    %eax,(%esi)
+801031a4:	0f 84 a4 00 00 00    	je     8010324e <pipealloc+0xce>
+801031aa:	e8 c1 db ff ff       	call   80100d70 <filealloc>
+801031af:	85 c0                	test   %eax,%eax
+801031b1:	89 03                	mov    %eax,(%ebx)
+801031b3:	0f 84 87 00 00 00    	je     80103240 <pipealloc+0xc0>
+    goto bad;
+  if((p = (struct pipe*)kalloc()) == 0)
+801031b9:	e8 f2 f2 ff ff       	call   801024b0 <kalloc>
+801031be:	85 c0                	test   %eax,%eax
+801031c0:	89 c7                	mov    %eax,%edi
+801031c2:	74 7c                	je     80103240 <pipealloc+0xc0>
+    goto bad;
+  p->readopen = 1;
+801031c4:	c7 80 3c 02 00 00 01 	movl   $0x1,0x23c(%eax)
+801031cb:	00 00 00 
+  p->writeopen = 1;
+801031ce:	c7 80 40 02 00 00 01 	movl   $0x1,0x240(%eax)
+801031d5:	00 00 00 
+  p->nwrite = 0;
+801031d8:	c7 80 38 02 00 00 00 	movl   $0x0,0x238(%eax)
+801031df:	00 00 00 
+  p->nread = 0;
+801031e2:	c7 80 34 02 00 00 00 	movl   $0x0,0x234(%eax)
+801031e9:	00 00 00 
+  initlock(&p->lock, "pipe");
+801031ec:	89 04 24             	mov    %eax,(%esp)
+801031ef:	c7 44 24 04 70 72 10 	movl   $0x80107270,0x4(%esp)
+801031f6:	80 
+801031f7:	e8 64 0e 00 00       	call   80104060 <initlock>
+  (*f0)->type = FD_PIPE;
+801031fc:	8b 06                	mov    (%esi),%eax
+801031fe:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+  (*f0)->readable = 1;
+80103204:	8b 06                	mov    (%esi),%eax
+80103206:	c6 40 08 01          	movb   $0x1,0x8(%eax)
+  (*f0)->writable = 0;
+8010320a:	8b 06                	mov    (%esi),%eax
+8010320c:	c6 40 09 00          	movb   $0x0,0x9(%eax)
+  (*f0)->pipe = p;
+80103210:	8b 06                	mov    (%esi),%eax
+80103212:	89 78 0c             	mov    %edi,0xc(%eax)
+  (*f1)->type = FD_PIPE;
+80103215:	8b 03                	mov    (%ebx),%eax
+80103217:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+  (*f1)->readable = 0;
+8010321d:	8b 03                	mov    (%ebx),%eax
+8010321f:	c6 40 08 00          	movb   $0x0,0x8(%eax)
+  (*f1)->writable = 1;
+80103223:	8b 03                	mov    (%ebx),%eax
+80103225:	c6 40 09 01          	movb   $0x1,0x9(%eax)
+  (*f1)->pipe = p;
+80103229:	8b 03                	mov    (%ebx),%eax
+  return 0;
+8010322b:	31 db                	xor    %ebx,%ebx
+  (*f1)->pipe = p;
+8010322d:	89 78 0c             	mov    %edi,0xc(%eax)
+  if(*f0)
+    fileclose(*f0);
+  if(*f1)
+    fileclose(*f1);
+  return -1;
+}
+80103230:	83 c4 1c             	add    $0x1c,%esp
+80103233:	89 d8                	mov    %ebx,%eax
+80103235:	5b                   	pop    %ebx
+80103236:	5e                   	pop    %esi
+80103237:	5f                   	pop    %edi
+80103238:	5d                   	pop    %ebp
+80103239:	c3                   	ret    
+8010323a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  if(*f0)
+80103240:	8b 06                	mov    (%esi),%eax
+80103242:	85 c0                	test   %eax,%eax
+80103244:	74 08                	je     8010324e <pipealloc+0xce>
+    fileclose(*f0);
+80103246:	89 04 24             	mov    %eax,(%esp)
+80103249:	e8 e2 db ff ff       	call   80100e30 <fileclose>
+  if(*f1)
+8010324e:	8b 03                	mov    (%ebx),%eax
+  return -1;
+80103250:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
+  if(*f1)
+80103255:	85 c0                	test   %eax,%eax
+80103257:	74 d7                	je     80103230 <pipealloc+0xb0>
+    fileclose(*f1);
+80103259:	89 04 24             	mov    %eax,(%esp)
+8010325c:	e8 cf db ff ff       	call   80100e30 <fileclose>
+}
+80103261:	83 c4 1c             	add    $0x1c,%esp
+80103264:	89 d8                	mov    %ebx,%eax
+80103266:	5b                   	pop    %ebx
+80103267:	5e                   	pop    %esi
+80103268:	5f                   	pop    %edi
+80103269:	5d                   	pop    %ebp
+8010326a:	c3                   	ret    
+8010326b:	90                   	nop
+8010326c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80103270 <pipeclose>:
+
+void
+pipeclose(struct pipe *p, int writable)
+{
+80103270:	55                   	push   %ebp
+80103271:	89 e5                	mov    %esp,%ebp
+80103273:	56                   	push   %esi
+80103274:	53                   	push   %ebx
+80103275:	83 ec 10             	sub    $0x10,%esp
+80103278:	8b 5d 08             	mov    0x8(%ebp),%ebx
+8010327b:	8b 75 0c             	mov    0xc(%ebp),%esi
+  acquire(&p->lock);
+8010327e:	89 1c 24             	mov    %ebx,(%esp)
+80103281:	e8 ca 0e 00 00       	call   80104150 <acquire>
+  if(writable){
+80103286:	85 f6                	test   %esi,%esi
+80103288:	74 3e                	je     801032c8 <pipeclose+0x58>
+    p->writeopen = 0;
+    wakeup(&p->nread);
+8010328a:	8d 83 34 02 00 00    	lea    0x234(%ebx),%eax
+    p->writeopen = 0;
+80103290:	c7 83 40 02 00 00 00 	movl   $0x0,0x240(%ebx)
+80103297:	00 00 00 
+    wakeup(&p->nread);
+8010329a:	89 04 24             	mov    %eax,(%esp)
+8010329d:	e8 fe 0a 00 00       	call   80103da0 <wakeup>
+  } else {
+    p->readopen = 0;
+    wakeup(&p->nwrite);
+  }
+  if(p->readopen == 0 && p->writeopen == 0){
+801032a2:	8b 93 3c 02 00 00    	mov    0x23c(%ebx),%edx
+801032a8:	85 d2                	test   %edx,%edx
+801032aa:	75 0a                	jne    801032b6 <pipeclose+0x46>
+801032ac:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
+801032b2:	85 c0                	test   %eax,%eax
+801032b4:	74 32                	je     801032e8 <pipeclose+0x78>
+    release(&p->lock);
+    kfree((char*)p);
+  } else
+    release(&p->lock);
+801032b6:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+801032b9:	83 c4 10             	add    $0x10,%esp
+801032bc:	5b                   	pop    %ebx
+801032bd:	5e                   	pop    %esi
+801032be:	5d                   	pop    %ebp
+    release(&p->lock);
+801032bf:	e9 7c 0f 00 00       	jmp    80104240 <release>
+801032c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    wakeup(&p->nwrite);
+801032c8:	8d 83 38 02 00 00    	lea    0x238(%ebx),%eax
+    p->readopen = 0;
+801032ce:	c7 83 3c 02 00 00 00 	movl   $0x0,0x23c(%ebx)
+801032d5:	00 00 00 
+    wakeup(&p->nwrite);
+801032d8:	89 04 24             	mov    %eax,(%esp)
+801032db:	e8 c0 0a 00 00       	call   80103da0 <wakeup>
+801032e0:	eb c0                	jmp    801032a2 <pipeclose+0x32>
+801032e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    release(&p->lock);
+801032e8:	89 1c 24             	mov    %ebx,(%esp)
+801032eb:	e8 50 0f 00 00       	call   80104240 <release>
+    kfree((char*)p);
+801032f0:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+801032f3:	83 c4 10             	add    $0x10,%esp
+801032f6:	5b                   	pop    %ebx
+801032f7:	5e                   	pop    %esi
+801032f8:	5d                   	pop    %ebp
+    kfree((char*)p);
+801032f9:	e9 02 f0 ff ff       	jmp    80102300 <kfree>
+801032fe:	66 90                	xchg   %ax,%ax
+
+80103300 <pipewrite>:
+
+//PAGEBREAK: 40
+int
+pipewrite(struct pipe *p, char *addr, int n)
+{
+80103300:	55                   	push   %ebp
+80103301:	89 e5                	mov    %esp,%ebp
+80103303:	57                   	push   %edi
+80103304:	56                   	push   %esi
+80103305:	53                   	push   %ebx
+80103306:	83 ec 1c             	sub    $0x1c,%esp
+80103309:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  int i;
+
+  acquire(&p->lock);
+8010330c:	89 1c 24             	mov    %ebx,(%esp)
+8010330f:	e8 3c 0e 00 00       	call   80104150 <acquire>
+  for(i = 0; i < n; i++){
+80103314:	8b 4d 10             	mov    0x10(%ebp),%ecx
+80103317:	85 c9                	test   %ecx,%ecx
+80103319:	0f 8e b2 00 00 00    	jle    801033d1 <pipewrite+0xd1>
+8010331f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+      if(p->readopen == 0 || myproc()->killed){
+        release(&p->lock);
+        return -1;
+      }
+      wakeup(&p->nread);
+80103322:	8d bb 34 02 00 00    	lea    0x234(%ebx),%edi
+80103328:	8b 83 38 02 00 00    	mov    0x238(%ebx),%eax
+      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+8010332e:	8d b3 38 02 00 00    	lea    0x238(%ebx),%esi
+80103334:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+80103337:	03 4d 10             	add    0x10(%ebp),%ecx
+8010333a:	89 4d e0             	mov    %ecx,-0x20(%ebp)
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+8010333d:	8b 8b 34 02 00 00    	mov    0x234(%ebx),%ecx
+80103343:	81 c1 00 02 00 00    	add    $0x200,%ecx
+80103349:	39 c8                	cmp    %ecx,%eax
+8010334b:	74 38                	je     80103385 <pipewrite+0x85>
+8010334d:	eb 55                	jmp    801033a4 <pipewrite+0xa4>
+8010334f:	90                   	nop
+      if(p->readopen == 0 || myproc()->killed){
+80103350:	e8 5b 03 00 00       	call   801036b0 <myproc>
+80103355:	8b 40 24             	mov    0x24(%eax),%eax
+80103358:	85 c0                	test   %eax,%eax
+8010335a:	75 33                	jne    8010338f <pipewrite+0x8f>
+      wakeup(&p->nread);
+8010335c:	89 3c 24             	mov    %edi,(%esp)
+8010335f:	e8 3c 0a 00 00       	call   80103da0 <wakeup>
+      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+80103364:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80103368:	89 34 24             	mov    %esi,(%esp)
+8010336b:	e8 a0 08 00 00       	call   80103c10 <sleep>
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+80103370:	8b 83 34 02 00 00    	mov    0x234(%ebx),%eax
+80103376:	8b 93 38 02 00 00    	mov    0x238(%ebx),%edx
+8010337c:	05 00 02 00 00       	add    $0x200,%eax
+80103381:	39 c2                	cmp    %eax,%edx
+80103383:	75 23                	jne    801033a8 <pipewrite+0xa8>
+      if(p->readopen == 0 || myproc()->killed){
+80103385:	8b 93 3c 02 00 00    	mov    0x23c(%ebx),%edx
+8010338b:	85 d2                	test   %edx,%edx
+8010338d:	75 c1                	jne    80103350 <pipewrite+0x50>
+        release(&p->lock);
+8010338f:	89 1c 24             	mov    %ebx,(%esp)
+80103392:	e8 a9 0e 00 00       	call   80104240 <release>
+        return -1;
+80103397:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+  }
+  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+  release(&p->lock);
+  return n;
+}
+8010339c:	83 c4 1c             	add    $0x1c,%esp
+8010339f:	5b                   	pop    %ebx
+801033a0:	5e                   	pop    %esi
+801033a1:	5f                   	pop    %edi
+801033a2:	5d                   	pop    %ebp
+801033a3:	c3                   	ret    
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+801033a4:	89 c2                	mov    %eax,%edx
+801033a6:	66 90                	xchg   %ax,%ax
+    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+801033a8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+801033ab:	8d 42 01             	lea    0x1(%edx),%eax
+801033ae:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
+801033b4:	89 83 38 02 00 00    	mov    %eax,0x238(%ebx)
+801033ba:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
+801033be:	0f b6 09             	movzbl (%ecx),%ecx
+801033c1:	88 4c 13 34          	mov    %cl,0x34(%ebx,%edx,1)
+  for(i = 0; i < n; i++){
+801033c5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+801033c8:	3b 4d e0             	cmp    -0x20(%ebp),%ecx
+801033cb:	0f 85 6c ff ff ff    	jne    8010333d <pipewrite+0x3d>
+  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+801033d1:	8d 83 34 02 00 00    	lea    0x234(%ebx),%eax
+801033d7:	89 04 24             	mov    %eax,(%esp)
+801033da:	e8 c1 09 00 00       	call   80103da0 <wakeup>
+  release(&p->lock);
+801033df:	89 1c 24             	mov    %ebx,(%esp)
+801033e2:	e8 59 0e 00 00       	call   80104240 <release>
+  return n;
+801033e7:	8b 45 10             	mov    0x10(%ebp),%eax
+801033ea:	eb b0                	jmp    8010339c <pipewrite+0x9c>
+801033ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+801033f0 <piperead>:
+
+int
+piperead(struct pipe *p, char *addr, int n)
+{
+801033f0:	55                   	push   %ebp
+801033f1:	89 e5                	mov    %esp,%ebp
+801033f3:	57                   	push   %edi
+801033f4:	56                   	push   %esi
+801033f5:	53                   	push   %ebx
+801033f6:	83 ec 1c             	sub    $0x1c,%esp
+801033f9:	8b 75 08             	mov    0x8(%ebp),%esi
+801033fc:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  int i;
+
+  acquire(&p->lock);
+801033ff:	89 34 24             	mov    %esi,(%esp)
+80103402:	e8 49 0d 00 00       	call   80104150 <acquire>
+  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+80103407:	8b 86 34 02 00 00    	mov    0x234(%esi),%eax
+8010340d:	3b 86 38 02 00 00    	cmp    0x238(%esi),%eax
+80103413:	75 5b                	jne    80103470 <piperead+0x80>
+80103415:	8b 9e 40 02 00 00    	mov    0x240(%esi),%ebx
+8010341b:	85 db                	test   %ebx,%ebx
+8010341d:	74 51                	je     80103470 <piperead+0x80>
+    if(myproc()->killed){
+      release(&p->lock);
+      return -1;
+    }
+    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+8010341f:	8d 9e 34 02 00 00    	lea    0x234(%esi),%ebx
+80103425:	eb 25                	jmp    8010344c <piperead+0x5c>
+80103427:	90                   	nop
+80103428:	89 74 24 04          	mov    %esi,0x4(%esp)
+8010342c:	89 1c 24             	mov    %ebx,(%esp)
+8010342f:	e8 dc 07 00 00       	call   80103c10 <sleep>
+  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+80103434:	8b 86 34 02 00 00    	mov    0x234(%esi),%eax
+8010343a:	3b 86 38 02 00 00    	cmp    0x238(%esi),%eax
+80103440:	75 2e                	jne    80103470 <piperead+0x80>
+80103442:	8b 96 40 02 00 00    	mov    0x240(%esi),%edx
+80103448:	85 d2                	test   %edx,%edx
+8010344a:	74 24                	je     80103470 <piperead+0x80>
+    if(myproc()->killed){
+8010344c:	e8 5f 02 00 00       	call   801036b0 <myproc>
+80103451:	8b 48 24             	mov    0x24(%eax),%ecx
+80103454:	85 c9                	test   %ecx,%ecx
+80103456:	74 d0                	je     80103428 <piperead+0x38>
+      release(&p->lock);
+80103458:	89 34 24             	mov    %esi,(%esp)
+8010345b:	e8 e0 0d 00 00       	call   80104240 <release>
+    addr[i] = p->data[p->nread++ % PIPESIZE];
+  }
+  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+  release(&p->lock);
+  return i;
+}
+80103460:	83 c4 1c             	add    $0x1c,%esp
+      return -1;
+80103463:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80103468:	5b                   	pop    %ebx
+80103469:	5e                   	pop    %esi
+8010346a:	5f                   	pop    %edi
+8010346b:	5d                   	pop    %ebp
+8010346c:	c3                   	ret    
+8010346d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+80103470:	8b 55 10             	mov    0x10(%ebp),%edx
+    if(p->nread == p->nwrite)
+80103473:	31 db                	xor    %ebx,%ebx
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+80103475:	85 d2                	test   %edx,%edx
+80103477:	7f 2b                	jg     801034a4 <piperead+0xb4>
+80103479:	eb 31                	jmp    801034ac <piperead+0xbc>
+8010347b:	90                   	nop
+8010347c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    addr[i] = p->data[p->nread++ % PIPESIZE];
+80103480:	8d 48 01             	lea    0x1(%eax),%ecx
+80103483:	25 ff 01 00 00       	and    $0x1ff,%eax
+80103488:	89 8e 34 02 00 00    	mov    %ecx,0x234(%esi)
+8010348e:	0f b6 44 06 34       	movzbl 0x34(%esi,%eax,1),%eax
+80103493:	88 04 1f             	mov    %al,(%edi,%ebx,1)
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+80103496:	83 c3 01             	add    $0x1,%ebx
+80103499:	3b 5d 10             	cmp    0x10(%ebp),%ebx
+8010349c:	74 0e                	je     801034ac <piperead+0xbc>
+    if(p->nread == p->nwrite)
+8010349e:	8b 86 34 02 00 00    	mov    0x234(%esi),%eax
+801034a4:	3b 86 38 02 00 00    	cmp    0x238(%esi),%eax
+801034aa:	75 d4                	jne    80103480 <piperead+0x90>
+  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+801034ac:	8d 86 38 02 00 00    	lea    0x238(%esi),%eax
+801034b2:	89 04 24             	mov    %eax,(%esp)
+801034b5:	e8 e6 08 00 00       	call   80103da0 <wakeup>
+  release(&p->lock);
+801034ba:	89 34 24             	mov    %esi,(%esp)
+801034bd:	e8 7e 0d 00 00       	call   80104240 <release>
+}
+801034c2:	83 c4 1c             	add    $0x1c,%esp
+  return i;
+801034c5:	89 d8                	mov    %ebx,%eax
+}
+801034c7:	5b                   	pop    %ebx
+801034c8:	5e                   	pop    %esi
+801034c9:	5f                   	pop    %edi
+801034ca:	5d                   	pop    %ebp
+801034cb:	c3                   	ret    
+801034cc:	66 90                	xchg   %ax,%ax
+801034ce:	66 90                	xchg   %ax,%ax
+
+801034d0 <allocproc>:
+// If found, change state to EMBRYO and initialize
+// state required to run in the kernel.
+// Otherwise return 0.
+static struct proc*
+allocproc(void)
+{
+801034d0:	55                   	push   %ebp
+801034d1:	89 e5                	mov    %esp,%ebp
+801034d3:	53                   	push   %ebx
+  struct proc *p;
+  char *sp;
+
+  acquire(&ptable.lock);
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+801034d4:	bb 54 2d 11 80       	mov    $0x80112d54,%ebx
+{
+801034d9:	83 ec 14             	sub    $0x14,%esp
+  acquire(&ptable.lock);
+801034dc:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+801034e3:	e8 68 0c 00 00       	call   80104150 <acquire>
+801034e8:	eb 11                	jmp    801034fb <allocproc+0x2b>
+801034ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+801034f0:	83 c3 7c             	add    $0x7c,%ebx
+801034f3:	81 fb 54 4c 11 80    	cmp    $0x80114c54,%ebx
+801034f9:	74 7d                	je     80103578 <allocproc+0xa8>
+    if(p->state == UNUSED)
+801034fb:	8b 43 0c             	mov    0xc(%ebx),%eax
+801034fe:	85 c0                	test   %eax,%eax
+80103500:	75 ee                	jne    801034f0 <allocproc+0x20>
+  release(&ptable.lock);
+  return 0;
+
+found:
+  p->state = EMBRYO;
+  p->pid = nextpid++;
+80103502:	a1 04 a0 10 80       	mov    0x8010a004,%eax
+
+  release(&ptable.lock);
+80103507:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+  p->state = EMBRYO;
+8010350e:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
+  p->pid = nextpid++;
+80103515:	8d 50 01             	lea    0x1(%eax),%edx
+80103518:	89 15 04 a0 10 80    	mov    %edx,0x8010a004
+8010351e:	89 43 10             	mov    %eax,0x10(%ebx)
+  release(&ptable.lock);
+80103521:	e8 1a 0d 00 00       	call   80104240 <release>
+
+  // Allocate kernel stack.
+  if((p->kstack = kalloc()) == 0){
+80103526:	e8 85 ef ff ff       	call   801024b0 <kalloc>
+8010352b:	85 c0                	test   %eax,%eax
+8010352d:	89 43 08             	mov    %eax,0x8(%ebx)
+80103530:	74 5a                	je     8010358c <allocproc+0xbc>
+    return 0;
+  }
+  sp = p->kstack + KSTACKSIZE;
+
+  // Leave room for trap frame.
+  sp -= sizeof *p->tf;
+80103532:	8d 90 b4 0f 00 00    	lea    0xfb4(%eax),%edx
+  // Set up new context to start executing at forkret,
+  // which returns to trapret.
+  sp -= 4;
+  *(uint*)sp = (uint)trapret;
+
+  sp -= sizeof *p->context;
+80103538:	05 9c 0f 00 00       	add    $0xf9c,%eax
+  sp -= sizeof *p->tf;
+8010353d:	89 53 18             	mov    %edx,0x18(%ebx)
+  *(uint*)sp = (uint)trapret;
+80103540:	c7 40 14 65 54 10 80 	movl   $0x80105465,0x14(%eax)
+  p->context = (struct context*)sp;
+  memset(p->context, 0, sizeof *p->context);
+80103547:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
+8010354e:	00 
+8010354f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80103556:	00 
+80103557:	89 04 24             	mov    %eax,(%esp)
+  p->context = (struct context*)sp;
+8010355a:	89 43 1c             	mov    %eax,0x1c(%ebx)
+  memset(p->context, 0, sizeof *p->context);
+8010355d:	e8 2e 0d 00 00       	call   80104290 <memset>
+  p->context->eip = (uint)forkret;
+80103562:	8b 43 1c             	mov    0x1c(%ebx),%eax
+80103565:	c7 40 10 a0 35 10 80 	movl   $0x801035a0,0x10(%eax)
+
+  return p;
+8010356c:	89 d8                	mov    %ebx,%eax
+}
+8010356e:	83 c4 14             	add    $0x14,%esp
+80103571:	5b                   	pop    %ebx
+80103572:	5d                   	pop    %ebp
+80103573:	c3                   	ret    
+80103574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  release(&ptable.lock);
+80103578:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+8010357f:	e8 bc 0c 00 00       	call   80104240 <release>
+}
+80103584:	83 c4 14             	add    $0x14,%esp
+  return 0;
+80103587:	31 c0                	xor    %eax,%eax
+}
+80103589:	5b                   	pop    %ebx
+8010358a:	5d                   	pop    %ebp
+8010358b:	c3                   	ret    
+    p->state = UNUSED;
+8010358c:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
+    return 0;
+80103593:	eb d9                	jmp    8010356e <allocproc+0x9e>
+80103595:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80103599:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801035a0 <forkret>:
+
+// A fork child's very first scheduling by scheduler()
+// will swtch here.  "Return" to user space.
+void
+forkret(void)
+{
+801035a0:	55                   	push   %ebp
+801035a1:	89 e5                	mov    %esp,%ebp
+801035a3:	83 ec 18             	sub    $0x18,%esp
+  static int first = 1;
+  // Still holding ptable.lock from scheduler.
+  release(&ptable.lock);
+801035a6:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+801035ad:	e8 8e 0c 00 00       	call   80104240 <release>
+
+  if (first) {
+801035b2:	a1 00 a0 10 80       	mov    0x8010a000,%eax
+801035b7:	85 c0                	test   %eax,%eax
+801035b9:	75 05                	jne    801035c0 <forkret+0x20>
+    iinit(ROOTDEV);
+    initlog(ROOTDEV);
+  }
+
+  // Return to "caller", actually trapret (see allocproc).
+}
+801035bb:	c9                   	leave  
+801035bc:	c3                   	ret    
+801035bd:	8d 76 00             	lea    0x0(%esi),%esi
+    iinit(ROOTDEV);
+801035c0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    first = 0;
+801035c7:	c7 05 00 a0 10 80 00 	movl   $0x0,0x8010a000
+801035ce:	00 00 00 
+    iinit(ROOTDEV);
+801035d1:	e8 aa de ff ff       	call   80101480 <iinit>
+    initlog(ROOTDEV);
+801035d6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+801035dd:	e8 9e f4 ff ff       	call   80102a80 <initlog>
+}
+801035e2:	c9                   	leave  
+801035e3:	c3                   	ret    
+801035e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+801035ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+801035f0 <pinit>:
+{
+801035f0:	55                   	push   %ebp
+801035f1:	89 e5                	mov    %esp,%ebp
+801035f3:	83 ec 18             	sub    $0x18,%esp
+  initlock(&ptable.lock, "ptable");
+801035f6:	c7 44 24 04 75 72 10 	movl   $0x80107275,0x4(%esp)
+801035fd:	80 
+801035fe:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103605:	e8 56 0a 00 00       	call   80104060 <initlock>
+}
+8010360a:	c9                   	leave  
+8010360b:	c3                   	ret    
+8010360c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80103610 <mycpu>:
+{
+80103610:	55                   	push   %ebp
+80103611:	89 e5                	mov    %esp,%ebp
+80103613:	56                   	push   %esi
+80103614:	53                   	push   %ebx
+80103615:	83 ec 10             	sub    $0x10,%esp
+  asm volatile("pushfl; popl %0" : "=r" (eflags));
+80103618:	9c                   	pushf  
+80103619:	58                   	pop    %eax
+  if(readeflags()&FL_IF)
+8010361a:	f6 c4 02             	test   $0x2,%ah
+8010361d:	75 57                	jne    80103676 <mycpu+0x66>
+  apicid = lapicid();
+8010361f:	e8 4c f1 ff ff       	call   80102770 <lapicid>
+  for (i = 0; i < ncpu; ++i) {
+80103624:	8b 35 00 2d 11 80    	mov    0x80112d00,%esi
+8010362a:	85 f6                	test   %esi,%esi
+8010362c:	7e 3c                	jle    8010366a <mycpu+0x5a>
+    if (cpus[i].apicid == apicid)
+8010362e:	0f b6 15 80 27 11 80 	movzbl 0x80112780,%edx
+80103635:	39 c2                	cmp    %eax,%edx
+80103637:	74 2d                	je     80103666 <mycpu+0x56>
+80103639:	b9 30 28 11 80       	mov    $0x80112830,%ecx
+  for (i = 0; i < ncpu; ++i) {
+8010363e:	31 d2                	xor    %edx,%edx
+80103640:	83 c2 01             	add    $0x1,%edx
+80103643:	39 f2                	cmp    %esi,%edx
+80103645:	74 23                	je     8010366a <mycpu+0x5a>
+    if (cpus[i].apicid == apicid)
+80103647:	0f b6 19             	movzbl (%ecx),%ebx
+8010364a:	81 c1 b0 00 00 00    	add    $0xb0,%ecx
+80103650:	39 c3                	cmp    %eax,%ebx
+80103652:	75 ec                	jne    80103640 <mycpu+0x30>
+      return &cpus[i];
+80103654:	69 c2 b0 00 00 00    	imul   $0xb0,%edx,%eax
+}
+8010365a:	83 c4 10             	add    $0x10,%esp
+8010365d:	5b                   	pop    %ebx
+8010365e:	5e                   	pop    %esi
+8010365f:	5d                   	pop    %ebp
+      return &cpus[i];
+80103660:	05 80 27 11 80       	add    $0x80112780,%eax
+}
+80103665:	c3                   	ret    
+  for (i = 0; i < ncpu; ++i) {
+80103666:	31 d2                	xor    %edx,%edx
+80103668:	eb ea                	jmp    80103654 <mycpu+0x44>
+  panic("unknown apicid\n");
+8010366a:	c7 04 24 7c 72 10 80 	movl   $0x8010727c,(%esp)
+80103671:	e8 ea cc ff ff       	call   80100360 <panic>
+    panic("mycpu called with interrupts enabled\n");
+80103676:	c7 04 24 58 73 10 80 	movl   $0x80107358,(%esp)
+8010367d:	e8 de cc ff ff       	call   80100360 <panic>
+80103682:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80103689:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80103690 <cpuid>:
+cpuid() {
+80103690:	55                   	push   %ebp
+80103691:	89 e5                	mov    %esp,%ebp
+80103693:	83 ec 08             	sub    $0x8,%esp
+  return mycpu()-cpus;
+80103696:	e8 75 ff ff ff       	call   80103610 <mycpu>
+}
+8010369b:	c9                   	leave  
+  return mycpu()-cpus;
+8010369c:	2d 80 27 11 80       	sub    $0x80112780,%eax
+801036a1:	c1 f8 04             	sar    $0x4,%eax
+801036a4:	69 c0 a3 8b 2e ba    	imul   $0xba2e8ba3,%eax,%eax
+}
+801036aa:	c3                   	ret    
+801036ab:	90                   	nop
+801036ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+801036b0 <myproc>:
+myproc(void) {
+801036b0:	55                   	push   %ebp
+801036b1:	89 e5                	mov    %esp,%ebp
+801036b3:	53                   	push   %ebx
+801036b4:	83 ec 04             	sub    $0x4,%esp
+  pushcli();
+801036b7:	e8 54 0a 00 00       	call   80104110 <pushcli>
+  c = mycpu();
+801036bc:	e8 4f ff ff ff       	call   80103610 <mycpu>
+  p = c->proc;
+801036c1:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
+  popcli();
+801036c7:	e8 04 0b 00 00       	call   801041d0 <popcli>
+}
+801036cc:	83 c4 04             	add    $0x4,%esp
+801036cf:	89 d8                	mov    %ebx,%eax
+801036d1:	5b                   	pop    %ebx
+801036d2:	5d                   	pop    %ebp
+801036d3:	c3                   	ret    
+801036d4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+801036da:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+801036e0 <userinit>:
+{
+801036e0:	55                   	push   %ebp
+801036e1:	89 e5                	mov    %esp,%ebp
+801036e3:	53                   	push   %ebx
+801036e4:	83 ec 14             	sub    $0x14,%esp
+  p = allocproc();
+801036e7:	e8 e4 fd ff ff       	call   801034d0 <allocproc>
+801036ec:	89 c3                	mov    %eax,%ebx
+  initproc = p;
+801036ee:	a3 b8 a5 10 80       	mov    %eax,0x8010a5b8
+  if((p->pgdir = setupkvm()) == 0)
+801036f3:	e8 f8 32 00 00       	call   801069f0 <setupkvm>
+801036f8:	85 c0                	test   %eax,%eax
+801036fa:	89 43 04             	mov    %eax,0x4(%ebx)
+801036fd:	0f 84 d4 00 00 00    	je     801037d7 <userinit+0xf7>
+  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+80103703:	89 04 24             	mov    %eax,(%esp)
+80103706:	c7 44 24 08 2c 00 00 	movl   $0x2c,0x8(%esp)
+8010370d:	00 
+8010370e:	c7 44 24 04 60 a4 10 	movl   $0x8010a460,0x4(%esp)
+80103715:	80 
+80103716:	e8 e5 2f 00 00       	call   80106700 <inituvm>
+  p->sz = PGSIZE;
+8010371b:	c7 03 00 10 00 00    	movl   $0x1000,(%ebx)
+  memset(p->tf, 0, sizeof(*p->tf));
+80103721:	c7 44 24 08 4c 00 00 	movl   $0x4c,0x8(%esp)
+80103728:	00 
+80103729:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80103730:	00 
+80103731:	8b 43 18             	mov    0x18(%ebx),%eax
+80103734:	89 04 24             	mov    %eax,(%esp)
+80103737:	e8 54 0b 00 00       	call   80104290 <memset>
+  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+8010373c:	8b 43 18             	mov    0x18(%ebx),%eax
+8010373f:	ba 1b 00 00 00       	mov    $0x1b,%edx
+  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+80103744:	b9 23 00 00 00       	mov    $0x23,%ecx
+  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+80103749:	66 89 50 3c          	mov    %dx,0x3c(%eax)
+  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+8010374d:	8b 43 18             	mov    0x18(%ebx),%eax
+80103750:	66 89 48 2c          	mov    %cx,0x2c(%eax)
+  p->tf->es = p->tf->ds;
+80103754:	8b 43 18             	mov    0x18(%ebx),%eax
+80103757:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
+8010375b:	66 89 50 28          	mov    %dx,0x28(%eax)
+  p->tf->ss = p->tf->ds;
+8010375f:	8b 43 18             	mov    0x18(%ebx),%eax
+80103762:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
+80103766:	66 89 50 48          	mov    %dx,0x48(%eax)
+  p->tf->eflags = FL_IF;
+8010376a:	8b 43 18             	mov    0x18(%ebx),%eax
+8010376d:	c7 40 40 00 02 00 00 	movl   $0x200,0x40(%eax)
+  p->tf->esp = PGSIZE;
+80103774:	8b 43 18             	mov    0x18(%ebx),%eax
+80103777:	c7 40 44 00 10 00 00 	movl   $0x1000,0x44(%eax)
+  p->tf->eip = 0;  // beginning of initcode.S
+8010377e:	8b 43 18             	mov    0x18(%ebx),%eax
+80103781:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
+  safestrcpy(p->name, "initcode", sizeof(p->name));
+80103788:	8d 43 6c             	lea    0x6c(%ebx),%eax
+8010378b:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+80103792:	00 
+80103793:	c7 44 24 04 a5 72 10 	movl   $0x801072a5,0x4(%esp)
+8010379a:	80 
+8010379b:	89 04 24             	mov    %eax,(%esp)
+8010379e:	e8 cd 0c 00 00       	call   80104470 <safestrcpy>
+  p->cwd = namei("/");
+801037a3:	c7 04 24 ae 72 10 80 	movl   $0x801072ae,(%esp)
+801037aa:	e8 61 e7 ff ff       	call   80101f10 <namei>
+801037af:	89 43 68             	mov    %eax,0x68(%ebx)
+  acquire(&ptable.lock);
+801037b2:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+801037b9:	e8 92 09 00 00       	call   80104150 <acquire>
+  p->state = RUNNABLE;
+801037be:	c7 43 0c 03 00 00 00 	movl   $0x3,0xc(%ebx)
+  release(&ptable.lock);
+801037c5:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+801037cc:	e8 6f 0a 00 00       	call   80104240 <release>
+}
+801037d1:	83 c4 14             	add    $0x14,%esp
+801037d4:	5b                   	pop    %ebx
+801037d5:	5d                   	pop    %ebp
+801037d6:	c3                   	ret    
+    panic("userinit: out of memory?");
+801037d7:	c7 04 24 8c 72 10 80 	movl   $0x8010728c,(%esp)
+801037de:	e8 7d cb ff ff       	call   80100360 <panic>
+801037e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+801037e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801037f0 <growproc>:
+{
+801037f0:	55                   	push   %ebp
+801037f1:	89 e5                	mov    %esp,%ebp
+801037f3:	56                   	push   %esi
+801037f4:	53                   	push   %ebx
+801037f5:	83 ec 10             	sub    $0x10,%esp
+801037f8:	8b 75 08             	mov    0x8(%ebp),%esi
+  struct proc *curproc = myproc();
+801037fb:	e8 b0 fe ff ff       	call   801036b0 <myproc>
+  if(n > 0){
+80103800:	83 fe 00             	cmp    $0x0,%esi
+  struct proc *curproc = myproc();
+80103803:	89 c3                	mov    %eax,%ebx
+  sz = curproc->sz;
+80103805:	8b 00                	mov    (%eax),%eax
+  if(n > 0){
+80103807:	7e 2f                	jle    80103838 <growproc+0x48>
+    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+80103809:	01 c6                	add    %eax,%esi
+8010380b:	89 74 24 08          	mov    %esi,0x8(%esp)
+8010380f:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103813:	8b 43 04             	mov    0x4(%ebx),%eax
+80103816:	89 04 24             	mov    %eax,(%esp)
+80103819:	e8 32 30 00 00       	call   80106850 <allocuvm>
+8010381e:	85 c0                	test   %eax,%eax
+80103820:	74 36                	je     80103858 <growproc+0x68>
+  curproc->sz = sz;
+80103822:	89 03                	mov    %eax,(%ebx)
+  switchuvm(curproc);
+80103824:	89 1c 24             	mov    %ebx,(%esp)
+80103827:	e8 c4 2d 00 00       	call   801065f0 <switchuvm>
+  return 0;
+8010382c:	31 c0                	xor    %eax,%eax
+}
+8010382e:	83 c4 10             	add    $0x10,%esp
+80103831:	5b                   	pop    %ebx
+80103832:	5e                   	pop    %esi
+80103833:	5d                   	pop    %ebp
+80103834:	c3                   	ret    
+80103835:	8d 76 00             	lea    0x0(%esi),%esi
+  } else if(n < 0){
+80103838:	74 e8                	je     80103822 <growproc+0x32>
+    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+8010383a:	01 c6                	add    %eax,%esi
+8010383c:	89 74 24 08          	mov    %esi,0x8(%esp)
+80103840:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103844:	8b 43 04             	mov    0x4(%ebx),%eax
+80103847:	89 04 24             	mov    %eax,(%esp)
+8010384a:	e8 01 31 00 00       	call   80106950 <deallocuvm>
+8010384f:	85 c0                	test   %eax,%eax
+80103851:	75 cf                	jne    80103822 <growproc+0x32>
+80103853:	90                   	nop
+80103854:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      return -1;
+80103858:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010385d:	eb cf                	jmp    8010382e <growproc+0x3e>
+8010385f:	90                   	nop
+
+80103860 <fork>:
+{
+80103860:	55                   	push   %ebp
+80103861:	89 e5                	mov    %esp,%ebp
+80103863:	57                   	push   %edi
+80103864:	56                   	push   %esi
+80103865:	53                   	push   %ebx
+80103866:	83 ec 1c             	sub    $0x1c,%esp
+  struct proc *curproc = myproc();
+80103869:	e8 42 fe ff ff       	call   801036b0 <myproc>
+8010386e:	89 c3                	mov    %eax,%ebx
+  if((np = allocproc()) == 0){
+80103870:	e8 5b fc ff ff       	call   801034d0 <allocproc>
+80103875:	85 c0                	test   %eax,%eax
+80103877:	89 c7                	mov    %eax,%edi
+80103879:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+8010387c:	0f 84 bc 00 00 00    	je     8010393e <fork+0xde>
+  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+80103882:	8b 03                	mov    (%ebx),%eax
+80103884:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103888:	8b 43 04             	mov    0x4(%ebx),%eax
+8010388b:	89 04 24             	mov    %eax,(%esp)
+8010388e:	e8 3d 32 00 00       	call   80106ad0 <copyuvm>
+80103893:	85 c0                	test   %eax,%eax
+80103895:	89 47 04             	mov    %eax,0x4(%edi)
+80103898:	0f 84 a7 00 00 00    	je     80103945 <fork+0xe5>
+  np->sz = curproc->sz;
+8010389e:	8b 03                	mov    (%ebx),%eax
+801038a0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+801038a3:	89 01                	mov    %eax,(%ecx)
+  *np->tf = *curproc->tf;
+801038a5:	8b 79 18             	mov    0x18(%ecx),%edi
+801038a8:	89 c8                	mov    %ecx,%eax
+  np->parent = curproc;
+801038aa:	89 59 14             	mov    %ebx,0x14(%ecx)
+  *np->tf = *curproc->tf;
+801038ad:	8b 73 18             	mov    0x18(%ebx),%esi
+801038b0:	b9 13 00 00 00       	mov    $0x13,%ecx
+801038b5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  for(i = 0; i < NOFILE; i++)
+801038b7:	31 f6                	xor    %esi,%esi
+  np->tf->eax = 0;
+801038b9:	8b 40 18             	mov    0x18(%eax),%eax
+801038bc:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
+801038c3:	90                   	nop
+801038c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    if(curproc->ofile[i])
+801038c8:	8b 44 b3 28          	mov    0x28(%ebx,%esi,4),%eax
+801038cc:	85 c0                	test   %eax,%eax
+801038ce:	74 0f                	je     801038df <fork+0x7f>
+      np->ofile[i] = filedup(curproc->ofile[i]);
+801038d0:	89 04 24             	mov    %eax,(%esp)
+801038d3:	e8 08 d5 ff ff       	call   80100de0 <filedup>
+801038d8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+801038db:	89 44 b2 28          	mov    %eax,0x28(%edx,%esi,4)
+  for(i = 0; i < NOFILE; i++)
+801038df:	83 c6 01             	add    $0x1,%esi
+801038e2:	83 fe 10             	cmp    $0x10,%esi
+801038e5:	75 e1                	jne    801038c8 <fork+0x68>
+  np->cwd = idup(curproc->cwd);
+801038e7:	8b 43 68             	mov    0x68(%ebx),%eax
+  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+801038ea:	83 c3 6c             	add    $0x6c,%ebx
+  np->cwd = idup(curproc->cwd);
+801038ed:	89 04 24             	mov    %eax,(%esp)
+801038f0:	e8 9b dd ff ff       	call   80101690 <idup>
+801038f5:	8b 7d e4             	mov    -0x1c(%ebp),%edi
+801038f8:	89 47 68             	mov    %eax,0x68(%edi)
+  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+801038fb:	8d 47 6c             	lea    0x6c(%edi),%eax
+801038fe:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80103902:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+80103909:	00 
+8010390a:	89 04 24             	mov    %eax,(%esp)
+8010390d:	e8 5e 0b 00 00       	call   80104470 <safestrcpy>
+  pid = np->pid;
+80103912:	8b 5f 10             	mov    0x10(%edi),%ebx
+  acquire(&ptable.lock);
+80103915:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+8010391c:	e8 2f 08 00 00       	call   80104150 <acquire>
+  np->state = RUNNABLE;
+80103921:	c7 47 0c 03 00 00 00 	movl   $0x3,0xc(%edi)
+  release(&ptable.lock);
+80103928:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+8010392f:	e8 0c 09 00 00       	call   80104240 <release>
+  return pid;
+80103934:	89 d8                	mov    %ebx,%eax
+}
+80103936:	83 c4 1c             	add    $0x1c,%esp
+80103939:	5b                   	pop    %ebx
+8010393a:	5e                   	pop    %esi
+8010393b:	5f                   	pop    %edi
+8010393c:	5d                   	pop    %ebp
+8010393d:	c3                   	ret    
+    return -1;
+8010393e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80103943:	eb f1                	jmp    80103936 <fork+0xd6>
+    kfree(np->kstack);
+80103945:	8b 7d e4             	mov    -0x1c(%ebp),%edi
+80103948:	8b 47 08             	mov    0x8(%edi),%eax
+8010394b:	89 04 24             	mov    %eax,(%esp)
+8010394e:	e8 ad e9 ff ff       	call   80102300 <kfree>
+    return -1;
+80103953:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    np->kstack = 0;
+80103958:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
+    np->state = UNUSED;
+8010395f:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
+    return -1;
+80103966:	eb ce                	jmp    80103936 <fork+0xd6>
+80103968:	90                   	nop
+80103969:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80103970 <scheduler>:
+{
+80103970:	55                   	push   %ebp
+80103971:	89 e5                	mov    %esp,%ebp
+80103973:	57                   	push   %edi
+80103974:	56                   	push   %esi
+80103975:	53                   	push   %ebx
+80103976:	83 ec 1c             	sub    $0x1c,%esp
+  struct cpu *c = mycpu();
+80103979:	e8 92 fc ff ff       	call   80103610 <mycpu>
+8010397e:	89 c6                	mov    %eax,%esi
+  c->proc = 0;
+80103980:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
+80103987:	00 00 00 
+8010398a:	8d 78 04             	lea    0x4(%eax),%edi
+8010398d:	8d 76 00             	lea    0x0(%esi),%esi
+  asm volatile("sti");
+80103990:	fb                   	sti    
+    acquire(&ptable.lock);
+80103991:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80103998:	bb 54 2d 11 80       	mov    $0x80112d54,%ebx
+    acquire(&ptable.lock);
+8010399d:	e8 ae 07 00 00       	call   80104150 <acquire>
+801039a2:	eb 0f                	jmp    801039b3 <scheduler+0x43>
+801039a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+801039a8:	83 c3 7c             	add    $0x7c,%ebx
+801039ab:	81 fb 54 4c 11 80    	cmp    $0x80114c54,%ebx
+801039b1:	74 45                	je     801039f8 <scheduler+0x88>
+      if(p->state != RUNNABLE)
+801039b3:	83 7b 0c 03          	cmpl   $0x3,0xc(%ebx)
+801039b7:	75 ef                	jne    801039a8 <scheduler+0x38>
+      c->proc = p;
+801039b9:	89 9e ac 00 00 00    	mov    %ebx,0xac(%esi)
+      switchuvm(p);
+801039bf:	89 1c 24             	mov    %ebx,(%esp)
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+801039c2:	83 c3 7c             	add    $0x7c,%ebx
+      switchuvm(p);
+801039c5:	e8 26 2c 00 00       	call   801065f0 <switchuvm>
+      swtch(&(c->scheduler), p->context);
+801039ca:	8b 43 a0             	mov    -0x60(%ebx),%eax
+      p->state = RUNNING;
+801039cd:	c7 43 90 04 00 00 00 	movl   $0x4,-0x70(%ebx)
+      swtch(&(c->scheduler), p->context);
+801039d4:	89 3c 24             	mov    %edi,(%esp)
+801039d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+801039db:	e8 eb 0a 00 00       	call   801044cb <swtch>
+      switchkvm();
+801039e0:	e8 eb 2b 00 00       	call   801065d0 <switchkvm>
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+801039e5:	81 fb 54 4c 11 80    	cmp    $0x80114c54,%ebx
+      c->proc = 0;
+801039eb:	c7 86 ac 00 00 00 00 	movl   $0x0,0xac(%esi)
+801039f2:	00 00 00 
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+801039f5:	75 bc                	jne    801039b3 <scheduler+0x43>
+801039f7:	90                   	nop
+    release(&ptable.lock);
+801039f8:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+801039ff:	e8 3c 08 00 00       	call   80104240 <release>
+  }
+80103a04:	eb 8a                	jmp    80103990 <scheduler+0x20>
+80103a06:	8d 76 00             	lea    0x0(%esi),%esi
+80103a09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80103a10 <sched>:
+{
+80103a10:	55                   	push   %ebp
+80103a11:	89 e5                	mov    %esp,%ebp
+80103a13:	56                   	push   %esi
+80103a14:	53                   	push   %ebx
+80103a15:	83 ec 10             	sub    $0x10,%esp
+  struct proc *p = myproc();
+80103a18:	e8 93 fc ff ff       	call   801036b0 <myproc>
+  if(!holding(&ptable.lock))
+80103a1d:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+  struct proc *p = myproc();
+80103a24:	89 c3                	mov    %eax,%ebx
+  if(!holding(&ptable.lock))
+80103a26:	e8 b5 06 00 00       	call   801040e0 <holding>
+80103a2b:	85 c0                	test   %eax,%eax
+80103a2d:	74 4f                	je     80103a7e <sched+0x6e>
+  if(mycpu()->ncli != 1)
+80103a2f:	e8 dc fb ff ff       	call   80103610 <mycpu>
+80103a34:	83 b8 a4 00 00 00 01 	cmpl   $0x1,0xa4(%eax)
+80103a3b:	75 65                	jne    80103aa2 <sched+0x92>
+  if(p->state == RUNNING)
+80103a3d:	83 7b 0c 04          	cmpl   $0x4,0xc(%ebx)
+80103a41:	74 53                	je     80103a96 <sched+0x86>
+  asm volatile("pushfl; popl %0" : "=r" (eflags));
+80103a43:	9c                   	pushf  
+80103a44:	58                   	pop    %eax
+  if(readeflags()&FL_IF)
+80103a45:	f6 c4 02             	test   $0x2,%ah
+80103a48:	75 40                	jne    80103a8a <sched+0x7a>
+  intena = mycpu()->intena;
+80103a4a:	e8 c1 fb ff ff       	call   80103610 <mycpu>
+  swtch(&p->context, mycpu()->scheduler);
+80103a4f:	83 c3 1c             	add    $0x1c,%ebx
+  intena = mycpu()->intena;
+80103a52:	8b b0 a8 00 00 00    	mov    0xa8(%eax),%esi
+  swtch(&p->context, mycpu()->scheduler);
+80103a58:	e8 b3 fb ff ff       	call   80103610 <mycpu>
+80103a5d:	8b 40 04             	mov    0x4(%eax),%eax
+80103a60:	89 1c 24             	mov    %ebx,(%esp)
+80103a63:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103a67:	e8 5f 0a 00 00       	call   801044cb <swtch>
+  mycpu()->intena = intena;
+80103a6c:	e8 9f fb ff ff       	call   80103610 <mycpu>
+80103a71:	89 b0 a8 00 00 00    	mov    %esi,0xa8(%eax)
+}
+80103a77:	83 c4 10             	add    $0x10,%esp
+80103a7a:	5b                   	pop    %ebx
+80103a7b:	5e                   	pop    %esi
+80103a7c:	5d                   	pop    %ebp
+80103a7d:	c3                   	ret    
+    panic("sched ptable.lock");
+80103a7e:	c7 04 24 b0 72 10 80 	movl   $0x801072b0,(%esp)
+80103a85:	e8 d6 c8 ff ff       	call   80100360 <panic>
+    panic("sched interruptible");
+80103a8a:	c7 04 24 dc 72 10 80 	movl   $0x801072dc,(%esp)
+80103a91:	e8 ca c8 ff ff       	call   80100360 <panic>
+    panic("sched running");
+80103a96:	c7 04 24 ce 72 10 80 	movl   $0x801072ce,(%esp)
+80103a9d:	e8 be c8 ff ff       	call   80100360 <panic>
+    panic("sched locks");
+80103aa2:	c7 04 24 c2 72 10 80 	movl   $0x801072c2,(%esp)
+80103aa9:	e8 b2 c8 ff ff       	call   80100360 <panic>
+80103aae:	66 90                	xchg   %ax,%ax
+
+80103ab0 <exit>:
+{
+80103ab0:	55                   	push   %ebp
+80103ab1:	89 e5                	mov    %esp,%ebp
+80103ab3:	56                   	push   %esi
+  if(curproc == initproc)
+80103ab4:	31 f6                	xor    %esi,%esi
+{
+80103ab6:	53                   	push   %ebx
+80103ab7:	83 ec 10             	sub    $0x10,%esp
+  struct proc *curproc = myproc();
+80103aba:	e8 f1 fb ff ff       	call   801036b0 <myproc>
+  if(curproc == initproc)
+80103abf:	3b 05 b8 a5 10 80    	cmp    0x8010a5b8,%eax
+  struct proc *curproc = myproc();
+80103ac5:	89 c3                	mov    %eax,%ebx
+  if(curproc == initproc)
+80103ac7:	0f 84 ea 00 00 00    	je     80103bb7 <exit+0x107>
+80103acd:	8d 76 00             	lea    0x0(%esi),%esi
+    if(curproc->ofile[fd]){
+80103ad0:	8b 44 b3 28          	mov    0x28(%ebx,%esi,4),%eax
+80103ad4:	85 c0                	test   %eax,%eax
+80103ad6:	74 10                	je     80103ae8 <exit+0x38>
+      fileclose(curproc->ofile[fd]);
+80103ad8:	89 04 24             	mov    %eax,(%esp)
+80103adb:	e8 50 d3 ff ff       	call   80100e30 <fileclose>
+      curproc->ofile[fd] = 0;
+80103ae0:	c7 44 b3 28 00 00 00 	movl   $0x0,0x28(%ebx,%esi,4)
+80103ae7:	00 
+  for(fd = 0; fd < NOFILE; fd++){
+80103ae8:	83 c6 01             	add    $0x1,%esi
+80103aeb:	83 fe 10             	cmp    $0x10,%esi
+80103aee:	75 e0                	jne    80103ad0 <exit+0x20>
+  begin_op();
+80103af0:	e8 2b f0 ff ff       	call   80102b20 <begin_op>
+  iput(curproc->cwd);
+80103af5:	8b 43 68             	mov    0x68(%ebx),%eax
+80103af8:	89 04 24             	mov    %eax,(%esp)
+80103afb:	e8 e0 dc ff ff       	call   801017e0 <iput>
+  end_op();
+80103b00:	e8 8b f0 ff ff       	call   80102b90 <end_op>
+  curproc->cwd = 0;
+80103b05:	c7 43 68 00 00 00 00 	movl   $0x0,0x68(%ebx)
+  acquire(&ptable.lock);
+80103b0c:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103b13:	e8 38 06 00 00       	call   80104150 <acquire>
+  wakeup1(curproc->parent);
+80103b18:	8b 43 14             	mov    0x14(%ebx),%eax
+static void
+wakeup1(void *chan)
+{
+  struct proc *p;
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80103b1b:	ba 54 2d 11 80       	mov    $0x80112d54,%edx
+80103b20:	eb 11                	jmp    80103b33 <exit+0x83>
+80103b22:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80103b28:	83 c2 7c             	add    $0x7c,%edx
+80103b2b:	81 fa 54 4c 11 80    	cmp    $0x80114c54,%edx
+80103b31:	74 1d                	je     80103b50 <exit+0xa0>
+    if(p->state == SLEEPING && p->chan == chan)
+80103b33:	83 7a 0c 02          	cmpl   $0x2,0xc(%edx)
+80103b37:	75 ef                	jne    80103b28 <exit+0x78>
+80103b39:	3b 42 20             	cmp    0x20(%edx),%eax
+80103b3c:	75 ea                	jne    80103b28 <exit+0x78>
+      p->state = RUNNABLE;
+80103b3e:	c7 42 0c 03 00 00 00 	movl   $0x3,0xc(%edx)
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80103b45:	83 c2 7c             	add    $0x7c,%edx
+80103b48:	81 fa 54 4c 11 80    	cmp    $0x80114c54,%edx
+80103b4e:	75 e3                	jne    80103b33 <exit+0x83>
+      p->parent = initproc;
+80103b50:	a1 b8 a5 10 80       	mov    0x8010a5b8,%eax
+80103b55:	b9 54 2d 11 80       	mov    $0x80112d54,%ecx
+80103b5a:	eb 0f                	jmp    80103b6b <exit+0xbb>
+80103b5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80103b60:	83 c1 7c             	add    $0x7c,%ecx
+80103b63:	81 f9 54 4c 11 80    	cmp    $0x80114c54,%ecx
+80103b69:	74 34                	je     80103b9f <exit+0xef>
+    if(p->parent == curproc){
+80103b6b:	39 59 14             	cmp    %ebx,0x14(%ecx)
+80103b6e:	75 f0                	jne    80103b60 <exit+0xb0>
+      if(p->state == ZOMBIE)
+80103b70:	83 79 0c 05          	cmpl   $0x5,0xc(%ecx)
+      p->parent = initproc;
+80103b74:	89 41 14             	mov    %eax,0x14(%ecx)
+      if(p->state == ZOMBIE)
+80103b77:	75 e7                	jne    80103b60 <exit+0xb0>
+80103b79:	ba 54 2d 11 80       	mov    $0x80112d54,%edx
+80103b7e:	eb 0b                	jmp    80103b8b <exit+0xdb>
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80103b80:	83 c2 7c             	add    $0x7c,%edx
+80103b83:	81 fa 54 4c 11 80    	cmp    $0x80114c54,%edx
+80103b89:	74 d5                	je     80103b60 <exit+0xb0>
+    if(p->state == SLEEPING && p->chan == chan)
+80103b8b:	83 7a 0c 02          	cmpl   $0x2,0xc(%edx)
+80103b8f:	75 ef                	jne    80103b80 <exit+0xd0>
+80103b91:	3b 42 20             	cmp    0x20(%edx),%eax
+80103b94:	75 ea                	jne    80103b80 <exit+0xd0>
+      p->state = RUNNABLE;
+80103b96:	c7 42 0c 03 00 00 00 	movl   $0x3,0xc(%edx)
+80103b9d:	eb e1                	jmp    80103b80 <exit+0xd0>
+  curproc->state = ZOMBIE;
+80103b9f:	c7 43 0c 05 00 00 00 	movl   $0x5,0xc(%ebx)
+  sched();
+80103ba6:	e8 65 fe ff ff       	call   80103a10 <sched>
+  panic("zombie exit");
+80103bab:	c7 04 24 fd 72 10 80 	movl   $0x801072fd,(%esp)
+80103bb2:	e8 a9 c7 ff ff       	call   80100360 <panic>
+    panic("init exiting");
+80103bb7:	c7 04 24 f0 72 10 80 	movl   $0x801072f0,(%esp)
+80103bbe:	e8 9d c7 ff ff       	call   80100360 <panic>
+80103bc3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80103bc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80103bd0 <yield>:
+{
+80103bd0:	55                   	push   %ebp
+80103bd1:	89 e5                	mov    %esp,%ebp
+80103bd3:	83 ec 18             	sub    $0x18,%esp
+  acquire(&ptable.lock);  //DOC: yieldlock
+80103bd6:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103bdd:	e8 6e 05 00 00       	call   80104150 <acquire>
+  myproc()->state = RUNNABLE;
+80103be2:	e8 c9 fa ff ff       	call   801036b0 <myproc>
+80103be7:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
+  sched();
+80103bee:	e8 1d fe ff ff       	call   80103a10 <sched>
+  release(&ptable.lock);
+80103bf3:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103bfa:	e8 41 06 00 00       	call   80104240 <release>
+}
+80103bff:	c9                   	leave  
+80103c00:	c3                   	ret    
+80103c01:	eb 0d                	jmp    80103c10 <sleep>
+80103c03:	90                   	nop
+80103c04:	90                   	nop
+80103c05:	90                   	nop
+80103c06:	90                   	nop
+80103c07:	90                   	nop
+80103c08:	90                   	nop
+80103c09:	90                   	nop
+80103c0a:	90                   	nop
+80103c0b:	90                   	nop
+80103c0c:	90                   	nop
+80103c0d:	90                   	nop
+80103c0e:	90                   	nop
+80103c0f:	90                   	nop
+
+80103c10 <sleep>:
+{
+80103c10:	55                   	push   %ebp
+80103c11:	89 e5                	mov    %esp,%ebp
+80103c13:	57                   	push   %edi
+80103c14:	56                   	push   %esi
+80103c15:	53                   	push   %ebx
+80103c16:	83 ec 1c             	sub    $0x1c,%esp
+80103c19:	8b 7d 08             	mov    0x8(%ebp),%edi
+80103c1c:	8b 75 0c             	mov    0xc(%ebp),%esi
+  struct proc *p = myproc();
+80103c1f:	e8 8c fa ff ff       	call   801036b0 <myproc>
+  if(p == 0)
+80103c24:	85 c0                	test   %eax,%eax
+  struct proc *p = myproc();
+80103c26:	89 c3                	mov    %eax,%ebx
+  if(p == 0)
+80103c28:	0f 84 7c 00 00 00    	je     80103caa <sleep+0x9a>
+  if(lk == 0)
+80103c2e:	85 f6                	test   %esi,%esi
+80103c30:	74 6c                	je     80103c9e <sleep+0x8e>
+  if(lk != &ptable.lock){  //DOC: sleeplock0
+80103c32:	81 fe 20 2d 11 80    	cmp    $0x80112d20,%esi
+80103c38:	74 46                	je     80103c80 <sleep+0x70>
+    acquire(&ptable.lock);  //DOC: sleeplock1
+80103c3a:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103c41:	e8 0a 05 00 00       	call   80104150 <acquire>
+    release(lk);
+80103c46:	89 34 24             	mov    %esi,(%esp)
+80103c49:	e8 f2 05 00 00       	call   80104240 <release>
+  p->chan = chan;
+80103c4e:	89 7b 20             	mov    %edi,0x20(%ebx)
+  p->state = SLEEPING;
+80103c51:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
+  sched();
+80103c58:	e8 b3 fd ff ff       	call   80103a10 <sched>
+  p->chan = 0;
+80103c5d:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
+    release(&ptable.lock);
+80103c64:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103c6b:	e8 d0 05 00 00       	call   80104240 <release>
+    acquire(lk);
+80103c70:	89 75 08             	mov    %esi,0x8(%ebp)
+}
+80103c73:	83 c4 1c             	add    $0x1c,%esp
+80103c76:	5b                   	pop    %ebx
+80103c77:	5e                   	pop    %esi
+80103c78:	5f                   	pop    %edi
+80103c79:	5d                   	pop    %ebp
+    acquire(lk);
+80103c7a:	e9 d1 04 00 00       	jmp    80104150 <acquire>
+80103c7f:	90                   	nop
+  p->chan = chan;
+80103c80:	89 78 20             	mov    %edi,0x20(%eax)
+  p->state = SLEEPING;
+80103c83:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
+  sched();
+80103c8a:	e8 81 fd ff ff       	call   80103a10 <sched>
+  p->chan = 0;
+80103c8f:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
+}
+80103c96:	83 c4 1c             	add    $0x1c,%esp
+80103c99:	5b                   	pop    %ebx
+80103c9a:	5e                   	pop    %esi
+80103c9b:	5f                   	pop    %edi
+80103c9c:	5d                   	pop    %ebp
+80103c9d:	c3                   	ret    
+    panic("sleep without lk");
+80103c9e:	c7 04 24 0f 73 10 80 	movl   $0x8010730f,(%esp)
+80103ca5:	e8 b6 c6 ff ff       	call   80100360 <panic>
+    panic("sleep");
+80103caa:	c7 04 24 09 73 10 80 	movl   $0x80107309,(%esp)
+80103cb1:	e8 aa c6 ff ff       	call   80100360 <panic>
+80103cb6:	8d 76 00             	lea    0x0(%esi),%esi
+80103cb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80103cc0 <wait>:
+{
+80103cc0:	55                   	push   %ebp
+80103cc1:	89 e5                	mov    %esp,%ebp
+80103cc3:	56                   	push   %esi
+80103cc4:	53                   	push   %ebx
+80103cc5:	83 ec 10             	sub    $0x10,%esp
+  struct proc *curproc = myproc();
+80103cc8:	e8 e3 f9 ff ff       	call   801036b0 <myproc>
+  acquire(&ptable.lock);
+80103ccd:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+  struct proc *curproc = myproc();
+80103cd4:	89 c6                	mov    %eax,%esi
+  acquire(&ptable.lock);
+80103cd6:	e8 75 04 00 00       	call   80104150 <acquire>
+    havekids = 0;
+80103cdb:	31 c0                	xor    %eax,%eax
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80103cdd:	bb 54 2d 11 80       	mov    $0x80112d54,%ebx
+80103ce2:	eb 0f                	jmp    80103cf3 <wait+0x33>
+80103ce4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80103ce8:	83 c3 7c             	add    $0x7c,%ebx
+80103ceb:	81 fb 54 4c 11 80    	cmp    $0x80114c54,%ebx
+80103cf1:	74 1d                	je     80103d10 <wait+0x50>
+      if(p->parent != curproc)
+80103cf3:	39 73 14             	cmp    %esi,0x14(%ebx)
+80103cf6:	75 f0                	jne    80103ce8 <wait+0x28>
+      if(p->state == ZOMBIE){
+80103cf8:	83 7b 0c 05          	cmpl   $0x5,0xc(%ebx)
+80103cfc:	74 2f                	je     80103d2d <wait+0x6d>
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80103cfe:	83 c3 7c             	add    $0x7c,%ebx
+      havekids = 1;
+80103d01:	b8 01 00 00 00       	mov    $0x1,%eax
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80103d06:	81 fb 54 4c 11 80    	cmp    $0x80114c54,%ebx
+80103d0c:	75 e5                	jne    80103cf3 <wait+0x33>
+80103d0e:	66 90                	xchg   %ax,%ax
+    if(!havekids || curproc->killed){
+80103d10:	85 c0                	test   %eax,%eax
+80103d12:	74 6e                	je     80103d82 <wait+0xc2>
+80103d14:	8b 46 24             	mov    0x24(%esi),%eax
+80103d17:	85 c0                	test   %eax,%eax
+80103d19:	75 67                	jne    80103d82 <wait+0xc2>
+    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+80103d1b:	c7 44 24 04 20 2d 11 	movl   $0x80112d20,0x4(%esp)
+80103d22:	80 
+80103d23:	89 34 24             	mov    %esi,(%esp)
+80103d26:	e8 e5 fe ff ff       	call   80103c10 <sleep>
+  }
+80103d2b:	eb ae                	jmp    80103cdb <wait+0x1b>
+        kfree(p->kstack);
+80103d2d:	8b 43 08             	mov    0x8(%ebx),%eax
+        pid = p->pid;
+80103d30:	8b 73 10             	mov    0x10(%ebx),%esi
+        kfree(p->kstack);
+80103d33:	89 04 24             	mov    %eax,(%esp)
+80103d36:	e8 c5 e5 ff ff       	call   80102300 <kfree>
+        freevm(p->pgdir);
+80103d3b:	8b 43 04             	mov    0x4(%ebx),%eax
+        p->kstack = 0;
+80103d3e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
+        freevm(p->pgdir);
+80103d45:	89 04 24             	mov    %eax,(%esp)
+80103d48:	e8 23 2c 00 00       	call   80106970 <freevm>
+        release(&ptable.lock);
+80103d4d:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+        p->pid = 0;
+80103d54:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
+        p->parent = 0;
+80103d5b:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
+        p->name[0] = 0;
+80103d62:	c6 43 6c 00          	movb   $0x0,0x6c(%ebx)
+        p->killed = 0;
+80103d66:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
+        p->state = UNUSED;
+80103d6d:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
+        release(&ptable.lock);
+80103d74:	e8 c7 04 00 00       	call   80104240 <release>
+}
+80103d79:	83 c4 10             	add    $0x10,%esp
+        return pid;
+80103d7c:	89 f0                	mov    %esi,%eax
+}
+80103d7e:	5b                   	pop    %ebx
+80103d7f:	5e                   	pop    %esi
+80103d80:	5d                   	pop    %ebp
+80103d81:	c3                   	ret    
+      release(&ptable.lock);
+80103d82:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103d89:	e8 b2 04 00 00       	call   80104240 <release>
+}
+80103d8e:	83 c4 10             	add    $0x10,%esp
+      return -1;
+80103d91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80103d96:	5b                   	pop    %ebx
+80103d97:	5e                   	pop    %esi
+80103d98:	5d                   	pop    %ebp
+80103d99:	c3                   	ret    
+80103d9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80103da0 <wakeup>:
+}
+
+// Wake up all processes sleeping on chan.
+void
+wakeup(void *chan)
+{
+80103da0:	55                   	push   %ebp
+80103da1:	89 e5                	mov    %esp,%ebp
+80103da3:	53                   	push   %ebx
+80103da4:	83 ec 14             	sub    $0x14,%esp
+80103da7:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&ptable.lock);
+80103daa:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103db1:	e8 9a 03 00 00       	call   80104150 <acquire>
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80103db6:	b8 54 2d 11 80       	mov    $0x80112d54,%eax
+80103dbb:	eb 0d                	jmp    80103dca <wakeup+0x2a>
+80103dbd:	8d 76 00             	lea    0x0(%esi),%esi
+80103dc0:	83 c0 7c             	add    $0x7c,%eax
+80103dc3:	3d 54 4c 11 80       	cmp    $0x80114c54,%eax
+80103dc8:	74 1e                	je     80103de8 <wakeup+0x48>
+    if(p->state == SLEEPING && p->chan == chan)
+80103dca:	83 78 0c 02          	cmpl   $0x2,0xc(%eax)
+80103dce:	75 f0                	jne    80103dc0 <wakeup+0x20>
+80103dd0:	3b 58 20             	cmp    0x20(%eax),%ebx
+80103dd3:	75 eb                	jne    80103dc0 <wakeup+0x20>
+      p->state = RUNNABLE;
+80103dd5:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80103ddc:	83 c0 7c             	add    $0x7c,%eax
+80103ddf:	3d 54 4c 11 80       	cmp    $0x80114c54,%eax
+80103de4:	75 e4                	jne    80103dca <wakeup+0x2a>
+80103de6:	66 90                	xchg   %ax,%ax
+  wakeup1(chan);
+  release(&ptable.lock);
+80103de8:	c7 45 08 20 2d 11 80 	movl   $0x80112d20,0x8(%ebp)
+}
+80103def:	83 c4 14             	add    $0x14,%esp
+80103df2:	5b                   	pop    %ebx
+80103df3:	5d                   	pop    %ebp
+  release(&ptable.lock);
+80103df4:	e9 47 04 00 00       	jmp    80104240 <release>
+80103df9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80103e00 <kill>:
+// Kill the process with the given pid.
+// Process won't exit until it returns
+// to user space (see trap in trap.c).
+int
+kill(int pid)
+{
+80103e00:	55                   	push   %ebp
+80103e01:	89 e5                	mov    %esp,%ebp
+80103e03:	53                   	push   %ebx
+80103e04:	83 ec 14             	sub    $0x14,%esp
+80103e07:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  struct proc *p;
+
+  acquire(&ptable.lock);
+80103e0a:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103e11:	e8 3a 03 00 00       	call   80104150 <acquire>
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80103e16:	b8 54 2d 11 80       	mov    $0x80112d54,%eax
+80103e1b:	eb 0d                	jmp    80103e2a <kill+0x2a>
+80103e1d:	8d 76 00             	lea    0x0(%esi),%esi
+80103e20:	83 c0 7c             	add    $0x7c,%eax
+80103e23:	3d 54 4c 11 80       	cmp    $0x80114c54,%eax
+80103e28:	74 36                	je     80103e60 <kill+0x60>
+    if(p->pid == pid){
+80103e2a:	39 58 10             	cmp    %ebx,0x10(%eax)
+80103e2d:	75 f1                	jne    80103e20 <kill+0x20>
+      p->killed = 1;
+      // Wake process from sleep if necessary.
+      if(p->state == SLEEPING)
+80103e2f:	83 78 0c 02          	cmpl   $0x2,0xc(%eax)
+      p->killed = 1;
+80103e33:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
+      if(p->state == SLEEPING)
+80103e3a:	74 14                	je     80103e50 <kill+0x50>
+        p->state = RUNNABLE;
+      release(&ptable.lock);
+80103e3c:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103e43:	e8 f8 03 00 00       	call   80104240 <release>
+      return 0;
+    }
+  }
+  release(&ptable.lock);
+  return -1;
+}
+80103e48:	83 c4 14             	add    $0x14,%esp
+      return 0;
+80103e4b:	31 c0                	xor    %eax,%eax
+}
+80103e4d:	5b                   	pop    %ebx
+80103e4e:	5d                   	pop    %ebp
+80103e4f:	c3                   	ret    
+        p->state = RUNNABLE;
+80103e50:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
+80103e57:	eb e3                	jmp    80103e3c <kill+0x3c>
+80103e59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  release(&ptable.lock);
+80103e60:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103e67:	e8 d4 03 00 00       	call   80104240 <release>
+}
+80103e6c:	83 c4 14             	add    $0x14,%esp
+  return -1;
+80103e6f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80103e74:	5b                   	pop    %ebx
+80103e75:	5d                   	pop    %ebp
+80103e76:	c3                   	ret    
+80103e77:	89 f6                	mov    %esi,%esi
+80103e79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80103e80 <procdump>:
+// Print a process listing to console.  For debugging.
+// Runs when user types ^P on console.
+// No lock to avoid wedging a stuck machine further.
+void
+procdump(void)
+{
+80103e80:	55                   	push   %ebp
+80103e81:	89 e5                	mov    %esp,%ebp
+80103e83:	57                   	push   %edi
+80103e84:	56                   	push   %esi
+80103e85:	53                   	push   %ebx
+80103e86:	bb c0 2d 11 80       	mov    $0x80112dc0,%ebx
+80103e8b:	83 ec 4c             	sub    $0x4c,%esp
+80103e8e:	8d 75 e8             	lea    -0x18(%ebp),%esi
+80103e91:	eb 20                	jmp    80103eb3 <procdump+0x33>
+80103e93:	90                   	nop
+80103e94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    if(p->state == SLEEPING){
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+      for(i=0; i<10 && pc[i] != 0; i++)
+        cprintf(" %p", pc[i]);
+    }
+    cprintf("\n");
+80103e98:	c7 04 24 9f 76 10 80 	movl   $0x8010769f,(%esp)
+80103e9f:	e8 ac c7 ff ff       	call   80100650 <cprintf>
+80103ea4:	83 c3 7c             	add    $0x7c,%ebx
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80103ea7:	81 fb c0 4c 11 80    	cmp    $0x80114cc0,%ebx
+80103ead:	0f 84 8d 00 00 00    	je     80103f40 <procdump+0xc0>
+    if(p->state == UNUSED)
+80103eb3:	8b 43 a0             	mov    -0x60(%ebx),%eax
+80103eb6:	85 c0                	test   %eax,%eax
+80103eb8:	74 ea                	je     80103ea4 <procdump+0x24>
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+80103eba:	83 f8 05             	cmp    $0x5,%eax
+      state = "???";
+80103ebd:	ba 20 73 10 80       	mov    $0x80107320,%edx
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+80103ec2:	77 11                	ja     80103ed5 <procdump+0x55>
+80103ec4:	8b 14 85 80 73 10 80 	mov    -0x7fef8c80(,%eax,4),%edx
+      state = "???";
+80103ecb:	b8 20 73 10 80       	mov    $0x80107320,%eax
+80103ed0:	85 d2                	test   %edx,%edx
+80103ed2:	0f 44 d0             	cmove  %eax,%edx
+    cprintf("%d %s %s", p->pid, state, p->name);
+80103ed5:	8b 43 a4             	mov    -0x5c(%ebx),%eax
+80103ed8:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+80103edc:	89 54 24 08          	mov    %edx,0x8(%esp)
+80103ee0:	c7 04 24 24 73 10 80 	movl   $0x80107324,(%esp)
+80103ee7:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103eeb:	e8 60 c7 ff ff       	call   80100650 <cprintf>
+    if(p->state == SLEEPING){
+80103ef0:	83 7b a0 02          	cmpl   $0x2,-0x60(%ebx)
+80103ef4:	75 a2                	jne    80103e98 <procdump+0x18>
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+80103ef6:	8d 45 c0             	lea    -0x40(%ebp),%eax
+80103ef9:	89 44 24 04          	mov    %eax,0x4(%esp)
+80103efd:	8b 43 b0             	mov    -0x50(%ebx),%eax
+80103f00:	8d 7d c0             	lea    -0x40(%ebp),%edi
+80103f03:	8b 40 0c             	mov    0xc(%eax),%eax
+80103f06:	83 c0 08             	add    $0x8,%eax
+80103f09:	89 04 24             	mov    %eax,(%esp)
+80103f0c:	e8 6f 01 00 00       	call   80104080 <getcallerpcs>
+80103f11:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      for(i=0; i<10 && pc[i] != 0; i++)
+80103f18:	8b 17                	mov    (%edi),%edx
+80103f1a:	85 d2                	test   %edx,%edx
+80103f1c:	0f 84 76 ff ff ff    	je     80103e98 <procdump+0x18>
+        cprintf(" %p", pc[i]);
+80103f22:	89 54 24 04          	mov    %edx,0x4(%esp)
+80103f26:	83 c7 04             	add    $0x4,%edi
+80103f29:	c7 04 24 61 6d 10 80 	movl   $0x80106d61,(%esp)
+80103f30:	e8 1b c7 ff ff       	call   80100650 <cprintf>
+      for(i=0; i<10 && pc[i] != 0; i++)
+80103f35:	39 f7                	cmp    %esi,%edi
+80103f37:	75 df                	jne    80103f18 <procdump+0x98>
+80103f39:	e9 5a ff ff ff       	jmp    80103e98 <procdump+0x18>
+80103f3e:	66 90                	xchg   %ax,%ax
+  }
+}
+80103f40:	83 c4 4c             	add    $0x4c,%esp
+80103f43:	5b                   	pop    %ebx
+80103f44:	5e                   	pop    %esi
+80103f45:	5f                   	pop    %edi
+80103f46:	5d                   	pop    %ebp
+80103f47:	c3                   	ret    
+80103f48:	66 90                	xchg   %ax,%ax
+80103f4a:	66 90                	xchg   %ax,%ax
+80103f4c:	66 90                	xchg   %ax,%ax
+80103f4e:	66 90                	xchg   %ax,%ax
+
+80103f50 <initsleeplock>:
+#include "spinlock.h"
+#include "sleeplock.h"
+
+void
+initsleeplock(struct sleeplock *lk, char *name)
+{
+80103f50:	55                   	push   %ebp
+80103f51:	89 e5                	mov    %esp,%ebp
+80103f53:	53                   	push   %ebx
+80103f54:	83 ec 14             	sub    $0x14,%esp
+80103f57:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  initlock(&lk->lk, "sleep lock");
+80103f5a:	c7 44 24 04 98 73 10 	movl   $0x80107398,0x4(%esp)
+80103f61:	80 
+80103f62:	8d 43 04             	lea    0x4(%ebx),%eax
+80103f65:	89 04 24             	mov    %eax,(%esp)
+80103f68:	e8 f3 00 00 00       	call   80104060 <initlock>
+  lk->name = name;
+80103f6d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  lk->locked = 0;
+80103f70:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+  lk->pid = 0;
+80103f76:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
+  lk->name = name;
+80103f7d:	89 43 38             	mov    %eax,0x38(%ebx)
+}
+80103f80:	83 c4 14             	add    $0x14,%esp
+80103f83:	5b                   	pop    %ebx
+80103f84:	5d                   	pop    %ebp
+80103f85:	c3                   	ret    
+80103f86:	8d 76 00             	lea    0x0(%esi),%esi
+80103f89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80103f90 <acquiresleep>:
+
+void
+acquiresleep(struct sleeplock *lk)
+{
+80103f90:	55                   	push   %ebp
+80103f91:	89 e5                	mov    %esp,%ebp
+80103f93:	56                   	push   %esi
+80103f94:	53                   	push   %ebx
+80103f95:	83 ec 10             	sub    $0x10,%esp
+80103f98:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&lk->lk);
+80103f9b:	8d 73 04             	lea    0x4(%ebx),%esi
+80103f9e:	89 34 24             	mov    %esi,(%esp)
+80103fa1:	e8 aa 01 00 00       	call   80104150 <acquire>
+  while (lk->locked) {
+80103fa6:	8b 13                	mov    (%ebx),%edx
+80103fa8:	85 d2                	test   %edx,%edx
+80103faa:	74 16                	je     80103fc2 <acquiresleep+0x32>
+80103fac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    sleep(lk, &lk->lk);
+80103fb0:	89 74 24 04          	mov    %esi,0x4(%esp)
+80103fb4:	89 1c 24             	mov    %ebx,(%esp)
+80103fb7:	e8 54 fc ff ff       	call   80103c10 <sleep>
+  while (lk->locked) {
+80103fbc:	8b 03                	mov    (%ebx),%eax
+80103fbe:	85 c0                	test   %eax,%eax
+80103fc0:	75 ee                	jne    80103fb0 <acquiresleep+0x20>
+  }
+  lk->locked = 1;
+80103fc2:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
+  lk->pid = myproc()->pid;
+80103fc8:	e8 e3 f6 ff ff       	call   801036b0 <myproc>
+80103fcd:	8b 40 10             	mov    0x10(%eax),%eax
+80103fd0:	89 43 3c             	mov    %eax,0x3c(%ebx)
+  release(&lk->lk);
+80103fd3:	89 75 08             	mov    %esi,0x8(%ebp)
+}
+80103fd6:	83 c4 10             	add    $0x10,%esp
+80103fd9:	5b                   	pop    %ebx
+80103fda:	5e                   	pop    %esi
+80103fdb:	5d                   	pop    %ebp
+  release(&lk->lk);
+80103fdc:	e9 5f 02 00 00       	jmp    80104240 <release>
+80103fe1:	eb 0d                	jmp    80103ff0 <releasesleep>
+80103fe3:	90                   	nop
+80103fe4:	90                   	nop
+80103fe5:	90                   	nop
+80103fe6:	90                   	nop
+80103fe7:	90                   	nop
+80103fe8:	90                   	nop
+80103fe9:	90                   	nop
+80103fea:	90                   	nop
+80103feb:	90                   	nop
+80103fec:	90                   	nop
+80103fed:	90                   	nop
+80103fee:	90                   	nop
+80103fef:	90                   	nop
+
+80103ff0 <releasesleep>:
+
+void
+releasesleep(struct sleeplock *lk)
+{
+80103ff0:	55                   	push   %ebp
+80103ff1:	89 e5                	mov    %esp,%ebp
+80103ff3:	56                   	push   %esi
+80103ff4:	53                   	push   %ebx
+80103ff5:	83 ec 10             	sub    $0x10,%esp
+80103ff8:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&lk->lk);
+80103ffb:	8d 73 04             	lea    0x4(%ebx),%esi
+80103ffe:	89 34 24             	mov    %esi,(%esp)
+80104001:	e8 4a 01 00 00       	call   80104150 <acquire>
+  lk->locked = 0;
+80104006:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+  lk->pid = 0;
+8010400c:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
+  wakeup(lk);
+80104013:	89 1c 24             	mov    %ebx,(%esp)
+80104016:	e8 85 fd ff ff       	call   80103da0 <wakeup>
+  release(&lk->lk);
+8010401b:	89 75 08             	mov    %esi,0x8(%ebp)
+}
+8010401e:	83 c4 10             	add    $0x10,%esp
+80104021:	5b                   	pop    %ebx
+80104022:	5e                   	pop    %esi
+80104023:	5d                   	pop    %ebp
+  release(&lk->lk);
+80104024:	e9 17 02 00 00       	jmp    80104240 <release>
+80104029:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80104030 <holdingsleep>:
+
+int
+holdingsleep(struct sleeplock *lk)
+{
+80104030:	55                   	push   %ebp
+80104031:	89 e5                	mov    %esp,%ebp
+80104033:	56                   	push   %esi
+80104034:	53                   	push   %ebx
+80104035:	83 ec 10             	sub    $0x10,%esp
+80104038:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  int r;
+  
+  acquire(&lk->lk);
+8010403b:	8d 73 04             	lea    0x4(%ebx),%esi
+8010403e:	89 34 24             	mov    %esi,(%esp)
+80104041:	e8 0a 01 00 00       	call   80104150 <acquire>
+  r = lk->locked;
+80104046:	8b 1b                	mov    (%ebx),%ebx
+  release(&lk->lk);
+80104048:	89 34 24             	mov    %esi,(%esp)
+8010404b:	e8 f0 01 00 00       	call   80104240 <release>
+  return r;
+}
+80104050:	83 c4 10             	add    $0x10,%esp
+80104053:	89 d8                	mov    %ebx,%eax
+80104055:	5b                   	pop    %ebx
+80104056:	5e                   	pop    %esi
+80104057:	5d                   	pop    %ebp
+80104058:	c3                   	ret    
+80104059:	66 90                	xchg   %ax,%ax
+8010405b:	66 90                	xchg   %ax,%ax
+8010405d:	66 90                	xchg   %ax,%ax
+8010405f:	90                   	nop
+
+80104060 <initlock>:
+#include "proc.h"
+#include "spinlock.h"
+
+void
+initlock(struct spinlock *lk, char *name)
+{
+80104060:	55                   	push   %ebp
+80104061:	89 e5                	mov    %esp,%ebp
+80104063:	8b 45 08             	mov    0x8(%ebp),%eax
+  lk->name = name;
+80104066:	8b 55 0c             	mov    0xc(%ebp),%edx
+  lk->locked = 0;
+80104069:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  lk->name = name;
+8010406f:	89 50 04             	mov    %edx,0x4(%eax)
+  lk->cpu = 0;
+80104072:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+}
+80104079:	5d                   	pop    %ebp
+8010407a:	c3                   	ret    
+8010407b:	90                   	nop
+8010407c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80104080 <getcallerpcs>:
+}
+
+// Record the current call stack in pcs[] by following the %ebp chain.
+void
+getcallerpcs(void *v, uint pcs[])
+{
+80104080:	55                   	push   %ebp
+80104081:	89 e5                	mov    %esp,%ebp
+  uint *ebp;
+  int i;
+
+  ebp = (uint*)v - 2;
+80104083:	8b 45 08             	mov    0x8(%ebp),%eax
+{
+80104086:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+80104089:	53                   	push   %ebx
+  ebp = (uint*)v - 2;
+8010408a:	8d 50 f8             	lea    -0x8(%eax),%edx
+  for(i = 0; i < 10; i++){
+8010408d:	31 c0                	xor    %eax,%eax
+8010408f:	90                   	nop
+    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+80104090:	8d 9a 00 00 00 80    	lea    -0x80000000(%edx),%ebx
+80104096:	81 fb fe ff ff 7f    	cmp    $0x7ffffffe,%ebx
+8010409c:	77 1a                	ja     801040b8 <getcallerpcs+0x38>
+      break;
+    pcs[i] = ebp[1];     // saved %eip
+8010409e:	8b 5a 04             	mov    0x4(%edx),%ebx
+801040a1:	89 1c 81             	mov    %ebx,(%ecx,%eax,4)
+  for(i = 0; i < 10; i++){
+801040a4:	83 c0 01             	add    $0x1,%eax
+    ebp = (uint*)ebp[0]; // saved %ebp
+801040a7:	8b 12                	mov    (%edx),%edx
+  for(i = 0; i < 10; i++){
+801040a9:	83 f8 0a             	cmp    $0xa,%eax
+801040ac:	75 e2                	jne    80104090 <getcallerpcs+0x10>
+  }
+  for(; i < 10; i++)
+    pcs[i] = 0;
+}
+801040ae:	5b                   	pop    %ebx
+801040af:	5d                   	pop    %ebp
+801040b0:	c3                   	ret    
+801040b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    pcs[i] = 0;
+801040b8:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
+  for(; i < 10; i++)
+801040bf:	83 c0 01             	add    $0x1,%eax
+801040c2:	83 f8 0a             	cmp    $0xa,%eax
+801040c5:	74 e7                	je     801040ae <getcallerpcs+0x2e>
+    pcs[i] = 0;
+801040c7:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
+  for(; i < 10; i++)
+801040ce:	83 c0 01             	add    $0x1,%eax
+801040d1:	83 f8 0a             	cmp    $0xa,%eax
+801040d4:	75 e2                	jne    801040b8 <getcallerpcs+0x38>
+801040d6:	eb d6                	jmp    801040ae <getcallerpcs+0x2e>
+801040d8:	90                   	nop
+801040d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+801040e0 <holding>:
+
+// Check whether this cpu is holding the lock.
+int
+holding(struct spinlock *lock)
+{
+801040e0:	55                   	push   %ebp
+  return lock->locked && lock->cpu == mycpu();
+801040e1:	31 c0                	xor    %eax,%eax
+{
+801040e3:	89 e5                	mov    %esp,%ebp
+801040e5:	53                   	push   %ebx
+801040e6:	83 ec 04             	sub    $0x4,%esp
+801040e9:	8b 55 08             	mov    0x8(%ebp),%edx
+  return lock->locked && lock->cpu == mycpu();
+801040ec:	8b 0a                	mov    (%edx),%ecx
+801040ee:	85 c9                	test   %ecx,%ecx
+801040f0:	74 10                	je     80104102 <holding+0x22>
+801040f2:	8b 5a 08             	mov    0x8(%edx),%ebx
+801040f5:	e8 16 f5 ff ff       	call   80103610 <mycpu>
+801040fa:	39 c3                	cmp    %eax,%ebx
+801040fc:	0f 94 c0             	sete   %al
+801040ff:	0f b6 c0             	movzbl %al,%eax
+}
+80104102:	83 c4 04             	add    $0x4,%esp
+80104105:	5b                   	pop    %ebx
+80104106:	5d                   	pop    %ebp
+80104107:	c3                   	ret    
+80104108:	90                   	nop
+80104109:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80104110 <pushcli>:
+// it takes two popcli to undo two pushcli.  Also, if interrupts
+// are off, then pushcli, popcli leaves them off.
+
+void
+pushcli(void)
+{
+80104110:	55                   	push   %ebp
+80104111:	89 e5                	mov    %esp,%ebp
+80104113:	53                   	push   %ebx
+80104114:	83 ec 04             	sub    $0x4,%esp
+80104117:	9c                   	pushf  
+80104118:	5b                   	pop    %ebx
+  asm volatile("cli");
+80104119:	fa                   	cli    
+  int eflags;
+
+  eflags = readeflags();
+  cli();
+  if(mycpu()->ncli == 0)
+8010411a:	e8 f1 f4 ff ff       	call   80103610 <mycpu>
+8010411f:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
+80104125:	85 c0                	test   %eax,%eax
+80104127:	75 11                	jne    8010413a <pushcli+0x2a>
+    mycpu()->intena = eflags & FL_IF;
+80104129:	e8 e2 f4 ff ff       	call   80103610 <mycpu>
+8010412e:	81 e3 00 02 00 00    	and    $0x200,%ebx
+80104134:	89 98 a8 00 00 00    	mov    %ebx,0xa8(%eax)
+  mycpu()->ncli += 1;
+8010413a:	e8 d1 f4 ff ff       	call   80103610 <mycpu>
+8010413f:	83 80 a4 00 00 00 01 	addl   $0x1,0xa4(%eax)
+}
+80104146:	83 c4 04             	add    $0x4,%esp
+80104149:	5b                   	pop    %ebx
+8010414a:	5d                   	pop    %ebp
+8010414b:	c3                   	ret    
+8010414c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80104150 <acquire>:
+{
+80104150:	55                   	push   %ebp
+80104151:	89 e5                	mov    %esp,%ebp
+80104153:	53                   	push   %ebx
+80104154:	83 ec 14             	sub    $0x14,%esp
+  pushcli(); // disable interrupts to avoid deadlock.
+80104157:	e8 b4 ff ff ff       	call   80104110 <pushcli>
+  if(holding(lk))
+8010415c:	8b 55 08             	mov    0x8(%ebp),%edx
+  return lock->locked && lock->cpu == mycpu();
+8010415f:	8b 02                	mov    (%edx),%eax
+80104161:	85 c0                	test   %eax,%eax
+80104163:	75 43                	jne    801041a8 <acquire+0x58>
+  asm volatile("lock; xchgl %0, %1" :
+80104165:	b9 01 00 00 00       	mov    $0x1,%ecx
+8010416a:	eb 07                	jmp    80104173 <acquire+0x23>
+8010416c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80104170:	8b 55 08             	mov    0x8(%ebp),%edx
+80104173:	89 c8                	mov    %ecx,%eax
+80104175:	f0 87 02             	lock xchg %eax,(%edx)
+  while(xchg(&lk->locked, 1) != 0)
+80104178:	85 c0                	test   %eax,%eax
+8010417a:	75 f4                	jne    80104170 <acquire+0x20>
+  __sync_synchronize();
+8010417c:	0f ae f0             	mfence 
+  lk->cpu = mycpu();
+8010417f:	8b 5d 08             	mov    0x8(%ebp),%ebx
+80104182:	e8 89 f4 ff ff       	call   80103610 <mycpu>
+80104187:	89 43 08             	mov    %eax,0x8(%ebx)
+  getcallerpcs(&lk, lk->pcs);
+8010418a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010418d:	83 c0 0c             	add    $0xc,%eax
+80104190:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104194:	8d 45 08             	lea    0x8(%ebp),%eax
+80104197:	89 04 24             	mov    %eax,(%esp)
+8010419a:	e8 e1 fe ff ff       	call   80104080 <getcallerpcs>
+}
+8010419f:	83 c4 14             	add    $0x14,%esp
+801041a2:	5b                   	pop    %ebx
+801041a3:	5d                   	pop    %ebp
+801041a4:	c3                   	ret    
+801041a5:	8d 76 00             	lea    0x0(%esi),%esi
+  return lock->locked && lock->cpu == mycpu();
+801041a8:	8b 5a 08             	mov    0x8(%edx),%ebx
+801041ab:	e8 60 f4 ff ff       	call   80103610 <mycpu>
+  if(holding(lk))
+801041b0:	39 c3                	cmp    %eax,%ebx
+801041b2:	74 05                	je     801041b9 <acquire+0x69>
+801041b4:	8b 55 08             	mov    0x8(%ebp),%edx
+801041b7:	eb ac                	jmp    80104165 <acquire+0x15>
+    panic("acquire");
+801041b9:	c7 04 24 a3 73 10 80 	movl   $0x801073a3,(%esp)
+801041c0:	e8 9b c1 ff ff       	call   80100360 <panic>
+801041c5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801041c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801041d0 <popcli>:
+
+void
+popcli(void)
+{
+801041d0:	55                   	push   %ebp
+801041d1:	89 e5                	mov    %esp,%ebp
+801041d3:	83 ec 18             	sub    $0x18,%esp
+  asm volatile("pushfl; popl %0" : "=r" (eflags));
+801041d6:	9c                   	pushf  
+801041d7:	58                   	pop    %eax
+  if(readeflags()&FL_IF)
+801041d8:	f6 c4 02             	test   $0x2,%ah
+801041db:	75 49                	jne    80104226 <popcli+0x56>
+    panic("popcli - interruptible");
+  if(--mycpu()->ncli < 0)
+801041dd:	e8 2e f4 ff ff       	call   80103610 <mycpu>
+801041e2:	8b 88 a4 00 00 00    	mov    0xa4(%eax),%ecx
+801041e8:	8d 51 ff             	lea    -0x1(%ecx),%edx
+801041eb:	85 d2                	test   %edx,%edx
+801041ed:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
+801041f3:	78 25                	js     8010421a <popcli+0x4a>
+    panic("popcli");
+  if(mycpu()->ncli == 0 && mycpu()->intena)
+801041f5:	e8 16 f4 ff ff       	call   80103610 <mycpu>
+801041fa:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
+80104200:	85 d2                	test   %edx,%edx
+80104202:	74 04                	je     80104208 <popcli+0x38>
+    sti();
+}
+80104204:	c9                   	leave  
+80104205:	c3                   	ret    
+80104206:	66 90                	xchg   %ax,%ax
+  if(mycpu()->ncli == 0 && mycpu()->intena)
+80104208:	e8 03 f4 ff ff       	call   80103610 <mycpu>
+8010420d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
+80104213:	85 c0                	test   %eax,%eax
+80104215:	74 ed                	je     80104204 <popcli+0x34>
+  asm volatile("sti");
+80104217:	fb                   	sti    
+}
+80104218:	c9                   	leave  
+80104219:	c3                   	ret    
+    panic("popcli");
+8010421a:	c7 04 24 c2 73 10 80 	movl   $0x801073c2,(%esp)
+80104221:	e8 3a c1 ff ff       	call   80100360 <panic>
+    panic("popcli - interruptible");
+80104226:	c7 04 24 ab 73 10 80 	movl   $0x801073ab,(%esp)
+8010422d:	e8 2e c1 ff ff       	call   80100360 <panic>
+80104232:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104239:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80104240 <release>:
+{
+80104240:	55                   	push   %ebp
+80104241:	89 e5                	mov    %esp,%ebp
+80104243:	56                   	push   %esi
+80104244:	53                   	push   %ebx
+80104245:	83 ec 10             	sub    $0x10,%esp
+80104248:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  return lock->locked && lock->cpu == mycpu();
+8010424b:	8b 03                	mov    (%ebx),%eax
+8010424d:	85 c0                	test   %eax,%eax
+8010424f:	75 0f                	jne    80104260 <release+0x20>
+    panic("release");
+80104251:	c7 04 24 c9 73 10 80 	movl   $0x801073c9,(%esp)
+80104258:	e8 03 c1 ff ff       	call   80100360 <panic>
+8010425d:	8d 76 00             	lea    0x0(%esi),%esi
+  return lock->locked && lock->cpu == mycpu();
+80104260:	8b 73 08             	mov    0x8(%ebx),%esi
+80104263:	e8 a8 f3 ff ff       	call   80103610 <mycpu>
+  if(!holding(lk))
+80104268:	39 c6                	cmp    %eax,%esi
+8010426a:	75 e5                	jne    80104251 <release+0x11>
+  lk->pcs[0] = 0;
+8010426c:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
+  lk->cpu = 0;
+80104273:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
+  __sync_synchronize();
+8010427a:	0f ae f0             	mfence 
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+8010427d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+}
+80104283:	83 c4 10             	add    $0x10,%esp
+80104286:	5b                   	pop    %ebx
+80104287:	5e                   	pop    %esi
+80104288:	5d                   	pop    %ebp
+  popcli();
+80104289:	e9 42 ff ff ff       	jmp    801041d0 <popcli>
+8010428e:	66 90                	xchg   %ax,%ax
+
+80104290 <memset>:
+#include "types.h"
+#include "x86.h"
+
+void*
+memset(void *dst, int c, uint n)
+{
+80104290:	55                   	push   %ebp
+80104291:	89 e5                	mov    %esp,%ebp
+80104293:	8b 55 08             	mov    0x8(%ebp),%edx
+80104296:	57                   	push   %edi
+80104297:	8b 4d 10             	mov    0x10(%ebp),%ecx
+8010429a:	53                   	push   %ebx
+  if ((int)dst%4 == 0 && n%4 == 0){
+8010429b:	f6 c2 03             	test   $0x3,%dl
+8010429e:	75 05                	jne    801042a5 <memset+0x15>
+801042a0:	f6 c1 03             	test   $0x3,%cl
+801042a3:	74 13                	je     801042b8 <memset+0x28>
+  asm volatile("cld; rep stosb" :
+801042a5:	89 d7                	mov    %edx,%edi
+801042a7:	8b 45 0c             	mov    0xc(%ebp),%eax
+801042aa:	fc                   	cld    
+801042ab:	f3 aa                	rep stos %al,%es:(%edi)
+    c &= 0xFF;
+    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
+  } else
+    stosb(dst, c, n);
+  return dst;
+}
+801042ad:	5b                   	pop    %ebx
+801042ae:	89 d0                	mov    %edx,%eax
+801042b0:	5f                   	pop    %edi
+801042b1:	5d                   	pop    %ebp
+801042b2:	c3                   	ret    
+801042b3:	90                   	nop
+801042b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    c &= 0xFF;
+801042b8:	0f b6 7d 0c          	movzbl 0xc(%ebp),%edi
+    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
+801042bc:	c1 e9 02             	shr    $0x2,%ecx
+801042bf:	89 f8                	mov    %edi,%eax
+801042c1:	89 fb                	mov    %edi,%ebx
+801042c3:	c1 e0 18             	shl    $0x18,%eax
+801042c6:	c1 e3 10             	shl    $0x10,%ebx
+801042c9:	09 d8                	or     %ebx,%eax
+801042cb:	09 f8                	or     %edi,%eax
+801042cd:	c1 e7 08             	shl    $0x8,%edi
+801042d0:	09 f8                	or     %edi,%eax
+  asm volatile("cld; rep stosl" :
+801042d2:	89 d7                	mov    %edx,%edi
+801042d4:	fc                   	cld    
+801042d5:	f3 ab                	rep stos %eax,%es:(%edi)
+}
+801042d7:	5b                   	pop    %ebx
+801042d8:	89 d0                	mov    %edx,%eax
+801042da:	5f                   	pop    %edi
+801042db:	5d                   	pop    %ebp
+801042dc:	c3                   	ret    
+801042dd:	8d 76 00             	lea    0x0(%esi),%esi
+
+801042e0 <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, uint n)
+{
+801042e0:	55                   	push   %ebp
+801042e1:	89 e5                	mov    %esp,%ebp
+801042e3:	8b 45 10             	mov    0x10(%ebp),%eax
+801042e6:	57                   	push   %edi
+801042e7:	56                   	push   %esi
+801042e8:	8b 75 0c             	mov    0xc(%ebp),%esi
+801042eb:	53                   	push   %ebx
+801042ec:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  const uchar *s1, *s2;
+
+  s1 = v1;
+  s2 = v2;
+  while(n-- > 0){
+801042ef:	85 c0                	test   %eax,%eax
+801042f1:	8d 78 ff             	lea    -0x1(%eax),%edi
+801042f4:	74 26                	je     8010431c <memcmp+0x3c>
+    if(*s1 != *s2)
+801042f6:	0f b6 03             	movzbl (%ebx),%eax
+801042f9:	31 d2                	xor    %edx,%edx
+801042fb:	0f b6 0e             	movzbl (%esi),%ecx
+801042fe:	38 c8                	cmp    %cl,%al
+80104300:	74 16                	je     80104318 <memcmp+0x38>
+80104302:	eb 24                	jmp    80104328 <memcmp+0x48>
+80104304:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80104308:	0f b6 44 13 01       	movzbl 0x1(%ebx,%edx,1),%eax
+8010430d:	83 c2 01             	add    $0x1,%edx
+80104310:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+80104314:	38 c8                	cmp    %cl,%al
+80104316:	75 10                	jne    80104328 <memcmp+0x48>
+  while(n-- > 0){
+80104318:	39 fa                	cmp    %edi,%edx
+8010431a:	75 ec                	jne    80104308 <memcmp+0x28>
+      return *s1 - *s2;
+    s1++, s2++;
+  }
+
+  return 0;
+}
+8010431c:	5b                   	pop    %ebx
+  return 0;
+8010431d:	31 c0                	xor    %eax,%eax
+}
+8010431f:	5e                   	pop    %esi
+80104320:	5f                   	pop    %edi
+80104321:	5d                   	pop    %ebp
+80104322:	c3                   	ret    
+80104323:	90                   	nop
+80104324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80104328:	5b                   	pop    %ebx
+      return *s1 - *s2;
+80104329:	29 c8                	sub    %ecx,%eax
+}
+8010432b:	5e                   	pop    %esi
+8010432c:	5f                   	pop    %edi
+8010432d:	5d                   	pop    %ebp
+8010432e:	c3                   	ret    
+8010432f:	90                   	nop
+
+80104330 <memmove>:
+
+void*
+memmove(void *dst, const void *src, uint n)
+{
+80104330:	55                   	push   %ebp
+80104331:	89 e5                	mov    %esp,%ebp
+80104333:	57                   	push   %edi
+80104334:	8b 45 08             	mov    0x8(%ebp),%eax
+80104337:	56                   	push   %esi
+80104338:	8b 75 0c             	mov    0xc(%ebp),%esi
+8010433b:	53                   	push   %ebx
+8010433c:	8b 5d 10             	mov    0x10(%ebp),%ebx
+  const char *s;
+  char *d;
+
+  s = src;
+  d = dst;
+  if(s < d && s + n > d){
+8010433f:	39 c6                	cmp    %eax,%esi
+80104341:	73 35                	jae    80104378 <memmove+0x48>
+80104343:	8d 0c 1e             	lea    (%esi,%ebx,1),%ecx
+80104346:	39 c8                	cmp    %ecx,%eax
+80104348:	73 2e                	jae    80104378 <memmove+0x48>
+    s += n;
+    d += n;
+    while(n-- > 0)
+8010434a:	85 db                	test   %ebx,%ebx
+    d += n;
+8010434c:	8d 3c 18             	lea    (%eax,%ebx,1),%edi
+    while(n-- > 0)
+8010434f:	8d 53 ff             	lea    -0x1(%ebx),%edx
+80104352:	74 1b                	je     8010436f <memmove+0x3f>
+80104354:	f7 db                	neg    %ebx
+80104356:	8d 34 19             	lea    (%ecx,%ebx,1),%esi
+80104359:	01 fb                	add    %edi,%ebx
+8010435b:	90                   	nop
+8010435c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      *--d = *--s;
+80104360:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+80104364:	88 0c 13             	mov    %cl,(%ebx,%edx,1)
+    while(n-- > 0)
+80104367:	83 ea 01             	sub    $0x1,%edx
+8010436a:	83 fa ff             	cmp    $0xffffffff,%edx
+8010436d:	75 f1                	jne    80104360 <memmove+0x30>
+  } else
+    while(n-- > 0)
+      *d++ = *s++;
+
+  return dst;
+}
+8010436f:	5b                   	pop    %ebx
+80104370:	5e                   	pop    %esi
+80104371:	5f                   	pop    %edi
+80104372:	5d                   	pop    %ebp
+80104373:	c3                   	ret    
+80104374:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    while(n-- > 0)
+80104378:	31 d2                	xor    %edx,%edx
+8010437a:	85 db                	test   %ebx,%ebx
+8010437c:	74 f1                	je     8010436f <memmove+0x3f>
+8010437e:	66 90                	xchg   %ax,%ax
+      *d++ = *s++;
+80104380:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+80104384:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+80104387:	83 c2 01             	add    $0x1,%edx
+    while(n-- > 0)
+8010438a:	39 da                	cmp    %ebx,%edx
+8010438c:	75 f2                	jne    80104380 <memmove+0x50>
+}
+8010438e:	5b                   	pop    %ebx
+8010438f:	5e                   	pop    %esi
+80104390:	5f                   	pop    %edi
+80104391:	5d                   	pop    %ebp
+80104392:	c3                   	ret    
+80104393:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80104399:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801043a0 <memcpy>:
+
+// memcpy exists to placate GCC.  Use memmove.
+void*
+memcpy(void *dst, const void *src, uint n)
+{
+801043a0:	55                   	push   %ebp
+801043a1:	89 e5                	mov    %esp,%ebp
+  return memmove(dst, src, n);
+}
+801043a3:	5d                   	pop    %ebp
+  return memmove(dst, src, n);
+801043a4:	eb 8a                	jmp    80104330 <memmove>
+801043a6:	8d 76 00             	lea    0x0(%esi),%esi
+801043a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801043b0 <strncmp>:
+
+int
+strncmp(const char *p, const char *q, uint n)
+{
+801043b0:	55                   	push   %ebp
+801043b1:	89 e5                	mov    %esp,%ebp
+801043b3:	56                   	push   %esi
+801043b4:	8b 75 10             	mov    0x10(%ebp),%esi
+801043b7:	53                   	push   %ebx
+801043b8:	8b 4d 08             	mov    0x8(%ebp),%ecx
+801043bb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while(n > 0 && *p && *p == *q)
+801043be:	85 f6                	test   %esi,%esi
+801043c0:	74 30                	je     801043f2 <strncmp+0x42>
+801043c2:	0f b6 01             	movzbl (%ecx),%eax
+801043c5:	84 c0                	test   %al,%al
+801043c7:	74 2f                	je     801043f8 <strncmp+0x48>
+801043c9:	0f b6 13             	movzbl (%ebx),%edx
+801043cc:	38 d0                	cmp    %dl,%al
+801043ce:	75 46                	jne    80104416 <strncmp+0x66>
+801043d0:	8d 51 01             	lea    0x1(%ecx),%edx
+801043d3:	01 ce                	add    %ecx,%esi
+801043d5:	eb 14                	jmp    801043eb <strncmp+0x3b>
+801043d7:	90                   	nop
+801043d8:	0f b6 02             	movzbl (%edx),%eax
+801043db:	84 c0                	test   %al,%al
+801043dd:	74 31                	je     80104410 <strncmp+0x60>
+801043df:	0f b6 19             	movzbl (%ecx),%ebx
+801043e2:	83 c2 01             	add    $0x1,%edx
+801043e5:	38 d8                	cmp    %bl,%al
+801043e7:	75 17                	jne    80104400 <strncmp+0x50>
+    n--, p++, q++;
+801043e9:	89 cb                	mov    %ecx,%ebx
+  while(n > 0 && *p && *p == *q)
+801043eb:	39 f2                	cmp    %esi,%edx
+    n--, p++, q++;
+801043ed:	8d 4b 01             	lea    0x1(%ebx),%ecx
+  while(n > 0 && *p && *p == *q)
+801043f0:	75 e6                	jne    801043d8 <strncmp+0x28>
+  if(n == 0)
+    return 0;
+  return (uchar)*p - (uchar)*q;
+}
+801043f2:	5b                   	pop    %ebx
+    return 0;
+801043f3:	31 c0                	xor    %eax,%eax
+}
+801043f5:	5e                   	pop    %esi
+801043f6:	5d                   	pop    %ebp
+801043f7:	c3                   	ret    
+801043f8:	0f b6 1b             	movzbl (%ebx),%ebx
+  while(n > 0 && *p && *p == *q)
+801043fb:	31 c0                	xor    %eax,%eax
+801043fd:	8d 76 00             	lea    0x0(%esi),%esi
+  return (uchar)*p - (uchar)*q;
+80104400:	0f b6 d3             	movzbl %bl,%edx
+80104403:	29 d0                	sub    %edx,%eax
+}
+80104405:	5b                   	pop    %ebx
+80104406:	5e                   	pop    %esi
+80104407:	5d                   	pop    %ebp
+80104408:	c3                   	ret    
+80104409:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104410:	0f b6 5b 01          	movzbl 0x1(%ebx),%ebx
+80104414:	eb ea                	jmp    80104400 <strncmp+0x50>
+  while(n > 0 && *p && *p == *q)
+80104416:	89 d3                	mov    %edx,%ebx
+80104418:	eb e6                	jmp    80104400 <strncmp+0x50>
+8010441a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80104420 <strncpy>:
+
+char*
+strncpy(char *s, const char *t, int n)
+{
+80104420:	55                   	push   %ebp
+80104421:	89 e5                	mov    %esp,%ebp
+80104423:	8b 45 08             	mov    0x8(%ebp),%eax
+80104426:	56                   	push   %esi
+80104427:	8b 4d 10             	mov    0x10(%ebp),%ecx
+8010442a:	53                   	push   %ebx
+8010442b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  char *os;
+
+  os = s;
+  while(n-- > 0 && (*s++ = *t++) != 0)
+8010442e:	89 c2                	mov    %eax,%edx
+80104430:	eb 19                	jmp    8010444b <strncpy+0x2b>
+80104432:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80104438:	83 c3 01             	add    $0x1,%ebx
+8010443b:	0f b6 4b ff          	movzbl -0x1(%ebx),%ecx
+8010443f:	83 c2 01             	add    $0x1,%edx
+80104442:	84 c9                	test   %cl,%cl
+80104444:	88 4a ff             	mov    %cl,-0x1(%edx)
+80104447:	74 09                	je     80104452 <strncpy+0x32>
+80104449:	89 f1                	mov    %esi,%ecx
+8010444b:	85 c9                	test   %ecx,%ecx
+8010444d:	8d 71 ff             	lea    -0x1(%ecx),%esi
+80104450:	7f e6                	jg     80104438 <strncpy+0x18>
+    ;
+  while(n-- > 0)
+80104452:	31 c9                	xor    %ecx,%ecx
+80104454:	85 f6                	test   %esi,%esi
+80104456:	7e 0f                	jle    80104467 <strncpy+0x47>
+    *s++ = 0;
+80104458:	c6 04 0a 00          	movb   $0x0,(%edx,%ecx,1)
+8010445c:	89 f3                	mov    %esi,%ebx
+8010445e:	83 c1 01             	add    $0x1,%ecx
+80104461:	29 cb                	sub    %ecx,%ebx
+  while(n-- > 0)
+80104463:	85 db                	test   %ebx,%ebx
+80104465:	7f f1                	jg     80104458 <strncpy+0x38>
+  return os;
+}
+80104467:	5b                   	pop    %ebx
+80104468:	5e                   	pop    %esi
+80104469:	5d                   	pop    %ebp
+8010446a:	c3                   	ret    
+8010446b:	90                   	nop
+8010446c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80104470 <safestrcpy>:
+
+// Like strncpy but guaranteed to NUL-terminate.
+char*
+safestrcpy(char *s, const char *t, int n)
+{
+80104470:	55                   	push   %ebp
+80104471:	89 e5                	mov    %esp,%ebp
+80104473:	8b 4d 10             	mov    0x10(%ebp),%ecx
+80104476:	56                   	push   %esi
+80104477:	8b 45 08             	mov    0x8(%ebp),%eax
+8010447a:	53                   	push   %ebx
+8010447b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  char *os;
+
+  os = s;
+  if(n <= 0)
+8010447e:	85 c9                	test   %ecx,%ecx
+80104480:	7e 26                	jle    801044a8 <safestrcpy+0x38>
+80104482:	8d 74 0a ff          	lea    -0x1(%edx,%ecx,1),%esi
+80104486:	89 c1                	mov    %eax,%ecx
+80104488:	eb 17                	jmp    801044a1 <safestrcpy+0x31>
+8010448a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    return os;
+  while(--n > 0 && (*s++ = *t++) != 0)
+80104490:	83 c2 01             	add    $0x1,%edx
+80104493:	0f b6 5a ff          	movzbl -0x1(%edx),%ebx
+80104497:	83 c1 01             	add    $0x1,%ecx
+8010449a:	84 db                	test   %bl,%bl
+8010449c:	88 59 ff             	mov    %bl,-0x1(%ecx)
+8010449f:	74 04                	je     801044a5 <safestrcpy+0x35>
+801044a1:	39 f2                	cmp    %esi,%edx
+801044a3:	75 eb                	jne    80104490 <safestrcpy+0x20>
+    ;
+  *s = 0;
+801044a5:	c6 01 00             	movb   $0x0,(%ecx)
+  return os;
+}
+801044a8:	5b                   	pop    %ebx
+801044a9:	5e                   	pop    %esi
+801044aa:	5d                   	pop    %ebp
+801044ab:	c3                   	ret    
+801044ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+801044b0 <strlen>:
+
+int
+strlen(const char *s)
+{
+801044b0:	55                   	push   %ebp
+  int n;
+
+  for(n = 0; s[n]; n++)
+801044b1:	31 c0                	xor    %eax,%eax
+{
+801044b3:	89 e5                	mov    %esp,%ebp
+801044b5:	8b 55 08             	mov    0x8(%ebp),%edx
+  for(n = 0; s[n]; n++)
+801044b8:	80 3a 00             	cmpb   $0x0,(%edx)
+801044bb:	74 0c                	je     801044c9 <strlen+0x19>
+801044bd:	8d 76 00             	lea    0x0(%esi),%esi
+801044c0:	83 c0 01             	add    $0x1,%eax
+801044c3:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+801044c7:	75 f7                	jne    801044c0 <strlen+0x10>
+    ;
+  return n;
+}
+801044c9:	5d                   	pop    %ebp
+801044ca:	c3                   	ret    
+
+801044cb <swtch>:
+# Save current register context in old
+# and then load register context from new.
+
+.globl swtch
+swtch:
+  movl 4(%esp), %eax
+801044cb:	8b 44 24 04          	mov    0x4(%esp),%eax
+  movl 8(%esp), %edx
+801044cf:	8b 54 24 08          	mov    0x8(%esp),%edx
+
+  # Save old callee-save registers
+  pushl %ebp
+801044d3:	55                   	push   %ebp
+  pushl %ebx
+801044d4:	53                   	push   %ebx
+  pushl %esi
+801044d5:	56                   	push   %esi
+  pushl %edi
+801044d6:	57                   	push   %edi
+
+  # Switch stacks
+  movl %esp, (%eax)
+801044d7:	89 20                	mov    %esp,(%eax)
+  movl %edx, %esp
+801044d9:	89 d4                	mov    %edx,%esp
+
+  # Load new callee-save registers
+  popl %edi
+801044db:	5f                   	pop    %edi
+  popl %esi
+801044dc:	5e                   	pop    %esi
+  popl %ebx
+801044dd:	5b                   	pop    %ebx
+  popl %ebp
+801044de:	5d                   	pop    %ebp
+  ret
+801044df:	c3                   	ret    
+
+801044e0 <fetchint>:
+// to a saved program counter, and then the first argument.
+
+// Fetch the int at addr from the current process.
+int
+fetchint(uint addr, int *ip)
+{
+801044e0:	55                   	push   %ebp
+801044e1:	89 e5                	mov    %esp,%ebp
+801044e3:	53                   	push   %ebx
+801044e4:	83 ec 04             	sub    $0x4,%esp
+801044e7:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  struct proc *curproc = myproc();
+801044ea:	e8 c1 f1 ff ff       	call   801036b0 <myproc>
+
+  if(addr >= curproc->sz || addr+4 > curproc->sz)
+801044ef:	8b 00                	mov    (%eax),%eax
+801044f1:	39 d8                	cmp    %ebx,%eax
+801044f3:	76 1b                	jbe    80104510 <fetchint+0x30>
+801044f5:	8d 53 04             	lea    0x4(%ebx),%edx
+801044f8:	39 d0                	cmp    %edx,%eax
+801044fa:	72 14                	jb     80104510 <fetchint+0x30>
+    return -1;
+  *ip = *(int*)(addr);
+801044fc:	8b 45 0c             	mov    0xc(%ebp),%eax
+801044ff:	8b 13                	mov    (%ebx),%edx
+80104501:	89 10                	mov    %edx,(%eax)
+  return 0;
+80104503:	31 c0                	xor    %eax,%eax
+}
+80104505:	83 c4 04             	add    $0x4,%esp
+80104508:	5b                   	pop    %ebx
+80104509:	5d                   	pop    %ebp
+8010450a:	c3                   	ret    
+8010450b:	90                   	nop
+8010450c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+80104510:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104515:	eb ee                	jmp    80104505 <fetchint+0x25>
+80104517:	89 f6                	mov    %esi,%esi
+80104519:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80104520 <fetchstr>:
+// Fetch the nul-terminated string at addr from the current process.
+// Doesn't actually copy the string - just sets *pp to point at it.
+// Returns length of string, not including nul.
+int
+fetchstr(uint addr, char **pp)
+{
+80104520:	55                   	push   %ebp
+80104521:	89 e5                	mov    %esp,%ebp
+80104523:	53                   	push   %ebx
+80104524:	83 ec 04             	sub    $0x4,%esp
+80104527:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  char *s, *ep;
+  struct proc *curproc = myproc();
+8010452a:	e8 81 f1 ff ff       	call   801036b0 <myproc>
+
+  if(addr >= curproc->sz)
+8010452f:	39 18                	cmp    %ebx,(%eax)
+80104531:	76 26                	jbe    80104559 <fetchstr+0x39>
+    return -1;
+  *pp = (char*)addr;
+80104533:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+80104536:	89 da                	mov    %ebx,%edx
+80104538:	89 19                	mov    %ebx,(%ecx)
+  ep = (char*)curproc->sz;
+8010453a:	8b 00                	mov    (%eax),%eax
+  for(s = *pp; s < ep; s++){
+8010453c:	39 c3                	cmp    %eax,%ebx
+8010453e:	73 19                	jae    80104559 <fetchstr+0x39>
+    if(*s == 0)
+80104540:	80 3b 00             	cmpb   $0x0,(%ebx)
+80104543:	75 0d                	jne    80104552 <fetchstr+0x32>
+80104545:	eb 21                	jmp    80104568 <fetchstr+0x48>
+80104547:	90                   	nop
+80104548:	80 3a 00             	cmpb   $0x0,(%edx)
+8010454b:	90                   	nop
+8010454c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80104550:	74 16                	je     80104568 <fetchstr+0x48>
+  for(s = *pp; s < ep; s++){
+80104552:	83 c2 01             	add    $0x1,%edx
+80104555:	39 d0                	cmp    %edx,%eax
+80104557:	77 ef                	ja     80104548 <fetchstr+0x28>
+      return s - *pp;
+  }
+  return -1;
+}
+80104559:	83 c4 04             	add    $0x4,%esp
+    return -1;
+8010455c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104561:	5b                   	pop    %ebx
+80104562:	5d                   	pop    %ebp
+80104563:	c3                   	ret    
+80104564:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80104568:	83 c4 04             	add    $0x4,%esp
+      return s - *pp;
+8010456b:	89 d0                	mov    %edx,%eax
+8010456d:	29 d8                	sub    %ebx,%eax
+}
+8010456f:	5b                   	pop    %ebx
+80104570:	5d                   	pop    %ebp
+80104571:	c3                   	ret    
+80104572:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104579:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80104580 <argint>:
+
+// Fetch the nth 32-bit system call argument.
+int
+argint(int n, int *ip)
+{
+80104580:	55                   	push   %ebp
+80104581:	89 e5                	mov    %esp,%ebp
+80104583:	56                   	push   %esi
+80104584:	8b 75 0c             	mov    0xc(%ebp),%esi
+80104587:	53                   	push   %ebx
+80104588:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+8010458b:	e8 20 f1 ff ff       	call   801036b0 <myproc>
+80104590:	89 75 0c             	mov    %esi,0xc(%ebp)
+80104593:	8b 40 18             	mov    0x18(%eax),%eax
+80104596:	8b 40 44             	mov    0x44(%eax),%eax
+80104599:	8d 44 98 04          	lea    0x4(%eax,%ebx,4),%eax
+8010459d:	89 45 08             	mov    %eax,0x8(%ebp)
+}
+801045a0:	5b                   	pop    %ebx
+801045a1:	5e                   	pop    %esi
+801045a2:	5d                   	pop    %ebp
+  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+801045a3:	e9 38 ff ff ff       	jmp    801044e0 <fetchint>
+801045a8:	90                   	nop
+801045a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+801045b0 <argptr>:
+// Fetch the nth word-sized system call argument as a pointer
+// to a block of memory of size bytes.  Check that the pointer
+// lies within the process address space.
+int
+argptr(int n, char **pp, int size)
+{
+801045b0:	55                   	push   %ebp
+801045b1:	89 e5                	mov    %esp,%ebp
+801045b3:	56                   	push   %esi
+801045b4:	53                   	push   %ebx
+801045b5:	83 ec 20             	sub    $0x20,%esp
+801045b8:	8b 5d 10             	mov    0x10(%ebp),%ebx
+  int i;
+  struct proc *curproc = myproc();
+801045bb:	e8 f0 f0 ff ff       	call   801036b0 <myproc>
+801045c0:	89 c6                	mov    %eax,%esi
+ 
+  if(argint(n, &i) < 0)
+801045c2:	8d 45 f4             	lea    -0xc(%ebp),%eax
+801045c5:	89 44 24 04          	mov    %eax,0x4(%esp)
+801045c9:	8b 45 08             	mov    0x8(%ebp),%eax
+801045cc:	89 04 24             	mov    %eax,(%esp)
+801045cf:	e8 ac ff ff ff       	call   80104580 <argint>
+801045d4:	85 c0                	test   %eax,%eax
+801045d6:	78 28                	js     80104600 <argptr+0x50>
+    return -1;
+  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+801045d8:	85 db                	test   %ebx,%ebx
+801045da:	78 24                	js     80104600 <argptr+0x50>
+801045dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801045df:	8b 06                	mov    (%esi),%eax
+801045e1:	39 c2                	cmp    %eax,%edx
+801045e3:	73 1b                	jae    80104600 <argptr+0x50>
+801045e5:	01 d3                	add    %edx,%ebx
+801045e7:	39 d8                	cmp    %ebx,%eax
+801045e9:	72 15                	jb     80104600 <argptr+0x50>
+    return -1;
+  *pp = (char*)i;
+801045eb:	8b 45 0c             	mov    0xc(%ebp),%eax
+801045ee:	89 10                	mov    %edx,(%eax)
+  return 0;
+}
+801045f0:	83 c4 20             	add    $0x20,%esp
+  return 0;
+801045f3:	31 c0                	xor    %eax,%eax
+}
+801045f5:	5b                   	pop    %ebx
+801045f6:	5e                   	pop    %esi
+801045f7:	5d                   	pop    %ebp
+801045f8:	c3                   	ret    
+801045f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104600:	83 c4 20             	add    $0x20,%esp
+    return -1;
+80104603:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104608:	5b                   	pop    %ebx
+80104609:	5e                   	pop    %esi
+8010460a:	5d                   	pop    %ebp
+8010460b:	c3                   	ret    
+8010460c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80104610 <argstr>:
+// Check that the pointer is valid and the string is nul-terminated.
+// (There is no shared writable memory, so the string can't change
+// between this check and being used by the kernel.)
+int
+argstr(int n, char **pp)
+{
+80104610:	55                   	push   %ebp
+80104611:	89 e5                	mov    %esp,%ebp
+80104613:	83 ec 28             	sub    $0x28,%esp
+  int addr;
+  if(argint(n, &addr) < 0)
+80104616:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80104619:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010461d:	8b 45 08             	mov    0x8(%ebp),%eax
+80104620:	89 04 24             	mov    %eax,(%esp)
+80104623:	e8 58 ff ff ff       	call   80104580 <argint>
+80104628:	85 c0                	test   %eax,%eax
+8010462a:	78 14                	js     80104640 <argstr+0x30>
+    return -1;
+  return fetchstr(addr, pp);
+8010462c:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010462f:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104633:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104636:	89 04 24             	mov    %eax,(%esp)
+80104639:	e8 e2 fe ff ff       	call   80104520 <fetchstr>
+}
+8010463e:	c9                   	leave  
+8010463f:	c3                   	ret    
+    return -1;
+80104640:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104645:	c9                   	leave  
+80104646:	c3                   	ret    
+80104647:	89 f6                	mov    %esi,%esi
+80104649:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80104650 <syscall>:
+[SYS_shm_close] sys_shm_close
+};
+
+void
+syscall(void)
+{
+80104650:	55                   	push   %ebp
+80104651:	89 e5                	mov    %esp,%ebp
+80104653:	56                   	push   %esi
+80104654:	53                   	push   %ebx
+80104655:	83 ec 10             	sub    $0x10,%esp
+  int num;
+  struct proc *curproc = myproc();
+80104658:	e8 53 f0 ff ff       	call   801036b0 <myproc>
+
+  num = curproc->tf->eax;
+8010465d:	8b 70 18             	mov    0x18(%eax),%esi
+  struct proc *curproc = myproc();
+80104660:	89 c3                	mov    %eax,%ebx
+  num = curproc->tf->eax;
+80104662:	8b 46 1c             	mov    0x1c(%esi),%eax
+  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+80104665:	8d 50 ff             	lea    -0x1(%eax),%edx
+80104668:	83 fa 16             	cmp    $0x16,%edx
+8010466b:	77 1b                	ja     80104688 <syscall+0x38>
+8010466d:	8b 14 85 00 74 10 80 	mov    -0x7fef8c00(,%eax,4),%edx
+80104674:	85 d2                	test   %edx,%edx
+80104676:	74 10                	je     80104688 <syscall+0x38>
+    curproc->tf->eax = syscalls[num]();
+80104678:	ff d2                	call   *%edx
+8010467a:	89 46 1c             	mov    %eax,0x1c(%esi)
+  } else {
+    cprintf("%d %s: unknown sys call %d\n",
+            curproc->pid, curproc->name, num);
+    curproc->tf->eax = -1;
+  }
+}
+8010467d:	83 c4 10             	add    $0x10,%esp
+80104680:	5b                   	pop    %ebx
+80104681:	5e                   	pop    %esi
+80104682:	5d                   	pop    %ebp
+80104683:	c3                   	ret    
+80104684:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    cprintf("%d %s: unknown sys call %d\n",
+80104688:	89 44 24 0c          	mov    %eax,0xc(%esp)
+            curproc->pid, curproc->name, num);
+8010468c:	8d 43 6c             	lea    0x6c(%ebx),%eax
+8010468f:	89 44 24 08          	mov    %eax,0x8(%esp)
+    cprintf("%d %s: unknown sys call %d\n",
+80104693:	8b 43 10             	mov    0x10(%ebx),%eax
+80104696:	c7 04 24 d1 73 10 80 	movl   $0x801073d1,(%esp)
+8010469d:	89 44 24 04          	mov    %eax,0x4(%esp)
+801046a1:	e8 aa bf ff ff       	call   80100650 <cprintf>
+    curproc->tf->eax = -1;
+801046a6:	8b 43 18             	mov    0x18(%ebx),%eax
+801046a9:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)
+}
+801046b0:	83 c4 10             	add    $0x10,%esp
+801046b3:	5b                   	pop    %ebx
+801046b4:	5e                   	pop    %esi
+801046b5:	5d                   	pop    %ebp
+801046b6:	c3                   	ret    
+801046b7:	66 90                	xchg   %ax,%ax
+801046b9:	66 90                	xchg   %ax,%ax
+801046bb:	66 90                	xchg   %ax,%ax
+801046bd:	66 90                	xchg   %ax,%ax
+801046bf:	90                   	nop
+
+801046c0 <fdalloc>:
+
+// Allocate a file descriptor for the given file.
+// Takes over file reference from caller on success.
+static int
+fdalloc(struct file *f)
+{
+801046c0:	55                   	push   %ebp
+801046c1:	89 e5                	mov    %esp,%ebp
+801046c3:	53                   	push   %ebx
+801046c4:	89 c3                	mov    %eax,%ebx
+801046c6:	83 ec 04             	sub    $0x4,%esp
+  int fd;
+  struct proc *curproc = myproc();
+801046c9:	e8 e2 ef ff ff       	call   801036b0 <myproc>
+
+  for(fd = 0; fd < NOFILE; fd++){
+801046ce:	31 d2                	xor    %edx,%edx
+    if(curproc->ofile[fd] == 0){
+801046d0:	8b 4c 90 28          	mov    0x28(%eax,%edx,4),%ecx
+801046d4:	85 c9                	test   %ecx,%ecx
+801046d6:	74 18                	je     801046f0 <fdalloc+0x30>
+  for(fd = 0; fd < NOFILE; fd++){
+801046d8:	83 c2 01             	add    $0x1,%edx
+801046db:	83 fa 10             	cmp    $0x10,%edx
+801046de:	75 f0                	jne    801046d0 <fdalloc+0x10>
+      curproc->ofile[fd] = f;
+      return fd;
+    }
+  }
+  return -1;
+}
+801046e0:	83 c4 04             	add    $0x4,%esp
+  return -1;
+801046e3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801046e8:	5b                   	pop    %ebx
+801046e9:	5d                   	pop    %ebp
+801046ea:	c3                   	ret    
+801046eb:	90                   	nop
+801046ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      curproc->ofile[fd] = f;
+801046f0:	89 5c 90 28          	mov    %ebx,0x28(%eax,%edx,4)
+}
+801046f4:	83 c4 04             	add    $0x4,%esp
+      return fd;
+801046f7:	89 d0                	mov    %edx,%eax
+}
+801046f9:	5b                   	pop    %ebx
+801046fa:	5d                   	pop    %ebp
+801046fb:	c3                   	ret    
+801046fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80104700 <create>:
+  return -1;
+}
+
+static struct inode*
+create(char *path, short type, short major, short minor)
+{
+80104700:	55                   	push   %ebp
+80104701:	89 e5                	mov    %esp,%ebp
+80104703:	57                   	push   %edi
+80104704:	56                   	push   %esi
+80104705:	53                   	push   %ebx
+80104706:	83 ec 4c             	sub    $0x4c,%esp
+80104709:	89 4d c0             	mov    %ecx,-0x40(%ebp)
+8010470c:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  uint off;
+  struct inode *ip, *dp;
+  char name[DIRSIZ];
+
+  if((dp = nameiparent(path, name)) == 0)
+8010470f:	8d 5d da             	lea    -0x26(%ebp),%ebx
+80104712:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80104716:	89 04 24             	mov    %eax,(%esp)
+{
+80104719:	89 55 c4             	mov    %edx,-0x3c(%ebp)
+8010471c:	89 4d bc             	mov    %ecx,-0x44(%ebp)
+  if((dp = nameiparent(path, name)) == 0)
+8010471f:	e8 0c d8 ff ff       	call   80101f30 <nameiparent>
+80104724:	85 c0                	test   %eax,%eax
+80104726:	89 c7                	mov    %eax,%edi
+80104728:	0f 84 da 00 00 00    	je     80104808 <create+0x108>
+    return 0;
+  ilock(dp);
+8010472e:	89 04 24             	mov    %eax,(%esp)
+80104731:	e8 8a cf ff ff       	call   801016c0 <ilock>
+
+  if((ip = dirlookup(dp, name, &off)) != 0){
+80104736:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+80104739:	89 44 24 08          	mov    %eax,0x8(%esp)
+8010473d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80104741:	89 3c 24             	mov    %edi,(%esp)
+80104744:	e8 87 d4 ff ff       	call   80101bd0 <dirlookup>
+80104749:	85 c0                	test   %eax,%eax
+8010474b:	89 c6                	mov    %eax,%esi
+8010474d:	74 41                	je     80104790 <create+0x90>
+    iunlockput(dp);
+8010474f:	89 3c 24             	mov    %edi,(%esp)
+80104752:	e8 c9 d1 ff ff       	call   80101920 <iunlockput>
+    ilock(ip);
+80104757:	89 34 24             	mov    %esi,(%esp)
+8010475a:	e8 61 cf ff ff       	call   801016c0 <ilock>
+    if(type == T_FILE && ip->type == T_FILE)
+8010475f:	66 83 7d c4 02       	cmpw   $0x2,-0x3c(%ebp)
+80104764:	75 12                	jne    80104778 <create+0x78>
+80104766:	66 83 7e 50 02       	cmpw   $0x2,0x50(%esi)
+8010476b:	89 f0                	mov    %esi,%eax
+8010476d:	75 09                	jne    80104778 <create+0x78>
+    panic("create: dirlink");
+
+  iunlockput(dp);
+
+  return ip;
+}
+8010476f:	83 c4 4c             	add    $0x4c,%esp
+80104772:	5b                   	pop    %ebx
+80104773:	5e                   	pop    %esi
+80104774:	5f                   	pop    %edi
+80104775:	5d                   	pop    %ebp
+80104776:	c3                   	ret    
+80104777:	90                   	nop
+    iunlockput(ip);
+80104778:	89 34 24             	mov    %esi,(%esp)
+8010477b:	e8 a0 d1 ff ff       	call   80101920 <iunlockput>
+}
+80104780:	83 c4 4c             	add    $0x4c,%esp
+    return 0;
+80104783:	31 c0                	xor    %eax,%eax
+}
+80104785:	5b                   	pop    %ebx
+80104786:	5e                   	pop    %esi
+80104787:	5f                   	pop    %edi
+80104788:	5d                   	pop    %ebp
+80104789:	c3                   	ret    
+8010478a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  if((ip = ialloc(dp->dev, type)) == 0)
+80104790:	0f bf 45 c4          	movswl -0x3c(%ebp),%eax
+80104794:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104798:	8b 07                	mov    (%edi),%eax
+8010479a:	89 04 24             	mov    %eax,(%esp)
+8010479d:	e8 8e cd ff ff       	call   80101530 <ialloc>
+801047a2:	85 c0                	test   %eax,%eax
+801047a4:	89 c6                	mov    %eax,%esi
+801047a6:	0f 84 bf 00 00 00    	je     8010486b <create+0x16b>
+  ilock(ip);
+801047ac:	89 04 24             	mov    %eax,(%esp)
+801047af:	e8 0c cf ff ff       	call   801016c0 <ilock>
+  ip->major = major;
+801047b4:	0f b7 45 c0          	movzwl -0x40(%ebp),%eax
+801047b8:	66 89 46 52          	mov    %ax,0x52(%esi)
+  ip->minor = minor;
+801047bc:	0f b7 45 bc          	movzwl -0x44(%ebp),%eax
+801047c0:	66 89 46 54          	mov    %ax,0x54(%esi)
+  ip->nlink = 1;
+801047c4:	b8 01 00 00 00       	mov    $0x1,%eax
+801047c9:	66 89 46 56          	mov    %ax,0x56(%esi)
+  iupdate(ip);
+801047cd:	89 34 24             	mov    %esi,(%esp)
+801047d0:	e8 2b ce ff ff       	call   80101600 <iupdate>
+  if(type == T_DIR){  // Create . and .. entries.
+801047d5:	66 83 7d c4 01       	cmpw   $0x1,-0x3c(%ebp)
+801047da:	74 34                	je     80104810 <create+0x110>
+  if(dirlink(dp, name, ip->inum) < 0)
+801047dc:	8b 46 04             	mov    0x4(%esi),%eax
+801047df:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+801047e3:	89 3c 24             	mov    %edi,(%esp)
+801047e6:	89 44 24 08          	mov    %eax,0x8(%esp)
+801047ea:	e8 41 d6 ff ff       	call   80101e30 <dirlink>
+801047ef:	85 c0                	test   %eax,%eax
+801047f1:	78 6c                	js     8010485f <create+0x15f>
+  iunlockput(dp);
+801047f3:	89 3c 24             	mov    %edi,(%esp)
+801047f6:	e8 25 d1 ff ff       	call   80101920 <iunlockput>
+}
+801047fb:	83 c4 4c             	add    $0x4c,%esp
+  return ip;
+801047fe:	89 f0                	mov    %esi,%eax
+}
+80104800:	5b                   	pop    %ebx
+80104801:	5e                   	pop    %esi
+80104802:	5f                   	pop    %edi
+80104803:	5d                   	pop    %ebp
+80104804:	c3                   	ret    
+80104805:	8d 76 00             	lea    0x0(%esi),%esi
+    return 0;
+80104808:	31 c0                	xor    %eax,%eax
+8010480a:	e9 60 ff ff ff       	jmp    8010476f <create+0x6f>
+8010480f:	90                   	nop
+    dp->nlink++;  // for ".."
+80104810:	66 83 47 56 01       	addw   $0x1,0x56(%edi)
+    iupdate(dp);
+80104815:	89 3c 24             	mov    %edi,(%esp)
+80104818:	e8 e3 cd ff ff       	call   80101600 <iupdate>
+    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+8010481d:	8b 46 04             	mov    0x4(%esi),%eax
+80104820:	c7 44 24 04 7c 74 10 	movl   $0x8010747c,0x4(%esp)
+80104827:	80 
+80104828:	89 34 24             	mov    %esi,(%esp)
+8010482b:	89 44 24 08          	mov    %eax,0x8(%esp)
+8010482f:	e8 fc d5 ff ff       	call   80101e30 <dirlink>
+80104834:	85 c0                	test   %eax,%eax
+80104836:	78 1b                	js     80104853 <create+0x153>
+80104838:	8b 47 04             	mov    0x4(%edi),%eax
+8010483b:	c7 44 24 04 7b 74 10 	movl   $0x8010747b,0x4(%esp)
+80104842:	80 
+80104843:	89 34 24             	mov    %esi,(%esp)
+80104846:	89 44 24 08          	mov    %eax,0x8(%esp)
+8010484a:	e8 e1 d5 ff ff       	call   80101e30 <dirlink>
+8010484f:	85 c0                	test   %eax,%eax
+80104851:	79 89                	jns    801047dc <create+0xdc>
+      panic("create dots");
+80104853:	c7 04 24 6f 74 10 80 	movl   $0x8010746f,(%esp)
+8010485a:	e8 01 bb ff ff       	call   80100360 <panic>
+    panic("create: dirlink");
+8010485f:	c7 04 24 7e 74 10 80 	movl   $0x8010747e,(%esp)
+80104866:	e8 f5 ba ff ff       	call   80100360 <panic>
+    panic("create: ialloc");
+8010486b:	c7 04 24 60 74 10 80 	movl   $0x80107460,(%esp)
+80104872:	e8 e9 ba ff ff       	call   80100360 <panic>
+80104877:	89 f6                	mov    %esi,%esi
+80104879:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80104880 <argfd.constprop.0>:
+argfd(int n, int *pfd, struct file **pf)
+80104880:	55                   	push   %ebp
+80104881:	89 e5                	mov    %esp,%ebp
+80104883:	56                   	push   %esi
+80104884:	89 c6                	mov    %eax,%esi
+80104886:	53                   	push   %ebx
+80104887:	89 d3                	mov    %edx,%ebx
+80104889:	83 ec 20             	sub    $0x20,%esp
+  if(argint(n, &fd) < 0)
+8010488c:	8d 45 f4             	lea    -0xc(%ebp),%eax
+8010488f:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104893:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+8010489a:	e8 e1 fc ff ff       	call   80104580 <argint>
+8010489f:	85 c0                	test   %eax,%eax
+801048a1:	78 2d                	js     801048d0 <argfd.constprop.0+0x50>
+  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+801048a3:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
+801048a7:	77 27                	ja     801048d0 <argfd.constprop.0+0x50>
+801048a9:	e8 02 ee ff ff       	call   801036b0 <myproc>
+801048ae:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801048b1:	8b 44 90 28          	mov    0x28(%eax,%edx,4),%eax
+801048b5:	85 c0                	test   %eax,%eax
+801048b7:	74 17                	je     801048d0 <argfd.constprop.0+0x50>
+  if(pfd)
+801048b9:	85 f6                	test   %esi,%esi
+801048bb:	74 02                	je     801048bf <argfd.constprop.0+0x3f>
+    *pfd = fd;
+801048bd:	89 16                	mov    %edx,(%esi)
+  if(pf)
+801048bf:	85 db                	test   %ebx,%ebx
+801048c1:	74 1d                	je     801048e0 <argfd.constprop.0+0x60>
+    *pf = f;
+801048c3:	89 03                	mov    %eax,(%ebx)
+  return 0;
+801048c5:	31 c0                	xor    %eax,%eax
+}
+801048c7:	83 c4 20             	add    $0x20,%esp
+801048ca:	5b                   	pop    %ebx
+801048cb:	5e                   	pop    %esi
+801048cc:	5d                   	pop    %ebp
+801048cd:	c3                   	ret    
+801048ce:	66 90                	xchg   %ax,%ax
+801048d0:	83 c4 20             	add    $0x20,%esp
+    return -1;
+801048d3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801048d8:	5b                   	pop    %ebx
+801048d9:	5e                   	pop    %esi
+801048da:	5d                   	pop    %ebp
+801048db:	c3                   	ret    
+801048dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+801048e0:	31 c0                	xor    %eax,%eax
+801048e2:	eb e3                	jmp    801048c7 <argfd.constprop.0+0x47>
+801048e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+801048ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+801048f0 <sys_dup>:
+{
+801048f0:	55                   	push   %ebp
+  if(argfd(0, 0, &f) < 0)
+801048f1:	31 c0                	xor    %eax,%eax
+{
+801048f3:	89 e5                	mov    %esp,%ebp
+801048f5:	53                   	push   %ebx
+801048f6:	83 ec 24             	sub    $0x24,%esp
+  if(argfd(0, 0, &f) < 0)
+801048f9:	8d 55 f4             	lea    -0xc(%ebp),%edx
+801048fc:	e8 7f ff ff ff       	call   80104880 <argfd.constprop.0>
+80104901:	85 c0                	test   %eax,%eax
+80104903:	78 23                	js     80104928 <sys_dup+0x38>
+  if((fd=fdalloc(f)) < 0)
+80104905:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104908:	e8 b3 fd ff ff       	call   801046c0 <fdalloc>
+8010490d:	85 c0                	test   %eax,%eax
+8010490f:	89 c3                	mov    %eax,%ebx
+80104911:	78 15                	js     80104928 <sys_dup+0x38>
+  filedup(f);
+80104913:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104916:	89 04 24             	mov    %eax,(%esp)
+80104919:	e8 c2 c4 ff ff       	call   80100de0 <filedup>
+  return fd;
+8010491e:	89 d8                	mov    %ebx,%eax
+}
+80104920:	83 c4 24             	add    $0x24,%esp
+80104923:	5b                   	pop    %ebx
+80104924:	5d                   	pop    %ebp
+80104925:	c3                   	ret    
+80104926:	66 90                	xchg   %ax,%ax
+    return -1;
+80104928:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010492d:	eb f1                	jmp    80104920 <sys_dup+0x30>
+8010492f:	90                   	nop
+
+80104930 <sys_read>:
+{
+80104930:	55                   	push   %ebp
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+80104931:	31 c0                	xor    %eax,%eax
+{
+80104933:	89 e5                	mov    %esp,%ebp
+80104935:	83 ec 28             	sub    $0x28,%esp
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+80104938:	8d 55 ec             	lea    -0x14(%ebp),%edx
+8010493b:	e8 40 ff ff ff       	call   80104880 <argfd.constprop.0>
+80104940:	85 c0                	test   %eax,%eax
+80104942:	78 54                	js     80104998 <sys_read+0x68>
+80104944:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80104947:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010494b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+80104952:	e8 29 fc ff ff       	call   80104580 <argint>
+80104957:	85 c0                	test   %eax,%eax
+80104959:	78 3d                	js     80104998 <sys_read+0x68>
+8010495b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010495e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+80104965:	89 44 24 08          	mov    %eax,0x8(%esp)
+80104969:	8d 45 f4             	lea    -0xc(%ebp),%eax
+8010496c:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104970:	e8 3b fc ff ff       	call   801045b0 <argptr>
+80104975:	85 c0                	test   %eax,%eax
+80104977:	78 1f                	js     80104998 <sys_read+0x68>
+  return fileread(f, p, n);
+80104979:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010497c:	89 44 24 08          	mov    %eax,0x8(%esp)
+80104980:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104983:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104987:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010498a:	89 04 24             	mov    %eax,(%esp)
+8010498d:	e8 ae c5 ff ff       	call   80100f40 <fileread>
+}
+80104992:	c9                   	leave  
+80104993:	c3                   	ret    
+80104994:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+80104998:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+8010499d:	c9                   	leave  
+8010499e:	c3                   	ret    
+8010499f:	90                   	nop
+
+801049a0 <sys_write>:
+{
+801049a0:	55                   	push   %ebp
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+801049a1:	31 c0                	xor    %eax,%eax
+{
+801049a3:	89 e5                	mov    %esp,%ebp
+801049a5:	83 ec 28             	sub    $0x28,%esp
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+801049a8:	8d 55 ec             	lea    -0x14(%ebp),%edx
+801049ab:	e8 d0 fe ff ff       	call   80104880 <argfd.constprop.0>
+801049b0:	85 c0                	test   %eax,%eax
+801049b2:	78 54                	js     80104a08 <sys_write+0x68>
+801049b4:	8d 45 f0             	lea    -0x10(%ebp),%eax
+801049b7:	89 44 24 04          	mov    %eax,0x4(%esp)
+801049bb:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+801049c2:	e8 b9 fb ff ff       	call   80104580 <argint>
+801049c7:	85 c0                	test   %eax,%eax
+801049c9:	78 3d                	js     80104a08 <sys_write+0x68>
+801049cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801049ce:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+801049d5:	89 44 24 08          	mov    %eax,0x8(%esp)
+801049d9:	8d 45 f4             	lea    -0xc(%ebp),%eax
+801049dc:	89 44 24 04          	mov    %eax,0x4(%esp)
+801049e0:	e8 cb fb ff ff       	call   801045b0 <argptr>
+801049e5:	85 c0                	test   %eax,%eax
+801049e7:	78 1f                	js     80104a08 <sys_write+0x68>
+  return filewrite(f, p, n);
+801049e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801049ec:	89 44 24 08          	mov    %eax,0x8(%esp)
+801049f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801049f3:	89 44 24 04          	mov    %eax,0x4(%esp)
+801049f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801049fa:	89 04 24             	mov    %eax,(%esp)
+801049fd:	e8 de c5 ff ff       	call   80100fe0 <filewrite>
+}
+80104a02:	c9                   	leave  
+80104a03:	c3                   	ret    
+80104a04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+80104a08:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104a0d:	c9                   	leave  
+80104a0e:	c3                   	ret    
+80104a0f:	90                   	nop
+
+80104a10 <sys_close>:
+{
+80104a10:	55                   	push   %ebp
+80104a11:	89 e5                	mov    %esp,%ebp
+80104a13:	83 ec 28             	sub    $0x28,%esp
+  if(argfd(0, &fd, &f) < 0)
+80104a16:	8d 55 f4             	lea    -0xc(%ebp),%edx
+80104a19:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80104a1c:	e8 5f fe ff ff       	call   80104880 <argfd.constprop.0>
+80104a21:	85 c0                	test   %eax,%eax
+80104a23:	78 23                	js     80104a48 <sys_close+0x38>
+  myproc()->ofile[fd] = 0;
+80104a25:	e8 86 ec ff ff       	call   801036b0 <myproc>
+80104a2a:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80104a2d:	c7 44 90 28 00 00 00 	movl   $0x0,0x28(%eax,%edx,4)
+80104a34:	00 
+  fileclose(f);
+80104a35:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104a38:	89 04 24             	mov    %eax,(%esp)
+80104a3b:	e8 f0 c3 ff ff       	call   80100e30 <fileclose>
+  return 0;
+80104a40:	31 c0                	xor    %eax,%eax
+}
+80104a42:	c9                   	leave  
+80104a43:	c3                   	ret    
+80104a44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+80104a48:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104a4d:	c9                   	leave  
+80104a4e:	c3                   	ret    
+80104a4f:	90                   	nop
+
+80104a50 <sys_fstat>:
+{
+80104a50:	55                   	push   %ebp
+  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+80104a51:	31 c0                	xor    %eax,%eax
+{
+80104a53:	89 e5                	mov    %esp,%ebp
+80104a55:	83 ec 28             	sub    $0x28,%esp
+  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+80104a58:	8d 55 f0             	lea    -0x10(%ebp),%edx
+80104a5b:	e8 20 fe ff ff       	call   80104880 <argfd.constprop.0>
+80104a60:	85 c0                	test   %eax,%eax
+80104a62:	78 34                	js     80104a98 <sys_fstat+0x48>
+80104a64:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80104a67:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
+80104a6e:	00 
+80104a6f:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104a73:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+80104a7a:	e8 31 fb ff ff       	call   801045b0 <argptr>
+80104a7f:	85 c0                	test   %eax,%eax
+80104a81:	78 15                	js     80104a98 <sys_fstat+0x48>
+  return filestat(f, st);
+80104a83:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104a86:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104a8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80104a8d:	89 04 24             	mov    %eax,(%esp)
+80104a90:	e8 5b c4 ff ff       	call   80100ef0 <filestat>
+}
+80104a95:	c9                   	leave  
+80104a96:	c3                   	ret    
+80104a97:	90                   	nop
+    return -1;
+80104a98:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104a9d:	c9                   	leave  
+80104a9e:	c3                   	ret    
+80104a9f:	90                   	nop
+
+80104aa0 <sys_link>:
+{
+80104aa0:	55                   	push   %ebp
+80104aa1:	89 e5                	mov    %esp,%ebp
+80104aa3:	57                   	push   %edi
+80104aa4:	56                   	push   %esi
+80104aa5:	53                   	push   %ebx
+80104aa6:	83 ec 3c             	sub    $0x3c,%esp
+  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
+80104aa9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+80104aac:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104ab0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80104ab7:	e8 54 fb ff ff       	call   80104610 <argstr>
+80104abc:	85 c0                	test   %eax,%eax
+80104abe:	0f 88 e6 00 00 00    	js     80104baa <sys_link+0x10a>
+80104ac4:	8d 45 d0             	lea    -0x30(%ebp),%eax
+80104ac7:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104acb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+80104ad2:	e8 39 fb ff ff       	call   80104610 <argstr>
+80104ad7:	85 c0                	test   %eax,%eax
+80104ad9:	0f 88 cb 00 00 00    	js     80104baa <sys_link+0x10a>
+  begin_op();
+80104adf:	e8 3c e0 ff ff       	call   80102b20 <begin_op>
+  if((ip = namei(old)) == 0){
+80104ae4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+80104ae7:	89 04 24             	mov    %eax,(%esp)
+80104aea:	e8 21 d4 ff ff       	call   80101f10 <namei>
+80104aef:	85 c0                	test   %eax,%eax
+80104af1:	89 c3                	mov    %eax,%ebx
+80104af3:	0f 84 ac 00 00 00    	je     80104ba5 <sys_link+0x105>
+  ilock(ip);
+80104af9:	89 04 24             	mov    %eax,(%esp)
+80104afc:	e8 bf cb ff ff       	call   801016c0 <ilock>
+  if(ip->type == T_DIR){
+80104b01:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
+80104b06:	0f 84 91 00 00 00    	je     80104b9d <sys_link+0xfd>
+  ip->nlink++;
+80104b0c:	66 83 43 56 01       	addw   $0x1,0x56(%ebx)
+  if((dp = nameiparent(new, name)) == 0)
+80104b11:	8d 7d da             	lea    -0x26(%ebp),%edi
+  iupdate(ip);
+80104b14:	89 1c 24             	mov    %ebx,(%esp)
+80104b17:	e8 e4 ca ff ff       	call   80101600 <iupdate>
+  iunlock(ip);
+80104b1c:	89 1c 24             	mov    %ebx,(%esp)
+80104b1f:	e8 7c cc ff ff       	call   801017a0 <iunlock>
+  if((dp = nameiparent(new, name)) == 0)
+80104b24:	8b 45 d0             	mov    -0x30(%ebp),%eax
+80104b27:	89 7c 24 04          	mov    %edi,0x4(%esp)
+80104b2b:	89 04 24             	mov    %eax,(%esp)
+80104b2e:	e8 fd d3 ff ff       	call   80101f30 <nameiparent>
+80104b33:	85 c0                	test   %eax,%eax
+80104b35:	89 c6                	mov    %eax,%esi
+80104b37:	74 4f                	je     80104b88 <sys_link+0xe8>
+  ilock(dp);
+80104b39:	89 04 24             	mov    %eax,(%esp)
+80104b3c:	e8 7f cb ff ff       	call   801016c0 <ilock>
+  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+80104b41:	8b 03                	mov    (%ebx),%eax
+80104b43:	39 06                	cmp    %eax,(%esi)
+80104b45:	75 39                	jne    80104b80 <sys_link+0xe0>
+80104b47:	8b 43 04             	mov    0x4(%ebx),%eax
+80104b4a:	89 7c 24 04          	mov    %edi,0x4(%esp)
+80104b4e:	89 34 24             	mov    %esi,(%esp)
+80104b51:	89 44 24 08          	mov    %eax,0x8(%esp)
+80104b55:	e8 d6 d2 ff ff       	call   80101e30 <dirlink>
+80104b5a:	85 c0                	test   %eax,%eax
+80104b5c:	78 22                	js     80104b80 <sys_link+0xe0>
+  iunlockput(dp);
+80104b5e:	89 34 24             	mov    %esi,(%esp)
+80104b61:	e8 ba cd ff ff       	call   80101920 <iunlockput>
+  iput(ip);
+80104b66:	89 1c 24             	mov    %ebx,(%esp)
+80104b69:	e8 72 cc ff ff       	call   801017e0 <iput>
+  end_op();
+80104b6e:	e8 1d e0 ff ff       	call   80102b90 <end_op>
+}
+80104b73:	83 c4 3c             	add    $0x3c,%esp
+  return 0;
+80104b76:	31 c0                	xor    %eax,%eax
+}
+80104b78:	5b                   	pop    %ebx
+80104b79:	5e                   	pop    %esi
+80104b7a:	5f                   	pop    %edi
+80104b7b:	5d                   	pop    %ebp
+80104b7c:	c3                   	ret    
+80104b7d:	8d 76 00             	lea    0x0(%esi),%esi
+    iunlockput(dp);
+80104b80:	89 34 24             	mov    %esi,(%esp)
+80104b83:	e8 98 cd ff ff       	call   80101920 <iunlockput>
+  ilock(ip);
+80104b88:	89 1c 24             	mov    %ebx,(%esp)
+80104b8b:	e8 30 cb ff ff       	call   801016c0 <ilock>
+  ip->nlink--;
+80104b90:	66 83 6b 56 01       	subw   $0x1,0x56(%ebx)
+  iupdate(ip);
+80104b95:	89 1c 24             	mov    %ebx,(%esp)
+80104b98:	e8 63 ca ff ff       	call   80101600 <iupdate>
+  iunlockput(ip);
+80104b9d:	89 1c 24             	mov    %ebx,(%esp)
+80104ba0:	e8 7b cd ff ff       	call   80101920 <iunlockput>
+  end_op();
+80104ba5:	e8 e6 df ff ff       	call   80102b90 <end_op>
+}
+80104baa:	83 c4 3c             	add    $0x3c,%esp
+  return -1;
+80104bad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104bb2:	5b                   	pop    %ebx
+80104bb3:	5e                   	pop    %esi
+80104bb4:	5f                   	pop    %edi
+80104bb5:	5d                   	pop    %ebp
+80104bb6:	c3                   	ret    
+80104bb7:	89 f6                	mov    %esi,%esi
+80104bb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80104bc0 <sys_unlink>:
+{
+80104bc0:	55                   	push   %ebp
+80104bc1:	89 e5                	mov    %esp,%ebp
+80104bc3:	57                   	push   %edi
+80104bc4:	56                   	push   %esi
+80104bc5:	53                   	push   %ebx
+80104bc6:	83 ec 5c             	sub    $0x5c,%esp
+  if(argstr(0, &path) < 0)
+80104bc9:	8d 45 c0             	lea    -0x40(%ebp),%eax
+80104bcc:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104bd0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80104bd7:	e8 34 fa ff ff       	call   80104610 <argstr>
+80104bdc:	85 c0                	test   %eax,%eax
+80104bde:	0f 88 76 01 00 00    	js     80104d5a <sys_unlink+0x19a>
+  begin_op();
+80104be4:	e8 37 df ff ff       	call   80102b20 <begin_op>
+  if((dp = nameiparent(path, name)) == 0){
+80104be9:	8b 45 c0             	mov    -0x40(%ebp),%eax
+80104bec:	8d 5d ca             	lea    -0x36(%ebp),%ebx
+80104bef:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80104bf3:	89 04 24             	mov    %eax,(%esp)
+80104bf6:	e8 35 d3 ff ff       	call   80101f30 <nameiparent>
+80104bfb:	85 c0                	test   %eax,%eax
+80104bfd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+80104c00:	0f 84 4f 01 00 00    	je     80104d55 <sys_unlink+0x195>
+  ilock(dp);
+80104c06:	8b 75 b4             	mov    -0x4c(%ebp),%esi
+80104c09:	89 34 24             	mov    %esi,(%esp)
+80104c0c:	e8 af ca ff ff       	call   801016c0 <ilock>
+  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+80104c11:	c7 44 24 04 7c 74 10 	movl   $0x8010747c,0x4(%esp)
+80104c18:	80 
+80104c19:	89 1c 24             	mov    %ebx,(%esp)
+80104c1c:	e8 7f cf ff ff       	call   80101ba0 <namecmp>
+80104c21:	85 c0                	test   %eax,%eax
+80104c23:	0f 84 21 01 00 00    	je     80104d4a <sys_unlink+0x18a>
+80104c29:	c7 44 24 04 7b 74 10 	movl   $0x8010747b,0x4(%esp)
+80104c30:	80 
+80104c31:	89 1c 24             	mov    %ebx,(%esp)
+80104c34:	e8 67 cf ff ff       	call   80101ba0 <namecmp>
+80104c39:	85 c0                	test   %eax,%eax
+80104c3b:	0f 84 09 01 00 00    	je     80104d4a <sys_unlink+0x18a>
+  if((ip = dirlookup(dp, name, &off)) == 0)
+80104c41:	8d 45 c4             	lea    -0x3c(%ebp),%eax
+80104c44:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80104c48:	89 44 24 08          	mov    %eax,0x8(%esp)
+80104c4c:	89 34 24             	mov    %esi,(%esp)
+80104c4f:	e8 7c cf ff ff       	call   80101bd0 <dirlookup>
+80104c54:	85 c0                	test   %eax,%eax
+80104c56:	89 c3                	mov    %eax,%ebx
+80104c58:	0f 84 ec 00 00 00    	je     80104d4a <sys_unlink+0x18a>
+  ilock(ip);
+80104c5e:	89 04 24             	mov    %eax,(%esp)
+80104c61:	e8 5a ca ff ff       	call   801016c0 <ilock>
+  if(ip->nlink < 1)
+80104c66:	66 83 7b 56 00       	cmpw   $0x0,0x56(%ebx)
+80104c6b:	0f 8e 24 01 00 00    	jle    80104d95 <sys_unlink+0x1d5>
+  if(ip->type == T_DIR && !isdirempty(ip)){
+80104c71:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
+80104c76:	8d 75 d8             	lea    -0x28(%ebp),%esi
+80104c79:	74 7d                	je     80104cf8 <sys_unlink+0x138>
+  memset(&de, 0, sizeof(de));
+80104c7b:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+80104c82:	00 
+80104c83:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80104c8a:	00 
+80104c8b:	89 34 24             	mov    %esi,(%esp)
+80104c8e:	e8 fd f5 ff ff       	call   80104290 <memset>
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80104c93:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+80104c96:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
+80104c9d:	00 
+80104c9e:	89 74 24 04          	mov    %esi,0x4(%esp)
+80104ca2:	89 44 24 08          	mov    %eax,0x8(%esp)
+80104ca6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+80104ca9:	89 04 24             	mov    %eax,(%esp)
+80104cac:	e8 bf cd ff ff       	call   80101a70 <writei>
+80104cb1:	83 f8 10             	cmp    $0x10,%eax
+80104cb4:	0f 85 cf 00 00 00    	jne    80104d89 <sys_unlink+0x1c9>
+  if(ip->type == T_DIR){
+80104cba:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
+80104cbf:	0f 84 a3 00 00 00    	je     80104d68 <sys_unlink+0x1a8>
+  iunlockput(dp);
+80104cc5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+80104cc8:	89 04 24             	mov    %eax,(%esp)
+80104ccb:	e8 50 cc ff ff       	call   80101920 <iunlockput>
+  ip->nlink--;
+80104cd0:	66 83 6b 56 01       	subw   $0x1,0x56(%ebx)
+  iupdate(ip);
+80104cd5:	89 1c 24             	mov    %ebx,(%esp)
+80104cd8:	e8 23 c9 ff ff       	call   80101600 <iupdate>
+  iunlockput(ip);
+80104cdd:	89 1c 24             	mov    %ebx,(%esp)
+80104ce0:	e8 3b cc ff ff       	call   80101920 <iunlockput>
+  end_op();
+80104ce5:	e8 a6 de ff ff       	call   80102b90 <end_op>
+}
+80104cea:	83 c4 5c             	add    $0x5c,%esp
+  return 0;
+80104ced:	31 c0                	xor    %eax,%eax
+}
+80104cef:	5b                   	pop    %ebx
+80104cf0:	5e                   	pop    %esi
+80104cf1:	5f                   	pop    %edi
+80104cf2:	5d                   	pop    %ebp
+80104cf3:	c3                   	ret    
+80104cf4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+80104cf8:	83 7b 58 20          	cmpl   $0x20,0x58(%ebx)
+80104cfc:	0f 86 79 ff ff ff    	jbe    80104c7b <sys_unlink+0xbb>
+80104d02:	bf 20 00 00 00       	mov    $0x20,%edi
+80104d07:	eb 15                	jmp    80104d1e <sys_unlink+0x15e>
+80104d09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104d10:	8d 57 10             	lea    0x10(%edi),%edx
+80104d13:	3b 53 58             	cmp    0x58(%ebx),%edx
+80104d16:	0f 83 5f ff ff ff    	jae    80104c7b <sys_unlink+0xbb>
+80104d1c:	89 d7                	mov    %edx,%edi
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80104d1e:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
+80104d25:	00 
+80104d26:	89 7c 24 08          	mov    %edi,0x8(%esp)
+80104d2a:	89 74 24 04          	mov    %esi,0x4(%esp)
+80104d2e:	89 1c 24             	mov    %ebx,(%esp)
+80104d31:	e8 3a cc ff ff       	call   80101970 <readi>
+80104d36:	83 f8 10             	cmp    $0x10,%eax
+80104d39:	75 42                	jne    80104d7d <sys_unlink+0x1bd>
+    if(de.inum != 0)
+80104d3b:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
+80104d40:	74 ce                	je     80104d10 <sys_unlink+0x150>
+    iunlockput(ip);
+80104d42:	89 1c 24             	mov    %ebx,(%esp)
+80104d45:	e8 d6 cb ff ff       	call   80101920 <iunlockput>
+  iunlockput(dp);
+80104d4a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+80104d4d:	89 04 24             	mov    %eax,(%esp)
+80104d50:	e8 cb cb ff ff       	call   80101920 <iunlockput>
+  end_op();
+80104d55:	e8 36 de ff ff       	call   80102b90 <end_op>
+}
+80104d5a:	83 c4 5c             	add    $0x5c,%esp
+  return -1;
+80104d5d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104d62:	5b                   	pop    %ebx
+80104d63:	5e                   	pop    %esi
+80104d64:	5f                   	pop    %edi
+80104d65:	5d                   	pop    %ebp
+80104d66:	c3                   	ret    
+80104d67:	90                   	nop
+    dp->nlink--;
+80104d68:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+80104d6b:	66 83 68 56 01       	subw   $0x1,0x56(%eax)
+    iupdate(dp);
+80104d70:	89 04 24             	mov    %eax,(%esp)
+80104d73:	e8 88 c8 ff ff       	call   80101600 <iupdate>
+80104d78:	e9 48 ff ff ff       	jmp    80104cc5 <sys_unlink+0x105>
+      panic("isdirempty: readi");
+80104d7d:	c7 04 24 a0 74 10 80 	movl   $0x801074a0,(%esp)
+80104d84:	e8 d7 b5 ff ff       	call   80100360 <panic>
+    panic("unlink: writei");
+80104d89:	c7 04 24 b2 74 10 80 	movl   $0x801074b2,(%esp)
+80104d90:	e8 cb b5 ff ff       	call   80100360 <panic>
+    panic("unlink: nlink < 1");
+80104d95:	c7 04 24 8e 74 10 80 	movl   $0x8010748e,(%esp)
+80104d9c:	e8 bf b5 ff ff       	call   80100360 <panic>
+80104da1:	eb 0d                	jmp    80104db0 <sys_open>
+80104da3:	90                   	nop
+80104da4:	90                   	nop
+80104da5:	90                   	nop
+80104da6:	90                   	nop
+80104da7:	90                   	nop
+80104da8:	90                   	nop
+80104da9:	90                   	nop
+80104daa:	90                   	nop
+80104dab:	90                   	nop
+80104dac:	90                   	nop
+80104dad:	90                   	nop
+80104dae:	90                   	nop
+80104daf:	90                   	nop
+
+80104db0 <sys_open>:
+
+int
+sys_open(void)
+{
+80104db0:	55                   	push   %ebp
+80104db1:	89 e5                	mov    %esp,%ebp
+80104db3:	57                   	push   %edi
+80104db4:	56                   	push   %esi
+80104db5:	53                   	push   %ebx
+80104db6:	83 ec 2c             	sub    $0x2c,%esp
+  char *path;
+  int fd, omode;
+  struct file *f;
+  struct inode *ip;
+
+  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
+80104db9:	8d 45 e0             	lea    -0x20(%ebp),%eax
+80104dbc:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104dc0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80104dc7:	e8 44 f8 ff ff       	call   80104610 <argstr>
+80104dcc:	85 c0                	test   %eax,%eax
+80104dce:	0f 88 d1 00 00 00    	js     80104ea5 <sys_open+0xf5>
+80104dd4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+80104dd7:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104ddb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+80104de2:	e8 99 f7 ff ff       	call   80104580 <argint>
+80104de7:	85 c0                	test   %eax,%eax
+80104de9:	0f 88 b6 00 00 00    	js     80104ea5 <sys_open+0xf5>
+    return -1;
+
+  begin_op();
+80104def:	e8 2c dd ff ff       	call   80102b20 <begin_op>
+
+  if(omode & O_CREATE){
+80104df4:	f6 45 e5 02          	testb  $0x2,-0x1b(%ebp)
+80104df8:	0f 85 82 00 00 00    	jne    80104e80 <sys_open+0xd0>
+    if(ip == 0){
+      end_op();
+      return -1;
+    }
+  } else {
+    if((ip = namei(path)) == 0){
+80104dfe:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104e01:	89 04 24             	mov    %eax,(%esp)
+80104e04:	e8 07 d1 ff ff       	call   80101f10 <namei>
+80104e09:	85 c0                	test   %eax,%eax
+80104e0b:	89 c6                	mov    %eax,%esi
+80104e0d:	0f 84 8d 00 00 00    	je     80104ea0 <sys_open+0xf0>
+      end_op();
+      return -1;
+    }
+    ilock(ip);
+80104e13:	89 04 24             	mov    %eax,(%esp)
+80104e16:	e8 a5 c8 ff ff       	call   801016c0 <ilock>
+    if(ip->type == T_DIR && omode != O_RDONLY){
+80104e1b:	66 83 7e 50 01       	cmpw   $0x1,0x50(%esi)
+80104e20:	0f 84 92 00 00 00    	je     80104eb8 <sys_open+0x108>
+      end_op();
+      return -1;
+    }
+  }
+
+  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
+80104e26:	e8 45 bf ff ff       	call   80100d70 <filealloc>
+80104e2b:	85 c0                	test   %eax,%eax
+80104e2d:	89 c3                	mov    %eax,%ebx
+80104e2f:	0f 84 93 00 00 00    	je     80104ec8 <sys_open+0x118>
+80104e35:	e8 86 f8 ff ff       	call   801046c0 <fdalloc>
+80104e3a:	85 c0                	test   %eax,%eax
+80104e3c:	89 c7                	mov    %eax,%edi
+80104e3e:	0f 88 94 00 00 00    	js     80104ed8 <sys_open+0x128>
+      fileclose(f);
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+  iunlock(ip);
+80104e44:	89 34 24             	mov    %esi,(%esp)
+80104e47:	e8 54 c9 ff ff       	call   801017a0 <iunlock>
+  end_op();
+80104e4c:	e8 3f dd ff ff       	call   80102b90 <end_op>
+
+  f->type = FD_INODE;
+80104e51:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
+  f->ip = ip;
+  f->off = 0;
+  f->readable = !(omode & O_WRONLY);
+80104e57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  f->ip = ip;
+80104e5a:	89 73 10             	mov    %esi,0x10(%ebx)
+  f->off = 0;
+80104e5d:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
+  f->readable = !(omode & O_WRONLY);
+80104e64:	89 c2                	mov    %eax,%edx
+80104e66:	83 e2 01             	and    $0x1,%edx
+80104e69:	83 f2 01             	xor    $0x1,%edx
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+80104e6c:	a8 03                	test   $0x3,%al
+  f->readable = !(omode & O_WRONLY);
+80104e6e:	88 53 08             	mov    %dl,0x8(%ebx)
+  return fd;
+80104e71:	89 f8                	mov    %edi,%eax
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+80104e73:	0f 95 43 09          	setne  0x9(%ebx)
+}
+80104e77:	83 c4 2c             	add    $0x2c,%esp
+80104e7a:	5b                   	pop    %ebx
+80104e7b:	5e                   	pop    %esi
+80104e7c:	5f                   	pop    %edi
+80104e7d:	5d                   	pop    %ebp
+80104e7e:	c3                   	ret    
+80104e7f:	90                   	nop
+    ip = create(path, T_FILE, 0, 0);
+80104e80:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104e83:	31 c9                	xor    %ecx,%ecx
+80104e85:	ba 02 00 00 00       	mov    $0x2,%edx
+80104e8a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80104e91:	e8 6a f8 ff ff       	call   80104700 <create>
+    if(ip == 0){
+80104e96:	85 c0                	test   %eax,%eax
+    ip = create(path, T_FILE, 0, 0);
+80104e98:	89 c6                	mov    %eax,%esi
+    if(ip == 0){
+80104e9a:	75 8a                	jne    80104e26 <sys_open+0x76>
+80104e9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    end_op();
+80104ea0:	e8 eb dc ff ff       	call   80102b90 <end_op>
+}
+80104ea5:	83 c4 2c             	add    $0x2c,%esp
+    return -1;
+80104ea8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104ead:	5b                   	pop    %ebx
+80104eae:	5e                   	pop    %esi
+80104eaf:	5f                   	pop    %edi
+80104eb0:	5d                   	pop    %ebp
+80104eb1:	c3                   	ret    
+80104eb2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(ip->type == T_DIR && omode != O_RDONLY){
+80104eb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80104ebb:	85 c0                	test   %eax,%eax
+80104ebd:	0f 84 63 ff ff ff    	je     80104e26 <sys_open+0x76>
+80104ec3:	90                   	nop
+80104ec4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    iunlockput(ip);
+80104ec8:	89 34 24             	mov    %esi,(%esp)
+80104ecb:	e8 50 ca ff ff       	call   80101920 <iunlockput>
+80104ed0:	eb ce                	jmp    80104ea0 <sys_open+0xf0>
+80104ed2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      fileclose(f);
+80104ed8:	89 1c 24             	mov    %ebx,(%esp)
+80104edb:	e8 50 bf ff ff       	call   80100e30 <fileclose>
+80104ee0:	eb e6                	jmp    80104ec8 <sys_open+0x118>
+80104ee2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104ee9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80104ef0 <sys_mkdir>:
+
+int
+sys_mkdir(void)
+{
+80104ef0:	55                   	push   %ebp
+80104ef1:	89 e5                	mov    %esp,%ebp
+80104ef3:	83 ec 28             	sub    $0x28,%esp
+  char *path;
+  struct inode *ip;
+
+  begin_op();
+80104ef6:	e8 25 dc ff ff       	call   80102b20 <begin_op>
+  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
+80104efb:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80104efe:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104f02:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80104f09:	e8 02 f7 ff ff       	call   80104610 <argstr>
+80104f0e:	85 c0                	test   %eax,%eax
+80104f10:	78 2e                	js     80104f40 <sys_mkdir+0x50>
+80104f12:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104f15:	31 c9                	xor    %ecx,%ecx
+80104f17:	ba 01 00 00 00       	mov    $0x1,%edx
+80104f1c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80104f23:	e8 d8 f7 ff ff       	call   80104700 <create>
+80104f28:	85 c0                	test   %eax,%eax
+80104f2a:	74 14                	je     80104f40 <sys_mkdir+0x50>
+    end_op();
+    return -1;
+  }
+  iunlockput(ip);
+80104f2c:	89 04 24             	mov    %eax,(%esp)
+80104f2f:	e8 ec c9 ff ff       	call   80101920 <iunlockput>
+  end_op();
+80104f34:	e8 57 dc ff ff       	call   80102b90 <end_op>
+  return 0;
+80104f39:	31 c0                	xor    %eax,%eax
+}
+80104f3b:	c9                   	leave  
+80104f3c:	c3                   	ret    
+80104f3d:	8d 76 00             	lea    0x0(%esi),%esi
+    end_op();
+80104f40:	e8 4b dc ff ff       	call   80102b90 <end_op>
+    return -1;
+80104f45:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104f4a:	c9                   	leave  
+80104f4b:	c3                   	ret    
+80104f4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80104f50 <sys_mknod>:
+
+int
+sys_mknod(void)
+{
+80104f50:	55                   	push   %ebp
+80104f51:	89 e5                	mov    %esp,%ebp
+80104f53:	83 ec 28             	sub    $0x28,%esp
+  struct inode *ip;
+  char *path;
+  int major, minor;
+
+  begin_op();
+80104f56:	e8 c5 db ff ff       	call   80102b20 <begin_op>
+  if((argstr(0, &path)) < 0 ||
+80104f5b:	8d 45 ec             	lea    -0x14(%ebp),%eax
+80104f5e:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104f62:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80104f69:	e8 a2 f6 ff ff       	call   80104610 <argstr>
+80104f6e:	85 c0                	test   %eax,%eax
+80104f70:	78 5e                	js     80104fd0 <sys_mknod+0x80>
+     argint(1, &major) < 0 ||
+80104f72:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80104f75:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104f79:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+80104f80:	e8 fb f5 ff ff       	call   80104580 <argint>
+  if((argstr(0, &path)) < 0 ||
+80104f85:	85 c0                	test   %eax,%eax
+80104f87:	78 47                	js     80104fd0 <sys_mknod+0x80>
+     argint(2, &minor) < 0 ||
+80104f89:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80104f8c:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104f90:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+80104f97:	e8 e4 f5 ff ff       	call   80104580 <argint>
+     argint(1, &major) < 0 ||
+80104f9c:	85 c0                	test   %eax,%eax
+80104f9e:	78 30                	js     80104fd0 <sys_mknod+0x80>
+     (ip = create(path, T_DEV, major, minor)) == 0){
+80104fa0:	0f bf 45 f4          	movswl -0xc(%ebp),%eax
+     argint(2, &minor) < 0 ||
+80104fa4:	ba 03 00 00 00       	mov    $0x3,%edx
+     (ip = create(path, T_DEV, major, minor)) == 0){
+80104fa9:	0f bf 4d f0          	movswl -0x10(%ebp),%ecx
+80104fad:	89 04 24             	mov    %eax,(%esp)
+     argint(2, &minor) < 0 ||
+80104fb0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104fb3:	e8 48 f7 ff ff       	call   80104700 <create>
+80104fb8:	85 c0                	test   %eax,%eax
+80104fba:	74 14                	je     80104fd0 <sys_mknod+0x80>
+    end_op();
+    return -1;
+  }
+  iunlockput(ip);
+80104fbc:	89 04 24             	mov    %eax,(%esp)
+80104fbf:	e8 5c c9 ff ff       	call   80101920 <iunlockput>
+  end_op();
+80104fc4:	e8 c7 db ff ff       	call   80102b90 <end_op>
+  return 0;
+80104fc9:	31 c0                	xor    %eax,%eax
+}
+80104fcb:	c9                   	leave  
+80104fcc:	c3                   	ret    
+80104fcd:	8d 76 00             	lea    0x0(%esi),%esi
+    end_op();
+80104fd0:	e8 bb db ff ff       	call   80102b90 <end_op>
+    return -1;
+80104fd5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104fda:	c9                   	leave  
+80104fdb:	c3                   	ret    
+80104fdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80104fe0 <sys_chdir>:
+
+int
+sys_chdir(void)
+{
+80104fe0:	55                   	push   %ebp
+80104fe1:	89 e5                	mov    %esp,%ebp
+80104fe3:	56                   	push   %esi
+80104fe4:	53                   	push   %ebx
+80104fe5:	83 ec 20             	sub    $0x20,%esp
+  char *path;
+  struct inode *ip;
+  struct proc *curproc = myproc();
+80104fe8:	e8 c3 e6 ff ff       	call   801036b0 <myproc>
+80104fed:	89 c6                	mov    %eax,%esi
+  
+  begin_op();
+80104fef:	e8 2c db ff ff       	call   80102b20 <begin_op>
+  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
+80104ff4:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80104ff7:	89 44 24 04          	mov    %eax,0x4(%esp)
+80104ffb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80105002:	e8 09 f6 ff ff       	call   80104610 <argstr>
+80105007:	85 c0                	test   %eax,%eax
+80105009:	78 4a                	js     80105055 <sys_chdir+0x75>
+8010500b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010500e:	89 04 24             	mov    %eax,(%esp)
+80105011:	e8 fa ce ff ff       	call   80101f10 <namei>
+80105016:	85 c0                	test   %eax,%eax
+80105018:	89 c3                	mov    %eax,%ebx
+8010501a:	74 39                	je     80105055 <sys_chdir+0x75>
+    end_op();
+    return -1;
+  }
+  ilock(ip);
+8010501c:	89 04 24             	mov    %eax,(%esp)
+8010501f:	e8 9c c6 ff ff       	call   801016c0 <ilock>
+  if(ip->type != T_DIR){
+80105024:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
+    iunlockput(ip);
+80105029:	89 1c 24             	mov    %ebx,(%esp)
+  if(ip->type != T_DIR){
+8010502c:	75 22                	jne    80105050 <sys_chdir+0x70>
+    end_op();
+    return -1;
+  }
+  iunlock(ip);
+8010502e:	e8 6d c7 ff ff       	call   801017a0 <iunlock>
+  iput(curproc->cwd);
+80105033:	8b 46 68             	mov    0x68(%esi),%eax
+80105036:	89 04 24             	mov    %eax,(%esp)
+80105039:	e8 a2 c7 ff ff       	call   801017e0 <iput>
+  end_op();
+8010503e:	e8 4d db ff ff       	call   80102b90 <end_op>
+  curproc->cwd = ip;
+  return 0;
+80105043:	31 c0                	xor    %eax,%eax
+  curproc->cwd = ip;
+80105045:	89 5e 68             	mov    %ebx,0x68(%esi)
+}
+80105048:	83 c4 20             	add    $0x20,%esp
+8010504b:	5b                   	pop    %ebx
+8010504c:	5e                   	pop    %esi
+8010504d:	5d                   	pop    %ebp
+8010504e:	c3                   	ret    
+8010504f:	90                   	nop
+    iunlockput(ip);
+80105050:	e8 cb c8 ff ff       	call   80101920 <iunlockput>
+    end_op();
+80105055:	e8 36 db ff ff       	call   80102b90 <end_op>
+}
+8010505a:	83 c4 20             	add    $0x20,%esp
+    return -1;
+8010505d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105062:	5b                   	pop    %ebx
+80105063:	5e                   	pop    %esi
+80105064:	5d                   	pop    %ebp
+80105065:	c3                   	ret    
+80105066:	8d 76 00             	lea    0x0(%esi),%esi
+80105069:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80105070 <sys_exec>:
+
+int
+sys_exec(void)
+{
+80105070:	55                   	push   %ebp
+80105071:	89 e5                	mov    %esp,%ebp
+80105073:	57                   	push   %edi
+80105074:	56                   	push   %esi
+80105075:	53                   	push   %ebx
+80105076:	81 ec ac 00 00 00    	sub    $0xac,%esp
+  char *path, *argv[MAXARG];
+  int i;
+  uint uargv, uarg;
+
+  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
+8010507c:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
+80105082:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105086:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+8010508d:	e8 7e f5 ff ff       	call   80104610 <argstr>
+80105092:	85 c0                	test   %eax,%eax
+80105094:	0f 88 84 00 00 00    	js     8010511e <sys_exec+0xae>
+8010509a:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
+801050a0:	89 44 24 04          	mov    %eax,0x4(%esp)
+801050a4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+801050ab:	e8 d0 f4 ff ff       	call   80104580 <argint>
+801050b0:	85 c0                	test   %eax,%eax
+801050b2:	78 6a                	js     8010511e <sys_exec+0xae>
+    return -1;
+  }
+  memset(argv, 0, sizeof(argv));
+801050b4:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
+  for(i=0;; i++){
+801050ba:	31 db                	xor    %ebx,%ebx
+  memset(argv, 0, sizeof(argv));
+801050bc:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
+801050c3:	00 
+801050c4:	8d b5 68 ff ff ff    	lea    -0x98(%ebp),%esi
+801050ca:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+801050d1:	00 
+801050d2:	8d bd 64 ff ff ff    	lea    -0x9c(%ebp),%edi
+801050d8:	89 04 24             	mov    %eax,(%esp)
+801050db:	e8 b0 f1 ff ff       	call   80104290 <memset>
+    if(i >= NELEM(argv))
+      return -1;
+    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
+801050e0:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
+801050e6:	89 7c 24 04          	mov    %edi,0x4(%esp)
+801050ea:	8d 04 98             	lea    (%eax,%ebx,4),%eax
+801050ed:	89 04 24             	mov    %eax,(%esp)
+801050f0:	e8 eb f3 ff ff       	call   801044e0 <fetchint>
+801050f5:	85 c0                	test   %eax,%eax
+801050f7:	78 25                	js     8010511e <sys_exec+0xae>
+      return -1;
+    if(uarg == 0){
+801050f9:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
+801050ff:	85 c0                	test   %eax,%eax
+80105101:	74 2d                	je     80105130 <sys_exec+0xc0>
+      argv[i] = 0;
+      break;
+    }
+    if(fetchstr(uarg, &argv[i]) < 0)
+80105103:	89 74 24 04          	mov    %esi,0x4(%esp)
+80105107:	89 04 24             	mov    %eax,(%esp)
+8010510a:	e8 11 f4 ff ff       	call   80104520 <fetchstr>
+8010510f:	85 c0                	test   %eax,%eax
+80105111:	78 0b                	js     8010511e <sys_exec+0xae>
+  for(i=0;; i++){
+80105113:	83 c3 01             	add    $0x1,%ebx
+80105116:	83 c6 04             	add    $0x4,%esi
+    if(i >= NELEM(argv))
+80105119:	83 fb 20             	cmp    $0x20,%ebx
+8010511c:	75 c2                	jne    801050e0 <sys_exec+0x70>
+      return -1;
+  }
+  return exec(path, argv);
+}
+8010511e:	81 c4 ac 00 00 00    	add    $0xac,%esp
+    return -1;
+80105124:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105129:	5b                   	pop    %ebx
+8010512a:	5e                   	pop    %esi
+8010512b:	5f                   	pop    %edi
+8010512c:	5d                   	pop    %ebp
+8010512d:	c3                   	ret    
+8010512e:	66 90                	xchg   %ax,%ax
+  return exec(path, argv);
+80105130:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
+80105136:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010513a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
+      argv[i] = 0;
+80105140:	c7 84 9d 68 ff ff ff 	movl   $0x0,-0x98(%ebp,%ebx,4)
+80105147:	00 00 00 00 
+  return exec(path, argv);
+8010514b:	89 04 24             	mov    %eax,(%esp)
+8010514e:	e8 4d b8 ff ff       	call   801009a0 <exec>
+}
+80105153:	81 c4 ac 00 00 00    	add    $0xac,%esp
+80105159:	5b                   	pop    %ebx
+8010515a:	5e                   	pop    %esi
+8010515b:	5f                   	pop    %edi
+8010515c:	5d                   	pop    %ebp
+8010515d:	c3                   	ret    
+8010515e:	66 90                	xchg   %ax,%ax
+
+80105160 <sys_pipe>:
+
+int
+sys_pipe(void)
+{
+80105160:	55                   	push   %ebp
+80105161:	89 e5                	mov    %esp,%ebp
+80105163:	53                   	push   %ebx
+80105164:	83 ec 24             	sub    $0x24,%esp
+  int *fd;
+  struct file *rf, *wf;
+  int fd0, fd1;
+
+  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
+80105167:	8d 45 ec             	lea    -0x14(%ebp),%eax
+8010516a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
+80105171:	00 
+80105172:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105176:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+8010517d:	e8 2e f4 ff ff       	call   801045b0 <argptr>
+80105182:	85 c0                	test   %eax,%eax
+80105184:	78 6d                	js     801051f3 <sys_pipe+0x93>
+    return -1;
+  if(pipealloc(&rf, &wf) < 0)
+80105186:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80105189:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010518d:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80105190:	89 04 24             	mov    %eax,(%esp)
+80105193:	e8 e8 df ff ff       	call   80103180 <pipealloc>
+80105198:	85 c0                	test   %eax,%eax
+8010519a:	78 57                	js     801051f3 <sys_pipe+0x93>
+    return -1;
+  fd0 = -1;
+  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
+8010519c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010519f:	e8 1c f5 ff ff       	call   801046c0 <fdalloc>
+801051a4:	85 c0                	test   %eax,%eax
+801051a6:	89 c3                	mov    %eax,%ebx
+801051a8:	78 33                	js     801051dd <sys_pipe+0x7d>
+801051aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801051ad:	e8 0e f5 ff ff       	call   801046c0 <fdalloc>
+801051b2:	85 c0                	test   %eax,%eax
+801051b4:	78 1a                	js     801051d0 <sys_pipe+0x70>
+      myproc()->ofile[fd0] = 0;
+    fileclose(rf);
+    fileclose(wf);
+    return -1;
+  }
+  fd[0] = fd0;
+801051b6:	8b 55 ec             	mov    -0x14(%ebp),%edx
+801051b9:	89 1a                	mov    %ebx,(%edx)
+  fd[1] = fd1;
+801051bb:	8b 55 ec             	mov    -0x14(%ebp),%edx
+801051be:	89 42 04             	mov    %eax,0x4(%edx)
+  return 0;
+}
+801051c1:	83 c4 24             	add    $0x24,%esp
+  return 0;
+801051c4:	31 c0                	xor    %eax,%eax
+}
+801051c6:	5b                   	pop    %ebx
+801051c7:	5d                   	pop    %ebp
+801051c8:	c3                   	ret    
+801051c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      myproc()->ofile[fd0] = 0;
+801051d0:	e8 db e4 ff ff       	call   801036b0 <myproc>
+801051d5:	c7 44 98 28 00 00 00 	movl   $0x0,0x28(%eax,%ebx,4)
+801051dc:	00 
+    fileclose(rf);
+801051dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801051e0:	89 04 24             	mov    %eax,(%esp)
+801051e3:	e8 48 bc ff ff       	call   80100e30 <fileclose>
+    fileclose(wf);
+801051e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801051eb:	89 04 24             	mov    %eax,(%esp)
+801051ee:	e8 3d bc ff ff       	call   80100e30 <fileclose>
+}
+801051f3:	83 c4 24             	add    $0x24,%esp
+    return -1;
+801051f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801051fb:	5b                   	pop    %ebx
+801051fc:	5d                   	pop    %ebp
+801051fd:	c3                   	ret    
+801051fe:	66 90                	xchg   %ax,%ax
+
+80105200 <sys_shm_open>:
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+
+int sys_shm_open(void) {
+80105200:	55                   	push   %ebp
+80105201:	89 e5                	mov    %esp,%ebp
+80105203:	83 ec 28             	sub    $0x28,%esp
+  int id;
+  char **pointer;
+
+  if(argint(0, &id) < 0)
+80105206:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80105209:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010520d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80105214:	e8 67 f3 ff ff       	call   80104580 <argint>
+80105219:	85 c0                	test   %eax,%eax
+8010521b:	78 33                	js     80105250 <sys_shm_open+0x50>
+    return -1;
+
+  if(argptr(1, (char **) (&pointer),4)<0)
+8010521d:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80105220:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
+80105227:	00 
+80105228:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010522c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+80105233:	e8 78 f3 ff ff       	call   801045b0 <argptr>
+80105238:	85 c0                	test   %eax,%eax
+8010523a:	78 14                	js     80105250 <sys_shm_open+0x50>
+    return -1;
+  return shm_open(id, pointer);
+8010523c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010523f:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105243:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105246:	89 04 24             	mov    %eax,(%esp)
+80105249:	e8 a2 1a 00 00       	call   80106cf0 <shm_open>
+}
+8010524e:	c9                   	leave  
+8010524f:	c3                   	ret    
+    return -1;
+80105250:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105255:	c9                   	leave  
+80105256:	c3                   	ret    
+80105257:	89 f6                	mov    %esi,%esi
+80105259:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80105260 <sys_shm_close>:
+
+int sys_shm_close(void) {
+80105260:	55                   	push   %ebp
+80105261:	89 e5                	mov    %esp,%ebp
+80105263:	83 ec 28             	sub    $0x28,%esp
+  int id;
+
+  if(argint(0, &id) < 0)
+80105266:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80105269:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010526d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80105274:	e8 07 f3 ff ff       	call   80104580 <argint>
+80105279:	85 c0                	test   %eax,%eax
+8010527b:	78 13                	js     80105290 <sys_shm_close+0x30>
+    return -1;
+
+  
+  return shm_close(id);
+8010527d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105280:	89 04 24             	mov    %eax,(%esp)
+80105283:	e8 78 1a 00 00       	call   80106d00 <shm_close>
+}
+80105288:	c9                   	leave  
+80105289:	c3                   	ret    
+8010528a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    return -1;
+80105290:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105295:	c9                   	leave  
+80105296:	c3                   	ret    
+80105297:	89 f6                	mov    %esi,%esi
+80105299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801052a0 <sys_fork>:
+
+int
+sys_fork(void)
+{
+801052a0:	55                   	push   %ebp
+801052a1:	89 e5                	mov    %esp,%ebp
+  return fork();
+}
+801052a3:	5d                   	pop    %ebp
+  return fork();
+801052a4:	e9 b7 e5 ff ff       	jmp    80103860 <fork>
+801052a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+801052b0 <sys_exit>:
+
+int
+sys_exit(void)
+{
+801052b0:	55                   	push   %ebp
+801052b1:	89 e5                	mov    %esp,%ebp
+801052b3:	83 ec 08             	sub    $0x8,%esp
+  exit();
+801052b6:	e8 f5 e7 ff ff       	call   80103ab0 <exit>
+  return 0;  // not reached
+}
+801052bb:	31 c0                	xor    %eax,%eax
+801052bd:	c9                   	leave  
+801052be:	c3                   	ret    
+801052bf:	90                   	nop
+
+801052c0 <sys_wait>:
+
+int
+sys_wait(void)
+{
+801052c0:	55                   	push   %ebp
+801052c1:	89 e5                	mov    %esp,%ebp
+  return wait();
+}
+801052c3:	5d                   	pop    %ebp
+  return wait();
+801052c4:	e9 f7 e9 ff ff       	jmp    80103cc0 <wait>
+801052c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+801052d0 <sys_kill>:
+
+int
+sys_kill(void)
+{
+801052d0:	55                   	push   %ebp
+801052d1:	89 e5                	mov    %esp,%ebp
+801052d3:	83 ec 28             	sub    $0x28,%esp
+  int pid;
+
+  if(argint(0, &pid) < 0)
+801052d6:	8d 45 f4             	lea    -0xc(%ebp),%eax
+801052d9:	89 44 24 04          	mov    %eax,0x4(%esp)
+801052dd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+801052e4:	e8 97 f2 ff ff       	call   80104580 <argint>
+801052e9:	85 c0                	test   %eax,%eax
+801052eb:	78 13                	js     80105300 <sys_kill+0x30>
+    return -1;
+  return kill(pid);
+801052ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801052f0:	89 04 24             	mov    %eax,(%esp)
+801052f3:	e8 08 eb ff ff       	call   80103e00 <kill>
+}
+801052f8:	c9                   	leave  
+801052f9:	c3                   	ret    
+801052fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    return -1;
+80105300:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105305:	c9                   	leave  
+80105306:	c3                   	ret    
+80105307:	89 f6                	mov    %esi,%esi
+80105309:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80105310 <sys_getpid>:
+
+int
+sys_getpid(void)
+{
+80105310:	55                   	push   %ebp
+80105311:	89 e5                	mov    %esp,%ebp
+80105313:	83 ec 08             	sub    $0x8,%esp
+  return myproc()->pid;
+80105316:	e8 95 e3 ff ff       	call   801036b0 <myproc>
+8010531b:	8b 40 10             	mov    0x10(%eax),%eax
+}
+8010531e:	c9                   	leave  
+8010531f:	c3                   	ret    
+
+80105320 <sys_sbrk>:
+
+int
+sys_sbrk(void)
+{
+80105320:	55                   	push   %ebp
+80105321:	89 e5                	mov    %esp,%ebp
+80105323:	53                   	push   %ebx
+80105324:	83 ec 24             	sub    $0x24,%esp
+  int addr;
+  int n;
+
+  if(argint(0, &n) < 0)
+80105327:	8d 45 f4             	lea    -0xc(%ebp),%eax
+8010532a:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010532e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80105335:	e8 46 f2 ff ff       	call   80104580 <argint>
+8010533a:	85 c0                	test   %eax,%eax
+8010533c:	78 22                	js     80105360 <sys_sbrk+0x40>
+    return -1;
+  addr = myproc()->sz;
+8010533e:	e8 6d e3 ff ff       	call   801036b0 <myproc>
+  if(growproc(n) < 0)
+80105343:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  addr = myproc()->sz;
+80105346:	8b 18                	mov    (%eax),%ebx
+  if(growproc(n) < 0)
+80105348:	89 14 24             	mov    %edx,(%esp)
+8010534b:	e8 a0 e4 ff ff       	call   801037f0 <growproc>
+80105350:	85 c0                	test   %eax,%eax
+80105352:	78 0c                	js     80105360 <sys_sbrk+0x40>
+    return -1;
+  return addr;
+80105354:	89 d8                	mov    %ebx,%eax
+}
+80105356:	83 c4 24             	add    $0x24,%esp
+80105359:	5b                   	pop    %ebx
+8010535a:	5d                   	pop    %ebp
+8010535b:	c3                   	ret    
+8010535c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+80105360:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105365:	eb ef                	jmp    80105356 <sys_sbrk+0x36>
+80105367:	89 f6                	mov    %esi,%esi
+80105369:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80105370 <sys_sleep>:
+
+int
+sys_sleep(void)
+{
+80105370:	55                   	push   %ebp
+80105371:	89 e5                	mov    %esp,%ebp
+80105373:	53                   	push   %ebx
+80105374:	83 ec 24             	sub    $0x24,%esp
+  int n;
+  uint ticks0;
+
+  if(argint(0, &n) < 0)
+80105377:	8d 45 f4             	lea    -0xc(%ebp),%eax
+8010537a:	89 44 24 04          	mov    %eax,0x4(%esp)
+8010537e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+80105385:	e8 f6 f1 ff ff       	call   80104580 <argint>
+8010538a:	85 c0                	test   %eax,%eax
+8010538c:	78 7e                	js     8010540c <sys_sleep+0x9c>
+    return -1;
+  acquire(&tickslock);
+8010538e:	c7 04 24 60 4c 11 80 	movl   $0x80114c60,(%esp)
+80105395:	e8 b6 ed ff ff       	call   80104150 <acquire>
+  ticks0 = ticks;
+  while(ticks - ticks0 < n){
+8010539a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  ticks0 = ticks;
+8010539d:	8b 1d a0 54 11 80    	mov    0x801154a0,%ebx
+  while(ticks - ticks0 < n){
+801053a3:	85 d2                	test   %edx,%edx
+801053a5:	75 29                	jne    801053d0 <sys_sleep+0x60>
+801053a7:	eb 4f                	jmp    801053f8 <sys_sleep+0x88>
+801053a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    if(myproc()->killed){
+      release(&tickslock);
+      return -1;
+    }
+    sleep(&ticks, &tickslock);
+801053b0:	c7 44 24 04 60 4c 11 	movl   $0x80114c60,0x4(%esp)
+801053b7:	80 
+801053b8:	c7 04 24 a0 54 11 80 	movl   $0x801154a0,(%esp)
+801053bf:	e8 4c e8 ff ff       	call   80103c10 <sleep>
+  while(ticks - ticks0 < n){
+801053c4:	a1 a0 54 11 80       	mov    0x801154a0,%eax
+801053c9:	29 d8                	sub    %ebx,%eax
+801053cb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+801053ce:	73 28                	jae    801053f8 <sys_sleep+0x88>
+    if(myproc()->killed){
+801053d0:	e8 db e2 ff ff       	call   801036b0 <myproc>
+801053d5:	8b 40 24             	mov    0x24(%eax),%eax
+801053d8:	85 c0                	test   %eax,%eax
+801053da:	74 d4                	je     801053b0 <sys_sleep+0x40>
+      release(&tickslock);
+801053dc:	c7 04 24 60 4c 11 80 	movl   $0x80114c60,(%esp)
+801053e3:	e8 58 ee ff ff       	call   80104240 <release>
+      return -1;
+801053e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  }
+  release(&tickslock);
+  return 0;
+}
+801053ed:	83 c4 24             	add    $0x24,%esp
+801053f0:	5b                   	pop    %ebx
+801053f1:	5d                   	pop    %ebp
+801053f2:	c3                   	ret    
+801053f3:	90                   	nop
+801053f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  release(&tickslock);
+801053f8:	c7 04 24 60 4c 11 80 	movl   $0x80114c60,(%esp)
+801053ff:	e8 3c ee ff ff       	call   80104240 <release>
+}
+80105404:	83 c4 24             	add    $0x24,%esp
+  return 0;
+80105407:	31 c0                	xor    %eax,%eax
+}
+80105409:	5b                   	pop    %ebx
+8010540a:	5d                   	pop    %ebp
+8010540b:	c3                   	ret    
+    return -1;
+8010540c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105411:	eb da                	jmp    801053ed <sys_sleep+0x7d>
+80105413:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80105419:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80105420 <sys_uptime>:
+
+// return how many clock tick interrupts have occurred
+// since start.
+int
+sys_uptime(void)
+{
+80105420:	55                   	push   %ebp
+80105421:	89 e5                	mov    %esp,%ebp
+80105423:	53                   	push   %ebx
+80105424:	83 ec 14             	sub    $0x14,%esp
+  uint xticks;
+
+  acquire(&tickslock);
+80105427:	c7 04 24 60 4c 11 80 	movl   $0x80114c60,(%esp)
+8010542e:	e8 1d ed ff ff       	call   80104150 <acquire>
+  xticks = ticks;
+80105433:	8b 1d a0 54 11 80    	mov    0x801154a0,%ebx
+  release(&tickslock);
+80105439:	c7 04 24 60 4c 11 80 	movl   $0x80114c60,(%esp)
+80105440:	e8 fb ed ff ff       	call   80104240 <release>
+  return xticks;
+}
+80105445:	83 c4 14             	add    $0x14,%esp
+80105448:	89 d8                	mov    %ebx,%eax
+8010544a:	5b                   	pop    %ebx
+8010544b:	5d                   	pop    %ebp
+8010544c:	c3                   	ret    
+
+8010544d <alltraps>:
+
+  # vectors.S sends all traps here.
+.globl alltraps
+alltraps:
+  # Build trap frame.
+  pushl %ds
+8010544d:	1e                   	push   %ds
+  pushl %es
+8010544e:	06                   	push   %es
+  pushl %fs
+8010544f:	0f a0                	push   %fs
+  pushl %gs
+80105451:	0f a8                	push   %gs
+  pushal
+80105453:	60                   	pusha  
+  
+  # Set up data segments.
+  movw $(SEG_KDATA<<3), %ax
+80105454:	66 b8 10 00          	mov    $0x10,%ax
+  movw %ax, %ds
+80105458:	8e d8                	mov    %eax,%ds
+  movw %ax, %es
+8010545a:	8e c0                	mov    %eax,%es
+
+  # Call trap(tf), where tf=%esp
+  pushl %esp
+8010545c:	54                   	push   %esp
+  call trap
+8010545d:	e8 de 00 00 00       	call   80105540 <trap>
+  addl $4, %esp
+80105462:	83 c4 04             	add    $0x4,%esp
+
+80105465 <trapret>:
+
+  # Return falls through to trapret...
+.globl trapret
+trapret:
+  popal
+80105465:	61                   	popa   
+  popl %gs
+80105466:	0f a9                	pop    %gs
+  popl %fs
+80105468:	0f a1                	pop    %fs
+  popl %es
+8010546a:	07                   	pop    %es
+  popl %ds
+8010546b:	1f                   	pop    %ds
+  addl $0x8, %esp  # trapno and errcode
+8010546c:	83 c4 08             	add    $0x8,%esp
+  iret
+8010546f:	cf                   	iret   
+
+80105470 <tvinit>:
+void
+tvinit(void)
+{
+  int i;
+
+  for(i = 0; i < 256; i++)
+80105470:	31 c0                	xor    %eax,%eax
+80105472:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
+80105478:	8b 14 85 08 a0 10 80 	mov    -0x7fef5ff8(,%eax,4),%edx
+8010547f:	b9 08 00 00 00       	mov    $0x8,%ecx
+80105484:	66 89 0c c5 a2 4c 11 	mov    %cx,-0x7feeb35e(,%eax,8)
+8010548b:	80 
+8010548c:	c6 04 c5 a4 4c 11 80 	movb   $0x0,-0x7feeb35c(,%eax,8)
+80105493:	00 
+80105494:	c6 04 c5 a5 4c 11 80 	movb   $0x8e,-0x7feeb35b(,%eax,8)
+8010549b:	8e 
+8010549c:	66 89 14 c5 a0 4c 11 	mov    %dx,-0x7feeb360(,%eax,8)
+801054a3:	80 
+801054a4:	c1 ea 10             	shr    $0x10,%edx
+801054a7:	66 89 14 c5 a6 4c 11 	mov    %dx,-0x7feeb35a(,%eax,8)
+801054ae:	80 
+  for(i = 0; i < 256; i++)
+801054af:	83 c0 01             	add    $0x1,%eax
+801054b2:	3d 00 01 00 00       	cmp    $0x100,%eax
+801054b7:	75 bf                	jne    80105478 <tvinit+0x8>
+{
+801054b9:	55                   	push   %ebp
+  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+801054ba:	ba 08 00 00 00       	mov    $0x8,%edx
+{
+801054bf:	89 e5                	mov    %esp,%ebp
+801054c1:	83 ec 18             	sub    $0x18,%esp
+  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+801054c4:	a1 08 a1 10 80       	mov    0x8010a108,%eax
+
+  initlock(&tickslock, "time");
+801054c9:	c7 44 24 04 c1 74 10 	movl   $0x801074c1,0x4(%esp)
+801054d0:	80 
+801054d1:	c7 04 24 60 4c 11 80 	movl   $0x80114c60,(%esp)
+  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+801054d8:	66 89 15 a2 4e 11 80 	mov    %dx,0x80114ea2
+801054df:	66 a3 a0 4e 11 80    	mov    %ax,0x80114ea0
+801054e5:	c1 e8 10             	shr    $0x10,%eax
+801054e8:	c6 05 a4 4e 11 80 00 	movb   $0x0,0x80114ea4
+801054ef:	c6 05 a5 4e 11 80 ef 	movb   $0xef,0x80114ea5
+801054f6:	66 a3 a6 4e 11 80    	mov    %ax,0x80114ea6
+  initlock(&tickslock, "time");
+801054fc:	e8 5f eb ff ff       	call   80104060 <initlock>
+}
+80105501:	c9                   	leave  
+80105502:	c3                   	ret    
+80105503:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80105509:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80105510 <idtinit>:
+
+void
+idtinit(void)
+{
+80105510:	55                   	push   %ebp
+  pd[0] = size-1;
+80105511:	b8 ff 07 00 00       	mov    $0x7ff,%eax
+80105516:	89 e5                	mov    %esp,%ebp
+80105518:	83 ec 10             	sub    $0x10,%esp
+8010551b:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+  pd[1] = (uint)p;
+8010551f:	b8 a0 4c 11 80       	mov    $0x80114ca0,%eax
+80105524:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+  pd[2] = (uint)p >> 16;
+80105528:	c1 e8 10             	shr    $0x10,%eax
+8010552b:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
+  asm volatile("lidt (%0)" : : "r" (pd));
+8010552f:	8d 45 fa             	lea    -0x6(%ebp),%eax
+80105532:	0f 01 18             	lidtl  (%eax)
+  lidt(idt, sizeof(idt));
+}
+80105535:	c9                   	leave  
+80105536:	c3                   	ret    
+80105537:	89 f6                	mov    %esi,%esi
+80105539:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80105540 <trap>:
+
+//PAGEBREAK: 41
+void
+trap(struct trapframe *tf)
+{
+80105540:	55                   	push   %ebp
+80105541:	89 e5                	mov    %esp,%ebp
+80105543:	57                   	push   %edi
+80105544:	56                   	push   %esi
+80105545:	53                   	push   %ebx
+80105546:	83 ec 3c             	sub    $0x3c,%esp
+80105549:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(tf->trapno == T_SYSCALL){
+8010554c:	8b 43 30             	mov    0x30(%ebx),%eax
+8010554f:	83 f8 40             	cmp    $0x40,%eax
+80105552:	0f 84 a0 01 00 00    	je     801056f8 <trap+0x1b8>
+    if(myproc()->killed)
+      exit();
+    return;
+  }
+
+  switch(tf->trapno){
+80105558:	83 e8 20             	sub    $0x20,%eax
+8010555b:	83 f8 1f             	cmp    $0x1f,%eax
+8010555e:	77 08                	ja     80105568 <trap+0x28>
+80105560:	ff 24 85 68 75 10 80 	jmp    *-0x7fef8a98(,%eax,4)
+80105567:	90                   	nop
+    lapiceoi();
+    break;
+
+  //PAGEBREAK: 13
+  default:
+    if(myproc() == 0 || (tf->cs&3) == 0){
+80105568:	e8 43 e1 ff ff       	call   801036b0 <myproc>
+8010556d:	85 c0                	test   %eax,%eax
+8010556f:	90                   	nop
+80105570:	0f 84 fa 01 00 00    	je     80105770 <trap+0x230>
+80105576:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
+8010557a:	0f 84 f0 01 00 00    	je     80105770 <trap+0x230>
+
+static inline uint
+rcr2(void)
+{
+  uint val;
+  asm volatile("movl %%cr2,%0" : "=r" (val));
+80105580:	0f 20 d1             	mov    %cr2,%ecx
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+              tf->trapno, cpuid(), tf->eip, rcr2());
+      panic("trap");
+    }
+    // In user space, assume process misbehaved.
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+80105583:	8b 53 38             	mov    0x38(%ebx),%edx
+80105586:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+80105589:	89 55 dc             	mov    %edx,-0x24(%ebp)
+8010558c:	e8 ff e0 ff ff       	call   80103690 <cpuid>
+80105591:	8b 73 30             	mov    0x30(%ebx),%esi
+80105594:	89 c7                	mov    %eax,%edi
+80105596:	8b 43 34             	mov    0x34(%ebx),%eax
+80105599:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            "eip 0x%x addr 0x%x--kill proc\n",
+            myproc()->pid, myproc()->name, tf->trapno,
+8010559c:	e8 0f e1 ff ff       	call   801036b0 <myproc>
+801055a1:	89 45 e0             	mov    %eax,-0x20(%ebp)
+801055a4:	e8 07 e1 ff ff       	call   801036b0 <myproc>
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+801055a9:	8b 55 dc             	mov    -0x24(%ebp),%edx
+801055ac:	89 74 24 0c          	mov    %esi,0xc(%esp)
+            myproc()->pid, myproc()->name, tf->trapno,
+801055b0:	8b 75 e0             	mov    -0x20(%ebp),%esi
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+801055b3:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+801055b6:	89 7c 24 14          	mov    %edi,0x14(%esp)
+801055ba:	89 54 24 18          	mov    %edx,0x18(%esp)
+801055be:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+            myproc()->pid, myproc()->name, tf->trapno,
+801055c1:	83 c6 6c             	add    $0x6c,%esi
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+801055c4:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
+            myproc()->pid, myproc()->name, tf->trapno,
+801055c8:	89 74 24 08          	mov    %esi,0x8(%esp)
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+801055cc:	89 54 24 10          	mov    %edx,0x10(%esp)
+801055d0:	8b 40 10             	mov    0x10(%eax),%eax
+801055d3:	c7 04 24 24 75 10 80 	movl   $0x80107524,(%esp)
+801055da:	89 44 24 04          	mov    %eax,0x4(%esp)
+801055de:	e8 6d b0 ff ff       	call   80100650 <cprintf>
+            tf->err, cpuid(), tf->eip, rcr2());
+    myproc()->killed = 1;
+801055e3:	e8 c8 e0 ff ff       	call   801036b0 <myproc>
+801055e8:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
+801055ef:	90                   	nop
+  }
+
+  // Force process exit if it has been killed and is in user space.
+  // (If it is still executing in the kernel, let it keep running
+  // until it gets to the regular system call return.)
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+801055f0:	e8 bb e0 ff ff       	call   801036b0 <myproc>
+801055f5:	85 c0                	test   %eax,%eax
+801055f7:	74 0c                	je     80105605 <trap+0xc5>
+801055f9:	e8 b2 e0 ff ff       	call   801036b0 <myproc>
+801055fe:	8b 50 24             	mov    0x24(%eax),%edx
+80105601:	85 d2                	test   %edx,%edx
+80105603:	75 4b                	jne    80105650 <trap+0x110>
+    exit();
+
+  // Force process to give up CPU on clock tick.
+  // If interrupts were on while locks held, would need to check nlock.
+  if(myproc() && myproc()->state == RUNNING &&
+80105605:	e8 a6 e0 ff ff       	call   801036b0 <myproc>
+8010560a:	85 c0                	test   %eax,%eax
+8010560c:	74 0d                	je     8010561b <trap+0xdb>
+8010560e:	66 90                	xchg   %ax,%ax
+80105610:	e8 9b e0 ff ff       	call   801036b0 <myproc>
+80105615:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
+80105619:	74 4d                	je     80105668 <trap+0x128>
+     tf->trapno == T_IRQ0+IRQ_TIMER)
+    yield();
+
+  // Check if the process has been killed since we yielded
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+8010561b:	e8 90 e0 ff ff       	call   801036b0 <myproc>
+80105620:	85 c0                	test   %eax,%eax
+80105622:	74 1d                	je     80105641 <trap+0x101>
+80105624:	e8 87 e0 ff ff       	call   801036b0 <myproc>
+80105629:	8b 40 24             	mov    0x24(%eax),%eax
+8010562c:	85 c0                	test   %eax,%eax
+8010562e:	74 11                	je     80105641 <trap+0x101>
+80105630:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
+80105634:	83 e0 03             	and    $0x3,%eax
+80105637:	66 83 f8 03          	cmp    $0x3,%ax
+8010563b:	0f 84 e8 00 00 00    	je     80105729 <trap+0x1e9>
+    exit();
+}
+80105641:	83 c4 3c             	add    $0x3c,%esp
+80105644:	5b                   	pop    %ebx
+80105645:	5e                   	pop    %esi
+80105646:	5f                   	pop    %edi
+80105647:	5d                   	pop    %ebp
+80105648:	c3                   	ret    
+80105649:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+80105650:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
+80105654:	83 e0 03             	and    $0x3,%eax
+80105657:	66 83 f8 03          	cmp    $0x3,%ax
+8010565b:	75 a8                	jne    80105605 <trap+0xc5>
+    exit();
+8010565d:	e8 4e e4 ff ff       	call   80103ab0 <exit>
+80105662:	eb a1                	jmp    80105605 <trap+0xc5>
+80105664:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  if(myproc() && myproc()->state == RUNNING &&
+80105668:	83 7b 30 20          	cmpl   $0x20,0x30(%ebx)
+8010566c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80105670:	75 a9                	jne    8010561b <trap+0xdb>
+    yield();
+80105672:	e8 59 e5 ff ff       	call   80103bd0 <yield>
+80105677:	eb a2                	jmp    8010561b <trap+0xdb>
+80105679:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    if(cpuid() == 0){
+80105680:	e8 0b e0 ff ff       	call   80103690 <cpuid>
+80105685:	85 c0                	test   %eax,%eax
+80105687:	0f 84 b3 00 00 00    	je     80105740 <trap+0x200>
+8010568d:	8d 76 00             	lea    0x0(%esi),%esi
+    lapiceoi();
+80105690:	e8 fb d0 ff ff       	call   80102790 <lapiceoi>
+    break;
+80105695:	e9 56 ff ff ff       	jmp    801055f0 <trap+0xb0>
+8010569a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    kbdintr();
+801056a0:	e8 3b cf ff ff       	call   801025e0 <kbdintr>
+    lapiceoi();
+801056a5:	e8 e6 d0 ff ff       	call   80102790 <lapiceoi>
+    break;
+801056aa:	e9 41 ff ff ff       	jmp    801055f0 <trap+0xb0>
+801056af:	90                   	nop
+    uartintr();
+801056b0:	e8 1b 02 00 00       	call   801058d0 <uartintr>
+    lapiceoi();
+801056b5:	e8 d6 d0 ff ff       	call   80102790 <lapiceoi>
+    break;
+801056ba:	e9 31 ff ff ff       	jmp    801055f0 <trap+0xb0>
+801056bf:	90                   	nop
+    cprintf("cpu%d: spurious interrupt at %x:%x\n",
+801056c0:	8b 7b 38             	mov    0x38(%ebx),%edi
+801056c3:	0f b7 73 3c          	movzwl 0x3c(%ebx),%esi
+801056c7:	e8 c4 df ff ff       	call   80103690 <cpuid>
+801056cc:	c7 04 24 cc 74 10 80 	movl   $0x801074cc,(%esp)
+801056d3:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+801056d7:	89 74 24 08          	mov    %esi,0x8(%esp)
+801056db:	89 44 24 04          	mov    %eax,0x4(%esp)
+801056df:	e8 6c af ff ff       	call   80100650 <cprintf>
+    lapiceoi();
+801056e4:	e8 a7 d0 ff ff       	call   80102790 <lapiceoi>
+    break;
+801056e9:	e9 02 ff ff ff       	jmp    801055f0 <trap+0xb0>
+801056ee:	66 90                	xchg   %ax,%ax
+    ideintr();
+801056f0:	e8 9b c9 ff ff       	call   80102090 <ideintr>
+801056f5:	eb 96                	jmp    8010568d <trap+0x14d>
+801056f7:	90                   	nop
+801056f8:	90                   	nop
+801056f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    if(myproc()->killed)
+80105700:	e8 ab df ff ff       	call   801036b0 <myproc>
+80105705:	8b 70 24             	mov    0x24(%eax),%esi
+80105708:	85 f6                	test   %esi,%esi
+8010570a:	75 2c                	jne    80105738 <trap+0x1f8>
+    myproc()->tf = tf;
+8010570c:	e8 9f df ff ff       	call   801036b0 <myproc>
+80105711:	89 58 18             	mov    %ebx,0x18(%eax)
+    syscall();
+80105714:	e8 37 ef ff ff       	call   80104650 <syscall>
+    if(myproc()->killed)
+80105719:	e8 92 df ff ff       	call   801036b0 <myproc>
+8010571e:	8b 48 24             	mov    0x24(%eax),%ecx
+80105721:	85 c9                	test   %ecx,%ecx
+80105723:	0f 84 18 ff ff ff    	je     80105641 <trap+0x101>
+}
+80105729:	83 c4 3c             	add    $0x3c,%esp
+8010572c:	5b                   	pop    %ebx
+8010572d:	5e                   	pop    %esi
+8010572e:	5f                   	pop    %edi
+8010572f:	5d                   	pop    %ebp
+      exit();
+80105730:	e9 7b e3 ff ff       	jmp    80103ab0 <exit>
+80105735:	8d 76 00             	lea    0x0(%esi),%esi
+      exit();
+80105738:	e8 73 e3 ff ff       	call   80103ab0 <exit>
+8010573d:	eb cd                	jmp    8010570c <trap+0x1cc>
+8010573f:	90                   	nop
+      acquire(&tickslock);
+80105740:	c7 04 24 60 4c 11 80 	movl   $0x80114c60,(%esp)
+80105747:	e8 04 ea ff ff       	call   80104150 <acquire>
+      wakeup(&ticks);
+8010574c:	c7 04 24 a0 54 11 80 	movl   $0x801154a0,(%esp)
+      ticks++;
+80105753:	83 05 a0 54 11 80 01 	addl   $0x1,0x801154a0
+      wakeup(&ticks);
+8010575a:	e8 41 e6 ff ff       	call   80103da0 <wakeup>
+      release(&tickslock);
+8010575f:	c7 04 24 60 4c 11 80 	movl   $0x80114c60,(%esp)
+80105766:	e8 d5 ea ff ff       	call   80104240 <release>
+8010576b:	e9 1d ff ff ff       	jmp    8010568d <trap+0x14d>
+80105770:	0f 20 d7             	mov    %cr2,%edi
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+80105773:	8b 73 38             	mov    0x38(%ebx),%esi
+80105776:	e8 15 df ff ff       	call   80103690 <cpuid>
+8010577b:	89 7c 24 10          	mov    %edi,0x10(%esp)
+8010577f:	89 74 24 0c          	mov    %esi,0xc(%esp)
+80105783:	89 44 24 08          	mov    %eax,0x8(%esp)
+80105787:	8b 43 30             	mov    0x30(%ebx),%eax
+8010578a:	c7 04 24 f0 74 10 80 	movl   $0x801074f0,(%esp)
+80105791:	89 44 24 04          	mov    %eax,0x4(%esp)
+80105795:	e8 b6 ae ff ff       	call   80100650 <cprintf>
+      panic("trap");
+8010579a:	c7 04 24 c6 74 10 80 	movl   $0x801074c6,(%esp)
+801057a1:	e8 ba ab ff ff       	call   80100360 <panic>
+801057a6:	66 90                	xchg   %ax,%ax
+801057a8:	66 90                	xchg   %ax,%ax
+801057aa:	66 90                	xchg   %ax,%ax
+801057ac:	66 90                	xchg   %ax,%ax
+801057ae:	66 90                	xchg   %ax,%ax
+
+801057b0 <uartgetc>:
+}
+
+static int
+uartgetc(void)
+{
+  if(!uart)
+801057b0:	a1 bc a5 10 80       	mov    0x8010a5bc,%eax
+{
+801057b5:	55                   	push   %ebp
+801057b6:	89 e5                	mov    %esp,%ebp
+  if(!uart)
+801057b8:	85 c0                	test   %eax,%eax
+801057ba:	74 14                	je     801057d0 <uartgetc+0x20>
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801057bc:	ba fd 03 00 00       	mov    $0x3fd,%edx
+801057c1:	ec                   	in     (%dx),%al
+    return -1;
+  if(!(inb(COM1+5) & 0x01))
+801057c2:	a8 01                	test   $0x1,%al
+801057c4:	74 0a                	je     801057d0 <uartgetc+0x20>
+801057c6:	b2 f8                	mov    $0xf8,%dl
+801057c8:	ec                   	in     (%dx),%al
+    return -1;
+  return inb(COM1+0);
+801057c9:	0f b6 c0             	movzbl %al,%eax
+}
+801057cc:	5d                   	pop    %ebp
+801057cd:	c3                   	ret    
+801057ce:	66 90                	xchg   %ax,%ax
+    return -1;
+801057d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801057d5:	5d                   	pop    %ebp
+801057d6:	c3                   	ret    
+801057d7:	89 f6                	mov    %esi,%esi
+801057d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801057e0 <uartputc>:
+  if(!uart)
+801057e0:	a1 bc a5 10 80       	mov    0x8010a5bc,%eax
+801057e5:	85 c0                	test   %eax,%eax
+801057e7:	74 3f                	je     80105828 <uartputc+0x48>
+{
+801057e9:	55                   	push   %ebp
+801057ea:	89 e5                	mov    %esp,%ebp
+801057ec:	56                   	push   %esi
+801057ed:	be fd 03 00 00       	mov    $0x3fd,%esi
+801057f2:	53                   	push   %ebx
+  if(!uart)
+801057f3:	bb 80 00 00 00       	mov    $0x80,%ebx
+{
+801057f8:	83 ec 10             	sub    $0x10,%esp
+801057fb:	eb 14                	jmp    80105811 <uartputc+0x31>
+801057fd:	8d 76 00             	lea    0x0(%esi),%esi
+    microdelay(10);
+80105800:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
+80105807:	e8 a4 cf ff ff       	call   801027b0 <microdelay>
+  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
+8010580c:	83 eb 01             	sub    $0x1,%ebx
+8010580f:	74 07                	je     80105818 <uartputc+0x38>
+80105811:	89 f2                	mov    %esi,%edx
+80105813:	ec                   	in     (%dx),%al
+80105814:	a8 20                	test   $0x20,%al
+80105816:	74 e8                	je     80105800 <uartputc+0x20>
+  outb(COM1+0, c);
+80105818:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+8010581c:	ba f8 03 00 00       	mov    $0x3f8,%edx
+80105821:	ee                   	out    %al,(%dx)
+}
+80105822:	83 c4 10             	add    $0x10,%esp
+80105825:	5b                   	pop    %ebx
+80105826:	5e                   	pop    %esi
+80105827:	5d                   	pop    %ebp
+80105828:	f3 c3                	repz ret 
+8010582a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80105830 <uartinit>:
+{
+80105830:	55                   	push   %ebp
+80105831:	31 c9                	xor    %ecx,%ecx
+80105833:	89 e5                	mov    %esp,%ebp
+80105835:	89 c8                	mov    %ecx,%eax
+80105837:	57                   	push   %edi
+80105838:	bf fa 03 00 00       	mov    $0x3fa,%edi
+8010583d:	56                   	push   %esi
+8010583e:	89 fa                	mov    %edi,%edx
+80105840:	53                   	push   %ebx
+80105841:	83 ec 1c             	sub    $0x1c,%esp
+80105844:	ee                   	out    %al,(%dx)
+80105845:	be fb 03 00 00       	mov    $0x3fb,%esi
+8010584a:	b8 80 ff ff ff       	mov    $0xffffff80,%eax
+8010584f:	89 f2                	mov    %esi,%edx
+80105851:	ee                   	out    %al,(%dx)
+80105852:	b8 0c 00 00 00       	mov    $0xc,%eax
+80105857:	b2 f8                	mov    $0xf8,%dl
+80105859:	ee                   	out    %al,(%dx)
+8010585a:	bb f9 03 00 00       	mov    $0x3f9,%ebx
+8010585f:	89 c8                	mov    %ecx,%eax
+80105861:	89 da                	mov    %ebx,%edx
+80105863:	ee                   	out    %al,(%dx)
+80105864:	b8 03 00 00 00       	mov    $0x3,%eax
+80105869:	89 f2                	mov    %esi,%edx
+8010586b:	ee                   	out    %al,(%dx)
+8010586c:	b2 fc                	mov    $0xfc,%dl
+8010586e:	89 c8                	mov    %ecx,%eax
+80105870:	ee                   	out    %al,(%dx)
+80105871:	b8 01 00 00 00       	mov    $0x1,%eax
+80105876:	89 da                	mov    %ebx,%edx
+80105878:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80105879:	b2 fd                	mov    $0xfd,%dl
+8010587b:	ec                   	in     (%dx),%al
+  if(inb(COM1+5) == 0xFF)
+8010587c:	3c ff                	cmp    $0xff,%al
+8010587e:	74 42                	je     801058c2 <uartinit+0x92>
+  uart = 1;
+80105880:	c7 05 bc a5 10 80 01 	movl   $0x1,0x8010a5bc
+80105887:	00 00 00 
+8010588a:	89 fa                	mov    %edi,%edx
+8010588c:	ec                   	in     (%dx),%al
+8010588d:	b2 f8                	mov    $0xf8,%dl
+8010588f:	ec                   	in     (%dx),%al
+  ioapicenable(IRQ_COM1, 0);
+80105890:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80105897:	00 
+  for(p="xv6...\n"; *p; p++)
+80105898:	bb e8 75 10 80       	mov    $0x801075e8,%ebx
+  ioapicenable(IRQ_COM1, 0);
+8010589d:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
+801058a4:	e8 17 ca ff ff       	call   801022c0 <ioapicenable>
+  for(p="xv6...\n"; *p; p++)
+801058a9:	b8 78 00 00 00       	mov    $0x78,%eax
+801058ae:	66 90                	xchg   %ax,%ax
+    uartputc(*p);
+801058b0:	89 04 24             	mov    %eax,(%esp)
+  for(p="xv6...\n"; *p; p++)
+801058b3:	83 c3 01             	add    $0x1,%ebx
+    uartputc(*p);
+801058b6:	e8 25 ff ff ff       	call   801057e0 <uartputc>
+  for(p="xv6...\n"; *p; p++)
+801058bb:	0f be 03             	movsbl (%ebx),%eax
+801058be:	84 c0                	test   %al,%al
+801058c0:	75 ee                	jne    801058b0 <uartinit+0x80>
+}
+801058c2:	83 c4 1c             	add    $0x1c,%esp
+801058c5:	5b                   	pop    %ebx
+801058c6:	5e                   	pop    %esi
+801058c7:	5f                   	pop    %edi
+801058c8:	5d                   	pop    %ebp
+801058c9:	c3                   	ret    
+801058ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+801058d0 <uartintr>:
+
+void
+uartintr(void)
+{
+801058d0:	55                   	push   %ebp
+801058d1:	89 e5                	mov    %esp,%ebp
+801058d3:	83 ec 18             	sub    $0x18,%esp
+  consoleintr(uartgetc);
+801058d6:	c7 04 24 b0 57 10 80 	movl   $0x801057b0,(%esp)
+801058dd:	e8 ce ae ff ff       	call   801007b0 <consoleintr>
+}
+801058e2:	c9                   	leave  
+801058e3:	c3                   	ret    
+
+801058e4 <vector0>:
+# generated by vectors.pl - do not edit
+# handlers
+.globl alltraps
+.globl vector0
+vector0:
+  pushl $0
+801058e4:	6a 00                	push   $0x0
+  pushl $0
+801058e6:	6a 00                	push   $0x0
+  jmp alltraps
+801058e8:	e9 60 fb ff ff       	jmp    8010544d <alltraps>
+
+801058ed <vector1>:
+.globl vector1
+vector1:
+  pushl $0
+801058ed:	6a 00                	push   $0x0
+  pushl $1
+801058ef:	6a 01                	push   $0x1
+  jmp alltraps
+801058f1:	e9 57 fb ff ff       	jmp    8010544d <alltraps>
+
+801058f6 <vector2>:
+.globl vector2
+vector2:
+  pushl $0
+801058f6:	6a 00                	push   $0x0
+  pushl $2
+801058f8:	6a 02                	push   $0x2
+  jmp alltraps
+801058fa:	e9 4e fb ff ff       	jmp    8010544d <alltraps>
+
+801058ff <vector3>:
+.globl vector3
+vector3:
+  pushl $0
+801058ff:	6a 00                	push   $0x0
+  pushl $3
+80105901:	6a 03                	push   $0x3
+  jmp alltraps
+80105903:	e9 45 fb ff ff       	jmp    8010544d <alltraps>
+
+80105908 <vector4>:
+.globl vector4
+vector4:
+  pushl $0
+80105908:	6a 00                	push   $0x0
+  pushl $4
+8010590a:	6a 04                	push   $0x4
+  jmp alltraps
+8010590c:	e9 3c fb ff ff       	jmp    8010544d <alltraps>
+
+80105911 <vector5>:
+.globl vector5
+vector5:
+  pushl $0
+80105911:	6a 00                	push   $0x0
+  pushl $5
+80105913:	6a 05                	push   $0x5
+  jmp alltraps
+80105915:	e9 33 fb ff ff       	jmp    8010544d <alltraps>
+
+8010591a <vector6>:
+.globl vector6
+vector6:
+  pushl $0
+8010591a:	6a 00                	push   $0x0
+  pushl $6
+8010591c:	6a 06                	push   $0x6
+  jmp alltraps
+8010591e:	e9 2a fb ff ff       	jmp    8010544d <alltraps>
+
+80105923 <vector7>:
+.globl vector7
+vector7:
+  pushl $0
+80105923:	6a 00                	push   $0x0
+  pushl $7
+80105925:	6a 07                	push   $0x7
+  jmp alltraps
+80105927:	e9 21 fb ff ff       	jmp    8010544d <alltraps>
+
+8010592c <vector8>:
+.globl vector8
+vector8:
+  pushl $8
+8010592c:	6a 08                	push   $0x8
+  jmp alltraps
+8010592e:	e9 1a fb ff ff       	jmp    8010544d <alltraps>
+
+80105933 <vector9>:
+.globl vector9
+vector9:
+  pushl $0
+80105933:	6a 00                	push   $0x0
+  pushl $9
+80105935:	6a 09                	push   $0x9
+  jmp alltraps
+80105937:	e9 11 fb ff ff       	jmp    8010544d <alltraps>
+
+8010593c <vector10>:
+.globl vector10
+vector10:
+  pushl $10
+8010593c:	6a 0a                	push   $0xa
+  jmp alltraps
+8010593e:	e9 0a fb ff ff       	jmp    8010544d <alltraps>
+
+80105943 <vector11>:
+.globl vector11
+vector11:
+  pushl $11
+80105943:	6a 0b                	push   $0xb
+  jmp alltraps
+80105945:	e9 03 fb ff ff       	jmp    8010544d <alltraps>
+
+8010594a <vector12>:
+.globl vector12
+vector12:
+  pushl $12
+8010594a:	6a 0c                	push   $0xc
+  jmp alltraps
+8010594c:	e9 fc fa ff ff       	jmp    8010544d <alltraps>
+
+80105951 <vector13>:
+.globl vector13
+vector13:
+  pushl $13
+80105951:	6a 0d                	push   $0xd
+  jmp alltraps
+80105953:	e9 f5 fa ff ff       	jmp    8010544d <alltraps>
+
+80105958 <vector14>:
+.globl vector14
+vector14:
+  pushl $14
+80105958:	6a 0e                	push   $0xe
+  jmp alltraps
+8010595a:	e9 ee fa ff ff       	jmp    8010544d <alltraps>
+
+8010595f <vector15>:
+.globl vector15
+vector15:
+  pushl $0
+8010595f:	6a 00                	push   $0x0
+  pushl $15
+80105961:	6a 0f                	push   $0xf
+  jmp alltraps
+80105963:	e9 e5 fa ff ff       	jmp    8010544d <alltraps>
+
+80105968 <vector16>:
+.globl vector16
+vector16:
+  pushl $0
+80105968:	6a 00                	push   $0x0
+  pushl $16
+8010596a:	6a 10                	push   $0x10
+  jmp alltraps
+8010596c:	e9 dc fa ff ff       	jmp    8010544d <alltraps>
+
+80105971 <vector17>:
+.globl vector17
+vector17:
+  pushl $17
+80105971:	6a 11                	push   $0x11
+  jmp alltraps
+80105973:	e9 d5 fa ff ff       	jmp    8010544d <alltraps>
+
+80105978 <vector18>:
+.globl vector18
+vector18:
+  pushl $0
+80105978:	6a 00                	push   $0x0
+  pushl $18
+8010597a:	6a 12                	push   $0x12
+  jmp alltraps
+8010597c:	e9 cc fa ff ff       	jmp    8010544d <alltraps>
+
+80105981 <vector19>:
+.globl vector19
+vector19:
+  pushl $0
+80105981:	6a 00                	push   $0x0
+  pushl $19
+80105983:	6a 13                	push   $0x13
+  jmp alltraps
+80105985:	e9 c3 fa ff ff       	jmp    8010544d <alltraps>
+
+8010598a <vector20>:
+.globl vector20
+vector20:
+  pushl $0
+8010598a:	6a 00                	push   $0x0
+  pushl $20
+8010598c:	6a 14                	push   $0x14
+  jmp alltraps
+8010598e:	e9 ba fa ff ff       	jmp    8010544d <alltraps>
+
+80105993 <vector21>:
+.globl vector21
+vector21:
+  pushl $0
+80105993:	6a 00                	push   $0x0
+  pushl $21
+80105995:	6a 15                	push   $0x15
+  jmp alltraps
+80105997:	e9 b1 fa ff ff       	jmp    8010544d <alltraps>
+
+8010599c <vector22>:
+.globl vector22
+vector22:
+  pushl $0
+8010599c:	6a 00                	push   $0x0
+  pushl $22
+8010599e:	6a 16                	push   $0x16
+  jmp alltraps
+801059a0:	e9 a8 fa ff ff       	jmp    8010544d <alltraps>
+
+801059a5 <vector23>:
+.globl vector23
+vector23:
+  pushl $0
+801059a5:	6a 00                	push   $0x0
+  pushl $23
+801059a7:	6a 17                	push   $0x17
+  jmp alltraps
+801059a9:	e9 9f fa ff ff       	jmp    8010544d <alltraps>
+
+801059ae <vector24>:
+.globl vector24
+vector24:
+  pushl $0
+801059ae:	6a 00                	push   $0x0
+  pushl $24
+801059b0:	6a 18                	push   $0x18
+  jmp alltraps
+801059b2:	e9 96 fa ff ff       	jmp    8010544d <alltraps>
+
+801059b7 <vector25>:
+.globl vector25
+vector25:
+  pushl $0
+801059b7:	6a 00                	push   $0x0
+  pushl $25
+801059b9:	6a 19                	push   $0x19
+  jmp alltraps
+801059bb:	e9 8d fa ff ff       	jmp    8010544d <alltraps>
+
+801059c0 <vector26>:
+.globl vector26
+vector26:
+  pushl $0
+801059c0:	6a 00                	push   $0x0
+  pushl $26
+801059c2:	6a 1a                	push   $0x1a
+  jmp alltraps
+801059c4:	e9 84 fa ff ff       	jmp    8010544d <alltraps>
+
+801059c9 <vector27>:
+.globl vector27
+vector27:
+  pushl $0
+801059c9:	6a 00                	push   $0x0
+  pushl $27
+801059cb:	6a 1b                	push   $0x1b
+  jmp alltraps
+801059cd:	e9 7b fa ff ff       	jmp    8010544d <alltraps>
+
+801059d2 <vector28>:
+.globl vector28
+vector28:
+  pushl $0
+801059d2:	6a 00                	push   $0x0
+  pushl $28
+801059d4:	6a 1c                	push   $0x1c
+  jmp alltraps
+801059d6:	e9 72 fa ff ff       	jmp    8010544d <alltraps>
+
+801059db <vector29>:
+.globl vector29
+vector29:
+  pushl $0
+801059db:	6a 00                	push   $0x0
+  pushl $29
+801059dd:	6a 1d                	push   $0x1d
+  jmp alltraps
+801059df:	e9 69 fa ff ff       	jmp    8010544d <alltraps>
+
+801059e4 <vector30>:
+.globl vector30
+vector30:
+  pushl $0
+801059e4:	6a 00                	push   $0x0
+  pushl $30
+801059e6:	6a 1e                	push   $0x1e
+  jmp alltraps
+801059e8:	e9 60 fa ff ff       	jmp    8010544d <alltraps>
+
+801059ed <vector31>:
+.globl vector31
+vector31:
+  pushl $0
+801059ed:	6a 00                	push   $0x0
+  pushl $31
+801059ef:	6a 1f                	push   $0x1f
+  jmp alltraps
+801059f1:	e9 57 fa ff ff       	jmp    8010544d <alltraps>
+
+801059f6 <vector32>:
+.globl vector32
+vector32:
+  pushl $0
+801059f6:	6a 00                	push   $0x0
+  pushl $32
+801059f8:	6a 20                	push   $0x20
+  jmp alltraps
+801059fa:	e9 4e fa ff ff       	jmp    8010544d <alltraps>
+
+801059ff <vector33>:
+.globl vector33
+vector33:
+  pushl $0
+801059ff:	6a 00                	push   $0x0
+  pushl $33
+80105a01:	6a 21                	push   $0x21
+  jmp alltraps
+80105a03:	e9 45 fa ff ff       	jmp    8010544d <alltraps>
+
+80105a08 <vector34>:
+.globl vector34
+vector34:
+  pushl $0
+80105a08:	6a 00                	push   $0x0
+  pushl $34
+80105a0a:	6a 22                	push   $0x22
+  jmp alltraps
+80105a0c:	e9 3c fa ff ff       	jmp    8010544d <alltraps>
+
+80105a11 <vector35>:
+.globl vector35
+vector35:
+  pushl $0
+80105a11:	6a 00                	push   $0x0
+  pushl $35
+80105a13:	6a 23                	push   $0x23
+  jmp alltraps
+80105a15:	e9 33 fa ff ff       	jmp    8010544d <alltraps>
+
+80105a1a <vector36>:
+.globl vector36
+vector36:
+  pushl $0
+80105a1a:	6a 00                	push   $0x0
+  pushl $36
+80105a1c:	6a 24                	push   $0x24
+  jmp alltraps
+80105a1e:	e9 2a fa ff ff       	jmp    8010544d <alltraps>
+
+80105a23 <vector37>:
+.globl vector37
+vector37:
+  pushl $0
+80105a23:	6a 00                	push   $0x0
+  pushl $37
+80105a25:	6a 25                	push   $0x25
+  jmp alltraps
+80105a27:	e9 21 fa ff ff       	jmp    8010544d <alltraps>
+
+80105a2c <vector38>:
+.globl vector38
+vector38:
+  pushl $0
+80105a2c:	6a 00                	push   $0x0
+  pushl $38
+80105a2e:	6a 26                	push   $0x26
+  jmp alltraps
+80105a30:	e9 18 fa ff ff       	jmp    8010544d <alltraps>
+
+80105a35 <vector39>:
+.globl vector39
+vector39:
+  pushl $0
+80105a35:	6a 00                	push   $0x0
+  pushl $39
+80105a37:	6a 27                	push   $0x27
+  jmp alltraps
+80105a39:	e9 0f fa ff ff       	jmp    8010544d <alltraps>
+
+80105a3e <vector40>:
+.globl vector40
+vector40:
+  pushl $0
+80105a3e:	6a 00                	push   $0x0
+  pushl $40
+80105a40:	6a 28                	push   $0x28
+  jmp alltraps
+80105a42:	e9 06 fa ff ff       	jmp    8010544d <alltraps>
+
+80105a47 <vector41>:
+.globl vector41
+vector41:
+  pushl $0
+80105a47:	6a 00                	push   $0x0
+  pushl $41
+80105a49:	6a 29                	push   $0x29
+  jmp alltraps
+80105a4b:	e9 fd f9 ff ff       	jmp    8010544d <alltraps>
+
+80105a50 <vector42>:
+.globl vector42
+vector42:
+  pushl $0
+80105a50:	6a 00                	push   $0x0
+  pushl $42
+80105a52:	6a 2a                	push   $0x2a
+  jmp alltraps
+80105a54:	e9 f4 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105a59 <vector43>:
+.globl vector43
+vector43:
+  pushl $0
+80105a59:	6a 00                	push   $0x0
+  pushl $43
+80105a5b:	6a 2b                	push   $0x2b
+  jmp alltraps
+80105a5d:	e9 eb f9 ff ff       	jmp    8010544d <alltraps>
+
+80105a62 <vector44>:
+.globl vector44
+vector44:
+  pushl $0
+80105a62:	6a 00                	push   $0x0
+  pushl $44
+80105a64:	6a 2c                	push   $0x2c
+  jmp alltraps
+80105a66:	e9 e2 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105a6b <vector45>:
+.globl vector45
+vector45:
+  pushl $0
+80105a6b:	6a 00                	push   $0x0
+  pushl $45
+80105a6d:	6a 2d                	push   $0x2d
+  jmp alltraps
+80105a6f:	e9 d9 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105a74 <vector46>:
+.globl vector46
+vector46:
+  pushl $0
+80105a74:	6a 00                	push   $0x0
+  pushl $46
+80105a76:	6a 2e                	push   $0x2e
+  jmp alltraps
+80105a78:	e9 d0 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105a7d <vector47>:
+.globl vector47
+vector47:
+  pushl $0
+80105a7d:	6a 00                	push   $0x0
+  pushl $47
+80105a7f:	6a 2f                	push   $0x2f
+  jmp alltraps
+80105a81:	e9 c7 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105a86 <vector48>:
+.globl vector48
+vector48:
+  pushl $0
+80105a86:	6a 00                	push   $0x0
+  pushl $48
+80105a88:	6a 30                	push   $0x30
+  jmp alltraps
+80105a8a:	e9 be f9 ff ff       	jmp    8010544d <alltraps>
+
+80105a8f <vector49>:
+.globl vector49
+vector49:
+  pushl $0
+80105a8f:	6a 00                	push   $0x0
+  pushl $49
+80105a91:	6a 31                	push   $0x31
+  jmp alltraps
+80105a93:	e9 b5 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105a98 <vector50>:
+.globl vector50
+vector50:
+  pushl $0
+80105a98:	6a 00                	push   $0x0
+  pushl $50
+80105a9a:	6a 32                	push   $0x32
+  jmp alltraps
+80105a9c:	e9 ac f9 ff ff       	jmp    8010544d <alltraps>
+
+80105aa1 <vector51>:
+.globl vector51
+vector51:
+  pushl $0
+80105aa1:	6a 00                	push   $0x0
+  pushl $51
+80105aa3:	6a 33                	push   $0x33
+  jmp alltraps
+80105aa5:	e9 a3 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105aaa <vector52>:
+.globl vector52
+vector52:
+  pushl $0
+80105aaa:	6a 00                	push   $0x0
+  pushl $52
+80105aac:	6a 34                	push   $0x34
+  jmp alltraps
+80105aae:	e9 9a f9 ff ff       	jmp    8010544d <alltraps>
+
+80105ab3 <vector53>:
+.globl vector53
+vector53:
+  pushl $0
+80105ab3:	6a 00                	push   $0x0
+  pushl $53
+80105ab5:	6a 35                	push   $0x35
+  jmp alltraps
+80105ab7:	e9 91 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105abc <vector54>:
+.globl vector54
+vector54:
+  pushl $0
+80105abc:	6a 00                	push   $0x0
+  pushl $54
+80105abe:	6a 36                	push   $0x36
+  jmp alltraps
+80105ac0:	e9 88 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105ac5 <vector55>:
+.globl vector55
+vector55:
+  pushl $0
+80105ac5:	6a 00                	push   $0x0
+  pushl $55
+80105ac7:	6a 37                	push   $0x37
+  jmp alltraps
+80105ac9:	e9 7f f9 ff ff       	jmp    8010544d <alltraps>
+
+80105ace <vector56>:
+.globl vector56
+vector56:
+  pushl $0
+80105ace:	6a 00                	push   $0x0
+  pushl $56
+80105ad0:	6a 38                	push   $0x38
+  jmp alltraps
+80105ad2:	e9 76 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105ad7 <vector57>:
+.globl vector57
+vector57:
+  pushl $0
+80105ad7:	6a 00                	push   $0x0
+  pushl $57
+80105ad9:	6a 39                	push   $0x39
+  jmp alltraps
+80105adb:	e9 6d f9 ff ff       	jmp    8010544d <alltraps>
+
+80105ae0 <vector58>:
+.globl vector58
+vector58:
+  pushl $0
+80105ae0:	6a 00                	push   $0x0
+  pushl $58
+80105ae2:	6a 3a                	push   $0x3a
+  jmp alltraps
+80105ae4:	e9 64 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105ae9 <vector59>:
+.globl vector59
+vector59:
+  pushl $0
+80105ae9:	6a 00                	push   $0x0
+  pushl $59
+80105aeb:	6a 3b                	push   $0x3b
+  jmp alltraps
+80105aed:	e9 5b f9 ff ff       	jmp    8010544d <alltraps>
+
+80105af2 <vector60>:
+.globl vector60
+vector60:
+  pushl $0
+80105af2:	6a 00                	push   $0x0
+  pushl $60
+80105af4:	6a 3c                	push   $0x3c
+  jmp alltraps
+80105af6:	e9 52 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105afb <vector61>:
+.globl vector61
+vector61:
+  pushl $0
+80105afb:	6a 00                	push   $0x0
+  pushl $61
+80105afd:	6a 3d                	push   $0x3d
+  jmp alltraps
+80105aff:	e9 49 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105b04 <vector62>:
+.globl vector62
+vector62:
+  pushl $0
+80105b04:	6a 00                	push   $0x0
+  pushl $62
+80105b06:	6a 3e                	push   $0x3e
+  jmp alltraps
+80105b08:	e9 40 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105b0d <vector63>:
+.globl vector63
+vector63:
+  pushl $0
+80105b0d:	6a 00                	push   $0x0
+  pushl $63
+80105b0f:	6a 3f                	push   $0x3f
+  jmp alltraps
+80105b11:	e9 37 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105b16 <vector64>:
+.globl vector64
+vector64:
+  pushl $0
+80105b16:	6a 00                	push   $0x0
+  pushl $64
+80105b18:	6a 40                	push   $0x40
+  jmp alltraps
+80105b1a:	e9 2e f9 ff ff       	jmp    8010544d <alltraps>
+
+80105b1f <vector65>:
+.globl vector65
+vector65:
+  pushl $0
+80105b1f:	6a 00                	push   $0x0
+  pushl $65
+80105b21:	6a 41                	push   $0x41
+  jmp alltraps
+80105b23:	e9 25 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105b28 <vector66>:
+.globl vector66
+vector66:
+  pushl $0
+80105b28:	6a 00                	push   $0x0
+  pushl $66
+80105b2a:	6a 42                	push   $0x42
+  jmp alltraps
+80105b2c:	e9 1c f9 ff ff       	jmp    8010544d <alltraps>
+
+80105b31 <vector67>:
+.globl vector67
+vector67:
+  pushl $0
+80105b31:	6a 00                	push   $0x0
+  pushl $67
+80105b33:	6a 43                	push   $0x43
+  jmp alltraps
+80105b35:	e9 13 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105b3a <vector68>:
+.globl vector68
+vector68:
+  pushl $0
+80105b3a:	6a 00                	push   $0x0
+  pushl $68
+80105b3c:	6a 44                	push   $0x44
+  jmp alltraps
+80105b3e:	e9 0a f9 ff ff       	jmp    8010544d <alltraps>
+
+80105b43 <vector69>:
+.globl vector69
+vector69:
+  pushl $0
+80105b43:	6a 00                	push   $0x0
+  pushl $69
+80105b45:	6a 45                	push   $0x45
+  jmp alltraps
+80105b47:	e9 01 f9 ff ff       	jmp    8010544d <alltraps>
+
+80105b4c <vector70>:
+.globl vector70
+vector70:
+  pushl $0
+80105b4c:	6a 00                	push   $0x0
+  pushl $70
+80105b4e:	6a 46                	push   $0x46
+  jmp alltraps
+80105b50:	e9 f8 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105b55 <vector71>:
+.globl vector71
+vector71:
+  pushl $0
+80105b55:	6a 00                	push   $0x0
+  pushl $71
+80105b57:	6a 47                	push   $0x47
+  jmp alltraps
+80105b59:	e9 ef f8 ff ff       	jmp    8010544d <alltraps>
+
+80105b5e <vector72>:
+.globl vector72
+vector72:
+  pushl $0
+80105b5e:	6a 00                	push   $0x0
+  pushl $72
+80105b60:	6a 48                	push   $0x48
+  jmp alltraps
+80105b62:	e9 e6 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105b67 <vector73>:
+.globl vector73
+vector73:
+  pushl $0
+80105b67:	6a 00                	push   $0x0
+  pushl $73
+80105b69:	6a 49                	push   $0x49
+  jmp alltraps
+80105b6b:	e9 dd f8 ff ff       	jmp    8010544d <alltraps>
+
+80105b70 <vector74>:
+.globl vector74
+vector74:
+  pushl $0
+80105b70:	6a 00                	push   $0x0
+  pushl $74
+80105b72:	6a 4a                	push   $0x4a
+  jmp alltraps
+80105b74:	e9 d4 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105b79 <vector75>:
+.globl vector75
+vector75:
+  pushl $0
+80105b79:	6a 00                	push   $0x0
+  pushl $75
+80105b7b:	6a 4b                	push   $0x4b
+  jmp alltraps
+80105b7d:	e9 cb f8 ff ff       	jmp    8010544d <alltraps>
+
+80105b82 <vector76>:
+.globl vector76
+vector76:
+  pushl $0
+80105b82:	6a 00                	push   $0x0
+  pushl $76
+80105b84:	6a 4c                	push   $0x4c
+  jmp alltraps
+80105b86:	e9 c2 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105b8b <vector77>:
+.globl vector77
+vector77:
+  pushl $0
+80105b8b:	6a 00                	push   $0x0
+  pushl $77
+80105b8d:	6a 4d                	push   $0x4d
+  jmp alltraps
+80105b8f:	e9 b9 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105b94 <vector78>:
+.globl vector78
+vector78:
+  pushl $0
+80105b94:	6a 00                	push   $0x0
+  pushl $78
+80105b96:	6a 4e                	push   $0x4e
+  jmp alltraps
+80105b98:	e9 b0 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105b9d <vector79>:
+.globl vector79
+vector79:
+  pushl $0
+80105b9d:	6a 00                	push   $0x0
+  pushl $79
+80105b9f:	6a 4f                	push   $0x4f
+  jmp alltraps
+80105ba1:	e9 a7 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105ba6 <vector80>:
+.globl vector80
+vector80:
+  pushl $0
+80105ba6:	6a 00                	push   $0x0
+  pushl $80
+80105ba8:	6a 50                	push   $0x50
+  jmp alltraps
+80105baa:	e9 9e f8 ff ff       	jmp    8010544d <alltraps>
+
+80105baf <vector81>:
+.globl vector81
+vector81:
+  pushl $0
+80105baf:	6a 00                	push   $0x0
+  pushl $81
+80105bb1:	6a 51                	push   $0x51
+  jmp alltraps
+80105bb3:	e9 95 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105bb8 <vector82>:
+.globl vector82
+vector82:
+  pushl $0
+80105bb8:	6a 00                	push   $0x0
+  pushl $82
+80105bba:	6a 52                	push   $0x52
+  jmp alltraps
+80105bbc:	e9 8c f8 ff ff       	jmp    8010544d <alltraps>
+
+80105bc1 <vector83>:
+.globl vector83
+vector83:
+  pushl $0
+80105bc1:	6a 00                	push   $0x0
+  pushl $83
+80105bc3:	6a 53                	push   $0x53
+  jmp alltraps
+80105bc5:	e9 83 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105bca <vector84>:
+.globl vector84
+vector84:
+  pushl $0
+80105bca:	6a 00                	push   $0x0
+  pushl $84
+80105bcc:	6a 54                	push   $0x54
+  jmp alltraps
+80105bce:	e9 7a f8 ff ff       	jmp    8010544d <alltraps>
+
+80105bd3 <vector85>:
+.globl vector85
+vector85:
+  pushl $0
+80105bd3:	6a 00                	push   $0x0
+  pushl $85
+80105bd5:	6a 55                	push   $0x55
+  jmp alltraps
+80105bd7:	e9 71 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105bdc <vector86>:
+.globl vector86
+vector86:
+  pushl $0
+80105bdc:	6a 00                	push   $0x0
+  pushl $86
+80105bde:	6a 56                	push   $0x56
+  jmp alltraps
+80105be0:	e9 68 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105be5 <vector87>:
+.globl vector87
+vector87:
+  pushl $0
+80105be5:	6a 00                	push   $0x0
+  pushl $87
+80105be7:	6a 57                	push   $0x57
+  jmp alltraps
+80105be9:	e9 5f f8 ff ff       	jmp    8010544d <alltraps>
+
+80105bee <vector88>:
+.globl vector88
+vector88:
+  pushl $0
+80105bee:	6a 00                	push   $0x0
+  pushl $88
+80105bf0:	6a 58                	push   $0x58
+  jmp alltraps
+80105bf2:	e9 56 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105bf7 <vector89>:
+.globl vector89
+vector89:
+  pushl $0
+80105bf7:	6a 00                	push   $0x0
+  pushl $89
+80105bf9:	6a 59                	push   $0x59
+  jmp alltraps
+80105bfb:	e9 4d f8 ff ff       	jmp    8010544d <alltraps>
+
+80105c00 <vector90>:
+.globl vector90
+vector90:
+  pushl $0
+80105c00:	6a 00                	push   $0x0
+  pushl $90
+80105c02:	6a 5a                	push   $0x5a
+  jmp alltraps
+80105c04:	e9 44 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105c09 <vector91>:
+.globl vector91
+vector91:
+  pushl $0
+80105c09:	6a 00                	push   $0x0
+  pushl $91
+80105c0b:	6a 5b                	push   $0x5b
+  jmp alltraps
+80105c0d:	e9 3b f8 ff ff       	jmp    8010544d <alltraps>
+
+80105c12 <vector92>:
+.globl vector92
+vector92:
+  pushl $0
+80105c12:	6a 00                	push   $0x0
+  pushl $92
+80105c14:	6a 5c                	push   $0x5c
+  jmp alltraps
+80105c16:	e9 32 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105c1b <vector93>:
+.globl vector93
+vector93:
+  pushl $0
+80105c1b:	6a 00                	push   $0x0
+  pushl $93
+80105c1d:	6a 5d                	push   $0x5d
+  jmp alltraps
+80105c1f:	e9 29 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105c24 <vector94>:
+.globl vector94
+vector94:
+  pushl $0
+80105c24:	6a 00                	push   $0x0
+  pushl $94
+80105c26:	6a 5e                	push   $0x5e
+  jmp alltraps
+80105c28:	e9 20 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105c2d <vector95>:
+.globl vector95
+vector95:
+  pushl $0
+80105c2d:	6a 00                	push   $0x0
+  pushl $95
+80105c2f:	6a 5f                	push   $0x5f
+  jmp alltraps
+80105c31:	e9 17 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105c36 <vector96>:
+.globl vector96
+vector96:
+  pushl $0
+80105c36:	6a 00                	push   $0x0
+  pushl $96
+80105c38:	6a 60                	push   $0x60
+  jmp alltraps
+80105c3a:	e9 0e f8 ff ff       	jmp    8010544d <alltraps>
+
+80105c3f <vector97>:
+.globl vector97
+vector97:
+  pushl $0
+80105c3f:	6a 00                	push   $0x0
+  pushl $97
+80105c41:	6a 61                	push   $0x61
+  jmp alltraps
+80105c43:	e9 05 f8 ff ff       	jmp    8010544d <alltraps>
+
+80105c48 <vector98>:
+.globl vector98
+vector98:
+  pushl $0
+80105c48:	6a 00                	push   $0x0
+  pushl $98
+80105c4a:	6a 62                	push   $0x62
+  jmp alltraps
+80105c4c:	e9 fc f7 ff ff       	jmp    8010544d <alltraps>
+
+80105c51 <vector99>:
+.globl vector99
+vector99:
+  pushl $0
+80105c51:	6a 00                	push   $0x0
+  pushl $99
+80105c53:	6a 63                	push   $0x63
+  jmp alltraps
+80105c55:	e9 f3 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105c5a <vector100>:
+.globl vector100
+vector100:
+  pushl $0
+80105c5a:	6a 00                	push   $0x0
+  pushl $100
+80105c5c:	6a 64                	push   $0x64
+  jmp alltraps
+80105c5e:	e9 ea f7 ff ff       	jmp    8010544d <alltraps>
+
+80105c63 <vector101>:
+.globl vector101
+vector101:
+  pushl $0
+80105c63:	6a 00                	push   $0x0
+  pushl $101
+80105c65:	6a 65                	push   $0x65
+  jmp alltraps
+80105c67:	e9 e1 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105c6c <vector102>:
+.globl vector102
+vector102:
+  pushl $0
+80105c6c:	6a 00                	push   $0x0
+  pushl $102
+80105c6e:	6a 66                	push   $0x66
+  jmp alltraps
+80105c70:	e9 d8 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105c75 <vector103>:
+.globl vector103
+vector103:
+  pushl $0
+80105c75:	6a 00                	push   $0x0
+  pushl $103
+80105c77:	6a 67                	push   $0x67
+  jmp alltraps
+80105c79:	e9 cf f7 ff ff       	jmp    8010544d <alltraps>
+
+80105c7e <vector104>:
+.globl vector104
+vector104:
+  pushl $0
+80105c7e:	6a 00                	push   $0x0
+  pushl $104
+80105c80:	6a 68                	push   $0x68
+  jmp alltraps
+80105c82:	e9 c6 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105c87 <vector105>:
+.globl vector105
+vector105:
+  pushl $0
+80105c87:	6a 00                	push   $0x0
+  pushl $105
+80105c89:	6a 69                	push   $0x69
+  jmp alltraps
+80105c8b:	e9 bd f7 ff ff       	jmp    8010544d <alltraps>
+
+80105c90 <vector106>:
+.globl vector106
+vector106:
+  pushl $0
+80105c90:	6a 00                	push   $0x0
+  pushl $106
+80105c92:	6a 6a                	push   $0x6a
+  jmp alltraps
+80105c94:	e9 b4 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105c99 <vector107>:
+.globl vector107
+vector107:
+  pushl $0
+80105c99:	6a 00                	push   $0x0
+  pushl $107
+80105c9b:	6a 6b                	push   $0x6b
+  jmp alltraps
+80105c9d:	e9 ab f7 ff ff       	jmp    8010544d <alltraps>
+
+80105ca2 <vector108>:
+.globl vector108
+vector108:
+  pushl $0
+80105ca2:	6a 00                	push   $0x0
+  pushl $108
+80105ca4:	6a 6c                	push   $0x6c
+  jmp alltraps
+80105ca6:	e9 a2 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105cab <vector109>:
+.globl vector109
+vector109:
+  pushl $0
+80105cab:	6a 00                	push   $0x0
+  pushl $109
+80105cad:	6a 6d                	push   $0x6d
+  jmp alltraps
+80105caf:	e9 99 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105cb4 <vector110>:
+.globl vector110
+vector110:
+  pushl $0
+80105cb4:	6a 00                	push   $0x0
+  pushl $110
+80105cb6:	6a 6e                	push   $0x6e
+  jmp alltraps
+80105cb8:	e9 90 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105cbd <vector111>:
+.globl vector111
+vector111:
+  pushl $0
+80105cbd:	6a 00                	push   $0x0
+  pushl $111
+80105cbf:	6a 6f                	push   $0x6f
+  jmp alltraps
+80105cc1:	e9 87 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105cc6 <vector112>:
+.globl vector112
+vector112:
+  pushl $0
+80105cc6:	6a 00                	push   $0x0
+  pushl $112
+80105cc8:	6a 70                	push   $0x70
+  jmp alltraps
+80105cca:	e9 7e f7 ff ff       	jmp    8010544d <alltraps>
+
+80105ccf <vector113>:
+.globl vector113
+vector113:
+  pushl $0
+80105ccf:	6a 00                	push   $0x0
+  pushl $113
+80105cd1:	6a 71                	push   $0x71
+  jmp alltraps
+80105cd3:	e9 75 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105cd8 <vector114>:
+.globl vector114
+vector114:
+  pushl $0
+80105cd8:	6a 00                	push   $0x0
+  pushl $114
+80105cda:	6a 72                	push   $0x72
+  jmp alltraps
+80105cdc:	e9 6c f7 ff ff       	jmp    8010544d <alltraps>
+
+80105ce1 <vector115>:
+.globl vector115
+vector115:
+  pushl $0
+80105ce1:	6a 00                	push   $0x0
+  pushl $115
+80105ce3:	6a 73                	push   $0x73
+  jmp alltraps
+80105ce5:	e9 63 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105cea <vector116>:
+.globl vector116
+vector116:
+  pushl $0
+80105cea:	6a 00                	push   $0x0
+  pushl $116
+80105cec:	6a 74                	push   $0x74
+  jmp alltraps
+80105cee:	e9 5a f7 ff ff       	jmp    8010544d <alltraps>
+
+80105cf3 <vector117>:
+.globl vector117
+vector117:
+  pushl $0
+80105cf3:	6a 00                	push   $0x0
+  pushl $117
+80105cf5:	6a 75                	push   $0x75
+  jmp alltraps
+80105cf7:	e9 51 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105cfc <vector118>:
+.globl vector118
+vector118:
+  pushl $0
+80105cfc:	6a 00                	push   $0x0
+  pushl $118
+80105cfe:	6a 76                	push   $0x76
+  jmp alltraps
+80105d00:	e9 48 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105d05 <vector119>:
+.globl vector119
+vector119:
+  pushl $0
+80105d05:	6a 00                	push   $0x0
+  pushl $119
+80105d07:	6a 77                	push   $0x77
+  jmp alltraps
+80105d09:	e9 3f f7 ff ff       	jmp    8010544d <alltraps>
+
+80105d0e <vector120>:
+.globl vector120
+vector120:
+  pushl $0
+80105d0e:	6a 00                	push   $0x0
+  pushl $120
+80105d10:	6a 78                	push   $0x78
+  jmp alltraps
+80105d12:	e9 36 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105d17 <vector121>:
+.globl vector121
+vector121:
+  pushl $0
+80105d17:	6a 00                	push   $0x0
+  pushl $121
+80105d19:	6a 79                	push   $0x79
+  jmp alltraps
+80105d1b:	e9 2d f7 ff ff       	jmp    8010544d <alltraps>
+
+80105d20 <vector122>:
+.globl vector122
+vector122:
+  pushl $0
+80105d20:	6a 00                	push   $0x0
+  pushl $122
+80105d22:	6a 7a                	push   $0x7a
+  jmp alltraps
+80105d24:	e9 24 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105d29 <vector123>:
+.globl vector123
+vector123:
+  pushl $0
+80105d29:	6a 00                	push   $0x0
+  pushl $123
+80105d2b:	6a 7b                	push   $0x7b
+  jmp alltraps
+80105d2d:	e9 1b f7 ff ff       	jmp    8010544d <alltraps>
+
+80105d32 <vector124>:
+.globl vector124
+vector124:
+  pushl $0
+80105d32:	6a 00                	push   $0x0
+  pushl $124
+80105d34:	6a 7c                	push   $0x7c
+  jmp alltraps
+80105d36:	e9 12 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105d3b <vector125>:
+.globl vector125
+vector125:
+  pushl $0
+80105d3b:	6a 00                	push   $0x0
+  pushl $125
+80105d3d:	6a 7d                	push   $0x7d
+  jmp alltraps
+80105d3f:	e9 09 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105d44 <vector126>:
+.globl vector126
+vector126:
+  pushl $0
+80105d44:	6a 00                	push   $0x0
+  pushl $126
+80105d46:	6a 7e                	push   $0x7e
+  jmp alltraps
+80105d48:	e9 00 f7 ff ff       	jmp    8010544d <alltraps>
+
+80105d4d <vector127>:
+.globl vector127
+vector127:
+  pushl $0
+80105d4d:	6a 00                	push   $0x0
+  pushl $127
+80105d4f:	6a 7f                	push   $0x7f
+  jmp alltraps
+80105d51:	e9 f7 f6 ff ff       	jmp    8010544d <alltraps>
+
+80105d56 <vector128>:
+.globl vector128
+vector128:
+  pushl $0
+80105d56:	6a 00                	push   $0x0
+  pushl $128
+80105d58:	68 80 00 00 00       	push   $0x80
+  jmp alltraps
+80105d5d:	e9 eb f6 ff ff       	jmp    8010544d <alltraps>
+
+80105d62 <vector129>:
+.globl vector129
+vector129:
+  pushl $0
+80105d62:	6a 00                	push   $0x0
+  pushl $129
+80105d64:	68 81 00 00 00       	push   $0x81
+  jmp alltraps
+80105d69:	e9 df f6 ff ff       	jmp    8010544d <alltraps>
+
+80105d6e <vector130>:
+.globl vector130
+vector130:
+  pushl $0
+80105d6e:	6a 00                	push   $0x0
+  pushl $130
+80105d70:	68 82 00 00 00       	push   $0x82
+  jmp alltraps
+80105d75:	e9 d3 f6 ff ff       	jmp    8010544d <alltraps>
+
+80105d7a <vector131>:
+.globl vector131
+vector131:
+  pushl $0
+80105d7a:	6a 00                	push   $0x0
+  pushl $131
+80105d7c:	68 83 00 00 00       	push   $0x83
+  jmp alltraps
+80105d81:	e9 c7 f6 ff ff       	jmp    8010544d <alltraps>
+
+80105d86 <vector132>:
+.globl vector132
+vector132:
+  pushl $0
+80105d86:	6a 00                	push   $0x0
+  pushl $132
+80105d88:	68 84 00 00 00       	push   $0x84
+  jmp alltraps
+80105d8d:	e9 bb f6 ff ff       	jmp    8010544d <alltraps>
+
+80105d92 <vector133>:
+.globl vector133
+vector133:
+  pushl $0
+80105d92:	6a 00                	push   $0x0
+  pushl $133
+80105d94:	68 85 00 00 00       	push   $0x85
+  jmp alltraps
+80105d99:	e9 af f6 ff ff       	jmp    8010544d <alltraps>
+
+80105d9e <vector134>:
+.globl vector134
+vector134:
+  pushl $0
+80105d9e:	6a 00                	push   $0x0
+  pushl $134
+80105da0:	68 86 00 00 00       	push   $0x86
+  jmp alltraps
+80105da5:	e9 a3 f6 ff ff       	jmp    8010544d <alltraps>
+
+80105daa <vector135>:
+.globl vector135
+vector135:
+  pushl $0
+80105daa:	6a 00                	push   $0x0
+  pushl $135
+80105dac:	68 87 00 00 00       	push   $0x87
+  jmp alltraps
+80105db1:	e9 97 f6 ff ff       	jmp    8010544d <alltraps>
+
+80105db6 <vector136>:
+.globl vector136
+vector136:
+  pushl $0
+80105db6:	6a 00                	push   $0x0
+  pushl $136
+80105db8:	68 88 00 00 00       	push   $0x88
+  jmp alltraps
+80105dbd:	e9 8b f6 ff ff       	jmp    8010544d <alltraps>
+
+80105dc2 <vector137>:
+.globl vector137
+vector137:
+  pushl $0
+80105dc2:	6a 00                	push   $0x0
+  pushl $137
+80105dc4:	68 89 00 00 00       	push   $0x89
+  jmp alltraps
+80105dc9:	e9 7f f6 ff ff       	jmp    8010544d <alltraps>
+
+80105dce <vector138>:
+.globl vector138
+vector138:
+  pushl $0
+80105dce:	6a 00                	push   $0x0
+  pushl $138
+80105dd0:	68 8a 00 00 00       	push   $0x8a
+  jmp alltraps
+80105dd5:	e9 73 f6 ff ff       	jmp    8010544d <alltraps>
+
+80105dda <vector139>:
+.globl vector139
+vector139:
+  pushl $0
+80105dda:	6a 00                	push   $0x0
+  pushl $139
+80105ddc:	68 8b 00 00 00       	push   $0x8b
+  jmp alltraps
+80105de1:	e9 67 f6 ff ff       	jmp    8010544d <alltraps>
+
+80105de6 <vector140>:
+.globl vector140
+vector140:
+  pushl $0
+80105de6:	6a 00                	push   $0x0
+  pushl $140
+80105de8:	68 8c 00 00 00       	push   $0x8c
+  jmp alltraps
+80105ded:	e9 5b f6 ff ff       	jmp    8010544d <alltraps>
+
+80105df2 <vector141>:
+.globl vector141
+vector141:
+  pushl $0
+80105df2:	6a 00                	push   $0x0
+  pushl $141
+80105df4:	68 8d 00 00 00       	push   $0x8d
+  jmp alltraps
+80105df9:	e9 4f f6 ff ff       	jmp    8010544d <alltraps>
+
+80105dfe <vector142>:
+.globl vector142
+vector142:
+  pushl $0
+80105dfe:	6a 00                	push   $0x0
+  pushl $142
+80105e00:	68 8e 00 00 00       	push   $0x8e
+  jmp alltraps
+80105e05:	e9 43 f6 ff ff       	jmp    8010544d <alltraps>
+
+80105e0a <vector143>:
+.globl vector143
+vector143:
+  pushl $0
+80105e0a:	6a 00                	push   $0x0
+  pushl $143
+80105e0c:	68 8f 00 00 00       	push   $0x8f
+  jmp alltraps
+80105e11:	e9 37 f6 ff ff       	jmp    8010544d <alltraps>
+
+80105e16 <vector144>:
+.globl vector144
+vector144:
+  pushl $0
+80105e16:	6a 00                	push   $0x0
+  pushl $144
+80105e18:	68 90 00 00 00       	push   $0x90
+  jmp alltraps
+80105e1d:	e9 2b f6 ff ff       	jmp    8010544d <alltraps>
+
+80105e22 <vector145>:
+.globl vector145
+vector145:
+  pushl $0
+80105e22:	6a 00                	push   $0x0
+  pushl $145
+80105e24:	68 91 00 00 00       	push   $0x91
+  jmp alltraps
+80105e29:	e9 1f f6 ff ff       	jmp    8010544d <alltraps>
+
+80105e2e <vector146>:
+.globl vector146
+vector146:
+  pushl $0
+80105e2e:	6a 00                	push   $0x0
+  pushl $146
+80105e30:	68 92 00 00 00       	push   $0x92
+  jmp alltraps
+80105e35:	e9 13 f6 ff ff       	jmp    8010544d <alltraps>
+
+80105e3a <vector147>:
+.globl vector147
+vector147:
+  pushl $0
+80105e3a:	6a 00                	push   $0x0
+  pushl $147
+80105e3c:	68 93 00 00 00       	push   $0x93
+  jmp alltraps
+80105e41:	e9 07 f6 ff ff       	jmp    8010544d <alltraps>
+
+80105e46 <vector148>:
+.globl vector148
+vector148:
+  pushl $0
+80105e46:	6a 00                	push   $0x0
+  pushl $148
+80105e48:	68 94 00 00 00       	push   $0x94
+  jmp alltraps
+80105e4d:	e9 fb f5 ff ff       	jmp    8010544d <alltraps>
+
+80105e52 <vector149>:
+.globl vector149
+vector149:
+  pushl $0
+80105e52:	6a 00                	push   $0x0
+  pushl $149
+80105e54:	68 95 00 00 00       	push   $0x95
+  jmp alltraps
+80105e59:	e9 ef f5 ff ff       	jmp    8010544d <alltraps>
+
+80105e5e <vector150>:
+.globl vector150
+vector150:
+  pushl $0
+80105e5e:	6a 00                	push   $0x0
+  pushl $150
+80105e60:	68 96 00 00 00       	push   $0x96
+  jmp alltraps
+80105e65:	e9 e3 f5 ff ff       	jmp    8010544d <alltraps>
+
+80105e6a <vector151>:
+.globl vector151
+vector151:
+  pushl $0
+80105e6a:	6a 00                	push   $0x0
+  pushl $151
+80105e6c:	68 97 00 00 00       	push   $0x97
+  jmp alltraps
+80105e71:	e9 d7 f5 ff ff       	jmp    8010544d <alltraps>
+
+80105e76 <vector152>:
+.globl vector152
+vector152:
+  pushl $0
+80105e76:	6a 00                	push   $0x0
+  pushl $152
+80105e78:	68 98 00 00 00       	push   $0x98
+  jmp alltraps
+80105e7d:	e9 cb f5 ff ff       	jmp    8010544d <alltraps>
+
+80105e82 <vector153>:
+.globl vector153
+vector153:
+  pushl $0
+80105e82:	6a 00                	push   $0x0
+  pushl $153
+80105e84:	68 99 00 00 00       	push   $0x99
+  jmp alltraps
+80105e89:	e9 bf f5 ff ff       	jmp    8010544d <alltraps>
+
+80105e8e <vector154>:
+.globl vector154
+vector154:
+  pushl $0
+80105e8e:	6a 00                	push   $0x0
+  pushl $154
+80105e90:	68 9a 00 00 00       	push   $0x9a
+  jmp alltraps
+80105e95:	e9 b3 f5 ff ff       	jmp    8010544d <alltraps>
+
+80105e9a <vector155>:
+.globl vector155
+vector155:
+  pushl $0
+80105e9a:	6a 00                	push   $0x0
+  pushl $155
+80105e9c:	68 9b 00 00 00       	push   $0x9b
+  jmp alltraps
+80105ea1:	e9 a7 f5 ff ff       	jmp    8010544d <alltraps>
+
+80105ea6 <vector156>:
+.globl vector156
+vector156:
+  pushl $0
+80105ea6:	6a 00                	push   $0x0
+  pushl $156
+80105ea8:	68 9c 00 00 00       	push   $0x9c
+  jmp alltraps
+80105ead:	e9 9b f5 ff ff       	jmp    8010544d <alltraps>
+
+80105eb2 <vector157>:
+.globl vector157
+vector157:
+  pushl $0
+80105eb2:	6a 00                	push   $0x0
+  pushl $157
+80105eb4:	68 9d 00 00 00       	push   $0x9d
+  jmp alltraps
+80105eb9:	e9 8f f5 ff ff       	jmp    8010544d <alltraps>
+
+80105ebe <vector158>:
+.globl vector158
+vector158:
+  pushl $0
+80105ebe:	6a 00                	push   $0x0
+  pushl $158
+80105ec0:	68 9e 00 00 00       	push   $0x9e
+  jmp alltraps
+80105ec5:	e9 83 f5 ff ff       	jmp    8010544d <alltraps>
+
+80105eca <vector159>:
+.globl vector159
+vector159:
+  pushl $0
+80105eca:	6a 00                	push   $0x0
+  pushl $159
+80105ecc:	68 9f 00 00 00       	push   $0x9f
+  jmp alltraps
+80105ed1:	e9 77 f5 ff ff       	jmp    8010544d <alltraps>
+
+80105ed6 <vector160>:
+.globl vector160
+vector160:
+  pushl $0
+80105ed6:	6a 00                	push   $0x0
+  pushl $160
+80105ed8:	68 a0 00 00 00       	push   $0xa0
+  jmp alltraps
+80105edd:	e9 6b f5 ff ff       	jmp    8010544d <alltraps>
+
+80105ee2 <vector161>:
+.globl vector161
+vector161:
+  pushl $0
+80105ee2:	6a 00                	push   $0x0
+  pushl $161
+80105ee4:	68 a1 00 00 00       	push   $0xa1
+  jmp alltraps
+80105ee9:	e9 5f f5 ff ff       	jmp    8010544d <alltraps>
+
+80105eee <vector162>:
+.globl vector162
+vector162:
+  pushl $0
+80105eee:	6a 00                	push   $0x0
+  pushl $162
+80105ef0:	68 a2 00 00 00       	push   $0xa2
+  jmp alltraps
+80105ef5:	e9 53 f5 ff ff       	jmp    8010544d <alltraps>
+
+80105efa <vector163>:
+.globl vector163
+vector163:
+  pushl $0
+80105efa:	6a 00                	push   $0x0
+  pushl $163
+80105efc:	68 a3 00 00 00       	push   $0xa3
+  jmp alltraps
+80105f01:	e9 47 f5 ff ff       	jmp    8010544d <alltraps>
+
+80105f06 <vector164>:
+.globl vector164
+vector164:
+  pushl $0
+80105f06:	6a 00                	push   $0x0
+  pushl $164
+80105f08:	68 a4 00 00 00       	push   $0xa4
+  jmp alltraps
+80105f0d:	e9 3b f5 ff ff       	jmp    8010544d <alltraps>
+
+80105f12 <vector165>:
+.globl vector165
+vector165:
+  pushl $0
+80105f12:	6a 00                	push   $0x0
+  pushl $165
+80105f14:	68 a5 00 00 00       	push   $0xa5
+  jmp alltraps
+80105f19:	e9 2f f5 ff ff       	jmp    8010544d <alltraps>
+
+80105f1e <vector166>:
+.globl vector166
+vector166:
+  pushl $0
+80105f1e:	6a 00                	push   $0x0
+  pushl $166
+80105f20:	68 a6 00 00 00       	push   $0xa6
+  jmp alltraps
+80105f25:	e9 23 f5 ff ff       	jmp    8010544d <alltraps>
+
+80105f2a <vector167>:
+.globl vector167
+vector167:
+  pushl $0
+80105f2a:	6a 00                	push   $0x0
+  pushl $167
+80105f2c:	68 a7 00 00 00       	push   $0xa7
+  jmp alltraps
+80105f31:	e9 17 f5 ff ff       	jmp    8010544d <alltraps>
+
+80105f36 <vector168>:
+.globl vector168
+vector168:
+  pushl $0
+80105f36:	6a 00                	push   $0x0
+  pushl $168
+80105f38:	68 a8 00 00 00       	push   $0xa8
+  jmp alltraps
+80105f3d:	e9 0b f5 ff ff       	jmp    8010544d <alltraps>
+
+80105f42 <vector169>:
+.globl vector169
+vector169:
+  pushl $0
+80105f42:	6a 00                	push   $0x0
+  pushl $169
+80105f44:	68 a9 00 00 00       	push   $0xa9
+  jmp alltraps
+80105f49:	e9 ff f4 ff ff       	jmp    8010544d <alltraps>
+
+80105f4e <vector170>:
+.globl vector170
+vector170:
+  pushl $0
+80105f4e:	6a 00                	push   $0x0
+  pushl $170
+80105f50:	68 aa 00 00 00       	push   $0xaa
+  jmp alltraps
+80105f55:	e9 f3 f4 ff ff       	jmp    8010544d <alltraps>
+
+80105f5a <vector171>:
+.globl vector171
+vector171:
+  pushl $0
+80105f5a:	6a 00                	push   $0x0
+  pushl $171
+80105f5c:	68 ab 00 00 00       	push   $0xab
+  jmp alltraps
+80105f61:	e9 e7 f4 ff ff       	jmp    8010544d <alltraps>
+
+80105f66 <vector172>:
+.globl vector172
+vector172:
+  pushl $0
+80105f66:	6a 00                	push   $0x0
+  pushl $172
+80105f68:	68 ac 00 00 00       	push   $0xac
+  jmp alltraps
+80105f6d:	e9 db f4 ff ff       	jmp    8010544d <alltraps>
+
+80105f72 <vector173>:
+.globl vector173
+vector173:
+  pushl $0
+80105f72:	6a 00                	push   $0x0
+  pushl $173
+80105f74:	68 ad 00 00 00       	push   $0xad
+  jmp alltraps
+80105f79:	e9 cf f4 ff ff       	jmp    8010544d <alltraps>
+
+80105f7e <vector174>:
+.globl vector174
+vector174:
+  pushl $0
+80105f7e:	6a 00                	push   $0x0
+  pushl $174
+80105f80:	68 ae 00 00 00       	push   $0xae
+  jmp alltraps
+80105f85:	e9 c3 f4 ff ff       	jmp    8010544d <alltraps>
+
+80105f8a <vector175>:
+.globl vector175
+vector175:
+  pushl $0
+80105f8a:	6a 00                	push   $0x0
+  pushl $175
+80105f8c:	68 af 00 00 00       	push   $0xaf
+  jmp alltraps
+80105f91:	e9 b7 f4 ff ff       	jmp    8010544d <alltraps>
+
+80105f96 <vector176>:
+.globl vector176
+vector176:
+  pushl $0
+80105f96:	6a 00                	push   $0x0
+  pushl $176
+80105f98:	68 b0 00 00 00       	push   $0xb0
+  jmp alltraps
+80105f9d:	e9 ab f4 ff ff       	jmp    8010544d <alltraps>
+
+80105fa2 <vector177>:
+.globl vector177
+vector177:
+  pushl $0
+80105fa2:	6a 00                	push   $0x0
+  pushl $177
+80105fa4:	68 b1 00 00 00       	push   $0xb1
+  jmp alltraps
+80105fa9:	e9 9f f4 ff ff       	jmp    8010544d <alltraps>
+
+80105fae <vector178>:
+.globl vector178
+vector178:
+  pushl $0
+80105fae:	6a 00                	push   $0x0
+  pushl $178
+80105fb0:	68 b2 00 00 00       	push   $0xb2
+  jmp alltraps
+80105fb5:	e9 93 f4 ff ff       	jmp    8010544d <alltraps>
+
+80105fba <vector179>:
+.globl vector179
+vector179:
+  pushl $0
+80105fba:	6a 00                	push   $0x0
+  pushl $179
+80105fbc:	68 b3 00 00 00       	push   $0xb3
+  jmp alltraps
+80105fc1:	e9 87 f4 ff ff       	jmp    8010544d <alltraps>
+
+80105fc6 <vector180>:
+.globl vector180
+vector180:
+  pushl $0
+80105fc6:	6a 00                	push   $0x0
+  pushl $180
+80105fc8:	68 b4 00 00 00       	push   $0xb4
+  jmp alltraps
+80105fcd:	e9 7b f4 ff ff       	jmp    8010544d <alltraps>
+
+80105fd2 <vector181>:
+.globl vector181
+vector181:
+  pushl $0
+80105fd2:	6a 00                	push   $0x0
+  pushl $181
+80105fd4:	68 b5 00 00 00       	push   $0xb5
+  jmp alltraps
+80105fd9:	e9 6f f4 ff ff       	jmp    8010544d <alltraps>
+
+80105fde <vector182>:
+.globl vector182
+vector182:
+  pushl $0
+80105fde:	6a 00                	push   $0x0
+  pushl $182
+80105fe0:	68 b6 00 00 00       	push   $0xb6
+  jmp alltraps
+80105fe5:	e9 63 f4 ff ff       	jmp    8010544d <alltraps>
+
+80105fea <vector183>:
+.globl vector183
+vector183:
+  pushl $0
+80105fea:	6a 00                	push   $0x0
+  pushl $183
+80105fec:	68 b7 00 00 00       	push   $0xb7
+  jmp alltraps
+80105ff1:	e9 57 f4 ff ff       	jmp    8010544d <alltraps>
+
+80105ff6 <vector184>:
+.globl vector184
+vector184:
+  pushl $0
+80105ff6:	6a 00                	push   $0x0
+  pushl $184
+80105ff8:	68 b8 00 00 00       	push   $0xb8
+  jmp alltraps
+80105ffd:	e9 4b f4 ff ff       	jmp    8010544d <alltraps>
+
+80106002 <vector185>:
+.globl vector185
+vector185:
+  pushl $0
+80106002:	6a 00                	push   $0x0
+  pushl $185
+80106004:	68 b9 00 00 00       	push   $0xb9
+  jmp alltraps
+80106009:	e9 3f f4 ff ff       	jmp    8010544d <alltraps>
+
+8010600e <vector186>:
+.globl vector186
+vector186:
+  pushl $0
+8010600e:	6a 00                	push   $0x0
+  pushl $186
+80106010:	68 ba 00 00 00       	push   $0xba
+  jmp alltraps
+80106015:	e9 33 f4 ff ff       	jmp    8010544d <alltraps>
+
+8010601a <vector187>:
+.globl vector187
+vector187:
+  pushl $0
+8010601a:	6a 00                	push   $0x0
+  pushl $187
+8010601c:	68 bb 00 00 00       	push   $0xbb
+  jmp alltraps
+80106021:	e9 27 f4 ff ff       	jmp    8010544d <alltraps>
+
+80106026 <vector188>:
+.globl vector188
+vector188:
+  pushl $0
+80106026:	6a 00                	push   $0x0
+  pushl $188
+80106028:	68 bc 00 00 00       	push   $0xbc
+  jmp alltraps
+8010602d:	e9 1b f4 ff ff       	jmp    8010544d <alltraps>
+
+80106032 <vector189>:
+.globl vector189
+vector189:
+  pushl $0
+80106032:	6a 00                	push   $0x0
+  pushl $189
+80106034:	68 bd 00 00 00       	push   $0xbd
+  jmp alltraps
+80106039:	e9 0f f4 ff ff       	jmp    8010544d <alltraps>
+
+8010603e <vector190>:
+.globl vector190
+vector190:
+  pushl $0
+8010603e:	6a 00                	push   $0x0
+  pushl $190
+80106040:	68 be 00 00 00       	push   $0xbe
+  jmp alltraps
+80106045:	e9 03 f4 ff ff       	jmp    8010544d <alltraps>
+
+8010604a <vector191>:
+.globl vector191
+vector191:
+  pushl $0
+8010604a:	6a 00                	push   $0x0
+  pushl $191
+8010604c:	68 bf 00 00 00       	push   $0xbf
+  jmp alltraps
+80106051:	e9 f7 f3 ff ff       	jmp    8010544d <alltraps>
+
+80106056 <vector192>:
+.globl vector192
+vector192:
+  pushl $0
+80106056:	6a 00                	push   $0x0
+  pushl $192
+80106058:	68 c0 00 00 00       	push   $0xc0
+  jmp alltraps
+8010605d:	e9 eb f3 ff ff       	jmp    8010544d <alltraps>
+
+80106062 <vector193>:
+.globl vector193
+vector193:
+  pushl $0
+80106062:	6a 00                	push   $0x0
+  pushl $193
+80106064:	68 c1 00 00 00       	push   $0xc1
+  jmp alltraps
+80106069:	e9 df f3 ff ff       	jmp    8010544d <alltraps>
+
+8010606e <vector194>:
+.globl vector194
+vector194:
+  pushl $0
+8010606e:	6a 00                	push   $0x0
+  pushl $194
+80106070:	68 c2 00 00 00       	push   $0xc2
+  jmp alltraps
+80106075:	e9 d3 f3 ff ff       	jmp    8010544d <alltraps>
+
+8010607a <vector195>:
+.globl vector195
+vector195:
+  pushl $0
+8010607a:	6a 00                	push   $0x0
+  pushl $195
+8010607c:	68 c3 00 00 00       	push   $0xc3
+  jmp alltraps
+80106081:	e9 c7 f3 ff ff       	jmp    8010544d <alltraps>
+
+80106086 <vector196>:
+.globl vector196
+vector196:
+  pushl $0
+80106086:	6a 00                	push   $0x0
+  pushl $196
+80106088:	68 c4 00 00 00       	push   $0xc4
+  jmp alltraps
+8010608d:	e9 bb f3 ff ff       	jmp    8010544d <alltraps>
+
+80106092 <vector197>:
+.globl vector197
+vector197:
+  pushl $0
+80106092:	6a 00                	push   $0x0
+  pushl $197
+80106094:	68 c5 00 00 00       	push   $0xc5
+  jmp alltraps
+80106099:	e9 af f3 ff ff       	jmp    8010544d <alltraps>
+
+8010609e <vector198>:
+.globl vector198
+vector198:
+  pushl $0
+8010609e:	6a 00                	push   $0x0
+  pushl $198
+801060a0:	68 c6 00 00 00       	push   $0xc6
+  jmp alltraps
+801060a5:	e9 a3 f3 ff ff       	jmp    8010544d <alltraps>
+
+801060aa <vector199>:
+.globl vector199
+vector199:
+  pushl $0
+801060aa:	6a 00                	push   $0x0
+  pushl $199
+801060ac:	68 c7 00 00 00       	push   $0xc7
+  jmp alltraps
+801060b1:	e9 97 f3 ff ff       	jmp    8010544d <alltraps>
+
+801060b6 <vector200>:
+.globl vector200
+vector200:
+  pushl $0
+801060b6:	6a 00                	push   $0x0
+  pushl $200
+801060b8:	68 c8 00 00 00       	push   $0xc8
+  jmp alltraps
+801060bd:	e9 8b f3 ff ff       	jmp    8010544d <alltraps>
+
+801060c2 <vector201>:
+.globl vector201
+vector201:
+  pushl $0
+801060c2:	6a 00                	push   $0x0
+  pushl $201
+801060c4:	68 c9 00 00 00       	push   $0xc9
+  jmp alltraps
+801060c9:	e9 7f f3 ff ff       	jmp    8010544d <alltraps>
+
+801060ce <vector202>:
+.globl vector202
+vector202:
+  pushl $0
+801060ce:	6a 00                	push   $0x0
+  pushl $202
+801060d0:	68 ca 00 00 00       	push   $0xca
+  jmp alltraps
+801060d5:	e9 73 f3 ff ff       	jmp    8010544d <alltraps>
+
+801060da <vector203>:
+.globl vector203
+vector203:
+  pushl $0
+801060da:	6a 00                	push   $0x0
+  pushl $203
+801060dc:	68 cb 00 00 00       	push   $0xcb
+  jmp alltraps
+801060e1:	e9 67 f3 ff ff       	jmp    8010544d <alltraps>
+
+801060e6 <vector204>:
+.globl vector204
+vector204:
+  pushl $0
+801060e6:	6a 00                	push   $0x0
+  pushl $204
+801060e8:	68 cc 00 00 00       	push   $0xcc
+  jmp alltraps
+801060ed:	e9 5b f3 ff ff       	jmp    8010544d <alltraps>
+
+801060f2 <vector205>:
+.globl vector205
+vector205:
+  pushl $0
+801060f2:	6a 00                	push   $0x0
+  pushl $205
+801060f4:	68 cd 00 00 00       	push   $0xcd
+  jmp alltraps
+801060f9:	e9 4f f3 ff ff       	jmp    8010544d <alltraps>
+
+801060fe <vector206>:
+.globl vector206
+vector206:
+  pushl $0
+801060fe:	6a 00                	push   $0x0
+  pushl $206
+80106100:	68 ce 00 00 00       	push   $0xce
+  jmp alltraps
+80106105:	e9 43 f3 ff ff       	jmp    8010544d <alltraps>
+
+8010610a <vector207>:
+.globl vector207
+vector207:
+  pushl $0
+8010610a:	6a 00                	push   $0x0
+  pushl $207
+8010610c:	68 cf 00 00 00       	push   $0xcf
+  jmp alltraps
+80106111:	e9 37 f3 ff ff       	jmp    8010544d <alltraps>
+
+80106116 <vector208>:
+.globl vector208
+vector208:
+  pushl $0
+80106116:	6a 00                	push   $0x0
+  pushl $208
+80106118:	68 d0 00 00 00       	push   $0xd0
+  jmp alltraps
+8010611d:	e9 2b f3 ff ff       	jmp    8010544d <alltraps>
+
+80106122 <vector209>:
+.globl vector209
+vector209:
+  pushl $0
+80106122:	6a 00                	push   $0x0
+  pushl $209
+80106124:	68 d1 00 00 00       	push   $0xd1
+  jmp alltraps
+80106129:	e9 1f f3 ff ff       	jmp    8010544d <alltraps>
+
+8010612e <vector210>:
+.globl vector210
+vector210:
+  pushl $0
+8010612e:	6a 00                	push   $0x0
+  pushl $210
+80106130:	68 d2 00 00 00       	push   $0xd2
+  jmp alltraps
+80106135:	e9 13 f3 ff ff       	jmp    8010544d <alltraps>
+
+8010613a <vector211>:
+.globl vector211
+vector211:
+  pushl $0
+8010613a:	6a 00                	push   $0x0
+  pushl $211
+8010613c:	68 d3 00 00 00       	push   $0xd3
+  jmp alltraps
+80106141:	e9 07 f3 ff ff       	jmp    8010544d <alltraps>
+
+80106146 <vector212>:
+.globl vector212
+vector212:
+  pushl $0
+80106146:	6a 00                	push   $0x0
+  pushl $212
+80106148:	68 d4 00 00 00       	push   $0xd4
+  jmp alltraps
+8010614d:	e9 fb f2 ff ff       	jmp    8010544d <alltraps>
+
+80106152 <vector213>:
+.globl vector213
+vector213:
+  pushl $0
+80106152:	6a 00                	push   $0x0
+  pushl $213
+80106154:	68 d5 00 00 00       	push   $0xd5
+  jmp alltraps
+80106159:	e9 ef f2 ff ff       	jmp    8010544d <alltraps>
+
+8010615e <vector214>:
+.globl vector214
+vector214:
+  pushl $0
+8010615e:	6a 00                	push   $0x0
+  pushl $214
+80106160:	68 d6 00 00 00       	push   $0xd6
+  jmp alltraps
+80106165:	e9 e3 f2 ff ff       	jmp    8010544d <alltraps>
+
+8010616a <vector215>:
+.globl vector215
+vector215:
+  pushl $0
+8010616a:	6a 00                	push   $0x0
+  pushl $215
+8010616c:	68 d7 00 00 00       	push   $0xd7
+  jmp alltraps
+80106171:	e9 d7 f2 ff ff       	jmp    8010544d <alltraps>
+
+80106176 <vector216>:
+.globl vector216
+vector216:
+  pushl $0
+80106176:	6a 00                	push   $0x0
+  pushl $216
+80106178:	68 d8 00 00 00       	push   $0xd8
+  jmp alltraps
+8010617d:	e9 cb f2 ff ff       	jmp    8010544d <alltraps>
+
+80106182 <vector217>:
+.globl vector217
+vector217:
+  pushl $0
+80106182:	6a 00                	push   $0x0
+  pushl $217
+80106184:	68 d9 00 00 00       	push   $0xd9
+  jmp alltraps
+80106189:	e9 bf f2 ff ff       	jmp    8010544d <alltraps>
+
+8010618e <vector218>:
+.globl vector218
+vector218:
+  pushl $0
+8010618e:	6a 00                	push   $0x0
+  pushl $218
+80106190:	68 da 00 00 00       	push   $0xda
+  jmp alltraps
+80106195:	e9 b3 f2 ff ff       	jmp    8010544d <alltraps>
+
+8010619a <vector219>:
+.globl vector219
+vector219:
+  pushl $0
+8010619a:	6a 00                	push   $0x0
+  pushl $219
+8010619c:	68 db 00 00 00       	push   $0xdb
+  jmp alltraps
+801061a1:	e9 a7 f2 ff ff       	jmp    8010544d <alltraps>
+
+801061a6 <vector220>:
+.globl vector220
+vector220:
+  pushl $0
+801061a6:	6a 00                	push   $0x0
+  pushl $220
+801061a8:	68 dc 00 00 00       	push   $0xdc
+  jmp alltraps
+801061ad:	e9 9b f2 ff ff       	jmp    8010544d <alltraps>
+
+801061b2 <vector221>:
+.globl vector221
+vector221:
+  pushl $0
+801061b2:	6a 00                	push   $0x0
+  pushl $221
+801061b4:	68 dd 00 00 00       	push   $0xdd
+  jmp alltraps
+801061b9:	e9 8f f2 ff ff       	jmp    8010544d <alltraps>
+
+801061be <vector222>:
+.globl vector222
+vector222:
+  pushl $0
+801061be:	6a 00                	push   $0x0
+  pushl $222
+801061c0:	68 de 00 00 00       	push   $0xde
+  jmp alltraps
+801061c5:	e9 83 f2 ff ff       	jmp    8010544d <alltraps>
+
+801061ca <vector223>:
+.globl vector223
+vector223:
+  pushl $0
+801061ca:	6a 00                	push   $0x0
+  pushl $223
+801061cc:	68 df 00 00 00       	push   $0xdf
+  jmp alltraps
+801061d1:	e9 77 f2 ff ff       	jmp    8010544d <alltraps>
+
+801061d6 <vector224>:
+.globl vector224
+vector224:
+  pushl $0
+801061d6:	6a 00                	push   $0x0
+  pushl $224
+801061d8:	68 e0 00 00 00       	push   $0xe0
+  jmp alltraps
+801061dd:	e9 6b f2 ff ff       	jmp    8010544d <alltraps>
+
+801061e2 <vector225>:
+.globl vector225
+vector225:
+  pushl $0
+801061e2:	6a 00                	push   $0x0
+  pushl $225
+801061e4:	68 e1 00 00 00       	push   $0xe1
+  jmp alltraps
+801061e9:	e9 5f f2 ff ff       	jmp    8010544d <alltraps>
+
+801061ee <vector226>:
+.globl vector226
+vector226:
+  pushl $0
+801061ee:	6a 00                	push   $0x0
+  pushl $226
+801061f0:	68 e2 00 00 00       	push   $0xe2
+  jmp alltraps
+801061f5:	e9 53 f2 ff ff       	jmp    8010544d <alltraps>
+
+801061fa <vector227>:
+.globl vector227
+vector227:
+  pushl $0
+801061fa:	6a 00                	push   $0x0
+  pushl $227
+801061fc:	68 e3 00 00 00       	push   $0xe3
+  jmp alltraps
+80106201:	e9 47 f2 ff ff       	jmp    8010544d <alltraps>
+
+80106206 <vector228>:
+.globl vector228
+vector228:
+  pushl $0
+80106206:	6a 00                	push   $0x0
+  pushl $228
+80106208:	68 e4 00 00 00       	push   $0xe4
+  jmp alltraps
+8010620d:	e9 3b f2 ff ff       	jmp    8010544d <alltraps>
+
+80106212 <vector229>:
+.globl vector229
+vector229:
+  pushl $0
+80106212:	6a 00                	push   $0x0
+  pushl $229
+80106214:	68 e5 00 00 00       	push   $0xe5
+  jmp alltraps
+80106219:	e9 2f f2 ff ff       	jmp    8010544d <alltraps>
+
+8010621e <vector230>:
+.globl vector230
+vector230:
+  pushl $0
+8010621e:	6a 00                	push   $0x0
+  pushl $230
+80106220:	68 e6 00 00 00       	push   $0xe6
+  jmp alltraps
+80106225:	e9 23 f2 ff ff       	jmp    8010544d <alltraps>
+
+8010622a <vector231>:
+.globl vector231
+vector231:
+  pushl $0
+8010622a:	6a 00                	push   $0x0
+  pushl $231
+8010622c:	68 e7 00 00 00       	push   $0xe7
+  jmp alltraps
+80106231:	e9 17 f2 ff ff       	jmp    8010544d <alltraps>
+
+80106236 <vector232>:
+.globl vector232
+vector232:
+  pushl $0
+80106236:	6a 00                	push   $0x0
+  pushl $232
+80106238:	68 e8 00 00 00       	push   $0xe8
+  jmp alltraps
+8010623d:	e9 0b f2 ff ff       	jmp    8010544d <alltraps>
+
+80106242 <vector233>:
+.globl vector233
+vector233:
+  pushl $0
+80106242:	6a 00                	push   $0x0
+  pushl $233
+80106244:	68 e9 00 00 00       	push   $0xe9
+  jmp alltraps
+80106249:	e9 ff f1 ff ff       	jmp    8010544d <alltraps>
+
+8010624e <vector234>:
+.globl vector234
+vector234:
+  pushl $0
+8010624e:	6a 00                	push   $0x0
+  pushl $234
+80106250:	68 ea 00 00 00       	push   $0xea
+  jmp alltraps
+80106255:	e9 f3 f1 ff ff       	jmp    8010544d <alltraps>
+
+8010625a <vector235>:
+.globl vector235
+vector235:
+  pushl $0
+8010625a:	6a 00                	push   $0x0
+  pushl $235
+8010625c:	68 eb 00 00 00       	push   $0xeb
+  jmp alltraps
+80106261:	e9 e7 f1 ff ff       	jmp    8010544d <alltraps>
+
+80106266 <vector236>:
+.globl vector236
+vector236:
+  pushl $0
+80106266:	6a 00                	push   $0x0
+  pushl $236
+80106268:	68 ec 00 00 00       	push   $0xec
+  jmp alltraps
+8010626d:	e9 db f1 ff ff       	jmp    8010544d <alltraps>
+
+80106272 <vector237>:
+.globl vector237
+vector237:
+  pushl $0
+80106272:	6a 00                	push   $0x0
+  pushl $237
+80106274:	68 ed 00 00 00       	push   $0xed
+  jmp alltraps
+80106279:	e9 cf f1 ff ff       	jmp    8010544d <alltraps>
+
+8010627e <vector238>:
+.globl vector238
+vector238:
+  pushl $0
+8010627e:	6a 00                	push   $0x0
+  pushl $238
+80106280:	68 ee 00 00 00       	push   $0xee
+  jmp alltraps
+80106285:	e9 c3 f1 ff ff       	jmp    8010544d <alltraps>
+
+8010628a <vector239>:
+.globl vector239
+vector239:
+  pushl $0
+8010628a:	6a 00                	push   $0x0
+  pushl $239
+8010628c:	68 ef 00 00 00       	push   $0xef
+  jmp alltraps
+80106291:	e9 b7 f1 ff ff       	jmp    8010544d <alltraps>
+
+80106296 <vector240>:
+.globl vector240
+vector240:
+  pushl $0
+80106296:	6a 00                	push   $0x0
+  pushl $240
+80106298:	68 f0 00 00 00       	push   $0xf0
+  jmp alltraps
+8010629d:	e9 ab f1 ff ff       	jmp    8010544d <alltraps>
+
+801062a2 <vector241>:
+.globl vector241
+vector241:
+  pushl $0
+801062a2:	6a 00                	push   $0x0
+  pushl $241
+801062a4:	68 f1 00 00 00       	push   $0xf1
+  jmp alltraps
+801062a9:	e9 9f f1 ff ff       	jmp    8010544d <alltraps>
+
+801062ae <vector242>:
+.globl vector242
+vector242:
+  pushl $0
+801062ae:	6a 00                	push   $0x0
+  pushl $242
+801062b0:	68 f2 00 00 00       	push   $0xf2
+  jmp alltraps
+801062b5:	e9 93 f1 ff ff       	jmp    8010544d <alltraps>
+
+801062ba <vector243>:
+.globl vector243
+vector243:
+  pushl $0
+801062ba:	6a 00                	push   $0x0
+  pushl $243
+801062bc:	68 f3 00 00 00       	push   $0xf3
+  jmp alltraps
+801062c1:	e9 87 f1 ff ff       	jmp    8010544d <alltraps>
+
+801062c6 <vector244>:
+.globl vector244
+vector244:
+  pushl $0
+801062c6:	6a 00                	push   $0x0
+  pushl $244
+801062c8:	68 f4 00 00 00       	push   $0xf4
+  jmp alltraps
+801062cd:	e9 7b f1 ff ff       	jmp    8010544d <alltraps>
+
+801062d2 <vector245>:
+.globl vector245
+vector245:
+  pushl $0
+801062d2:	6a 00                	push   $0x0
+  pushl $245
+801062d4:	68 f5 00 00 00       	push   $0xf5
+  jmp alltraps
+801062d9:	e9 6f f1 ff ff       	jmp    8010544d <alltraps>
+
+801062de <vector246>:
+.globl vector246
+vector246:
+  pushl $0
+801062de:	6a 00                	push   $0x0
+  pushl $246
+801062e0:	68 f6 00 00 00       	push   $0xf6
+  jmp alltraps
+801062e5:	e9 63 f1 ff ff       	jmp    8010544d <alltraps>
+
+801062ea <vector247>:
+.globl vector247
+vector247:
+  pushl $0
+801062ea:	6a 00                	push   $0x0
+  pushl $247
+801062ec:	68 f7 00 00 00       	push   $0xf7
+  jmp alltraps
+801062f1:	e9 57 f1 ff ff       	jmp    8010544d <alltraps>
+
+801062f6 <vector248>:
+.globl vector248
+vector248:
+  pushl $0
+801062f6:	6a 00                	push   $0x0
+  pushl $248
+801062f8:	68 f8 00 00 00       	push   $0xf8
+  jmp alltraps
+801062fd:	e9 4b f1 ff ff       	jmp    8010544d <alltraps>
+
+80106302 <vector249>:
+.globl vector249
+vector249:
+  pushl $0
+80106302:	6a 00                	push   $0x0
+  pushl $249
+80106304:	68 f9 00 00 00       	push   $0xf9
+  jmp alltraps
+80106309:	e9 3f f1 ff ff       	jmp    8010544d <alltraps>
+
+8010630e <vector250>:
+.globl vector250
+vector250:
+  pushl $0
+8010630e:	6a 00                	push   $0x0
+  pushl $250
+80106310:	68 fa 00 00 00       	push   $0xfa
+  jmp alltraps
+80106315:	e9 33 f1 ff ff       	jmp    8010544d <alltraps>
+
+8010631a <vector251>:
+.globl vector251
+vector251:
+  pushl $0
+8010631a:	6a 00                	push   $0x0
+  pushl $251
+8010631c:	68 fb 00 00 00       	push   $0xfb
+  jmp alltraps
+80106321:	e9 27 f1 ff ff       	jmp    8010544d <alltraps>
+
+80106326 <vector252>:
+.globl vector252
+vector252:
+  pushl $0
+80106326:	6a 00                	push   $0x0
+  pushl $252
+80106328:	68 fc 00 00 00       	push   $0xfc
+  jmp alltraps
+8010632d:	e9 1b f1 ff ff       	jmp    8010544d <alltraps>
+
+80106332 <vector253>:
+.globl vector253
+vector253:
+  pushl $0
+80106332:	6a 00                	push   $0x0
+  pushl $253
+80106334:	68 fd 00 00 00       	push   $0xfd
+  jmp alltraps
+80106339:	e9 0f f1 ff ff       	jmp    8010544d <alltraps>
+
+8010633e <vector254>:
+.globl vector254
+vector254:
+  pushl $0
+8010633e:	6a 00                	push   $0x0
+  pushl $254
+80106340:	68 fe 00 00 00       	push   $0xfe
+  jmp alltraps
+80106345:	e9 03 f1 ff ff       	jmp    8010544d <alltraps>
+
+8010634a <vector255>:
+.globl vector255
+vector255:
+  pushl $0
+8010634a:	6a 00                	push   $0x0
+  pushl $255
+8010634c:	68 ff 00 00 00       	push   $0xff
+  jmp alltraps
+80106351:	e9 f7 f0 ff ff       	jmp    8010544d <alltraps>
+80106356:	66 90                	xchg   %ax,%ax
+80106358:	66 90                	xchg   %ax,%ax
+8010635a:	66 90                	xchg   %ax,%ax
+8010635c:	66 90                	xchg   %ax,%ax
+8010635e:	66 90                	xchg   %ax,%ax
+
+80106360 <walkpgdir>:
+// Return the address of the PTE in page table pgdir
+// that corresponds to virtual address va.  If alloc!=0,
+// create any required page table pages.
+static pte_t *
+walkpgdir(pde_t *pgdir, const void *va, int alloc)
+{
+80106360:	55                   	push   %ebp
+80106361:	89 e5                	mov    %esp,%ebp
+80106363:	57                   	push   %edi
+80106364:	56                   	push   %esi
+80106365:	89 d6                	mov    %edx,%esi
+  pde_t *pde;
+  pte_t *pgtab;
+
+  pde = &pgdir[PDX(va)];
+80106367:	c1 ea 16             	shr    $0x16,%edx
+{
+8010636a:	53                   	push   %ebx
+  pde = &pgdir[PDX(va)];
+8010636b:	8d 3c 90             	lea    (%eax,%edx,4),%edi
+{
+8010636e:	83 ec 1c             	sub    $0x1c,%esp
+  if(*pde & PTE_P){
+80106371:	8b 1f                	mov    (%edi),%ebx
+80106373:	f6 c3 01             	test   $0x1,%bl
+80106376:	74 28                	je     801063a0 <walkpgdir+0x40>
+    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+80106378:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
+8010637e:	81 c3 00 00 00 80    	add    $0x80000000,%ebx
+    // The permissions here are overly generous, but they can
+    // be further restricted by the permissions in the page table
+    // entries, if necessary.
+    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+  }
+  return &pgtab[PTX(va)];
+80106384:	c1 ee 0a             	shr    $0xa,%esi
+}
+80106387:	83 c4 1c             	add    $0x1c,%esp
+  return &pgtab[PTX(va)];
+8010638a:	89 f2                	mov    %esi,%edx
+8010638c:	81 e2 fc 0f 00 00    	and    $0xffc,%edx
+80106392:	8d 04 13             	lea    (%ebx,%edx,1),%eax
+}
+80106395:	5b                   	pop    %ebx
+80106396:	5e                   	pop    %esi
+80106397:	5f                   	pop    %edi
+80106398:	5d                   	pop    %ebp
+80106399:	c3                   	ret    
+8010639a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+801063a0:	85 c9                	test   %ecx,%ecx
+801063a2:	74 34                	je     801063d8 <walkpgdir+0x78>
+801063a4:	e8 07 c1 ff ff       	call   801024b0 <kalloc>
+801063a9:	85 c0                	test   %eax,%eax
+801063ab:	89 c3                	mov    %eax,%ebx
+801063ad:	74 29                	je     801063d8 <walkpgdir+0x78>
+    memset(pgtab, 0, PGSIZE);
+801063af:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+801063b6:	00 
+801063b7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+801063be:	00 
+801063bf:	89 04 24             	mov    %eax,(%esp)
+801063c2:	e8 c9 de ff ff       	call   80104290 <memset>
+    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+801063c7:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
+801063cd:	83 c8 07             	or     $0x7,%eax
+801063d0:	89 07                	mov    %eax,(%edi)
+801063d2:	eb b0                	jmp    80106384 <walkpgdir+0x24>
+801063d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+}
+801063d8:	83 c4 1c             	add    $0x1c,%esp
+      return 0;
+801063db:	31 c0                	xor    %eax,%eax
+}
+801063dd:	5b                   	pop    %ebx
+801063de:	5e                   	pop    %esi
+801063df:	5f                   	pop    %edi
+801063e0:	5d                   	pop    %ebp
+801063e1:	c3                   	ret    
+801063e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801063e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801063f0 <deallocuvm.part.0>:
+// Deallocate user pages to bring the process size from oldsz to
+// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+// need to be less than oldsz.  oldsz can be larger than the actual
+// process size.  Returns the new process size.
+int
+deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+801063f0:	55                   	push   %ebp
+801063f1:	89 e5                	mov    %esp,%ebp
+801063f3:	57                   	push   %edi
+801063f4:	89 c7                	mov    %eax,%edi
+801063f6:	56                   	push   %esi
+801063f7:	89 d6                	mov    %edx,%esi
+801063f9:	53                   	push   %ebx
+  uint a, pa;
+
+  if(newsz >= oldsz)
+    return oldsz;
+
+  a = PGROUNDUP(newsz);
+801063fa:	8d 99 ff 0f 00 00    	lea    0xfff(%ecx),%ebx
+deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+80106400:	83 ec 1c             	sub    $0x1c,%esp
+  a = PGROUNDUP(newsz);
+80106403:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
+  for(; a  < oldsz; a += PGSIZE){
+80106409:	39 d3                	cmp    %edx,%ebx
+deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+8010640b:	89 4d e0             	mov    %ecx,-0x20(%ebp)
+  for(; a  < oldsz; a += PGSIZE){
+8010640e:	72 3b                	jb     8010644b <deallocuvm.part.0+0x5b>
+80106410:	eb 5e                	jmp    80106470 <deallocuvm.part.0+0x80>
+80106412:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    pte = walkpgdir(pgdir, (char*)a, 0);
+    if(!pte)
+      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+    else if((*pte & PTE_P) != 0){
+80106418:	8b 10                	mov    (%eax),%edx
+8010641a:	f6 c2 01             	test   $0x1,%dl
+8010641d:	74 22                	je     80106441 <deallocuvm.part.0+0x51>
+      pa = PTE_ADDR(*pte);
+      if(pa == 0)
+8010641f:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
+80106425:	74 54                	je     8010647b <deallocuvm.part.0+0x8b>
+        panic("kfree");
+      char *v = P2V(pa);
+80106427:	81 c2 00 00 00 80    	add    $0x80000000,%edx
+      kfree(v);
+8010642d:	89 14 24             	mov    %edx,(%esp)
+80106430:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80106433:	e8 c8 be ff ff       	call   80102300 <kfree>
+      *pte = 0;
+80106438:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+8010643b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  for(; a  < oldsz; a += PGSIZE){
+80106441:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+80106447:	39 f3                	cmp    %esi,%ebx
+80106449:	73 25                	jae    80106470 <deallocuvm.part.0+0x80>
+    pte = walkpgdir(pgdir, (char*)a, 0);
+8010644b:	31 c9                	xor    %ecx,%ecx
+8010644d:	89 da                	mov    %ebx,%edx
+8010644f:	89 f8                	mov    %edi,%eax
+80106451:	e8 0a ff ff ff       	call   80106360 <walkpgdir>
+    if(!pte)
+80106456:	85 c0                	test   %eax,%eax
+80106458:	75 be                	jne    80106418 <deallocuvm.part.0+0x28>
+      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+8010645a:	81 e3 00 00 c0 ff    	and    $0xffc00000,%ebx
+80106460:	81 c3 00 f0 3f 00    	add    $0x3ff000,%ebx
+  for(; a  < oldsz; a += PGSIZE){
+80106466:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+8010646c:	39 f3                	cmp    %esi,%ebx
+8010646e:	72 db                	jb     8010644b <deallocuvm.part.0+0x5b>
+    }
+  }
+  return newsz;
+}
+80106470:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80106473:	83 c4 1c             	add    $0x1c,%esp
+80106476:	5b                   	pop    %ebx
+80106477:	5e                   	pop    %esi
+80106478:	5f                   	pop    %edi
+80106479:	5d                   	pop    %ebp
+8010647a:	c3                   	ret    
+        panic("kfree");
+8010647b:	c7 04 24 86 6f 10 80 	movl   $0x80106f86,(%esp)
+80106482:	e8 d9 9e ff ff       	call   80100360 <panic>
+80106487:	89 f6                	mov    %esi,%esi
+80106489:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80106490 <seginit>:
+{
+80106490:	55                   	push   %ebp
+80106491:	89 e5                	mov    %esp,%ebp
+80106493:	83 ec 18             	sub    $0x18,%esp
+  c = &cpus[cpuid()];
+80106496:	e8 f5 d1 ff ff       	call   80103690 <cpuid>
+  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+8010649b:	31 c9                	xor    %ecx,%ecx
+8010649d:	ba ff ff ff ff       	mov    $0xffffffff,%edx
+  c = &cpus[cpuid()];
+801064a2:	69 c0 b0 00 00 00    	imul   $0xb0,%eax,%eax
+801064a8:	05 80 27 11 80       	add    $0x80112780,%eax
+  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+801064ad:	66 89 50 78          	mov    %dx,0x78(%eax)
+  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+801064b1:	ba ff ff ff ff       	mov    $0xffffffff,%edx
+  lgdt(c->gdt, sizeof(c->gdt));
+801064b6:	83 c0 70             	add    $0x70,%eax
+  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+801064b9:	66 89 48 0a          	mov    %cx,0xa(%eax)
+  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+801064bd:	31 c9                	xor    %ecx,%ecx
+801064bf:	66 89 50 10          	mov    %dx,0x10(%eax)
+  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+801064c3:	ba ff ff ff ff       	mov    $0xffffffff,%edx
+  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+801064c8:	66 89 48 12          	mov    %cx,0x12(%eax)
+  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+801064cc:	31 c9                	xor    %ecx,%ecx
+801064ce:	66 89 50 18          	mov    %dx,0x18(%eax)
+  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+801064d2:	ba ff ff ff ff       	mov    $0xffffffff,%edx
+  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+801064d7:	66 89 48 1a          	mov    %cx,0x1a(%eax)
+  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+801064db:	31 c9                	xor    %ecx,%ecx
+  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+801064dd:	c6 40 0d 9a          	movb   $0x9a,0xd(%eax)
+801064e1:	c6 40 0e cf          	movb   $0xcf,0xe(%eax)
+  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+801064e5:	c6 40 15 92          	movb   $0x92,0x15(%eax)
+801064e9:	c6 40 16 cf          	movb   $0xcf,0x16(%eax)
+  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+801064ed:	c6 40 1d fa          	movb   $0xfa,0x1d(%eax)
+801064f1:	c6 40 1e cf          	movb   $0xcf,0x1e(%eax)
+  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+801064f5:	c6 40 25 f2          	movb   $0xf2,0x25(%eax)
+801064f9:	c6 40 26 cf          	movb   $0xcf,0x26(%eax)
+801064fd:	66 89 50 20          	mov    %dx,0x20(%eax)
+  pd[0] = size-1;
+80106501:	ba 2f 00 00 00       	mov    $0x2f,%edx
+  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+80106506:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
+8010650a:	c6 40 0f 00          	movb   $0x0,0xf(%eax)
+  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+8010650e:	c6 40 14 00          	movb   $0x0,0x14(%eax)
+80106512:	c6 40 17 00          	movb   $0x0,0x17(%eax)
+  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+80106516:	c6 40 1c 00          	movb   $0x0,0x1c(%eax)
+8010651a:	c6 40 1f 00          	movb   $0x0,0x1f(%eax)
+  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+8010651e:	66 89 48 22          	mov    %cx,0x22(%eax)
+80106522:	c6 40 24 00          	movb   $0x0,0x24(%eax)
+80106526:	c6 40 27 00          	movb   $0x0,0x27(%eax)
+8010652a:	66 89 55 f2          	mov    %dx,-0xe(%ebp)
+  pd[1] = (uint)p;
+8010652e:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
+  pd[2] = (uint)p >> 16;
+80106532:	c1 e8 10             	shr    $0x10,%eax
+80106535:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
+  asm volatile("lgdt (%0)" : : "r" (pd));
+80106539:	8d 45 f2             	lea    -0xe(%ebp),%eax
+8010653c:	0f 01 10             	lgdtl  (%eax)
+}
+8010653f:	c9                   	leave  
+80106540:	c3                   	ret    
+80106541:	eb 0d                	jmp    80106550 <mappages>
+80106543:	90                   	nop
+80106544:	90                   	nop
+80106545:	90                   	nop
+80106546:	90                   	nop
+80106547:	90                   	nop
+80106548:	90                   	nop
+80106549:	90                   	nop
+8010654a:	90                   	nop
+8010654b:	90                   	nop
+8010654c:	90                   	nop
+8010654d:	90                   	nop
+8010654e:	90                   	nop
+8010654f:	90                   	nop
+
+80106550 <mappages>:
+{
+80106550:	55                   	push   %ebp
+80106551:	89 e5                	mov    %esp,%ebp
+80106553:	57                   	push   %edi
+80106554:	56                   	push   %esi
+80106555:	53                   	push   %ebx
+80106556:	83 ec 1c             	sub    $0x1c,%esp
+80106559:	8b 45 0c             	mov    0xc(%ebp),%eax
+  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+8010655c:	8b 55 10             	mov    0x10(%ebp),%edx
+{
+8010655f:	8b 7d 14             	mov    0x14(%ebp),%edi
+    *pte = pa | perm | PTE_P;
+80106562:	83 4d 18 01          	orl    $0x1,0x18(%ebp)
+  a = (char*)PGROUNDDOWN((uint)va);
+80106566:	89 c3                	mov    %eax,%ebx
+80106568:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
+  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+8010656e:	8d 44 10 ff          	lea    -0x1(%eax,%edx,1),%eax
+80106572:	29 df                	sub    %ebx,%edi
+80106574:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80106577:	81 65 e4 00 f0 ff ff 	andl   $0xfffff000,-0x1c(%ebp)
+8010657e:	eb 15                	jmp    80106595 <mappages+0x45>
+    if(*pte & PTE_P)
+80106580:	f6 00 01             	testb  $0x1,(%eax)
+80106583:	75 3d                	jne    801065c2 <mappages+0x72>
+    *pte = pa | perm | PTE_P;
+80106585:	0b 75 18             	or     0x18(%ebp),%esi
+    if(a == last)
+80106588:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
+    *pte = pa | perm | PTE_P;
+8010658b:	89 30                	mov    %esi,(%eax)
+    if(a == last)
+8010658d:	74 29                	je     801065b8 <mappages+0x68>
+    a += PGSIZE;
+8010658f:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+    if((pte = walkpgdir(pgdir, a, 1)) == 0)
+80106595:	8b 45 08             	mov    0x8(%ebp),%eax
+80106598:	b9 01 00 00 00       	mov    $0x1,%ecx
+8010659d:	89 da                	mov    %ebx,%edx
+8010659f:	8d 34 3b             	lea    (%ebx,%edi,1),%esi
+801065a2:	e8 b9 fd ff ff       	call   80106360 <walkpgdir>
+801065a7:	85 c0                	test   %eax,%eax
+801065a9:	75 d5                	jne    80106580 <mappages+0x30>
+}
+801065ab:	83 c4 1c             	add    $0x1c,%esp
+      return -1;
+801065ae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801065b3:	5b                   	pop    %ebx
+801065b4:	5e                   	pop    %esi
+801065b5:	5f                   	pop    %edi
+801065b6:	5d                   	pop    %ebp
+801065b7:	c3                   	ret    
+801065b8:	83 c4 1c             	add    $0x1c,%esp
+  return 0;
+801065bb:	31 c0                	xor    %eax,%eax
+}
+801065bd:	5b                   	pop    %ebx
+801065be:	5e                   	pop    %esi
+801065bf:	5f                   	pop    %edi
+801065c0:	5d                   	pop    %ebp
+801065c1:	c3                   	ret    
+      panic("remap");
+801065c2:	c7 04 24 f0 75 10 80 	movl   $0x801075f0,(%esp)
+801065c9:	e8 92 9d ff ff       	call   80100360 <panic>
+801065ce:	66 90                	xchg   %ax,%ax
+
+801065d0 <switchkvm>:
+  lcr3(V2P(kpgdir));   // switch to the kernel page table
+801065d0:	a1 a4 54 11 80       	mov    0x801154a4,%eax
+{
+801065d5:	55                   	push   %ebp
+801065d6:	89 e5                	mov    %esp,%ebp
+  lcr3(V2P(kpgdir));   // switch to the kernel page table
+801065d8:	05 00 00 00 80       	add    $0x80000000,%eax
+}
+
+static inline void
+lcr3(uint val)
+{
+  asm volatile("movl %0,%%cr3" : : "r" (val));
+801065dd:	0f 22 d8             	mov    %eax,%cr3
+}
+801065e0:	5d                   	pop    %ebp
+801065e1:	c3                   	ret    
+801065e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801065e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+801065f0 <switchuvm>:
+{
+801065f0:	55                   	push   %ebp
+801065f1:	89 e5                	mov    %esp,%ebp
+801065f3:	57                   	push   %edi
+801065f4:	56                   	push   %esi
+801065f5:	53                   	push   %ebx
+801065f6:	83 ec 1c             	sub    $0x1c,%esp
+801065f9:	8b 75 08             	mov    0x8(%ebp),%esi
+  if(p == 0)
+801065fc:	85 f6                	test   %esi,%esi
+801065fe:	0f 84 cd 00 00 00    	je     801066d1 <switchuvm+0xe1>
+  if(p->kstack == 0)
+80106604:	8b 46 08             	mov    0x8(%esi),%eax
+80106607:	85 c0                	test   %eax,%eax
+80106609:	0f 84 da 00 00 00    	je     801066e9 <switchuvm+0xf9>
+  if(p->pgdir == 0)
+8010660f:	8b 7e 04             	mov    0x4(%esi),%edi
+80106612:	85 ff                	test   %edi,%edi
+80106614:	0f 84 c3 00 00 00    	je     801066dd <switchuvm+0xed>
+  pushcli();
+8010661a:	e8 f1 da ff ff       	call   80104110 <pushcli>
+  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
+8010661f:	e8 ec cf ff ff       	call   80103610 <mycpu>
+80106624:	89 c3                	mov    %eax,%ebx
+80106626:	e8 e5 cf ff ff       	call   80103610 <mycpu>
+8010662b:	89 c7                	mov    %eax,%edi
+8010662d:	e8 de cf ff ff       	call   80103610 <mycpu>
+80106632:	83 c7 08             	add    $0x8,%edi
+80106635:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80106638:	e8 d3 cf ff ff       	call   80103610 <mycpu>
+8010663d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+80106640:	ba 67 00 00 00       	mov    $0x67,%edx
+80106645:	66 89 93 98 00 00 00 	mov    %dx,0x98(%ebx)
+8010664c:	66 89 bb 9a 00 00 00 	mov    %di,0x9a(%ebx)
+80106653:	c6 83 9d 00 00 00 99 	movb   $0x99,0x9d(%ebx)
+8010665a:	83 c1 08             	add    $0x8,%ecx
+8010665d:	c1 e9 10             	shr    $0x10,%ecx
+80106660:	83 c0 08             	add    $0x8,%eax
+80106663:	c1 e8 18             	shr    $0x18,%eax
+80106666:	88 8b 9c 00 00 00    	mov    %cl,0x9c(%ebx)
+8010666c:	c6 83 9e 00 00 00 40 	movb   $0x40,0x9e(%ebx)
+80106673:	88 83 9f 00 00 00    	mov    %al,0x9f(%ebx)
+  mycpu()->ts.iomb = (ushort) 0xFFFF;
+80106679:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
+  mycpu()->gdt[SEG_TSS].s = 0;
+8010667e:	e8 8d cf ff ff       	call   80103610 <mycpu>
+80106683:	80 a0 9d 00 00 00 ef 	andb   $0xef,0x9d(%eax)
+  mycpu()->ts.ss0 = SEG_KDATA << 3;
+8010668a:	e8 81 cf ff ff       	call   80103610 <mycpu>
+8010668f:	b9 10 00 00 00       	mov    $0x10,%ecx
+80106694:	66 89 48 10          	mov    %cx,0x10(%eax)
+  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+80106698:	e8 73 cf ff ff       	call   80103610 <mycpu>
+8010669d:	8b 56 08             	mov    0x8(%esi),%edx
+801066a0:	8d 8a 00 10 00 00    	lea    0x1000(%edx),%ecx
+801066a6:	89 48 0c             	mov    %ecx,0xc(%eax)
+  mycpu()->ts.iomb = (ushort) 0xFFFF;
+801066a9:	e8 62 cf ff ff       	call   80103610 <mycpu>
+801066ae:	66 89 58 6e          	mov    %bx,0x6e(%eax)
+  asm volatile("ltr %0" : : "r" (sel));
+801066b2:	b8 28 00 00 00       	mov    $0x28,%eax
+801066b7:	0f 00 d8             	ltr    %ax
+  lcr3(V2P(p->pgdir));  // switch to process's address space
+801066ba:	8b 46 04             	mov    0x4(%esi),%eax
+801066bd:	05 00 00 00 80       	add    $0x80000000,%eax
+  asm volatile("movl %0,%%cr3" : : "r" (val));
+801066c2:	0f 22 d8             	mov    %eax,%cr3
+}
+801066c5:	83 c4 1c             	add    $0x1c,%esp
+801066c8:	5b                   	pop    %ebx
+801066c9:	5e                   	pop    %esi
+801066ca:	5f                   	pop    %edi
+801066cb:	5d                   	pop    %ebp
+  popcli();
+801066cc:	e9 ff da ff ff       	jmp    801041d0 <popcli>
+    panic("switchuvm: no process");
+801066d1:	c7 04 24 f6 75 10 80 	movl   $0x801075f6,(%esp)
+801066d8:	e8 83 9c ff ff       	call   80100360 <panic>
+    panic("switchuvm: no pgdir");
+801066dd:	c7 04 24 21 76 10 80 	movl   $0x80107621,(%esp)
+801066e4:	e8 77 9c ff ff       	call   80100360 <panic>
+    panic("switchuvm: no kstack");
+801066e9:	c7 04 24 0c 76 10 80 	movl   $0x8010760c,(%esp)
+801066f0:	e8 6b 9c ff ff       	call   80100360 <panic>
+801066f5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801066f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80106700 <inituvm>:
+{
+80106700:	55                   	push   %ebp
+80106701:	89 e5                	mov    %esp,%ebp
+80106703:	57                   	push   %edi
+80106704:	56                   	push   %esi
+80106705:	53                   	push   %ebx
+80106706:	83 ec 2c             	sub    $0x2c,%esp
+80106709:	8b 75 10             	mov    0x10(%ebp),%esi
+8010670c:	8b 55 08             	mov    0x8(%ebp),%edx
+8010670f:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  if(sz >= PGSIZE)
+80106712:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
+80106718:	77 64                	ja     8010677e <inituvm+0x7e>
+8010671a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  mem = kalloc();
+8010671d:	e8 8e bd ff ff       	call   801024b0 <kalloc>
+  memset(mem, 0, PGSIZE);
+80106722:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+80106729:	00 
+8010672a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80106731:	00 
+80106732:	89 04 24             	mov    %eax,(%esp)
+  mem = kalloc();
+80106735:	89 c3                	mov    %eax,%ebx
+  memset(mem, 0, PGSIZE);
+80106737:	e8 54 db ff ff       	call   80104290 <memset>
+  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
+8010673c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+8010673f:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
+80106745:	c7 44 24 10 06 00 00 	movl   $0x6,0x10(%esp)
+8010674c:	00 
+8010674d:	89 44 24 0c          	mov    %eax,0xc(%esp)
+80106751:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+80106758:	00 
+80106759:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80106760:	00 
+80106761:	89 14 24             	mov    %edx,(%esp)
+80106764:	e8 e7 fd ff ff       	call   80106550 <mappages>
+  memmove(mem, init, sz);
+80106769:	89 75 10             	mov    %esi,0x10(%ebp)
+8010676c:	89 7d 0c             	mov    %edi,0xc(%ebp)
+8010676f:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+80106772:	83 c4 2c             	add    $0x2c,%esp
+80106775:	5b                   	pop    %ebx
+80106776:	5e                   	pop    %esi
+80106777:	5f                   	pop    %edi
+80106778:	5d                   	pop    %ebp
+  memmove(mem, init, sz);
+80106779:	e9 b2 db ff ff       	jmp    80104330 <memmove>
+    panic("inituvm: more than a page");
+8010677e:	c7 04 24 35 76 10 80 	movl   $0x80107635,(%esp)
+80106785:	e8 d6 9b ff ff       	call   80100360 <panic>
+8010678a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80106790 <loaduvm>:
+{
+80106790:	55                   	push   %ebp
+80106791:	89 e5                	mov    %esp,%ebp
+80106793:	57                   	push   %edi
+80106794:	56                   	push   %esi
+80106795:	53                   	push   %ebx
+80106796:	83 ec 1c             	sub    $0x1c,%esp
+  if((uint) addr % PGSIZE != 0)
+80106799:	f7 45 0c ff 0f 00 00 	testl  $0xfff,0xc(%ebp)
+801067a0:	0f 85 98 00 00 00    	jne    8010683e <loaduvm+0xae>
+  for(i = 0; i < sz; i += PGSIZE){
+801067a6:	8b 75 18             	mov    0x18(%ebp),%esi
+801067a9:	31 db                	xor    %ebx,%ebx
+801067ab:	85 f6                	test   %esi,%esi
+801067ad:	75 1a                	jne    801067c9 <loaduvm+0x39>
+801067af:	eb 77                	jmp    80106828 <loaduvm+0x98>
+801067b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801067b8:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+801067be:	81 ee 00 10 00 00    	sub    $0x1000,%esi
+801067c4:	39 5d 18             	cmp    %ebx,0x18(%ebp)
+801067c7:	76 5f                	jbe    80106828 <loaduvm+0x98>
+801067c9:	8b 55 0c             	mov    0xc(%ebp),%edx
+    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
+801067cc:	31 c9                	xor    %ecx,%ecx
+801067ce:	8b 45 08             	mov    0x8(%ebp),%eax
+801067d1:	01 da                	add    %ebx,%edx
+801067d3:	e8 88 fb ff ff       	call   80106360 <walkpgdir>
+801067d8:	85 c0                	test   %eax,%eax
+801067da:	74 56                	je     80106832 <loaduvm+0xa2>
+    pa = PTE_ADDR(*pte);
+801067dc:	8b 00                	mov    (%eax),%eax
+      n = PGSIZE;
+801067de:	bf 00 10 00 00       	mov    $0x1000,%edi
+801067e3:	8b 4d 14             	mov    0x14(%ebp),%ecx
+    pa = PTE_ADDR(*pte);
+801067e6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+      n = PGSIZE;
+801067eb:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+801067f1:	0f 42 fe             	cmovb  %esi,%edi
+    if(readi(ip, P2V(pa), offset+i, n) != n)
+801067f4:	05 00 00 00 80       	add    $0x80000000,%eax
+801067f9:	89 44 24 04          	mov    %eax,0x4(%esp)
+801067fd:	8b 45 10             	mov    0x10(%ebp),%eax
+80106800:	01 d9                	add    %ebx,%ecx
+80106802:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+80106806:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+8010680a:	89 04 24             	mov    %eax,(%esp)
+8010680d:	e8 5e b1 ff ff       	call   80101970 <readi>
+80106812:	39 f8                	cmp    %edi,%eax
+80106814:	74 a2                	je     801067b8 <loaduvm+0x28>
+}
+80106816:	83 c4 1c             	add    $0x1c,%esp
+      return -1;
+80106819:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+8010681e:	5b                   	pop    %ebx
+8010681f:	5e                   	pop    %esi
+80106820:	5f                   	pop    %edi
+80106821:	5d                   	pop    %ebp
+80106822:	c3                   	ret    
+80106823:	90                   	nop
+80106824:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80106828:	83 c4 1c             	add    $0x1c,%esp
+  return 0;
+8010682b:	31 c0                	xor    %eax,%eax
+}
+8010682d:	5b                   	pop    %ebx
+8010682e:	5e                   	pop    %esi
+8010682f:	5f                   	pop    %edi
+80106830:	5d                   	pop    %ebp
+80106831:	c3                   	ret    
+      panic("loaduvm: address should exist");
+80106832:	c7 04 24 4f 76 10 80 	movl   $0x8010764f,(%esp)
+80106839:	e8 22 9b ff ff       	call   80100360 <panic>
+    panic("loaduvm: addr must be page aligned");
+8010683e:	c7 04 24 f0 76 10 80 	movl   $0x801076f0,(%esp)
+80106845:	e8 16 9b ff ff       	call   80100360 <panic>
+8010684a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80106850 <allocuvm>:
+{
+80106850:	55                   	push   %ebp
+80106851:	89 e5                	mov    %esp,%ebp
+80106853:	57                   	push   %edi
+80106854:	56                   	push   %esi
+80106855:	53                   	push   %ebx
+80106856:	83 ec 2c             	sub    $0x2c,%esp
+80106859:	8b 7d 10             	mov    0x10(%ebp),%edi
+  if(newsz >= KERNBASE)
+8010685c:	85 ff                	test   %edi,%edi
+8010685e:	0f 88 8f 00 00 00    	js     801068f3 <allocuvm+0xa3>
+  if(newsz < oldsz)
+80106864:	3b 7d 0c             	cmp    0xc(%ebp),%edi
+    return oldsz;
+80106867:	8b 45 0c             	mov    0xc(%ebp),%eax
+  if(newsz < oldsz)
+8010686a:	0f 82 85 00 00 00    	jb     801068f5 <allocuvm+0xa5>
+  a = PGROUNDUP(oldsz);
+80106870:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
+80106876:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
+  for(; a < newsz; a += PGSIZE){
+8010687c:	39 df                	cmp    %ebx,%edi
+8010687e:	77 57                	ja     801068d7 <allocuvm+0x87>
+80106880:	eb 7e                	jmp    80106900 <allocuvm+0xb0>
+80106882:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    memset(mem, 0, PGSIZE);
+80106888:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+8010688f:	00 
+80106890:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80106897:	00 
+80106898:	89 04 24             	mov    %eax,(%esp)
+8010689b:	e8 f0 d9 ff ff       	call   80104290 <memset>
+    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
+801068a0:	8d 86 00 00 00 80    	lea    -0x80000000(%esi),%eax
+801068a6:	89 44 24 0c          	mov    %eax,0xc(%esp)
+801068aa:	8b 45 08             	mov    0x8(%ebp),%eax
+801068ad:	c7 44 24 10 06 00 00 	movl   $0x6,0x10(%esp)
+801068b4:	00 
+801068b5:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+801068bc:	00 
+801068bd:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+801068c1:	89 04 24             	mov    %eax,(%esp)
+801068c4:	e8 87 fc ff ff       	call   80106550 <mappages>
+801068c9:	85 c0                	test   %eax,%eax
+801068cb:	78 43                	js     80106910 <allocuvm+0xc0>
+  for(; a < newsz; a += PGSIZE){
+801068cd:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+801068d3:	39 df                	cmp    %ebx,%edi
+801068d5:	76 29                	jbe    80106900 <allocuvm+0xb0>
+    mem = kalloc();
+801068d7:	e8 d4 bb ff ff       	call   801024b0 <kalloc>
+    if(mem == 0){
+801068dc:	85 c0                	test   %eax,%eax
+    mem = kalloc();
+801068de:	89 c6                	mov    %eax,%esi
+    if(mem == 0){
+801068e0:	75 a6                	jne    80106888 <allocuvm+0x38>
+      cprintf("allocuvm out of memory\n");
+801068e2:	c7 04 24 6d 76 10 80 	movl   $0x8010766d,(%esp)
+801068e9:	e8 62 9d ff ff       	call   80100650 <cprintf>
+  if(newsz >= oldsz)
+801068ee:	3b 7d 0c             	cmp    0xc(%ebp),%edi
+801068f1:	77 47                	ja     8010693a <allocuvm+0xea>
+      return 0;
+801068f3:	31 c0                	xor    %eax,%eax
+}
+801068f5:	83 c4 2c             	add    $0x2c,%esp
+801068f8:	5b                   	pop    %ebx
+801068f9:	5e                   	pop    %esi
+801068fa:	5f                   	pop    %edi
+801068fb:	5d                   	pop    %ebp
+801068fc:	c3                   	ret    
+801068fd:	8d 76 00             	lea    0x0(%esi),%esi
+80106900:	83 c4 2c             	add    $0x2c,%esp
+80106903:	89 f8                	mov    %edi,%eax
+80106905:	5b                   	pop    %ebx
+80106906:	5e                   	pop    %esi
+80106907:	5f                   	pop    %edi
+80106908:	5d                   	pop    %ebp
+80106909:	c3                   	ret    
+8010690a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      cprintf("allocuvm out of memory (2)\n");
+80106910:	c7 04 24 85 76 10 80 	movl   $0x80107685,(%esp)
+80106917:	e8 34 9d ff ff       	call   80100650 <cprintf>
+  if(newsz >= oldsz)
+8010691c:	3b 7d 0c             	cmp    0xc(%ebp),%edi
+8010691f:	76 0d                	jbe    8010692e <allocuvm+0xde>
+80106921:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+80106924:	89 fa                	mov    %edi,%edx
+80106926:	8b 45 08             	mov    0x8(%ebp),%eax
+80106929:	e8 c2 fa ff ff       	call   801063f0 <deallocuvm.part.0>
+      kfree(mem);
+8010692e:	89 34 24             	mov    %esi,(%esp)
+80106931:	e8 ca b9 ff ff       	call   80102300 <kfree>
+      return 0;
+80106936:	31 c0                	xor    %eax,%eax
+80106938:	eb bb                	jmp    801068f5 <allocuvm+0xa5>
+8010693a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+8010693d:	89 fa                	mov    %edi,%edx
+8010693f:	8b 45 08             	mov    0x8(%ebp),%eax
+80106942:	e8 a9 fa ff ff       	call   801063f0 <deallocuvm.part.0>
+      return 0;
+80106947:	31 c0                	xor    %eax,%eax
+80106949:	eb aa                	jmp    801068f5 <allocuvm+0xa5>
+8010694b:	90                   	nop
+8010694c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80106950 <deallocuvm>:
+{
+80106950:	55                   	push   %ebp
+80106951:	89 e5                	mov    %esp,%ebp
+80106953:	8b 55 0c             	mov    0xc(%ebp),%edx
+80106956:	8b 4d 10             	mov    0x10(%ebp),%ecx
+80106959:	8b 45 08             	mov    0x8(%ebp),%eax
+  if(newsz >= oldsz)
+8010695c:	39 d1                	cmp    %edx,%ecx
+8010695e:	73 08                	jae    80106968 <deallocuvm+0x18>
+}
+80106960:	5d                   	pop    %ebp
+80106961:	e9 8a fa ff ff       	jmp    801063f0 <deallocuvm.part.0>
+80106966:	66 90                	xchg   %ax,%ax
+80106968:	89 d0                	mov    %edx,%eax
+8010696a:	5d                   	pop    %ebp
+8010696b:	c3                   	ret    
+8010696c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80106970 <freevm>:
+
+// Free a page table and all the physical memory pages
+// in the user part.
+void
+freevm(pde_t *pgdir)
+{
+80106970:	55                   	push   %ebp
+80106971:	89 e5                	mov    %esp,%ebp
+80106973:	56                   	push   %esi
+80106974:	53                   	push   %ebx
+80106975:	83 ec 10             	sub    $0x10,%esp
+80106978:	8b 75 08             	mov    0x8(%ebp),%esi
+  uint i;
+
+  if(pgdir == 0)
+8010697b:	85 f6                	test   %esi,%esi
+8010697d:	74 59                	je     801069d8 <freevm+0x68>
+8010697f:	31 c9                	xor    %ecx,%ecx
+80106981:	ba 00 00 00 80       	mov    $0x80000000,%edx
+80106986:	89 f0                	mov    %esi,%eax
+    panic("freevm: no pgdir");
+  deallocuvm(pgdir, KERNBASE, 0);
+  for(i = 0; i < NPDENTRIES; i++){
+80106988:	31 db                	xor    %ebx,%ebx
+8010698a:	e8 61 fa ff ff       	call   801063f0 <deallocuvm.part.0>
+8010698f:	eb 12                	jmp    801069a3 <freevm+0x33>
+80106991:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80106998:	83 c3 01             	add    $0x1,%ebx
+8010699b:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
+801069a1:	74 27                	je     801069ca <freevm+0x5a>
+    if(pgdir[i] & PTE_P){
+801069a3:	8b 14 9e             	mov    (%esi,%ebx,4),%edx
+801069a6:	f6 c2 01             	test   $0x1,%dl
+801069a9:	74 ed                	je     80106998 <freevm+0x28>
+      char * v = P2V(PTE_ADDR(pgdir[i]));
+801069ab:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
+  for(i = 0; i < NPDENTRIES; i++){
+801069b1:	83 c3 01             	add    $0x1,%ebx
+      char * v = P2V(PTE_ADDR(pgdir[i]));
+801069b4:	81 c2 00 00 00 80    	add    $0x80000000,%edx
+      kfree(v);
+801069ba:	89 14 24             	mov    %edx,(%esp)
+801069bd:	e8 3e b9 ff ff       	call   80102300 <kfree>
+  for(i = 0; i < NPDENTRIES; i++){
+801069c2:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
+801069c8:	75 d9                	jne    801069a3 <freevm+0x33>
+    }
+  }
+  kfree((char*)pgdir);
+801069ca:	89 75 08             	mov    %esi,0x8(%ebp)
+}
+801069cd:	83 c4 10             	add    $0x10,%esp
+801069d0:	5b                   	pop    %ebx
+801069d1:	5e                   	pop    %esi
+801069d2:	5d                   	pop    %ebp
+  kfree((char*)pgdir);
+801069d3:	e9 28 b9 ff ff       	jmp    80102300 <kfree>
+    panic("freevm: no pgdir");
+801069d8:	c7 04 24 a1 76 10 80 	movl   $0x801076a1,(%esp)
+801069df:	e8 7c 99 ff ff       	call   80100360 <panic>
+801069e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+801069ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+801069f0 <setupkvm>:
+{
+801069f0:	55                   	push   %ebp
+801069f1:	89 e5                	mov    %esp,%ebp
+801069f3:	56                   	push   %esi
+801069f4:	53                   	push   %ebx
+801069f5:	83 ec 20             	sub    $0x20,%esp
+  if((pgdir = (pde_t*)kalloc()) == 0)
+801069f8:	e8 b3 ba ff ff       	call   801024b0 <kalloc>
+801069fd:	85 c0                	test   %eax,%eax
+801069ff:	89 c6                	mov    %eax,%esi
+80106a01:	74 75                	je     80106a78 <setupkvm+0x88>
+  memset(pgdir, 0, PGSIZE);
+80106a03:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+80106a0a:	00 
+  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+80106a0b:	bb 20 a4 10 80       	mov    $0x8010a420,%ebx
+  memset(pgdir, 0, PGSIZE);
+80106a10:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+80106a17:	00 
+80106a18:	89 04 24             	mov    %eax,(%esp)
+80106a1b:	e8 70 d8 ff ff       	call   80104290 <memset>
+    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+80106a20:	8b 53 0c             	mov    0xc(%ebx),%edx
+80106a23:	8b 43 04             	mov    0x4(%ebx),%eax
+80106a26:	89 34 24             	mov    %esi,(%esp)
+80106a29:	89 54 24 10          	mov    %edx,0x10(%esp)
+80106a2d:	8b 53 08             	mov    0x8(%ebx),%edx
+80106a30:	89 44 24 0c          	mov    %eax,0xc(%esp)
+80106a34:	29 c2                	sub    %eax,%edx
+80106a36:	8b 03                	mov    (%ebx),%eax
+80106a38:	89 54 24 08          	mov    %edx,0x8(%esp)
+80106a3c:	89 44 24 04          	mov    %eax,0x4(%esp)
+80106a40:	e8 0b fb ff ff       	call   80106550 <mappages>
+80106a45:	85 c0                	test   %eax,%eax
+80106a47:	78 17                	js     80106a60 <setupkvm+0x70>
+  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+80106a49:	83 c3 10             	add    $0x10,%ebx
+80106a4c:	81 fb 60 a4 10 80    	cmp    $0x8010a460,%ebx
+80106a52:	72 cc                	jb     80106a20 <setupkvm+0x30>
+80106a54:	89 f0                	mov    %esi,%eax
+}
+80106a56:	83 c4 20             	add    $0x20,%esp
+80106a59:	5b                   	pop    %ebx
+80106a5a:	5e                   	pop    %esi
+80106a5b:	5d                   	pop    %ebp
+80106a5c:	c3                   	ret    
+80106a5d:	8d 76 00             	lea    0x0(%esi),%esi
+      freevm(pgdir);
+80106a60:	89 34 24             	mov    %esi,(%esp)
+80106a63:	e8 08 ff ff ff       	call   80106970 <freevm>
+}
+80106a68:	83 c4 20             	add    $0x20,%esp
+      return 0;
+80106a6b:	31 c0                	xor    %eax,%eax
+}
+80106a6d:	5b                   	pop    %ebx
+80106a6e:	5e                   	pop    %esi
+80106a6f:	5d                   	pop    %ebp
+80106a70:	c3                   	ret    
+80106a71:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return 0;
+80106a78:	31 c0                	xor    %eax,%eax
+80106a7a:	eb da                	jmp    80106a56 <setupkvm+0x66>
+80106a7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80106a80 <kvmalloc>:
+{
+80106a80:	55                   	push   %ebp
+80106a81:	89 e5                	mov    %esp,%ebp
+80106a83:	83 ec 08             	sub    $0x8,%esp
+  kpgdir = setupkvm();
+80106a86:	e8 65 ff ff ff       	call   801069f0 <setupkvm>
+80106a8b:	a3 a4 54 11 80       	mov    %eax,0x801154a4
+  lcr3(V2P(kpgdir));   // switch to the kernel page table
+80106a90:	05 00 00 00 80       	add    $0x80000000,%eax
+80106a95:	0f 22 d8             	mov    %eax,%cr3
+}
+80106a98:	c9                   	leave  
+80106a99:	c3                   	ret    
+80106a9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80106aa0 <clearpteu>:
+
+// Clear PTE_U on a page. Used to create an inaccessible
+// page beneath the user stack.
+void
+clearpteu(pde_t *pgdir, char *uva)
+{
+80106aa0:	55                   	push   %ebp
+  pte_t *pte;
+
+  pte = walkpgdir(pgdir, uva, 0);
+80106aa1:	31 c9                	xor    %ecx,%ecx
+{
+80106aa3:	89 e5                	mov    %esp,%ebp
+80106aa5:	83 ec 18             	sub    $0x18,%esp
+  pte = walkpgdir(pgdir, uva, 0);
+80106aa8:	8b 55 0c             	mov    0xc(%ebp),%edx
+80106aab:	8b 45 08             	mov    0x8(%ebp),%eax
+80106aae:	e8 ad f8 ff ff       	call   80106360 <walkpgdir>
+  if(pte == 0)
+80106ab3:	85 c0                	test   %eax,%eax
+80106ab5:	74 05                	je     80106abc <clearpteu+0x1c>
+    panic("clearpteu");
+  *pte &= ~PTE_U;
+80106ab7:	83 20 fb             	andl   $0xfffffffb,(%eax)
+}
+80106aba:	c9                   	leave  
+80106abb:	c3                   	ret    
+    panic("clearpteu");
+80106abc:	c7 04 24 b2 76 10 80 	movl   $0x801076b2,(%esp)
+80106ac3:	e8 98 98 ff ff       	call   80100360 <panic>
+80106ac8:	90                   	nop
+80106ac9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80106ad0 <copyuvm>:
+
+// Given a parent process's page table, create a copy
+// of it for a child.
+pde_t*
+copyuvm(pde_t *pgdir, uint sz)
+{
+80106ad0:	55                   	push   %ebp
+80106ad1:	89 e5                	mov    %esp,%ebp
+80106ad3:	57                   	push   %edi
+80106ad4:	56                   	push   %esi
+80106ad5:	53                   	push   %ebx
+80106ad6:	83 ec 2c             	sub    $0x2c,%esp
+  pde_t *d;
+  pte_t *pte;
+  uint pa, i, flags;
+  char *mem;
+
+  if((d = setupkvm()) == 0)
+80106ad9:	e8 12 ff ff ff       	call   801069f0 <setupkvm>
+80106ade:	85 c0                	test   %eax,%eax
+80106ae0:	89 45 e0             	mov    %eax,-0x20(%ebp)
+80106ae3:	0f 84 ba 00 00 00    	je     80106ba3 <copyuvm+0xd3>
+    return 0;
+  for(i = 0; i < sz; i += PGSIZE){
+80106ae9:	8b 45 0c             	mov    0xc(%ebp),%eax
+80106aec:	85 c0                	test   %eax,%eax
+80106aee:	0f 84 a4 00 00 00    	je     80106b98 <copyuvm+0xc8>
+80106af4:	31 db                	xor    %ebx,%ebx
+80106af6:	eb 51                	jmp    80106b49 <copyuvm+0x79>
+      panic("copyuvm: page not present");
+    pa = PTE_ADDR(*pte);
+    flags = PTE_FLAGS(*pte);
+    if((mem = kalloc()) == 0)
+      goto bad;
+    memmove(mem, (char*)P2V(pa), PGSIZE);
+80106af8:	81 c7 00 00 00 80    	add    $0x80000000,%edi
+80106afe:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+80106b05:	00 
+80106b06:	89 7c 24 04          	mov    %edi,0x4(%esp)
+80106b0a:	89 04 24             	mov    %eax,(%esp)
+80106b0d:	e8 1e d8 ff ff       	call   80104330 <memmove>
+    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0)
+80106b12:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80106b15:	8d 96 00 00 00 80    	lea    -0x80000000(%esi),%edx
+80106b1b:	89 54 24 0c          	mov    %edx,0xc(%esp)
+80106b1f:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+80106b26:	00 
+80106b27:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+80106b2b:	89 44 24 10          	mov    %eax,0x10(%esp)
+80106b2f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80106b32:	89 04 24             	mov    %eax,(%esp)
+80106b35:	e8 16 fa ff ff       	call   80106550 <mappages>
+80106b3a:	85 c0                	test   %eax,%eax
+80106b3c:	78 45                	js     80106b83 <copyuvm+0xb3>
+  for(i = 0; i < sz; i += PGSIZE){
+80106b3e:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+80106b44:	39 5d 0c             	cmp    %ebx,0xc(%ebp)
+80106b47:	76 4f                	jbe    80106b98 <copyuvm+0xc8>
+    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+80106b49:	8b 45 08             	mov    0x8(%ebp),%eax
+80106b4c:	31 c9                	xor    %ecx,%ecx
+80106b4e:	89 da                	mov    %ebx,%edx
+80106b50:	e8 0b f8 ff ff       	call   80106360 <walkpgdir>
+80106b55:	85 c0                	test   %eax,%eax
+80106b57:	74 5a                	je     80106bb3 <copyuvm+0xe3>
+    if(!(*pte & PTE_P))
+80106b59:	8b 30                	mov    (%eax),%esi
+80106b5b:	f7 c6 01 00 00 00    	test   $0x1,%esi
+80106b61:	74 44                	je     80106ba7 <copyuvm+0xd7>
+    pa = PTE_ADDR(*pte);
+80106b63:	89 f7                	mov    %esi,%edi
+    flags = PTE_FLAGS(*pte);
+80106b65:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
+80106b6b:	89 75 e4             	mov    %esi,-0x1c(%ebp)
+    pa = PTE_ADDR(*pte);
+80106b6e:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
+    if((mem = kalloc()) == 0)
+80106b74:	e8 37 b9 ff ff       	call   801024b0 <kalloc>
+80106b79:	85 c0                	test   %eax,%eax
+80106b7b:	89 c6                	mov    %eax,%esi
+80106b7d:	0f 85 75 ff ff ff    	jne    80106af8 <copyuvm+0x28>
+      goto bad;
+  }
+  return d;
+
+bad:
+  freevm(d);
+80106b83:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80106b86:	89 04 24             	mov    %eax,(%esp)
+80106b89:	e8 e2 fd ff ff       	call   80106970 <freevm>
+  return 0;
+80106b8e:	31 c0                	xor    %eax,%eax
+}
+80106b90:	83 c4 2c             	add    $0x2c,%esp
+80106b93:	5b                   	pop    %ebx
+80106b94:	5e                   	pop    %esi
+80106b95:	5f                   	pop    %edi
+80106b96:	5d                   	pop    %ebp
+80106b97:	c3                   	ret    
+80106b98:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80106b9b:	83 c4 2c             	add    $0x2c,%esp
+80106b9e:	5b                   	pop    %ebx
+80106b9f:	5e                   	pop    %esi
+80106ba0:	5f                   	pop    %edi
+80106ba1:	5d                   	pop    %ebp
+80106ba2:	c3                   	ret    
+    return 0;
+80106ba3:	31 c0                	xor    %eax,%eax
+80106ba5:	eb e9                	jmp    80106b90 <copyuvm+0xc0>
+      panic("copyuvm: page not present");
+80106ba7:	c7 04 24 d6 76 10 80 	movl   $0x801076d6,(%esp)
+80106bae:	e8 ad 97 ff ff       	call   80100360 <panic>
+      panic("copyuvm: pte should exist");
+80106bb3:	c7 04 24 bc 76 10 80 	movl   $0x801076bc,(%esp)
+80106bba:	e8 a1 97 ff ff       	call   80100360 <panic>
+80106bbf:	90                   	nop
+
+80106bc0 <uva2ka>:
+
+//PAGEBREAK!
+// Map user virtual address to kernel address.
+char*
+uva2ka(pde_t *pgdir, char *uva)
+{
+80106bc0:	55                   	push   %ebp
+  pte_t *pte;
+
+  pte = walkpgdir(pgdir, uva, 0);
+80106bc1:	31 c9                	xor    %ecx,%ecx
+{
+80106bc3:	89 e5                	mov    %esp,%ebp
+80106bc5:	83 ec 08             	sub    $0x8,%esp
+  pte = walkpgdir(pgdir, uva, 0);
+80106bc8:	8b 55 0c             	mov    0xc(%ebp),%edx
+80106bcb:	8b 45 08             	mov    0x8(%ebp),%eax
+80106bce:	e8 8d f7 ff ff       	call   80106360 <walkpgdir>
+  if((*pte & PTE_P) == 0)
+80106bd3:	8b 00                	mov    (%eax),%eax
+80106bd5:	89 c2                	mov    %eax,%edx
+80106bd7:	83 e2 05             	and    $0x5,%edx
+    return 0;
+  if((*pte & PTE_U) == 0)
+80106bda:	83 fa 05             	cmp    $0x5,%edx
+80106bdd:	75 11                	jne    80106bf0 <uva2ka+0x30>
+    return 0;
+  return (char*)P2V(PTE_ADDR(*pte));
+80106bdf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80106be4:	05 00 00 00 80       	add    $0x80000000,%eax
+}
+80106be9:	c9                   	leave  
+80106bea:	c3                   	ret    
+80106beb:	90                   	nop
+80106bec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return 0;
+80106bf0:	31 c0                	xor    %eax,%eax
+}
+80106bf2:	c9                   	leave  
+80106bf3:	c3                   	ret    
+80106bf4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80106bfa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+80106c00 <copyout>:
+// Copy len bytes from p to user address va in page table pgdir.
+// Most useful when pgdir is not the current page table.
+// uva2ka ensures this only works for PTE_U pages.
+int
+copyout(pde_t *pgdir, uint va, void *p, uint len)
+{
+80106c00:	55                   	push   %ebp
+80106c01:	89 e5                	mov    %esp,%ebp
+80106c03:	57                   	push   %edi
+80106c04:	56                   	push   %esi
+80106c05:	53                   	push   %ebx
+80106c06:	83 ec 1c             	sub    $0x1c,%esp
+80106c09:	8b 5d 14             	mov    0x14(%ebp),%ebx
+80106c0c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+80106c0f:	8b 7d 10             	mov    0x10(%ebp),%edi
+  char *buf, *pa0;
+  uint n, va0;
+
+  buf = (char*)p;
+  while(len > 0){
+80106c12:	85 db                	test   %ebx,%ebx
+80106c14:	75 3a                	jne    80106c50 <copyout+0x50>
+80106c16:	eb 68                	jmp    80106c80 <copyout+0x80>
+    va0 = (uint)PGROUNDDOWN(va);
+    pa0 = uva2ka(pgdir, (char*)va0);
+    if(pa0 == 0)
+      return -1;
+    n = PGSIZE - (va - va0);
+80106c18:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+80106c1b:	89 f2                	mov    %esi,%edx
+    if(n > len)
+      n = len;
+    memmove(pa0 + (va - va0), buf, n);
+80106c1d:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    n = PGSIZE - (va - va0);
+80106c21:	29 ca                	sub    %ecx,%edx
+80106c23:	81 c2 00 10 00 00    	add    $0x1000,%edx
+80106c29:	39 da                	cmp    %ebx,%edx
+80106c2b:	0f 47 d3             	cmova  %ebx,%edx
+    memmove(pa0 + (va - va0), buf, n);
+80106c2e:	29 f1                	sub    %esi,%ecx
+80106c30:	01 c8                	add    %ecx,%eax
+80106c32:	89 54 24 08          	mov    %edx,0x8(%esp)
+80106c36:	89 04 24             	mov    %eax,(%esp)
+80106c39:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+80106c3c:	e8 ef d6 ff ff       	call   80104330 <memmove>
+    len -= n;
+    buf += n;
+80106c41:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+    va = va0 + PGSIZE;
+80106c44:	8d 8e 00 10 00 00    	lea    0x1000(%esi),%ecx
+    buf += n;
+80106c4a:	01 d7                	add    %edx,%edi
+  while(len > 0){
+80106c4c:	29 d3                	sub    %edx,%ebx
+80106c4e:	74 30                	je     80106c80 <copyout+0x80>
+    pa0 = uva2ka(pgdir, (char*)va0);
+80106c50:	8b 45 08             	mov    0x8(%ebp),%eax
+    va0 = (uint)PGROUNDDOWN(va);
+80106c53:	89 ce                	mov    %ecx,%esi
+80106c55:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
+    pa0 = uva2ka(pgdir, (char*)va0);
+80106c5b:	89 74 24 04          	mov    %esi,0x4(%esp)
+    va0 = (uint)PGROUNDDOWN(va);
+80106c5f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+    pa0 = uva2ka(pgdir, (char*)va0);
+80106c62:	89 04 24             	mov    %eax,(%esp)
+80106c65:	e8 56 ff ff ff       	call   80106bc0 <uva2ka>
+    if(pa0 == 0)
+80106c6a:	85 c0                	test   %eax,%eax
+80106c6c:	75 aa                	jne    80106c18 <copyout+0x18>
+  }
+  return 0;
+}
+80106c6e:	83 c4 1c             	add    $0x1c,%esp
+      return -1;
+80106c71:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80106c76:	5b                   	pop    %ebx
+80106c77:	5e                   	pop    %esi
+80106c78:	5f                   	pop    %edi
+80106c79:	5d                   	pop    %ebp
+80106c7a:	c3                   	ret    
+80106c7b:	90                   	nop
+80106c7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80106c80:	83 c4 1c             	add    $0x1c,%esp
+  return 0;
+80106c83:	31 c0                	xor    %eax,%eax
+}
+80106c85:	5b                   	pop    %ebx
+80106c86:	5e                   	pop    %esi
+80106c87:	5f                   	pop    %edi
+80106c88:	5d                   	pop    %ebp
+80106c89:	c3                   	ret    
+80106c8a:	66 90                	xchg   %ax,%ax
+80106c8c:	66 90                	xchg   %ax,%ax
+80106c8e:	66 90                	xchg   %ax,%ax
+
+80106c90 <shminit>:
+    char *frame;
+    int refcnt;
+  } shm_pages[64];
+} shm_table;
+
+void shminit() {
+80106c90:	55                   	push   %ebp
+80106c91:	89 e5                	mov    %esp,%ebp
+80106c93:	83 ec 18             	sub    $0x18,%esp
+  int i;
+  initlock(&(shm_table.lock), "SHM lock");
+80106c96:	c7 44 24 04 14 77 10 	movl   $0x80107714,0x4(%esp)
+80106c9d:	80 
+80106c9e:	c7 04 24 c0 54 11 80 	movl   $0x801154c0,(%esp)
+80106ca5:	e8 b6 d3 ff ff       	call   80104060 <initlock>
+  acquire(&(shm_table.lock));
+80106caa:	c7 04 24 c0 54 11 80 	movl   $0x801154c0,(%esp)
+80106cb1:	e8 9a d4 ff ff       	call   80104150 <acquire>
+80106cb6:	b8 f4 54 11 80       	mov    $0x801154f4,%eax
+80106cbb:	90                   	nop
+80106cbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  for (i = 0; i< 64; i++) {
+    shm_table.shm_pages[i].id =0;
+80106cc0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+80106cc6:	83 c0 0c             	add    $0xc,%eax
+    shm_table.shm_pages[i].frame =0;
+80106cc9:	c7 40 f8 00 00 00 00 	movl   $0x0,-0x8(%eax)
+    shm_table.shm_pages[i].refcnt =0;
+80106cd0:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
+  for (i = 0; i< 64; i++) {
+80106cd7:	3d f4 57 11 80       	cmp    $0x801157f4,%eax
+80106cdc:	75 e2                	jne    80106cc0 <shminit+0x30>
+  }
+  release(&(shm_table.lock));
+80106cde:	c7 04 24 c0 54 11 80 	movl   $0x801154c0,(%esp)
+80106ce5:	e8 56 d5 ff ff       	call   80104240 <release>
+}
+80106cea:	c9                   	leave  
+80106ceb:	c3                   	ret    
+80106cec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80106cf0 <shm_open>:
+
+int shm_open(int id, char **pointer) {
+80106cf0:	55                   	push   %ebp
+
+
+
+
+return 0; //added to remove compiler warning -- you should decide what to return
+}
+80106cf1:	31 c0                	xor    %eax,%eax
+int shm_open(int id, char **pointer) {
+80106cf3:	89 e5                	mov    %esp,%ebp
+}
+80106cf5:	5d                   	pop    %ebp
+80106cf6:	c3                   	ret    
+80106cf7:	89 f6                	mov    %esi,%esi
+80106cf9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+80106d00 <shm_close>:
+
+
+int shm_close(int id) {
+80106d00:	55                   	push   %ebp
+
+
+
+
+return 0; //added to remove compiler warning -- you should decide what to return
+}
+80106d01:	31 c0                	xor    %eax,%eax
+int shm_close(int id) {
+80106d03:	89 e5                	mov    %esp,%ebp
+}
+80106d05:	5d                   	pop    %ebp
+80106d06:	c3                   	ret    
diff --git a/kernel.ld b/kernel.ld
index 4e12e14..e24c860 100644
--- a/kernel.ld
+++ b/kernel.ld
@@ -26,12 +26,16 @@ SECTIONS
 		PROVIDE(__STAB_BEGIN__ = .);
 		*(.stab);
 		PROVIDE(__STAB_END__ = .);
+		BYTE(0)		/* Force the linker to allocate space
+				   for this section */
 	}
 
 	.stabstr : {
 		PROVIDE(__STABSTR_BEGIN__ = .);
 		*(.stabstr);
 		PROVIDE(__STABSTR_END__ = .);
+		BYTE(0)		/* Force the linker to allocate space
+				   for this section */
 	}
 
 	/* Adjust the address for the data segment to the next page */
diff --git a/kernel.sym b/kernel.sym
new file mode 100644
index 0000000..f083464
--- /dev/null
+++ b/kernel.sym
@@ -0,0 +1,526 @@
+80100000 .text
+80106d20 .rodata
+8010771d .stab
+8010771e .stabstr
+80108000 .data
+8010a520 .bss
+00000000 .debug_line
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_aranges
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 .debug_str
+00000000 .comment
+00000000 bio.c
+00000000 console.c
+8010a520 cons
+8010a558 panicked
+801003e0 consputc
+80100570 printint
+80106d90 digits.1859
+00000000 exec.c
+00000000 file.c
+00000000 fs.c
+80101100 balloc
+80101220 iget
+801012e0 bmap
+801013f0 bfree
+80101c90 namex
+00000000 ide.c
+80101f50 idestart
+8010a580 idelock
+8010a560 havedisk1
+8010a564 idequeue
+00000000 ioapic.c
+00000000 kalloc.c
+00000000 kbd.c
+8010a5b4 shift.1700
+801070c0 shiftcode
+80106fc0 togglecode
+80106fa0 charcode.1701
+80108200 normalmap
+80108100 shiftmap
+80108000 ctlmap
+00000000 lapic.c
+80102600 fill_rtcdate
+00000000 log.c
+80102970 install_trans
+80102a10 write_head
+00000000 main.c
+80102d90 mpmain
+80102de0 mpenter
+00000000 mp.c
+80102f30 mpsearch1
+00000000 picirq.c
+00000000 pipe.c
+00000000 proc.c
+801034d0 allocproc
+8010a000 first.1901
+8010a5b8 initproc
+80107380 states.1927
+00000000 sleeplock.c
+00000000 spinlock.c
+00000000 string.c
+00000000 syscall.c
+80107400 syscalls
+00000000 sysfile.c
+801046c0 fdalloc
+80104700 create
+80104880 argfd.constprop.0
+00000000 sysproc.c
+00000000 trap.c
+00000000 uart.c
+801057b0 uartgetc
+8010a5bc uart
+00000000 vm.c
+80106360 walkpgdir
+801063f0 deallocuvm.part.0
+8010a420 kmap
+00000000 shm.c
+80106550 mappages
+80100270 consoleread
+801062ae vector242
+80105d05 vector119
+8010000c entry
+80105be5 vector87
+80105bdc vector86
+80104470 safestrcpy
+80104a10 sys_close
+8010631a vector251
+80105c09 vector91
+801059ff vector33
+80105eee vector162
+80103bd0 yield
+80112680 log
+80112640 kmem
+80106152 vector213
+80105ca2 vector108
+80105830 uartinit
+80105a59 vector43
+80102790 lapiceoi
+80105f12 vector165
+80106002 vector185
+80102210 ioapicinit
+80105ce1 vector115
+80100f40 fileread
+80105d20 vector122
+80105320 sys_sbrk
+80112760 ioapicid
+80105ea6 vector156
+801062d2 vector245
+80112634 ioapic
+80106032 vector189
+80105923 vector7
+80105afb vector61
+801059ae vector24
+80105cbd vector111
+801060b6 vector200
+80105b31 vector67
+80105dce vector138
+80105b70 vector74
+80103a10 sched
+80104330 memmove
+80105ad7 vector57
+80105200 sys_shm_open
+80104650 syscall
+8010615e vector214
+80105c51 vector99
+80103690 cpuid
+80101a70 writei
+80105df2 vector141
+801052a0 sys_fork
+8010b5c0 bcache
+80105f66 vector172
+80106cf0 shm_open
+801062a2 vector241
+80104080 getcallerpcs
+80104ef0 sys_mkdir
+80106332 vector253
+801058ff vector3
+801058f6 vector2
+80101ba0 namecmp
+801061fa vector227
+8010612e vector210
+80104610 argstr
+801061d6 vector224
+80105a47 vector41
+80100650 cprintf
+80100de0 filedup
+80101f10 namei
+80105993 vector21
+80100040 binit
+80105fa2 vector177
+80105cfc vector118
+80105b4c vector70
+80105b43 vector69
+80106272 vector237
+80105b16 vector64
+801059c9 vector27
+80105d86 vector132
+8010600e vector186
+80104930 sys_read
+80106182 vector217
+801044e0 fetchint
+801069f0 setupkvm
+801043a0 memcpy
+80106970 freevm
+801058ed vector1
+80105fae vector178
+80105a2c vector38
+80102300 kfree
+8010627e vector238
+80103610 mycpu
+801017e0 iput
+80105d92 vector133
+80105b67 vector73
+80105e16 vector144
+8010633e vector254
+801013a0 readsb
+8010a004 nextpid
+80105c63 vector101
+8010613a vector211
+80102fa0 mpinit
+80105f7e vector174
+801062ba vector243
+80100d50 fileinit
+80104060 initlock
+80105d56 vector128
+80106c00 copyout
+80105baf vector81
+80103c10 sleep
+801154c0 shm_table
+801027b0 microdelay
+80105951 vector13
+80105aa1 vector51
+80105968 vector16
+8010ff20 input
+80106296 vector240
+80105abc vector54
+80105981 vector19
+80105c12 vector92
+801062c6 vector244
+80101940 stati
+80105de6 vector140
+801052d0 sys_kill
+80105a6b vector45
+80105b9d vector79
+80103270 pipeclose
+80106212 vector229
+80105ebe vector158
+80104a50 sys_fstat
+801005f0 consolewrite
+80105a35 vector39
+80105f36 vector168
+80102b90 end_op
+80105a11 vector35
+80105ccf vector113
+801023a0 freerange
+80105d3b vector125
+80106850 allocuvm
+80105465 trapret
+80106176 vector216
+80105b0d vector63
+801059c0 vector26
+80106062 vector193
+80102680 lapicinit
+80106086 vector196
+80106122 vector209
+80105908 vector4
+80105f4e vector170
+8010a5c0 stack
+80105db6 vector136
+8010593c vector10
+801060fe vector206
+801017a0 iunlock
+80105370 sys_sleep
+8010634a vector255
+80105fd2 vector181
+80105ae9 vector59
+80105bd3 vector85
+80105bca vector84
+80105fea vector183
+80105eca vector159
+80106146 vector212
+80104aa0 sys_link
+80105a7d vector47
+80106206 vector228
+80105a50 vector42
+80105cd8 vector114
+80106bc0 uva2ka
+80105f8a vector175
+80105e0a vector143
+80100d70 filealloc
+80103da0 wakeup
+80105d6e vector130
+801062de vector246
+80105260 sys_shm_close
+80105933 vector9
+80105dfe vector142
+80105c5a vector100
+801060c2 vector201
+80106aa0 clearpteu
+801036b0 myproc
+80105470 tvinit
+80105af2 vector60
+801059a5 vector23
+80101690 idup
+80106266 vector236
+801025e0 kbdintr
+80104db0 sys_open
+8010622a vector231
+80105b28 vector66
+801059db vector29
+80101970 readi
+80105daa vector135
+801007b0 consoleintr
+80103e00 kill
+80105b8b vector77
+80101530 ialloc
+80105fc6 vector180
+801154a4 kpgdir
+80106116 vector208
+80102850 cmostime
+801058d0 uartintr
+80105c48 vector98
+80105c3f vector97
+80105f96 vector176
+8010606e vector194
+801059f6 vector32
+801157f4 end
+801060aa vector199
+80105d7a vector131
+80106326 vector252
+80100fe0 filewrite
+801058e4 vector0
+80104580 argint
+801009a0 exec
+80105e22 vector145
+801049a0 sys_write
+80104240 release
+80104520 fetchstr
+80105c99 vector107
+80105a3e vector40
+80103cc0 wait
+80105c6c vector102
+80109000 entrypgdir
+0010000c _start
+80105ace vector56
+80105b3a vector68
+8010591a vector6
+8010a48c _binary_initcode_end
+80100000 multiboot_header
+80105d62 vector129
+80103970 scheduler
+80101bd0 dirlookup
+80106092 vector197
+80100e30 fileclose
+80102b20 begin_op
+80105e76 vector152
+80106a80 kvmalloc
+8010621e vector230
+801043b0 strncmp
+80105a23 vector37
+801060f2 vector205
+80105ee2 vector161
+80114c60 tickslock
+80103300 pipewrite
+80104420 strncpy
+80105b55 vector71
+80106ad0 copyuvm
+8010ffc0 ftable
+80105ed6 vector160
+801045b0 argptr
+8010616a vector215
+80105eb2 vector157
+801048f0 sys_dup
+80105cc6 vector112
+80100360 panic
+801035a0 forkret
+80105fde vector182
+8010594a vector12
+801042e0 memcmp
+80102510 kbdgetc
+80105cab vector109
+8010598a vector20
+80103860 fork
+80105ab3 vector53
+80105978 vector18
+0000008a _binary_entryother_size
+80112780 cpus
+80103ff0 releasesleep
+80105c2d vector95
+801040e0 holding
+801109c0 sb
+80104150 acquire
+801061ee vector226
+80106c90 shminit
+80101f30 nameiparent
+80105a8f vector49
+80105a62 vector44
+8011267c lapic
+80105b94 vector78
+8010544d alltraps
+80105f72 vector173
+80105cf3 vector117
+80106d00 shm_close
+80105bb8 vector82
+801061be vector222
+8010592c vector8
+80105e52 vector149
+80101600 iupdate
+80108000 data
+80104290 memset
+80106236 vector232
+80102e00 main
+801065d0 switchkvm
+80105c90 vector106
+801061a6 vector220
+80105c00 vector90
+80105efa vector163
+8010624e vector234
+80102cc0 log_write
+80103f90 acquiresleep
+80104bc0 sys_unlink
+80105b04 vector62
+801059b7 vector25
+8010609e vector198
+80105d0e vector120
+8010a48c _binary_entryother_start
+801023f0 kinit1
+80105a98 vector50
+8010595f vector15
+80105e6a vector151
+80105bc1 vector83
+80105bf7 vector89
+80105bee vector88
+80105540 trap
+80105420 sys_uptime
+80105fba vector179
+80105a08 vector34
+80105a74 vector46
+80105d9e vector134
+801061ca vector223
+80114ca0 idt
+8010618e vector218
+801035f0 pinit
+80106950 deallocuvm
+801061e2 vector225
+80102770 lapicid
+8010601a vector187
+801037f0 growproc
+80104030 holdingsleep
+80112d00 ncpu
+801059e4 vector30
+801036e0 userinit
+801000d0 bread
+80105d4d vector127
+801033f0 piperead
+801154a0 ticks
+80106056 vector192
+80105f1e vector166
+80100950 consoleinit
+80105b82 vector76
+80105b79 vector75
+80102090 ideintr
+8010607a vector195
+80105e5e vector150
+80105ae0 vector58
+801062f6 vector248
+80105d29 vector123
+80105c36 vector96
+801059ed vector31
+801060da vector203
+80105dda vector139
+80105e82 vector153
+80105f06 vector164
+80103e80 procdump
+80105d17 vector121
+801057e0 uartputc
+80105911 vector5
+80105f2a vector167
+80105e9a vector155
+80106302 vector249
+801001e0 brelse
+8010630e vector250
+80105d32 vector124
+80105cb4 vector110
+801060e6 vector204
+801016c0 ilock
+80105070 sys_exec
+80105dc2 vector137
+8010a460 _binary_initcode_start
+801044cb swtch
+801062ea vector247
+8010599c vector22
+801060ce vector202
+80106490 seginit
+80101920 iunlockput
+80105b5e vector72
+80105ac5 vector55
+80105d44 vector126
+80105b1f vector65
+801059d2 vector28
+8010a516 _binary_entryother_end
+80105f42 vector169
+801001a0 bwrite
+80106242 vector233
+80105510 idtinit
+80103ab0 exit
+801052c0 sys_wait
+801052b0 sys_exit
+80101e30 dirlink
+0000002c _binary_initcode_size
+80105e3a vector147
+80103f50 initsleeplock
+80102010 ideinit
+80106790 loaduvm
+80105c7e vector104
+80105cea vector116
+80112d20 ptable
+801022c0 ioapicenable
+801041d0 popcli
+8010a008 vectors
+80105aaa vector52
+80105971 vector17
+80105ff6 vector184
+801044b0 strlen
+80105160 sys_pipe
+80101480 iinit
+80103160 picinit
+8010610a vector207
+80106700 inituvm
+8010603e vector190
+8010628a vector239
+80105c24 vector94
+80105c1b vector93
+80102a80 initlog
+80106026 vector188
+80105a86 vector48
+80102130 iderw
+8010619a vector219
+80105e46 vector148
+801061b2 vector221
+801024b0 kalloc
+80110960 devsw
+80105310 sys_getpid
+80105ba6 vector80
+80105f5a vector171
+80105e8e vector154
+80105a1a vector36
+80103180 pipealloc
+8010625a vector235
+80105c87 vector105
+80104fe0 sys_chdir
+801109e0 icache
+80105e2e vector146
+8010604a vector191
+80105c75 vector103
+80104f50 sys_mknod
+801027c0 lapicstartap
+801065f0 switchuvm
+80104110 pushcli
+80102460 kinit2
+80105943 vector11
+80105958 vector14
+80100ef0 filestat
diff --git a/kill.asm b/kill.asm
new file mode 100644
index 0000000..abb7b69
--- /dev/null
+++ b/kill.asm
@@ -0,0 +1,1222 @@
+
+_kill:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char **argv)
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	57                   	push   %edi
+    1004:	56                   	push   %esi
+    1005:	53                   	push   %ebx
+  int i;
+
+  if(argc < 2){
+    1006:	bb 01 00 00 00       	mov    $0x1,%ebx
+{
+    100b:	83 e4 f0             	and    $0xfffffff0,%esp
+    100e:	83 ec 10             	sub    $0x10,%esp
+    1011:	8b 75 08             	mov    0x8(%ebp),%esi
+    1014:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  if(argc < 2){
+    1017:	83 fe 01             	cmp    $0x1,%esi
+    101a:	7e 23                	jle    103f <main+0x3f>
+    101c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    printf(2, "usage: kill pid...\n");
+    exit();
+  }
+  for(i=1; i<argc; i++)
+    kill(atoi(argv[i]));
+    1020:	8b 04 9f             	mov    (%edi,%ebx,4),%eax
+  for(i=1; i<argc; i++)
+    1023:	83 c3 01             	add    $0x1,%ebx
+    kill(atoi(argv[i]));
+    1026:	89 04 24             	mov    %eax,(%esp)
+    1029:	e8 f2 01 00 00       	call   1220 <atoi>
+    102e:	89 04 24             	mov    %eax,(%esp)
+    1031:	e8 7c 02 00 00       	call   12b2 <kill>
+  for(i=1; i<argc; i++)
+    1036:	39 f3                	cmp    %esi,%ebx
+    1038:	75 e6                	jne    1020 <main+0x20>
+  exit();
+    103a:	e8 43 02 00 00       	call   1282 <exit>
+    printf(2, "usage: kill pid...\n");
+    103f:	c7 44 24 04 81 17 00 	movl   $0x1781,0x4(%esp)
+    1046:	00 
+    1047:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    104e:	e8 8d 03 00 00       	call   13e0 <printf>
+    exit();
+    1053:	e8 2a 02 00 00       	call   1282 <exit>
+    1058:	66 90                	xchg   %ax,%ax
+    105a:	66 90                	xchg   %ax,%ax
+    105c:	66 90                	xchg   %ax,%ax
+    105e:	66 90                	xchg   %ax,%ax
+
+00001060 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1060:	55                   	push   %ebp
+    1061:	89 e5                	mov    %esp,%ebp
+    1063:	8b 45 08             	mov    0x8(%ebp),%eax
+    1066:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1069:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    106a:	89 c2                	mov    %eax,%edx
+    106c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1070:	83 c1 01             	add    $0x1,%ecx
+    1073:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1077:	83 c2 01             	add    $0x1,%edx
+    107a:	84 db                	test   %bl,%bl
+    107c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    107f:	75 ef                	jne    1070 <strcpy+0x10>
+    ;
+  return os;
+}
+    1081:	5b                   	pop    %ebx
+    1082:	5d                   	pop    %ebp
+    1083:	c3                   	ret    
+    1084:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    108a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001090 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1090:	55                   	push   %ebp
+    1091:	89 e5                	mov    %esp,%ebp
+    1093:	8b 55 08             	mov    0x8(%ebp),%edx
+    1096:	53                   	push   %ebx
+    1097:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    109a:	0f b6 02             	movzbl (%edx),%eax
+    109d:	84 c0                	test   %al,%al
+    109f:	74 2d                	je     10ce <strcmp+0x3e>
+    10a1:	0f b6 19             	movzbl (%ecx),%ebx
+    10a4:	38 d8                	cmp    %bl,%al
+    10a6:	74 0e                	je     10b6 <strcmp+0x26>
+    10a8:	eb 2b                	jmp    10d5 <strcmp+0x45>
+    10aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    10b0:	38 c8                	cmp    %cl,%al
+    10b2:	75 15                	jne    10c9 <strcmp+0x39>
+    p++, q++;
+    10b4:	89 d9                	mov    %ebx,%ecx
+    10b6:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    10b9:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    10bc:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    10bf:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    10c3:	84 c0                	test   %al,%al
+    10c5:	75 e9                	jne    10b0 <strcmp+0x20>
+    10c7:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    10c9:	29 c8                	sub    %ecx,%eax
+}
+    10cb:	5b                   	pop    %ebx
+    10cc:	5d                   	pop    %ebp
+    10cd:	c3                   	ret    
+    10ce:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    10d1:	31 c0                	xor    %eax,%eax
+    10d3:	eb f4                	jmp    10c9 <strcmp+0x39>
+    10d5:	0f b6 cb             	movzbl %bl,%ecx
+    10d8:	eb ef                	jmp    10c9 <strcmp+0x39>
+    10da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000010e0 <strlen>:
+
+uint
+strlen(char *s)
+{
+    10e0:	55                   	push   %ebp
+    10e1:	89 e5                	mov    %esp,%ebp
+    10e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    10e6:	80 39 00             	cmpb   $0x0,(%ecx)
+    10e9:	74 12                	je     10fd <strlen+0x1d>
+    10eb:	31 d2                	xor    %edx,%edx
+    10ed:	8d 76 00             	lea    0x0(%esi),%esi
+    10f0:	83 c2 01             	add    $0x1,%edx
+    10f3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    10f7:	89 d0                	mov    %edx,%eax
+    10f9:	75 f5                	jne    10f0 <strlen+0x10>
+    ;
+  return n;
+}
+    10fb:	5d                   	pop    %ebp
+    10fc:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    10fd:	31 c0                	xor    %eax,%eax
+}
+    10ff:	5d                   	pop    %ebp
+    1100:	c3                   	ret    
+    1101:	eb 0d                	jmp    1110 <memset>
+    1103:	90                   	nop
+    1104:	90                   	nop
+    1105:	90                   	nop
+    1106:	90                   	nop
+    1107:	90                   	nop
+    1108:	90                   	nop
+    1109:	90                   	nop
+    110a:	90                   	nop
+    110b:	90                   	nop
+    110c:	90                   	nop
+    110d:	90                   	nop
+    110e:	90                   	nop
+    110f:	90                   	nop
+
+00001110 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    1110:	55                   	push   %ebp
+    1111:	89 e5                	mov    %esp,%ebp
+    1113:	8b 55 08             	mov    0x8(%ebp),%edx
+    1116:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    1117:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    111a:	8b 45 0c             	mov    0xc(%ebp),%eax
+    111d:	89 d7                	mov    %edx,%edi
+    111f:	fc                   	cld    
+    1120:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    1122:	89 d0                	mov    %edx,%eax
+    1124:	5f                   	pop    %edi
+    1125:	5d                   	pop    %ebp
+    1126:	c3                   	ret    
+    1127:	89 f6                	mov    %esi,%esi
+    1129:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001130 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    1130:	55                   	push   %ebp
+    1131:	89 e5                	mov    %esp,%ebp
+    1133:	8b 45 08             	mov    0x8(%ebp),%eax
+    1136:	53                   	push   %ebx
+    1137:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    113a:	0f b6 18             	movzbl (%eax),%ebx
+    113d:	84 db                	test   %bl,%bl
+    113f:	74 1d                	je     115e <strchr+0x2e>
+    if(*s == c)
+    1141:	38 d3                	cmp    %dl,%bl
+    1143:	89 d1                	mov    %edx,%ecx
+    1145:	75 0d                	jne    1154 <strchr+0x24>
+    1147:	eb 17                	jmp    1160 <strchr+0x30>
+    1149:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1150:	38 ca                	cmp    %cl,%dl
+    1152:	74 0c                	je     1160 <strchr+0x30>
+  for(; *s; s++)
+    1154:	83 c0 01             	add    $0x1,%eax
+    1157:	0f b6 10             	movzbl (%eax),%edx
+    115a:	84 d2                	test   %dl,%dl
+    115c:	75 f2                	jne    1150 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    115e:	31 c0                	xor    %eax,%eax
+}
+    1160:	5b                   	pop    %ebx
+    1161:	5d                   	pop    %ebp
+    1162:	c3                   	ret    
+    1163:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1169:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001170 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1170:	55                   	push   %ebp
+    1171:	89 e5                	mov    %esp,%ebp
+    1173:	57                   	push   %edi
+    1174:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1175:	31 f6                	xor    %esi,%esi
+{
+    1177:	53                   	push   %ebx
+    1178:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    117b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    117e:	eb 31                	jmp    11b1 <gets+0x41>
+    cc = read(0, &c, 1);
+    1180:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1187:	00 
+    1188:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    118c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1193:	e8 02 01 00 00       	call   129a <read>
+    if(cc < 1)
+    1198:	85 c0                	test   %eax,%eax
+    119a:	7e 1d                	jle    11b9 <gets+0x49>
+      break;
+    buf[i++] = c;
+    119c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    11a0:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    11a2:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    11a5:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    11a7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    11ab:	74 0c                	je     11b9 <gets+0x49>
+    11ad:	3c 0a                	cmp    $0xa,%al
+    11af:	74 08                	je     11b9 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    11b1:	8d 5e 01             	lea    0x1(%esi),%ebx
+    11b4:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    11b7:	7c c7                	jl     1180 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    11b9:	8b 45 08             	mov    0x8(%ebp),%eax
+    11bc:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    11c0:	83 c4 2c             	add    $0x2c,%esp
+    11c3:	5b                   	pop    %ebx
+    11c4:	5e                   	pop    %esi
+    11c5:	5f                   	pop    %edi
+    11c6:	5d                   	pop    %ebp
+    11c7:	c3                   	ret    
+    11c8:	90                   	nop
+    11c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000011d0 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    11d0:	55                   	push   %ebp
+    11d1:	89 e5                	mov    %esp,%ebp
+    11d3:	56                   	push   %esi
+    11d4:	53                   	push   %ebx
+    11d5:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    11d8:	8b 45 08             	mov    0x8(%ebp),%eax
+    11db:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    11e2:	00 
+    11e3:	89 04 24             	mov    %eax,(%esp)
+    11e6:	e8 d7 00 00 00       	call   12c2 <open>
+  if(fd < 0)
+    11eb:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    11ed:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    11ef:	78 27                	js     1218 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    11f1:	8b 45 0c             	mov    0xc(%ebp),%eax
+    11f4:	89 1c 24             	mov    %ebx,(%esp)
+    11f7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    11fb:	e8 da 00 00 00       	call   12da <fstat>
+  close(fd);
+    1200:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    1203:	89 c6                	mov    %eax,%esi
+  close(fd);
+    1205:	e8 a0 00 00 00       	call   12aa <close>
+  return r;
+    120a:	89 f0                	mov    %esi,%eax
+}
+    120c:	83 c4 10             	add    $0x10,%esp
+    120f:	5b                   	pop    %ebx
+    1210:	5e                   	pop    %esi
+    1211:	5d                   	pop    %ebp
+    1212:	c3                   	ret    
+    1213:	90                   	nop
+    1214:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    1218:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    121d:	eb ed                	jmp    120c <stat+0x3c>
+    121f:	90                   	nop
+
+00001220 <atoi>:
+
+int
+atoi(const char *s)
+{
+    1220:	55                   	push   %ebp
+    1221:	89 e5                	mov    %esp,%ebp
+    1223:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    1226:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    1227:	0f be 11             	movsbl (%ecx),%edx
+    122a:	8d 42 d0             	lea    -0x30(%edx),%eax
+    122d:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    122f:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    1234:	77 17                	ja     124d <atoi+0x2d>
+    1236:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    1238:	83 c1 01             	add    $0x1,%ecx
+    123b:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    123e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1242:	0f be 11             	movsbl (%ecx),%edx
+    1245:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1248:	80 fb 09             	cmp    $0x9,%bl
+    124b:	76 eb                	jbe    1238 <atoi+0x18>
+  return n;
+}
+    124d:	5b                   	pop    %ebx
+    124e:	5d                   	pop    %ebp
+    124f:	c3                   	ret    
+
+00001250 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1250:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1251:	31 d2                	xor    %edx,%edx
+{
+    1253:	89 e5                	mov    %esp,%ebp
+    1255:	56                   	push   %esi
+    1256:	8b 45 08             	mov    0x8(%ebp),%eax
+    1259:	53                   	push   %ebx
+    125a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    125d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1260:	85 db                	test   %ebx,%ebx
+    1262:	7e 12                	jle    1276 <memmove+0x26>
+    1264:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1268:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    126c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    126f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1272:	39 da                	cmp    %ebx,%edx
+    1274:	75 f2                	jne    1268 <memmove+0x18>
+  return vdst;
+}
+    1276:	5b                   	pop    %ebx
+    1277:	5e                   	pop    %esi
+    1278:	5d                   	pop    %ebp
+    1279:	c3                   	ret    
+
+0000127a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    127a:	b8 01 00 00 00       	mov    $0x1,%eax
+    127f:	cd 40                	int    $0x40
+    1281:	c3                   	ret    
+
+00001282 <exit>:
+SYSCALL(exit)
+    1282:	b8 02 00 00 00       	mov    $0x2,%eax
+    1287:	cd 40                	int    $0x40
+    1289:	c3                   	ret    
+
+0000128a <wait>:
+SYSCALL(wait)
+    128a:	b8 03 00 00 00       	mov    $0x3,%eax
+    128f:	cd 40                	int    $0x40
+    1291:	c3                   	ret    
+
+00001292 <pipe>:
+SYSCALL(pipe)
+    1292:	b8 04 00 00 00       	mov    $0x4,%eax
+    1297:	cd 40                	int    $0x40
+    1299:	c3                   	ret    
+
+0000129a <read>:
+SYSCALL(read)
+    129a:	b8 05 00 00 00       	mov    $0x5,%eax
+    129f:	cd 40                	int    $0x40
+    12a1:	c3                   	ret    
+
+000012a2 <write>:
+SYSCALL(write)
+    12a2:	b8 10 00 00 00       	mov    $0x10,%eax
+    12a7:	cd 40                	int    $0x40
+    12a9:	c3                   	ret    
+
+000012aa <close>:
+SYSCALL(close)
+    12aa:	b8 15 00 00 00       	mov    $0x15,%eax
+    12af:	cd 40                	int    $0x40
+    12b1:	c3                   	ret    
+
+000012b2 <kill>:
+SYSCALL(kill)
+    12b2:	b8 06 00 00 00       	mov    $0x6,%eax
+    12b7:	cd 40                	int    $0x40
+    12b9:	c3                   	ret    
+
+000012ba <exec>:
+SYSCALL(exec)
+    12ba:	b8 07 00 00 00       	mov    $0x7,%eax
+    12bf:	cd 40                	int    $0x40
+    12c1:	c3                   	ret    
+
+000012c2 <open>:
+SYSCALL(open)
+    12c2:	b8 0f 00 00 00       	mov    $0xf,%eax
+    12c7:	cd 40                	int    $0x40
+    12c9:	c3                   	ret    
+
+000012ca <mknod>:
+SYSCALL(mknod)
+    12ca:	b8 11 00 00 00       	mov    $0x11,%eax
+    12cf:	cd 40                	int    $0x40
+    12d1:	c3                   	ret    
+
+000012d2 <unlink>:
+SYSCALL(unlink)
+    12d2:	b8 12 00 00 00       	mov    $0x12,%eax
+    12d7:	cd 40                	int    $0x40
+    12d9:	c3                   	ret    
+
+000012da <fstat>:
+SYSCALL(fstat)
+    12da:	b8 08 00 00 00       	mov    $0x8,%eax
+    12df:	cd 40                	int    $0x40
+    12e1:	c3                   	ret    
+
+000012e2 <link>:
+SYSCALL(link)
+    12e2:	b8 13 00 00 00       	mov    $0x13,%eax
+    12e7:	cd 40                	int    $0x40
+    12e9:	c3                   	ret    
+
+000012ea <mkdir>:
+SYSCALL(mkdir)
+    12ea:	b8 14 00 00 00       	mov    $0x14,%eax
+    12ef:	cd 40                	int    $0x40
+    12f1:	c3                   	ret    
+
+000012f2 <chdir>:
+SYSCALL(chdir)
+    12f2:	b8 09 00 00 00       	mov    $0x9,%eax
+    12f7:	cd 40                	int    $0x40
+    12f9:	c3                   	ret    
+
+000012fa <dup>:
+SYSCALL(dup)
+    12fa:	b8 0a 00 00 00       	mov    $0xa,%eax
+    12ff:	cd 40                	int    $0x40
+    1301:	c3                   	ret    
+
+00001302 <getpid>:
+SYSCALL(getpid)
+    1302:	b8 0b 00 00 00       	mov    $0xb,%eax
+    1307:	cd 40                	int    $0x40
+    1309:	c3                   	ret    
+
+0000130a <sbrk>:
+SYSCALL(sbrk)
+    130a:	b8 0c 00 00 00       	mov    $0xc,%eax
+    130f:	cd 40                	int    $0x40
+    1311:	c3                   	ret    
+
+00001312 <sleep>:
+SYSCALL(sleep)
+    1312:	b8 0d 00 00 00       	mov    $0xd,%eax
+    1317:	cd 40                	int    $0x40
+    1319:	c3                   	ret    
+
+0000131a <uptime>:
+SYSCALL(uptime)
+    131a:	b8 0e 00 00 00       	mov    $0xe,%eax
+    131f:	cd 40                	int    $0x40
+    1321:	c3                   	ret    
+
+00001322 <shm_open>:
+SYSCALL(shm_open)
+    1322:	b8 16 00 00 00       	mov    $0x16,%eax
+    1327:	cd 40                	int    $0x40
+    1329:	c3                   	ret    
+
+0000132a <shm_close>:
+SYSCALL(shm_close)	
+    132a:	b8 17 00 00 00       	mov    $0x17,%eax
+    132f:	cd 40                	int    $0x40
+    1331:	c3                   	ret    
+    1332:	66 90                	xchg   %ax,%ax
+    1334:	66 90                	xchg   %ax,%ax
+    1336:	66 90                	xchg   %ax,%ax
+    1338:	66 90                	xchg   %ax,%ax
+    133a:	66 90                	xchg   %ax,%ax
+    133c:	66 90                	xchg   %ax,%ax
+    133e:	66 90                	xchg   %ax,%ax
+
+00001340 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1340:	55                   	push   %ebp
+    1341:	89 e5                	mov    %esp,%ebp
+    1343:	57                   	push   %edi
+    1344:	56                   	push   %esi
+    1345:	89 c6                	mov    %eax,%esi
+    1347:	53                   	push   %ebx
+    1348:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    134b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    134e:	85 db                	test   %ebx,%ebx
+    1350:	74 09                	je     135b <printint+0x1b>
+    1352:	89 d0                	mov    %edx,%eax
+    1354:	c1 e8 1f             	shr    $0x1f,%eax
+    1357:	84 c0                	test   %al,%al
+    1359:	75 75                	jne    13d0 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    135b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    135d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1364:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1367:	31 ff                	xor    %edi,%edi
+    1369:	89 ce                	mov    %ecx,%esi
+    136b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    136e:	eb 02                	jmp    1372 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1370:	89 cf                	mov    %ecx,%edi
+    1372:	31 d2                	xor    %edx,%edx
+    1374:	f7 f6                	div    %esi
+    1376:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1379:	0f b6 92 9c 17 00 00 	movzbl 0x179c(%edx),%edx
+  }while((x /= base) != 0);
+    1380:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1382:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1385:	75 e9                	jne    1370 <printint+0x30>
+  if(neg)
+    1387:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    138a:	89 c8                	mov    %ecx,%eax
+    138c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    138f:	85 d2                	test   %edx,%edx
+    1391:	74 08                	je     139b <printint+0x5b>
+    buf[i++] = '-';
+    1393:	8d 4f 02             	lea    0x2(%edi),%ecx
+    1396:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    139b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    139e:	66 90                	xchg   %ax,%ax
+    13a0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    13a5:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    13a8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    13af:	00 
+    13b0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    13b4:	89 34 24             	mov    %esi,(%esp)
+    13b7:	88 45 d7             	mov    %al,-0x29(%ebp)
+    13ba:	e8 e3 fe ff ff       	call   12a2 <write>
+  while(--i >= 0)
+    13bf:	83 ff ff             	cmp    $0xffffffff,%edi
+    13c2:	75 dc                	jne    13a0 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    13c4:	83 c4 4c             	add    $0x4c,%esp
+    13c7:	5b                   	pop    %ebx
+    13c8:	5e                   	pop    %esi
+    13c9:	5f                   	pop    %edi
+    13ca:	5d                   	pop    %ebp
+    13cb:	c3                   	ret    
+    13cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    13d0:	89 d0                	mov    %edx,%eax
+    13d2:	f7 d8                	neg    %eax
+    neg = 1;
+    13d4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    13db:	eb 87                	jmp    1364 <printint+0x24>
+    13dd:	8d 76 00             	lea    0x0(%esi),%esi
+
+000013e0 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    13e0:	55                   	push   %ebp
+    13e1:	89 e5                	mov    %esp,%ebp
+    13e3:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    13e4:	31 ff                	xor    %edi,%edi
+{
+    13e6:	56                   	push   %esi
+    13e7:	53                   	push   %ebx
+    13e8:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    13eb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    13ee:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    13f1:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    13f4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    13f7:	0f b6 13             	movzbl (%ebx),%edx
+    13fa:	83 c3 01             	add    $0x1,%ebx
+    13fd:	84 d2                	test   %dl,%dl
+    13ff:	75 39                	jne    143a <printf+0x5a>
+    1401:	e9 c2 00 00 00       	jmp    14c8 <printf+0xe8>
+    1406:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    1408:	83 fa 25             	cmp    $0x25,%edx
+    140b:	0f 84 bf 00 00 00    	je     14d0 <printf+0xf0>
+  write(fd, &c, 1);
+    1411:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    1414:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    141b:	00 
+    141c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1420:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    1423:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    1426:	e8 77 fe ff ff       	call   12a2 <write>
+    142b:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    142e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    1432:	84 d2                	test   %dl,%dl
+    1434:	0f 84 8e 00 00 00    	je     14c8 <printf+0xe8>
+    if(state == 0){
+    143a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    143c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    143f:	74 c7                	je     1408 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1441:	83 ff 25             	cmp    $0x25,%edi
+    1444:	75 e5                	jne    142b <printf+0x4b>
+      if(c == 'd'){
+    1446:	83 fa 64             	cmp    $0x64,%edx
+    1449:	0f 84 31 01 00 00    	je     1580 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    144f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1454:	83 f8 70             	cmp    $0x70,%eax
+    1457:	0f 84 83 00 00 00    	je     14e0 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    145d:	83 fa 73             	cmp    $0x73,%edx
+    1460:	0f 84 a2 00 00 00    	je     1508 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1466:	83 fa 63             	cmp    $0x63,%edx
+    1469:	0f 84 35 01 00 00    	je     15a4 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    146f:	83 fa 25             	cmp    $0x25,%edx
+    1472:	0f 84 e0 00 00 00    	je     1558 <printf+0x178>
+  write(fd, &c, 1);
+    1478:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    147b:	83 c3 01             	add    $0x1,%ebx
+    147e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1485:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    1486:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    1488:	89 44 24 04          	mov    %eax,0x4(%esp)
+    148c:	89 34 24             	mov    %esi,(%esp)
+    148f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    1492:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    1496:	e8 07 fe ff ff       	call   12a2 <write>
+        putc(fd, c);
+    149b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    149e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    14a1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14a8:	00 
+    14a9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14ad:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    14b0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    14b3:	e8 ea fd ff ff       	call   12a2 <write>
+  for(i = 0; fmt[i]; i++){
+    14b8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    14bc:	84 d2                	test   %dl,%dl
+    14be:	0f 85 76 ff ff ff    	jne    143a <printf+0x5a>
+    14c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    14c8:	83 c4 3c             	add    $0x3c,%esp
+    14cb:	5b                   	pop    %ebx
+    14cc:	5e                   	pop    %esi
+    14cd:	5f                   	pop    %edi
+    14ce:	5d                   	pop    %ebp
+    14cf:	c3                   	ret    
+        state = '%';
+    14d0:	bf 25 00 00 00       	mov    $0x25,%edi
+    14d5:	e9 51 ff ff ff       	jmp    142b <printf+0x4b>
+    14da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    14e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    14e3:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    14e8:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    14ea:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    14f1:	8b 10                	mov    (%eax),%edx
+    14f3:	89 f0                	mov    %esi,%eax
+    14f5:	e8 46 fe ff ff       	call   1340 <printint>
+        ap++;
+    14fa:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    14fe:	e9 28 ff ff ff       	jmp    142b <printf+0x4b>
+    1503:	90                   	nop
+    1504:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    1508:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    150b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    150f:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    1511:	b8 95 17 00 00       	mov    $0x1795,%eax
+    1516:	85 ff                	test   %edi,%edi
+    1518:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    151b:	0f b6 07             	movzbl (%edi),%eax
+    151e:	84 c0                	test   %al,%al
+    1520:	74 2a                	je     154c <printf+0x16c>
+    1522:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1528:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    152b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    152e:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    1531:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1538:	00 
+    1539:	89 44 24 04          	mov    %eax,0x4(%esp)
+    153d:	89 34 24             	mov    %esi,(%esp)
+    1540:	e8 5d fd ff ff       	call   12a2 <write>
+        while(*s != 0){
+    1545:	0f b6 07             	movzbl (%edi),%eax
+    1548:	84 c0                	test   %al,%al
+    154a:	75 dc                	jne    1528 <printf+0x148>
+      state = 0;
+    154c:	31 ff                	xor    %edi,%edi
+    154e:	e9 d8 fe ff ff       	jmp    142b <printf+0x4b>
+    1553:	90                   	nop
+    1554:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1558:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    155b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    155d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1564:	00 
+    1565:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1569:	89 34 24             	mov    %esi,(%esp)
+    156c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1570:	e8 2d fd ff ff       	call   12a2 <write>
+    1575:	e9 b1 fe ff ff       	jmp    142b <printf+0x4b>
+    157a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    1580:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1583:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    1588:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    158b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1592:	8b 10                	mov    (%eax),%edx
+    1594:	89 f0                	mov    %esi,%eax
+    1596:	e8 a5 fd ff ff       	call   1340 <printint>
+        ap++;
+    159b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    159f:	e9 87 fe ff ff       	jmp    142b <printf+0x4b>
+        putc(fd, *ap);
+    15a4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    15a7:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    15a9:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    15ab:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    15b2:	00 
+    15b3:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    15b6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    15b9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    15bc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15c0:	e8 dd fc ff ff       	call   12a2 <write>
+        ap++;
+    15c5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15c9:	e9 5d fe ff ff       	jmp    142b <printf+0x4b>
+    15ce:	66 90                	xchg   %ax,%ax
+
+000015d0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    15d0:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15d1:	a1 58 1a 00 00       	mov    0x1a58,%eax
+{
+    15d6:	89 e5                	mov    %esp,%ebp
+    15d8:	57                   	push   %edi
+    15d9:	56                   	push   %esi
+    15da:	53                   	push   %ebx
+    15db:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15de:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    15e0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15e3:	39 d0                	cmp    %edx,%eax
+    15e5:	72 11                	jb     15f8 <free+0x28>
+    15e7:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15e8:	39 c8                	cmp    %ecx,%eax
+    15ea:	72 04                	jb     15f0 <free+0x20>
+    15ec:	39 ca                	cmp    %ecx,%edx
+    15ee:	72 10                	jb     1600 <free+0x30>
+    15f0:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15f2:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15f4:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15f6:	73 f0                	jae    15e8 <free+0x18>
+    15f8:	39 ca                	cmp    %ecx,%edx
+    15fa:	72 04                	jb     1600 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15fc:	39 c8                	cmp    %ecx,%eax
+    15fe:	72 f0                	jb     15f0 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    1600:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    1603:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    1606:	39 cf                	cmp    %ecx,%edi
+    1608:	74 1e                	je     1628 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    160a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    160d:	8b 48 04             	mov    0x4(%eax),%ecx
+    1610:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    1613:	39 f2                	cmp    %esi,%edx
+    1615:	74 28                	je     163f <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    1617:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    1619:	a3 58 1a 00 00       	mov    %eax,0x1a58
+}
+    161e:	5b                   	pop    %ebx
+    161f:	5e                   	pop    %esi
+    1620:	5f                   	pop    %edi
+    1621:	5d                   	pop    %ebp
+    1622:	c3                   	ret    
+    1623:	90                   	nop
+    1624:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    1628:	03 71 04             	add    0x4(%ecx),%esi
+    162b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    162e:	8b 08                	mov    (%eax),%ecx
+    1630:	8b 09                	mov    (%ecx),%ecx
+    1632:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    1635:	8b 48 04             	mov    0x4(%eax),%ecx
+    1638:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    163b:	39 f2                	cmp    %esi,%edx
+    163d:	75 d8                	jne    1617 <free+0x47>
+    p->s.size += bp->s.size;
+    163f:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    1642:	a3 58 1a 00 00       	mov    %eax,0x1a58
+    p->s.size += bp->s.size;
+    1647:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    164a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    164d:	89 10                	mov    %edx,(%eax)
+}
+    164f:	5b                   	pop    %ebx
+    1650:	5e                   	pop    %esi
+    1651:	5f                   	pop    %edi
+    1652:	5d                   	pop    %ebp
+    1653:	c3                   	ret    
+    1654:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    165a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001660 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1660:	55                   	push   %ebp
+    1661:	89 e5                	mov    %esp,%ebp
+    1663:	57                   	push   %edi
+    1664:	56                   	push   %esi
+    1665:	53                   	push   %ebx
+    1666:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1669:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    166c:	8b 1d 58 1a 00 00    	mov    0x1a58,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1672:	8d 48 07             	lea    0x7(%eax),%ecx
+    1675:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1678:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    167a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    167d:	0f 84 9b 00 00 00    	je     171e <malloc+0xbe>
+    1683:	8b 13                	mov    (%ebx),%edx
+    1685:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    1688:	39 fe                	cmp    %edi,%esi
+    168a:	76 64                	jbe    16f0 <malloc+0x90>
+    168c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    1693:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    1698:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    169b:	eb 0e                	jmp    16ab <malloc+0x4b>
+    169d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    16a0:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    16a2:	8b 78 04             	mov    0x4(%eax),%edi
+    16a5:	39 fe                	cmp    %edi,%esi
+    16a7:	76 4f                	jbe    16f8 <malloc+0x98>
+    16a9:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    16ab:	3b 15 58 1a 00 00    	cmp    0x1a58,%edx
+    16b1:	75 ed                	jne    16a0 <malloc+0x40>
+  if(nu < 4096)
+    16b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    16b6:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    16bc:	bf 00 10 00 00       	mov    $0x1000,%edi
+    16c1:	0f 43 fe             	cmovae %esi,%edi
+    16c4:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    16c7:	89 04 24             	mov    %eax,(%esp)
+    16ca:	e8 3b fc ff ff       	call   130a <sbrk>
+  if(p == (char*)-1)
+    16cf:	83 f8 ff             	cmp    $0xffffffff,%eax
+    16d2:	74 18                	je     16ec <malloc+0x8c>
+  hp->s.size = nu;
+    16d4:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    16d7:	83 c0 08             	add    $0x8,%eax
+    16da:	89 04 24             	mov    %eax,(%esp)
+    16dd:	e8 ee fe ff ff       	call   15d0 <free>
+  return freep;
+    16e2:	8b 15 58 1a 00 00    	mov    0x1a58,%edx
+      if((p = morecore(nunits)) == 0)
+    16e8:	85 d2                	test   %edx,%edx
+    16ea:	75 b4                	jne    16a0 <malloc+0x40>
+        return 0;
+    16ec:	31 c0                	xor    %eax,%eax
+    16ee:	eb 20                	jmp    1710 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    16f0:	89 d0                	mov    %edx,%eax
+    16f2:	89 da                	mov    %ebx,%edx
+    16f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    16f8:	39 fe                	cmp    %edi,%esi
+    16fa:	74 1c                	je     1718 <malloc+0xb8>
+        p->s.size -= nunits;
+    16fc:	29 f7                	sub    %esi,%edi
+    16fe:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    1701:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    1704:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    1707:	89 15 58 1a 00 00    	mov    %edx,0x1a58
+      return (void*)(p + 1);
+    170d:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    1710:	83 c4 1c             	add    $0x1c,%esp
+    1713:	5b                   	pop    %ebx
+    1714:	5e                   	pop    %esi
+    1715:	5f                   	pop    %edi
+    1716:	5d                   	pop    %ebp
+    1717:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    1718:	8b 08                	mov    (%eax),%ecx
+    171a:	89 0a                	mov    %ecx,(%edx)
+    171c:	eb e9                	jmp    1707 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    171e:	c7 05 58 1a 00 00 5c 	movl   $0x1a5c,0x1a58
+    1725:	1a 00 00 
+    base.s.size = 0;
+    1728:	ba 5c 1a 00 00       	mov    $0x1a5c,%edx
+    base.s.ptr = freep = prevp = &base;
+    172d:	c7 05 5c 1a 00 00 5c 	movl   $0x1a5c,0x1a5c
+    1734:	1a 00 00 
+    base.s.size = 0;
+    1737:	c7 05 60 1a 00 00 00 	movl   $0x0,0x1a60
+    173e:	00 00 00 
+    1741:	e9 46 ff ff ff       	jmp    168c <malloc+0x2c>
+    1746:	66 90                	xchg   %ax,%ax
+    1748:	66 90                	xchg   %ax,%ax
+    174a:	66 90                	xchg   %ax,%ax
+    174c:	66 90                	xchg   %ax,%ax
+    174e:	66 90                	xchg   %ax,%ax
+
+00001750 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1750:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1751:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1756:	89 e5                	mov    %esp,%ebp
+    1758:	8b 55 08             	mov    0x8(%ebp),%edx
+    175b:	90                   	nop
+    175c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1760:	89 c8                	mov    %ecx,%eax
+    1762:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1765:	85 c0                	test   %eax,%eax
+    1767:	75 f7                	jne    1760 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1769:	0f ae f0             	mfence 
+}
+    176c:	5d                   	pop    %ebp
+    176d:	c3                   	ret    
+    176e:	66 90                	xchg   %ax,%ax
+
+00001770 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1770:	55                   	push   %ebp
+    1771:	89 e5                	mov    %esp,%ebp
+    1773:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1776:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1779:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    177f:	5d                   	pop    %ebp
+    1780:	c3                   	ret    
diff --git a/kill.c b/kill.c
index 875916c..364f6af 100644
--- a/kill.c
+++ b/kill.c
@@ -9,9 +9,9 @@ main(int argc, char **argv)
 
   if(argc < 2){
     printf(2, "usage: kill pid...\n");
-    exit(1);
+    exit();
   }
   for(i=1; i<argc; i++)
     kill(atoi(argv[i]));
-  exit(0);
+  exit();
 }
diff --git a/kill.d b/kill.d
new file mode 100644
index 0000000..078f4f8
--- /dev/null
+++ b/kill.d
@@ -0,0 +1 @@
+kill.o: kill.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/kill.o b/kill.o
new file mode 100644
index 0000000..48cb2b3
Binary files /dev/null and b/kill.o differ
diff --git a/kill.sym b/kill.sym
new file mode 100644
index 0000000..a5cd1f4
--- /dev/null
+++ b/kill.sym
@@ -0,0 +1,62 @@
+00001000 .text
+00001781 .rodata
+000017b0 .eh_frame
+00001a58 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 kill.c
+00000000 ulib.c
+00000000 printf.c
+00001340 printint
+0000179c digits.1359
+00000000 umalloc.c
+00001a58 freep
+00001a5c base
+00000000 uspinlock.c
+00001060 strcpy
+000013e0 printf
+00001250 memmove
+000012ca mknod
+00001322 shm_open
+00001170 gets
+00001302 getpid
+00001660 malloc
+00001312 sleep
+00001292 pipe
+000012a2 write
+000012da fstat
+000012b2 kill
+000012f2 chdir
+000012ba exec
+0000128a wait
+0000129a read
+000012d2 unlink
+00001750 uacquire
+0000127a fork
+0000130a sbrk
+0000132a shm_close
+0000131a uptime
+00001a58 __bss_start
+00001110 memset
+00001000 main
+00001090 strcmp
+000012fa dup
+000011d0 stat
+00001a58 _edata
+00001a64 _end
+000012e2 link
+00001282 exit
+00001220 atoi
+000010e0 strlen
+000012c2 open
+00001130 strchr
+000012ea mkdir
+000012aa close
+00001770 urelease
+000015d0 free
diff --git a/lab1.c b/lab3.c
similarity index 50%
rename from lab1.c
rename to lab3.c
index 2192a52..7cf6b00 100644
--- a/lab1.c
+++ b/lab3.c
@@ -16,54 +16,11 @@
 #include "types.h"
 #include "user.h"
 
-int main(int argc, char **argv) {
+int main(int argc, char *argv[]) {
 
-    int pid;
+    int v = argc;
 
-    pid = fork();
-
-    if(pid > 0)
-    {
-        waitpid(pid, NULL, 0);
-        printf(1, "Grandpa says it's time to sleep! PID: %d\n", pid);:
-        exit(0);
-    }
-
-
-    pid = fork();
-
-    if(pid == 0)
-    {
-        printf(1, "I'm the child! PID: %d\n", pid);
-    }
-    else
-    {
-        printf(1, "I'm the parent! PID: %d\n", pid);
-        waitpid(pid, NULL, 0);
-
-    }
-
-
-    exit(0);
+    printf(1, "%d",sizeof(*argv) / sizeof(*argv[0]));
+    printf(1, "%p\n", &v);
+    exit();
 }
-//    printf(1, "Waitpid Demo Initializing...\n"); // fd=1 means standard output.
-//
-//    int defValue = -1;
-//    int* status = &defValue;
-//
-//    int pid = fork();
-//
-//
-//    if(pid > 0)
-//    while(waitpid(pid, status, 0) == -1);
-//
-//    if(pid == 0)
-//    {
-//        printf(1, "hi im the child :)\n"); // fd=1 means standard output.
-//        exit(0);
-//    }
-//
-//    printf(1, "Exit status returned is: %d\n", *status); // fd=1 means standard output.
-//
-//    exit(0);
-//}
diff --git a/lab3p2.c b/lab3p2.c
new file mode 100644
index 0000000..f94207f
--- /dev/null
+++ b/lab3p2.c
@@ -0,0 +1,31 @@
+#include "types.h"
+#include "user.h"
+
+// Prevent this function from being optimized, which might give it closed form
+#pragma GCC push_options
+#pragma GCC optimize ("O0")
+static int
+recurse(int n)
+{
+    if(n == 0)
+        return 0;
+    return n + recurse(n - 1);
+}
+#pragma GCC pop_options
+
+int
+main(int argc, char *argv[])
+{
+    int n, m;
+
+    if(argc != 2){
+        printf(1, "Usage: %s levels\n", argv[0]);
+        exit();
+    }
+
+    n = atoi(argv[1]);
+    printf(1, "Lab 3: Recursing %d levels\n", n);
+    m = recurse(n);
+    printf(1, "Lab 3: Yielded a value of %d\n", m);
+    exit();
+}
\ No newline at end of file
diff --git a/lapic.c b/lapic.c
index b22bbd7..2b71987 100644
--- a/lapic.c
+++ b/lapic.c
@@ -171,8 +171,7 @@ lapicstartap(uchar apicid, uint addr)
 #define MONTH   0x08
 #define YEAR    0x09
 
-static uint
-cmos_read(uint reg)
+static uint cmos_read(uint reg)
 {
   outb(CMOS_PORT,  reg);
   microdelay(200);
@@ -180,8 +179,7 @@ cmos_read(uint reg)
   return inb(CMOS_RETURN);
 }
 
-static void
-fill_rtcdate(struct rtcdate *r)
+static void fill_rtcdate(struct rtcdate *r)
 {
   r->second = cmos_read(SECS);
   r->minute = cmos_read(MINS);
@@ -192,8 +190,7 @@ fill_rtcdate(struct rtcdate *r)
 }
 
 // qemu seems to use 24-hour GWT and the values are BCD encoded
-void
-cmostime(struct rtcdate *r)
+void cmostime(struct rtcdate *r)
 {
   struct rtcdate t1, t2;
   int sb, bcd;
diff --git a/lapic.d b/lapic.d
new file mode 100644
index 0000000..6e62387
--- /dev/null
+++ b/lapic.d
@@ -0,0 +1,2 @@
+lapic.o: lapic.c /usr/include/stdc-predef.h param.h types.h defs.h date.h \
+ memlayout.h traps.h mmu.h x86.h
diff --git a/lapic.o b/lapic.o
new file mode 100644
index 0000000..2ce363e
Binary files /dev/null and b/lapic.o differ
diff --git a/ln.asm b/ln.asm
new file mode 100644
index 0000000..9650cfe
--- /dev/null
+++ b/ln.asm
@@ -0,0 +1,1216 @@
+
+_ln:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	53                   	push   %ebx
+    1004:	83 e4 f0             	and    $0xfffffff0,%esp
+    1007:	83 ec 10             	sub    $0x10,%esp
+    100a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  if(argc != 3){
+    100d:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
+    1011:	74 19                	je     102c <main+0x2c>
+    printf(2, "Usage: ln old new\n");
+    1013:	c7 44 24 04 91 17 00 	movl   $0x1791,0x4(%esp)
+    101a:	00 
+    101b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    1022:	e8 c9 03 00 00       	call   13f0 <printf>
+    exit();
+    1027:	e8 66 02 00 00       	call   1292 <exit>
+  }
+  if(link(argv[1], argv[2]) < 0)
+    102c:	8b 43 08             	mov    0x8(%ebx),%eax
+    102f:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1033:	8b 43 04             	mov    0x4(%ebx),%eax
+    1036:	89 04 24             	mov    %eax,(%esp)
+    1039:	e8 b4 02 00 00       	call   12f2 <link>
+    103e:	85 c0                	test   %eax,%eax
+    1040:	78 05                	js     1047 <main+0x47>
+    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+  exit();
+    1042:	e8 4b 02 00 00       	call   1292 <exit>
+    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+    1047:	8b 43 08             	mov    0x8(%ebx),%eax
+    104a:	89 44 24 0c          	mov    %eax,0xc(%esp)
+    104e:	8b 43 04             	mov    0x4(%ebx),%eax
+    1051:	c7 44 24 04 a4 17 00 	movl   $0x17a4,0x4(%esp)
+    1058:	00 
+    1059:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    1060:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1064:	e8 87 03 00 00       	call   13f0 <printf>
+    1069:	eb d7                	jmp    1042 <main+0x42>
+    106b:	66 90                	xchg   %ax,%ax
+    106d:	66 90                	xchg   %ax,%ax
+    106f:	90                   	nop
+
+00001070 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1070:	55                   	push   %ebp
+    1071:	89 e5                	mov    %esp,%ebp
+    1073:	8b 45 08             	mov    0x8(%ebp),%eax
+    1076:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1079:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    107a:	89 c2                	mov    %eax,%edx
+    107c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1080:	83 c1 01             	add    $0x1,%ecx
+    1083:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1087:	83 c2 01             	add    $0x1,%edx
+    108a:	84 db                	test   %bl,%bl
+    108c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    108f:	75 ef                	jne    1080 <strcpy+0x10>
+    ;
+  return os;
+}
+    1091:	5b                   	pop    %ebx
+    1092:	5d                   	pop    %ebp
+    1093:	c3                   	ret    
+    1094:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    109a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+000010a0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    10a0:	55                   	push   %ebp
+    10a1:	89 e5                	mov    %esp,%ebp
+    10a3:	8b 55 08             	mov    0x8(%ebp),%edx
+    10a6:	53                   	push   %ebx
+    10a7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    10aa:	0f b6 02             	movzbl (%edx),%eax
+    10ad:	84 c0                	test   %al,%al
+    10af:	74 2d                	je     10de <strcmp+0x3e>
+    10b1:	0f b6 19             	movzbl (%ecx),%ebx
+    10b4:	38 d8                	cmp    %bl,%al
+    10b6:	74 0e                	je     10c6 <strcmp+0x26>
+    10b8:	eb 2b                	jmp    10e5 <strcmp+0x45>
+    10ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    10c0:	38 c8                	cmp    %cl,%al
+    10c2:	75 15                	jne    10d9 <strcmp+0x39>
+    p++, q++;
+    10c4:	89 d9                	mov    %ebx,%ecx
+    10c6:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    10c9:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    10cc:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    10cf:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    10d3:	84 c0                	test   %al,%al
+    10d5:	75 e9                	jne    10c0 <strcmp+0x20>
+    10d7:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    10d9:	29 c8                	sub    %ecx,%eax
+}
+    10db:	5b                   	pop    %ebx
+    10dc:	5d                   	pop    %ebp
+    10dd:	c3                   	ret    
+    10de:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    10e1:	31 c0                	xor    %eax,%eax
+    10e3:	eb f4                	jmp    10d9 <strcmp+0x39>
+    10e5:	0f b6 cb             	movzbl %bl,%ecx
+    10e8:	eb ef                	jmp    10d9 <strcmp+0x39>
+    10ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000010f0 <strlen>:
+
+uint
+strlen(char *s)
+{
+    10f0:	55                   	push   %ebp
+    10f1:	89 e5                	mov    %esp,%ebp
+    10f3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    10f6:	80 39 00             	cmpb   $0x0,(%ecx)
+    10f9:	74 12                	je     110d <strlen+0x1d>
+    10fb:	31 d2                	xor    %edx,%edx
+    10fd:	8d 76 00             	lea    0x0(%esi),%esi
+    1100:	83 c2 01             	add    $0x1,%edx
+    1103:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    1107:	89 d0                	mov    %edx,%eax
+    1109:	75 f5                	jne    1100 <strlen+0x10>
+    ;
+  return n;
+}
+    110b:	5d                   	pop    %ebp
+    110c:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    110d:	31 c0                	xor    %eax,%eax
+}
+    110f:	5d                   	pop    %ebp
+    1110:	c3                   	ret    
+    1111:	eb 0d                	jmp    1120 <memset>
+    1113:	90                   	nop
+    1114:	90                   	nop
+    1115:	90                   	nop
+    1116:	90                   	nop
+    1117:	90                   	nop
+    1118:	90                   	nop
+    1119:	90                   	nop
+    111a:	90                   	nop
+    111b:	90                   	nop
+    111c:	90                   	nop
+    111d:	90                   	nop
+    111e:	90                   	nop
+    111f:	90                   	nop
+
+00001120 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    1120:	55                   	push   %ebp
+    1121:	89 e5                	mov    %esp,%ebp
+    1123:	8b 55 08             	mov    0x8(%ebp),%edx
+    1126:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    1127:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    112a:	8b 45 0c             	mov    0xc(%ebp),%eax
+    112d:	89 d7                	mov    %edx,%edi
+    112f:	fc                   	cld    
+    1130:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    1132:	89 d0                	mov    %edx,%eax
+    1134:	5f                   	pop    %edi
+    1135:	5d                   	pop    %ebp
+    1136:	c3                   	ret    
+    1137:	89 f6                	mov    %esi,%esi
+    1139:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001140 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    1140:	55                   	push   %ebp
+    1141:	89 e5                	mov    %esp,%ebp
+    1143:	8b 45 08             	mov    0x8(%ebp),%eax
+    1146:	53                   	push   %ebx
+    1147:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    114a:	0f b6 18             	movzbl (%eax),%ebx
+    114d:	84 db                	test   %bl,%bl
+    114f:	74 1d                	je     116e <strchr+0x2e>
+    if(*s == c)
+    1151:	38 d3                	cmp    %dl,%bl
+    1153:	89 d1                	mov    %edx,%ecx
+    1155:	75 0d                	jne    1164 <strchr+0x24>
+    1157:	eb 17                	jmp    1170 <strchr+0x30>
+    1159:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1160:	38 ca                	cmp    %cl,%dl
+    1162:	74 0c                	je     1170 <strchr+0x30>
+  for(; *s; s++)
+    1164:	83 c0 01             	add    $0x1,%eax
+    1167:	0f b6 10             	movzbl (%eax),%edx
+    116a:	84 d2                	test   %dl,%dl
+    116c:	75 f2                	jne    1160 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    116e:	31 c0                	xor    %eax,%eax
+}
+    1170:	5b                   	pop    %ebx
+    1171:	5d                   	pop    %ebp
+    1172:	c3                   	ret    
+    1173:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1179:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001180 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1180:	55                   	push   %ebp
+    1181:	89 e5                	mov    %esp,%ebp
+    1183:	57                   	push   %edi
+    1184:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1185:	31 f6                	xor    %esi,%esi
+{
+    1187:	53                   	push   %ebx
+    1188:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    118b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    118e:	eb 31                	jmp    11c1 <gets+0x41>
+    cc = read(0, &c, 1);
+    1190:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1197:	00 
+    1198:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    119c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    11a3:	e8 02 01 00 00       	call   12aa <read>
+    if(cc < 1)
+    11a8:	85 c0                	test   %eax,%eax
+    11aa:	7e 1d                	jle    11c9 <gets+0x49>
+      break;
+    buf[i++] = c;
+    11ac:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    11b0:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    11b2:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    11b5:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    11b7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    11bb:	74 0c                	je     11c9 <gets+0x49>
+    11bd:	3c 0a                	cmp    $0xa,%al
+    11bf:	74 08                	je     11c9 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    11c1:	8d 5e 01             	lea    0x1(%esi),%ebx
+    11c4:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    11c7:	7c c7                	jl     1190 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    11c9:	8b 45 08             	mov    0x8(%ebp),%eax
+    11cc:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    11d0:	83 c4 2c             	add    $0x2c,%esp
+    11d3:	5b                   	pop    %ebx
+    11d4:	5e                   	pop    %esi
+    11d5:	5f                   	pop    %edi
+    11d6:	5d                   	pop    %ebp
+    11d7:	c3                   	ret    
+    11d8:	90                   	nop
+    11d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000011e0 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    11e0:	55                   	push   %ebp
+    11e1:	89 e5                	mov    %esp,%ebp
+    11e3:	56                   	push   %esi
+    11e4:	53                   	push   %ebx
+    11e5:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    11e8:	8b 45 08             	mov    0x8(%ebp),%eax
+    11eb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    11f2:	00 
+    11f3:	89 04 24             	mov    %eax,(%esp)
+    11f6:	e8 d7 00 00 00       	call   12d2 <open>
+  if(fd < 0)
+    11fb:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    11fd:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    11ff:	78 27                	js     1228 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    1201:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1204:	89 1c 24             	mov    %ebx,(%esp)
+    1207:	89 44 24 04          	mov    %eax,0x4(%esp)
+    120b:	e8 da 00 00 00       	call   12ea <fstat>
+  close(fd);
+    1210:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    1213:	89 c6                	mov    %eax,%esi
+  close(fd);
+    1215:	e8 a0 00 00 00       	call   12ba <close>
+  return r;
+    121a:	89 f0                	mov    %esi,%eax
+}
+    121c:	83 c4 10             	add    $0x10,%esp
+    121f:	5b                   	pop    %ebx
+    1220:	5e                   	pop    %esi
+    1221:	5d                   	pop    %ebp
+    1222:	c3                   	ret    
+    1223:	90                   	nop
+    1224:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    1228:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    122d:	eb ed                	jmp    121c <stat+0x3c>
+    122f:	90                   	nop
+
+00001230 <atoi>:
+
+int
+atoi(const char *s)
+{
+    1230:	55                   	push   %ebp
+    1231:	89 e5                	mov    %esp,%ebp
+    1233:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    1236:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    1237:	0f be 11             	movsbl (%ecx),%edx
+    123a:	8d 42 d0             	lea    -0x30(%edx),%eax
+    123d:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    123f:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    1244:	77 17                	ja     125d <atoi+0x2d>
+    1246:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    1248:	83 c1 01             	add    $0x1,%ecx
+    124b:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    124e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1252:	0f be 11             	movsbl (%ecx),%edx
+    1255:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1258:	80 fb 09             	cmp    $0x9,%bl
+    125b:	76 eb                	jbe    1248 <atoi+0x18>
+  return n;
+}
+    125d:	5b                   	pop    %ebx
+    125e:	5d                   	pop    %ebp
+    125f:	c3                   	ret    
+
+00001260 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1260:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1261:	31 d2                	xor    %edx,%edx
+{
+    1263:	89 e5                	mov    %esp,%ebp
+    1265:	56                   	push   %esi
+    1266:	8b 45 08             	mov    0x8(%ebp),%eax
+    1269:	53                   	push   %ebx
+    126a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    126d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1270:	85 db                	test   %ebx,%ebx
+    1272:	7e 12                	jle    1286 <memmove+0x26>
+    1274:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1278:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    127c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    127f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1282:	39 da                	cmp    %ebx,%edx
+    1284:	75 f2                	jne    1278 <memmove+0x18>
+  return vdst;
+}
+    1286:	5b                   	pop    %ebx
+    1287:	5e                   	pop    %esi
+    1288:	5d                   	pop    %ebp
+    1289:	c3                   	ret    
+
+0000128a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    128a:	b8 01 00 00 00       	mov    $0x1,%eax
+    128f:	cd 40                	int    $0x40
+    1291:	c3                   	ret    
+
+00001292 <exit>:
+SYSCALL(exit)
+    1292:	b8 02 00 00 00       	mov    $0x2,%eax
+    1297:	cd 40                	int    $0x40
+    1299:	c3                   	ret    
+
+0000129a <wait>:
+SYSCALL(wait)
+    129a:	b8 03 00 00 00       	mov    $0x3,%eax
+    129f:	cd 40                	int    $0x40
+    12a1:	c3                   	ret    
+
+000012a2 <pipe>:
+SYSCALL(pipe)
+    12a2:	b8 04 00 00 00       	mov    $0x4,%eax
+    12a7:	cd 40                	int    $0x40
+    12a9:	c3                   	ret    
+
+000012aa <read>:
+SYSCALL(read)
+    12aa:	b8 05 00 00 00       	mov    $0x5,%eax
+    12af:	cd 40                	int    $0x40
+    12b1:	c3                   	ret    
+
+000012b2 <write>:
+SYSCALL(write)
+    12b2:	b8 10 00 00 00       	mov    $0x10,%eax
+    12b7:	cd 40                	int    $0x40
+    12b9:	c3                   	ret    
+
+000012ba <close>:
+SYSCALL(close)
+    12ba:	b8 15 00 00 00       	mov    $0x15,%eax
+    12bf:	cd 40                	int    $0x40
+    12c1:	c3                   	ret    
+
+000012c2 <kill>:
+SYSCALL(kill)
+    12c2:	b8 06 00 00 00       	mov    $0x6,%eax
+    12c7:	cd 40                	int    $0x40
+    12c9:	c3                   	ret    
+
+000012ca <exec>:
+SYSCALL(exec)
+    12ca:	b8 07 00 00 00       	mov    $0x7,%eax
+    12cf:	cd 40                	int    $0x40
+    12d1:	c3                   	ret    
+
+000012d2 <open>:
+SYSCALL(open)
+    12d2:	b8 0f 00 00 00       	mov    $0xf,%eax
+    12d7:	cd 40                	int    $0x40
+    12d9:	c3                   	ret    
+
+000012da <mknod>:
+SYSCALL(mknod)
+    12da:	b8 11 00 00 00       	mov    $0x11,%eax
+    12df:	cd 40                	int    $0x40
+    12e1:	c3                   	ret    
+
+000012e2 <unlink>:
+SYSCALL(unlink)
+    12e2:	b8 12 00 00 00       	mov    $0x12,%eax
+    12e7:	cd 40                	int    $0x40
+    12e9:	c3                   	ret    
+
+000012ea <fstat>:
+SYSCALL(fstat)
+    12ea:	b8 08 00 00 00       	mov    $0x8,%eax
+    12ef:	cd 40                	int    $0x40
+    12f1:	c3                   	ret    
+
+000012f2 <link>:
+SYSCALL(link)
+    12f2:	b8 13 00 00 00       	mov    $0x13,%eax
+    12f7:	cd 40                	int    $0x40
+    12f9:	c3                   	ret    
+
+000012fa <mkdir>:
+SYSCALL(mkdir)
+    12fa:	b8 14 00 00 00       	mov    $0x14,%eax
+    12ff:	cd 40                	int    $0x40
+    1301:	c3                   	ret    
+
+00001302 <chdir>:
+SYSCALL(chdir)
+    1302:	b8 09 00 00 00       	mov    $0x9,%eax
+    1307:	cd 40                	int    $0x40
+    1309:	c3                   	ret    
+
+0000130a <dup>:
+SYSCALL(dup)
+    130a:	b8 0a 00 00 00       	mov    $0xa,%eax
+    130f:	cd 40                	int    $0x40
+    1311:	c3                   	ret    
+
+00001312 <getpid>:
+SYSCALL(getpid)
+    1312:	b8 0b 00 00 00       	mov    $0xb,%eax
+    1317:	cd 40                	int    $0x40
+    1319:	c3                   	ret    
+
+0000131a <sbrk>:
+SYSCALL(sbrk)
+    131a:	b8 0c 00 00 00       	mov    $0xc,%eax
+    131f:	cd 40                	int    $0x40
+    1321:	c3                   	ret    
+
+00001322 <sleep>:
+SYSCALL(sleep)
+    1322:	b8 0d 00 00 00       	mov    $0xd,%eax
+    1327:	cd 40                	int    $0x40
+    1329:	c3                   	ret    
+
+0000132a <uptime>:
+SYSCALL(uptime)
+    132a:	b8 0e 00 00 00       	mov    $0xe,%eax
+    132f:	cd 40                	int    $0x40
+    1331:	c3                   	ret    
+
+00001332 <shm_open>:
+SYSCALL(shm_open)
+    1332:	b8 16 00 00 00       	mov    $0x16,%eax
+    1337:	cd 40                	int    $0x40
+    1339:	c3                   	ret    
+
+0000133a <shm_close>:
+SYSCALL(shm_close)	
+    133a:	b8 17 00 00 00       	mov    $0x17,%eax
+    133f:	cd 40                	int    $0x40
+    1341:	c3                   	ret    
+    1342:	66 90                	xchg   %ax,%ax
+    1344:	66 90                	xchg   %ax,%ax
+    1346:	66 90                	xchg   %ax,%ax
+    1348:	66 90                	xchg   %ax,%ax
+    134a:	66 90                	xchg   %ax,%ax
+    134c:	66 90                	xchg   %ax,%ax
+    134e:	66 90                	xchg   %ax,%ax
+
+00001350 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1350:	55                   	push   %ebp
+    1351:	89 e5                	mov    %esp,%ebp
+    1353:	57                   	push   %edi
+    1354:	56                   	push   %esi
+    1355:	89 c6                	mov    %eax,%esi
+    1357:	53                   	push   %ebx
+    1358:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    135b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    135e:	85 db                	test   %ebx,%ebx
+    1360:	74 09                	je     136b <printint+0x1b>
+    1362:	89 d0                	mov    %edx,%eax
+    1364:	c1 e8 1f             	shr    $0x1f,%eax
+    1367:	84 c0                	test   %al,%al
+    1369:	75 75                	jne    13e0 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    136b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    136d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1374:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1377:	31 ff                	xor    %edi,%edi
+    1379:	89 ce                	mov    %ecx,%esi
+    137b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    137e:	eb 02                	jmp    1382 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1380:	89 cf                	mov    %ecx,%edi
+    1382:	31 d2                	xor    %edx,%edx
+    1384:	f7 f6                	div    %esi
+    1386:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1389:	0f b6 92 bf 17 00 00 	movzbl 0x17bf(%edx),%edx
+  }while((x /= base) != 0);
+    1390:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1392:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1395:	75 e9                	jne    1380 <printint+0x30>
+  if(neg)
+    1397:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    139a:	89 c8                	mov    %ecx,%eax
+    139c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    139f:	85 d2                	test   %edx,%edx
+    13a1:	74 08                	je     13ab <printint+0x5b>
+    buf[i++] = '-';
+    13a3:	8d 4f 02             	lea    0x2(%edi),%ecx
+    13a6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    13ab:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    13ae:	66 90                	xchg   %ax,%ax
+    13b0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    13b5:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    13b8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    13bf:	00 
+    13c0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    13c4:	89 34 24             	mov    %esi,(%esp)
+    13c7:	88 45 d7             	mov    %al,-0x29(%ebp)
+    13ca:	e8 e3 fe ff ff       	call   12b2 <write>
+  while(--i >= 0)
+    13cf:	83 ff ff             	cmp    $0xffffffff,%edi
+    13d2:	75 dc                	jne    13b0 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    13d4:	83 c4 4c             	add    $0x4c,%esp
+    13d7:	5b                   	pop    %ebx
+    13d8:	5e                   	pop    %esi
+    13d9:	5f                   	pop    %edi
+    13da:	5d                   	pop    %ebp
+    13db:	c3                   	ret    
+    13dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    13e0:	89 d0                	mov    %edx,%eax
+    13e2:	f7 d8                	neg    %eax
+    neg = 1;
+    13e4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    13eb:	eb 87                	jmp    1374 <printint+0x24>
+    13ed:	8d 76 00             	lea    0x0(%esi),%esi
+
+000013f0 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    13f0:	55                   	push   %ebp
+    13f1:	89 e5                	mov    %esp,%ebp
+    13f3:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    13f4:	31 ff                	xor    %edi,%edi
+{
+    13f6:	56                   	push   %esi
+    13f7:	53                   	push   %ebx
+    13f8:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    13fb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    13fe:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    1401:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    1404:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    1407:	0f b6 13             	movzbl (%ebx),%edx
+    140a:	83 c3 01             	add    $0x1,%ebx
+    140d:	84 d2                	test   %dl,%dl
+    140f:	75 39                	jne    144a <printf+0x5a>
+    1411:	e9 c2 00 00 00       	jmp    14d8 <printf+0xe8>
+    1416:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    1418:	83 fa 25             	cmp    $0x25,%edx
+    141b:	0f 84 bf 00 00 00    	je     14e0 <printf+0xf0>
+  write(fd, &c, 1);
+    1421:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    1424:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    142b:	00 
+    142c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1430:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    1433:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    1436:	e8 77 fe ff ff       	call   12b2 <write>
+    143b:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    143e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    1442:	84 d2                	test   %dl,%dl
+    1444:	0f 84 8e 00 00 00    	je     14d8 <printf+0xe8>
+    if(state == 0){
+    144a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    144c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    144f:	74 c7                	je     1418 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1451:	83 ff 25             	cmp    $0x25,%edi
+    1454:	75 e5                	jne    143b <printf+0x4b>
+      if(c == 'd'){
+    1456:	83 fa 64             	cmp    $0x64,%edx
+    1459:	0f 84 31 01 00 00    	je     1590 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    145f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1464:	83 f8 70             	cmp    $0x70,%eax
+    1467:	0f 84 83 00 00 00    	je     14f0 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    146d:	83 fa 73             	cmp    $0x73,%edx
+    1470:	0f 84 a2 00 00 00    	je     1518 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1476:	83 fa 63             	cmp    $0x63,%edx
+    1479:	0f 84 35 01 00 00    	je     15b4 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    147f:	83 fa 25             	cmp    $0x25,%edx
+    1482:	0f 84 e0 00 00 00    	je     1568 <printf+0x178>
+  write(fd, &c, 1);
+    1488:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    148b:	83 c3 01             	add    $0x1,%ebx
+    148e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1495:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    1496:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    1498:	89 44 24 04          	mov    %eax,0x4(%esp)
+    149c:	89 34 24             	mov    %esi,(%esp)
+    149f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    14a2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    14a6:	e8 07 fe ff ff       	call   12b2 <write>
+        putc(fd, c);
+    14ab:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    14ae:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    14b1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14b8:	00 
+    14b9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14bd:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    14c0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    14c3:	e8 ea fd ff ff       	call   12b2 <write>
+  for(i = 0; fmt[i]; i++){
+    14c8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    14cc:	84 d2                	test   %dl,%dl
+    14ce:	0f 85 76 ff ff ff    	jne    144a <printf+0x5a>
+    14d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    14d8:	83 c4 3c             	add    $0x3c,%esp
+    14db:	5b                   	pop    %ebx
+    14dc:	5e                   	pop    %esi
+    14dd:	5f                   	pop    %edi
+    14de:	5d                   	pop    %ebp
+    14df:	c3                   	ret    
+        state = '%';
+    14e0:	bf 25 00 00 00       	mov    $0x25,%edi
+    14e5:	e9 51 ff ff ff       	jmp    143b <printf+0x4b>
+    14ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    14f0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    14f3:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    14f8:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    14fa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1501:	8b 10                	mov    (%eax),%edx
+    1503:	89 f0                	mov    %esi,%eax
+    1505:	e8 46 fe ff ff       	call   1350 <printint>
+        ap++;
+    150a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    150e:	e9 28 ff ff ff       	jmp    143b <printf+0x4b>
+    1513:	90                   	nop
+    1514:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    1518:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    151b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    151f:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    1521:	b8 b8 17 00 00       	mov    $0x17b8,%eax
+    1526:	85 ff                	test   %edi,%edi
+    1528:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    152b:	0f b6 07             	movzbl (%edi),%eax
+    152e:	84 c0                	test   %al,%al
+    1530:	74 2a                	je     155c <printf+0x16c>
+    1532:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1538:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    153b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    153e:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    1541:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1548:	00 
+    1549:	89 44 24 04          	mov    %eax,0x4(%esp)
+    154d:	89 34 24             	mov    %esi,(%esp)
+    1550:	e8 5d fd ff ff       	call   12b2 <write>
+        while(*s != 0){
+    1555:	0f b6 07             	movzbl (%edi),%eax
+    1558:	84 c0                	test   %al,%al
+    155a:	75 dc                	jne    1538 <printf+0x148>
+      state = 0;
+    155c:	31 ff                	xor    %edi,%edi
+    155e:	e9 d8 fe ff ff       	jmp    143b <printf+0x4b>
+    1563:	90                   	nop
+    1564:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1568:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    156b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    156d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1574:	00 
+    1575:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1579:	89 34 24             	mov    %esi,(%esp)
+    157c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1580:	e8 2d fd ff ff       	call   12b2 <write>
+    1585:	e9 b1 fe ff ff       	jmp    143b <printf+0x4b>
+    158a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    1590:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1593:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    1598:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    159b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    15a2:	8b 10                	mov    (%eax),%edx
+    15a4:	89 f0                	mov    %esi,%eax
+    15a6:	e8 a5 fd ff ff       	call   1350 <printint>
+        ap++;
+    15ab:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15af:	e9 87 fe ff ff       	jmp    143b <printf+0x4b>
+        putc(fd, *ap);
+    15b4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    15b7:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    15b9:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    15bb:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    15c2:	00 
+    15c3:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    15c6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    15c9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    15cc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15d0:	e8 dd fc ff ff       	call   12b2 <write>
+        ap++;
+    15d5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15d9:	e9 5d fe ff ff       	jmp    143b <printf+0x4b>
+    15de:	66 90                	xchg   %ax,%ax
+
+000015e0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    15e0:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15e1:	a1 74 1a 00 00       	mov    0x1a74,%eax
+{
+    15e6:	89 e5                	mov    %esp,%ebp
+    15e8:	57                   	push   %edi
+    15e9:	56                   	push   %esi
+    15ea:	53                   	push   %ebx
+    15eb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15ee:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    15f0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15f3:	39 d0                	cmp    %edx,%eax
+    15f5:	72 11                	jb     1608 <free+0x28>
+    15f7:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15f8:	39 c8                	cmp    %ecx,%eax
+    15fa:	72 04                	jb     1600 <free+0x20>
+    15fc:	39 ca                	cmp    %ecx,%edx
+    15fe:	72 10                	jb     1610 <free+0x30>
+    1600:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1602:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1604:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1606:	73 f0                	jae    15f8 <free+0x18>
+    1608:	39 ca                	cmp    %ecx,%edx
+    160a:	72 04                	jb     1610 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    160c:	39 c8                	cmp    %ecx,%eax
+    160e:	72 f0                	jb     1600 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    1610:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    1613:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    1616:	39 cf                	cmp    %ecx,%edi
+    1618:	74 1e                	je     1638 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    161a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    161d:	8b 48 04             	mov    0x4(%eax),%ecx
+    1620:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    1623:	39 f2                	cmp    %esi,%edx
+    1625:	74 28                	je     164f <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    1627:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    1629:	a3 74 1a 00 00       	mov    %eax,0x1a74
+}
+    162e:	5b                   	pop    %ebx
+    162f:	5e                   	pop    %esi
+    1630:	5f                   	pop    %edi
+    1631:	5d                   	pop    %ebp
+    1632:	c3                   	ret    
+    1633:	90                   	nop
+    1634:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    1638:	03 71 04             	add    0x4(%ecx),%esi
+    163b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    163e:	8b 08                	mov    (%eax),%ecx
+    1640:	8b 09                	mov    (%ecx),%ecx
+    1642:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    1645:	8b 48 04             	mov    0x4(%eax),%ecx
+    1648:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    164b:	39 f2                	cmp    %esi,%edx
+    164d:	75 d8                	jne    1627 <free+0x47>
+    p->s.size += bp->s.size;
+    164f:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    1652:	a3 74 1a 00 00       	mov    %eax,0x1a74
+    p->s.size += bp->s.size;
+    1657:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    165a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    165d:	89 10                	mov    %edx,(%eax)
+}
+    165f:	5b                   	pop    %ebx
+    1660:	5e                   	pop    %esi
+    1661:	5f                   	pop    %edi
+    1662:	5d                   	pop    %ebp
+    1663:	c3                   	ret    
+    1664:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    166a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001670 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1670:	55                   	push   %ebp
+    1671:	89 e5                	mov    %esp,%ebp
+    1673:	57                   	push   %edi
+    1674:	56                   	push   %esi
+    1675:	53                   	push   %ebx
+    1676:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1679:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    167c:	8b 1d 74 1a 00 00    	mov    0x1a74,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1682:	8d 48 07             	lea    0x7(%eax),%ecx
+    1685:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1688:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    168a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    168d:	0f 84 9b 00 00 00    	je     172e <malloc+0xbe>
+    1693:	8b 13                	mov    (%ebx),%edx
+    1695:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    1698:	39 fe                	cmp    %edi,%esi
+    169a:	76 64                	jbe    1700 <malloc+0x90>
+    169c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    16a3:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    16a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    16ab:	eb 0e                	jmp    16bb <malloc+0x4b>
+    16ad:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    16b0:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    16b2:	8b 78 04             	mov    0x4(%eax),%edi
+    16b5:	39 fe                	cmp    %edi,%esi
+    16b7:	76 4f                	jbe    1708 <malloc+0x98>
+    16b9:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    16bb:	3b 15 74 1a 00 00    	cmp    0x1a74,%edx
+    16c1:	75 ed                	jne    16b0 <malloc+0x40>
+  if(nu < 4096)
+    16c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    16c6:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    16cc:	bf 00 10 00 00       	mov    $0x1000,%edi
+    16d1:	0f 43 fe             	cmovae %esi,%edi
+    16d4:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    16d7:	89 04 24             	mov    %eax,(%esp)
+    16da:	e8 3b fc ff ff       	call   131a <sbrk>
+  if(p == (char*)-1)
+    16df:	83 f8 ff             	cmp    $0xffffffff,%eax
+    16e2:	74 18                	je     16fc <malloc+0x8c>
+  hp->s.size = nu;
+    16e4:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    16e7:	83 c0 08             	add    $0x8,%eax
+    16ea:	89 04 24             	mov    %eax,(%esp)
+    16ed:	e8 ee fe ff ff       	call   15e0 <free>
+  return freep;
+    16f2:	8b 15 74 1a 00 00    	mov    0x1a74,%edx
+      if((p = morecore(nunits)) == 0)
+    16f8:	85 d2                	test   %edx,%edx
+    16fa:	75 b4                	jne    16b0 <malloc+0x40>
+        return 0;
+    16fc:	31 c0                	xor    %eax,%eax
+    16fe:	eb 20                	jmp    1720 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    1700:	89 d0                	mov    %edx,%eax
+    1702:	89 da                	mov    %ebx,%edx
+    1704:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    1708:	39 fe                	cmp    %edi,%esi
+    170a:	74 1c                	je     1728 <malloc+0xb8>
+        p->s.size -= nunits;
+    170c:	29 f7                	sub    %esi,%edi
+    170e:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    1711:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    1714:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    1717:	89 15 74 1a 00 00    	mov    %edx,0x1a74
+      return (void*)(p + 1);
+    171d:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    1720:	83 c4 1c             	add    $0x1c,%esp
+    1723:	5b                   	pop    %ebx
+    1724:	5e                   	pop    %esi
+    1725:	5f                   	pop    %edi
+    1726:	5d                   	pop    %ebp
+    1727:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    1728:	8b 08                	mov    (%eax),%ecx
+    172a:	89 0a                	mov    %ecx,(%edx)
+    172c:	eb e9                	jmp    1717 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    172e:	c7 05 74 1a 00 00 78 	movl   $0x1a78,0x1a74
+    1735:	1a 00 00 
+    base.s.size = 0;
+    1738:	ba 78 1a 00 00       	mov    $0x1a78,%edx
+    base.s.ptr = freep = prevp = &base;
+    173d:	c7 05 78 1a 00 00 78 	movl   $0x1a78,0x1a78
+    1744:	1a 00 00 
+    base.s.size = 0;
+    1747:	c7 05 7c 1a 00 00 00 	movl   $0x0,0x1a7c
+    174e:	00 00 00 
+    1751:	e9 46 ff ff ff       	jmp    169c <malloc+0x2c>
+    1756:	66 90                	xchg   %ax,%ax
+    1758:	66 90                	xchg   %ax,%ax
+    175a:	66 90                	xchg   %ax,%ax
+    175c:	66 90                	xchg   %ax,%ax
+    175e:	66 90                	xchg   %ax,%ax
+
+00001760 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1760:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1761:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1766:	89 e5                	mov    %esp,%ebp
+    1768:	8b 55 08             	mov    0x8(%ebp),%edx
+    176b:	90                   	nop
+    176c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1770:	89 c8                	mov    %ecx,%eax
+    1772:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1775:	85 c0                	test   %eax,%eax
+    1777:	75 f7                	jne    1770 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1779:	0f ae f0             	mfence 
+}
+    177c:	5d                   	pop    %ebp
+    177d:	c3                   	ret    
+    177e:	66 90                	xchg   %ax,%ax
+
+00001780 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1780:	55                   	push   %ebp
+    1781:	89 e5                	mov    %esp,%ebp
+    1783:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1786:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1789:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    178f:	5d                   	pop    %ebp
+    1790:	c3                   	ret    
diff --git a/ln.c b/ln.c
index fb17c3b..cf8a64e 100644
--- a/ln.c
+++ b/ln.c
@@ -7,9 +7,9 @@ main(int argc, char *argv[])
 {
   if(argc != 3){
     printf(2, "Usage: ln old new\n");
-    exit(1);
+    exit();
   }
   if(link(argv[1], argv[2]) < 0)
     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
-  exit(0);
+  exit();
 }
diff --git a/ln.d b/ln.d
new file mode 100644
index 0000000..6728be9
--- /dev/null
+++ b/ln.d
@@ -0,0 +1 @@
+ln.o: ln.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/ln.o b/ln.o
new file mode 100644
index 0000000..04ba7a6
Binary files /dev/null and b/ln.o differ
diff --git a/ln.sym b/ln.sym
new file mode 100644
index 0000000..2f16578
--- /dev/null
+++ b/ln.sym
@@ -0,0 +1,62 @@
+00001000 .text
+00001791 .rodata
+000017d0 .eh_frame
+00001a74 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 ln.c
+00000000 ulib.c
+00000000 printf.c
+00001350 printint
+000017bf digits.1359
+00000000 umalloc.c
+00001a74 freep
+00001a78 base
+00000000 uspinlock.c
+00001070 strcpy
+000013f0 printf
+00001260 memmove
+000012da mknod
+00001332 shm_open
+00001180 gets
+00001312 getpid
+00001670 malloc
+00001322 sleep
+000012a2 pipe
+000012b2 write
+000012ea fstat
+000012c2 kill
+00001302 chdir
+000012ca exec
+0000129a wait
+000012aa read
+000012e2 unlink
+00001760 uacquire
+0000128a fork
+0000131a sbrk
+0000133a shm_close
+0000132a uptime
+00001a74 __bss_start
+00001120 memset
+00001000 main
+000010a0 strcmp
+0000130a dup
+000011e0 stat
+00001a74 _edata
+00001a80 _end
+000012f2 link
+00001292 exit
+00001230 atoi
+000010f0 strlen
+000012d2 open
+00001140 strchr
+000012fa mkdir
+000012ba close
+00001780 urelease
+000015e0 free
diff --git a/log.d b/log.d
new file mode 100644
index 0000000..04c8930
--- /dev/null
+++ b/log.d
@@ -0,0 +1,2 @@
+log.o: log.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h \
+ sleeplock.h fs.h buf.h
diff --git a/log.o b/log.o
new file mode 100644
index 0000000..16594c6
Binary files /dev/null and b/log.o differ
diff --git a/ls.asm b/ls.asm
new file mode 100644
index 0000000..1fed3e4
--- /dev/null
+++ b/ls.asm
@@ -0,0 +1,1467 @@
+
+_ls:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+  close(fd);
+}
+
+int
+main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	57                   	push   %edi
+    1004:	56                   	push   %esi
+    1005:	53                   	push   %ebx
+  int i;
+
+  if(argc < 2){
+    1006:	bb 01 00 00 00       	mov    $0x1,%ebx
+{
+    100b:	83 e4 f0             	and    $0xfffffff0,%esp
+    100e:	83 ec 10             	sub    $0x10,%esp
+    1011:	8b 75 08             	mov    0x8(%ebp),%esi
+    1014:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  if(argc < 2){
+    1017:	83 fe 01             	cmp    $0x1,%esi
+    101a:	7e 1b                	jle    1037 <main+0x37>
+    101c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    ls(".");
+    exit();
+  }
+  for(i=1; i<argc; i++)
+    ls(argv[i]);
+    1020:	8b 04 9f             	mov    (%edi,%ebx,4),%eax
+  for(i=1; i<argc; i++)
+    1023:	83 c3 01             	add    $0x1,%ebx
+    ls(argv[i]);
+    1026:	89 04 24             	mov    %eax,(%esp)
+    1029:	e8 c2 00 00 00       	call   10f0 <ls>
+  for(i=1; i<argc; i++)
+    102e:	39 f3                	cmp    %esi,%ebx
+    1030:	75 ee                	jne    1020 <main+0x20>
+  exit();
+    1032:	e8 6b 05 00 00       	call   15a2 <exit>
+    ls(".");
+    1037:	c7 04 24 e9 1a 00 00 	movl   $0x1ae9,(%esp)
+    103e:	e8 ad 00 00 00       	call   10f0 <ls>
+    exit();
+    1043:	e8 5a 05 00 00       	call   15a2 <exit>
+    1048:	66 90                	xchg   %ax,%ax
+    104a:	66 90                	xchg   %ax,%ax
+    104c:	66 90                	xchg   %ax,%ax
+    104e:	66 90                	xchg   %ax,%ax
+
+00001050 <fmtname>:
+{
+    1050:	55                   	push   %ebp
+    1051:	89 e5                	mov    %esp,%ebp
+    1053:	56                   	push   %esi
+    1054:	53                   	push   %ebx
+    1055:	83 ec 10             	sub    $0x10,%esp
+    1058:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+    105b:	89 1c 24             	mov    %ebx,(%esp)
+    105e:	e8 9d 03 00 00       	call   1400 <strlen>
+    1063:	01 d8                	add    %ebx,%eax
+    1065:	73 10                	jae    1077 <fmtname+0x27>
+    1067:	eb 13                	jmp    107c <fmtname+0x2c>
+    1069:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1070:	83 e8 01             	sub    $0x1,%eax
+    1073:	39 c3                	cmp    %eax,%ebx
+    1075:	77 05                	ja     107c <fmtname+0x2c>
+    1077:	80 38 2f             	cmpb   $0x2f,(%eax)
+    107a:	75 f4                	jne    1070 <fmtname+0x20>
+  p++;
+    107c:	8d 58 01             	lea    0x1(%eax),%ebx
+  if(strlen(p) >= DIRSIZ)
+    107f:	89 1c 24             	mov    %ebx,(%esp)
+    1082:	e8 79 03 00 00       	call   1400 <strlen>
+    1087:	83 f8 0d             	cmp    $0xd,%eax
+    108a:	77 53                	ja     10df <fmtname+0x8f>
+  memmove(buf, p, strlen(p));
+    108c:	89 1c 24             	mov    %ebx,(%esp)
+    108f:	e8 6c 03 00 00       	call   1400 <strlen>
+    1094:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1098:	c7 04 24 14 1e 00 00 	movl   $0x1e14,(%esp)
+    109f:	89 44 24 08          	mov    %eax,0x8(%esp)
+    10a3:	e8 c8 04 00 00       	call   1570 <memmove>
+  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+    10a8:	89 1c 24             	mov    %ebx,(%esp)
+    10ab:	e8 50 03 00 00       	call   1400 <strlen>
+    10b0:	89 1c 24             	mov    %ebx,(%esp)
+  return buf;
+    10b3:	bb 14 1e 00 00       	mov    $0x1e14,%ebx
+  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+    10b8:	89 c6                	mov    %eax,%esi
+    10ba:	e8 41 03 00 00       	call   1400 <strlen>
+    10bf:	ba 0e 00 00 00       	mov    $0xe,%edx
+    10c4:	29 f2                	sub    %esi,%edx
+    10c6:	89 54 24 08          	mov    %edx,0x8(%esp)
+    10ca:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
+    10d1:	00 
+    10d2:	05 14 1e 00 00       	add    $0x1e14,%eax
+    10d7:	89 04 24             	mov    %eax,(%esp)
+    10da:	e8 51 03 00 00       	call   1430 <memset>
+}
+    10df:	83 c4 10             	add    $0x10,%esp
+    10e2:	89 d8                	mov    %ebx,%eax
+    10e4:	5b                   	pop    %ebx
+    10e5:	5e                   	pop    %esi
+    10e6:	5d                   	pop    %ebp
+    10e7:	c3                   	ret    
+    10e8:	90                   	nop
+    10e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000010f0 <ls>:
+{
+    10f0:	55                   	push   %ebp
+    10f1:	89 e5                	mov    %esp,%ebp
+    10f3:	57                   	push   %edi
+    10f4:	56                   	push   %esi
+    10f5:	53                   	push   %ebx
+    10f6:	81 ec 6c 02 00 00    	sub    $0x26c,%esp
+    10fc:	8b 7d 08             	mov    0x8(%ebp),%edi
+  if((fd = open(path, 0)) < 0){
+    10ff:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1106:	00 
+    1107:	89 3c 24             	mov    %edi,(%esp)
+    110a:	e8 d3 04 00 00       	call   15e2 <open>
+    110f:	85 c0                	test   %eax,%eax
+    1111:	89 c3                	mov    %eax,%ebx
+    1113:	0f 88 c7 01 00 00    	js     12e0 <ls+0x1f0>
+  if(fstat(fd, &st) < 0){
+    1119:	8d b5 d4 fd ff ff    	lea    -0x22c(%ebp),%esi
+    111f:	89 74 24 04          	mov    %esi,0x4(%esp)
+    1123:	89 04 24             	mov    %eax,(%esp)
+    1126:	e8 cf 04 00 00       	call   15fa <fstat>
+    112b:	85 c0                	test   %eax,%eax
+    112d:	0f 88 f5 01 00 00    	js     1328 <ls+0x238>
+  switch(st.type){
+    1133:	0f b7 85 d4 fd ff ff 	movzwl -0x22c(%ebp),%eax
+    113a:	66 83 f8 01          	cmp    $0x1,%ax
+    113e:	74 68                	je     11a8 <ls+0xb8>
+    1140:	66 83 f8 02          	cmp    $0x2,%ax
+    1144:	75 48                	jne    118e <ls+0x9e>
+    printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
+    1146:	8b 95 e4 fd ff ff    	mov    -0x21c(%ebp),%edx
+    114c:	89 3c 24             	mov    %edi,(%esp)
+    114f:	8b b5 dc fd ff ff    	mov    -0x224(%ebp),%esi
+    1155:	89 95 b4 fd ff ff    	mov    %edx,-0x24c(%ebp)
+    115b:	e8 f0 fe ff ff       	call   1050 <fmtname>
+    1160:	8b 95 b4 fd ff ff    	mov    -0x24c(%ebp),%edx
+    1166:	89 74 24 10          	mov    %esi,0x10(%esp)
+    116a:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+    1171:	00 
+    1172:	c7 44 24 04 c9 1a 00 	movl   $0x1ac9,0x4(%esp)
+    1179:	00 
+    117a:	89 54 24 14          	mov    %edx,0x14(%esp)
+    117e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1185:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1189:	e8 72 05 00 00       	call   1700 <printf>
+  close(fd);
+    118e:	89 1c 24             	mov    %ebx,(%esp)
+    1191:	e8 34 04 00 00       	call   15ca <close>
+}
+    1196:	81 c4 6c 02 00 00    	add    $0x26c,%esp
+    119c:	5b                   	pop    %ebx
+    119d:	5e                   	pop    %esi
+    119e:	5f                   	pop    %edi
+    119f:	5d                   	pop    %ebp
+    11a0:	c3                   	ret    
+    11a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+    11a8:	89 3c 24             	mov    %edi,(%esp)
+    11ab:	e8 50 02 00 00       	call   1400 <strlen>
+    11b0:	83 c0 10             	add    $0x10,%eax
+    11b3:	3d 00 02 00 00       	cmp    $0x200,%eax
+    11b8:	0f 87 4a 01 00 00    	ja     1308 <ls+0x218>
+    strcpy(buf, path);
+    11be:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
+    11c4:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    11c8:	8d bd c4 fd ff ff    	lea    -0x23c(%ebp),%edi
+    11ce:	89 04 24             	mov    %eax,(%esp)
+    11d1:	e8 aa 01 00 00       	call   1380 <strcpy>
+    p = buf+strlen(buf);
+    11d6:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
+    11dc:	89 04 24             	mov    %eax,(%esp)
+    11df:	e8 1c 02 00 00       	call   1400 <strlen>
+    11e4:	8d 8d e8 fd ff ff    	lea    -0x218(%ebp),%ecx
+    11ea:	01 c8                	add    %ecx,%eax
+    *p++ = '/';
+    11ec:	8d 48 01             	lea    0x1(%eax),%ecx
+    p = buf+strlen(buf);
+    11ef:	89 85 a8 fd ff ff    	mov    %eax,-0x258(%ebp)
+    *p++ = '/';
+    11f5:	89 8d a4 fd ff ff    	mov    %ecx,-0x25c(%ebp)
+    11fb:	c6 00 2f             	movb   $0x2f,(%eax)
+    11fe:	66 90                	xchg   %ax,%ax
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+    1200:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+    1207:	00 
+    1208:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    120c:	89 1c 24             	mov    %ebx,(%esp)
+    120f:	e8 a6 03 00 00       	call   15ba <read>
+    1214:	83 f8 10             	cmp    $0x10,%eax
+    1217:	0f 85 71 ff ff ff    	jne    118e <ls+0x9e>
+      if(de.inum == 0)
+    121d:	66 83 bd c4 fd ff ff 	cmpw   $0x0,-0x23c(%ebp)
+    1224:	00 
+    1225:	74 d9                	je     1200 <ls+0x110>
+      memmove(p, de.name, DIRSIZ);
+    1227:	8d 85 c6 fd ff ff    	lea    -0x23a(%ebp),%eax
+    122d:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1231:	8b 85 a4 fd ff ff    	mov    -0x25c(%ebp),%eax
+    1237:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp)
+    123e:	00 
+    123f:	89 04 24             	mov    %eax,(%esp)
+    1242:	e8 29 03 00 00       	call   1570 <memmove>
+      p[DIRSIZ] = 0;
+    1247:	8b 85 a8 fd ff ff    	mov    -0x258(%ebp),%eax
+    124d:	c6 40 0f 00          	movb   $0x0,0xf(%eax)
+      if(stat(buf, &st) < 0){
+    1251:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
+    1257:	89 74 24 04          	mov    %esi,0x4(%esp)
+    125b:	89 04 24             	mov    %eax,(%esp)
+    125e:	e8 8d 02 00 00       	call   14f0 <stat>
+    1263:	85 c0                	test   %eax,%eax
+    1265:	0f 88 e5 00 00 00    	js     1350 <ls+0x260>
+      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
+    126b:	0f bf 95 d4 fd ff ff 	movswl -0x22c(%ebp),%edx
+    1272:	8b 8d e4 fd ff ff    	mov    -0x21c(%ebp),%ecx
+    1278:	8b 85 dc fd ff ff    	mov    -0x224(%ebp),%eax
+    127e:	89 95 b0 fd ff ff    	mov    %edx,-0x250(%ebp)
+    1284:	8d 95 e8 fd ff ff    	lea    -0x218(%ebp),%edx
+    128a:	89 14 24             	mov    %edx,(%esp)
+    128d:	89 8d ac fd ff ff    	mov    %ecx,-0x254(%ebp)
+    1293:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
+    1299:	e8 b2 fd ff ff       	call   1050 <fmtname>
+    129e:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
+    12a4:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
+    12aa:	c7 44 24 04 c9 1a 00 	movl   $0x1ac9,0x4(%esp)
+    12b1:	00 
+    12b2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    12b9:	89 4c 24 14          	mov    %ecx,0x14(%esp)
+    12bd:	8b 8d b4 fd ff ff    	mov    -0x24c(%ebp),%ecx
+    12c3:	89 54 24 0c          	mov    %edx,0xc(%esp)
+    12c7:	89 44 24 08          	mov    %eax,0x8(%esp)
+    12cb:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+    12cf:	e8 2c 04 00 00       	call   1700 <printf>
+    12d4:	e9 27 ff ff ff       	jmp    1200 <ls+0x110>
+    12d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    printf(2, "ls: cannot open %s\n", path);
+    12e0:	89 7c 24 08          	mov    %edi,0x8(%esp)
+    12e4:	c7 44 24 04 a1 1a 00 	movl   $0x1aa1,0x4(%esp)
+    12eb:	00 
+    12ec:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    12f3:	e8 08 04 00 00       	call   1700 <printf>
+}
+    12f8:	81 c4 6c 02 00 00    	add    $0x26c,%esp
+    12fe:	5b                   	pop    %ebx
+    12ff:	5e                   	pop    %esi
+    1300:	5f                   	pop    %edi
+    1301:	5d                   	pop    %ebp
+    1302:	c3                   	ret    
+    1303:	90                   	nop
+    1304:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      printf(1, "ls: path too long\n");
+    1308:	c7 44 24 04 d6 1a 00 	movl   $0x1ad6,0x4(%esp)
+    130f:	00 
+    1310:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1317:	e8 e4 03 00 00       	call   1700 <printf>
+      break;
+    131c:	e9 6d fe ff ff       	jmp    118e <ls+0x9e>
+    1321:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    printf(2, "ls: cannot stat %s\n", path);
+    1328:	89 7c 24 08          	mov    %edi,0x8(%esp)
+    132c:	c7 44 24 04 b5 1a 00 	movl   $0x1ab5,0x4(%esp)
+    1333:	00 
+    1334:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    133b:	e8 c0 03 00 00       	call   1700 <printf>
+    close(fd);
+    1340:	89 1c 24             	mov    %ebx,(%esp)
+    1343:	e8 82 02 00 00       	call   15ca <close>
+    return;
+    1348:	e9 49 fe ff ff       	jmp    1196 <ls+0xa6>
+    134d:	8d 76 00             	lea    0x0(%esi),%esi
+        printf(1, "ls: cannot stat %s\n", buf);
+    1350:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
+    1356:	89 44 24 08          	mov    %eax,0x8(%esp)
+    135a:	c7 44 24 04 b5 1a 00 	movl   $0x1ab5,0x4(%esp)
+    1361:	00 
+    1362:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1369:	e8 92 03 00 00       	call   1700 <printf>
+        continue;
+    136e:	e9 8d fe ff ff       	jmp    1200 <ls+0x110>
+    1373:	66 90                	xchg   %ax,%ax
+    1375:	66 90                	xchg   %ax,%ax
+    1377:	66 90                	xchg   %ax,%ax
+    1379:	66 90                	xchg   %ax,%ax
+    137b:	66 90                	xchg   %ax,%ax
+    137d:	66 90                	xchg   %ax,%ax
+    137f:	90                   	nop
+
+00001380 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1380:	55                   	push   %ebp
+    1381:	89 e5                	mov    %esp,%ebp
+    1383:	8b 45 08             	mov    0x8(%ebp),%eax
+    1386:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1389:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    138a:	89 c2                	mov    %eax,%edx
+    138c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1390:	83 c1 01             	add    $0x1,%ecx
+    1393:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1397:	83 c2 01             	add    $0x1,%edx
+    139a:	84 db                	test   %bl,%bl
+    139c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    139f:	75 ef                	jne    1390 <strcpy+0x10>
+    ;
+  return os;
+}
+    13a1:	5b                   	pop    %ebx
+    13a2:	5d                   	pop    %ebp
+    13a3:	c3                   	ret    
+    13a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    13aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+000013b0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    13b0:	55                   	push   %ebp
+    13b1:	89 e5                	mov    %esp,%ebp
+    13b3:	8b 55 08             	mov    0x8(%ebp),%edx
+    13b6:	53                   	push   %ebx
+    13b7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    13ba:	0f b6 02             	movzbl (%edx),%eax
+    13bd:	84 c0                	test   %al,%al
+    13bf:	74 2d                	je     13ee <strcmp+0x3e>
+    13c1:	0f b6 19             	movzbl (%ecx),%ebx
+    13c4:	38 d8                	cmp    %bl,%al
+    13c6:	74 0e                	je     13d6 <strcmp+0x26>
+    13c8:	eb 2b                	jmp    13f5 <strcmp+0x45>
+    13ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    13d0:	38 c8                	cmp    %cl,%al
+    13d2:	75 15                	jne    13e9 <strcmp+0x39>
+    p++, q++;
+    13d4:	89 d9                	mov    %ebx,%ecx
+    13d6:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    13d9:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    13dc:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    13df:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    13e3:	84 c0                	test   %al,%al
+    13e5:	75 e9                	jne    13d0 <strcmp+0x20>
+    13e7:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    13e9:	29 c8                	sub    %ecx,%eax
+}
+    13eb:	5b                   	pop    %ebx
+    13ec:	5d                   	pop    %ebp
+    13ed:	c3                   	ret    
+    13ee:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    13f1:	31 c0                	xor    %eax,%eax
+    13f3:	eb f4                	jmp    13e9 <strcmp+0x39>
+    13f5:	0f b6 cb             	movzbl %bl,%ecx
+    13f8:	eb ef                	jmp    13e9 <strcmp+0x39>
+    13fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001400 <strlen>:
+
+uint
+strlen(char *s)
+{
+    1400:	55                   	push   %ebp
+    1401:	89 e5                	mov    %esp,%ebp
+    1403:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    1406:	80 39 00             	cmpb   $0x0,(%ecx)
+    1409:	74 12                	je     141d <strlen+0x1d>
+    140b:	31 d2                	xor    %edx,%edx
+    140d:	8d 76 00             	lea    0x0(%esi),%esi
+    1410:	83 c2 01             	add    $0x1,%edx
+    1413:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    1417:	89 d0                	mov    %edx,%eax
+    1419:	75 f5                	jne    1410 <strlen+0x10>
+    ;
+  return n;
+}
+    141b:	5d                   	pop    %ebp
+    141c:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    141d:	31 c0                	xor    %eax,%eax
+}
+    141f:	5d                   	pop    %ebp
+    1420:	c3                   	ret    
+    1421:	eb 0d                	jmp    1430 <memset>
+    1423:	90                   	nop
+    1424:	90                   	nop
+    1425:	90                   	nop
+    1426:	90                   	nop
+    1427:	90                   	nop
+    1428:	90                   	nop
+    1429:	90                   	nop
+    142a:	90                   	nop
+    142b:	90                   	nop
+    142c:	90                   	nop
+    142d:	90                   	nop
+    142e:	90                   	nop
+    142f:	90                   	nop
+
+00001430 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    1430:	55                   	push   %ebp
+    1431:	89 e5                	mov    %esp,%ebp
+    1433:	8b 55 08             	mov    0x8(%ebp),%edx
+    1436:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    1437:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    143a:	8b 45 0c             	mov    0xc(%ebp),%eax
+    143d:	89 d7                	mov    %edx,%edi
+    143f:	fc                   	cld    
+    1440:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    1442:	89 d0                	mov    %edx,%eax
+    1444:	5f                   	pop    %edi
+    1445:	5d                   	pop    %ebp
+    1446:	c3                   	ret    
+    1447:	89 f6                	mov    %esi,%esi
+    1449:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001450 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    1450:	55                   	push   %ebp
+    1451:	89 e5                	mov    %esp,%ebp
+    1453:	8b 45 08             	mov    0x8(%ebp),%eax
+    1456:	53                   	push   %ebx
+    1457:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    145a:	0f b6 18             	movzbl (%eax),%ebx
+    145d:	84 db                	test   %bl,%bl
+    145f:	74 1d                	je     147e <strchr+0x2e>
+    if(*s == c)
+    1461:	38 d3                	cmp    %dl,%bl
+    1463:	89 d1                	mov    %edx,%ecx
+    1465:	75 0d                	jne    1474 <strchr+0x24>
+    1467:	eb 17                	jmp    1480 <strchr+0x30>
+    1469:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1470:	38 ca                	cmp    %cl,%dl
+    1472:	74 0c                	je     1480 <strchr+0x30>
+  for(; *s; s++)
+    1474:	83 c0 01             	add    $0x1,%eax
+    1477:	0f b6 10             	movzbl (%eax),%edx
+    147a:	84 d2                	test   %dl,%dl
+    147c:	75 f2                	jne    1470 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    147e:	31 c0                	xor    %eax,%eax
+}
+    1480:	5b                   	pop    %ebx
+    1481:	5d                   	pop    %ebp
+    1482:	c3                   	ret    
+    1483:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1489:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001490 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1490:	55                   	push   %ebp
+    1491:	89 e5                	mov    %esp,%ebp
+    1493:	57                   	push   %edi
+    1494:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1495:	31 f6                	xor    %esi,%esi
+{
+    1497:	53                   	push   %ebx
+    1498:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    149b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    149e:	eb 31                	jmp    14d1 <gets+0x41>
+    cc = read(0, &c, 1);
+    14a0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14a7:	00 
+    14a8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    14ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    14b3:	e8 02 01 00 00       	call   15ba <read>
+    if(cc < 1)
+    14b8:	85 c0                	test   %eax,%eax
+    14ba:	7e 1d                	jle    14d9 <gets+0x49>
+      break;
+    buf[i++] = c;
+    14bc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    14c0:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    14c2:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    14c5:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    14c7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    14cb:	74 0c                	je     14d9 <gets+0x49>
+    14cd:	3c 0a                	cmp    $0xa,%al
+    14cf:	74 08                	je     14d9 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    14d1:	8d 5e 01             	lea    0x1(%esi),%ebx
+    14d4:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    14d7:	7c c7                	jl     14a0 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    14d9:	8b 45 08             	mov    0x8(%ebp),%eax
+    14dc:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    14e0:	83 c4 2c             	add    $0x2c,%esp
+    14e3:	5b                   	pop    %ebx
+    14e4:	5e                   	pop    %esi
+    14e5:	5f                   	pop    %edi
+    14e6:	5d                   	pop    %ebp
+    14e7:	c3                   	ret    
+    14e8:	90                   	nop
+    14e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000014f0 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    14f0:	55                   	push   %ebp
+    14f1:	89 e5                	mov    %esp,%ebp
+    14f3:	56                   	push   %esi
+    14f4:	53                   	push   %ebx
+    14f5:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    14f8:	8b 45 08             	mov    0x8(%ebp),%eax
+    14fb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1502:	00 
+    1503:	89 04 24             	mov    %eax,(%esp)
+    1506:	e8 d7 00 00 00       	call   15e2 <open>
+  if(fd < 0)
+    150b:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    150d:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    150f:	78 27                	js     1538 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    1511:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1514:	89 1c 24             	mov    %ebx,(%esp)
+    1517:	89 44 24 04          	mov    %eax,0x4(%esp)
+    151b:	e8 da 00 00 00       	call   15fa <fstat>
+  close(fd);
+    1520:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    1523:	89 c6                	mov    %eax,%esi
+  close(fd);
+    1525:	e8 a0 00 00 00       	call   15ca <close>
+  return r;
+    152a:	89 f0                	mov    %esi,%eax
+}
+    152c:	83 c4 10             	add    $0x10,%esp
+    152f:	5b                   	pop    %ebx
+    1530:	5e                   	pop    %esi
+    1531:	5d                   	pop    %ebp
+    1532:	c3                   	ret    
+    1533:	90                   	nop
+    1534:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    1538:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    153d:	eb ed                	jmp    152c <stat+0x3c>
+    153f:	90                   	nop
+
+00001540 <atoi>:
+
+int
+atoi(const char *s)
+{
+    1540:	55                   	push   %ebp
+    1541:	89 e5                	mov    %esp,%ebp
+    1543:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    1546:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    1547:	0f be 11             	movsbl (%ecx),%edx
+    154a:	8d 42 d0             	lea    -0x30(%edx),%eax
+    154d:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    154f:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    1554:	77 17                	ja     156d <atoi+0x2d>
+    1556:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    1558:	83 c1 01             	add    $0x1,%ecx
+    155b:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    155e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1562:	0f be 11             	movsbl (%ecx),%edx
+    1565:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1568:	80 fb 09             	cmp    $0x9,%bl
+    156b:	76 eb                	jbe    1558 <atoi+0x18>
+  return n;
+}
+    156d:	5b                   	pop    %ebx
+    156e:	5d                   	pop    %ebp
+    156f:	c3                   	ret    
+
+00001570 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1570:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1571:	31 d2                	xor    %edx,%edx
+{
+    1573:	89 e5                	mov    %esp,%ebp
+    1575:	56                   	push   %esi
+    1576:	8b 45 08             	mov    0x8(%ebp),%eax
+    1579:	53                   	push   %ebx
+    157a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    157d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1580:	85 db                	test   %ebx,%ebx
+    1582:	7e 12                	jle    1596 <memmove+0x26>
+    1584:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1588:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    158c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    158f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1592:	39 da                	cmp    %ebx,%edx
+    1594:	75 f2                	jne    1588 <memmove+0x18>
+  return vdst;
+}
+    1596:	5b                   	pop    %ebx
+    1597:	5e                   	pop    %esi
+    1598:	5d                   	pop    %ebp
+    1599:	c3                   	ret    
+
+0000159a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    159a:	b8 01 00 00 00       	mov    $0x1,%eax
+    159f:	cd 40                	int    $0x40
+    15a1:	c3                   	ret    
+
+000015a2 <exit>:
+SYSCALL(exit)
+    15a2:	b8 02 00 00 00       	mov    $0x2,%eax
+    15a7:	cd 40                	int    $0x40
+    15a9:	c3                   	ret    
+
+000015aa <wait>:
+SYSCALL(wait)
+    15aa:	b8 03 00 00 00       	mov    $0x3,%eax
+    15af:	cd 40                	int    $0x40
+    15b1:	c3                   	ret    
+
+000015b2 <pipe>:
+SYSCALL(pipe)
+    15b2:	b8 04 00 00 00       	mov    $0x4,%eax
+    15b7:	cd 40                	int    $0x40
+    15b9:	c3                   	ret    
+
+000015ba <read>:
+SYSCALL(read)
+    15ba:	b8 05 00 00 00       	mov    $0x5,%eax
+    15bf:	cd 40                	int    $0x40
+    15c1:	c3                   	ret    
+
+000015c2 <write>:
+SYSCALL(write)
+    15c2:	b8 10 00 00 00       	mov    $0x10,%eax
+    15c7:	cd 40                	int    $0x40
+    15c9:	c3                   	ret    
+
+000015ca <close>:
+SYSCALL(close)
+    15ca:	b8 15 00 00 00       	mov    $0x15,%eax
+    15cf:	cd 40                	int    $0x40
+    15d1:	c3                   	ret    
+
+000015d2 <kill>:
+SYSCALL(kill)
+    15d2:	b8 06 00 00 00       	mov    $0x6,%eax
+    15d7:	cd 40                	int    $0x40
+    15d9:	c3                   	ret    
+
+000015da <exec>:
+SYSCALL(exec)
+    15da:	b8 07 00 00 00       	mov    $0x7,%eax
+    15df:	cd 40                	int    $0x40
+    15e1:	c3                   	ret    
+
+000015e2 <open>:
+SYSCALL(open)
+    15e2:	b8 0f 00 00 00       	mov    $0xf,%eax
+    15e7:	cd 40                	int    $0x40
+    15e9:	c3                   	ret    
+
+000015ea <mknod>:
+SYSCALL(mknod)
+    15ea:	b8 11 00 00 00       	mov    $0x11,%eax
+    15ef:	cd 40                	int    $0x40
+    15f1:	c3                   	ret    
+
+000015f2 <unlink>:
+SYSCALL(unlink)
+    15f2:	b8 12 00 00 00       	mov    $0x12,%eax
+    15f7:	cd 40                	int    $0x40
+    15f9:	c3                   	ret    
+
+000015fa <fstat>:
+SYSCALL(fstat)
+    15fa:	b8 08 00 00 00       	mov    $0x8,%eax
+    15ff:	cd 40                	int    $0x40
+    1601:	c3                   	ret    
+
+00001602 <link>:
+SYSCALL(link)
+    1602:	b8 13 00 00 00       	mov    $0x13,%eax
+    1607:	cd 40                	int    $0x40
+    1609:	c3                   	ret    
+
+0000160a <mkdir>:
+SYSCALL(mkdir)
+    160a:	b8 14 00 00 00       	mov    $0x14,%eax
+    160f:	cd 40                	int    $0x40
+    1611:	c3                   	ret    
+
+00001612 <chdir>:
+SYSCALL(chdir)
+    1612:	b8 09 00 00 00       	mov    $0x9,%eax
+    1617:	cd 40                	int    $0x40
+    1619:	c3                   	ret    
+
+0000161a <dup>:
+SYSCALL(dup)
+    161a:	b8 0a 00 00 00       	mov    $0xa,%eax
+    161f:	cd 40                	int    $0x40
+    1621:	c3                   	ret    
+
+00001622 <getpid>:
+SYSCALL(getpid)
+    1622:	b8 0b 00 00 00       	mov    $0xb,%eax
+    1627:	cd 40                	int    $0x40
+    1629:	c3                   	ret    
+
+0000162a <sbrk>:
+SYSCALL(sbrk)
+    162a:	b8 0c 00 00 00       	mov    $0xc,%eax
+    162f:	cd 40                	int    $0x40
+    1631:	c3                   	ret    
+
+00001632 <sleep>:
+SYSCALL(sleep)
+    1632:	b8 0d 00 00 00       	mov    $0xd,%eax
+    1637:	cd 40                	int    $0x40
+    1639:	c3                   	ret    
+
+0000163a <uptime>:
+SYSCALL(uptime)
+    163a:	b8 0e 00 00 00       	mov    $0xe,%eax
+    163f:	cd 40                	int    $0x40
+    1641:	c3                   	ret    
+
+00001642 <shm_open>:
+SYSCALL(shm_open)
+    1642:	b8 16 00 00 00       	mov    $0x16,%eax
+    1647:	cd 40                	int    $0x40
+    1649:	c3                   	ret    
+
+0000164a <shm_close>:
+SYSCALL(shm_close)	
+    164a:	b8 17 00 00 00       	mov    $0x17,%eax
+    164f:	cd 40                	int    $0x40
+    1651:	c3                   	ret    
+    1652:	66 90                	xchg   %ax,%ax
+    1654:	66 90                	xchg   %ax,%ax
+    1656:	66 90                	xchg   %ax,%ax
+    1658:	66 90                	xchg   %ax,%ax
+    165a:	66 90                	xchg   %ax,%ax
+    165c:	66 90                	xchg   %ax,%ax
+    165e:	66 90                	xchg   %ax,%ax
+
+00001660 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1660:	55                   	push   %ebp
+    1661:	89 e5                	mov    %esp,%ebp
+    1663:	57                   	push   %edi
+    1664:	56                   	push   %esi
+    1665:	89 c6                	mov    %eax,%esi
+    1667:	53                   	push   %ebx
+    1668:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    166b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    166e:	85 db                	test   %ebx,%ebx
+    1670:	74 09                	je     167b <printint+0x1b>
+    1672:	89 d0                	mov    %edx,%eax
+    1674:	c1 e8 1f             	shr    $0x1f,%eax
+    1677:	84 c0                	test   %al,%al
+    1679:	75 75                	jne    16f0 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    167b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    167d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1684:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1687:	31 ff                	xor    %edi,%edi
+    1689:	89 ce                	mov    %ecx,%esi
+    168b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    168e:	eb 02                	jmp    1692 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1690:	89 cf                	mov    %ecx,%edi
+    1692:	31 d2                	xor    %edx,%edx
+    1694:	f7 f6                	div    %esi
+    1696:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1699:	0f b6 92 f2 1a 00 00 	movzbl 0x1af2(%edx),%edx
+  }while((x /= base) != 0);
+    16a0:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    16a2:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    16a5:	75 e9                	jne    1690 <printint+0x30>
+  if(neg)
+    16a7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    16aa:	89 c8                	mov    %ecx,%eax
+    16ac:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    16af:	85 d2                	test   %edx,%edx
+    16b1:	74 08                	je     16bb <printint+0x5b>
+    buf[i++] = '-';
+    16b3:	8d 4f 02             	lea    0x2(%edi),%ecx
+    16b6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    16bb:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    16be:	66 90                	xchg   %ax,%ax
+    16c0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    16c5:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    16c8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    16cf:	00 
+    16d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    16d4:	89 34 24             	mov    %esi,(%esp)
+    16d7:	88 45 d7             	mov    %al,-0x29(%ebp)
+    16da:	e8 e3 fe ff ff       	call   15c2 <write>
+  while(--i >= 0)
+    16df:	83 ff ff             	cmp    $0xffffffff,%edi
+    16e2:	75 dc                	jne    16c0 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    16e4:	83 c4 4c             	add    $0x4c,%esp
+    16e7:	5b                   	pop    %ebx
+    16e8:	5e                   	pop    %esi
+    16e9:	5f                   	pop    %edi
+    16ea:	5d                   	pop    %ebp
+    16eb:	c3                   	ret    
+    16ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    16f0:	89 d0                	mov    %edx,%eax
+    16f2:	f7 d8                	neg    %eax
+    neg = 1;
+    16f4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    16fb:	eb 87                	jmp    1684 <printint+0x24>
+    16fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+00001700 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    1700:	55                   	push   %ebp
+    1701:	89 e5                	mov    %esp,%ebp
+    1703:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    1704:	31 ff                	xor    %edi,%edi
+{
+    1706:	56                   	push   %esi
+    1707:	53                   	push   %ebx
+    1708:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    170b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    170e:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    1711:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    1714:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    1717:	0f b6 13             	movzbl (%ebx),%edx
+    171a:	83 c3 01             	add    $0x1,%ebx
+    171d:	84 d2                	test   %dl,%dl
+    171f:	75 39                	jne    175a <printf+0x5a>
+    1721:	e9 c2 00 00 00       	jmp    17e8 <printf+0xe8>
+    1726:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    1728:	83 fa 25             	cmp    $0x25,%edx
+    172b:	0f 84 bf 00 00 00    	je     17f0 <printf+0xf0>
+  write(fd, &c, 1);
+    1731:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    1734:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    173b:	00 
+    173c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1740:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    1743:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    1746:	e8 77 fe ff ff       	call   15c2 <write>
+    174b:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    174e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    1752:	84 d2                	test   %dl,%dl
+    1754:	0f 84 8e 00 00 00    	je     17e8 <printf+0xe8>
+    if(state == 0){
+    175a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    175c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    175f:	74 c7                	je     1728 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1761:	83 ff 25             	cmp    $0x25,%edi
+    1764:	75 e5                	jne    174b <printf+0x4b>
+      if(c == 'd'){
+    1766:	83 fa 64             	cmp    $0x64,%edx
+    1769:	0f 84 31 01 00 00    	je     18a0 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    176f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1774:	83 f8 70             	cmp    $0x70,%eax
+    1777:	0f 84 83 00 00 00    	je     1800 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    177d:	83 fa 73             	cmp    $0x73,%edx
+    1780:	0f 84 a2 00 00 00    	je     1828 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1786:	83 fa 63             	cmp    $0x63,%edx
+    1789:	0f 84 35 01 00 00    	je     18c4 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    178f:	83 fa 25             	cmp    $0x25,%edx
+    1792:	0f 84 e0 00 00 00    	je     1878 <printf+0x178>
+  write(fd, &c, 1);
+    1798:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    179b:	83 c3 01             	add    $0x1,%ebx
+    179e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    17a5:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    17a6:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    17a8:	89 44 24 04          	mov    %eax,0x4(%esp)
+    17ac:	89 34 24             	mov    %esi,(%esp)
+    17af:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    17b2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    17b6:	e8 07 fe ff ff       	call   15c2 <write>
+        putc(fd, c);
+    17bb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    17be:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    17c1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    17c8:	00 
+    17c9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    17cd:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    17d0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    17d3:	e8 ea fd ff ff       	call   15c2 <write>
+  for(i = 0; fmt[i]; i++){
+    17d8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    17dc:	84 d2                	test   %dl,%dl
+    17de:	0f 85 76 ff ff ff    	jne    175a <printf+0x5a>
+    17e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    17e8:	83 c4 3c             	add    $0x3c,%esp
+    17eb:	5b                   	pop    %ebx
+    17ec:	5e                   	pop    %esi
+    17ed:	5f                   	pop    %edi
+    17ee:	5d                   	pop    %ebp
+    17ef:	c3                   	ret    
+        state = '%';
+    17f0:	bf 25 00 00 00       	mov    $0x25,%edi
+    17f5:	e9 51 ff ff ff       	jmp    174b <printf+0x4b>
+    17fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    1800:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1803:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    1808:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    180a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1811:	8b 10                	mov    (%eax),%edx
+    1813:	89 f0                	mov    %esi,%eax
+    1815:	e8 46 fe ff ff       	call   1660 <printint>
+        ap++;
+    181a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    181e:	e9 28 ff ff ff       	jmp    174b <printf+0x4b>
+    1823:	90                   	nop
+    1824:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    1828:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    182b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    182f:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    1831:	b8 eb 1a 00 00       	mov    $0x1aeb,%eax
+    1836:	85 ff                	test   %edi,%edi
+    1838:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    183b:	0f b6 07             	movzbl (%edi),%eax
+    183e:	84 c0                	test   %al,%al
+    1840:	74 2a                	je     186c <printf+0x16c>
+    1842:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1848:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    184b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    184e:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    1851:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1858:	00 
+    1859:	89 44 24 04          	mov    %eax,0x4(%esp)
+    185d:	89 34 24             	mov    %esi,(%esp)
+    1860:	e8 5d fd ff ff       	call   15c2 <write>
+        while(*s != 0){
+    1865:	0f b6 07             	movzbl (%edi),%eax
+    1868:	84 c0                	test   %al,%al
+    186a:	75 dc                	jne    1848 <printf+0x148>
+      state = 0;
+    186c:	31 ff                	xor    %edi,%edi
+    186e:	e9 d8 fe ff ff       	jmp    174b <printf+0x4b>
+    1873:	90                   	nop
+    1874:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1878:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    187b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    187d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1884:	00 
+    1885:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1889:	89 34 24             	mov    %esi,(%esp)
+    188c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1890:	e8 2d fd ff ff       	call   15c2 <write>
+    1895:	e9 b1 fe ff ff       	jmp    174b <printf+0x4b>
+    189a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    18a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    18a3:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    18a8:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    18ab:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    18b2:	8b 10                	mov    (%eax),%edx
+    18b4:	89 f0                	mov    %esi,%eax
+    18b6:	e8 a5 fd ff ff       	call   1660 <printint>
+        ap++;
+    18bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    18bf:	e9 87 fe ff ff       	jmp    174b <printf+0x4b>
+        putc(fd, *ap);
+    18c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    18c7:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    18c9:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    18cb:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    18d2:	00 
+    18d3:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    18d6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    18d9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    18dc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    18e0:	e8 dd fc ff ff       	call   15c2 <write>
+        ap++;
+    18e5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    18e9:	e9 5d fe ff ff       	jmp    174b <printf+0x4b>
+    18ee:	66 90                	xchg   %ax,%ax
+
+000018f0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    18f0:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    18f1:	a1 24 1e 00 00       	mov    0x1e24,%eax
+{
+    18f6:	89 e5                	mov    %esp,%ebp
+    18f8:	57                   	push   %edi
+    18f9:	56                   	push   %esi
+    18fa:	53                   	push   %ebx
+    18fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    18fe:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    1900:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1903:	39 d0                	cmp    %edx,%eax
+    1905:	72 11                	jb     1918 <free+0x28>
+    1907:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1908:	39 c8                	cmp    %ecx,%eax
+    190a:	72 04                	jb     1910 <free+0x20>
+    190c:	39 ca                	cmp    %ecx,%edx
+    190e:	72 10                	jb     1920 <free+0x30>
+    1910:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1912:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1914:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1916:	73 f0                	jae    1908 <free+0x18>
+    1918:	39 ca                	cmp    %ecx,%edx
+    191a:	72 04                	jb     1920 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    191c:	39 c8                	cmp    %ecx,%eax
+    191e:	72 f0                	jb     1910 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    1920:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    1923:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    1926:	39 cf                	cmp    %ecx,%edi
+    1928:	74 1e                	je     1948 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    192a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    192d:	8b 48 04             	mov    0x4(%eax),%ecx
+    1930:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    1933:	39 f2                	cmp    %esi,%edx
+    1935:	74 28                	je     195f <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    1937:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    1939:	a3 24 1e 00 00       	mov    %eax,0x1e24
+}
+    193e:	5b                   	pop    %ebx
+    193f:	5e                   	pop    %esi
+    1940:	5f                   	pop    %edi
+    1941:	5d                   	pop    %ebp
+    1942:	c3                   	ret    
+    1943:	90                   	nop
+    1944:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    1948:	03 71 04             	add    0x4(%ecx),%esi
+    194b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    194e:	8b 08                	mov    (%eax),%ecx
+    1950:	8b 09                	mov    (%ecx),%ecx
+    1952:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    1955:	8b 48 04             	mov    0x4(%eax),%ecx
+    1958:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    195b:	39 f2                	cmp    %esi,%edx
+    195d:	75 d8                	jne    1937 <free+0x47>
+    p->s.size += bp->s.size;
+    195f:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    1962:	a3 24 1e 00 00       	mov    %eax,0x1e24
+    p->s.size += bp->s.size;
+    1967:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    196a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    196d:	89 10                	mov    %edx,(%eax)
+}
+    196f:	5b                   	pop    %ebx
+    1970:	5e                   	pop    %esi
+    1971:	5f                   	pop    %edi
+    1972:	5d                   	pop    %ebp
+    1973:	c3                   	ret    
+    1974:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    197a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001980 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1980:	55                   	push   %ebp
+    1981:	89 e5                	mov    %esp,%ebp
+    1983:	57                   	push   %edi
+    1984:	56                   	push   %esi
+    1985:	53                   	push   %ebx
+    1986:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1989:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    198c:	8b 1d 24 1e 00 00    	mov    0x1e24,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1992:	8d 48 07             	lea    0x7(%eax),%ecx
+    1995:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1998:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    199a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    199d:	0f 84 9b 00 00 00    	je     1a3e <malloc+0xbe>
+    19a3:	8b 13                	mov    (%ebx),%edx
+    19a5:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    19a8:	39 fe                	cmp    %edi,%esi
+    19aa:	76 64                	jbe    1a10 <malloc+0x90>
+    19ac:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    19b3:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    19b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    19bb:	eb 0e                	jmp    19cb <malloc+0x4b>
+    19bd:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    19c0:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    19c2:	8b 78 04             	mov    0x4(%eax),%edi
+    19c5:	39 fe                	cmp    %edi,%esi
+    19c7:	76 4f                	jbe    1a18 <malloc+0x98>
+    19c9:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    19cb:	3b 15 24 1e 00 00    	cmp    0x1e24,%edx
+    19d1:	75 ed                	jne    19c0 <malloc+0x40>
+  if(nu < 4096)
+    19d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    19d6:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    19dc:	bf 00 10 00 00       	mov    $0x1000,%edi
+    19e1:	0f 43 fe             	cmovae %esi,%edi
+    19e4:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    19e7:	89 04 24             	mov    %eax,(%esp)
+    19ea:	e8 3b fc ff ff       	call   162a <sbrk>
+  if(p == (char*)-1)
+    19ef:	83 f8 ff             	cmp    $0xffffffff,%eax
+    19f2:	74 18                	je     1a0c <malloc+0x8c>
+  hp->s.size = nu;
+    19f4:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    19f7:	83 c0 08             	add    $0x8,%eax
+    19fa:	89 04 24             	mov    %eax,(%esp)
+    19fd:	e8 ee fe ff ff       	call   18f0 <free>
+  return freep;
+    1a02:	8b 15 24 1e 00 00    	mov    0x1e24,%edx
+      if((p = morecore(nunits)) == 0)
+    1a08:	85 d2                	test   %edx,%edx
+    1a0a:	75 b4                	jne    19c0 <malloc+0x40>
+        return 0;
+    1a0c:	31 c0                	xor    %eax,%eax
+    1a0e:	eb 20                	jmp    1a30 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    1a10:	89 d0                	mov    %edx,%eax
+    1a12:	89 da                	mov    %ebx,%edx
+    1a14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    1a18:	39 fe                	cmp    %edi,%esi
+    1a1a:	74 1c                	je     1a38 <malloc+0xb8>
+        p->s.size -= nunits;
+    1a1c:	29 f7                	sub    %esi,%edi
+    1a1e:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    1a21:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    1a24:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    1a27:	89 15 24 1e 00 00    	mov    %edx,0x1e24
+      return (void*)(p + 1);
+    1a2d:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    1a30:	83 c4 1c             	add    $0x1c,%esp
+    1a33:	5b                   	pop    %ebx
+    1a34:	5e                   	pop    %esi
+    1a35:	5f                   	pop    %edi
+    1a36:	5d                   	pop    %ebp
+    1a37:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    1a38:	8b 08                	mov    (%eax),%ecx
+    1a3a:	89 0a                	mov    %ecx,(%edx)
+    1a3c:	eb e9                	jmp    1a27 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    1a3e:	c7 05 24 1e 00 00 28 	movl   $0x1e28,0x1e24
+    1a45:	1e 00 00 
+    base.s.size = 0;
+    1a48:	ba 28 1e 00 00       	mov    $0x1e28,%edx
+    base.s.ptr = freep = prevp = &base;
+    1a4d:	c7 05 28 1e 00 00 28 	movl   $0x1e28,0x1e28
+    1a54:	1e 00 00 
+    base.s.size = 0;
+    1a57:	c7 05 2c 1e 00 00 00 	movl   $0x0,0x1e2c
+    1a5e:	00 00 00 
+    1a61:	e9 46 ff ff ff       	jmp    19ac <malloc+0x2c>
+    1a66:	66 90                	xchg   %ax,%ax
+    1a68:	66 90                	xchg   %ax,%ax
+    1a6a:	66 90                	xchg   %ax,%ax
+    1a6c:	66 90                	xchg   %ax,%ax
+    1a6e:	66 90                	xchg   %ax,%ax
+
+00001a70 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1a70:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1a71:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1a76:	89 e5                	mov    %esp,%ebp
+    1a78:	8b 55 08             	mov    0x8(%ebp),%edx
+    1a7b:	90                   	nop
+    1a7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1a80:	89 c8                	mov    %ecx,%eax
+    1a82:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1a85:	85 c0                	test   %eax,%eax
+    1a87:	75 f7                	jne    1a80 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1a89:	0f ae f0             	mfence 
+}
+    1a8c:	5d                   	pop    %ebp
+    1a8d:	c3                   	ret    
+    1a8e:	66 90                	xchg   %ax,%ax
+
+00001a90 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1a90:	55                   	push   %ebp
+    1a91:	89 e5                	mov    %esp,%ebp
+    1a93:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1a96:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1a99:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    1a9f:	5d                   	pop    %ebp
+    1aa0:	c3                   	ret    
diff --git a/ls.c b/ls.c
index 6bf943b..2862913 100644
--- a/ls.c
+++ b/ls.c
@@ -77,9 +77,9 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     ls(".");
-    exit(1);
+    exit();
   }
   for(i=1; i<argc; i++)
     ls(argv[i]);
-  exit(0);
+  exit();
 }
diff --git a/ls.d b/ls.d
new file mode 100644
index 0000000..a55b6d4
--- /dev/null
+++ b/ls.d
@@ -0,0 +1 @@
+ls.o: ls.c /usr/include/stdc-predef.h types.h stat.h user.h fs.h
diff --git a/ls.o b/ls.o
new file mode 100644
index 0000000..de3d988
Binary files /dev/null and b/ls.o differ
diff --git a/ls.sym b/ls.sym
new file mode 100644
index 0000000..fe75bf9
--- /dev/null
+++ b/ls.sym
@@ -0,0 +1,65 @@
+00001000 .text
+00001aa1 .rodata
+00001b04 .eh_frame
+00001e14 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 ls.c
+00001e14 buf.1370
+00000000 ulib.c
+00000000 printf.c
+00001660 printint
+00001af2 digits.1359
+00000000 umalloc.c
+00001e24 freep
+00001e28 base
+00000000 uspinlock.c
+00001380 strcpy
+00001050 fmtname
+00001700 printf
+00001570 memmove
+000015ea mknod
+00001642 shm_open
+00001490 gets
+00001622 getpid
+00001980 malloc
+00001632 sleep
+000015b2 pipe
+000015c2 write
+000015fa fstat
+000015d2 kill
+00001612 chdir
+000015da exec
+000015aa wait
+000015ba read
+000015f2 unlink
+00001a70 uacquire
+0000159a fork
+0000162a sbrk
+0000164a shm_close
+0000163a uptime
+00001e14 __bss_start
+00001430 memset
+00001000 main
+000013b0 strcmp
+0000161a dup
+000014f0 stat
+00001e14 _edata
+00001e30 _end
+00001602 link
+000010f0 ls
+000015a2 exit
+00001540 atoi
+00001400 strlen
+000015e2 open
+00001450 strchr
+0000160a mkdir
+000015ca close
+00001a90 urelease
+000018f0 free
diff --git a/main.c b/main.c
index 9924e64..139b126 100644
--- a/main.c
+++ b/main.c
@@ -27,6 +27,7 @@ main(void)
   consoleinit();   // console hardware
   uartinit();      // serial port
   pinit();         // process table
+  shminit();       // shared memory
   tvinit();        // trap vectors
   binit();         // buffer cache
   fileinit();      // file table
@@ -83,7 +84,7 @@ startothers(void)
     // is running in low  memory, so we use entrypgdir for the APs too.
     stack = kalloc();
     *(void**)(code-4) = stack + KSTACKSIZE;
-    *(void(**)(void))(code-8) = mpenter;
+    *(void**)(code-8) = mpenter;
     *(int**)(code-12) = (void *) V2P(entrypgdir);
 
     lapicstartap(c->apicid, V2P(code));
diff --git a/main.d b/main.d
new file mode 100644
index 0000000..354dab4
--- /dev/null
+++ b/main.d
@@ -0,0 +1,2 @@
+main.o: main.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h proc.h x86.h
diff --git a/main.o b/main.o
new file mode 100644
index 0000000..27d17cf
Binary files /dev/null and b/main.o differ
diff --git a/memlayout.h b/memlayout.h
index d1615f7..70c1968 100644
--- a/memlayout.h
+++ b/memlayout.h
@@ -9,7 +9,7 @@
 #define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
 
 #define V2P(a) (((uint) (a)) - KERNBASE)
-#define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
+#define P2V(a) (((void *) (a)) + KERNBASE)
 
 #define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
 #define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts
diff --git a/mkdir.asm b/mkdir.asm
new file mode 100644
index 0000000..7d1d259
--- /dev/null
+++ b/mkdir.asm
@@ -0,0 +1,1240 @@
+
+_mkdir:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	57                   	push   %edi
+    1004:	56                   	push   %esi
+  int i;
+
+  if(argc < 2){
+    1005:	be 01 00 00 00       	mov    $0x1,%esi
+{
+    100a:	53                   	push   %ebx
+    100b:	83 e4 f0             	and    $0xfffffff0,%esp
+    100e:	83 ec 10             	sub    $0x10,%esp
+    1011:	8b 7d 08             	mov    0x8(%ebp),%edi
+    1014:	8b 45 0c             	mov    0xc(%ebp),%eax
+  if(argc < 2){
+    1017:	83 ff 01             	cmp    $0x1,%edi
+    101a:	8d 58 04             	lea    0x4(%eax),%ebx
+    101d:	7e 3a                	jle    1059 <main+0x59>
+    101f:	90                   	nop
+    printf(2, "Usage: mkdir files...\n");
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+    if(mkdir(argv[i]) < 0){
+    1020:	8b 03                	mov    (%ebx),%eax
+    1022:	89 04 24             	mov    %eax,(%esp)
+    1025:	e8 e0 02 00 00       	call   130a <mkdir>
+    102a:	85 c0                	test   %eax,%eax
+    102c:	78 0f                	js     103d <main+0x3d>
+  for(i = 1; i < argc; i++){
+    102e:	83 c6 01             	add    $0x1,%esi
+    1031:	83 c3 04             	add    $0x4,%ebx
+    1034:	39 fe                	cmp    %edi,%esi
+    1036:	75 e8                	jne    1020 <main+0x20>
+      printf(2, "mkdir: %s failed to create\n", argv[i]);
+      break;
+    }
+  }
+
+  exit();
+    1038:	e8 65 02 00 00       	call   12a2 <exit>
+      printf(2, "mkdir: %s failed to create\n", argv[i]);
+    103d:	8b 03                	mov    (%ebx),%eax
+    103f:	c7 44 24 04 b8 17 00 	movl   $0x17b8,0x4(%esp)
+    1046:	00 
+    1047:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    104e:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1052:	e8 a9 03 00 00       	call   1400 <printf>
+      break;
+    1057:	eb df                	jmp    1038 <main+0x38>
+    printf(2, "Usage: mkdir files...\n");
+    1059:	c7 44 24 04 a1 17 00 	movl   $0x17a1,0x4(%esp)
+    1060:	00 
+    1061:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    1068:	e8 93 03 00 00       	call   1400 <printf>
+    exit();
+    106d:	e8 30 02 00 00       	call   12a2 <exit>
+    1072:	66 90                	xchg   %ax,%ax
+    1074:	66 90                	xchg   %ax,%ax
+    1076:	66 90                	xchg   %ax,%ax
+    1078:	66 90                	xchg   %ax,%ax
+    107a:	66 90                	xchg   %ax,%ax
+    107c:	66 90                	xchg   %ax,%ax
+    107e:	66 90                	xchg   %ax,%ax
+
+00001080 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1080:	55                   	push   %ebp
+    1081:	89 e5                	mov    %esp,%ebp
+    1083:	8b 45 08             	mov    0x8(%ebp),%eax
+    1086:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1089:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    108a:	89 c2                	mov    %eax,%edx
+    108c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1090:	83 c1 01             	add    $0x1,%ecx
+    1093:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1097:	83 c2 01             	add    $0x1,%edx
+    109a:	84 db                	test   %bl,%bl
+    109c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    109f:	75 ef                	jne    1090 <strcpy+0x10>
+    ;
+  return os;
+}
+    10a1:	5b                   	pop    %ebx
+    10a2:	5d                   	pop    %ebp
+    10a3:	c3                   	ret    
+    10a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    10aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+000010b0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    10b0:	55                   	push   %ebp
+    10b1:	89 e5                	mov    %esp,%ebp
+    10b3:	8b 55 08             	mov    0x8(%ebp),%edx
+    10b6:	53                   	push   %ebx
+    10b7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    10ba:	0f b6 02             	movzbl (%edx),%eax
+    10bd:	84 c0                	test   %al,%al
+    10bf:	74 2d                	je     10ee <strcmp+0x3e>
+    10c1:	0f b6 19             	movzbl (%ecx),%ebx
+    10c4:	38 d8                	cmp    %bl,%al
+    10c6:	74 0e                	je     10d6 <strcmp+0x26>
+    10c8:	eb 2b                	jmp    10f5 <strcmp+0x45>
+    10ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    10d0:	38 c8                	cmp    %cl,%al
+    10d2:	75 15                	jne    10e9 <strcmp+0x39>
+    p++, q++;
+    10d4:	89 d9                	mov    %ebx,%ecx
+    10d6:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    10d9:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    10dc:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    10df:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    10e3:	84 c0                	test   %al,%al
+    10e5:	75 e9                	jne    10d0 <strcmp+0x20>
+    10e7:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    10e9:	29 c8                	sub    %ecx,%eax
+}
+    10eb:	5b                   	pop    %ebx
+    10ec:	5d                   	pop    %ebp
+    10ed:	c3                   	ret    
+    10ee:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    10f1:	31 c0                	xor    %eax,%eax
+    10f3:	eb f4                	jmp    10e9 <strcmp+0x39>
+    10f5:	0f b6 cb             	movzbl %bl,%ecx
+    10f8:	eb ef                	jmp    10e9 <strcmp+0x39>
+    10fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001100 <strlen>:
+
+uint
+strlen(char *s)
+{
+    1100:	55                   	push   %ebp
+    1101:	89 e5                	mov    %esp,%ebp
+    1103:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    1106:	80 39 00             	cmpb   $0x0,(%ecx)
+    1109:	74 12                	je     111d <strlen+0x1d>
+    110b:	31 d2                	xor    %edx,%edx
+    110d:	8d 76 00             	lea    0x0(%esi),%esi
+    1110:	83 c2 01             	add    $0x1,%edx
+    1113:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    1117:	89 d0                	mov    %edx,%eax
+    1119:	75 f5                	jne    1110 <strlen+0x10>
+    ;
+  return n;
+}
+    111b:	5d                   	pop    %ebp
+    111c:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    111d:	31 c0                	xor    %eax,%eax
+}
+    111f:	5d                   	pop    %ebp
+    1120:	c3                   	ret    
+    1121:	eb 0d                	jmp    1130 <memset>
+    1123:	90                   	nop
+    1124:	90                   	nop
+    1125:	90                   	nop
+    1126:	90                   	nop
+    1127:	90                   	nop
+    1128:	90                   	nop
+    1129:	90                   	nop
+    112a:	90                   	nop
+    112b:	90                   	nop
+    112c:	90                   	nop
+    112d:	90                   	nop
+    112e:	90                   	nop
+    112f:	90                   	nop
+
+00001130 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    1130:	55                   	push   %ebp
+    1131:	89 e5                	mov    %esp,%ebp
+    1133:	8b 55 08             	mov    0x8(%ebp),%edx
+    1136:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    1137:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    113a:	8b 45 0c             	mov    0xc(%ebp),%eax
+    113d:	89 d7                	mov    %edx,%edi
+    113f:	fc                   	cld    
+    1140:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    1142:	89 d0                	mov    %edx,%eax
+    1144:	5f                   	pop    %edi
+    1145:	5d                   	pop    %ebp
+    1146:	c3                   	ret    
+    1147:	89 f6                	mov    %esi,%esi
+    1149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001150 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    1150:	55                   	push   %ebp
+    1151:	89 e5                	mov    %esp,%ebp
+    1153:	8b 45 08             	mov    0x8(%ebp),%eax
+    1156:	53                   	push   %ebx
+    1157:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    115a:	0f b6 18             	movzbl (%eax),%ebx
+    115d:	84 db                	test   %bl,%bl
+    115f:	74 1d                	je     117e <strchr+0x2e>
+    if(*s == c)
+    1161:	38 d3                	cmp    %dl,%bl
+    1163:	89 d1                	mov    %edx,%ecx
+    1165:	75 0d                	jne    1174 <strchr+0x24>
+    1167:	eb 17                	jmp    1180 <strchr+0x30>
+    1169:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1170:	38 ca                	cmp    %cl,%dl
+    1172:	74 0c                	je     1180 <strchr+0x30>
+  for(; *s; s++)
+    1174:	83 c0 01             	add    $0x1,%eax
+    1177:	0f b6 10             	movzbl (%eax),%edx
+    117a:	84 d2                	test   %dl,%dl
+    117c:	75 f2                	jne    1170 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    117e:	31 c0                	xor    %eax,%eax
+}
+    1180:	5b                   	pop    %ebx
+    1181:	5d                   	pop    %ebp
+    1182:	c3                   	ret    
+    1183:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1189:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001190 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1190:	55                   	push   %ebp
+    1191:	89 e5                	mov    %esp,%ebp
+    1193:	57                   	push   %edi
+    1194:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1195:	31 f6                	xor    %esi,%esi
+{
+    1197:	53                   	push   %ebx
+    1198:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    119b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    119e:	eb 31                	jmp    11d1 <gets+0x41>
+    cc = read(0, &c, 1);
+    11a0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    11a7:	00 
+    11a8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    11ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    11b3:	e8 02 01 00 00       	call   12ba <read>
+    if(cc < 1)
+    11b8:	85 c0                	test   %eax,%eax
+    11ba:	7e 1d                	jle    11d9 <gets+0x49>
+      break;
+    buf[i++] = c;
+    11bc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    11c0:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    11c2:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    11c5:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    11c7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    11cb:	74 0c                	je     11d9 <gets+0x49>
+    11cd:	3c 0a                	cmp    $0xa,%al
+    11cf:	74 08                	je     11d9 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    11d1:	8d 5e 01             	lea    0x1(%esi),%ebx
+    11d4:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    11d7:	7c c7                	jl     11a0 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    11d9:	8b 45 08             	mov    0x8(%ebp),%eax
+    11dc:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    11e0:	83 c4 2c             	add    $0x2c,%esp
+    11e3:	5b                   	pop    %ebx
+    11e4:	5e                   	pop    %esi
+    11e5:	5f                   	pop    %edi
+    11e6:	5d                   	pop    %ebp
+    11e7:	c3                   	ret    
+    11e8:	90                   	nop
+    11e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000011f0 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    11f0:	55                   	push   %ebp
+    11f1:	89 e5                	mov    %esp,%ebp
+    11f3:	56                   	push   %esi
+    11f4:	53                   	push   %ebx
+    11f5:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    11f8:	8b 45 08             	mov    0x8(%ebp),%eax
+    11fb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1202:	00 
+    1203:	89 04 24             	mov    %eax,(%esp)
+    1206:	e8 d7 00 00 00       	call   12e2 <open>
+  if(fd < 0)
+    120b:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    120d:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    120f:	78 27                	js     1238 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    1211:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1214:	89 1c 24             	mov    %ebx,(%esp)
+    1217:	89 44 24 04          	mov    %eax,0x4(%esp)
+    121b:	e8 da 00 00 00       	call   12fa <fstat>
+  close(fd);
+    1220:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    1223:	89 c6                	mov    %eax,%esi
+  close(fd);
+    1225:	e8 a0 00 00 00       	call   12ca <close>
+  return r;
+    122a:	89 f0                	mov    %esi,%eax
+}
+    122c:	83 c4 10             	add    $0x10,%esp
+    122f:	5b                   	pop    %ebx
+    1230:	5e                   	pop    %esi
+    1231:	5d                   	pop    %ebp
+    1232:	c3                   	ret    
+    1233:	90                   	nop
+    1234:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    1238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    123d:	eb ed                	jmp    122c <stat+0x3c>
+    123f:	90                   	nop
+
+00001240 <atoi>:
+
+int
+atoi(const char *s)
+{
+    1240:	55                   	push   %ebp
+    1241:	89 e5                	mov    %esp,%ebp
+    1243:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    1246:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    1247:	0f be 11             	movsbl (%ecx),%edx
+    124a:	8d 42 d0             	lea    -0x30(%edx),%eax
+    124d:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    124f:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    1254:	77 17                	ja     126d <atoi+0x2d>
+    1256:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    1258:	83 c1 01             	add    $0x1,%ecx
+    125b:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    125e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1262:	0f be 11             	movsbl (%ecx),%edx
+    1265:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1268:	80 fb 09             	cmp    $0x9,%bl
+    126b:	76 eb                	jbe    1258 <atoi+0x18>
+  return n;
+}
+    126d:	5b                   	pop    %ebx
+    126e:	5d                   	pop    %ebp
+    126f:	c3                   	ret    
+
+00001270 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1270:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1271:	31 d2                	xor    %edx,%edx
+{
+    1273:	89 e5                	mov    %esp,%ebp
+    1275:	56                   	push   %esi
+    1276:	8b 45 08             	mov    0x8(%ebp),%eax
+    1279:	53                   	push   %ebx
+    127a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    127d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1280:	85 db                	test   %ebx,%ebx
+    1282:	7e 12                	jle    1296 <memmove+0x26>
+    1284:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1288:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    128c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    128f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1292:	39 da                	cmp    %ebx,%edx
+    1294:	75 f2                	jne    1288 <memmove+0x18>
+  return vdst;
+}
+    1296:	5b                   	pop    %ebx
+    1297:	5e                   	pop    %esi
+    1298:	5d                   	pop    %ebp
+    1299:	c3                   	ret    
+
+0000129a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    129a:	b8 01 00 00 00       	mov    $0x1,%eax
+    129f:	cd 40                	int    $0x40
+    12a1:	c3                   	ret    
+
+000012a2 <exit>:
+SYSCALL(exit)
+    12a2:	b8 02 00 00 00       	mov    $0x2,%eax
+    12a7:	cd 40                	int    $0x40
+    12a9:	c3                   	ret    
+
+000012aa <wait>:
+SYSCALL(wait)
+    12aa:	b8 03 00 00 00       	mov    $0x3,%eax
+    12af:	cd 40                	int    $0x40
+    12b1:	c3                   	ret    
+
+000012b2 <pipe>:
+SYSCALL(pipe)
+    12b2:	b8 04 00 00 00       	mov    $0x4,%eax
+    12b7:	cd 40                	int    $0x40
+    12b9:	c3                   	ret    
+
+000012ba <read>:
+SYSCALL(read)
+    12ba:	b8 05 00 00 00       	mov    $0x5,%eax
+    12bf:	cd 40                	int    $0x40
+    12c1:	c3                   	ret    
+
+000012c2 <write>:
+SYSCALL(write)
+    12c2:	b8 10 00 00 00       	mov    $0x10,%eax
+    12c7:	cd 40                	int    $0x40
+    12c9:	c3                   	ret    
+
+000012ca <close>:
+SYSCALL(close)
+    12ca:	b8 15 00 00 00       	mov    $0x15,%eax
+    12cf:	cd 40                	int    $0x40
+    12d1:	c3                   	ret    
+
+000012d2 <kill>:
+SYSCALL(kill)
+    12d2:	b8 06 00 00 00       	mov    $0x6,%eax
+    12d7:	cd 40                	int    $0x40
+    12d9:	c3                   	ret    
+
+000012da <exec>:
+SYSCALL(exec)
+    12da:	b8 07 00 00 00       	mov    $0x7,%eax
+    12df:	cd 40                	int    $0x40
+    12e1:	c3                   	ret    
+
+000012e2 <open>:
+SYSCALL(open)
+    12e2:	b8 0f 00 00 00       	mov    $0xf,%eax
+    12e7:	cd 40                	int    $0x40
+    12e9:	c3                   	ret    
+
+000012ea <mknod>:
+SYSCALL(mknod)
+    12ea:	b8 11 00 00 00       	mov    $0x11,%eax
+    12ef:	cd 40                	int    $0x40
+    12f1:	c3                   	ret    
+
+000012f2 <unlink>:
+SYSCALL(unlink)
+    12f2:	b8 12 00 00 00       	mov    $0x12,%eax
+    12f7:	cd 40                	int    $0x40
+    12f9:	c3                   	ret    
+
+000012fa <fstat>:
+SYSCALL(fstat)
+    12fa:	b8 08 00 00 00       	mov    $0x8,%eax
+    12ff:	cd 40                	int    $0x40
+    1301:	c3                   	ret    
+
+00001302 <link>:
+SYSCALL(link)
+    1302:	b8 13 00 00 00       	mov    $0x13,%eax
+    1307:	cd 40                	int    $0x40
+    1309:	c3                   	ret    
+
+0000130a <mkdir>:
+SYSCALL(mkdir)
+    130a:	b8 14 00 00 00       	mov    $0x14,%eax
+    130f:	cd 40                	int    $0x40
+    1311:	c3                   	ret    
+
+00001312 <chdir>:
+SYSCALL(chdir)
+    1312:	b8 09 00 00 00       	mov    $0x9,%eax
+    1317:	cd 40                	int    $0x40
+    1319:	c3                   	ret    
+
+0000131a <dup>:
+SYSCALL(dup)
+    131a:	b8 0a 00 00 00       	mov    $0xa,%eax
+    131f:	cd 40                	int    $0x40
+    1321:	c3                   	ret    
+
+00001322 <getpid>:
+SYSCALL(getpid)
+    1322:	b8 0b 00 00 00       	mov    $0xb,%eax
+    1327:	cd 40                	int    $0x40
+    1329:	c3                   	ret    
+
+0000132a <sbrk>:
+SYSCALL(sbrk)
+    132a:	b8 0c 00 00 00       	mov    $0xc,%eax
+    132f:	cd 40                	int    $0x40
+    1331:	c3                   	ret    
+
+00001332 <sleep>:
+SYSCALL(sleep)
+    1332:	b8 0d 00 00 00       	mov    $0xd,%eax
+    1337:	cd 40                	int    $0x40
+    1339:	c3                   	ret    
+
+0000133a <uptime>:
+SYSCALL(uptime)
+    133a:	b8 0e 00 00 00       	mov    $0xe,%eax
+    133f:	cd 40                	int    $0x40
+    1341:	c3                   	ret    
+
+00001342 <shm_open>:
+SYSCALL(shm_open)
+    1342:	b8 16 00 00 00       	mov    $0x16,%eax
+    1347:	cd 40                	int    $0x40
+    1349:	c3                   	ret    
+
+0000134a <shm_close>:
+SYSCALL(shm_close)	
+    134a:	b8 17 00 00 00       	mov    $0x17,%eax
+    134f:	cd 40                	int    $0x40
+    1351:	c3                   	ret    
+    1352:	66 90                	xchg   %ax,%ax
+    1354:	66 90                	xchg   %ax,%ax
+    1356:	66 90                	xchg   %ax,%ax
+    1358:	66 90                	xchg   %ax,%ax
+    135a:	66 90                	xchg   %ax,%ax
+    135c:	66 90                	xchg   %ax,%ax
+    135e:	66 90                	xchg   %ax,%ax
+
+00001360 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1360:	55                   	push   %ebp
+    1361:	89 e5                	mov    %esp,%ebp
+    1363:	57                   	push   %edi
+    1364:	56                   	push   %esi
+    1365:	89 c6                	mov    %eax,%esi
+    1367:	53                   	push   %ebx
+    1368:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    136b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    136e:	85 db                	test   %ebx,%ebx
+    1370:	74 09                	je     137b <printint+0x1b>
+    1372:	89 d0                	mov    %edx,%eax
+    1374:	c1 e8 1f             	shr    $0x1f,%eax
+    1377:	84 c0                	test   %al,%al
+    1379:	75 75                	jne    13f0 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    137b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    137d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1384:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1387:	31 ff                	xor    %edi,%edi
+    1389:	89 ce                	mov    %ecx,%esi
+    138b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    138e:	eb 02                	jmp    1392 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1390:	89 cf                	mov    %ecx,%edi
+    1392:	31 d2                	xor    %edx,%edx
+    1394:	f7 f6                	div    %esi
+    1396:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1399:	0f b6 92 db 17 00 00 	movzbl 0x17db(%edx),%edx
+  }while((x /= base) != 0);
+    13a0:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    13a2:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    13a5:	75 e9                	jne    1390 <printint+0x30>
+  if(neg)
+    13a7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    13aa:	89 c8                	mov    %ecx,%eax
+    13ac:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    13af:	85 d2                	test   %edx,%edx
+    13b1:	74 08                	je     13bb <printint+0x5b>
+    buf[i++] = '-';
+    13b3:	8d 4f 02             	lea    0x2(%edi),%ecx
+    13b6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    13bb:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    13be:	66 90                	xchg   %ax,%ax
+    13c0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    13c5:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    13c8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    13cf:	00 
+    13d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    13d4:	89 34 24             	mov    %esi,(%esp)
+    13d7:	88 45 d7             	mov    %al,-0x29(%ebp)
+    13da:	e8 e3 fe ff ff       	call   12c2 <write>
+  while(--i >= 0)
+    13df:	83 ff ff             	cmp    $0xffffffff,%edi
+    13e2:	75 dc                	jne    13c0 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    13e4:	83 c4 4c             	add    $0x4c,%esp
+    13e7:	5b                   	pop    %ebx
+    13e8:	5e                   	pop    %esi
+    13e9:	5f                   	pop    %edi
+    13ea:	5d                   	pop    %ebp
+    13eb:	c3                   	ret    
+    13ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    13f0:	89 d0                	mov    %edx,%eax
+    13f2:	f7 d8                	neg    %eax
+    neg = 1;
+    13f4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    13fb:	eb 87                	jmp    1384 <printint+0x24>
+    13fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+00001400 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    1400:	55                   	push   %ebp
+    1401:	89 e5                	mov    %esp,%ebp
+    1403:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    1404:	31 ff                	xor    %edi,%edi
+{
+    1406:	56                   	push   %esi
+    1407:	53                   	push   %ebx
+    1408:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    140b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    140e:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    1411:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    1414:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    1417:	0f b6 13             	movzbl (%ebx),%edx
+    141a:	83 c3 01             	add    $0x1,%ebx
+    141d:	84 d2                	test   %dl,%dl
+    141f:	75 39                	jne    145a <printf+0x5a>
+    1421:	e9 c2 00 00 00       	jmp    14e8 <printf+0xe8>
+    1426:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    1428:	83 fa 25             	cmp    $0x25,%edx
+    142b:	0f 84 bf 00 00 00    	je     14f0 <printf+0xf0>
+  write(fd, &c, 1);
+    1431:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    1434:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    143b:	00 
+    143c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1440:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    1443:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    1446:	e8 77 fe ff ff       	call   12c2 <write>
+    144b:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    144e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    1452:	84 d2                	test   %dl,%dl
+    1454:	0f 84 8e 00 00 00    	je     14e8 <printf+0xe8>
+    if(state == 0){
+    145a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    145c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    145f:	74 c7                	je     1428 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1461:	83 ff 25             	cmp    $0x25,%edi
+    1464:	75 e5                	jne    144b <printf+0x4b>
+      if(c == 'd'){
+    1466:	83 fa 64             	cmp    $0x64,%edx
+    1469:	0f 84 31 01 00 00    	je     15a0 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    146f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1474:	83 f8 70             	cmp    $0x70,%eax
+    1477:	0f 84 83 00 00 00    	je     1500 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    147d:	83 fa 73             	cmp    $0x73,%edx
+    1480:	0f 84 a2 00 00 00    	je     1528 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1486:	83 fa 63             	cmp    $0x63,%edx
+    1489:	0f 84 35 01 00 00    	je     15c4 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    148f:	83 fa 25             	cmp    $0x25,%edx
+    1492:	0f 84 e0 00 00 00    	je     1578 <printf+0x178>
+  write(fd, &c, 1);
+    1498:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    149b:	83 c3 01             	add    $0x1,%ebx
+    149e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14a5:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    14a6:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    14a8:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14ac:	89 34 24             	mov    %esi,(%esp)
+    14af:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    14b2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    14b6:	e8 07 fe ff ff       	call   12c2 <write>
+        putc(fd, c);
+    14bb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    14be:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    14c1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14c8:	00 
+    14c9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14cd:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    14d0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    14d3:	e8 ea fd ff ff       	call   12c2 <write>
+  for(i = 0; fmt[i]; i++){
+    14d8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    14dc:	84 d2                	test   %dl,%dl
+    14de:	0f 85 76 ff ff ff    	jne    145a <printf+0x5a>
+    14e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    14e8:	83 c4 3c             	add    $0x3c,%esp
+    14eb:	5b                   	pop    %ebx
+    14ec:	5e                   	pop    %esi
+    14ed:	5f                   	pop    %edi
+    14ee:	5d                   	pop    %ebp
+    14ef:	c3                   	ret    
+        state = '%';
+    14f0:	bf 25 00 00 00       	mov    $0x25,%edi
+    14f5:	e9 51 ff ff ff       	jmp    144b <printf+0x4b>
+    14fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    1500:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1503:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    1508:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    150a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1511:	8b 10                	mov    (%eax),%edx
+    1513:	89 f0                	mov    %esi,%eax
+    1515:	e8 46 fe ff ff       	call   1360 <printint>
+        ap++;
+    151a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    151e:	e9 28 ff ff ff       	jmp    144b <printf+0x4b>
+    1523:	90                   	nop
+    1524:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    1528:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    152b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    152f:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    1531:	b8 d4 17 00 00       	mov    $0x17d4,%eax
+    1536:	85 ff                	test   %edi,%edi
+    1538:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    153b:	0f b6 07             	movzbl (%edi),%eax
+    153e:	84 c0                	test   %al,%al
+    1540:	74 2a                	je     156c <printf+0x16c>
+    1542:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1548:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    154b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    154e:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    1551:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1558:	00 
+    1559:	89 44 24 04          	mov    %eax,0x4(%esp)
+    155d:	89 34 24             	mov    %esi,(%esp)
+    1560:	e8 5d fd ff ff       	call   12c2 <write>
+        while(*s != 0){
+    1565:	0f b6 07             	movzbl (%edi),%eax
+    1568:	84 c0                	test   %al,%al
+    156a:	75 dc                	jne    1548 <printf+0x148>
+      state = 0;
+    156c:	31 ff                	xor    %edi,%edi
+    156e:	e9 d8 fe ff ff       	jmp    144b <printf+0x4b>
+    1573:	90                   	nop
+    1574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1578:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    157b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    157d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1584:	00 
+    1585:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1589:	89 34 24             	mov    %esi,(%esp)
+    158c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1590:	e8 2d fd ff ff       	call   12c2 <write>
+    1595:	e9 b1 fe ff ff       	jmp    144b <printf+0x4b>
+    159a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    15a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    15a3:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    15a8:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    15ab:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    15b2:	8b 10                	mov    (%eax),%edx
+    15b4:	89 f0                	mov    %esi,%eax
+    15b6:	e8 a5 fd ff ff       	call   1360 <printint>
+        ap++;
+    15bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15bf:	e9 87 fe ff ff       	jmp    144b <printf+0x4b>
+        putc(fd, *ap);
+    15c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    15c7:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    15c9:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    15cb:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    15d2:	00 
+    15d3:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    15d6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    15d9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    15dc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15e0:	e8 dd fc ff ff       	call   12c2 <write>
+        ap++;
+    15e5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15e9:	e9 5d fe ff ff       	jmp    144b <printf+0x4b>
+    15ee:	66 90                	xchg   %ax,%ax
+
+000015f0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    15f0:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15f1:	a1 98 1a 00 00       	mov    0x1a98,%eax
+{
+    15f6:	89 e5                	mov    %esp,%ebp
+    15f8:	57                   	push   %edi
+    15f9:	56                   	push   %esi
+    15fa:	53                   	push   %ebx
+    15fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15fe:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    1600:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1603:	39 d0                	cmp    %edx,%eax
+    1605:	72 11                	jb     1618 <free+0x28>
+    1607:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1608:	39 c8                	cmp    %ecx,%eax
+    160a:	72 04                	jb     1610 <free+0x20>
+    160c:	39 ca                	cmp    %ecx,%edx
+    160e:	72 10                	jb     1620 <free+0x30>
+    1610:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1612:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1614:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1616:	73 f0                	jae    1608 <free+0x18>
+    1618:	39 ca                	cmp    %ecx,%edx
+    161a:	72 04                	jb     1620 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    161c:	39 c8                	cmp    %ecx,%eax
+    161e:	72 f0                	jb     1610 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    1620:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    1623:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    1626:	39 cf                	cmp    %ecx,%edi
+    1628:	74 1e                	je     1648 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    162a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    162d:	8b 48 04             	mov    0x4(%eax),%ecx
+    1630:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    1633:	39 f2                	cmp    %esi,%edx
+    1635:	74 28                	je     165f <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    1637:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    1639:	a3 98 1a 00 00       	mov    %eax,0x1a98
+}
+    163e:	5b                   	pop    %ebx
+    163f:	5e                   	pop    %esi
+    1640:	5f                   	pop    %edi
+    1641:	5d                   	pop    %ebp
+    1642:	c3                   	ret    
+    1643:	90                   	nop
+    1644:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    1648:	03 71 04             	add    0x4(%ecx),%esi
+    164b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    164e:	8b 08                	mov    (%eax),%ecx
+    1650:	8b 09                	mov    (%ecx),%ecx
+    1652:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    1655:	8b 48 04             	mov    0x4(%eax),%ecx
+    1658:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    165b:	39 f2                	cmp    %esi,%edx
+    165d:	75 d8                	jne    1637 <free+0x47>
+    p->s.size += bp->s.size;
+    165f:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    1662:	a3 98 1a 00 00       	mov    %eax,0x1a98
+    p->s.size += bp->s.size;
+    1667:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    166a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    166d:	89 10                	mov    %edx,(%eax)
+}
+    166f:	5b                   	pop    %ebx
+    1670:	5e                   	pop    %esi
+    1671:	5f                   	pop    %edi
+    1672:	5d                   	pop    %ebp
+    1673:	c3                   	ret    
+    1674:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    167a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001680 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1680:	55                   	push   %ebp
+    1681:	89 e5                	mov    %esp,%ebp
+    1683:	57                   	push   %edi
+    1684:	56                   	push   %esi
+    1685:	53                   	push   %ebx
+    1686:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1689:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    168c:	8b 1d 98 1a 00 00    	mov    0x1a98,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1692:	8d 48 07             	lea    0x7(%eax),%ecx
+    1695:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1698:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    169a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    169d:	0f 84 9b 00 00 00    	je     173e <malloc+0xbe>
+    16a3:	8b 13                	mov    (%ebx),%edx
+    16a5:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    16a8:	39 fe                	cmp    %edi,%esi
+    16aa:	76 64                	jbe    1710 <malloc+0x90>
+    16ac:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    16b3:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    16b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    16bb:	eb 0e                	jmp    16cb <malloc+0x4b>
+    16bd:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    16c0:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    16c2:	8b 78 04             	mov    0x4(%eax),%edi
+    16c5:	39 fe                	cmp    %edi,%esi
+    16c7:	76 4f                	jbe    1718 <malloc+0x98>
+    16c9:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    16cb:	3b 15 98 1a 00 00    	cmp    0x1a98,%edx
+    16d1:	75 ed                	jne    16c0 <malloc+0x40>
+  if(nu < 4096)
+    16d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    16d6:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    16dc:	bf 00 10 00 00       	mov    $0x1000,%edi
+    16e1:	0f 43 fe             	cmovae %esi,%edi
+    16e4:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    16e7:	89 04 24             	mov    %eax,(%esp)
+    16ea:	e8 3b fc ff ff       	call   132a <sbrk>
+  if(p == (char*)-1)
+    16ef:	83 f8 ff             	cmp    $0xffffffff,%eax
+    16f2:	74 18                	je     170c <malloc+0x8c>
+  hp->s.size = nu;
+    16f4:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    16f7:	83 c0 08             	add    $0x8,%eax
+    16fa:	89 04 24             	mov    %eax,(%esp)
+    16fd:	e8 ee fe ff ff       	call   15f0 <free>
+  return freep;
+    1702:	8b 15 98 1a 00 00    	mov    0x1a98,%edx
+      if((p = morecore(nunits)) == 0)
+    1708:	85 d2                	test   %edx,%edx
+    170a:	75 b4                	jne    16c0 <malloc+0x40>
+        return 0;
+    170c:	31 c0                	xor    %eax,%eax
+    170e:	eb 20                	jmp    1730 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    1710:	89 d0                	mov    %edx,%eax
+    1712:	89 da                	mov    %ebx,%edx
+    1714:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    1718:	39 fe                	cmp    %edi,%esi
+    171a:	74 1c                	je     1738 <malloc+0xb8>
+        p->s.size -= nunits;
+    171c:	29 f7                	sub    %esi,%edi
+    171e:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    1721:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    1724:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    1727:	89 15 98 1a 00 00    	mov    %edx,0x1a98
+      return (void*)(p + 1);
+    172d:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    1730:	83 c4 1c             	add    $0x1c,%esp
+    1733:	5b                   	pop    %ebx
+    1734:	5e                   	pop    %esi
+    1735:	5f                   	pop    %edi
+    1736:	5d                   	pop    %ebp
+    1737:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    1738:	8b 08                	mov    (%eax),%ecx
+    173a:	89 0a                	mov    %ecx,(%edx)
+    173c:	eb e9                	jmp    1727 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    173e:	c7 05 98 1a 00 00 9c 	movl   $0x1a9c,0x1a98
+    1745:	1a 00 00 
+    base.s.size = 0;
+    1748:	ba 9c 1a 00 00       	mov    $0x1a9c,%edx
+    base.s.ptr = freep = prevp = &base;
+    174d:	c7 05 9c 1a 00 00 9c 	movl   $0x1a9c,0x1a9c
+    1754:	1a 00 00 
+    base.s.size = 0;
+    1757:	c7 05 a0 1a 00 00 00 	movl   $0x0,0x1aa0
+    175e:	00 00 00 
+    1761:	e9 46 ff ff ff       	jmp    16ac <malloc+0x2c>
+    1766:	66 90                	xchg   %ax,%ax
+    1768:	66 90                	xchg   %ax,%ax
+    176a:	66 90                	xchg   %ax,%ax
+    176c:	66 90                	xchg   %ax,%ax
+    176e:	66 90                	xchg   %ax,%ax
+
+00001770 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1770:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1771:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1776:	89 e5                	mov    %esp,%ebp
+    1778:	8b 55 08             	mov    0x8(%ebp),%edx
+    177b:	90                   	nop
+    177c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1780:	89 c8                	mov    %ecx,%eax
+    1782:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1785:	85 c0                	test   %eax,%eax
+    1787:	75 f7                	jne    1780 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1789:	0f ae f0             	mfence 
+}
+    178c:	5d                   	pop    %ebp
+    178d:	c3                   	ret    
+    178e:	66 90                	xchg   %ax,%ax
+
+00001790 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1790:	55                   	push   %ebp
+    1791:	89 e5                	mov    %esp,%ebp
+    1793:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1796:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1799:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    179f:	5d                   	pop    %ebp
+    17a0:	c3                   	ret    
diff --git a/mkdir.c b/mkdir.c
index 2d90781..6e4c954 100644
--- a/mkdir.c
+++ b/mkdir.c
@@ -9,7 +9,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     printf(2, "Usage: mkdir files...\n");
-    exit(1);
+    exit();
   }
 
   for(i = 1; i < argc; i++){
@@ -19,5 +19,5 @@ main(int argc, char *argv[])
     }
   }
 
-  exit(0);
+  exit();
 }
diff --git a/mkdir.d b/mkdir.d
new file mode 100644
index 0000000..0c77808
--- /dev/null
+++ b/mkdir.d
@@ -0,0 +1 @@
+mkdir.o: mkdir.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/mkdir.o b/mkdir.o
new file mode 100644
index 0000000..0ad411e
Binary files /dev/null and b/mkdir.o differ
diff --git a/mkdir.sym b/mkdir.sym
new file mode 100644
index 0000000..56d8639
--- /dev/null
+++ b/mkdir.sym
@@ -0,0 +1,62 @@
+00001000 .text
+000017a1 .rodata
+000017ec .eh_frame
+00001a98 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 mkdir.c
+00000000 ulib.c
+00000000 printf.c
+00001360 printint
+000017db digits.1359
+00000000 umalloc.c
+00001a98 freep
+00001a9c base
+00000000 uspinlock.c
+00001080 strcpy
+00001400 printf
+00001270 memmove
+000012ea mknod
+00001342 shm_open
+00001190 gets
+00001322 getpid
+00001680 malloc
+00001332 sleep
+000012b2 pipe
+000012c2 write
+000012fa fstat
+000012d2 kill
+00001312 chdir
+000012da exec
+000012aa wait
+000012ba read
+000012f2 unlink
+00001770 uacquire
+0000129a fork
+0000132a sbrk
+0000134a shm_close
+0000133a uptime
+00001a98 __bss_start
+00001130 memset
+00001000 main
+000010b0 strcmp
+0000131a dup
+000011f0 stat
+00001a98 _edata
+00001aa4 _end
+00001302 link
+000012a2 exit
+00001240 atoi
+00001100 strlen
+000012e2 open
+00001150 strchr
+0000130a mkdir
+000012ca close
+00001790 urelease
+000015f0 free
diff --git a/mkfs b/mkfs
new file mode 100644
index 0000000..d534393
Binary files /dev/null and b/mkfs differ
diff --git a/mmu.h b/mmu.h
index a82d8e2..7b63db0 100644
--- a/mmu.h
+++ b/mmu.h
@@ -2,11 +2,39 @@
 // x86 memory management unit (MMU).
 
 // Eflags register
+#define FL_CF           0x00000001      // Carry Flag
+#define FL_PF           0x00000004      // Parity Flag
+#define FL_AF           0x00000010      // Auxiliary carry Flag
+#define FL_ZF           0x00000040      // Zero Flag
+#define FL_SF           0x00000080      // Sign Flag
+#define FL_TF           0x00000100      // Trap Flag
 #define FL_IF           0x00000200      // Interrupt Enable
+#define FL_DF           0x00000400      // Direction Flag
+#define FL_OF           0x00000800      // Overflow Flag
+#define FL_IOPL_MASK    0x00003000      // I/O Privilege Level bitmask
+#define FL_IOPL_0       0x00000000      //   IOPL == 0
+#define FL_IOPL_1       0x00001000      //   IOPL == 1
+#define FL_IOPL_2       0x00002000      //   IOPL == 2
+#define FL_IOPL_3       0x00003000      //   IOPL == 3
+#define FL_NT           0x00004000      // Nested Task
+#define FL_RF           0x00010000      // Resume Flag
+#define FL_VM           0x00020000      // Virtual 8086 mode
+#define FL_AC           0x00040000      // Alignment Check
+#define FL_VIF          0x00080000      // Virtual Interrupt Flag
+#define FL_VIP          0x00100000      // Virtual Interrupt Pending
+#define FL_ID           0x00200000      // ID flag
 
 // Control Register flags
 #define CR0_PE          0x00000001      // Protection Enable
+#define CR0_MP          0x00000002      // Monitor coProcessor
+#define CR0_EM          0x00000004      // Emulation
+#define CR0_TS          0x00000008      // Task Switched
+#define CR0_ET          0x00000010      // Extension Type
+#define CR0_NE          0x00000020      // Numeric Errror
 #define CR0_WP          0x00010000      // Write Protect
+#define CR0_AM          0x00040000      // Alignment Mask
+#define CR0_NW          0x20000000      // Not Writethrough
+#define CR0_CD          0x40000000      // Cache Disable
 #define CR0_PG          0x80000000      // Paging
 
 #define CR4_PSE         0x00000010      // Page size extension
@@ -54,11 +82,23 @@ struct segdesc {
 
 // Application segment type bits
 #define STA_X       0x8     // Executable segment
+#define STA_E       0x4     // Expand down (non-executable segments)
+#define STA_C       0x4     // Conforming code segment (executable only)
 #define STA_W       0x2     // Writeable (non-executable segments)
 #define STA_R       0x2     // Readable (executable segments)
+#define STA_A       0x1     // Accessed
 
 // System segment type bits
+#define STS_T16A    0x1     // Available 16-bit TSS
+#define STS_LDT     0x2     // Local Descriptor Table
+#define STS_T16B    0x3     // Busy 16-bit TSS
+#define STS_CG16    0x4     // 16-bit Call Gate
+#define STS_TG      0x5     // Task Gate / Coum Transmitions
+#define STS_IG16    0x6     // 16-bit Interrupt Gate
+#define STS_TG16    0x7     // 16-bit Trap Gate
 #define STS_T32A    0x9     // Available 32-bit TSS
+#define STS_T32B    0xB     // Busy 32-bit TSS
+#define STS_CG32    0xC     // 32-bit Call Gate
 #define STS_IG32    0xE     // 32-bit Interrupt Gate
 #define STS_TG32    0xF     // 32-bit Trap Gate
 
@@ -84,6 +124,7 @@ struct segdesc {
 #define NPTENTRIES      1024    // # PTEs per page table
 #define PGSIZE          4096    // bytes mapped by a page
 
+#define PGSHIFT         12      // log2(PGSIZE)
 #define PTXSHIFT        12      // offset of PTX in a linear address
 #define PDXSHIFT        22      // offset of PDX in a linear address
 
@@ -94,7 +135,12 @@ struct segdesc {
 #define PTE_P           0x001   // Present
 #define PTE_W           0x002   // Writeable
 #define PTE_U           0x004   // User
+#define PTE_PWT         0x008   // Write-Through
+#define PTE_PCD         0x010   // Cache-Disable
+#define PTE_A           0x020   // Accessed
+#define PTE_D           0x040   // Dirty
 #define PTE_PS          0x080   // Page Size
+#define PTE_MBZ         0x180   // Bits must be zero
 
 // Address in page table or page directory entry
 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
@@ -144,13 +190,14 @@ struct taskstate {
   ushort iomb;       // I/O map base address
 };
 
+// PAGEBREAK: 12
 // Gate descriptors for interrupts and traps
 struct gatedesc {
   uint off_15_0 : 16;   // low 16 bits of offset in segment
   uint cs : 16;         // code segment selector
   uint args : 5;        // # args, 0 for interrupt/trap gates
   uint rsv1 : 3;        // reserved(should be zero I guess)
-  uint type : 4;        // type(STS_{IG32,TG32})
+  uint type : 4;        // type(STS_{TG,IG32,TG32})
   uint s : 1;           // must be 0 (system)
   uint dpl : 2;         // descriptor(meaning new) privilege level
   uint p : 1;           // Present
diff --git a/mp.d b/mp.d
new file mode 100644
index 0000000..0714441
--- /dev/null
+++ b/mp.d
@@ -0,0 +1,2 @@
+mp.o: mp.c /usr/include/stdc-predef.h types.h defs.h param.h memlayout.h \
+ mp.h x86.h mmu.h proc.h
diff --git a/mp.o b/mp.o
new file mode 100644
index 0000000..319593c
Binary files /dev/null and b/mp.o differ
diff --git a/null.asm b/null.asm
new file mode 100644
index 0000000..00713de
--- /dev/null
+++ b/null.asm
@@ -0,0 +1,1204 @@
+
+_null:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	83 e4 f0             	and    $0xfffffff0,%esp
+    1006:	83 ec 10             	sub    $0x10,%esp
+int *i = 0;
+
+(*i)++;
+    1009:	a1 00 00 00 00       	mov    0x0,%eax
+    100e:	83 c0 01             	add    $0x1,%eax
+    1011:	a3 00 00 00 00       	mov    %eax,0x0
+
+printf(1,"Hi %d",*i);
+    1016:	89 44 24 08          	mov    %eax,0x8(%esp)
+    101a:	c7 44 24 04 61 17 00 	movl   $0x1761,0x4(%esp)
+    1021:	00 
+    1022:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1029:	e8 92 03 00 00       	call   13c0 <printf>
+
+return 1;
+}
+    102e:	b8 01 00 00 00       	mov    $0x1,%eax
+    1033:	c9                   	leave  
+    1034:	c3                   	ret    
+    1035:	66 90                	xchg   %ax,%ax
+    1037:	66 90                	xchg   %ax,%ax
+    1039:	66 90                	xchg   %ax,%ax
+    103b:	66 90                	xchg   %ax,%ax
+    103d:	66 90                	xchg   %ax,%ax
+    103f:	90                   	nop
+
+00001040 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1040:	55                   	push   %ebp
+    1041:	89 e5                	mov    %esp,%ebp
+    1043:	8b 45 08             	mov    0x8(%ebp),%eax
+    1046:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1049:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    104a:	89 c2                	mov    %eax,%edx
+    104c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1050:	83 c1 01             	add    $0x1,%ecx
+    1053:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1057:	83 c2 01             	add    $0x1,%edx
+    105a:	84 db                	test   %bl,%bl
+    105c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    105f:	75 ef                	jne    1050 <strcpy+0x10>
+    ;
+  return os;
+}
+    1061:	5b                   	pop    %ebx
+    1062:	5d                   	pop    %ebp
+    1063:	c3                   	ret    
+    1064:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    106a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001070 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1070:	55                   	push   %ebp
+    1071:	89 e5                	mov    %esp,%ebp
+    1073:	8b 55 08             	mov    0x8(%ebp),%edx
+    1076:	53                   	push   %ebx
+    1077:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    107a:	0f b6 02             	movzbl (%edx),%eax
+    107d:	84 c0                	test   %al,%al
+    107f:	74 2d                	je     10ae <strcmp+0x3e>
+    1081:	0f b6 19             	movzbl (%ecx),%ebx
+    1084:	38 d8                	cmp    %bl,%al
+    1086:	74 0e                	je     1096 <strcmp+0x26>
+    1088:	eb 2b                	jmp    10b5 <strcmp+0x45>
+    108a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1090:	38 c8                	cmp    %cl,%al
+    1092:	75 15                	jne    10a9 <strcmp+0x39>
+    p++, q++;
+    1094:	89 d9                	mov    %ebx,%ecx
+    1096:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    1099:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    109c:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    109f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    10a3:	84 c0                	test   %al,%al
+    10a5:	75 e9                	jne    1090 <strcmp+0x20>
+    10a7:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    10a9:	29 c8                	sub    %ecx,%eax
+}
+    10ab:	5b                   	pop    %ebx
+    10ac:	5d                   	pop    %ebp
+    10ad:	c3                   	ret    
+    10ae:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    10b1:	31 c0                	xor    %eax,%eax
+    10b3:	eb f4                	jmp    10a9 <strcmp+0x39>
+    10b5:	0f b6 cb             	movzbl %bl,%ecx
+    10b8:	eb ef                	jmp    10a9 <strcmp+0x39>
+    10ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000010c0 <strlen>:
+
+uint
+strlen(char *s)
+{
+    10c0:	55                   	push   %ebp
+    10c1:	89 e5                	mov    %esp,%ebp
+    10c3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    10c6:	80 39 00             	cmpb   $0x0,(%ecx)
+    10c9:	74 12                	je     10dd <strlen+0x1d>
+    10cb:	31 d2                	xor    %edx,%edx
+    10cd:	8d 76 00             	lea    0x0(%esi),%esi
+    10d0:	83 c2 01             	add    $0x1,%edx
+    10d3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    10d7:	89 d0                	mov    %edx,%eax
+    10d9:	75 f5                	jne    10d0 <strlen+0x10>
+    ;
+  return n;
+}
+    10db:	5d                   	pop    %ebp
+    10dc:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    10dd:	31 c0                	xor    %eax,%eax
+}
+    10df:	5d                   	pop    %ebp
+    10e0:	c3                   	ret    
+    10e1:	eb 0d                	jmp    10f0 <memset>
+    10e3:	90                   	nop
+    10e4:	90                   	nop
+    10e5:	90                   	nop
+    10e6:	90                   	nop
+    10e7:	90                   	nop
+    10e8:	90                   	nop
+    10e9:	90                   	nop
+    10ea:	90                   	nop
+    10eb:	90                   	nop
+    10ec:	90                   	nop
+    10ed:	90                   	nop
+    10ee:	90                   	nop
+    10ef:	90                   	nop
+
+000010f0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    10f0:	55                   	push   %ebp
+    10f1:	89 e5                	mov    %esp,%ebp
+    10f3:	8b 55 08             	mov    0x8(%ebp),%edx
+    10f6:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    10f7:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    10fa:	8b 45 0c             	mov    0xc(%ebp),%eax
+    10fd:	89 d7                	mov    %edx,%edi
+    10ff:	fc                   	cld    
+    1100:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    1102:	89 d0                	mov    %edx,%eax
+    1104:	5f                   	pop    %edi
+    1105:	5d                   	pop    %ebp
+    1106:	c3                   	ret    
+    1107:	89 f6                	mov    %esi,%esi
+    1109:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001110 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    1110:	55                   	push   %ebp
+    1111:	89 e5                	mov    %esp,%ebp
+    1113:	8b 45 08             	mov    0x8(%ebp),%eax
+    1116:	53                   	push   %ebx
+    1117:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    111a:	0f b6 18             	movzbl (%eax),%ebx
+    111d:	84 db                	test   %bl,%bl
+    111f:	74 1d                	je     113e <strchr+0x2e>
+    if(*s == c)
+    1121:	38 d3                	cmp    %dl,%bl
+    1123:	89 d1                	mov    %edx,%ecx
+    1125:	75 0d                	jne    1134 <strchr+0x24>
+    1127:	eb 17                	jmp    1140 <strchr+0x30>
+    1129:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1130:	38 ca                	cmp    %cl,%dl
+    1132:	74 0c                	je     1140 <strchr+0x30>
+  for(; *s; s++)
+    1134:	83 c0 01             	add    $0x1,%eax
+    1137:	0f b6 10             	movzbl (%eax),%edx
+    113a:	84 d2                	test   %dl,%dl
+    113c:	75 f2                	jne    1130 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    113e:	31 c0                	xor    %eax,%eax
+}
+    1140:	5b                   	pop    %ebx
+    1141:	5d                   	pop    %ebp
+    1142:	c3                   	ret    
+    1143:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001150 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1150:	55                   	push   %ebp
+    1151:	89 e5                	mov    %esp,%ebp
+    1153:	57                   	push   %edi
+    1154:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1155:	31 f6                	xor    %esi,%esi
+{
+    1157:	53                   	push   %ebx
+    1158:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    115b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    115e:	eb 31                	jmp    1191 <gets+0x41>
+    cc = read(0, &c, 1);
+    1160:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1167:	00 
+    1168:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    116c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1173:	e8 02 01 00 00       	call   127a <read>
+    if(cc < 1)
+    1178:	85 c0                	test   %eax,%eax
+    117a:	7e 1d                	jle    1199 <gets+0x49>
+      break;
+    buf[i++] = c;
+    117c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    1180:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    1182:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    1185:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    1187:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    118b:	74 0c                	je     1199 <gets+0x49>
+    118d:	3c 0a                	cmp    $0xa,%al
+    118f:	74 08                	je     1199 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    1191:	8d 5e 01             	lea    0x1(%esi),%ebx
+    1194:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    1197:	7c c7                	jl     1160 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    1199:	8b 45 08             	mov    0x8(%ebp),%eax
+    119c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    11a0:	83 c4 2c             	add    $0x2c,%esp
+    11a3:	5b                   	pop    %ebx
+    11a4:	5e                   	pop    %esi
+    11a5:	5f                   	pop    %edi
+    11a6:	5d                   	pop    %ebp
+    11a7:	c3                   	ret    
+    11a8:	90                   	nop
+    11a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000011b0 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    11b0:	55                   	push   %ebp
+    11b1:	89 e5                	mov    %esp,%ebp
+    11b3:	56                   	push   %esi
+    11b4:	53                   	push   %ebx
+    11b5:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    11b8:	8b 45 08             	mov    0x8(%ebp),%eax
+    11bb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    11c2:	00 
+    11c3:	89 04 24             	mov    %eax,(%esp)
+    11c6:	e8 d7 00 00 00       	call   12a2 <open>
+  if(fd < 0)
+    11cb:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    11cd:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    11cf:	78 27                	js     11f8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    11d1:	8b 45 0c             	mov    0xc(%ebp),%eax
+    11d4:	89 1c 24             	mov    %ebx,(%esp)
+    11d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    11db:	e8 da 00 00 00       	call   12ba <fstat>
+  close(fd);
+    11e0:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    11e3:	89 c6                	mov    %eax,%esi
+  close(fd);
+    11e5:	e8 a0 00 00 00       	call   128a <close>
+  return r;
+    11ea:	89 f0                	mov    %esi,%eax
+}
+    11ec:	83 c4 10             	add    $0x10,%esp
+    11ef:	5b                   	pop    %ebx
+    11f0:	5e                   	pop    %esi
+    11f1:	5d                   	pop    %ebp
+    11f2:	c3                   	ret    
+    11f3:	90                   	nop
+    11f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    11f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    11fd:	eb ed                	jmp    11ec <stat+0x3c>
+    11ff:	90                   	nop
+
+00001200 <atoi>:
+
+int
+atoi(const char *s)
+{
+    1200:	55                   	push   %ebp
+    1201:	89 e5                	mov    %esp,%ebp
+    1203:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    1206:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    1207:	0f be 11             	movsbl (%ecx),%edx
+    120a:	8d 42 d0             	lea    -0x30(%edx),%eax
+    120d:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    120f:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    1214:	77 17                	ja     122d <atoi+0x2d>
+    1216:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    1218:	83 c1 01             	add    $0x1,%ecx
+    121b:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    121e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1222:	0f be 11             	movsbl (%ecx),%edx
+    1225:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1228:	80 fb 09             	cmp    $0x9,%bl
+    122b:	76 eb                	jbe    1218 <atoi+0x18>
+  return n;
+}
+    122d:	5b                   	pop    %ebx
+    122e:	5d                   	pop    %ebp
+    122f:	c3                   	ret    
+
+00001230 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1230:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1231:	31 d2                	xor    %edx,%edx
+{
+    1233:	89 e5                	mov    %esp,%ebp
+    1235:	56                   	push   %esi
+    1236:	8b 45 08             	mov    0x8(%ebp),%eax
+    1239:	53                   	push   %ebx
+    123a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    123d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1240:	85 db                	test   %ebx,%ebx
+    1242:	7e 12                	jle    1256 <memmove+0x26>
+    1244:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1248:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    124c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    124f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1252:	39 da                	cmp    %ebx,%edx
+    1254:	75 f2                	jne    1248 <memmove+0x18>
+  return vdst;
+}
+    1256:	5b                   	pop    %ebx
+    1257:	5e                   	pop    %esi
+    1258:	5d                   	pop    %ebp
+    1259:	c3                   	ret    
+
+0000125a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    125a:	b8 01 00 00 00       	mov    $0x1,%eax
+    125f:	cd 40                	int    $0x40
+    1261:	c3                   	ret    
+
+00001262 <exit>:
+SYSCALL(exit)
+    1262:	b8 02 00 00 00       	mov    $0x2,%eax
+    1267:	cd 40                	int    $0x40
+    1269:	c3                   	ret    
+
+0000126a <wait>:
+SYSCALL(wait)
+    126a:	b8 03 00 00 00       	mov    $0x3,%eax
+    126f:	cd 40                	int    $0x40
+    1271:	c3                   	ret    
+
+00001272 <pipe>:
+SYSCALL(pipe)
+    1272:	b8 04 00 00 00       	mov    $0x4,%eax
+    1277:	cd 40                	int    $0x40
+    1279:	c3                   	ret    
+
+0000127a <read>:
+SYSCALL(read)
+    127a:	b8 05 00 00 00       	mov    $0x5,%eax
+    127f:	cd 40                	int    $0x40
+    1281:	c3                   	ret    
+
+00001282 <write>:
+SYSCALL(write)
+    1282:	b8 10 00 00 00       	mov    $0x10,%eax
+    1287:	cd 40                	int    $0x40
+    1289:	c3                   	ret    
+
+0000128a <close>:
+SYSCALL(close)
+    128a:	b8 15 00 00 00       	mov    $0x15,%eax
+    128f:	cd 40                	int    $0x40
+    1291:	c3                   	ret    
+
+00001292 <kill>:
+SYSCALL(kill)
+    1292:	b8 06 00 00 00       	mov    $0x6,%eax
+    1297:	cd 40                	int    $0x40
+    1299:	c3                   	ret    
+
+0000129a <exec>:
+SYSCALL(exec)
+    129a:	b8 07 00 00 00       	mov    $0x7,%eax
+    129f:	cd 40                	int    $0x40
+    12a1:	c3                   	ret    
+
+000012a2 <open>:
+SYSCALL(open)
+    12a2:	b8 0f 00 00 00       	mov    $0xf,%eax
+    12a7:	cd 40                	int    $0x40
+    12a9:	c3                   	ret    
+
+000012aa <mknod>:
+SYSCALL(mknod)
+    12aa:	b8 11 00 00 00       	mov    $0x11,%eax
+    12af:	cd 40                	int    $0x40
+    12b1:	c3                   	ret    
+
+000012b2 <unlink>:
+SYSCALL(unlink)
+    12b2:	b8 12 00 00 00       	mov    $0x12,%eax
+    12b7:	cd 40                	int    $0x40
+    12b9:	c3                   	ret    
+
+000012ba <fstat>:
+SYSCALL(fstat)
+    12ba:	b8 08 00 00 00       	mov    $0x8,%eax
+    12bf:	cd 40                	int    $0x40
+    12c1:	c3                   	ret    
+
+000012c2 <link>:
+SYSCALL(link)
+    12c2:	b8 13 00 00 00       	mov    $0x13,%eax
+    12c7:	cd 40                	int    $0x40
+    12c9:	c3                   	ret    
+
+000012ca <mkdir>:
+SYSCALL(mkdir)
+    12ca:	b8 14 00 00 00       	mov    $0x14,%eax
+    12cf:	cd 40                	int    $0x40
+    12d1:	c3                   	ret    
+
+000012d2 <chdir>:
+SYSCALL(chdir)
+    12d2:	b8 09 00 00 00       	mov    $0x9,%eax
+    12d7:	cd 40                	int    $0x40
+    12d9:	c3                   	ret    
+
+000012da <dup>:
+SYSCALL(dup)
+    12da:	b8 0a 00 00 00       	mov    $0xa,%eax
+    12df:	cd 40                	int    $0x40
+    12e1:	c3                   	ret    
+
+000012e2 <getpid>:
+SYSCALL(getpid)
+    12e2:	b8 0b 00 00 00       	mov    $0xb,%eax
+    12e7:	cd 40                	int    $0x40
+    12e9:	c3                   	ret    
+
+000012ea <sbrk>:
+SYSCALL(sbrk)
+    12ea:	b8 0c 00 00 00       	mov    $0xc,%eax
+    12ef:	cd 40                	int    $0x40
+    12f1:	c3                   	ret    
+
+000012f2 <sleep>:
+SYSCALL(sleep)
+    12f2:	b8 0d 00 00 00       	mov    $0xd,%eax
+    12f7:	cd 40                	int    $0x40
+    12f9:	c3                   	ret    
+
+000012fa <uptime>:
+SYSCALL(uptime)
+    12fa:	b8 0e 00 00 00       	mov    $0xe,%eax
+    12ff:	cd 40                	int    $0x40
+    1301:	c3                   	ret    
+
+00001302 <shm_open>:
+SYSCALL(shm_open)
+    1302:	b8 16 00 00 00       	mov    $0x16,%eax
+    1307:	cd 40                	int    $0x40
+    1309:	c3                   	ret    
+
+0000130a <shm_close>:
+SYSCALL(shm_close)	
+    130a:	b8 17 00 00 00       	mov    $0x17,%eax
+    130f:	cd 40                	int    $0x40
+    1311:	c3                   	ret    
+    1312:	66 90                	xchg   %ax,%ax
+    1314:	66 90                	xchg   %ax,%ax
+    1316:	66 90                	xchg   %ax,%ax
+    1318:	66 90                	xchg   %ax,%ax
+    131a:	66 90                	xchg   %ax,%ax
+    131c:	66 90                	xchg   %ax,%ax
+    131e:	66 90                	xchg   %ax,%ax
+
+00001320 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1320:	55                   	push   %ebp
+    1321:	89 e5                	mov    %esp,%ebp
+    1323:	57                   	push   %edi
+    1324:	56                   	push   %esi
+    1325:	89 c6                	mov    %eax,%esi
+    1327:	53                   	push   %ebx
+    1328:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    132b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    132e:	85 db                	test   %ebx,%ebx
+    1330:	74 09                	je     133b <printint+0x1b>
+    1332:	89 d0                	mov    %edx,%eax
+    1334:	c1 e8 1f             	shr    $0x1f,%eax
+    1337:	84 c0                	test   %al,%al
+    1339:	75 75                	jne    13b0 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    133b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    133d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1344:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1347:	31 ff                	xor    %edi,%edi
+    1349:	89 ce                	mov    %ecx,%esi
+    134b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    134e:	eb 02                	jmp    1352 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1350:	89 cf                	mov    %ecx,%edi
+    1352:	31 d2                	xor    %edx,%edx
+    1354:	f7 f6                	div    %esi
+    1356:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1359:	0f b6 92 6e 17 00 00 	movzbl 0x176e(%edx),%edx
+  }while((x /= base) != 0);
+    1360:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1362:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1365:	75 e9                	jne    1350 <printint+0x30>
+  if(neg)
+    1367:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    136a:	89 c8                	mov    %ecx,%eax
+    136c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    136f:	85 d2                	test   %edx,%edx
+    1371:	74 08                	je     137b <printint+0x5b>
+    buf[i++] = '-';
+    1373:	8d 4f 02             	lea    0x2(%edi),%ecx
+    1376:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    137b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    137e:	66 90                	xchg   %ax,%ax
+    1380:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    1385:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    1388:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    138f:	00 
+    1390:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1394:	89 34 24             	mov    %esi,(%esp)
+    1397:	88 45 d7             	mov    %al,-0x29(%ebp)
+    139a:	e8 e3 fe ff ff       	call   1282 <write>
+  while(--i >= 0)
+    139f:	83 ff ff             	cmp    $0xffffffff,%edi
+    13a2:	75 dc                	jne    1380 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    13a4:	83 c4 4c             	add    $0x4c,%esp
+    13a7:	5b                   	pop    %ebx
+    13a8:	5e                   	pop    %esi
+    13a9:	5f                   	pop    %edi
+    13aa:	5d                   	pop    %ebp
+    13ab:	c3                   	ret    
+    13ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    13b0:	89 d0                	mov    %edx,%eax
+    13b2:	f7 d8                	neg    %eax
+    neg = 1;
+    13b4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    13bb:	eb 87                	jmp    1344 <printint+0x24>
+    13bd:	8d 76 00             	lea    0x0(%esi),%esi
+
+000013c0 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    13c0:	55                   	push   %ebp
+    13c1:	89 e5                	mov    %esp,%ebp
+    13c3:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    13c4:	31 ff                	xor    %edi,%edi
+{
+    13c6:	56                   	push   %esi
+    13c7:	53                   	push   %ebx
+    13c8:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    13cb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    13ce:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    13d1:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    13d4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    13d7:	0f b6 13             	movzbl (%ebx),%edx
+    13da:	83 c3 01             	add    $0x1,%ebx
+    13dd:	84 d2                	test   %dl,%dl
+    13df:	75 39                	jne    141a <printf+0x5a>
+    13e1:	e9 c2 00 00 00       	jmp    14a8 <printf+0xe8>
+    13e6:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    13e8:	83 fa 25             	cmp    $0x25,%edx
+    13eb:	0f 84 bf 00 00 00    	je     14b0 <printf+0xf0>
+  write(fd, &c, 1);
+    13f1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    13f4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    13fb:	00 
+    13fc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1400:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    1403:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    1406:	e8 77 fe ff ff       	call   1282 <write>
+    140b:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    140e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    1412:	84 d2                	test   %dl,%dl
+    1414:	0f 84 8e 00 00 00    	je     14a8 <printf+0xe8>
+    if(state == 0){
+    141a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    141c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    141f:	74 c7                	je     13e8 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1421:	83 ff 25             	cmp    $0x25,%edi
+    1424:	75 e5                	jne    140b <printf+0x4b>
+      if(c == 'd'){
+    1426:	83 fa 64             	cmp    $0x64,%edx
+    1429:	0f 84 31 01 00 00    	je     1560 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    142f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1434:	83 f8 70             	cmp    $0x70,%eax
+    1437:	0f 84 83 00 00 00    	je     14c0 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    143d:	83 fa 73             	cmp    $0x73,%edx
+    1440:	0f 84 a2 00 00 00    	je     14e8 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1446:	83 fa 63             	cmp    $0x63,%edx
+    1449:	0f 84 35 01 00 00    	je     1584 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    144f:	83 fa 25             	cmp    $0x25,%edx
+    1452:	0f 84 e0 00 00 00    	je     1538 <printf+0x178>
+  write(fd, &c, 1);
+    1458:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    145b:	83 c3 01             	add    $0x1,%ebx
+    145e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1465:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    1466:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    1468:	89 44 24 04          	mov    %eax,0x4(%esp)
+    146c:	89 34 24             	mov    %esi,(%esp)
+    146f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    1472:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    1476:	e8 07 fe ff ff       	call   1282 <write>
+        putc(fd, c);
+    147b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    147e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    1481:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1488:	00 
+    1489:	89 44 24 04          	mov    %eax,0x4(%esp)
+    148d:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    1490:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    1493:	e8 ea fd ff ff       	call   1282 <write>
+  for(i = 0; fmt[i]; i++){
+    1498:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    149c:	84 d2                	test   %dl,%dl
+    149e:	0f 85 76 ff ff ff    	jne    141a <printf+0x5a>
+    14a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    14a8:	83 c4 3c             	add    $0x3c,%esp
+    14ab:	5b                   	pop    %ebx
+    14ac:	5e                   	pop    %esi
+    14ad:	5f                   	pop    %edi
+    14ae:	5d                   	pop    %ebp
+    14af:	c3                   	ret    
+        state = '%';
+    14b0:	bf 25 00 00 00       	mov    $0x25,%edi
+    14b5:	e9 51 ff ff ff       	jmp    140b <printf+0x4b>
+    14ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    14c0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    14c3:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    14c8:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    14ca:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    14d1:	8b 10                	mov    (%eax),%edx
+    14d3:	89 f0                	mov    %esi,%eax
+    14d5:	e8 46 fe ff ff       	call   1320 <printint>
+        ap++;
+    14da:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    14de:	e9 28 ff ff ff       	jmp    140b <printf+0x4b>
+    14e3:	90                   	nop
+    14e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    14e8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    14eb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    14ef:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    14f1:	b8 67 17 00 00       	mov    $0x1767,%eax
+    14f6:	85 ff                	test   %edi,%edi
+    14f8:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    14fb:	0f b6 07             	movzbl (%edi),%eax
+    14fe:	84 c0                	test   %al,%al
+    1500:	74 2a                	je     152c <printf+0x16c>
+    1502:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1508:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    150b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    150e:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    1511:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1518:	00 
+    1519:	89 44 24 04          	mov    %eax,0x4(%esp)
+    151d:	89 34 24             	mov    %esi,(%esp)
+    1520:	e8 5d fd ff ff       	call   1282 <write>
+        while(*s != 0){
+    1525:	0f b6 07             	movzbl (%edi),%eax
+    1528:	84 c0                	test   %al,%al
+    152a:	75 dc                	jne    1508 <printf+0x148>
+      state = 0;
+    152c:	31 ff                	xor    %edi,%edi
+    152e:	e9 d8 fe ff ff       	jmp    140b <printf+0x4b>
+    1533:	90                   	nop
+    1534:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1538:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    153b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    153d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1544:	00 
+    1545:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1549:	89 34 24             	mov    %esi,(%esp)
+    154c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1550:	e8 2d fd ff ff       	call   1282 <write>
+    1555:	e9 b1 fe ff ff       	jmp    140b <printf+0x4b>
+    155a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    1560:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1563:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    1568:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    156b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1572:	8b 10                	mov    (%eax),%edx
+    1574:	89 f0                	mov    %esi,%eax
+    1576:	e8 a5 fd ff ff       	call   1320 <printint>
+        ap++;
+    157b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    157f:	e9 87 fe ff ff       	jmp    140b <printf+0x4b>
+        putc(fd, *ap);
+    1584:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    1587:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    1589:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    158b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1592:	00 
+    1593:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    1596:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    1599:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    159c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15a0:	e8 dd fc ff ff       	call   1282 <write>
+        ap++;
+    15a5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15a9:	e9 5d fe ff ff       	jmp    140b <printf+0x4b>
+    15ae:	66 90                	xchg   %ax,%ax
+
+000015b0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    15b0:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15b1:	a1 28 1a 00 00       	mov    0x1a28,%eax
+{
+    15b6:	89 e5                	mov    %esp,%ebp
+    15b8:	57                   	push   %edi
+    15b9:	56                   	push   %esi
+    15ba:	53                   	push   %ebx
+    15bb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15be:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    15c0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15c3:	39 d0                	cmp    %edx,%eax
+    15c5:	72 11                	jb     15d8 <free+0x28>
+    15c7:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15c8:	39 c8                	cmp    %ecx,%eax
+    15ca:	72 04                	jb     15d0 <free+0x20>
+    15cc:	39 ca                	cmp    %ecx,%edx
+    15ce:	72 10                	jb     15e0 <free+0x30>
+    15d0:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15d2:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15d4:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15d6:	73 f0                	jae    15c8 <free+0x18>
+    15d8:	39 ca                	cmp    %ecx,%edx
+    15da:	72 04                	jb     15e0 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15dc:	39 c8                	cmp    %ecx,%eax
+    15de:	72 f0                	jb     15d0 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    15e0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    15e3:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    15e6:	39 cf                	cmp    %ecx,%edi
+    15e8:	74 1e                	je     1608 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    15ea:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    15ed:	8b 48 04             	mov    0x4(%eax),%ecx
+    15f0:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    15f3:	39 f2                	cmp    %esi,%edx
+    15f5:	74 28                	je     161f <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    15f7:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    15f9:	a3 28 1a 00 00       	mov    %eax,0x1a28
+}
+    15fe:	5b                   	pop    %ebx
+    15ff:	5e                   	pop    %esi
+    1600:	5f                   	pop    %edi
+    1601:	5d                   	pop    %ebp
+    1602:	c3                   	ret    
+    1603:	90                   	nop
+    1604:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    1608:	03 71 04             	add    0x4(%ecx),%esi
+    160b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    160e:	8b 08                	mov    (%eax),%ecx
+    1610:	8b 09                	mov    (%ecx),%ecx
+    1612:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    1615:	8b 48 04             	mov    0x4(%eax),%ecx
+    1618:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    161b:	39 f2                	cmp    %esi,%edx
+    161d:	75 d8                	jne    15f7 <free+0x47>
+    p->s.size += bp->s.size;
+    161f:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    1622:	a3 28 1a 00 00       	mov    %eax,0x1a28
+    p->s.size += bp->s.size;
+    1627:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    162a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    162d:	89 10                	mov    %edx,(%eax)
+}
+    162f:	5b                   	pop    %ebx
+    1630:	5e                   	pop    %esi
+    1631:	5f                   	pop    %edi
+    1632:	5d                   	pop    %ebp
+    1633:	c3                   	ret    
+    1634:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    163a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001640 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1640:	55                   	push   %ebp
+    1641:	89 e5                	mov    %esp,%ebp
+    1643:	57                   	push   %edi
+    1644:	56                   	push   %esi
+    1645:	53                   	push   %ebx
+    1646:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1649:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    164c:	8b 1d 28 1a 00 00    	mov    0x1a28,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1652:	8d 48 07             	lea    0x7(%eax),%ecx
+    1655:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1658:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    165a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    165d:	0f 84 9b 00 00 00    	je     16fe <malloc+0xbe>
+    1663:	8b 13                	mov    (%ebx),%edx
+    1665:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    1668:	39 fe                	cmp    %edi,%esi
+    166a:	76 64                	jbe    16d0 <malloc+0x90>
+    166c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    1673:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    1678:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    167b:	eb 0e                	jmp    168b <malloc+0x4b>
+    167d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1680:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    1682:	8b 78 04             	mov    0x4(%eax),%edi
+    1685:	39 fe                	cmp    %edi,%esi
+    1687:	76 4f                	jbe    16d8 <malloc+0x98>
+    1689:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    168b:	3b 15 28 1a 00 00    	cmp    0x1a28,%edx
+    1691:	75 ed                	jne    1680 <malloc+0x40>
+  if(nu < 4096)
+    1693:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1696:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    169c:	bf 00 10 00 00       	mov    $0x1000,%edi
+    16a1:	0f 43 fe             	cmovae %esi,%edi
+    16a4:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    16a7:	89 04 24             	mov    %eax,(%esp)
+    16aa:	e8 3b fc ff ff       	call   12ea <sbrk>
+  if(p == (char*)-1)
+    16af:	83 f8 ff             	cmp    $0xffffffff,%eax
+    16b2:	74 18                	je     16cc <malloc+0x8c>
+  hp->s.size = nu;
+    16b4:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    16b7:	83 c0 08             	add    $0x8,%eax
+    16ba:	89 04 24             	mov    %eax,(%esp)
+    16bd:	e8 ee fe ff ff       	call   15b0 <free>
+  return freep;
+    16c2:	8b 15 28 1a 00 00    	mov    0x1a28,%edx
+      if((p = morecore(nunits)) == 0)
+    16c8:	85 d2                	test   %edx,%edx
+    16ca:	75 b4                	jne    1680 <malloc+0x40>
+        return 0;
+    16cc:	31 c0                	xor    %eax,%eax
+    16ce:	eb 20                	jmp    16f0 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    16d0:	89 d0                	mov    %edx,%eax
+    16d2:	89 da                	mov    %ebx,%edx
+    16d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    16d8:	39 fe                	cmp    %edi,%esi
+    16da:	74 1c                	je     16f8 <malloc+0xb8>
+        p->s.size -= nunits;
+    16dc:	29 f7                	sub    %esi,%edi
+    16de:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    16e1:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    16e4:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    16e7:	89 15 28 1a 00 00    	mov    %edx,0x1a28
+      return (void*)(p + 1);
+    16ed:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    16f0:	83 c4 1c             	add    $0x1c,%esp
+    16f3:	5b                   	pop    %ebx
+    16f4:	5e                   	pop    %esi
+    16f5:	5f                   	pop    %edi
+    16f6:	5d                   	pop    %ebp
+    16f7:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    16f8:	8b 08                	mov    (%eax),%ecx
+    16fa:	89 0a                	mov    %ecx,(%edx)
+    16fc:	eb e9                	jmp    16e7 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    16fe:	c7 05 28 1a 00 00 2c 	movl   $0x1a2c,0x1a28
+    1705:	1a 00 00 
+    base.s.size = 0;
+    1708:	ba 2c 1a 00 00       	mov    $0x1a2c,%edx
+    base.s.ptr = freep = prevp = &base;
+    170d:	c7 05 2c 1a 00 00 2c 	movl   $0x1a2c,0x1a2c
+    1714:	1a 00 00 
+    base.s.size = 0;
+    1717:	c7 05 30 1a 00 00 00 	movl   $0x0,0x1a30
+    171e:	00 00 00 
+    1721:	e9 46 ff ff ff       	jmp    166c <malloc+0x2c>
+    1726:	66 90                	xchg   %ax,%ax
+    1728:	66 90                	xchg   %ax,%ax
+    172a:	66 90                	xchg   %ax,%ax
+    172c:	66 90                	xchg   %ax,%ax
+    172e:	66 90                	xchg   %ax,%ax
+
+00001730 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1730:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1731:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1736:	89 e5                	mov    %esp,%ebp
+    1738:	8b 55 08             	mov    0x8(%ebp),%edx
+    173b:	90                   	nop
+    173c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1740:	89 c8                	mov    %ecx,%eax
+    1742:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1745:	85 c0                	test   %eax,%eax
+    1747:	75 f7                	jne    1740 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1749:	0f ae f0             	mfence 
+}
+    174c:	5d                   	pop    %ebp
+    174d:	c3                   	ret    
+    174e:	66 90                	xchg   %ax,%ax
+
+00001750 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1750:	55                   	push   %ebp
+    1751:	89 e5                	mov    %esp,%ebp
+    1753:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1756:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1759:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    175f:	5d                   	pop    %ebp
+    1760:	c3                   	ret    
diff --git a/null.c b/null.c
new file mode 100644
index 0000000..eef068c
--- /dev/null
+++ b/null.c
@@ -0,0 +1,15 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(int argc, char *argv[])
+{
+int *i = 0;
+
+(*i)++;
+
+printf(1,"Hi %d",*i);
+
+return 1;
+}
+
diff --git a/null.d b/null.d
new file mode 100644
index 0000000..ce6ff04
--- /dev/null
+++ b/null.d
@@ -0,0 +1 @@
+null.o: null.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/null.o b/null.o
new file mode 100644
index 0000000..42b2837
Binary files /dev/null and b/null.o differ
diff --git a/null.sym b/null.sym
new file mode 100644
index 0000000..a2fd4de
--- /dev/null
+++ b/null.sym
@@ -0,0 +1,62 @@
+00001000 .text
+00001761 .rodata
+00001780 .eh_frame
+00001a28 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 null.c
+00000000 ulib.c
+00000000 printf.c
+00001320 printint
+0000176e digits.1359
+00000000 umalloc.c
+00001a28 freep
+00001a2c base
+00000000 uspinlock.c
+00001040 strcpy
+000013c0 printf
+00001230 memmove
+000012aa mknod
+00001302 shm_open
+00001150 gets
+000012e2 getpid
+00001640 malloc
+000012f2 sleep
+00001272 pipe
+00001282 write
+000012ba fstat
+00001292 kill
+000012d2 chdir
+0000129a exec
+0000126a wait
+0000127a read
+000012b2 unlink
+00001730 uacquire
+0000125a fork
+000012ea sbrk
+0000130a shm_close
+000012fa uptime
+00001a28 __bss_start
+000010f0 memset
+00001000 main
+00001070 strcmp
+000012da dup
+000011b0 stat
+00001a28 _edata
+00001a34 _end
+000012c2 link
+00001262 exit
+00001200 atoi
+000010c0 strlen
+000012a2 open
+00001110 strchr
+000012ca mkdir
+0000128a close
+00001750 urelease
+000015b0 free
diff --git a/picirq.d b/picirq.d
new file mode 100644
index 0000000..5233e7e
--- /dev/null
+++ b/picirq.d
@@ -0,0 +1 @@
+picirq.o: picirq.c /usr/include/stdc-predef.h types.h x86.h traps.h
diff --git a/picirq.o b/picirq.o
new file mode 100644
index 0000000..ebbde7e
Binary files /dev/null and b/picirq.o differ
diff --git a/pipe.d b/pipe.d
new file mode 100644
index 0000000..3d0eac9
--- /dev/null
+++ b/pipe.d
@@ -0,0 +1,2 @@
+pipe.o: pipe.c /usr/include/stdc-predef.h types.h defs.h param.h mmu.h \
+ proc.h fs.h spinlock.h sleeplock.h file.h
diff --git a/pipe.o b/pipe.o
new file mode 100644
index 0000000..a2f4d1d
Binary files /dev/null and b/pipe.o differ
diff --git a/printf.c b/printf.c
index b3298aa..9972b45 100644
--- a/printf.c
+++ b/printf.c
@@ -37,7 +37,7 @@ printint(int fd, int xx, int base, int sgn)
 
 // Print to the given fd. Only understands %d, %x, %p, %s.
 void
-printf(int fd, const char *fmt, ...)
+printf(int fd, char *fmt, ...)
 {
   char *s;
   int c, i, state;
diff --git a/printf.d b/printf.d
new file mode 100644
index 0000000..ddd3a8d
--- /dev/null
+++ b/printf.d
@@ -0,0 +1 @@
+printf.o: printf.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/printf.o b/printf.o
new file mode 100644
index 0000000..f544951
Binary files /dev/null and b/printf.o differ
diff --git a/proc.c b/proc.c
index 84b335f..806b1b1 100644
--- a/proc.c
+++ b/proc.c
@@ -1,5 +1,3 @@
-#include <stddef.h>
-
 #include "types.h"
 #include "defs.h"
 #include "param.h"
@@ -10,61 +8,61 @@
 #include "spinlock.h"
 
 struct {
-    struct spinlock lock;
-    struct proc proc[NPROC];
+  struct spinlock lock;
+  struct proc proc[NPROC];
 } ptable;
 
 static struct proc *initproc;
 
 int nextpid = 1;
-
 extern void forkret(void);
-
 extern void trapret(void);
 
 static void wakeup1(void *chan);
 
 void
-pinit(void) {
-    initlock(&ptable.lock, "ptable");
+pinit(void)
+{
+  initlock(&ptable.lock, "ptable");
 }
 
 // Must be called with interrupts disabled
 int
 cpuid() {
-    return mycpu() - cpus;
+  return mycpu()-cpus;
 }
 
 // Must be called with interrupts disabled to avoid the caller being
 // rescheduled between reading lapicid and running through the loop.
-struct cpu *
-mycpu(void) {
-    int apicid, i;
-
-    if (readeflags() & FL_IF)
-        panic("mycpu called with interrupts enabled\n");
-
-    apicid = lapicid();
-    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
-    // a reverse map, or reserve a register to store &cpus[i].
-    for (i = 0; i < ncpu; ++i) {
-        if (cpus[i].apicid == apicid)
-            return &cpus[i];
-    }
-    panic("unknown apicid\n");
+struct cpu*
+mycpu(void)
+{
+  int apicid, i;
+  
+  if(readeflags()&FL_IF)
+    panic("mycpu called with interrupts enabled\n");
+  
+  apicid = lapicid();
+  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+  // a reverse map, or reserve a register to store &cpus[i].
+  for (i = 0; i < ncpu; ++i) {
+    if (cpus[i].apicid == apicid)
+      return &cpus[i];
+  }
+  panic("unknown apicid\n");
 }
 
 // Disable interrupts so that we are not rescheduled
 // while reading proc from the cpu structure
-struct proc *
+struct proc*
 myproc(void) {
-    struct cpu *c;
-    struct proc *p;
-    pushcli();
-    c = mycpu();
-    p = c->proc;
-    popcli();
-    return p;
+  struct cpu *c;
+  struct proc *p;
+  pushcli();
+  c = mycpu();
+  p = c->proc;
+  popcli();
+  return p;
 }
 
 //PAGEBREAK: 32
@@ -72,295 +70,245 @@ myproc(void) {
 // If found, change state to EMBRYO and initialize
 // state required to run in the kernel.
 // Otherwise return 0.
-static struct proc *
-allocproc(void) {
-    struct proc *p;
-    char *sp;
+static struct proc*
+allocproc(void)
+{
+  struct proc *p;
+  char *sp;
 
-    acquire(&ptable.lock);
+  acquire(&ptable.lock);
 
-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-        if (p->state == UNUSED)
-            goto found;
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == UNUSED)
+      goto found;
 
-    release(&ptable.lock);
-    return 0;
+  release(&ptable.lock);
+  return 0;
 
-    found:
-    p->state = EMBRYO;
-    p->pid = nextpid++;
+found:
+  p->state = EMBRYO;
+  p->pid = nextpid++;
 
-    release(&ptable.lock);
+  release(&ptable.lock);
 
-    // Allocate kernel stack.
-    if ((p->kstack = kalloc()) == 0) {
-        p->state = UNUSED;
-        return 0;
-    }
-    sp = p->kstack + KSTACKSIZE;
+  // Allocate kernel stack.
+  if((p->kstack = kalloc()) == 0){
+    p->state = UNUSED;
+    return 0;
+  }
+  sp = p->kstack + KSTACKSIZE;
 
-    // Leave room for trap frame.
-    sp -= sizeof *p->tf;
-    p->tf = (struct trapframe *) sp;
+  // Leave room for trap frame.
+  sp -= sizeof *p->tf;
+  p->tf = (struct trapframe*)sp;
 
-    // Set up new context to start executing at forkret,
-    // which returns to trapret.
-    sp -= 4;
-    *(uint *) sp = (uint) trapret;
+  // Set up new context to start executing at forkret,
+  // which returns to trapret.
+  sp -= 4;
+  *(uint*)sp = (uint)trapret;
 
-    sp -= sizeof *p->context;
-    p->context = (struct context *) sp;
-    memset(p->context, 0, sizeof *p->context);
-    p->context->eip = (uint) forkret;
+  sp -= sizeof *p->context;
+  p->context = (struct context*)sp;
+  memset(p->context, 0, sizeof *p->context);
+  p->context->eip = (uint)forkret;
 
-    return p;
+  return p;
 }
 
 //PAGEBREAK: 32
 // Set up first user process.
 void
-userinit(void) {
-    struct proc *p;
-    extern char _binary_initcode_start[], _binary_initcode_size[];
-
-    p = allocproc();
-
-    initproc = p;
-    if ((p->pgdir = setupkvm()) == 0)
-        panic("userinit: out of memory?");
-    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
-    p->sz = PGSIZE;
-    memset(p->tf, 0, sizeof(*p->tf));
-    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
-    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
-    p->tf->es = p->tf->ds;
-    p->tf->ss = p->tf->ds;
-    p->tf->eflags = FL_IF;
-    p->tf->esp = PGSIZE;
-    p->tf->eip = 0;  // beginning of initcode.S
-
-    safestrcpy(p->name, "initcode", sizeof(p->name));
-    p->cwd = namei("/");
-
-    // this assignment to p->state lets other cores
-    // run this process. the acquire forces the above
-    // writes to be visible, and the lock is also needed
-    // because the assignment might not be atomic.
-    acquire(&ptable.lock);
-
-    p->state = RUNNABLE;
-
-    release(&ptable.lock);
+userinit(void)
+{
+  struct proc *p;
+  extern char _binary_initcode_start[], _binary_initcode_size[];
+
+  p = allocproc();
+  
+  initproc = p;
+  if((p->pgdir = setupkvm()) == 0)
+    panic("userinit: out of memory?");
+  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+  p->sz = PGSIZE;
+  memset(p->tf, 0, sizeof(*p->tf));
+  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+  p->tf->es = p->tf->ds;
+  p->tf->ss = p->tf->ds;
+  p->tf->eflags = FL_IF;
+  p->tf->esp = PGSIZE;
+  p->tf->eip = 0;  // beginning of initcode.S
+
+  safestrcpy(p->name, "initcode", sizeof(p->name));
+  p->cwd = namei("/");
+
+  // this assignment to p->state lets other cores
+  // run this process. the acquire forces the above
+  // writes to be visible, and the lock is also needed
+  // because the assignment might not be atomic.
+  acquire(&ptable.lock);
+
+  p->state = RUNNABLE;
+
+  release(&ptable.lock);
 }
 
 // Grow current process's memory by n bytes.
 // Return 0 on success, -1 on failure.
 int
-growproc(int n) {
-    uint sz;
-    struct proc *curproc = myproc();
-
-    sz = curproc->sz;
-    if (n > 0) {
-        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
-            return -1;
-    } else if (n < 0) {
-        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
-            return -1;
-    }
-    curproc->sz = sz;
-    switchuvm(curproc);
-    return 0;
+growproc(int n)
+{
+  uint sz;
+  struct proc *curproc = myproc();
+
+  sz = curproc->sz;
+  if(n > 0){
+    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+      return -1;
+  } else if(n < 0){
+    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+      return -1;
+  }
+  curproc->sz = sz;
+  switchuvm(curproc);
+  return 0;
 }
 
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
 int
-fork(void) {
-    int i, pid;
-    struct proc *np;
-    struct proc *curproc = myproc();
-
-    // Allocate process.
-    if ((np = allocproc()) == 0) {
-        return -1;
-    }
+fork(void)
+{
+  int i, pid;
+  struct proc *np;
+  struct proc *curproc = myproc();
+
+  // Allocate process.
+  if((np = allocproc()) == 0){
+    return -1;
+  }
 
-    // Copy process state from proc.
-    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
-        kfree(np->kstack);
-        np->kstack = 0;
-        np->state = UNUSED;
-        return -1;
-    }
-    np->sz = curproc->sz;
-    np->parent = curproc;
-    *np->tf = *curproc->tf;
+  // Copy process state from proc.
+  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+    kfree(np->kstack);
+    np->kstack = 0;
+    np->state = UNUSED;
+    return -1;
+  }
+  np->sz = curproc->sz;
+  np->parent = curproc;
+  *np->tf = *curproc->tf;
 
-    // Clear %eax so that fork returns 0 in the child.
-    np->tf->eax = 0;
+  // Clear %eax so that fork returns 0 in the child.
+  np->tf->eax = 0;
 
-    for (i = 0; i < NOFILE; i++)
-        if (curproc->ofile[i])
-            np->ofile[i] = filedup(curproc->ofile[i]);
-    np->cwd = idup(curproc->cwd);
+  for(i = 0; i < NOFILE; i++)
+    if(curproc->ofile[i])
+      np->ofile[i] = filedup(curproc->ofile[i]);
+  np->cwd = idup(curproc->cwd);
 
-    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
 
-    pid = np->pid;
+  pid = np->pid;
 
-    acquire(&ptable.lock);
+  acquire(&ptable.lock);
 
-    np->state = RUNNABLE;
+  np->state = RUNNABLE;
 
-    release(&ptable.lock);
+  release(&ptable.lock);
 
-    return pid;
+  return pid;
 }
 
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
 void
-exit(int status) {
-    struct proc *curproc = myproc();
-    struct proc *p;
-    int fd;
-
-    curproc->status = status;
-
-    if (curproc == initproc)
-        panic("init exiting");
-
-    // Close all open files.
-    for (fd = 0; fd < NOFILE; fd++) {
-        if (curproc->ofile[fd]) {
-            fileclose(curproc->ofile[fd]);
-            curproc->ofile[fd] = 0;
-        }
+exit(void)
+{
+  struct proc *curproc = myproc();
+  struct proc *p;
+  int fd;
+
+  if(curproc == initproc)
+    panic("init exiting");
+
+  // Close all open files.
+  for(fd = 0; fd < NOFILE; fd++){
+    if(curproc->ofile[fd]){
+      fileclose(curproc->ofile[fd]);
+      curproc->ofile[fd] = 0;
     }
+  }
 
-    begin_op();
-    iput(curproc->cwd);
-    end_op();
-    curproc->cwd = 0;
+  begin_op();
+  iput(curproc->cwd);
+  end_op();
+  curproc->cwd = 0;
 
-    acquire(&ptable.lock);
+  acquire(&ptable.lock);
 
-    // Parent might be sleeping in wait().
-    wakeup1(curproc->parent);
+  // Parent might be sleeping in wait().
+  wakeup1(curproc->parent);
 
-    // Pass abandoned children to init.
-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-        if (p->parent == curproc) {
-            p->parent = initproc;
-            if (p->state == ZOMBIE)
-                wakeup1(initproc);
-        }
+  // Pass abandoned children to init.
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->parent == curproc){
+      p->parent = initproc;
+      if(p->state == ZOMBIE)
+        wakeup1(initproc);
     }
+  }
 
-    // Jump into the scheduler, never to return.
-    curproc->state = ZOMBIE;
-    sched();
-    panic("zombie exit");
+  // Jump into the scheduler, never to return.
+  curproc->state = ZOMBIE;
+  sched();
+  panic("zombie exit");
 }
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
 int
-wait(int *status) {
-    struct proc *p;
-    int havekids, pid;
-    struct proc *curproc = myproc();
-
-    acquire(&ptable.lock);
-    for (;;) {
-        // Scan through table looking for exited children.
-        havekids = 0;
-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-            if (p->parent != curproc)
-                continue;
-            havekids = 1;
-            if (p->state == ZOMBIE) {
-                // Found one.
-                pid = p->pid;
-                kfree(p->kstack);
-                p->kstack = 0;
-                freevm(p->pgdir);
-                p->pid = 0;
-                p->parent = 0;
-                p->name[0] = 0;
-                p->killed = 0;
-                p->state = UNUSED;
-                release(&ptable.lock);
-                if (status != NULL)
-                    *status = p->status;
-                return pid;
-            }
-        }
-
-        // No point waiting if we don't have any children.
-        if (!havekids || curproc->killed) {
-            release(&ptable.lock);
-            return -1;
-        }
-
-        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+wait(void)
+{
+  struct proc *p;
+  int havekids, pid;
+  struct proc *curproc = myproc();
+  
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for exited children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != curproc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        p->state = UNUSED;
+        release(&ptable.lock);
+        return pid;
+      }
     }
-}
 
-// Wait for a child process to exit and return its pid.
-// Return -1 if this process has no children.
-int
-waitpid(int pidBeingSearchedFor, int *status, int options) {
-    struct proc *p;
-    int doesProcExist, pidFound;
-    struct proc *curproc = myproc();
-    acquire(&ptable.lock);
-    for (;;) {
-        // Scan through table looking for exited children.
-        doesProcExist = 0;
-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-//            if(p->parent != curproc)
-//                continue;
-
-            if (p->pid != pidBeingSearchedFor)
-                continue;
-
-            doesProcExist = 1;
-            if (p->state == ZOMBIE) {
-                // Found one.
-                pidFound = p->pid;
-                kfree(p->kstack);
-                p->kstack = 0;
-                freevm(p->pgdir);
-                p->pid = 0;
-                p->parent = 0;
-                p->name[0] = 0;
-                p->killed = 0;
-                p->state = UNUSED;
-                release(&ptable.lock);
-                if (status != NULL)
-                    *status = p->status;
-                return pidFound;
-            }
-        }
-
-//        // No point waiting if we don't have any children.
-//        if(!havekids || curproc->killed){
-//            release(&ptable.lock);
-//            return -1;
-//        }
-
-        if (!doesProcExist || curproc->killed) {
-            release(&ptable.lock);
-            return -1;
-        }
-        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+    // No point waiting if we don't have any children.
+    if(!havekids || curproc->killed){
+      release(&ptable.lock);
+      return -1;
     }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+  }
 }
 
 //PAGEBREAK: 42
@@ -372,38 +320,39 @@ waitpid(int pidBeingSearchedFor, int *status, int options) {
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
 void
-scheduler(void) {
-    struct proc *p;
-    struct cpu *c = mycpu();
-    c->proc = 0;
-
-    for (;;) {
-        // Enable interrupts on this processor.
-        sti();
-
-        // Loop over process table looking for process to run.
-        acquire(&ptable.lock);
-        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-            if (p->state != RUNNABLE)
-                continue;
-
-            // Switch to chosen process.  It is the process's job
-            // to release ptable.lock and then reacquire it
-            // before jumping back to us.
-            c->proc = p;
-            switchuvm(p);
-            p->state = RUNNING;
-
-            swtch(&(c->scheduler), p->context);
-            switchkvm();
-
-            // Process is done running for now.
-            // It should have changed its p->state before coming back.
-            c->proc = 0;
-        }
-        release(&ptable.lock);
-
+scheduler(void)
+{
+  struct proc *p;
+  struct cpu *c = mycpu();
+  c->proc = 0;
+  
+  for(;;){
+    // Enable interrupts on this processor.
+    sti();
+
+    // Loop over process table looking for process to run.
+    acquire(&ptable.lock);
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->state != RUNNABLE)
+        continue;
+
+      // Switch to chosen process.  It is the process's job
+      // to release ptable.lock and then reacquire it
+      // before jumping back to us.
+      c->proc = p;
+      switchuvm(p);
+      p->state = RUNNING;
+
+      swtch(&(c->scheduler), p->context);
+      switchkvm();
+
+      // Process is done running for now.
+      // It should have changed its p->state before coming back.
+      c->proc = 0;
     }
+    release(&ptable.lock);
+
+  }
 }
 
 // Enter scheduler.  Must hold only ptable.lock
@@ -414,130 +363,137 @@ scheduler(void) {
 // break in the few places where a lock is held but
 // there's no process.
 void
-sched(void) {
-    int intena;
-    struct proc *p = myproc();
-
-    if (!holding(&ptable.lock))
-        panic("sched ptable.lock");
-    if (mycpu()->ncli != 1)
-        panic("sched locks");
-    if (p->state == RUNNING)
-        panic("sched running");
-    if (readeflags() & FL_IF)
-        panic("sched interruptible");
-    intena = mycpu()->intena;
-    swtch(&p->context, mycpu()->scheduler);
-    mycpu()->intena = intena;
+sched(void)
+{
+  int intena;
+  struct proc *p = myproc();
+
+  if(!holding(&ptable.lock))
+    panic("sched ptable.lock");
+  if(mycpu()->ncli != 1)
+    panic("sched locks");
+  if(p->state == RUNNING)
+    panic("sched running");
+  if(readeflags()&FL_IF)
+    panic("sched interruptible");
+  intena = mycpu()->intena;
+  swtch(&p->context, mycpu()->scheduler);
+  mycpu()->intena = intena;
 }
 
 // Give up the CPU for one scheduling round.
 void
-yield(void) {
-    acquire(&ptable.lock);  //DOC: yieldlock
-    myproc()->state = RUNNABLE;
-    sched();
-    release(&ptable.lock);
+yield(void)
+{
+  acquire(&ptable.lock);  //DOC: yieldlock
+  myproc()->state = RUNNABLE;
+  sched();
+  release(&ptable.lock);
 }
 
 // A fork child's very first scheduling by scheduler()
 // will swtch here.  "Return" to user space.
 void
-forkret(void) {
-    static int first = 1;
-    // Still holding ptable.lock from scheduler.
-    release(&ptable.lock);
-
-    if (first) {
-        // Some initialization functions must be run in the context
-        // of a regular process (e.g., they call sleep), and thus cannot
-        // be run from main().
-        first = 0;
-        iinit(ROOTDEV);
-        initlog(ROOTDEV);
-    }
-
-    // Return to "caller", actually trapret (see allocproc).
+forkret(void)
+{
+  static int first = 1;
+  // Still holding ptable.lock from scheduler.
+  release(&ptable.lock);
+
+  if (first) {
+    // Some initialization functions must be run in the context
+    // of a regular process (e.g., they call sleep), and thus cannot
+    // be run from main().
+    first = 0;
+    iinit(ROOTDEV);
+    initlog(ROOTDEV);
+  }
+
+  // Return to "caller", actually trapret (see allocproc).
 }
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
 void
-sleep(void *chan, struct spinlock *lk) {
-    struct proc *p = myproc();
-
-    if (p == 0)
-        panic("sleep");
-
-    if (lk == 0)
-        panic("sleep without lk");
-
-    // Must acquire ptable.lock in order to
-    // change p->state and then call sched.
-    // Once we hold ptable.lock, we can be
-    // guaranteed that we won't miss any wakeup
-    // (wakeup runs with ptable.lock locked),
-    // so it's okay to release lk.
-    if (lk != &ptable.lock) {  //DOC: sleeplock0
-        acquire(&ptable.lock);  //DOC: sleeplock1
-        release(lk);
-    }
-    // Go to sleep.
-    p->chan = chan;
-    p->state = SLEEPING;
-
-    sched();
-
-    // Tidy up.
-    p->chan = 0;
-
-    // Reacquire original lock.
-    if (lk != &ptable.lock) {  //DOC: sleeplock2
-        release(&ptable.lock);
-        acquire(lk);
-    }
+sleep(void *chan, struct spinlock *lk)
+{
+  struct proc *p = myproc();
+  
+  if(p == 0)
+    panic("sleep");
+
+  if(lk == 0)
+    panic("sleep without lk");
+
+  // Must acquire ptable.lock in order to
+  // change p->state and then call sched.
+  // Once we hold ptable.lock, we can be
+  // guaranteed that we won't miss any wakeup
+  // (wakeup runs with ptable.lock locked),
+  // so it's okay to release lk.
+  if(lk != &ptable.lock){  //DOC: sleeplock0
+    acquire(&ptable.lock);  //DOC: sleeplock1
+    release(lk);
+  }
+  // Go to sleep.
+  p->chan = chan;
+  p->state = SLEEPING;
+
+  sched();
+
+  // Tidy up.
+  p->chan = 0;
+
+  // Reacquire original lock.
+  if(lk != &ptable.lock){  //DOC: sleeplock2
+    release(&ptable.lock);
+    acquire(lk);
+  }
 }
 
 //PAGEBREAK!
 // Wake up all processes sleeping on chan.
 // The ptable lock must be held.
 static void
-wakeup1(void *chan) {
-    struct proc *p;
+wakeup1(void *chan)
+{
+  struct proc *p;
 
-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-        if (p->state == SLEEPING && p->chan == chan)
-            p->state = RUNNABLE;
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == SLEEPING && p->chan == chan)
+      p->state = RUNNABLE;
 }
 
 // Wake up all processes sleeping on chan.
 void
-wakeup(void *chan) {
-    acquire(&ptable.lock);
-    wakeup1(chan);
-    release(&ptable.lock);
+wakeup(void *chan)
+{
+  acquire(&ptable.lock);
+  wakeup1(chan);
+  release(&ptable.lock);
 }
 
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
 int
-kill(int pid) {
-    struct proc *p;
-
-    acquire(&ptable.lock);
-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-        if (p->pid == pid) {
-            p->killed = 1;
-            // Wake process from sleep if necessary.
-            if (p->state == SLEEPING)
-                p->state = RUNNABLE;
-            release(&ptable.lock);
-            return 0;
-        }
+kill(int pid)
+{
+  struct proc *p;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->pid == pid){
+      p->killed = 1;
+      // Wake process from sleep if necessary.
+      if(p->state == SLEEPING)
+        p->state = RUNNABLE;
+      release(&ptable.lock);
+      return 0;
     }
-    release(&ptable.lock);
-    return -1;
+  }
+  release(&ptable.lock);
+  return -1;
 }
 
 //PAGEBREAK: 36
@@ -545,33 +501,34 @@ kill(int pid) {
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
 void
-procdump(void) {
-    static char *states[] = {
-            [UNUSED]    "unused",
-            [EMBRYO]    "embryo",
-            [SLEEPING]  "sleep ",
-            [RUNNABLE]  "runble",
-            [RUNNING]   "run   ",
-            [ZOMBIE]    "zombie"
-    };
-    int i;
-    struct proc *p;
-    char *state;
-    uint pc[10];
-
-    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
-        if (p->state == UNUSED)
-            continue;
-        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
-            state = states[p->state];
-        else
-            state = "???";
-        cprintf("%d %s %s", p->pid, state, p->name);
-        if (p->state == SLEEPING) {
-            getcallerpcs((uint *) p->context->ebp + 2, pc);
-            for (i = 0; i < 10 && pc[i] != 0; i++)
-                cprintf(" %p", pc[i]);
-        }
-        cprintf("\n");
+procdump(void)
+{
+  static char *states[] = {
+  [UNUSED]    "unused",
+  [EMBRYO]    "embryo",
+  [SLEEPING]  "sleep ",
+  [RUNNABLE]  "runble",
+  [RUNNING]   "run   ",
+  [ZOMBIE]    "zombie"
+  };
+  int i;
+  struct proc *p;
+  char *state;
+  uint pc[10];
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED)
+      continue;
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+      state = states[p->state];
+    else
+      state = "???";
+    cprintf("%d %s %s", p->pid, state, p->name);
+    if(p->state == SLEEPING){
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+      for(i=0; i<10 && pc[i] != 0; i++)
+        cprintf(" %p", pc[i]);
     }
+    cprintf("\n");
+  }
 }
diff --git a/proc.d b/proc.d
new file mode 100644
index 0000000..9396fef
--- /dev/null
+++ b/proc.d
@@ -0,0 +1,2 @@
+proc.o: proc.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h x86.h proc.h spinlock.h
diff --git a/proc.h b/proc.h
index a06b921..1647114 100644
--- a/proc.h
+++ b/proc.h
@@ -49,7 +49,6 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
-  int status;                  // Exit status
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/proc.o b/proc.o
new file mode 100644
index 0000000..2cdc5fb
Binary files /dev/null and b/proc.o differ
diff --git a/rm.asm b/rm.asm
new file mode 100644
index 0000000..b3df998
--- /dev/null
+++ b/rm.asm
@@ -0,0 +1,1240 @@
+
+_rm:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	57                   	push   %edi
+    1004:	56                   	push   %esi
+  int i;
+
+  if(argc < 2){
+    1005:	be 01 00 00 00       	mov    $0x1,%esi
+{
+    100a:	53                   	push   %ebx
+    100b:	83 e4 f0             	and    $0xfffffff0,%esp
+    100e:	83 ec 10             	sub    $0x10,%esp
+    1011:	8b 7d 08             	mov    0x8(%ebp),%edi
+    1014:	8b 45 0c             	mov    0xc(%ebp),%eax
+  if(argc < 2){
+    1017:	83 ff 01             	cmp    $0x1,%edi
+    101a:	8d 58 04             	lea    0x4(%eax),%ebx
+    101d:	7e 3a                	jle    1059 <main+0x59>
+    101f:	90                   	nop
+    printf(2, "Usage: rm files...\n");
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+    if(unlink(argv[i]) < 0){
+    1020:	8b 03                	mov    (%ebx),%eax
+    1022:	89 04 24             	mov    %eax,(%esp)
+    1025:	e8 c8 02 00 00       	call   12f2 <unlink>
+    102a:	85 c0                	test   %eax,%eax
+    102c:	78 0f                	js     103d <main+0x3d>
+  for(i = 1; i < argc; i++){
+    102e:	83 c6 01             	add    $0x1,%esi
+    1031:	83 c3 04             	add    $0x4,%ebx
+    1034:	39 fe                	cmp    %edi,%esi
+    1036:	75 e8                	jne    1020 <main+0x20>
+      printf(2, "rm: %s failed to delete\n", argv[i]);
+      break;
+    }
+  }
+
+  exit();
+    1038:	e8 65 02 00 00       	call   12a2 <exit>
+      printf(2, "rm: %s failed to delete\n", argv[i]);
+    103d:	8b 03                	mov    (%ebx),%eax
+    103f:	c7 44 24 04 b5 17 00 	movl   $0x17b5,0x4(%esp)
+    1046:	00 
+    1047:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    104e:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1052:	e8 a9 03 00 00       	call   1400 <printf>
+      break;
+    1057:	eb df                	jmp    1038 <main+0x38>
+    printf(2, "Usage: rm files...\n");
+    1059:	c7 44 24 04 a1 17 00 	movl   $0x17a1,0x4(%esp)
+    1060:	00 
+    1061:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    1068:	e8 93 03 00 00       	call   1400 <printf>
+    exit();
+    106d:	e8 30 02 00 00       	call   12a2 <exit>
+    1072:	66 90                	xchg   %ax,%ax
+    1074:	66 90                	xchg   %ax,%ax
+    1076:	66 90                	xchg   %ax,%ax
+    1078:	66 90                	xchg   %ax,%ax
+    107a:	66 90                	xchg   %ax,%ax
+    107c:	66 90                	xchg   %ax,%ax
+    107e:	66 90                	xchg   %ax,%ax
+
+00001080 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1080:	55                   	push   %ebp
+    1081:	89 e5                	mov    %esp,%ebp
+    1083:	8b 45 08             	mov    0x8(%ebp),%eax
+    1086:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1089:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    108a:	89 c2                	mov    %eax,%edx
+    108c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1090:	83 c1 01             	add    $0x1,%ecx
+    1093:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1097:	83 c2 01             	add    $0x1,%edx
+    109a:	84 db                	test   %bl,%bl
+    109c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    109f:	75 ef                	jne    1090 <strcpy+0x10>
+    ;
+  return os;
+}
+    10a1:	5b                   	pop    %ebx
+    10a2:	5d                   	pop    %ebp
+    10a3:	c3                   	ret    
+    10a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    10aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+000010b0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    10b0:	55                   	push   %ebp
+    10b1:	89 e5                	mov    %esp,%ebp
+    10b3:	8b 55 08             	mov    0x8(%ebp),%edx
+    10b6:	53                   	push   %ebx
+    10b7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    10ba:	0f b6 02             	movzbl (%edx),%eax
+    10bd:	84 c0                	test   %al,%al
+    10bf:	74 2d                	je     10ee <strcmp+0x3e>
+    10c1:	0f b6 19             	movzbl (%ecx),%ebx
+    10c4:	38 d8                	cmp    %bl,%al
+    10c6:	74 0e                	je     10d6 <strcmp+0x26>
+    10c8:	eb 2b                	jmp    10f5 <strcmp+0x45>
+    10ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    10d0:	38 c8                	cmp    %cl,%al
+    10d2:	75 15                	jne    10e9 <strcmp+0x39>
+    p++, q++;
+    10d4:	89 d9                	mov    %ebx,%ecx
+    10d6:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    10d9:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    10dc:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    10df:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    10e3:	84 c0                	test   %al,%al
+    10e5:	75 e9                	jne    10d0 <strcmp+0x20>
+    10e7:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    10e9:	29 c8                	sub    %ecx,%eax
+}
+    10eb:	5b                   	pop    %ebx
+    10ec:	5d                   	pop    %ebp
+    10ed:	c3                   	ret    
+    10ee:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    10f1:	31 c0                	xor    %eax,%eax
+    10f3:	eb f4                	jmp    10e9 <strcmp+0x39>
+    10f5:	0f b6 cb             	movzbl %bl,%ecx
+    10f8:	eb ef                	jmp    10e9 <strcmp+0x39>
+    10fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001100 <strlen>:
+
+uint
+strlen(char *s)
+{
+    1100:	55                   	push   %ebp
+    1101:	89 e5                	mov    %esp,%ebp
+    1103:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    1106:	80 39 00             	cmpb   $0x0,(%ecx)
+    1109:	74 12                	je     111d <strlen+0x1d>
+    110b:	31 d2                	xor    %edx,%edx
+    110d:	8d 76 00             	lea    0x0(%esi),%esi
+    1110:	83 c2 01             	add    $0x1,%edx
+    1113:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    1117:	89 d0                	mov    %edx,%eax
+    1119:	75 f5                	jne    1110 <strlen+0x10>
+    ;
+  return n;
+}
+    111b:	5d                   	pop    %ebp
+    111c:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    111d:	31 c0                	xor    %eax,%eax
+}
+    111f:	5d                   	pop    %ebp
+    1120:	c3                   	ret    
+    1121:	eb 0d                	jmp    1130 <memset>
+    1123:	90                   	nop
+    1124:	90                   	nop
+    1125:	90                   	nop
+    1126:	90                   	nop
+    1127:	90                   	nop
+    1128:	90                   	nop
+    1129:	90                   	nop
+    112a:	90                   	nop
+    112b:	90                   	nop
+    112c:	90                   	nop
+    112d:	90                   	nop
+    112e:	90                   	nop
+    112f:	90                   	nop
+
+00001130 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    1130:	55                   	push   %ebp
+    1131:	89 e5                	mov    %esp,%ebp
+    1133:	8b 55 08             	mov    0x8(%ebp),%edx
+    1136:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    1137:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    113a:	8b 45 0c             	mov    0xc(%ebp),%eax
+    113d:	89 d7                	mov    %edx,%edi
+    113f:	fc                   	cld    
+    1140:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    1142:	89 d0                	mov    %edx,%eax
+    1144:	5f                   	pop    %edi
+    1145:	5d                   	pop    %ebp
+    1146:	c3                   	ret    
+    1147:	89 f6                	mov    %esi,%esi
+    1149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001150 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    1150:	55                   	push   %ebp
+    1151:	89 e5                	mov    %esp,%ebp
+    1153:	8b 45 08             	mov    0x8(%ebp),%eax
+    1156:	53                   	push   %ebx
+    1157:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    115a:	0f b6 18             	movzbl (%eax),%ebx
+    115d:	84 db                	test   %bl,%bl
+    115f:	74 1d                	je     117e <strchr+0x2e>
+    if(*s == c)
+    1161:	38 d3                	cmp    %dl,%bl
+    1163:	89 d1                	mov    %edx,%ecx
+    1165:	75 0d                	jne    1174 <strchr+0x24>
+    1167:	eb 17                	jmp    1180 <strchr+0x30>
+    1169:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1170:	38 ca                	cmp    %cl,%dl
+    1172:	74 0c                	je     1180 <strchr+0x30>
+  for(; *s; s++)
+    1174:	83 c0 01             	add    $0x1,%eax
+    1177:	0f b6 10             	movzbl (%eax),%edx
+    117a:	84 d2                	test   %dl,%dl
+    117c:	75 f2                	jne    1170 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    117e:	31 c0                	xor    %eax,%eax
+}
+    1180:	5b                   	pop    %ebx
+    1181:	5d                   	pop    %ebp
+    1182:	c3                   	ret    
+    1183:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1189:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001190 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1190:	55                   	push   %ebp
+    1191:	89 e5                	mov    %esp,%ebp
+    1193:	57                   	push   %edi
+    1194:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1195:	31 f6                	xor    %esi,%esi
+{
+    1197:	53                   	push   %ebx
+    1198:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    119b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    119e:	eb 31                	jmp    11d1 <gets+0x41>
+    cc = read(0, &c, 1);
+    11a0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    11a7:	00 
+    11a8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    11ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    11b3:	e8 02 01 00 00       	call   12ba <read>
+    if(cc < 1)
+    11b8:	85 c0                	test   %eax,%eax
+    11ba:	7e 1d                	jle    11d9 <gets+0x49>
+      break;
+    buf[i++] = c;
+    11bc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    11c0:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    11c2:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    11c5:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    11c7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    11cb:	74 0c                	je     11d9 <gets+0x49>
+    11cd:	3c 0a                	cmp    $0xa,%al
+    11cf:	74 08                	je     11d9 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    11d1:	8d 5e 01             	lea    0x1(%esi),%ebx
+    11d4:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    11d7:	7c c7                	jl     11a0 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    11d9:	8b 45 08             	mov    0x8(%ebp),%eax
+    11dc:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    11e0:	83 c4 2c             	add    $0x2c,%esp
+    11e3:	5b                   	pop    %ebx
+    11e4:	5e                   	pop    %esi
+    11e5:	5f                   	pop    %edi
+    11e6:	5d                   	pop    %ebp
+    11e7:	c3                   	ret    
+    11e8:	90                   	nop
+    11e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000011f0 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    11f0:	55                   	push   %ebp
+    11f1:	89 e5                	mov    %esp,%ebp
+    11f3:	56                   	push   %esi
+    11f4:	53                   	push   %ebx
+    11f5:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    11f8:	8b 45 08             	mov    0x8(%ebp),%eax
+    11fb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1202:	00 
+    1203:	89 04 24             	mov    %eax,(%esp)
+    1206:	e8 d7 00 00 00       	call   12e2 <open>
+  if(fd < 0)
+    120b:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    120d:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    120f:	78 27                	js     1238 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    1211:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1214:	89 1c 24             	mov    %ebx,(%esp)
+    1217:	89 44 24 04          	mov    %eax,0x4(%esp)
+    121b:	e8 da 00 00 00       	call   12fa <fstat>
+  close(fd);
+    1220:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    1223:	89 c6                	mov    %eax,%esi
+  close(fd);
+    1225:	e8 a0 00 00 00       	call   12ca <close>
+  return r;
+    122a:	89 f0                	mov    %esi,%eax
+}
+    122c:	83 c4 10             	add    $0x10,%esp
+    122f:	5b                   	pop    %ebx
+    1230:	5e                   	pop    %esi
+    1231:	5d                   	pop    %ebp
+    1232:	c3                   	ret    
+    1233:	90                   	nop
+    1234:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    1238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    123d:	eb ed                	jmp    122c <stat+0x3c>
+    123f:	90                   	nop
+
+00001240 <atoi>:
+
+int
+atoi(const char *s)
+{
+    1240:	55                   	push   %ebp
+    1241:	89 e5                	mov    %esp,%ebp
+    1243:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    1246:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    1247:	0f be 11             	movsbl (%ecx),%edx
+    124a:	8d 42 d0             	lea    -0x30(%edx),%eax
+    124d:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    124f:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    1254:	77 17                	ja     126d <atoi+0x2d>
+    1256:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    1258:	83 c1 01             	add    $0x1,%ecx
+    125b:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    125e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1262:	0f be 11             	movsbl (%ecx),%edx
+    1265:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1268:	80 fb 09             	cmp    $0x9,%bl
+    126b:	76 eb                	jbe    1258 <atoi+0x18>
+  return n;
+}
+    126d:	5b                   	pop    %ebx
+    126e:	5d                   	pop    %ebp
+    126f:	c3                   	ret    
+
+00001270 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1270:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1271:	31 d2                	xor    %edx,%edx
+{
+    1273:	89 e5                	mov    %esp,%ebp
+    1275:	56                   	push   %esi
+    1276:	8b 45 08             	mov    0x8(%ebp),%eax
+    1279:	53                   	push   %ebx
+    127a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    127d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1280:	85 db                	test   %ebx,%ebx
+    1282:	7e 12                	jle    1296 <memmove+0x26>
+    1284:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1288:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    128c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    128f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1292:	39 da                	cmp    %ebx,%edx
+    1294:	75 f2                	jne    1288 <memmove+0x18>
+  return vdst;
+}
+    1296:	5b                   	pop    %ebx
+    1297:	5e                   	pop    %esi
+    1298:	5d                   	pop    %ebp
+    1299:	c3                   	ret    
+
+0000129a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    129a:	b8 01 00 00 00       	mov    $0x1,%eax
+    129f:	cd 40                	int    $0x40
+    12a1:	c3                   	ret    
+
+000012a2 <exit>:
+SYSCALL(exit)
+    12a2:	b8 02 00 00 00       	mov    $0x2,%eax
+    12a7:	cd 40                	int    $0x40
+    12a9:	c3                   	ret    
+
+000012aa <wait>:
+SYSCALL(wait)
+    12aa:	b8 03 00 00 00       	mov    $0x3,%eax
+    12af:	cd 40                	int    $0x40
+    12b1:	c3                   	ret    
+
+000012b2 <pipe>:
+SYSCALL(pipe)
+    12b2:	b8 04 00 00 00       	mov    $0x4,%eax
+    12b7:	cd 40                	int    $0x40
+    12b9:	c3                   	ret    
+
+000012ba <read>:
+SYSCALL(read)
+    12ba:	b8 05 00 00 00       	mov    $0x5,%eax
+    12bf:	cd 40                	int    $0x40
+    12c1:	c3                   	ret    
+
+000012c2 <write>:
+SYSCALL(write)
+    12c2:	b8 10 00 00 00       	mov    $0x10,%eax
+    12c7:	cd 40                	int    $0x40
+    12c9:	c3                   	ret    
+
+000012ca <close>:
+SYSCALL(close)
+    12ca:	b8 15 00 00 00       	mov    $0x15,%eax
+    12cf:	cd 40                	int    $0x40
+    12d1:	c3                   	ret    
+
+000012d2 <kill>:
+SYSCALL(kill)
+    12d2:	b8 06 00 00 00       	mov    $0x6,%eax
+    12d7:	cd 40                	int    $0x40
+    12d9:	c3                   	ret    
+
+000012da <exec>:
+SYSCALL(exec)
+    12da:	b8 07 00 00 00       	mov    $0x7,%eax
+    12df:	cd 40                	int    $0x40
+    12e1:	c3                   	ret    
+
+000012e2 <open>:
+SYSCALL(open)
+    12e2:	b8 0f 00 00 00       	mov    $0xf,%eax
+    12e7:	cd 40                	int    $0x40
+    12e9:	c3                   	ret    
+
+000012ea <mknod>:
+SYSCALL(mknod)
+    12ea:	b8 11 00 00 00       	mov    $0x11,%eax
+    12ef:	cd 40                	int    $0x40
+    12f1:	c3                   	ret    
+
+000012f2 <unlink>:
+SYSCALL(unlink)
+    12f2:	b8 12 00 00 00       	mov    $0x12,%eax
+    12f7:	cd 40                	int    $0x40
+    12f9:	c3                   	ret    
+
+000012fa <fstat>:
+SYSCALL(fstat)
+    12fa:	b8 08 00 00 00       	mov    $0x8,%eax
+    12ff:	cd 40                	int    $0x40
+    1301:	c3                   	ret    
+
+00001302 <link>:
+SYSCALL(link)
+    1302:	b8 13 00 00 00       	mov    $0x13,%eax
+    1307:	cd 40                	int    $0x40
+    1309:	c3                   	ret    
+
+0000130a <mkdir>:
+SYSCALL(mkdir)
+    130a:	b8 14 00 00 00       	mov    $0x14,%eax
+    130f:	cd 40                	int    $0x40
+    1311:	c3                   	ret    
+
+00001312 <chdir>:
+SYSCALL(chdir)
+    1312:	b8 09 00 00 00       	mov    $0x9,%eax
+    1317:	cd 40                	int    $0x40
+    1319:	c3                   	ret    
+
+0000131a <dup>:
+SYSCALL(dup)
+    131a:	b8 0a 00 00 00       	mov    $0xa,%eax
+    131f:	cd 40                	int    $0x40
+    1321:	c3                   	ret    
+
+00001322 <getpid>:
+SYSCALL(getpid)
+    1322:	b8 0b 00 00 00       	mov    $0xb,%eax
+    1327:	cd 40                	int    $0x40
+    1329:	c3                   	ret    
+
+0000132a <sbrk>:
+SYSCALL(sbrk)
+    132a:	b8 0c 00 00 00       	mov    $0xc,%eax
+    132f:	cd 40                	int    $0x40
+    1331:	c3                   	ret    
+
+00001332 <sleep>:
+SYSCALL(sleep)
+    1332:	b8 0d 00 00 00       	mov    $0xd,%eax
+    1337:	cd 40                	int    $0x40
+    1339:	c3                   	ret    
+
+0000133a <uptime>:
+SYSCALL(uptime)
+    133a:	b8 0e 00 00 00       	mov    $0xe,%eax
+    133f:	cd 40                	int    $0x40
+    1341:	c3                   	ret    
+
+00001342 <shm_open>:
+SYSCALL(shm_open)
+    1342:	b8 16 00 00 00       	mov    $0x16,%eax
+    1347:	cd 40                	int    $0x40
+    1349:	c3                   	ret    
+
+0000134a <shm_close>:
+SYSCALL(shm_close)	
+    134a:	b8 17 00 00 00       	mov    $0x17,%eax
+    134f:	cd 40                	int    $0x40
+    1351:	c3                   	ret    
+    1352:	66 90                	xchg   %ax,%ax
+    1354:	66 90                	xchg   %ax,%ax
+    1356:	66 90                	xchg   %ax,%ax
+    1358:	66 90                	xchg   %ax,%ax
+    135a:	66 90                	xchg   %ax,%ax
+    135c:	66 90                	xchg   %ax,%ax
+    135e:	66 90                	xchg   %ax,%ax
+
+00001360 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1360:	55                   	push   %ebp
+    1361:	89 e5                	mov    %esp,%ebp
+    1363:	57                   	push   %edi
+    1364:	56                   	push   %esi
+    1365:	89 c6                	mov    %eax,%esi
+    1367:	53                   	push   %ebx
+    1368:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    136b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    136e:	85 db                	test   %ebx,%ebx
+    1370:	74 09                	je     137b <printint+0x1b>
+    1372:	89 d0                	mov    %edx,%eax
+    1374:	c1 e8 1f             	shr    $0x1f,%eax
+    1377:	84 c0                	test   %al,%al
+    1379:	75 75                	jne    13f0 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    137b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    137d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1384:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1387:	31 ff                	xor    %edi,%edi
+    1389:	89 ce                	mov    %ecx,%esi
+    138b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    138e:	eb 02                	jmp    1392 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1390:	89 cf                	mov    %ecx,%edi
+    1392:	31 d2                	xor    %edx,%edx
+    1394:	f7 f6                	div    %esi
+    1396:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1399:	0f b6 92 d5 17 00 00 	movzbl 0x17d5(%edx),%edx
+  }while((x /= base) != 0);
+    13a0:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    13a2:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    13a5:	75 e9                	jne    1390 <printint+0x30>
+  if(neg)
+    13a7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    13aa:	89 c8                	mov    %ecx,%eax
+    13ac:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    13af:	85 d2                	test   %edx,%edx
+    13b1:	74 08                	je     13bb <printint+0x5b>
+    buf[i++] = '-';
+    13b3:	8d 4f 02             	lea    0x2(%edi),%ecx
+    13b6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    13bb:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    13be:	66 90                	xchg   %ax,%ax
+    13c0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    13c5:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    13c8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    13cf:	00 
+    13d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    13d4:	89 34 24             	mov    %esi,(%esp)
+    13d7:	88 45 d7             	mov    %al,-0x29(%ebp)
+    13da:	e8 e3 fe ff ff       	call   12c2 <write>
+  while(--i >= 0)
+    13df:	83 ff ff             	cmp    $0xffffffff,%edi
+    13e2:	75 dc                	jne    13c0 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    13e4:	83 c4 4c             	add    $0x4c,%esp
+    13e7:	5b                   	pop    %ebx
+    13e8:	5e                   	pop    %esi
+    13e9:	5f                   	pop    %edi
+    13ea:	5d                   	pop    %ebp
+    13eb:	c3                   	ret    
+    13ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    13f0:	89 d0                	mov    %edx,%eax
+    13f2:	f7 d8                	neg    %eax
+    neg = 1;
+    13f4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    13fb:	eb 87                	jmp    1384 <printint+0x24>
+    13fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+00001400 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    1400:	55                   	push   %ebp
+    1401:	89 e5                	mov    %esp,%ebp
+    1403:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    1404:	31 ff                	xor    %edi,%edi
+{
+    1406:	56                   	push   %esi
+    1407:	53                   	push   %ebx
+    1408:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    140b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    140e:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    1411:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    1414:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    1417:	0f b6 13             	movzbl (%ebx),%edx
+    141a:	83 c3 01             	add    $0x1,%ebx
+    141d:	84 d2                	test   %dl,%dl
+    141f:	75 39                	jne    145a <printf+0x5a>
+    1421:	e9 c2 00 00 00       	jmp    14e8 <printf+0xe8>
+    1426:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    1428:	83 fa 25             	cmp    $0x25,%edx
+    142b:	0f 84 bf 00 00 00    	je     14f0 <printf+0xf0>
+  write(fd, &c, 1);
+    1431:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    1434:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    143b:	00 
+    143c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1440:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    1443:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    1446:	e8 77 fe ff ff       	call   12c2 <write>
+    144b:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    144e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    1452:	84 d2                	test   %dl,%dl
+    1454:	0f 84 8e 00 00 00    	je     14e8 <printf+0xe8>
+    if(state == 0){
+    145a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    145c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    145f:	74 c7                	je     1428 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1461:	83 ff 25             	cmp    $0x25,%edi
+    1464:	75 e5                	jne    144b <printf+0x4b>
+      if(c == 'd'){
+    1466:	83 fa 64             	cmp    $0x64,%edx
+    1469:	0f 84 31 01 00 00    	je     15a0 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    146f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1474:	83 f8 70             	cmp    $0x70,%eax
+    1477:	0f 84 83 00 00 00    	je     1500 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    147d:	83 fa 73             	cmp    $0x73,%edx
+    1480:	0f 84 a2 00 00 00    	je     1528 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1486:	83 fa 63             	cmp    $0x63,%edx
+    1489:	0f 84 35 01 00 00    	je     15c4 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    148f:	83 fa 25             	cmp    $0x25,%edx
+    1492:	0f 84 e0 00 00 00    	je     1578 <printf+0x178>
+  write(fd, &c, 1);
+    1498:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    149b:	83 c3 01             	add    $0x1,%ebx
+    149e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14a5:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    14a6:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    14a8:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14ac:	89 34 24             	mov    %esi,(%esp)
+    14af:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    14b2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    14b6:	e8 07 fe ff ff       	call   12c2 <write>
+        putc(fd, c);
+    14bb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    14be:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    14c1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14c8:	00 
+    14c9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14cd:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    14d0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    14d3:	e8 ea fd ff ff       	call   12c2 <write>
+  for(i = 0; fmt[i]; i++){
+    14d8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    14dc:	84 d2                	test   %dl,%dl
+    14de:	0f 85 76 ff ff ff    	jne    145a <printf+0x5a>
+    14e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    14e8:	83 c4 3c             	add    $0x3c,%esp
+    14eb:	5b                   	pop    %ebx
+    14ec:	5e                   	pop    %esi
+    14ed:	5f                   	pop    %edi
+    14ee:	5d                   	pop    %ebp
+    14ef:	c3                   	ret    
+        state = '%';
+    14f0:	bf 25 00 00 00       	mov    $0x25,%edi
+    14f5:	e9 51 ff ff ff       	jmp    144b <printf+0x4b>
+    14fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    1500:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1503:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    1508:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    150a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1511:	8b 10                	mov    (%eax),%edx
+    1513:	89 f0                	mov    %esi,%eax
+    1515:	e8 46 fe ff ff       	call   1360 <printint>
+        ap++;
+    151a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    151e:	e9 28 ff ff ff       	jmp    144b <printf+0x4b>
+    1523:	90                   	nop
+    1524:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    1528:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    152b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    152f:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    1531:	b8 ce 17 00 00       	mov    $0x17ce,%eax
+    1536:	85 ff                	test   %edi,%edi
+    1538:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    153b:	0f b6 07             	movzbl (%edi),%eax
+    153e:	84 c0                	test   %al,%al
+    1540:	74 2a                	je     156c <printf+0x16c>
+    1542:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1548:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    154b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    154e:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    1551:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1558:	00 
+    1559:	89 44 24 04          	mov    %eax,0x4(%esp)
+    155d:	89 34 24             	mov    %esi,(%esp)
+    1560:	e8 5d fd ff ff       	call   12c2 <write>
+        while(*s != 0){
+    1565:	0f b6 07             	movzbl (%edi),%eax
+    1568:	84 c0                	test   %al,%al
+    156a:	75 dc                	jne    1548 <printf+0x148>
+      state = 0;
+    156c:	31 ff                	xor    %edi,%edi
+    156e:	e9 d8 fe ff ff       	jmp    144b <printf+0x4b>
+    1573:	90                   	nop
+    1574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1578:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    157b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    157d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1584:	00 
+    1585:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1589:	89 34 24             	mov    %esi,(%esp)
+    158c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1590:	e8 2d fd ff ff       	call   12c2 <write>
+    1595:	e9 b1 fe ff ff       	jmp    144b <printf+0x4b>
+    159a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    15a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    15a3:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    15a8:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    15ab:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    15b2:	8b 10                	mov    (%eax),%edx
+    15b4:	89 f0                	mov    %esi,%eax
+    15b6:	e8 a5 fd ff ff       	call   1360 <printint>
+        ap++;
+    15bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15bf:	e9 87 fe ff ff       	jmp    144b <printf+0x4b>
+        putc(fd, *ap);
+    15c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    15c7:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    15c9:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    15cb:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    15d2:	00 
+    15d3:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    15d6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    15d9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    15dc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15e0:	e8 dd fc ff ff       	call   12c2 <write>
+        ap++;
+    15e5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15e9:	e9 5d fe ff ff       	jmp    144b <printf+0x4b>
+    15ee:	66 90                	xchg   %ax,%ax
+
+000015f0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    15f0:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15f1:	a1 94 1a 00 00       	mov    0x1a94,%eax
+{
+    15f6:	89 e5                	mov    %esp,%ebp
+    15f8:	57                   	push   %edi
+    15f9:	56                   	push   %esi
+    15fa:	53                   	push   %ebx
+    15fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15fe:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    1600:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1603:	39 d0                	cmp    %edx,%eax
+    1605:	72 11                	jb     1618 <free+0x28>
+    1607:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1608:	39 c8                	cmp    %ecx,%eax
+    160a:	72 04                	jb     1610 <free+0x20>
+    160c:	39 ca                	cmp    %ecx,%edx
+    160e:	72 10                	jb     1620 <free+0x30>
+    1610:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1612:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1614:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1616:	73 f0                	jae    1608 <free+0x18>
+    1618:	39 ca                	cmp    %ecx,%edx
+    161a:	72 04                	jb     1620 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    161c:	39 c8                	cmp    %ecx,%eax
+    161e:	72 f0                	jb     1610 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    1620:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    1623:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    1626:	39 cf                	cmp    %ecx,%edi
+    1628:	74 1e                	je     1648 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    162a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    162d:	8b 48 04             	mov    0x4(%eax),%ecx
+    1630:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    1633:	39 f2                	cmp    %esi,%edx
+    1635:	74 28                	je     165f <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    1637:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    1639:	a3 94 1a 00 00       	mov    %eax,0x1a94
+}
+    163e:	5b                   	pop    %ebx
+    163f:	5e                   	pop    %esi
+    1640:	5f                   	pop    %edi
+    1641:	5d                   	pop    %ebp
+    1642:	c3                   	ret    
+    1643:	90                   	nop
+    1644:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    1648:	03 71 04             	add    0x4(%ecx),%esi
+    164b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    164e:	8b 08                	mov    (%eax),%ecx
+    1650:	8b 09                	mov    (%ecx),%ecx
+    1652:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    1655:	8b 48 04             	mov    0x4(%eax),%ecx
+    1658:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    165b:	39 f2                	cmp    %esi,%edx
+    165d:	75 d8                	jne    1637 <free+0x47>
+    p->s.size += bp->s.size;
+    165f:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    1662:	a3 94 1a 00 00       	mov    %eax,0x1a94
+    p->s.size += bp->s.size;
+    1667:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    166a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    166d:	89 10                	mov    %edx,(%eax)
+}
+    166f:	5b                   	pop    %ebx
+    1670:	5e                   	pop    %esi
+    1671:	5f                   	pop    %edi
+    1672:	5d                   	pop    %ebp
+    1673:	c3                   	ret    
+    1674:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    167a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001680 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1680:	55                   	push   %ebp
+    1681:	89 e5                	mov    %esp,%ebp
+    1683:	57                   	push   %edi
+    1684:	56                   	push   %esi
+    1685:	53                   	push   %ebx
+    1686:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1689:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    168c:	8b 1d 94 1a 00 00    	mov    0x1a94,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1692:	8d 48 07             	lea    0x7(%eax),%ecx
+    1695:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1698:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    169a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    169d:	0f 84 9b 00 00 00    	je     173e <malloc+0xbe>
+    16a3:	8b 13                	mov    (%ebx),%edx
+    16a5:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    16a8:	39 fe                	cmp    %edi,%esi
+    16aa:	76 64                	jbe    1710 <malloc+0x90>
+    16ac:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    16b3:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    16b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    16bb:	eb 0e                	jmp    16cb <malloc+0x4b>
+    16bd:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    16c0:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    16c2:	8b 78 04             	mov    0x4(%eax),%edi
+    16c5:	39 fe                	cmp    %edi,%esi
+    16c7:	76 4f                	jbe    1718 <malloc+0x98>
+    16c9:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    16cb:	3b 15 94 1a 00 00    	cmp    0x1a94,%edx
+    16d1:	75 ed                	jne    16c0 <malloc+0x40>
+  if(nu < 4096)
+    16d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    16d6:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    16dc:	bf 00 10 00 00       	mov    $0x1000,%edi
+    16e1:	0f 43 fe             	cmovae %esi,%edi
+    16e4:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    16e7:	89 04 24             	mov    %eax,(%esp)
+    16ea:	e8 3b fc ff ff       	call   132a <sbrk>
+  if(p == (char*)-1)
+    16ef:	83 f8 ff             	cmp    $0xffffffff,%eax
+    16f2:	74 18                	je     170c <malloc+0x8c>
+  hp->s.size = nu;
+    16f4:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    16f7:	83 c0 08             	add    $0x8,%eax
+    16fa:	89 04 24             	mov    %eax,(%esp)
+    16fd:	e8 ee fe ff ff       	call   15f0 <free>
+  return freep;
+    1702:	8b 15 94 1a 00 00    	mov    0x1a94,%edx
+      if((p = morecore(nunits)) == 0)
+    1708:	85 d2                	test   %edx,%edx
+    170a:	75 b4                	jne    16c0 <malloc+0x40>
+        return 0;
+    170c:	31 c0                	xor    %eax,%eax
+    170e:	eb 20                	jmp    1730 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    1710:	89 d0                	mov    %edx,%eax
+    1712:	89 da                	mov    %ebx,%edx
+    1714:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    1718:	39 fe                	cmp    %edi,%esi
+    171a:	74 1c                	je     1738 <malloc+0xb8>
+        p->s.size -= nunits;
+    171c:	29 f7                	sub    %esi,%edi
+    171e:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    1721:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    1724:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    1727:	89 15 94 1a 00 00    	mov    %edx,0x1a94
+      return (void*)(p + 1);
+    172d:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    1730:	83 c4 1c             	add    $0x1c,%esp
+    1733:	5b                   	pop    %ebx
+    1734:	5e                   	pop    %esi
+    1735:	5f                   	pop    %edi
+    1736:	5d                   	pop    %ebp
+    1737:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    1738:	8b 08                	mov    (%eax),%ecx
+    173a:	89 0a                	mov    %ecx,(%edx)
+    173c:	eb e9                	jmp    1727 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    173e:	c7 05 94 1a 00 00 98 	movl   $0x1a98,0x1a94
+    1745:	1a 00 00 
+    base.s.size = 0;
+    1748:	ba 98 1a 00 00       	mov    $0x1a98,%edx
+    base.s.ptr = freep = prevp = &base;
+    174d:	c7 05 98 1a 00 00 98 	movl   $0x1a98,0x1a98
+    1754:	1a 00 00 
+    base.s.size = 0;
+    1757:	c7 05 9c 1a 00 00 00 	movl   $0x0,0x1a9c
+    175e:	00 00 00 
+    1761:	e9 46 ff ff ff       	jmp    16ac <malloc+0x2c>
+    1766:	66 90                	xchg   %ax,%ax
+    1768:	66 90                	xchg   %ax,%ax
+    176a:	66 90                	xchg   %ax,%ax
+    176c:	66 90                	xchg   %ax,%ax
+    176e:	66 90                	xchg   %ax,%ax
+
+00001770 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1770:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1771:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1776:	89 e5                	mov    %esp,%ebp
+    1778:	8b 55 08             	mov    0x8(%ebp),%edx
+    177b:	90                   	nop
+    177c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1780:	89 c8                	mov    %ecx,%eax
+    1782:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1785:	85 c0                	test   %eax,%eax
+    1787:	75 f7                	jne    1780 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1789:	0f ae f0             	mfence 
+}
+    178c:	5d                   	pop    %ebp
+    178d:	c3                   	ret    
+    178e:	66 90                	xchg   %ax,%ax
+
+00001790 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1790:	55                   	push   %ebp
+    1791:	89 e5                	mov    %esp,%ebp
+    1793:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1796:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1799:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    179f:	5d                   	pop    %ebp
+    17a0:	c3                   	ret    
diff --git a/rm.c b/rm.c
index 1e6daec..4fd33c8 100644
--- a/rm.c
+++ b/rm.c
@@ -9,7 +9,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     printf(2, "Usage: rm files...\n");
-    exit(1);
+    exit();
   }
 
   for(i = 1; i < argc; i++){
@@ -19,5 +19,5 @@ main(int argc, char *argv[])
     }
   }
 
-  exit(0);
+  exit();
 }
diff --git a/rm.d b/rm.d
new file mode 100644
index 0000000..ba50b6b
--- /dev/null
+++ b/rm.d
@@ -0,0 +1 @@
+rm.o: rm.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/rm.o b/rm.o
new file mode 100644
index 0000000..29a6a43
Binary files /dev/null and b/rm.o differ
diff --git a/rm.sym b/rm.sym
new file mode 100644
index 0000000..3c09268
--- /dev/null
+++ b/rm.sym
@@ -0,0 +1,62 @@
+00001000 .text
+000017a1 .rodata
+000017e8 .eh_frame
+00001a94 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 rm.c
+00000000 ulib.c
+00000000 printf.c
+00001360 printint
+000017d5 digits.1359
+00000000 umalloc.c
+00001a94 freep
+00001a98 base
+00000000 uspinlock.c
+00001080 strcpy
+00001400 printf
+00001270 memmove
+000012ea mknod
+00001342 shm_open
+00001190 gets
+00001322 getpid
+00001680 malloc
+00001332 sleep
+000012b2 pipe
+000012c2 write
+000012fa fstat
+000012d2 kill
+00001312 chdir
+000012da exec
+000012aa wait
+000012ba read
+000012f2 unlink
+00001770 uacquire
+0000129a fork
+0000132a sbrk
+0000134a shm_close
+0000133a uptime
+00001a94 __bss_start
+00001130 memset
+00001000 main
+000010b0 strcmp
+0000131a dup
+000011f0 stat
+00001a94 _edata
+00001aa0 _end
+00001302 link
+000012a2 exit
+00001240 atoi
+00001100 strlen
+000012e2 open
+00001150 strchr
+0000130a mkdir
+000012ca close
+00001790 urelease
+000015f0 free
diff --git a/runoff b/runoff
index be362d0..26593af 100644
--- a/runoff
+++ b/runoff
@@ -14,7 +14,6 @@ pad()
 mkdir -p fmt
 rm -f fmt/*
 cp README fmt
-echo > fmt/blank
 files=`grep -v '^#' runoff.list | awk '{print $1}'`
 n=99
 for i in $files
@@ -215,9 +214,7 @@ awk '
 	# pr -t -2 t.defs | ../pr.pl -h "definitions" | pad
 	pr -t -l50 -2 refs | ../pr.pl -h "cross-references" | pad
 	# pr.pl -h "definitions" -2 t.defs | pad
-	# pr.pl -h "cross-references" -2 refs | pad
-	../pr.pl blank  # make sheet 1 start on left page
-	../pr.pl blank
+	# pr.pl -h "cross-references" -2 refs | pad 
 	for i in $files
 	do
 		../pr.pl -h "xv6/$i" $i
diff --git a/runoff.list b/runoff.list
index 2df9b81..02d1b65 100644
--- a/runoff.list
+++ b/runoff.list
@@ -7,7 +7,6 @@ x86.h
 asm.h
 mmu.h
 elf.h
-date.h
 
 # entering xv6
 entry.S
@@ -76,5 +75,3 @@ sh.c
 bootasm.S
 bootmain.c
 
-# link
-kernel.ld
diff --git a/sh.asm b/sh.asm
new file mode 100644
index 0000000..495f3ee
--- /dev/null
+++ b/sh.asm
@@ -0,0 +1,2570 @@
+
+_sh:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+  return 0;
+}
+
+int
+main(void)
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	83 e4 f0             	and    $0xfffffff0,%esp
+    1006:	83 ec 10             	sub    $0x10,%esp
+  static char buf[100];
+  int fd;
+
+  // Ensure that three file descriptors are open.
+  while((fd = open("console", O_RDWR)) >= 0){
+    1009:	eb 0e                	jmp    1019 <main+0x19>
+    100b:	90                   	nop
+    100c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    if(fd >= 3){
+    1010:	83 f8 02             	cmp    $0x2,%eax
+    1013:	0f 8f cd 00 00 00    	jg     10e6 <main+0xe6>
+  while((fd = open("console", O_RDWR)) >= 0){
+    1019:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+    1020:	00 
+    1021:	c7 04 24 85 23 00 00 	movl   $0x2385,(%esp)
+    1028:	e8 f5 0d 00 00       	call   1e22 <open>
+    102d:	85 c0                	test   %eax,%eax
+    102f:	79 df                	jns    1010 <main+0x10>
+    1031:	eb 23                	jmp    1056 <main+0x56>
+    1033:	90                   	nop
+    1034:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+
+  // Read and run input commands.
+  while(getcmd(buf, sizeof(buf)) >= 0){
+    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+    1038:	80 3d c2 29 00 00 20 	cmpb   $0x20,0x29c2
+    103f:	90                   	nop
+    1040:	74 60                	je     10a2 <main+0xa2>
+    1042:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      buf[strlen(buf)-1] = 0;  // chop \n
+      if(chdir(buf+3) < 0)
+        printf(2, "cannot cd %s\n", buf+3);
+      continue;
+    }
+    if(fork1() == 0)
+    1048:	e8 43 01 00 00       	call   1190 <fork1>
+    104d:	85 c0                	test   %eax,%eax
+    104f:	74 38                	je     1089 <main+0x89>
+      runcmd(parsecmd(buf));
+    wait();
+    1051:	e8 94 0d 00 00       	call   1dea <wait>
+  while(getcmd(buf, sizeof(buf)) >= 0){
+    1056:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
+    105d:	00 
+    105e:	c7 04 24 c0 29 00 00 	movl   $0x29c0,(%esp)
+    1065:	e8 96 00 00 00       	call   1100 <getcmd>
+    106a:	85 c0                	test   %eax,%eax
+    106c:	78 2f                	js     109d <main+0x9d>
+    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+    106e:	80 3d c0 29 00 00 63 	cmpb   $0x63,0x29c0
+    1075:	75 d1                	jne    1048 <main+0x48>
+    1077:	80 3d c1 29 00 00 64 	cmpb   $0x64,0x29c1
+    107e:	74 b8                	je     1038 <main+0x38>
+    if(fork1() == 0)
+    1080:	e8 0b 01 00 00       	call   1190 <fork1>
+    1085:	85 c0                	test   %eax,%eax
+    1087:	75 c8                	jne    1051 <main+0x51>
+      runcmd(parsecmd(buf));
+    1089:	c7 04 24 c0 29 00 00 	movl   $0x29c0,(%esp)
+    1090:	e8 ab 0a 00 00       	call   1b40 <parsecmd>
+    1095:	89 04 24             	mov    %eax,(%esp)
+    1098:	e8 13 01 00 00       	call   11b0 <runcmd>
+  }
+  exit();
+    109d:	e8 40 0d 00 00       	call   1de2 <exit>
+      buf[strlen(buf)-1] = 0;  // chop \n
+    10a2:	c7 04 24 c0 29 00 00 	movl   $0x29c0,(%esp)
+    10a9:	e8 92 0b 00 00       	call   1c40 <strlen>
+      if(chdir(buf+3) < 0)
+    10ae:	c7 04 24 c3 29 00 00 	movl   $0x29c3,(%esp)
+      buf[strlen(buf)-1] = 0;  // chop \n
+    10b5:	c6 80 bf 29 00 00 00 	movb   $0x0,0x29bf(%eax)
+      if(chdir(buf+3) < 0)
+    10bc:	e8 91 0d 00 00       	call   1e52 <chdir>
+    10c1:	85 c0                	test   %eax,%eax
+    10c3:	79 91                	jns    1056 <main+0x56>
+        printf(2, "cannot cd %s\n", buf+3);
+    10c5:	c7 44 24 08 c3 29 00 	movl   $0x29c3,0x8(%esp)
+    10cc:	00 
+    10cd:	c7 44 24 04 8d 23 00 	movl   $0x238d,0x4(%esp)
+    10d4:	00 
+    10d5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    10dc:	e8 5f 0e 00 00       	call   1f40 <printf>
+    10e1:	e9 70 ff ff ff       	jmp    1056 <main+0x56>
+      close(fd);
+    10e6:	89 04 24             	mov    %eax,(%esp)
+    10e9:	e8 1c 0d 00 00       	call   1e0a <close>
+    10ee:	66 90                	xchg   %ax,%ax
+      break;
+    10f0:	e9 61 ff ff ff       	jmp    1056 <main+0x56>
+    10f5:	66 90                	xchg   %ax,%ax
+    10f7:	66 90                	xchg   %ax,%ax
+    10f9:	66 90                	xchg   %ax,%ax
+    10fb:	66 90                	xchg   %ax,%ax
+    10fd:	66 90                	xchg   %ax,%ax
+    10ff:	90                   	nop
+
+00001100 <getcmd>:
+{
+    1100:	55                   	push   %ebp
+    1101:	89 e5                	mov    %esp,%ebp
+    1103:	56                   	push   %esi
+    1104:	53                   	push   %ebx
+    1105:	83 ec 10             	sub    $0x10,%esp
+    1108:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    110b:	8b 75 0c             	mov    0xc(%ebp),%esi
+  printf(2, "$ ");
+    110e:	c7 44 24 04 e4 22 00 	movl   $0x22e4,0x4(%esp)
+    1115:	00 
+    1116:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    111d:	e8 1e 0e 00 00       	call   1f40 <printf>
+  memset(buf, 0, nbuf);
+    1122:	89 74 24 08          	mov    %esi,0x8(%esp)
+    1126:	89 1c 24             	mov    %ebx,(%esp)
+    1129:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1130:	00 
+    1131:	e8 3a 0b 00 00       	call   1c70 <memset>
+  gets(buf, nbuf);
+    1136:	89 74 24 04          	mov    %esi,0x4(%esp)
+    113a:	89 1c 24             	mov    %ebx,(%esp)
+    113d:	e8 8e 0b 00 00       	call   1cd0 <gets>
+  if(buf[0] == 0) // EOF
+    1142:	31 c0                	xor    %eax,%eax
+    1144:	80 3b 00             	cmpb   $0x0,(%ebx)
+    1147:	0f 94 c0             	sete   %al
+}
+    114a:	83 c4 10             	add    $0x10,%esp
+    114d:	5b                   	pop    %ebx
+  if(buf[0] == 0) // EOF
+    114e:	f7 d8                	neg    %eax
+}
+    1150:	5e                   	pop    %esi
+    1151:	5d                   	pop    %ebp
+    1152:	c3                   	ret    
+    1153:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1159:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001160 <panic>:
+}
+
+void
+panic(char *s)
+{
+    1160:	55                   	push   %ebp
+    1161:	89 e5                	mov    %esp,%ebp
+    1163:	83 ec 18             	sub    $0x18,%esp
+  printf(2, "%s\n", s);
+    1166:	8b 45 08             	mov    0x8(%ebp),%eax
+    1169:	c7 44 24 04 81 23 00 	movl   $0x2381,0x4(%esp)
+    1170:	00 
+    1171:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    1178:	89 44 24 08          	mov    %eax,0x8(%esp)
+    117c:	e8 bf 0d 00 00       	call   1f40 <printf>
+  exit();
+    1181:	e8 5c 0c 00 00       	call   1de2 <exit>
+    1186:	8d 76 00             	lea    0x0(%esi),%esi
+    1189:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001190 <fork1>:
+}
+
+int
+fork1(void)
+{
+    1190:	55                   	push   %ebp
+    1191:	89 e5                	mov    %esp,%ebp
+    1193:	83 ec 18             	sub    $0x18,%esp
+  int pid;
+
+  pid = fork();
+    1196:	e8 3f 0c 00 00       	call   1dda <fork>
+  if(pid == -1)
+    119b:	83 f8 ff             	cmp    $0xffffffff,%eax
+    119e:	74 02                	je     11a2 <fork1+0x12>
+    panic("fork");
+  return pid;
+}
+    11a0:	c9                   	leave  
+    11a1:	c3                   	ret    
+    panic("fork");
+    11a2:	c7 04 24 e7 22 00 00 	movl   $0x22e7,(%esp)
+    11a9:	e8 b2 ff ff ff       	call   1160 <panic>
+    11ae:	66 90                	xchg   %ax,%ax
+
+000011b0 <runcmd>:
+{
+    11b0:	55                   	push   %ebp
+    11b1:	89 e5                	mov    %esp,%ebp
+    11b3:	53                   	push   %ebx
+    11b4:	83 ec 24             	sub    $0x24,%esp
+    11b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(cmd == 0)
+    11ba:	85 db                	test   %ebx,%ebx
+    11bc:	74 5f                	je     121d <runcmd+0x6d>
+  switch(cmd->type){
+    11be:	83 3b 05             	cmpl   $0x5,(%ebx)
+    11c1:	0f 87 e7 00 00 00    	ja     12ae <runcmd+0xfe>
+    11c7:	8b 03                	mov    (%ebx),%eax
+    11c9:	ff 24 85 9c 23 00 00 	jmp    *0x239c(,%eax,4)
+    if(pipe(p) < 0)
+    11d0:	8d 45 f0             	lea    -0x10(%ebp),%eax
+    11d3:	89 04 24             	mov    %eax,(%esp)
+    11d6:	e8 17 0c 00 00       	call   1df2 <pipe>
+    11db:	85 c0                	test   %eax,%eax
+    11dd:	0f 88 d7 00 00 00    	js     12ba <runcmd+0x10a>
+    if(fork1() == 0){
+    11e3:	e8 a8 ff ff ff       	call   1190 <fork1>
+    11e8:	85 c0                	test   %eax,%eax
+    11ea:	0f 84 2e 01 00 00    	je     131e <runcmd+0x16e>
+    if(fork1() == 0){
+    11f0:	e8 9b ff ff ff       	call   1190 <fork1>
+    11f5:	85 c0                	test   %eax,%eax
+    11f7:	0f 84 e9 00 00 00    	je     12e6 <runcmd+0x136>
+    close(p[0]);
+    11fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1200:	89 04 24             	mov    %eax,(%esp)
+    1203:	e8 02 0c 00 00       	call   1e0a <close>
+    close(p[1]);
+    1208:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    120b:	89 04 24             	mov    %eax,(%esp)
+    120e:	e8 f7 0b 00 00       	call   1e0a <close>
+    wait();
+    1213:	e8 d2 0b 00 00       	call   1dea <wait>
+    wait();
+    1218:	e8 cd 0b 00 00       	call   1dea <wait>
+    121d:	8d 76 00             	lea    0x0(%esi),%esi
+      exit();
+    1220:	e8 bd 0b 00 00       	call   1de2 <exit>
+    if(fork1() == 0)
+    1225:	e8 66 ff ff ff       	call   1190 <fork1>
+    122a:	85 c0                	test   %eax,%eax
+    122c:	75 ef                	jne    121d <runcmd+0x6d>
+    122e:	66 90                	xchg   %ax,%ax
+    1230:	eb 71                	jmp    12a3 <runcmd+0xf3>
+    if(ecmd->argv[0] == 0)
+    1232:	8b 43 04             	mov    0x4(%ebx),%eax
+    1235:	85 c0                	test   %eax,%eax
+    1237:	74 e4                	je     121d <runcmd+0x6d>
+    exec(ecmd->argv[0], ecmd->argv);
+    1239:	8d 53 04             	lea    0x4(%ebx),%edx
+    123c:	89 54 24 04          	mov    %edx,0x4(%esp)
+    1240:	89 04 24             	mov    %eax,(%esp)
+    1243:	e8 d2 0b 00 00       	call   1e1a <exec>
+    printf(2, "exec %s failed\n", ecmd->argv[0]);
+    1248:	8b 43 04             	mov    0x4(%ebx),%eax
+    124b:	c7 44 24 04 f3 22 00 	movl   $0x22f3,0x4(%esp)
+    1252:	00 
+    1253:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    125a:	89 44 24 08          	mov    %eax,0x8(%esp)
+    125e:	e8 dd 0c 00 00       	call   1f40 <printf>
+    break;
+    1263:	eb b8                	jmp    121d <runcmd+0x6d>
+    if(fork1() == 0)
+    1265:	e8 26 ff ff ff       	call   1190 <fork1>
+    126a:	85 c0                	test   %eax,%eax
+    126c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1270:	74 31                	je     12a3 <runcmd+0xf3>
+    wait();
+    1272:	e8 73 0b 00 00       	call   1dea <wait>
+    runcmd(lcmd->right);
+    1277:	8b 43 08             	mov    0x8(%ebx),%eax
+    127a:	89 04 24             	mov    %eax,(%esp)
+    127d:	e8 2e ff ff ff       	call   11b0 <runcmd>
+    close(rcmd->fd);
+    1282:	8b 43 14             	mov    0x14(%ebx),%eax
+    1285:	89 04 24             	mov    %eax,(%esp)
+    1288:	e8 7d 0b 00 00       	call   1e0a <close>
+    if(open(rcmd->file, rcmd->mode) < 0){
+    128d:	8b 43 10             	mov    0x10(%ebx),%eax
+    1290:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1294:	8b 43 08             	mov    0x8(%ebx),%eax
+    1297:	89 04 24             	mov    %eax,(%esp)
+    129a:	e8 83 0b 00 00       	call   1e22 <open>
+    129f:	85 c0                	test   %eax,%eax
+    12a1:	78 23                	js     12c6 <runcmd+0x116>
+      runcmd(bcmd->cmd);
+    12a3:	8b 43 04             	mov    0x4(%ebx),%eax
+    12a6:	89 04 24             	mov    %eax,(%esp)
+    12a9:	e8 02 ff ff ff       	call   11b0 <runcmd>
+    panic("runcmd");
+    12ae:	c7 04 24 ec 22 00 00 	movl   $0x22ec,(%esp)
+    12b5:	e8 a6 fe ff ff       	call   1160 <panic>
+      panic("pipe");
+    12ba:	c7 04 24 13 23 00 00 	movl   $0x2313,(%esp)
+    12c1:	e8 9a fe ff ff       	call   1160 <panic>
+      printf(2, "open %s failed\n", rcmd->file);
+    12c6:	8b 43 08             	mov    0x8(%ebx),%eax
+    12c9:	c7 44 24 04 03 23 00 	movl   $0x2303,0x4(%esp)
+    12d0:	00 
+    12d1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    12d8:	89 44 24 08          	mov    %eax,0x8(%esp)
+    12dc:	e8 5f 0c 00 00       	call   1f40 <printf>
+    12e1:	e9 37 ff ff ff       	jmp    121d <runcmd+0x6d>
+      close(0);
+    12e6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    12ed:	e8 18 0b 00 00       	call   1e0a <close>
+      dup(p[0]);
+    12f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    12f5:	89 04 24             	mov    %eax,(%esp)
+    12f8:	e8 5d 0b 00 00       	call   1e5a <dup>
+      close(p[0]);
+    12fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1300:	89 04 24             	mov    %eax,(%esp)
+    1303:	e8 02 0b 00 00       	call   1e0a <close>
+      close(p[1]);
+    1308:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    130b:	89 04 24             	mov    %eax,(%esp)
+    130e:	e8 f7 0a 00 00       	call   1e0a <close>
+      runcmd(pcmd->right);
+    1313:	8b 43 08             	mov    0x8(%ebx),%eax
+    1316:	89 04 24             	mov    %eax,(%esp)
+    1319:	e8 92 fe ff ff       	call   11b0 <runcmd>
+      close(1);
+    131e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1325:	e8 e0 0a 00 00       	call   1e0a <close>
+      dup(p[1]);
+    132a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    132d:	89 04 24             	mov    %eax,(%esp)
+    1330:	e8 25 0b 00 00       	call   1e5a <dup>
+      close(p[0]);
+    1335:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1338:	89 04 24             	mov    %eax,(%esp)
+    133b:	e8 ca 0a 00 00       	call   1e0a <close>
+      close(p[1]);
+    1340:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1343:	89 04 24             	mov    %eax,(%esp)
+    1346:	e8 bf 0a 00 00       	call   1e0a <close>
+      runcmd(pcmd->left);
+    134b:	8b 43 04             	mov    0x4(%ebx),%eax
+    134e:	89 04 24             	mov    %eax,(%esp)
+    1351:	e8 5a fe ff ff       	call   11b0 <runcmd>
+    1356:	8d 76 00             	lea    0x0(%esi),%esi
+    1359:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001360 <execcmd>:
+//PAGEBREAK!
+// Constructors
+
+struct cmd*
+execcmd(void)
+{
+    1360:	55                   	push   %ebp
+    1361:	89 e5                	mov    %esp,%ebp
+    1363:	53                   	push   %ebx
+    1364:	83 ec 14             	sub    $0x14,%esp
+  struct execcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+    1367:	c7 04 24 54 00 00 00 	movl   $0x54,(%esp)
+    136e:	e8 4d 0e 00 00       	call   21c0 <malloc>
+  memset(cmd, 0, sizeof(*cmd));
+    1373:	c7 44 24 08 54 00 00 	movl   $0x54,0x8(%esp)
+    137a:	00 
+    137b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1382:	00 
+  cmd = malloc(sizeof(*cmd));
+    1383:	89 c3                	mov    %eax,%ebx
+  memset(cmd, 0, sizeof(*cmd));
+    1385:	89 04 24             	mov    %eax,(%esp)
+    1388:	e8 e3 08 00 00       	call   1c70 <memset>
+  cmd->type = EXEC;
+  return (struct cmd*)cmd;
+}
+    138d:	89 d8                	mov    %ebx,%eax
+  cmd->type = EXEC;
+    138f:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
+}
+    1395:	83 c4 14             	add    $0x14,%esp
+    1398:	5b                   	pop    %ebx
+    1399:	5d                   	pop    %ebp
+    139a:	c3                   	ret    
+    139b:	90                   	nop
+    139c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000013a0 <redircmd>:
+
+struct cmd*
+redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
+{
+    13a0:	55                   	push   %ebp
+    13a1:	89 e5                	mov    %esp,%ebp
+    13a3:	53                   	push   %ebx
+    13a4:	83 ec 14             	sub    $0x14,%esp
+  struct redircmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+    13a7:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
+    13ae:	e8 0d 0e 00 00       	call   21c0 <malloc>
+  memset(cmd, 0, sizeof(*cmd));
+    13b3:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
+    13ba:	00 
+    13bb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    13c2:	00 
+    13c3:	89 04 24             	mov    %eax,(%esp)
+  cmd = malloc(sizeof(*cmd));
+    13c6:	89 c3                	mov    %eax,%ebx
+  memset(cmd, 0, sizeof(*cmd));
+    13c8:	e8 a3 08 00 00       	call   1c70 <memset>
+  cmd->type = REDIR;
+  cmd->cmd = subcmd;
+    13cd:	8b 45 08             	mov    0x8(%ebp),%eax
+  cmd->type = REDIR;
+    13d0:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
+  cmd->cmd = subcmd;
+    13d6:	89 43 04             	mov    %eax,0x4(%ebx)
+  cmd->file = file;
+    13d9:	8b 45 0c             	mov    0xc(%ebp),%eax
+    13dc:	89 43 08             	mov    %eax,0x8(%ebx)
+  cmd->efile = efile;
+    13df:	8b 45 10             	mov    0x10(%ebp),%eax
+    13e2:	89 43 0c             	mov    %eax,0xc(%ebx)
+  cmd->mode = mode;
+    13e5:	8b 45 14             	mov    0x14(%ebp),%eax
+    13e8:	89 43 10             	mov    %eax,0x10(%ebx)
+  cmd->fd = fd;
+    13eb:	8b 45 18             	mov    0x18(%ebp),%eax
+    13ee:	89 43 14             	mov    %eax,0x14(%ebx)
+  return (struct cmd*)cmd;
+}
+    13f1:	83 c4 14             	add    $0x14,%esp
+    13f4:	89 d8                	mov    %ebx,%eax
+    13f6:	5b                   	pop    %ebx
+    13f7:	5d                   	pop    %ebp
+    13f8:	c3                   	ret    
+    13f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001400 <pipecmd>:
+
+struct cmd*
+pipecmd(struct cmd *left, struct cmd *right)
+{
+    1400:	55                   	push   %ebp
+    1401:	89 e5                	mov    %esp,%ebp
+    1403:	53                   	push   %ebx
+    1404:	83 ec 14             	sub    $0x14,%esp
+  struct pipecmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+    1407:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
+    140e:	e8 ad 0d 00 00       	call   21c0 <malloc>
+  memset(cmd, 0, sizeof(*cmd));
+    1413:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp)
+    141a:	00 
+    141b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1422:	00 
+    1423:	89 04 24             	mov    %eax,(%esp)
+  cmd = malloc(sizeof(*cmd));
+    1426:	89 c3                	mov    %eax,%ebx
+  memset(cmd, 0, sizeof(*cmd));
+    1428:	e8 43 08 00 00       	call   1c70 <memset>
+  cmd->type = PIPE;
+  cmd->left = left;
+    142d:	8b 45 08             	mov    0x8(%ebp),%eax
+  cmd->type = PIPE;
+    1430:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
+  cmd->left = left;
+    1436:	89 43 04             	mov    %eax,0x4(%ebx)
+  cmd->right = right;
+    1439:	8b 45 0c             	mov    0xc(%ebp),%eax
+    143c:	89 43 08             	mov    %eax,0x8(%ebx)
+  return (struct cmd*)cmd;
+}
+    143f:	83 c4 14             	add    $0x14,%esp
+    1442:	89 d8                	mov    %ebx,%eax
+    1444:	5b                   	pop    %ebx
+    1445:	5d                   	pop    %ebp
+    1446:	c3                   	ret    
+    1447:	89 f6                	mov    %esi,%esi
+    1449:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001450 <listcmd>:
+
+struct cmd*
+listcmd(struct cmd *left, struct cmd *right)
+{
+    1450:	55                   	push   %ebp
+    1451:	89 e5                	mov    %esp,%ebp
+    1453:	53                   	push   %ebx
+    1454:	83 ec 14             	sub    $0x14,%esp
+  struct listcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+    1457:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
+    145e:	e8 5d 0d 00 00       	call   21c0 <malloc>
+  memset(cmd, 0, sizeof(*cmd));
+    1463:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp)
+    146a:	00 
+    146b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1472:	00 
+    1473:	89 04 24             	mov    %eax,(%esp)
+  cmd = malloc(sizeof(*cmd));
+    1476:	89 c3                	mov    %eax,%ebx
+  memset(cmd, 0, sizeof(*cmd));
+    1478:	e8 f3 07 00 00       	call   1c70 <memset>
+  cmd->type = LIST;
+  cmd->left = left;
+    147d:	8b 45 08             	mov    0x8(%ebp),%eax
+  cmd->type = LIST;
+    1480:	c7 03 04 00 00 00    	movl   $0x4,(%ebx)
+  cmd->left = left;
+    1486:	89 43 04             	mov    %eax,0x4(%ebx)
+  cmd->right = right;
+    1489:	8b 45 0c             	mov    0xc(%ebp),%eax
+    148c:	89 43 08             	mov    %eax,0x8(%ebx)
+  return (struct cmd*)cmd;
+}
+    148f:	83 c4 14             	add    $0x14,%esp
+    1492:	89 d8                	mov    %ebx,%eax
+    1494:	5b                   	pop    %ebx
+    1495:	5d                   	pop    %ebp
+    1496:	c3                   	ret    
+    1497:	89 f6                	mov    %esi,%esi
+    1499:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+000014a0 <backcmd>:
+
+struct cmd*
+backcmd(struct cmd *subcmd)
+{
+    14a0:	55                   	push   %ebp
+    14a1:	89 e5                	mov    %esp,%ebp
+    14a3:	53                   	push   %ebx
+    14a4:	83 ec 14             	sub    $0x14,%esp
+  struct backcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+    14a7:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+    14ae:	e8 0d 0d 00 00       	call   21c0 <malloc>
+  memset(cmd, 0, sizeof(*cmd));
+    14b3:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
+    14ba:	00 
+    14bb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    14c2:	00 
+    14c3:	89 04 24             	mov    %eax,(%esp)
+  cmd = malloc(sizeof(*cmd));
+    14c6:	89 c3                	mov    %eax,%ebx
+  memset(cmd, 0, sizeof(*cmd));
+    14c8:	e8 a3 07 00 00       	call   1c70 <memset>
+  cmd->type = BACK;
+  cmd->cmd = subcmd;
+    14cd:	8b 45 08             	mov    0x8(%ebp),%eax
+  cmd->type = BACK;
+    14d0:	c7 03 05 00 00 00    	movl   $0x5,(%ebx)
+  cmd->cmd = subcmd;
+    14d6:	89 43 04             	mov    %eax,0x4(%ebx)
+  return (struct cmd*)cmd;
+}
+    14d9:	83 c4 14             	add    $0x14,%esp
+    14dc:	89 d8                	mov    %ebx,%eax
+    14de:	5b                   	pop    %ebx
+    14df:	5d                   	pop    %ebp
+    14e0:	c3                   	ret    
+    14e1:	eb 0d                	jmp    14f0 <gettoken>
+    14e3:	90                   	nop
+    14e4:	90                   	nop
+    14e5:	90                   	nop
+    14e6:	90                   	nop
+    14e7:	90                   	nop
+    14e8:	90                   	nop
+    14e9:	90                   	nop
+    14ea:	90                   	nop
+    14eb:	90                   	nop
+    14ec:	90                   	nop
+    14ed:	90                   	nop
+    14ee:	90                   	nop
+    14ef:	90                   	nop
+
+000014f0 <gettoken>:
+char whitespace[] = " \t\r\n\v";
+char symbols[] = "<|>&;()";
+
+int
+gettoken(char **ps, char *es, char **q, char **eq)
+{
+    14f0:	55                   	push   %ebp
+    14f1:	89 e5                	mov    %esp,%ebp
+    14f3:	57                   	push   %edi
+    14f4:	56                   	push   %esi
+    14f5:	53                   	push   %ebx
+    14f6:	83 ec 1c             	sub    $0x1c,%esp
+  char *s;
+  int ret;
+
+  s = *ps;
+    14f9:	8b 45 08             	mov    0x8(%ebp),%eax
+{
+    14fc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+    14ff:	8b 75 10             	mov    0x10(%ebp),%esi
+  s = *ps;
+    1502:	8b 38                	mov    (%eax),%edi
+  while(s < es && strchr(whitespace, *s))
+    1504:	39 df                	cmp    %ebx,%edi
+    1506:	72 0f                	jb     1517 <gettoken+0x27>
+    1508:	eb 24                	jmp    152e <gettoken+0x3e>
+    150a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    s++;
+    1510:	83 c7 01             	add    $0x1,%edi
+  while(s < es && strchr(whitespace, *s))
+    1513:	39 df                	cmp    %ebx,%edi
+    1515:	74 17                	je     152e <gettoken+0x3e>
+    1517:	0f be 07             	movsbl (%edi),%eax
+    151a:	c7 04 24 ac 29 00 00 	movl   $0x29ac,(%esp)
+    1521:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1525:	e8 66 07 00 00       	call   1c90 <strchr>
+    152a:	85 c0                	test   %eax,%eax
+    152c:	75 e2                	jne    1510 <gettoken+0x20>
+  if(q)
+    152e:	85 f6                	test   %esi,%esi
+    1530:	74 02                	je     1534 <gettoken+0x44>
+    *q = s;
+    1532:	89 3e                	mov    %edi,(%esi)
+  ret = *s;
+    1534:	0f b6 0f             	movzbl (%edi),%ecx
+    1537:	0f be f1             	movsbl %cl,%esi
+  switch(*s){
+    153a:	80 f9 29             	cmp    $0x29,%cl
+  ret = *s;
+    153d:	89 f0                	mov    %esi,%eax
+  switch(*s){
+    153f:	7f 4f                	jg     1590 <gettoken+0xa0>
+    1541:	80 f9 28             	cmp    $0x28,%cl
+    1544:	7d 55                	jge    159b <gettoken+0xab>
+    1546:	84 c9                	test   %cl,%cl
+    1548:	0f 85 ca 00 00 00    	jne    1618 <gettoken+0x128>
+    ret = 'a';
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+      s++;
+    break;
+  }
+  if(eq)
+    154e:	8b 45 14             	mov    0x14(%ebp),%eax
+    1551:	85 c0                	test   %eax,%eax
+    1553:	74 05                	je     155a <gettoken+0x6a>
+    *eq = s;
+    1555:	8b 45 14             	mov    0x14(%ebp),%eax
+    1558:	89 38                	mov    %edi,(%eax)
+
+  while(s < es && strchr(whitespace, *s))
+    155a:	39 df                	cmp    %ebx,%edi
+    155c:	72 09                	jb     1567 <gettoken+0x77>
+    155e:	eb 1e                	jmp    157e <gettoken+0x8e>
+    s++;
+    1560:	83 c7 01             	add    $0x1,%edi
+  while(s < es && strchr(whitespace, *s))
+    1563:	39 df                	cmp    %ebx,%edi
+    1565:	74 17                	je     157e <gettoken+0x8e>
+    1567:	0f be 07             	movsbl (%edi),%eax
+    156a:	c7 04 24 ac 29 00 00 	movl   $0x29ac,(%esp)
+    1571:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1575:	e8 16 07 00 00       	call   1c90 <strchr>
+    157a:	85 c0                	test   %eax,%eax
+    157c:	75 e2                	jne    1560 <gettoken+0x70>
+  *ps = s;
+    157e:	8b 45 08             	mov    0x8(%ebp),%eax
+    1581:	89 38                	mov    %edi,(%eax)
+  return ret;
+}
+    1583:	83 c4 1c             	add    $0x1c,%esp
+    1586:	89 f0                	mov    %esi,%eax
+    1588:	5b                   	pop    %ebx
+    1589:	5e                   	pop    %esi
+    158a:	5f                   	pop    %edi
+    158b:	5d                   	pop    %ebp
+    158c:	c3                   	ret    
+    158d:	8d 76 00             	lea    0x0(%esi),%esi
+  switch(*s){
+    1590:	80 f9 3e             	cmp    $0x3e,%cl
+    1593:	75 0b                	jne    15a0 <gettoken+0xb0>
+    if(*s == '>'){
+    1595:	80 7f 01 3e          	cmpb   $0x3e,0x1(%edi)
+    1599:	74 6d                	je     1608 <gettoken+0x118>
+    s++;
+    159b:	83 c7 01             	add    $0x1,%edi
+    159e:	eb ae                	jmp    154e <gettoken+0x5e>
+  switch(*s){
+    15a0:	7f 56                	jg     15f8 <gettoken+0x108>
+    15a2:	83 e9 3b             	sub    $0x3b,%ecx
+    15a5:	80 f9 01             	cmp    $0x1,%cl
+    15a8:	76 f1                	jbe    159b <gettoken+0xab>
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+    15aa:	39 fb                	cmp    %edi,%ebx
+    15ac:	77 2b                	ja     15d9 <gettoken+0xe9>
+    15ae:	66 90                	xchg   %ax,%ax
+    15b0:	eb 3b                	jmp    15ed <gettoken+0xfd>
+    15b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    15b8:	0f be 07             	movsbl (%edi),%eax
+    15bb:	c7 04 24 a4 29 00 00 	movl   $0x29a4,(%esp)
+    15c2:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15c6:	e8 c5 06 00 00       	call   1c90 <strchr>
+    15cb:	85 c0                	test   %eax,%eax
+    15cd:	75 1e                	jne    15ed <gettoken+0xfd>
+      s++;
+    15cf:	83 c7 01             	add    $0x1,%edi
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+    15d2:	39 df                	cmp    %ebx,%edi
+    15d4:	74 17                	je     15ed <gettoken+0xfd>
+    15d6:	0f be 07             	movsbl (%edi),%eax
+    15d9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15dd:	c7 04 24 ac 29 00 00 	movl   $0x29ac,(%esp)
+    15e4:	e8 a7 06 00 00       	call   1c90 <strchr>
+    15e9:	85 c0                	test   %eax,%eax
+    15eb:	74 cb                	je     15b8 <gettoken+0xc8>
+    ret = 'a';
+    15ed:	be 61 00 00 00       	mov    $0x61,%esi
+    15f2:	e9 57 ff ff ff       	jmp    154e <gettoken+0x5e>
+    15f7:	90                   	nop
+  switch(*s){
+    15f8:	80 f9 7c             	cmp    $0x7c,%cl
+    15fb:	74 9e                	je     159b <gettoken+0xab>
+    15fd:	8d 76 00             	lea    0x0(%esi),%esi
+    1600:	eb a8                	jmp    15aa <gettoken+0xba>
+    1602:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      s++;
+    1608:	83 c7 02             	add    $0x2,%edi
+      ret = '+';
+    160b:	be 2b 00 00 00       	mov    $0x2b,%esi
+    1610:	e9 39 ff ff ff       	jmp    154e <gettoken+0x5e>
+    1615:	8d 76 00             	lea    0x0(%esi),%esi
+  switch(*s){
+    1618:	80 f9 26             	cmp    $0x26,%cl
+    161b:	75 8d                	jne    15aa <gettoken+0xba>
+    161d:	e9 79 ff ff ff       	jmp    159b <gettoken+0xab>
+    1622:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1629:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001630 <peek>:
+
+int
+peek(char **ps, char *es, char *toks)
+{
+    1630:	55                   	push   %ebp
+    1631:	89 e5                	mov    %esp,%ebp
+    1633:	57                   	push   %edi
+    1634:	56                   	push   %esi
+    1635:	53                   	push   %ebx
+    1636:	83 ec 1c             	sub    $0x1c,%esp
+    1639:	8b 7d 08             	mov    0x8(%ebp),%edi
+    163c:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *s;
+
+  s = *ps;
+    163f:	8b 1f                	mov    (%edi),%ebx
+  while(s < es && strchr(whitespace, *s))
+    1641:	39 f3                	cmp    %esi,%ebx
+    1643:	72 0a                	jb     164f <peek+0x1f>
+    1645:	eb 1f                	jmp    1666 <peek+0x36>
+    1647:	90                   	nop
+    s++;
+    1648:	83 c3 01             	add    $0x1,%ebx
+  while(s < es && strchr(whitespace, *s))
+    164b:	39 f3                	cmp    %esi,%ebx
+    164d:	74 17                	je     1666 <peek+0x36>
+    164f:	0f be 03             	movsbl (%ebx),%eax
+    1652:	c7 04 24 ac 29 00 00 	movl   $0x29ac,(%esp)
+    1659:	89 44 24 04          	mov    %eax,0x4(%esp)
+    165d:	e8 2e 06 00 00       	call   1c90 <strchr>
+    1662:	85 c0                	test   %eax,%eax
+    1664:	75 e2                	jne    1648 <peek+0x18>
+  *ps = s;
+    1666:	89 1f                	mov    %ebx,(%edi)
+  return *s && strchr(toks, *s);
+    1668:	0f be 13             	movsbl (%ebx),%edx
+    166b:	31 c0                	xor    %eax,%eax
+    166d:	84 d2                	test   %dl,%dl
+    166f:	74 17                	je     1688 <peek+0x58>
+    1671:	8b 45 10             	mov    0x10(%ebp),%eax
+    1674:	89 54 24 04          	mov    %edx,0x4(%esp)
+    1678:	89 04 24             	mov    %eax,(%esp)
+    167b:	e8 10 06 00 00       	call   1c90 <strchr>
+    1680:	85 c0                	test   %eax,%eax
+    1682:	0f 95 c0             	setne  %al
+    1685:	0f b6 c0             	movzbl %al,%eax
+}
+    1688:	83 c4 1c             	add    $0x1c,%esp
+    168b:	5b                   	pop    %ebx
+    168c:	5e                   	pop    %esi
+    168d:	5f                   	pop    %edi
+    168e:	5d                   	pop    %ebp
+    168f:	c3                   	ret    
+
+00001690 <parseredirs>:
+  return cmd;
+}
+
+struct cmd*
+parseredirs(struct cmd *cmd, char **ps, char *es)
+{
+    1690:	55                   	push   %ebp
+    1691:	89 e5                	mov    %esp,%ebp
+    1693:	57                   	push   %edi
+    1694:	56                   	push   %esi
+    1695:	53                   	push   %ebx
+    1696:	83 ec 3c             	sub    $0x3c,%esp
+    1699:	8b 75 0c             	mov    0xc(%ebp),%esi
+    169c:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    169f:	90                   	nop
+  int tok;
+  char *q, *eq;
+
+  while(peek(ps, es, "<>")){
+    16a0:	c7 44 24 08 35 23 00 	movl   $0x2335,0x8(%esp)
+    16a7:	00 
+    16a8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    16ac:	89 34 24             	mov    %esi,(%esp)
+    16af:	e8 7c ff ff ff       	call   1630 <peek>
+    16b4:	85 c0                	test   %eax,%eax
+    16b6:	0f 84 9c 00 00 00    	je     1758 <parseredirs+0xc8>
+    tok = gettoken(ps, es, 0, 0);
+    16bc:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+    16c3:	00 
+    16c4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+    16cb:	00 
+    16cc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    16d0:	89 34 24             	mov    %esi,(%esp)
+    16d3:	e8 18 fe ff ff       	call   14f0 <gettoken>
+    if(gettoken(ps, es, &q, &eq) != 'a')
+    16d8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    16dc:	89 34 24             	mov    %esi,(%esp)
+    tok = gettoken(ps, es, 0, 0);
+    16df:	89 c7                	mov    %eax,%edi
+    if(gettoken(ps, es, &q, &eq) != 'a')
+    16e1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    16e4:	89 44 24 0c          	mov    %eax,0xc(%esp)
+    16e8:	8d 45 e0             	lea    -0x20(%ebp),%eax
+    16eb:	89 44 24 08          	mov    %eax,0x8(%esp)
+    16ef:	e8 fc fd ff ff       	call   14f0 <gettoken>
+    16f4:	83 f8 61             	cmp    $0x61,%eax
+    16f7:	75 6a                	jne    1763 <parseredirs+0xd3>
+      panic("missing file for redirection");
+    switch(tok){
+    16f9:	83 ff 3c             	cmp    $0x3c,%edi
+    16fc:	74 42                	je     1740 <parseredirs+0xb0>
+    16fe:	83 ff 3e             	cmp    $0x3e,%edi
+    1701:	74 05                	je     1708 <parseredirs+0x78>
+    1703:	83 ff 2b             	cmp    $0x2b,%edi
+    1706:	75 98                	jne    16a0 <parseredirs+0x10>
+      break;
+    case '>':
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+      break;
+    case '+':  // >>
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+    1708:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
+    170f:	00 
+    1710:	c7 44 24 0c 01 02 00 	movl   $0x201,0xc(%esp)
+    1717:	00 
+    1718:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    171b:	89 44 24 08          	mov    %eax,0x8(%esp)
+    171f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+    1722:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1726:	8b 45 08             	mov    0x8(%ebp),%eax
+    1729:	89 04 24             	mov    %eax,(%esp)
+    172c:	e8 6f fc ff ff       	call   13a0 <redircmd>
+    1731:	89 45 08             	mov    %eax,0x8(%ebp)
+      break;
+    1734:	e9 67 ff ff ff       	jmp    16a0 <parseredirs+0x10>
+    1739:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
+    1740:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+    1747:	00 
+    1748:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+    174f:	00 
+    1750:	eb c6                	jmp    1718 <parseredirs+0x88>
+    1752:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    }
+  }
+  return cmd;
+}
+    1758:	8b 45 08             	mov    0x8(%ebp),%eax
+    175b:	83 c4 3c             	add    $0x3c,%esp
+    175e:	5b                   	pop    %ebx
+    175f:	5e                   	pop    %esi
+    1760:	5f                   	pop    %edi
+    1761:	5d                   	pop    %ebp
+    1762:	c3                   	ret    
+      panic("missing file for redirection");
+    1763:	c7 04 24 18 23 00 00 	movl   $0x2318,(%esp)
+    176a:	e8 f1 f9 ff ff       	call   1160 <panic>
+    176f:	90                   	nop
+
+00001770 <parseexec>:
+  return cmd;
+}
+
+struct cmd*
+parseexec(char **ps, char *es)
+{
+    1770:	55                   	push   %ebp
+    1771:	89 e5                	mov    %esp,%ebp
+    1773:	57                   	push   %edi
+    1774:	56                   	push   %esi
+    1775:	53                   	push   %ebx
+    1776:	83 ec 3c             	sub    $0x3c,%esp
+    1779:	8b 75 08             	mov    0x8(%ebp),%esi
+    177c:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  char *q, *eq;
+  int tok, argc;
+  struct execcmd *cmd;
+  struct cmd *ret;
+
+  if(peek(ps, es, "("))
+    177f:	c7 44 24 08 38 23 00 	movl   $0x2338,0x8(%esp)
+    1786:	00 
+    1787:	89 34 24             	mov    %esi,(%esp)
+    178a:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    178e:	e8 9d fe ff ff       	call   1630 <peek>
+    1793:	85 c0                	test   %eax,%eax
+    1795:	0f 85 a5 00 00 00    	jne    1840 <parseexec+0xd0>
+    return parseblock(ps, es);
+
+  ret = execcmd();
+    179b:	e8 c0 fb ff ff       	call   1360 <execcmd>
+  cmd = (struct execcmd*)ret;
+
+  argc = 0;
+  ret = parseredirs(ret, ps, es);
+    17a0:	89 7c 24 08          	mov    %edi,0x8(%esp)
+    17a4:	89 74 24 04          	mov    %esi,0x4(%esp)
+    17a8:	89 04 24             	mov    %eax,(%esp)
+  ret = execcmd();
+    17ab:	89 c3                	mov    %eax,%ebx
+    17ad:	89 45 cc             	mov    %eax,-0x34(%ebp)
+  ret = parseredirs(ret, ps, es);
+    17b0:	e8 db fe ff ff       	call   1690 <parseredirs>
+  argc = 0;
+    17b5:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+  ret = parseredirs(ret, ps, es);
+    17bc:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  while(!peek(ps, es, "|)&;")){
+    17bf:	eb 1d                	jmp    17de <parseexec+0x6e>
+    17c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    cmd->argv[argc] = q;
+    cmd->eargv[argc] = eq;
+    argc++;
+    if(argc >= MAXARGS)
+      panic("too many args");
+    ret = parseredirs(ret, ps, es);
+    17c8:	8b 45 d0             	mov    -0x30(%ebp),%eax
+    17cb:	89 7c 24 08          	mov    %edi,0x8(%esp)
+    17cf:	89 74 24 04          	mov    %esi,0x4(%esp)
+    17d3:	89 04 24             	mov    %eax,(%esp)
+    17d6:	e8 b5 fe ff ff       	call   1690 <parseredirs>
+    17db:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  while(!peek(ps, es, "|)&;")){
+    17de:	c7 44 24 08 4f 23 00 	movl   $0x234f,0x8(%esp)
+    17e5:	00 
+    17e6:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    17ea:	89 34 24             	mov    %esi,(%esp)
+    17ed:	e8 3e fe ff ff       	call   1630 <peek>
+    17f2:	85 c0                	test   %eax,%eax
+    17f4:	75 62                	jne    1858 <parseexec+0xe8>
+    if((tok=gettoken(ps, es, &q, &eq)) == 0)
+    17f6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    17f9:	89 44 24 0c          	mov    %eax,0xc(%esp)
+    17fd:	8d 45 e0             	lea    -0x20(%ebp),%eax
+    1800:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1804:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    1808:	89 34 24             	mov    %esi,(%esp)
+    180b:	e8 e0 fc ff ff       	call   14f0 <gettoken>
+    1810:	85 c0                	test   %eax,%eax
+    1812:	74 44                	je     1858 <parseexec+0xe8>
+    if(tok != 'a')
+    1814:	83 f8 61             	cmp    $0x61,%eax
+    1817:	75 61                	jne    187a <parseexec+0x10a>
+    cmd->argv[argc] = q;
+    1819:	8b 45 e0             	mov    -0x20(%ebp),%eax
+    181c:	83 c3 04             	add    $0x4,%ebx
+    argc++;
+    181f:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
+    cmd->argv[argc] = q;
+    1823:	89 03                	mov    %eax,(%ebx)
+    cmd->eargv[argc] = eq;
+    1825:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1828:	89 43 28             	mov    %eax,0x28(%ebx)
+    if(argc >= MAXARGS)
+    182b:	83 7d d4 0a          	cmpl   $0xa,-0x2c(%ebp)
+    182f:	75 97                	jne    17c8 <parseexec+0x58>
+      panic("too many args");
+    1831:	c7 04 24 41 23 00 00 	movl   $0x2341,(%esp)
+    1838:	e8 23 f9 ff ff       	call   1160 <panic>
+    183d:	8d 76 00             	lea    0x0(%esi),%esi
+    return parseblock(ps, es);
+    1840:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    1844:	89 34 24             	mov    %esi,(%esp)
+    1847:	e8 84 01 00 00       	call   19d0 <parseblock>
+  }
+  cmd->argv[argc] = 0;
+  cmd->eargv[argc] = 0;
+  return ret;
+}
+    184c:	83 c4 3c             	add    $0x3c,%esp
+    184f:	5b                   	pop    %ebx
+    1850:	5e                   	pop    %esi
+    1851:	5f                   	pop    %edi
+    1852:	5d                   	pop    %ebp
+    1853:	c3                   	ret    
+    1854:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1858:	8b 45 cc             	mov    -0x34(%ebp),%eax
+    185b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+    185e:	8d 04 90             	lea    (%eax,%edx,4),%eax
+  cmd->argv[argc] = 0;
+    1861:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+  cmd->eargv[argc] = 0;
+    1868:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
+  return ret;
+    186f:	8b 45 d0             	mov    -0x30(%ebp),%eax
+}
+    1872:	83 c4 3c             	add    $0x3c,%esp
+    1875:	5b                   	pop    %ebx
+    1876:	5e                   	pop    %esi
+    1877:	5f                   	pop    %edi
+    1878:	5d                   	pop    %ebp
+    1879:	c3                   	ret    
+      panic("syntax");
+    187a:	c7 04 24 3a 23 00 00 	movl   $0x233a,(%esp)
+    1881:	e8 da f8 ff ff       	call   1160 <panic>
+    1886:	8d 76 00             	lea    0x0(%esi),%esi
+    1889:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001890 <parsepipe>:
+{
+    1890:	55                   	push   %ebp
+    1891:	89 e5                	mov    %esp,%ebp
+    1893:	57                   	push   %edi
+    1894:	56                   	push   %esi
+    1895:	53                   	push   %ebx
+    1896:	83 ec 1c             	sub    $0x1c,%esp
+    1899:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    189c:	8b 75 0c             	mov    0xc(%ebp),%esi
+  cmd = parseexec(ps, es);
+    189f:	89 1c 24             	mov    %ebx,(%esp)
+    18a2:	89 74 24 04          	mov    %esi,0x4(%esp)
+    18a6:	e8 c5 fe ff ff       	call   1770 <parseexec>
+  if(peek(ps, es, "|")){
+    18ab:	c7 44 24 08 54 23 00 	movl   $0x2354,0x8(%esp)
+    18b2:	00 
+    18b3:	89 74 24 04          	mov    %esi,0x4(%esp)
+    18b7:	89 1c 24             	mov    %ebx,(%esp)
+  cmd = parseexec(ps, es);
+    18ba:	89 c7                	mov    %eax,%edi
+  if(peek(ps, es, "|")){
+    18bc:	e8 6f fd ff ff       	call   1630 <peek>
+    18c1:	85 c0                	test   %eax,%eax
+    18c3:	75 0b                	jne    18d0 <parsepipe+0x40>
+}
+    18c5:	83 c4 1c             	add    $0x1c,%esp
+    18c8:	89 f8                	mov    %edi,%eax
+    18ca:	5b                   	pop    %ebx
+    18cb:	5e                   	pop    %esi
+    18cc:	5f                   	pop    %edi
+    18cd:	5d                   	pop    %ebp
+    18ce:	c3                   	ret    
+    18cf:	90                   	nop
+    gettoken(ps, es, 0, 0);
+    18d0:	89 74 24 04          	mov    %esi,0x4(%esp)
+    18d4:	89 1c 24             	mov    %ebx,(%esp)
+    18d7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+    18de:	00 
+    18df:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+    18e6:	00 
+    18e7:	e8 04 fc ff ff       	call   14f0 <gettoken>
+    cmd = pipecmd(cmd, parsepipe(ps, es));
+    18ec:	89 74 24 04          	mov    %esi,0x4(%esp)
+    18f0:	89 1c 24             	mov    %ebx,(%esp)
+    18f3:	e8 98 ff ff ff       	call   1890 <parsepipe>
+    18f8:	89 7d 08             	mov    %edi,0x8(%ebp)
+    18fb:	89 45 0c             	mov    %eax,0xc(%ebp)
+}
+    18fe:	83 c4 1c             	add    $0x1c,%esp
+    1901:	5b                   	pop    %ebx
+    1902:	5e                   	pop    %esi
+    1903:	5f                   	pop    %edi
+    1904:	5d                   	pop    %ebp
+    cmd = pipecmd(cmd, parsepipe(ps, es));
+    1905:	e9 f6 fa ff ff       	jmp    1400 <pipecmd>
+    190a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001910 <parseline>:
+{
+    1910:	55                   	push   %ebp
+    1911:	89 e5                	mov    %esp,%ebp
+    1913:	57                   	push   %edi
+    1914:	56                   	push   %esi
+    1915:	53                   	push   %ebx
+    1916:	83 ec 1c             	sub    $0x1c,%esp
+    1919:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    191c:	8b 75 0c             	mov    0xc(%ebp),%esi
+  cmd = parsepipe(ps, es);
+    191f:	89 1c 24             	mov    %ebx,(%esp)
+    1922:	89 74 24 04          	mov    %esi,0x4(%esp)
+    1926:	e8 65 ff ff ff       	call   1890 <parsepipe>
+    192b:	89 c7                	mov    %eax,%edi
+  while(peek(ps, es, "&")){
+    192d:	eb 27                	jmp    1956 <parseline+0x46>
+    192f:	90                   	nop
+    gettoken(ps, es, 0, 0);
+    1930:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+    1937:	00 
+    1938:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+    193f:	00 
+    1940:	89 74 24 04          	mov    %esi,0x4(%esp)
+    1944:	89 1c 24             	mov    %ebx,(%esp)
+    1947:	e8 a4 fb ff ff       	call   14f0 <gettoken>
+    cmd = backcmd(cmd);
+    194c:	89 3c 24             	mov    %edi,(%esp)
+    194f:	e8 4c fb ff ff       	call   14a0 <backcmd>
+    1954:	89 c7                	mov    %eax,%edi
+  while(peek(ps, es, "&")){
+    1956:	c7 44 24 08 56 23 00 	movl   $0x2356,0x8(%esp)
+    195d:	00 
+    195e:	89 74 24 04          	mov    %esi,0x4(%esp)
+    1962:	89 1c 24             	mov    %ebx,(%esp)
+    1965:	e8 c6 fc ff ff       	call   1630 <peek>
+    196a:	85 c0                	test   %eax,%eax
+    196c:	75 c2                	jne    1930 <parseline+0x20>
+  if(peek(ps, es, ";")){
+    196e:	c7 44 24 08 52 23 00 	movl   $0x2352,0x8(%esp)
+    1975:	00 
+    1976:	89 74 24 04          	mov    %esi,0x4(%esp)
+    197a:	89 1c 24             	mov    %ebx,(%esp)
+    197d:	e8 ae fc ff ff       	call   1630 <peek>
+    1982:	85 c0                	test   %eax,%eax
+    1984:	75 0a                	jne    1990 <parseline+0x80>
+}
+    1986:	83 c4 1c             	add    $0x1c,%esp
+    1989:	89 f8                	mov    %edi,%eax
+    198b:	5b                   	pop    %ebx
+    198c:	5e                   	pop    %esi
+    198d:	5f                   	pop    %edi
+    198e:	5d                   	pop    %ebp
+    198f:	c3                   	ret    
+    gettoken(ps, es, 0, 0);
+    1990:	89 74 24 04          	mov    %esi,0x4(%esp)
+    1994:	89 1c 24             	mov    %ebx,(%esp)
+    1997:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+    199e:	00 
+    199f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+    19a6:	00 
+    19a7:	e8 44 fb ff ff       	call   14f0 <gettoken>
+    cmd = listcmd(cmd, parseline(ps, es));
+    19ac:	89 74 24 04          	mov    %esi,0x4(%esp)
+    19b0:	89 1c 24             	mov    %ebx,(%esp)
+    19b3:	e8 58 ff ff ff       	call   1910 <parseline>
+    19b8:	89 7d 08             	mov    %edi,0x8(%ebp)
+    19bb:	89 45 0c             	mov    %eax,0xc(%ebp)
+}
+    19be:	83 c4 1c             	add    $0x1c,%esp
+    19c1:	5b                   	pop    %ebx
+    19c2:	5e                   	pop    %esi
+    19c3:	5f                   	pop    %edi
+    19c4:	5d                   	pop    %ebp
+    cmd = listcmd(cmd, parseline(ps, es));
+    19c5:	e9 86 fa ff ff       	jmp    1450 <listcmd>
+    19ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000019d0 <parseblock>:
+{
+    19d0:	55                   	push   %ebp
+    19d1:	89 e5                	mov    %esp,%ebp
+    19d3:	57                   	push   %edi
+    19d4:	56                   	push   %esi
+    19d5:	53                   	push   %ebx
+    19d6:	83 ec 1c             	sub    $0x1c,%esp
+    19d9:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    19dc:	8b 75 0c             	mov    0xc(%ebp),%esi
+  if(!peek(ps, es, "("))
+    19df:	c7 44 24 08 38 23 00 	movl   $0x2338,0x8(%esp)
+    19e6:	00 
+    19e7:	89 1c 24             	mov    %ebx,(%esp)
+    19ea:	89 74 24 04          	mov    %esi,0x4(%esp)
+    19ee:	e8 3d fc ff ff       	call   1630 <peek>
+    19f3:	85 c0                	test   %eax,%eax
+    19f5:	74 76                	je     1a6d <parseblock+0x9d>
+  gettoken(ps, es, 0, 0);
+    19f7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+    19fe:	00 
+    19ff:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+    1a06:	00 
+    1a07:	89 74 24 04          	mov    %esi,0x4(%esp)
+    1a0b:	89 1c 24             	mov    %ebx,(%esp)
+    1a0e:	e8 dd fa ff ff       	call   14f0 <gettoken>
+  cmd = parseline(ps, es);
+    1a13:	89 74 24 04          	mov    %esi,0x4(%esp)
+    1a17:	89 1c 24             	mov    %ebx,(%esp)
+    1a1a:	e8 f1 fe ff ff       	call   1910 <parseline>
+  if(!peek(ps, es, ")"))
+    1a1f:	c7 44 24 08 74 23 00 	movl   $0x2374,0x8(%esp)
+    1a26:	00 
+    1a27:	89 74 24 04          	mov    %esi,0x4(%esp)
+    1a2b:	89 1c 24             	mov    %ebx,(%esp)
+  cmd = parseline(ps, es);
+    1a2e:	89 c7                	mov    %eax,%edi
+  if(!peek(ps, es, ")"))
+    1a30:	e8 fb fb ff ff       	call   1630 <peek>
+    1a35:	85 c0                	test   %eax,%eax
+    1a37:	74 40                	je     1a79 <parseblock+0xa9>
+  gettoken(ps, es, 0, 0);
+    1a39:	89 74 24 04          	mov    %esi,0x4(%esp)
+    1a3d:	89 1c 24             	mov    %ebx,(%esp)
+    1a40:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+    1a47:	00 
+    1a48:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+    1a4f:	00 
+    1a50:	e8 9b fa ff ff       	call   14f0 <gettoken>
+  cmd = parseredirs(cmd, ps, es);
+    1a55:	89 74 24 08          	mov    %esi,0x8(%esp)
+    1a59:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1a5d:	89 3c 24             	mov    %edi,(%esp)
+    1a60:	e8 2b fc ff ff       	call   1690 <parseredirs>
+}
+    1a65:	83 c4 1c             	add    $0x1c,%esp
+    1a68:	5b                   	pop    %ebx
+    1a69:	5e                   	pop    %esi
+    1a6a:	5f                   	pop    %edi
+    1a6b:	5d                   	pop    %ebp
+    1a6c:	c3                   	ret    
+    panic("parseblock");
+    1a6d:	c7 04 24 58 23 00 00 	movl   $0x2358,(%esp)
+    1a74:	e8 e7 f6 ff ff       	call   1160 <panic>
+    panic("syntax - missing )");
+    1a79:	c7 04 24 63 23 00 00 	movl   $0x2363,(%esp)
+    1a80:	e8 db f6 ff ff       	call   1160 <panic>
+    1a85:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1a89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001a90 <nulterminate>:
+
+// NUL-terminate all the counted strings.
+struct cmd*
+nulterminate(struct cmd *cmd)
+{
+    1a90:	55                   	push   %ebp
+    1a91:	89 e5                	mov    %esp,%ebp
+    1a93:	53                   	push   %ebx
+    1a94:	83 ec 14             	sub    $0x14,%esp
+    1a97:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  struct execcmd *ecmd;
+  struct listcmd *lcmd;
+  struct pipecmd *pcmd;
+  struct redircmd *rcmd;
+
+  if(cmd == 0)
+    1a9a:	85 db                	test   %ebx,%ebx
+    1a9c:	0f 84 8e 00 00 00    	je     1b30 <nulterminate+0xa0>
+    return 0;
+
+  switch(cmd->type){
+    1aa2:	83 3b 05             	cmpl   $0x5,(%ebx)
+    1aa5:	77 49                	ja     1af0 <nulterminate+0x60>
+    1aa7:	8b 03                	mov    (%ebx),%eax
+    1aa9:	ff 24 85 b4 23 00 00 	jmp    *0x23b4(,%eax,4)
+    nulterminate(pcmd->right);
+    break;
+
+  case LIST:
+    lcmd = (struct listcmd*)cmd;
+    nulterminate(lcmd->left);
+    1ab0:	8b 43 04             	mov    0x4(%ebx),%eax
+    1ab3:	89 04 24             	mov    %eax,(%esp)
+    1ab6:	e8 d5 ff ff ff       	call   1a90 <nulterminate>
+    nulterminate(lcmd->right);
+    1abb:	8b 43 08             	mov    0x8(%ebx),%eax
+    1abe:	89 04 24             	mov    %eax,(%esp)
+    1ac1:	e8 ca ff ff ff       	call   1a90 <nulterminate>
+    break;
+    1ac6:	89 d8                	mov    %ebx,%eax
+    bcmd = (struct backcmd*)cmd;
+    nulterminate(bcmd->cmd);
+    break;
+  }
+  return cmd;
+}
+    1ac8:	83 c4 14             	add    $0x14,%esp
+    1acb:	5b                   	pop    %ebx
+    1acc:	5d                   	pop    %ebp
+    1acd:	c3                   	ret    
+    1ace:	66 90                	xchg   %ax,%ax
+    for(i=0; ecmd->argv[i]; i++)
+    1ad0:	8b 4b 04             	mov    0x4(%ebx),%ecx
+    1ad3:	89 d8                	mov    %ebx,%eax
+    1ad5:	85 c9                	test   %ecx,%ecx
+    1ad7:	74 17                	je     1af0 <nulterminate+0x60>
+    1ad9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      *ecmd->eargv[i] = 0;
+    1ae0:	8b 50 2c             	mov    0x2c(%eax),%edx
+    1ae3:	83 c0 04             	add    $0x4,%eax
+    1ae6:	c6 02 00             	movb   $0x0,(%edx)
+    for(i=0; ecmd->argv[i]; i++)
+    1ae9:	8b 50 04             	mov    0x4(%eax),%edx
+    1aec:	85 d2                	test   %edx,%edx
+    1aee:	75 f0                	jne    1ae0 <nulterminate+0x50>
+}
+    1af0:	83 c4 14             	add    $0x14,%esp
+  switch(cmd->type){
+    1af3:	89 d8                	mov    %ebx,%eax
+}
+    1af5:	5b                   	pop    %ebx
+    1af6:	5d                   	pop    %ebp
+    1af7:	c3                   	ret    
+    nulterminate(bcmd->cmd);
+    1af8:	8b 43 04             	mov    0x4(%ebx),%eax
+    1afb:	89 04 24             	mov    %eax,(%esp)
+    1afe:	e8 8d ff ff ff       	call   1a90 <nulterminate>
+}
+    1b03:	83 c4 14             	add    $0x14,%esp
+    break;
+    1b06:	89 d8                	mov    %ebx,%eax
+}
+    1b08:	5b                   	pop    %ebx
+    1b09:	5d                   	pop    %ebp
+    1b0a:	c3                   	ret    
+    1b0b:	90                   	nop
+    1b0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    nulterminate(rcmd->cmd);
+    1b10:	8b 43 04             	mov    0x4(%ebx),%eax
+    1b13:	89 04 24             	mov    %eax,(%esp)
+    1b16:	e8 75 ff ff ff       	call   1a90 <nulterminate>
+    *rcmd->efile = 0;
+    1b1b:	8b 43 0c             	mov    0xc(%ebx),%eax
+    1b1e:	c6 00 00             	movb   $0x0,(%eax)
+}
+    1b21:	83 c4 14             	add    $0x14,%esp
+    break;
+    1b24:	89 d8                	mov    %ebx,%eax
+}
+    1b26:	5b                   	pop    %ebx
+    1b27:	5d                   	pop    %ebp
+    1b28:	c3                   	ret    
+    1b29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return 0;
+    1b30:	31 c0                	xor    %eax,%eax
+    1b32:	eb 94                	jmp    1ac8 <nulterminate+0x38>
+    1b34:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1b3a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001b40 <parsecmd>:
+{
+    1b40:	55                   	push   %ebp
+    1b41:	89 e5                	mov    %esp,%ebp
+    1b43:	56                   	push   %esi
+    1b44:	53                   	push   %ebx
+    1b45:	83 ec 10             	sub    $0x10,%esp
+  es = s + strlen(s);
+    1b48:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    1b4b:	89 1c 24             	mov    %ebx,(%esp)
+    1b4e:	e8 ed 00 00 00       	call   1c40 <strlen>
+    1b53:	01 c3                	add    %eax,%ebx
+  cmd = parseline(&s, es);
+    1b55:	8d 45 08             	lea    0x8(%ebp),%eax
+    1b58:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1b5c:	89 04 24             	mov    %eax,(%esp)
+    1b5f:	e8 ac fd ff ff       	call   1910 <parseline>
+  peek(&s, es, "");
+    1b64:	c7 44 24 08 02 23 00 	movl   $0x2302,0x8(%esp)
+    1b6b:	00 
+    1b6c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+  cmd = parseline(&s, es);
+    1b70:	89 c6                	mov    %eax,%esi
+  peek(&s, es, "");
+    1b72:	8d 45 08             	lea    0x8(%ebp),%eax
+    1b75:	89 04 24             	mov    %eax,(%esp)
+    1b78:	e8 b3 fa ff ff       	call   1630 <peek>
+  if(s != es){
+    1b7d:	8b 45 08             	mov    0x8(%ebp),%eax
+    1b80:	39 d8                	cmp    %ebx,%eax
+    1b82:	75 11                	jne    1b95 <parsecmd+0x55>
+  nulterminate(cmd);
+    1b84:	89 34 24             	mov    %esi,(%esp)
+    1b87:	e8 04 ff ff ff       	call   1a90 <nulterminate>
+}
+    1b8c:	83 c4 10             	add    $0x10,%esp
+    1b8f:	89 f0                	mov    %esi,%eax
+    1b91:	5b                   	pop    %ebx
+    1b92:	5e                   	pop    %esi
+    1b93:	5d                   	pop    %ebp
+    1b94:	c3                   	ret    
+    printf(2, "leftovers: %s\n", s);
+    1b95:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1b99:	c7 44 24 04 76 23 00 	movl   $0x2376,0x4(%esp)
+    1ba0:	00 
+    1ba1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    1ba8:	e8 93 03 00 00       	call   1f40 <printf>
+    panic("syntax");
+    1bad:	c7 04 24 3a 23 00 00 	movl   $0x233a,(%esp)
+    1bb4:	e8 a7 f5 ff ff       	call   1160 <panic>
+    1bb9:	66 90                	xchg   %ax,%ax
+    1bbb:	66 90                	xchg   %ax,%ax
+    1bbd:	66 90                	xchg   %ax,%ax
+    1bbf:	90                   	nop
+
+00001bc0 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1bc0:	55                   	push   %ebp
+    1bc1:	89 e5                	mov    %esp,%ebp
+    1bc3:	8b 45 08             	mov    0x8(%ebp),%eax
+    1bc6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1bc9:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    1bca:	89 c2                	mov    %eax,%edx
+    1bcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1bd0:	83 c1 01             	add    $0x1,%ecx
+    1bd3:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1bd7:	83 c2 01             	add    $0x1,%edx
+    1bda:	84 db                	test   %bl,%bl
+    1bdc:	88 5a ff             	mov    %bl,-0x1(%edx)
+    1bdf:	75 ef                	jne    1bd0 <strcpy+0x10>
+    ;
+  return os;
+}
+    1be1:	5b                   	pop    %ebx
+    1be2:	5d                   	pop    %ebp
+    1be3:	c3                   	ret    
+    1be4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1bea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001bf0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1bf0:	55                   	push   %ebp
+    1bf1:	89 e5                	mov    %esp,%ebp
+    1bf3:	8b 55 08             	mov    0x8(%ebp),%edx
+    1bf6:	53                   	push   %ebx
+    1bf7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    1bfa:	0f b6 02             	movzbl (%edx),%eax
+    1bfd:	84 c0                	test   %al,%al
+    1bff:	74 2d                	je     1c2e <strcmp+0x3e>
+    1c01:	0f b6 19             	movzbl (%ecx),%ebx
+    1c04:	38 d8                	cmp    %bl,%al
+    1c06:	74 0e                	je     1c16 <strcmp+0x26>
+    1c08:	eb 2b                	jmp    1c35 <strcmp+0x45>
+    1c0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1c10:	38 c8                	cmp    %cl,%al
+    1c12:	75 15                	jne    1c29 <strcmp+0x39>
+    p++, q++;
+    1c14:	89 d9                	mov    %ebx,%ecx
+    1c16:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    1c19:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    1c1c:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    1c1f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    1c23:	84 c0                	test   %al,%al
+    1c25:	75 e9                	jne    1c10 <strcmp+0x20>
+    1c27:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    1c29:	29 c8                	sub    %ecx,%eax
+}
+    1c2b:	5b                   	pop    %ebx
+    1c2c:	5d                   	pop    %ebp
+    1c2d:	c3                   	ret    
+    1c2e:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    1c31:	31 c0                	xor    %eax,%eax
+    1c33:	eb f4                	jmp    1c29 <strcmp+0x39>
+    1c35:	0f b6 cb             	movzbl %bl,%ecx
+    1c38:	eb ef                	jmp    1c29 <strcmp+0x39>
+    1c3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001c40 <strlen>:
+
+uint
+strlen(char *s)
+{
+    1c40:	55                   	push   %ebp
+    1c41:	89 e5                	mov    %esp,%ebp
+    1c43:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    1c46:	80 39 00             	cmpb   $0x0,(%ecx)
+    1c49:	74 12                	je     1c5d <strlen+0x1d>
+    1c4b:	31 d2                	xor    %edx,%edx
+    1c4d:	8d 76 00             	lea    0x0(%esi),%esi
+    1c50:	83 c2 01             	add    $0x1,%edx
+    1c53:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    1c57:	89 d0                	mov    %edx,%eax
+    1c59:	75 f5                	jne    1c50 <strlen+0x10>
+    ;
+  return n;
+}
+    1c5b:	5d                   	pop    %ebp
+    1c5c:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    1c5d:	31 c0                	xor    %eax,%eax
+}
+    1c5f:	5d                   	pop    %ebp
+    1c60:	c3                   	ret    
+    1c61:	eb 0d                	jmp    1c70 <memset>
+    1c63:	90                   	nop
+    1c64:	90                   	nop
+    1c65:	90                   	nop
+    1c66:	90                   	nop
+    1c67:	90                   	nop
+    1c68:	90                   	nop
+    1c69:	90                   	nop
+    1c6a:	90                   	nop
+    1c6b:	90                   	nop
+    1c6c:	90                   	nop
+    1c6d:	90                   	nop
+    1c6e:	90                   	nop
+    1c6f:	90                   	nop
+
+00001c70 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    1c70:	55                   	push   %ebp
+    1c71:	89 e5                	mov    %esp,%ebp
+    1c73:	8b 55 08             	mov    0x8(%ebp),%edx
+    1c76:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    1c77:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    1c7a:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1c7d:	89 d7                	mov    %edx,%edi
+    1c7f:	fc                   	cld    
+    1c80:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    1c82:	89 d0                	mov    %edx,%eax
+    1c84:	5f                   	pop    %edi
+    1c85:	5d                   	pop    %ebp
+    1c86:	c3                   	ret    
+    1c87:	89 f6                	mov    %esi,%esi
+    1c89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001c90 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    1c90:	55                   	push   %ebp
+    1c91:	89 e5                	mov    %esp,%ebp
+    1c93:	8b 45 08             	mov    0x8(%ebp),%eax
+    1c96:	53                   	push   %ebx
+    1c97:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    1c9a:	0f b6 18             	movzbl (%eax),%ebx
+    1c9d:	84 db                	test   %bl,%bl
+    1c9f:	74 1d                	je     1cbe <strchr+0x2e>
+    if(*s == c)
+    1ca1:	38 d3                	cmp    %dl,%bl
+    1ca3:	89 d1                	mov    %edx,%ecx
+    1ca5:	75 0d                	jne    1cb4 <strchr+0x24>
+    1ca7:	eb 17                	jmp    1cc0 <strchr+0x30>
+    1ca9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1cb0:	38 ca                	cmp    %cl,%dl
+    1cb2:	74 0c                	je     1cc0 <strchr+0x30>
+  for(; *s; s++)
+    1cb4:	83 c0 01             	add    $0x1,%eax
+    1cb7:	0f b6 10             	movzbl (%eax),%edx
+    1cba:	84 d2                	test   %dl,%dl
+    1cbc:	75 f2                	jne    1cb0 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    1cbe:	31 c0                	xor    %eax,%eax
+}
+    1cc0:	5b                   	pop    %ebx
+    1cc1:	5d                   	pop    %ebp
+    1cc2:	c3                   	ret    
+    1cc3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1cc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001cd0 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1cd0:	55                   	push   %ebp
+    1cd1:	89 e5                	mov    %esp,%ebp
+    1cd3:	57                   	push   %edi
+    1cd4:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1cd5:	31 f6                	xor    %esi,%esi
+{
+    1cd7:	53                   	push   %ebx
+    1cd8:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    1cdb:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    1cde:	eb 31                	jmp    1d11 <gets+0x41>
+    cc = read(0, &c, 1);
+    1ce0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1ce7:	00 
+    1ce8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    1cec:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1cf3:	e8 02 01 00 00       	call   1dfa <read>
+    if(cc < 1)
+    1cf8:	85 c0                	test   %eax,%eax
+    1cfa:	7e 1d                	jle    1d19 <gets+0x49>
+      break;
+    buf[i++] = c;
+    1cfc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    1d00:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    1d02:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    1d05:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    1d07:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    1d0b:	74 0c                	je     1d19 <gets+0x49>
+    1d0d:	3c 0a                	cmp    $0xa,%al
+    1d0f:	74 08                	je     1d19 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    1d11:	8d 5e 01             	lea    0x1(%esi),%ebx
+    1d14:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    1d17:	7c c7                	jl     1ce0 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    1d19:	8b 45 08             	mov    0x8(%ebp),%eax
+    1d1c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    1d20:	83 c4 2c             	add    $0x2c,%esp
+    1d23:	5b                   	pop    %ebx
+    1d24:	5e                   	pop    %esi
+    1d25:	5f                   	pop    %edi
+    1d26:	5d                   	pop    %ebp
+    1d27:	c3                   	ret    
+    1d28:	90                   	nop
+    1d29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001d30 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    1d30:	55                   	push   %ebp
+    1d31:	89 e5                	mov    %esp,%ebp
+    1d33:	56                   	push   %esi
+    1d34:	53                   	push   %ebx
+    1d35:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    1d38:	8b 45 08             	mov    0x8(%ebp),%eax
+    1d3b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1d42:	00 
+    1d43:	89 04 24             	mov    %eax,(%esp)
+    1d46:	e8 d7 00 00 00       	call   1e22 <open>
+  if(fd < 0)
+    1d4b:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    1d4d:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    1d4f:	78 27                	js     1d78 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    1d51:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1d54:	89 1c 24             	mov    %ebx,(%esp)
+    1d57:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1d5b:	e8 da 00 00 00       	call   1e3a <fstat>
+  close(fd);
+    1d60:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    1d63:	89 c6                	mov    %eax,%esi
+  close(fd);
+    1d65:	e8 a0 00 00 00       	call   1e0a <close>
+  return r;
+    1d6a:	89 f0                	mov    %esi,%eax
+}
+    1d6c:	83 c4 10             	add    $0x10,%esp
+    1d6f:	5b                   	pop    %ebx
+    1d70:	5e                   	pop    %esi
+    1d71:	5d                   	pop    %ebp
+    1d72:	c3                   	ret    
+    1d73:	90                   	nop
+    1d74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    1d78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    1d7d:	eb ed                	jmp    1d6c <stat+0x3c>
+    1d7f:	90                   	nop
+
+00001d80 <atoi>:
+
+int
+atoi(const char *s)
+{
+    1d80:	55                   	push   %ebp
+    1d81:	89 e5                	mov    %esp,%ebp
+    1d83:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    1d86:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    1d87:	0f be 11             	movsbl (%ecx),%edx
+    1d8a:	8d 42 d0             	lea    -0x30(%edx),%eax
+    1d8d:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    1d8f:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    1d94:	77 17                	ja     1dad <atoi+0x2d>
+    1d96:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    1d98:	83 c1 01             	add    $0x1,%ecx
+    1d9b:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    1d9e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1da2:	0f be 11             	movsbl (%ecx),%edx
+    1da5:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1da8:	80 fb 09             	cmp    $0x9,%bl
+    1dab:	76 eb                	jbe    1d98 <atoi+0x18>
+  return n;
+}
+    1dad:	5b                   	pop    %ebx
+    1dae:	5d                   	pop    %ebp
+    1daf:	c3                   	ret    
+
+00001db0 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1db0:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1db1:	31 d2                	xor    %edx,%edx
+{
+    1db3:	89 e5                	mov    %esp,%ebp
+    1db5:	56                   	push   %esi
+    1db6:	8b 45 08             	mov    0x8(%ebp),%eax
+    1db9:	53                   	push   %ebx
+    1dba:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    1dbd:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1dc0:	85 db                	test   %ebx,%ebx
+    1dc2:	7e 12                	jle    1dd6 <memmove+0x26>
+    1dc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1dc8:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    1dcc:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    1dcf:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1dd2:	39 da                	cmp    %ebx,%edx
+    1dd4:	75 f2                	jne    1dc8 <memmove+0x18>
+  return vdst;
+}
+    1dd6:	5b                   	pop    %ebx
+    1dd7:	5e                   	pop    %esi
+    1dd8:	5d                   	pop    %ebp
+    1dd9:	c3                   	ret    
+
+00001dda <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    1dda:	b8 01 00 00 00       	mov    $0x1,%eax
+    1ddf:	cd 40                	int    $0x40
+    1de1:	c3                   	ret    
+
+00001de2 <exit>:
+SYSCALL(exit)
+    1de2:	b8 02 00 00 00       	mov    $0x2,%eax
+    1de7:	cd 40                	int    $0x40
+    1de9:	c3                   	ret    
+
+00001dea <wait>:
+SYSCALL(wait)
+    1dea:	b8 03 00 00 00       	mov    $0x3,%eax
+    1def:	cd 40                	int    $0x40
+    1df1:	c3                   	ret    
+
+00001df2 <pipe>:
+SYSCALL(pipe)
+    1df2:	b8 04 00 00 00       	mov    $0x4,%eax
+    1df7:	cd 40                	int    $0x40
+    1df9:	c3                   	ret    
+
+00001dfa <read>:
+SYSCALL(read)
+    1dfa:	b8 05 00 00 00       	mov    $0x5,%eax
+    1dff:	cd 40                	int    $0x40
+    1e01:	c3                   	ret    
+
+00001e02 <write>:
+SYSCALL(write)
+    1e02:	b8 10 00 00 00       	mov    $0x10,%eax
+    1e07:	cd 40                	int    $0x40
+    1e09:	c3                   	ret    
+
+00001e0a <close>:
+SYSCALL(close)
+    1e0a:	b8 15 00 00 00       	mov    $0x15,%eax
+    1e0f:	cd 40                	int    $0x40
+    1e11:	c3                   	ret    
+
+00001e12 <kill>:
+SYSCALL(kill)
+    1e12:	b8 06 00 00 00       	mov    $0x6,%eax
+    1e17:	cd 40                	int    $0x40
+    1e19:	c3                   	ret    
+
+00001e1a <exec>:
+SYSCALL(exec)
+    1e1a:	b8 07 00 00 00       	mov    $0x7,%eax
+    1e1f:	cd 40                	int    $0x40
+    1e21:	c3                   	ret    
+
+00001e22 <open>:
+SYSCALL(open)
+    1e22:	b8 0f 00 00 00       	mov    $0xf,%eax
+    1e27:	cd 40                	int    $0x40
+    1e29:	c3                   	ret    
+
+00001e2a <mknod>:
+SYSCALL(mknod)
+    1e2a:	b8 11 00 00 00       	mov    $0x11,%eax
+    1e2f:	cd 40                	int    $0x40
+    1e31:	c3                   	ret    
+
+00001e32 <unlink>:
+SYSCALL(unlink)
+    1e32:	b8 12 00 00 00       	mov    $0x12,%eax
+    1e37:	cd 40                	int    $0x40
+    1e39:	c3                   	ret    
+
+00001e3a <fstat>:
+SYSCALL(fstat)
+    1e3a:	b8 08 00 00 00       	mov    $0x8,%eax
+    1e3f:	cd 40                	int    $0x40
+    1e41:	c3                   	ret    
+
+00001e42 <link>:
+SYSCALL(link)
+    1e42:	b8 13 00 00 00       	mov    $0x13,%eax
+    1e47:	cd 40                	int    $0x40
+    1e49:	c3                   	ret    
+
+00001e4a <mkdir>:
+SYSCALL(mkdir)
+    1e4a:	b8 14 00 00 00       	mov    $0x14,%eax
+    1e4f:	cd 40                	int    $0x40
+    1e51:	c3                   	ret    
+
+00001e52 <chdir>:
+SYSCALL(chdir)
+    1e52:	b8 09 00 00 00       	mov    $0x9,%eax
+    1e57:	cd 40                	int    $0x40
+    1e59:	c3                   	ret    
+
+00001e5a <dup>:
+SYSCALL(dup)
+    1e5a:	b8 0a 00 00 00       	mov    $0xa,%eax
+    1e5f:	cd 40                	int    $0x40
+    1e61:	c3                   	ret    
+
+00001e62 <getpid>:
+SYSCALL(getpid)
+    1e62:	b8 0b 00 00 00       	mov    $0xb,%eax
+    1e67:	cd 40                	int    $0x40
+    1e69:	c3                   	ret    
+
+00001e6a <sbrk>:
+SYSCALL(sbrk)
+    1e6a:	b8 0c 00 00 00       	mov    $0xc,%eax
+    1e6f:	cd 40                	int    $0x40
+    1e71:	c3                   	ret    
+
+00001e72 <sleep>:
+SYSCALL(sleep)
+    1e72:	b8 0d 00 00 00       	mov    $0xd,%eax
+    1e77:	cd 40                	int    $0x40
+    1e79:	c3                   	ret    
+
+00001e7a <uptime>:
+SYSCALL(uptime)
+    1e7a:	b8 0e 00 00 00       	mov    $0xe,%eax
+    1e7f:	cd 40                	int    $0x40
+    1e81:	c3                   	ret    
+
+00001e82 <shm_open>:
+SYSCALL(shm_open)
+    1e82:	b8 16 00 00 00       	mov    $0x16,%eax
+    1e87:	cd 40                	int    $0x40
+    1e89:	c3                   	ret    
+
+00001e8a <shm_close>:
+SYSCALL(shm_close)	
+    1e8a:	b8 17 00 00 00       	mov    $0x17,%eax
+    1e8f:	cd 40                	int    $0x40
+    1e91:	c3                   	ret    
+    1e92:	66 90                	xchg   %ax,%ax
+    1e94:	66 90                	xchg   %ax,%ax
+    1e96:	66 90                	xchg   %ax,%ax
+    1e98:	66 90                	xchg   %ax,%ax
+    1e9a:	66 90                	xchg   %ax,%ax
+    1e9c:	66 90                	xchg   %ax,%ax
+    1e9e:	66 90                	xchg   %ax,%ax
+
+00001ea0 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1ea0:	55                   	push   %ebp
+    1ea1:	89 e5                	mov    %esp,%ebp
+    1ea3:	57                   	push   %edi
+    1ea4:	56                   	push   %esi
+    1ea5:	89 c6                	mov    %eax,%esi
+    1ea7:	53                   	push   %ebx
+    1ea8:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    1eab:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    1eae:	85 db                	test   %ebx,%ebx
+    1eb0:	74 09                	je     1ebb <printint+0x1b>
+    1eb2:	89 d0                	mov    %edx,%eax
+    1eb4:	c1 e8 1f             	shr    $0x1f,%eax
+    1eb7:	84 c0                	test   %al,%al
+    1eb9:	75 75                	jne    1f30 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    1ebb:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    1ebd:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1ec4:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1ec7:	31 ff                	xor    %edi,%edi
+    1ec9:	89 ce                	mov    %ecx,%esi
+    1ecb:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    1ece:	eb 02                	jmp    1ed2 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1ed0:	89 cf                	mov    %ecx,%edi
+    1ed2:	31 d2                	xor    %edx,%edx
+    1ed4:	f7 f6                	div    %esi
+    1ed6:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1ed9:	0f b6 92 d3 23 00 00 	movzbl 0x23d3(%edx),%edx
+  }while((x /= base) != 0);
+    1ee0:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1ee2:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1ee5:	75 e9                	jne    1ed0 <printint+0x30>
+  if(neg)
+    1ee7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    1eea:	89 c8                	mov    %ecx,%eax
+    1eec:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    1eef:	85 d2                	test   %edx,%edx
+    1ef1:	74 08                	je     1efb <printint+0x5b>
+    buf[i++] = '-';
+    1ef3:	8d 4f 02             	lea    0x2(%edi),%ecx
+    1ef6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    1efb:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    1efe:	66 90                	xchg   %ax,%ax
+    1f00:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    1f05:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    1f08:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1f0f:	00 
+    1f10:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1f14:	89 34 24             	mov    %esi,(%esp)
+    1f17:	88 45 d7             	mov    %al,-0x29(%ebp)
+    1f1a:	e8 e3 fe ff ff       	call   1e02 <write>
+  while(--i >= 0)
+    1f1f:	83 ff ff             	cmp    $0xffffffff,%edi
+    1f22:	75 dc                	jne    1f00 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    1f24:	83 c4 4c             	add    $0x4c,%esp
+    1f27:	5b                   	pop    %ebx
+    1f28:	5e                   	pop    %esi
+    1f29:	5f                   	pop    %edi
+    1f2a:	5d                   	pop    %ebp
+    1f2b:	c3                   	ret    
+    1f2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    1f30:	89 d0                	mov    %edx,%eax
+    1f32:	f7 d8                	neg    %eax
+    neg = 1;
+    1f34:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    1f3b:	eb 87                	jmp    1ec4 <printint+0x24>
+    1f3d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00001f40 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    1f40:	55                   	push   %ebp
+    1f41:	89 e5                	mov    %esp,%ebp
+    1f43:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    1f44:	31 ff                	xor    %edi,%edi
+{
+    1f46:	56                   	push   %esi
+    1f47:	53                   	push   %ebx
+    1f48:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    1f4b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    1f4e:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    1f51:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    1f54:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    1f57:	0f b6 13             	movzbl (%ebx),%edx
+    1f5a:	83 c3 01             	add    $0x1,%ebx
+    1f5d:	84 d2                	test   %dl,%dl
+    1f5f:	75 39                	jne    1f9a <printf+0x5a>
+    1f61:	e9 c2 00 00 00       	jmp    2028 <printf+0xe8>
+    1f66:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    1f68:	83 fa 25             	cmp    $0x25,%edx
+    1f6b:	0f 84 bf 00 00 00    	je     2030 <printf+0xf0>
+  write(fd, &c, 1);
+    1f71:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    1f74:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1f7b:	00 
+    1f7c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1f80:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    1f83:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    1f86:	e8 77 fe ff ff       	call   1e02 <write>
+    1f8b:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    1f8e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    1f92:	84 d2                	test   %dl,%dl
+    1f94:	0f 84 8e 00 00 00    	je     2028 <printf+0xe8>
+    if(state == 0){
+    1f9a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    1f9c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    1f9f:	74 c7                	je     1f68 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1fa1:	83 ff 25             	cmp    $0x25,%edi
+    1fa4:	75 e5                	jne    1f8b <printf+0x4b>
+      if(c == 'd'){
+    1fa6:	83 fa 64             	cmp    $0x64,%edx
+    1fa9:	0f 84 31 01 00 00    	je     20e0 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    1faf:	25 f7 00 00 00       	and    $0xf7,%eax
+    1fb4:	83 f8 70             	cmp    $0x70,%eax
+    1fb7:	0f 84 83 00 00 00    	je     2040 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    1fbd:	83 fa 73             	cmp    $0x73,%edx
+    1fc0:	0f 84 a2 00 00 00    	je     2068 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1fc6:	83 fa 63             	cmp    $0x63,%edx
+    1fc9:	0f 84 35 01 00 00    	je     2104 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    1fcf:	83 fa 25             	cmp    $0x25,%edx
+    1fd2:	0f 84 e0 00 00 00    	je     20b8 <printf+0x178>
+  write(fd, &c, 1);
+    1fd8:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    1fdb:	83 c3 01             	add    $0x1,%ebx
+    1fde:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1fe5:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    1fe6:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    1fe8:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1fec:	89 34 24             	mov    %esi,(%esp)
+    1fef:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    1ff2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    1ff6:	e8 07 fe ff ff       	call   1e02 <write>
+        putc(fd, c);
+    1ffb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    1ffe:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    2001:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    2008:	00 
+    2009:	89 44 24 04          	mov    %eax,0x4(%esp)
+    200d:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    2010:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    2013:	e8 ea fd ff ff       	call   1e02 <write>
+  for(i = 0; fmt[i]; i++){
+    2018:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    201c:	84 d2                	test   %dl,%dl
+    201e:	0f 85 76 ff ff ff    	jne    1f9a <printf+0x5a>
+    2024:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    2028:	83 c4 3c             	add    $0x3c,%esp
+    202b:	5b                   	pop    %ebx
+    202c:	5e                   	pop    %esi
+    202d:	5f                   	pop    %edi
+    202e:	5d                   	pop    %ebp
+    202f:	c3                   	ret    
+        state = '%';
+    2030:	bf 25 00 00 00       	mov    $0x25,%edi
+    2035:	e9 51 ff ff ff       	jmp    1f8b <printf+0x4b>
+    203a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    2040:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    2043:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    2048:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    204a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    2051:	8b 10                	mov    (%eax),%edx
+    2053:	89 f0                	mov    %esi,%eax
+    2055:	e8 46 fe ff ff       	call   1ea0 <printint>
+        ap++;
+    205a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    205e:	e9 28 ff ff ff       	jmp    1f8b <printf+0x4b>
+    2063:	90                   	nop
+    2064:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    2068:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    206b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    206f:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    2071:	b8 cc 23 00 00       	mov    $0x23cc,%eax
+    2076:	85 ff                	test   %edi,%edi
+    2078:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    207b:	0f b6 07             	movzbl (%edi),%eax
+    207e:	84 c0                	test   %al,%al
+    2080:	74 2a                	je     20ac <printf+0x16c>
+    2082:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    2088:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    208b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    208e:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    2091:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    2098:	00 
+    2099:	89 44 24 04          	mov    %eax,0x4(%esp)
+    209d:	89 34 24             	mov    %esi,(%esp)
+    20a0:	e8 5d fd ff ff       	call   1e02 <write>
+        while(*s != 0){
+    20a5:	0f b6 07             	movzbl (%edi),%eax
+    20a8:	84 c0                	test   %al,%al
+    20aa:	75 dc                	jne    2088 <printf+0x148>
+      state = 0;
+    20ac:	31 ff                	xor    %edi,%edi
+    20ae:	e9 d8 fe ff ff       	jmp    1f8b <printf+0x4b>
+    20b3:	90                   	nop
+    20b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    20b8:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    20bb:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    20bd:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    20c4:	00 
+    20c5:	89 44 24 04          	mov    %eax,0x4(%esp)
+    20c9:	89 34 24             	mov    %esi,(%esp)
+    20cc:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    20d0:	e8 2d fd ff ff       	call   1e02 <write>
+    20d5:	e9 b1 fe ff ff       	jmp    1f8b <printf+0x4b>
+    20da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    20e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    20e3:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    20e8:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    20eb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    20f2:	8b 10                	mov    (%eax),%edx
+    20f4:	89 f0                	mov    %esi,%eax
+    20f6:	e8 a5 fd ff ff       	call   1ea0 <printint>
+        ap++;
+    20fb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    20ff:	e9 87 fe ff ff       	jmp    1f8b <printf+0x4b>
+        putc(fd, *ap);
+    2104:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    2107:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    2109:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    210b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    2112:	00 
+    2113:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    2116:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    2119:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    211c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    2120:	e8 dd fc ff ff       	call   1e02 <write>
+        ap++;
+    2125:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    2129:	e9 5d fe ff ff       	jmp    1f8b <printf+0x4b>
+    212e:	66 90                	xchg   %ax,%ax
+
+00002130 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    2130:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    2131:	a1 24 2a 00 00       	mov    0x2a24,%eax
+{
+    2136:	89 e5                	mov    %esp,%ebp
+    2138:	57                   	push   %edi
+    2139:	56                   	push   %esi
+    213a:	53                   	push   %ebx
+    213b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    213e:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    2140:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    2143:	39 d0                	cmp    %edx,%eax
+    2145:	72 11                	jb     2158 <free+0x28>
+    2147:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    2148:	39 c8                	cmp    %ecx,%eax
+    214a:	72 04                	jb     2150 <free+0x20>
+    214c:	39 ca                	cmp    %ecx,%edx
+    214e:	72 10                	jb     2160 <free+0x30>
+    2150:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    2152:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    2154:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    2156:	73 f0                	jae    2148 <free+0x18>
+    2158:	39 ca                	cmp    %ecx,%edx
+    215a:	72 04                	jb     2160 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    215c:	39 c8                	cmp    %ecx,%eax
+    215e:	72 f0                	jb     2150 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    2160:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    2163:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    2166:	39 cf                	cmp    %ecx,%edi
+    2168:	74 1e                	je     2188 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    216a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    216d:	8b 48 04             	mov    0x4(%eax),%ecx
+    2170:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    2173:	39 f2                	cmp    %esi,%edx
+    2175:	74 28                	je     219f <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    2177:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    2179:	a3 24 2a 00 00       	mov    %eax,0x2a24
+}
+    217e:	5b                   	pop    %ebx
+    217f:	5e                   	pop    %esi
+    2180:	5f                   	pop    %edi
+    2181:	5d                   	pop    %ebp
+    2182:	c3                   	ret    
+    2183:	90                   	nop
+    2184:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    2188:	03 71 04             	add    0x4(%ecx),%esi
+    218b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    218e:	8b 08                	mov    (%eax),%ecx
+    2190:	8b 09                	mov    (%ecx),%ecx
+    2192:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    2195:	8b 48 04             	mov    0x4(%eax),%ecx
+    2198:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    219b:	39 f2                	cmp    %esi,%edx
+    219d:	75 d8                	jne    2177 <free+0x47>
+    p->s.size += bp->s.size;
+    219f:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    21a2:	a3 24 2a 00 00       	mov    %eax,0x2a24
+    p->s.size += bp->s.size;
+    21a7:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    21aa:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    21ad:	89 10                	mov    %edx,(%eax)
+}
+    21af:	5b                   	pop    %ebx
+    21b0:	5e                   	pop    %esi
+    21b1:	5f                   	pop    %edi
+    21b2:	5d                   	pop    %ebp
+    21b3:	c3                   	ret    
+    21b4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    21ba:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+000021c0 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    21c0:	55                   	push   %ebp
+    21c1:	89 e5                	mov    %esp,%ebp
+    21c3:	57                   	push   %edi
+    21c4:	56                   	push   %esi
+    21c5:	53                   	push   %ebx
+    21c6:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    21c9:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    21cc:	8b 1d 24 2a 00 00    	mov    0x2a24,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    21d2:	8d 48 07             	lea    0x7(%eax),%ecx
+    21d5:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    21d8:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    21da:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    21dd:	0f 84 9b 00 00 00    	je     227e <malloc+0xbe>
+    21e3:	8b 13                	mov    (%ebx),%edx
+    21e5:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    21e8:	39 fe                	cmp    %edi,%esi
+    21ea:	76 64                	jbe    2250 <malloc+0x90>
+    21ec:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    21f3:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    21f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    21fb:	eb 0e                	jmp    220b <malloc+0x4b>
+    21fd:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    2200:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    2202:	8b 78 04             	mov    0x4(%eax),%edi
+    2205:	39 fe                	cmp    %edi,%esi
+    2207:	76 4f                	jbe    2258 <malloc+0x98>
+    2209:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    220b:	3b 15 24 2a 00 00    	cmp    0x2a24,%edx
+    2211:	75 ed                	jne    2200 <malloc+0x40>
+  if(nu < 4096)
+    2213:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    2216:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    221c:	bf 00 10 00 00       	mov    $0x1000,%edi
+    2221:	0f 43 fe             	cmovae %esi,%edi
+    2224:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    2227:	89 04 24             	mov    %eax,(%esp)
+    222a:	e8 3b fc ff ff       	call   1e6a <sbrk>
+  if(p == (char*)-1)
+    222f:	83 f8 ff             	cmp    $0xffffffff,%eax
+    2232:	74 18                	je     224c <malloc+0x8c>
+  hp->s.size = nu;
+    2234:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    2237:	83 c0 08             	add    $0x8,%eax
+    223a:	89 04 24             	mov    %eax,(%esp)
+    223d:	e8 ee fe ff ff       	call   2130 <free>
+  return freep;
+    2242:	8b 15 24 2a 00 00    	mov    0x2a24,%edx
+      if((p = morecore(nunits)) == 0)
+    2248:	85 d2                	test   %edx,%edx
+    224a:	75 b4                	jne    2200 <malloc+0x40>
+        return 0;
+    224c:	31 c0                	xor    %eax,%eax
+    224e:	eb 20                	jmp    2270 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    2250:	89 d0                	mov    %edx,%eax
+    2252:	89 da                	mov    %ebx,%edx
+    2254:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    2258:	39 fe                	cmp    %edi,%esi
+    225a:	74 1c                	je     2278 <malloc+0xb8>
+        p->s.size -= nunits;
+    225c:	29 f7                	sub    %esi,%edi
+    225e:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    2261:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    2264:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    2267:	89 15 24 2a 00 00    	mov    %edx,0x2a24
+      return (void*)(p + 1);
+    226d:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    2270:	83 c4 1c             	add    $0x1c,%esp
+    2273:	5b                   	pop    %ebx
+    2274:	5e                   	pop    %esi
+    2275:	5f                   	pop    %edi
+    2276:	5d                   	pop    %ebp
+    2277:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    2278:	8b 08                	mov    (%eax),%ecx
+    227a:	89 0a                	mov    %ecx,(%edx)
+    227c:	eb e9                	jmp    2267 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    227e:	c7 05 24 2a 00 00 28 	movl   $0x2a28,0x2a24
+    2285:	2a 00 00 
+    base.s.size = 0;
+    2288:	ba 28 2a 00 00       	mov    $0x2a28,%edx
+    base.s.ptr = freep = prevp = &base;
+    228d:	c7 05 28 2a 00 00 28 	movl   $0x2a28,0x2a28
+    2294:	2a 00 00 
+    base.s.size = 0;
+    2297:	c7 05 2c 2a 00 00 00 	movl   $0x0,0x2a2c
+    229e:	00 00 00 
+    22a1:	e9 46 ff ff ff       	jmp    21ec <malloc+0x2c>
+    22a6:	66 90                	xchg   %ax,%ax
+    22a8:	66 90                	xchg   %ax,%ax
+    22aa:	66 90                	xchg   %ax,%ax
+    22ac:	66 90                	xchg   %ax,%ax
+    22ae:	66 90                	xchg   %ax,%ax
+
+000022b0 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    22b0:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    22b1:	b9 01 00 00 00       	mov    $0x1,%ecx
+    22b6:	89 e5                	mov    %esp,%ebp
+    22b8:	8b 55 08             	mov    0x8(%ebp),%edx
+    22bb:	90                   	nop
+    22bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    22c0:	89 c8                	mov    %ecx,%eax
+    22c2:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    22c5:	85 c0                	test   %eax,%eax
+    22c7:	75 f7                	jne    22c0 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    22c9:	0f ae f0             	mfence 
+}
+    22cc:	5d                   	pop    %ebp
+    22cd:	c3                   	ret    
+    22ce:	66 90                	xchg   %ax,%ax
+
+000022d0 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    22d0:	55                   	push   %ebp
+    22d1:	89 e5                	mov    %esp,%ebp
+    22d3:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    22d6:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    22d9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    22df:	5d                   	pop    %ebp
+    22e0:	c3                   	ret    
diff --git a/sh.c b/sh.c
index ca2ae37..054bab9 100644
--- a/sh.c
+++ b/sh.c
@@ -65,7 +65,7 @@ runcmd(struct cmd *cmd)
   struct redircmd *rcmd;
 
   if(cmd == 0)
-    exit(1);
+    exit();
 
   switch(cmd->type){
   default:
@@ -74,7 +74,7 @@ runcmd(struct cmd *cmd)
   case EXEC:
     ecmd = (struct execcmd*)cmd;
     if(ecmd->argv[0] == 0)
-      exit(2);
+      exit();
     exec(ecmd->argv[0], ecmd->argv);
     printf(2, "exec %s failed\n", ecmd->argv[0]);
     break;
@@ -84,7 +84,7 @@ runcmd(struct cmd *cmd)
     close(rcmd->fd);
     if(open(rcmd->file, rcmd->mode) < 0){
       printf(2, "open %s failed\n", rcmd->file);
-      exit(6);
+      exit();
     }
     runcmd(rcmd->cmd);
     break;
@@ -93,7 +93,7 @@ runcmd(struct cmd *cmd)
     lcmd = (struct listcmd*)cmd;
     if(fork1() == 0)
       runcmd(lcmd->left);
-    wait(NULL);
+    wait();
     runcmd(lcmd->right);
     break;
 
@@ -117,8 +117,8 @@ runcmd(struct cmd *cmd)
     }
     close(p[0]);
     close(p[1]);
-    wait(NULL);
-    wait(NULL);
+    wait();
+    wait();
     break;
 
   case BACK:
@@ -127,7 +127,7 @@ runcmd(struct cmd *cmd)
       runcmd(bcmd->cmd);
     break;
   }
-  exit(3);
+  exit();
 }
 
 int
@@ -166,16 +166,16 @@ main(void)
     }
     if(fork1() == 0)
       runcmd(parsecmd(buf));
-    wait(NULL);
+    wait();
   }
-  exit(0);
+  exit();
 }
 
 void
 panic(char *s)
 {
   printf(2, "%s\n", s);
-  exit(5);
+  exit();
 }
 
 int
diff --git a/sh.d b/sh.d
new file mode 100644
index 0000000..51ddf2d
--- /dev/null
+++ b/sh.d
@@ -0,0 +1 @@
+sh.o: sh.c /usr/include/stdc-predef.h types.h user.h fcntl.h
diff --git a/sh.o b/sh.o
new file mode 100644
index 0000000..c4a7bdc
Binary files /dev/null and b/sh.o differ
diff --git a/sh.sym b/sh.sym
new file mode 100644
index 0000000..bca42bb
--- /dev/null
+++ b/sh.sym
@@ -0,0 +1,84 @@
+00001000 .text
+000022e4 .rodata
+000023e4 .eh_frame
+000029a4 .data
+000029c0 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 sh.c
+000029c0 buf.1397
+00000000 ulib.c
+00000000 printf.c
+00001ea0 printint
+000023d3 digits.1359
+00000000 umalloc.c
+00002a24 freep
+00002a28 base
+00000000 uspinlock.c
+00001bc0 strcpy
+00001f40 printf
+00001db0 memmove
+00001e2a mknod
+00001360 execcmd
+00001e82 shm_open
+00001cd0 gets
+00001e62 getpid
+00001890 parsepipe
+00001b40 parsecmd
+000014a0 backcmd
+00001630 peek
+00001690 parseredirs
+000014f0 gettoken
+000021c0 malloc
+00001e72 sleep
+000029ac whitespace
+00001190 fork1
+00001a90 nulterminate
+00001df2 pipe
+00001100 getcmd
+00001e02 write
+00001e3a fstat
+00001e12 kill
+00001e52 chdir
+00001910 parseline
+000011b0 runcmd
+000019d0 parseblock
+00001e1a exec
+00001dea wait
+000029a4 symbols
+00001dfa read
+00001770 parseexec
+00001e32 unlink
+000022b0 uacquire
+00001160 panic
+00001dda fork
+00001e6a sbrk
+00001e8a shm_close
+00001e7a uptime
+000029b2 __bss_start
+00001c70 memset
+00001000 main
+00001bf0 strcmp
+00001e5a dup
+00001400 pipecmd
+000013a0 redircmd
+00001d30 stat
+000029b2 _edata
+00002a30 _end
+00001e42 link
+00001de2 exit
+00001d80 atoi
+00001c40 strlen
+00001e22 open
+00001c90 strchr
+00001e4a mkdir
+00001e0a close
+000022d0 urelease
+00001450 listcmd
+00002130 free
diff --git a/shm.c b/shm.c
new file mode 100644
index 0000000..79ccbe9
--- /dev/null
+++ b/shm.c
@@ -0,0 +1,89 @@
+#include "param.h"
+#include "types.h"
+#include "defs.h"
+#include "x86.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "spinlock.h"
+
+struct {
+    struct spinlock lock;
+    struct shm_page {
+        uint id;
+        char *frame;
+        int refcnt;
+    } shm_pages[64];
+} shm_table;
+
+void shminit() {
+    int i;
+    initlock(&(shm_table.lock), "SHM lock");
+    acquire(&(shm_table.lock));
+    for (i = 0; i < 64; i++) {
+        shm_table.shm_pages[i].id = 0;
+        shm_table.shm_pages[i].frame = 0;
+        shm_table.shm_pages[i].refcnt = 0;
+    }
+    release(&(shm_table.lock));
+}
+
+int shm_open(int id, char **pointer) {
+
+    int i;
+    acquire(&(shm_table.lock)); //acquire lock
+    //Case 1:
+    //Iterate 64 pages and check whether segment id  exists
+    for (i = 0; i < 64; i++) {
+        //Found, it exists! ID MATCH
+        if (shm_table.shm_pages[i].id == id) {
+            //Increase ref. count
+            mappages(myproc()->pgdir, (char *) PGROUNDUP(myproc()->sz), PGSIZE, V2P(shm_table.shm_pages[i].frame),
+                     PTE_W | PTE_U);
+            shm_table.shm_pages[i].refcnt++;
+            *pointer = (char *) PGROUNDUP(myproc()->sz); // return ptr
+            myproc()->sz += PGSIZE; //Update process sz too add PG size due to virtual address space being increased
+            release(&(shm_table.lock));
+            return 0; //Break out of loop
+        }
+    }
+    //Case 2: Shared Memoery
+    for (i = 0; i < 64; i++) {
+        if (shm_table.shm_pages[i].id == 0) {
+            shm_table.shm_pages[i].id = id;
+            shm_table.shm_pages[i].frame = kalloc();
+            shm_table.shm_pages[i].refcnt = 1;
+            memset(shm_table.shm_pages[i].frame, 0, PGSIZE);
+            mappages(myproc()->pgdir, (char *) PGROUNDUP(myproc()->sz), PGSIZE, V2P(shm_table.shm_pages[i].frame),
+                     PTE_W | PTE_U);
+            *pointer = (char *) PGROUNDUP(myproc()->sz); // return the ptr
+            myproc()->sz += PGSIZE; //Update process sz too add PG size due to virtual address space being increased
+            release(&(shm_table.lock));
+            return 0; //This does nothing
+        }
+    }
+    release(&(shm_table.lock));
+    return 0;
+}
+
+
+int shm_close(int id) {
+
+    int i;
+    initlock(&(shm_table.lock), "SHM lock"); //reinitialize lock
+    acquire(&(shm_table.lock));
+    for (i = 0; i < 64; i++) {
+        if (shm_table.shm_pages[i].id == id) { //We found page id that matches the one we closing
+            shm_table.shm_pages[i].refcnt--; //Decrease ref count
+            if (shm_table.shm_pages[i].refcnt == 0) { //If ref count is 0, clear table
+                shm_table.shm_pages[i].id = 0;
+                shm_table.shm_pages[i].frame = 0;
+                shm_table.shm_pages[i].refcnt = 0;
+            }
+        }
+    }
+
+
+    release(&(shm_table.lock));
+    return 0; //added to remove compiler warning -- you should decide what to return
+}
diff --git a/shm.d b/shm.d
new file mode 100644
index 0000000..5981dc1
--- /dev/null
+++ b/shm.d
@@ -0,0 +1,2 @@
+shm.o: shm.c /usr/include/stdc-predef.h param.h types.h defs.h x86.h \
+ memlayout.h mmu.h proc.h spinlock.h
diff --git a/shm.o b/shm.o
new file mode 100644
index 0000000..a3974d9
Binary files /dev/null and b/shm.o differ
diff --git a/shm_cnt.asm b/shm_cnt.asm
new file mode 100644
index 0000000..0e7225e
--- /dev/null
+++ b/shm_cnt.asm
@@ -0,0 +1,1289 @@
+
+_shm_cnt:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+   struct uspinlock lock;
+   int cnt;
+};
+
+int main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	57                   	push   %edi
+//which we can now use but will be shared between the two processes
+  
+shm_open(1,(char **)&counter);
+ 
+//  printf(1,"%s returned successfully from shm_open with counter %x\n", pid? "Child": "Parent", counter); 
+  for(i = 0; i < 10000; i++)
+    1004:	31 ff                	xor    %edi,%edi
+{
+    1006:	56                   	push   %esi
+    1007:	53                   	push   %ebx
+     uacquire(&(counter->lock));
+     counter->cnt++;
+     urelease(&(counter->lock));
+
+//print something because we are curious and to give a chance to switch process
+     if(i%1000 == 0)
+    1008:	bb d3 4d 62 10       	mov    $0x10624dd3,%ebx
+{
+    100d:	83 e4 f0             	and    $0xfffffff0,%esp
+    1010:	83 ec 30             	sub    $0x30,%esp
+  pid=fork();
+    1013:	e8 12 03 00 00       	call   132a <fork>
+  sleep(1);
+    1018:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  pid=fork();
+    101f:	89 c6                	mov    %eax,%esi
+  sleep(1);
+    1021:	e8 9c 03 00 00       	call   13c2 <sleep>
+shm_open(1,(char **)&counter);
+    1026:	8d 44 24 2c          	lea    0x2c(%esp),%eax
+    102a:	89 44 24 04          	mov    %eax,0x4(%esp)
+    102e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1035:	e8 98 03 00 00       	call   13d2 <shm_open>
+    103a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+     uacquire(&(counter->lock));
+    1040:	8b 44 24 2c          	mov    0x2c(%esp),%eax
+    1044:	89 04 24             	mov    %eax,(%esp)
+    1047:	e8 b4 07 00 00       	call   1800 <uacquire>
+     counter->cnt++;
+    104c:	8b 44 24 2c          	mov    0x2c(%esp),%eax
+    1050:	83 40 04 01          	addl   $0x1,0x4(%eax)
+     urelease(&(counter->lock));
+    1054:	89 04 24             	mov    %eax,(%esp)
+    1057:	e8 c4 07 00 00       	call   1820 <urelease>
+     if(i%1000 == 0)
+    105c:	89 f8                	mov    %edi,%eax
+    105e:	f7 eb                	imul   %ebx
+    1060:	89 f8                	mov    %edi,%eax
+    1062:	c1 f8 1f             	sar    $0x1f,%eax
+    1065:	c1 fa 06             	sar    $0x6,%edx
+    1068:	29 c2                	sub    %eax,%edx
+    106a:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
+    1070:	39 d7                	cmp    %edx,%edi
+    1072:	75 3e                	jne    10b2 <main+0xb2>
+       printf(1,"Counter in %s is %d at address %x\n",pid? "Parent" : "Child", counter->cnt, counter);
+    1074:	8b 54 24 2c          	mov    0x2c(%esp),%edx
+    1078:	b8 3b 18 00 00       	mov    $0x183b,%eax
+    107d:	85 f6                	test   %esi,%esi
+    107f:	8b 4a 04             	mov    0x4(%edx),%ecx
+    1082:	89 54 24 10          	mov    %edx,0x10(%esp)
+    1086:	c7 44 24 04 74 18 00 	movl   $0x1874,0x4(%esp)
+    108d:	00 
+    108e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1095:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
+    1099:	b9 34 18 00 00       	mov    $0x1834,%ecx
+    109e:	0f 45 c1             	cmovne %ecx,%eax
+    10a1:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
+    10a5:	89 44 24 08          	mov    %eax,0x8(%esp)
+    10a9:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+    10ad:	e8 de 03 00 00       	call   1490 <printf>
+  for(i = 0; i < 10000; i++)
+    10b2:	83 c7 01             	add    $0x1,%edi
+    10b5:	81 ff 10 27 00 00    	cmp    $0x2710,%edi
+    10bb:	75 83                	jne    1040 <main+0x40>
+}
+  
+  if(pid)
+     {
+       printf(1,"Counter in parent is %d\n",counter->cnt);
+    10bd:	8b 44 24 2c          	mov    0x2c(%esp),%eax
+  if(pid)
+    10c1:	85 f6                	test   %esi,%esi
+       printf(1,"Counter in parent is %d\n",counter->cnt);
+    10c3:	8b 40 04             	mov    0x4(%eax),%eax
+    10c6:	89 44 24 08          	mov    %eax,0x8(%esp)
+  if(pid)
+    10ca:	74 2a                	je     10f6 <main+0xf6>
+       printf(1,"Counter in parent is %d\n",counter->cnt);
+    10cc:	c7 44 24 04 41 18 00 	movl   $0x1841,0x4(%esp)
+    10d3:	00 
+    10d4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10db:	e8 b0 03 00 00       	call   1490 <printf>
+    wait();
+    10e0:	e8 55 02 00 00       	call   133a <wait>
+    } else
+    printf(1,"Counter in child is %d\n\n",counter->cnt);
+
+//shm_close: first process will just detach, next one will free up the shm_table entry (but for now not the page)
+   shm_close(1);
+    10e5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10ec:	e8 e9 02 00 00       	call   13da <shm_close>
+   exit();
+    10f1:	e8 3c 02 00 00       	call   1332 <exit>
+    printf(1,"Counter in child is %d\n\n",counter->cnt);
+    10f6:	c7 44 24 04 5a 18 00 	movl   $0x185a,0x4(%esp)
+    10fd:	00 
+    10fe:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1105:	e8 86 03 00 00       	call   1490 <printf>
+    110a:	eb d9                	jmp    10e5 <main+0xe5>
+    110c:	66 90                	xchg   %ax,%ax
+    110e:	66 90                	xchg   %ax,%ax
+
+00001110 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1110:	55                   	push   %ebp
+    1111:	89 e5                	mov    %esp,%ebp
+    1113:	8b 45 08             	mov    0x8(%ebp),%eax
+    1116:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1119:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    111a:	89 c2                	mov    %eax,%edx
+    111c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1120:	83 c1 01             	add    $0x1,%ecx
+    1123:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1127:	83 c2 01             	add    $0x1,%edx
+    112a:	84 db                	test   %bl,%bl
+    112c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    112f:	75 ef                	jne    1120 <strcpy+0x10>
+    ;
+  return os;
+}
+    1131:	5b                   	pop    %ebx
+    1132:	5d                   	pop    %ebp
+    1133:	c3                   	ret    
+    1134:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    113a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001140 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1140:	55                   	push   %ebp
+    1141:	89 e5                	mov    %esp,%ebp
+    1143:	8b 55 08             	mov    0x8(%ebp),%edx
+    1146:	53                   	push   %ebx
+    1147:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    114a:	0f b6 02             	movzbl (%edx),%eax
+    114d:	84 c0                	test   %al,%al
+    114f:	74 2d                	je     117e <strcmp+0x3e>
+    1151:	0f b6 19             	movzbl (%ecx),%ebx
+    1154:	38 d8                	cmp    %bl,%al
+    1156:	74 0e                	je     1166 <strcmp+0x26>
+    1158:	eb 2b                	jmp    1185 <strcmp+0x45>
+    115a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1160:	38 c8                	cmp    %cl,%al
+    1162:	75 15                	jne    1179 <strcmp+0x39>
+    p++, q++;
+    1164:	89 d9                	mov    %ebx,%ecx
+    1166:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    1169:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    116c:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    116f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    1173:	84 c0                	test   %al,%al
+    1175:	75 e9                	jne    1160 <strcmp+0x20>
+    1177:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    1179:	29 c8                	sub    %ecx,%eax
+}
+    117b:	5b                   	pop    %ebx
+    117c:	5d                   	pop    %ebp
+    117d:	c3                   	ret    
+    117e:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    1181:	31 c0                	xor    %eax,%eax
+    1183:	eb f4                	jmp    1179 <strcmp+0x39>
+    1185:	0f b6 cb             	movzbl %bl,%ecx
+    1188:	eb ef                	jmp    1179 <strcmp+0x39>
+    118a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001190 <strlen>:
+
+uint
+strlen(char *s)
+{
+    1190:	55                   	push   %ebp
+    1191:	89 e5                	mov    %esp,%ebp
+    1193:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    1196:	80 39 00             	cmpb   $0x0,(%ecx)
+    1199:	74 12                	je     11ad <strlen+0x1d>
+    119b:	31 d2                	xor    %edx,%edx
+    119d:	8d 76 00             	lea    0x0(%esi),%esi
+    11a0:	83 c2 01             	add    $0x1,%edx
+    11a3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    11a7:	89 d0                	mov    %edx,%eax
+    11a9:	75 f5                	jne    11a0 <strlen+0x10>
+    ;
+  return n;
+}
+    11ab:	5d                   	pop    %ebp
+    11ac:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    11ad:	31 c0                	xor    %eax,%eax
+}
+    11af:	5d                   	pop    %ebp
+    11b0:	c3                   	ret    
+    11b1:	eb 0d                	jmp    11c0 <memset>
+    11b3:	90                   	nop
+    11b4:	90                   	nop
+    11b5:	90                   	nop
+    11b6:	90                   	nop
+    11b7:	90                   	nop
+    11b8:	90                   	nop
+    11b9:	90                   	nop
+    11ba:	90                   	nop
+    11bb:	90                   	nop
+    11bc:	90                   	nop
+    11bd:	90                   	nop
+    11be:	90                   	nop
+    11bf:	90                   	nop
+
+000011c0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    11c0:	55                   	push   %ebp
+    11c1:	89 e5                	mov    %esp,%ebp
+    11c3:	8b 55 08             	mov    0x8(%ebp),%edx
+    11c6:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    11c7:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    11ca:	8b 45 0c             	mov    0xc(%ebp),%eax
+    11cd:	89 d7                	mov    %edx,%edi
+    11cf:	fc                   	cld    
+    11d0:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    11d2:	89 d0                	mov    %edx,%eax
+    11d4:	5f                   	pop    %edi
+    11d5:	5d                   	pop    %ebp
+    11d6:	c3                   	ret    
+    11d7:	89 f6                	mov    %esi,%esi
+    11d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+000011e0 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    11e0:	55                   	push   %ebp
+    11e1:	89 e5                	mov    %esp,%ebp
+    11e3:	8b 45 08             	mov    0x8(%ebp),%eax
+    11e6:	53                   	push   %ebx
+    11e7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    11ea:	0f b6 18             	movzbl (%eax),%ebx
+    11ed:	84 db                	test   %bl,%bl
+    11ef:	74 1d                	je     120e <strchr+0x2e>
+    if(*s == c)
+    11f1:	38 d3                	cmp    %dl,%bl
+    11f3:	89 d1                	mov    %edx,%ecx
+    11f5:	75 0d                	jne    1204 <strchr+0x24>
+    11f7:	eb 17                	jmp    1210 <strchr+0x30>
+    11f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1200:	38 ca                	cmp    %cl,%dl
+    1202:	74 0c                	je     1210 <strchr+0x30>
+  for(; *s; s++)
+    1204:	83 c0 01             	add    $0x1,%eax
+    1207:	0f b6 10             	movzbl (%eax),%edx
+    120a:	84 d2                	test   %dl,%dl
+    120c:	75 f2                	jne    1200 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    120e:	31 c0                	xor    %eax,%eax
+}
+    1210:	5b                   	pop    %ebx
+    1211:	5d                   	pop    %ebp
+    1212:	c3                   	ret    
+    1213:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001220 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1220:	55                   	push   %ebp
+    1221:	89 e5                	mov    %esp,%ebp
+    1223:	57                   	push   %edi
+    1224:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1225:	31 f6                	xor    %esi,%esi
+{
+    1227:	53                   	push   %ebx
+    1228:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    122b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    122e:	eb 31                	jmp    1261 <gets+0x41>
+    cc = read(0, &c, 1);
+    1230:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1237:	00 
+    1238:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    123c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1243:	e8 02 01 00 00       	call   134a <read>
+    if(cc < 1)
+    1248:	85 c0                	test   %eax,%eax
+    124a:	7e 1d                	jle    1269 <gets+0x49>
+      break;
+    buf[i++] = c;
+    124c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    1250:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    1252:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    1255:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    1257:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    125b:	74 0c                	je     1269 <gets+0x49>
+    125d:	3c 0a                	cmp    $0xa,%al
+    125f:	74 08                	je     1269 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    1261:	8d 5e 01             	lea    0x1(%esi),%ebx
+    1264:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    1267:	7c c7                	jl     1230 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    1269:	8b 45 08             	mov    0x8(%ebp),%eax
+    126c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    1270:	83 c4 2c             	add    $0x2c,%esp
+    1273:	5b                   	pop    %ebx
+    1274:	5e                   	pop    %esi
+    1275:	5f                   	pop    %edi
+    1276:	5d                   	pop    %ebp
+    1277:	c3                   	ret    
+    1278:	90                   	nop
+    1279:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001280 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    1280:	55                   	push   %ebp
+    1281:	89 e5                	mov    %esp,%ebp
+    1283:	56                   	push   %esi
+    1284:	53                   	push   %ebx
+    1285:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    1288:	8b 45 08             	mov    0x8(%ebp),%eax
+    128b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1292:	00 
+    1293:	89 04 24             	mov    %eax,(%esp)
+    1296:	e8 d7 00 00 00       	call   1372 <open>
+  if(fd < 0)
+    129b:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    129d:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    129f:	78 27                	js     12c8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    12a1:	8b 45 0c             	mov    0xc(%ebp),%eax
+    12a4:	89 1c 24             	mov    %ebx,(%esp)
+    12a7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    12ab:	e8 da 00 00 00       	call   138a <fstat>
+  close(fd);
+    12b0:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    12b3:	89 c6                	mov    %eax,%esi
+  close(fd);
+    12b5:	e8 a0 00 00 00       	call   135a <close>
+  return r;
+    12ba:	89 f0                	mov    %esi,%eax
+}
+    12bc:	83 c4 10             	add    $0x10,%esp
+    12bf:	5b                   	pop    %ebx
+    12c0:	5e                   	pop    %esi
+    12c1:	5d                   	pop    %ebp
+    12c2:	c3                   	ret    
+    12c3:	90                   	nop
+    12c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    12c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    12cd:	eb ed                	jmp    12bc <stat+0x3c>
+    12cf:	90                   	nop
+
+000012d0 <atoi>:
+
+int
+atoi(const char *s)
+{
+    12d0:	55                   	push   %ebp
+    12d1:	89 e5                	mov    %esp,%ebp
+    12d3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    12d6:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    12d7:	0f be 11             	movsbl (%ecx),%edx
+    12da:	8d 42 d0             	lea    -0x30(%edx),%eax
+    12dd:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    12df:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    12e4:	77 17                	ja     12fd <atoi+0x2d>
+    12e6:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    12e8:	83 c1 01             	add    $0x1,%ecx
+    12eb:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    12ee:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    12f2:	0f be 11             	movsbl (%ecx),%edx
+    12f5:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    12f8:	80 fb 09             	cmp    $0x9,%bl
+    12fb:	76 eb                	jbe    12e8 <atoi+0x18>
+  return n;
+}
+    12fd:	5b                   	pop    %ebx
+    12fe:	5d                   	pop    %ebp
+    12ff:	c3                   	ret    
+
+00001300 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1300:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1301:	31 d2                	xor    %edx,%edx
+{
+    1303:	89 e5                	mov    %esp,%ebp
+    1305:	56                   	push   %esi
+    1306:	8b 45 08             	mov    0x8(%ebp),%eax
+    1309:	53                   	push   %ebx
+    130a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    130d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1310:	85 db                	test   %ebx,%ebx
+    1312:	7e 12                	jle    1326 <memmove+0x26>
+    1314:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1318:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    131c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    131f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1322:	39 da                	cmp    %ebx,%edx
+    1324:	75 f2                	jne    1318 <memmove+0x18>
+  return vdst;
+}
+    1326:	5b                   	pop    %ebx
+    1327:	5e                   	pop    %esi
+    1328:	5d                   	pop    %ebp
+    1329:	c3                   	ret    
+
+0000132a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    132a:	b8 01 00 00 00       	mov    $0x1,%eax
+    132f:	cd 40                	int    $0x40
+    1331:	c3                   	ret    
+
+00001332 <exit>:
+SYSCALL(exit)
+    1332:	b8 02 00 00 00       	mov    $0x2,%eax
+    1337:	cd 40                	int    $0x40
+    1339:	c3                   	ret    
+
+0000133a <wait>:
+SYSCALL(wait)
+    133a:	b8 03 00 00 00       	mov    $0x3,%eax
+    133f:	cd 40                	int    $0x40
+    1341:	c3                   	ret    
+
+00001342 <pipe>:
+SYSCALL(pipe)
+    1342:	b8 04 00 00 00       	mov    $0x4,%eax
+    1347:	cd 40                	int    $0x40
+    1349:	c3                   	ret    
+
+0000134a <read>:
+SYSCALL(read)
+    134a:	b8 05 00 00 00       	mov    $0x5,%eax
+    134f:	cd 40                	int    $0x40
+    1351:	c3                   	ret    
+
+00001352 <write>:
+SYSCALL(write)
+    1352:	b8 10 00 00 00       	mov    $0x10,%eax
+    1357:	cd 40                	int    $0x40
+    1359:	c3                   	ret    
+
+0000135a <close>:
+SYSCALL(close)
+    135a:	b8 15 00 00 00       	mov    $0x15,%eax
+    135f:	cd 40                	int    $0x40
+    1361:	c3                   	ret    
+
+00001362 <kill>:
+SYSCALL(kill)
+    1362:	b8 06 00 00 00       	mov    $0x6,%eax
+    1367:	cd 40                	int    $0x40
+    1369:	c3                   	ret    
+
+0000136a <exec>:
+SYSCALL(exec)
+    136a:	b8 07 00 00 00       	mov    $0x7,%eax
+    136f:	cd 40                	int    $0x40
+    1371:	c3                   	ret    
+
+00001372 <open>:
+SYSCALL(open)
+    1372:	b8 0f 00 00 00       	mov    $0xf,%eax
+    1377:	cd 40                	int    $0x40
+    1379:	c3                   	ret    
+
+0000137a <mknod>:
+SYSCALL(mknod)
+    137a:	b8 11 00 00 00       	mov    $0x11,%eax
+    137f:	cd 40                	int    $0x40
+    1381:	c3                   	ret    
+
+00001382 <unlink>:
+SYSCALL(unlink)
+    1382:	b8 12 00 00 00       	mov    $0x12,%eax
+    1387:	cd 40                	int    $0x40
+    1389:	c3                   	ret    
+
+0000138a <fstat>:
+SYSCALL(fstat)
+    138a:	b8 08 00 00 00       	mov    $0x8,%eax
+    138f:	cd 40                	int    $0x40
+    1391:	c3                   	ret    
+
+00001392 <link>:
+SYSCALL(link)
+    1392:	b8 13 00 00 00       	mov    $0x13,%eax
+    1397:	cd 40                	int    $0x40
+    1399:	c3                   	ret    
+
+0000139a <mkdir>:
+SYSCALL(mkdir)
+    139a:	b8 14 00 00 00       	mov    $0x14,%eax
+    139f:	cd 40                	int    $0x40
+    13a1:	c3                   	ret    
+
+000013a2 <chdir>:
+SYSCALL(chdir)
+    13a2:	b8 09 00 00 00       	mov    $0x9,%eax
+    13a7:	cd 40                	int    $0x40
+    13a9:	c3                   	ret    
+
+000013aa <dup>:
+SYSCALL(dup)
+    13aa:	b8 0a 00 00 00       	mov    $0xa,%eax
+    13af:	cd 40                	int    $0x40
+    13b1:	c3                   	ret    
+
+000013b2 <getpid>:
+SYSCALL(getpid)
+    13b2:	b8 0b 00 00 00       	mov    $0xb,%eax
+    13b7:	cd 40                	int    $0x40
+    13b9:	c3                   	ret    
+
+000013ba <sbrk>:
+SYSCALL(sbrk)
+    13ba:	b8 0c 00 00 00       	mov    $0xc,%eax
+    13bf:	cd 40                	int    $0x40
+    13c1:	c3                   	ret    
+
+000013c2 <sleep>:
+SYSCALL(sleep)
+    13c2:	b8 0d 00 00 00       	mov    $0xd,%eax
+    13c7:	cd 40                	int    $0x40
+    13c9:	c3                   	ret    
+
+000013ca <uptime>:
+SYSCALL(uptime)
+    13ca:	b8 0e 00 00 00       	mov    $0xe,%eax
+    13cf:	cd 40                	int    $0x40
+    13d1:	c3                   	ret    
+
+000013d2 <shm_open>:
+SYSCALL(shm_open)
+    13d2:	b8 16 00 00 00       	mov    $0x16,%eax
+    13d7:	cd 40                	int    $0x40
+    13d9:	c3                   	ret    
+
+000013da <shm_close>:
+SYSCALL(shm_close)	
+    13da:	b8 17 00 00 00       	mov    $0x17,%eax
+    13df:	cd 40                	int    $0x40
+    13e1:	c3                   	ret    
+    13e2:	66 90                	xchg   %ax,%ax
+    13e4:	66 90                	xchg   %ax,%ax
+    13e6:	66 90                	xchg   %ax,%ax
+    13e8:	66 90                	xchg   %ax,%ax
+    13ea:	66 90                	xchg   %ax,%ax
+    13ec:	66 90                	xchg   %ax,%ax
+    13ee:	66 90                	xchg   %ax,%ax
+
+000013f0 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    13f0:	55                   	push   %ebp
+    13f1:	89 e5                	mov    %esp,%ebp
+    13f3:	57                   	push   %edi
+    13f4:	56                   	push   %esi
+    13f5:	89 c6                	mov    %eax,%esi
+    13f7:	53                   	push   %ebx
+    13f8:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    13fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    13fe:	85 db                	test   %ebx,%ebx
+    1400:	74 09                	je     140b <printint+0x1b>
+    1402:	89 d0                	mov    %edx,%eax
+    1404:	c1 e8 1f             	shr    $0x1f,%eax
+    1407:	84 c0                	test   %al,%al
+    1409:	75 75                	jne    1480 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    140b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    140d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1414:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1417:	31 ff                	xor    %edi,%edi
+    1419:	89 ce                	mov    %ecx,%esi
+    141b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    141e:	eb 02                	jmp    1422 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1420:	89 cf                	mov    %ecx,%edi
+    1422:	31 d2                	xor    %edx,%edx
+    1424:	f7 f6                	div    %esi
+    1426:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1429:	0f b6 92 9f 18 00 00 	movzbl 0x189f(%edx),%edx
+  }while((x /= base) != 0);
+    1430:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1432:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1435:	75 e9                	jne    1420 <printint+0x30>
+  if(neg)
+    1437:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    143a:	89 c8                	mov    %ecx,%eax
+    143c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    143f:	85 d2                	test   %edx,%edx
+    1441:	74 08                	je     144b <printint+0x5b>
+    buf[i++] = '-';
+    1443:	8d 4f 02             	lea    0x2(%edi),%ecx
+    1446:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    144b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    144e:	66 90                	xchg   %ax,%ax
+    1450:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    1455:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    1458:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    145f:	00 
+    1460:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1464:	89 34 24             	mov    %esi,(%esp)
+    1467:	88 45 d7             	mov    %al,-0x29(%ebp)
+    146a:	e8 e3 fe ff ff       	call   1352 <write>
+  while(--i >= 0)
+    146f:	83 ff ff             	cmp    $0xffffffff,%edi
+    1472:	75 dc                	jne    1450 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    1474:	83 c4 4c             	add    $0x4c,%esp
+    1477:	5b                   	pop    %ebx
+    1478:	5e                   	pop    %esi
+    1479:	5f                   	pop    %edi
+    147a:	5d                   	pop    %ebp
+    147b:	c3                   	ret    
+    147c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    1480:	89 d0                	mov    %edx,%eax
+    1482:	f7 d8                	neg    %eax
+    neg = 1;
+    1484:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    148b:	eb 87                	jmp    1414 <printint+0x24>
+    148d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00001490 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    1490:	55                   	push   %ebp
+    1491:	89 e5                	mov    %esp,%ebp
+    1493:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    1494:	31 ff                	xor    %edi,%edi
+{
+    1496:	56                   	push   %esi
+    1497:	53                   	push   %ebx
+    1498:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    149b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    149e:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    14a1:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    14a4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    14a7:	0f b6 13             	movzbl (%ebx),%edx
+    14aa:	83 c3 01             	add    $0x1,%ebx
+    14ad:	84 d2                	test   %dl,%dl
+    14af:	75 39                	jne    14ea <printf+0x5a>
+    14b1:	e9 c2 00 00 00       	jmp    1578 <printf+0xe8>
+    14b6:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    14b8:	83 fa 25             	cmp    $0x25,%edx
+    14bb:	0f 84 bf 00 00 00    	je     1580 <printf+0xf0>
+  write(fd, &c, 1);
+    14c1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    14c4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14cb:	00 
+    14cc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    14d0:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    14d3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    14d6:	e8 77 fe ff ff       	call   1352 <write>
+    14db:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    14de:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    14e2:	84 d2                	test   %dl,%dl
+    14e4:	0f 84 8e 00 00 00    	je     1578 <printf+0xe8>
+    if(state == 0){
+    14ea:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    14ec:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    14ef:	74 c7                	je     14b8 <printf+0x28>
+      }
+    } else if(state == '%'){
+    14f1:	83 ff 25             	cmp    $0x25,%edi
+    14f4:	75 e5                	jne    14db <printf+0x4b>
+      if(c == 'd'){
+    14f6:	83 fa 64             	cmp    $0x64,%edx
+    14f9:	0f 84 31 01 00 00    	je     1630 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    14ff:	25 f7 00 00 00       	and    $0xf7,%eax
+    1504:	83 f8 70             	cmp    $0x70,%eax
+    1507:	0f 84 83 00 00 00    	je     1590 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    150d:	83 fa 73             	cmp    $0x73,%edx
+    1510:	0f 84 a2 00 00 00    	je     15b8 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1516:	83 fa 63             	cmp    $0x63,%edx
+    1519:	0f 84 35 01 00 00    	je     1654 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    151f:	83 fa 25             	cmp    $0x25,%edx
+    1522:	0f 84 e0 00 00 00    	je     1608 <printf+0x178>
+  write(fd, &c, 1);
+    1528:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    152b:	83 c3 01             	add    $0x1,%ebx
+    152e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1535:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    1536:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    1538:	89 44 24 04          	mov    %eax,0x4(%esp)
+    153c:	89 34 24             	mov    %esi,(%esp)
+    153f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    1542:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    1546:	e8 07 fe ff ff       	call   1352 <write>
+        putc(fd, c);
+    154b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    154e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    1551:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1558:	00 
+    1559:	89 44 24 04          	mov    %eax,0x4(%esp)
+    155d:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    1560:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    1563:	e8 ea fd ff ff       	call   1352 <write>
+  for(i = 0; fmt[i]; i++){
+    1568:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    156c:	84 d2                	test   %dl,%dl
+    156e:	0f 85 76 ff ff ff    	jne    14ea <printf+0x5a>
+    1574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    1578:	83 c4 3c             	add    $0x3c,%esp
+    157b:	5b                   	pop    %ebx
+    157c:	5e                   	pop    %esi
+    157d:	5f                   	pop    %edi
+    157e:	5d                   	pop    %ebp
+    157f:	c3                   	ret    
+        state = '%';
+    1580:	bf 25 00 00 00       	mov    $0x25,%edi
+    1585:	e9 51 ff ff ff       	jmp    14db <printf+0x4b>
+    158a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    1590:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1593:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    1598:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    159a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    15a1:	8b 10                	mov    (%eax),%edx
+    15a3:	89 f0                	mov    %esi,%eax
+    15a5:	e8 46 fe ff ff       	call   13f0 <printint>
+        ap++;
+    15aa:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15ae:	e9 28 ff ff ff       	jmp    14db <printf+0x4b>
+    15b3:	90                   	nop
+    15b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    15b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    15bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    15bf:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    15c1:	b8 98 18 00 00       	mov    $0x1898,%eax
+    15c6:	85 ff                	test   %edi,%edi
+    15c8:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    15cb:	0f b6 07             	movzbl (%edi),%eax
+    15ce:	84 c0                	test   %al,%al
+    15d0:	74 2a                	je     15fc <printf+0x16c>
+    15d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    15d8:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    15db:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    15de:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    15e1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    15e8:	00 
+    15e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15ed:	89 34 24             	mov    %esi,(%esp)
+    15f0:	e8 5d fd ff ff       	call   1352 <write>
+        while(*s != 0){
+    15f5:	0f b6 07             	movzbl (%edi),%eax
+    15f8:	84 c0                	test   %al,%al
+    15fa:	75 dc                	jne    15d8 <printf+0x148>
+      state = 0;
+    15fc:	31 ff                	xor    %edi,%edi
+    15fe:	e9 d8 fe ff ff       	jmp    14db <printf+0x4b>
+    1603:	90                   	nop
+    1604:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1608:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    160b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    160d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1614:	00 
+    1615:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1619:	89 34 24             	mov    %esi,(%esp)
+    161c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1620:	e8 2d fd ff ff       	call   1352 <write>
+    1625:	e9 b1 fe ff ff       	jmp    14db <printf+0x4b>
+    162a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    1630:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1633:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    1638:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    163b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1642:	8b 10                	mov    (%eax),%edx
+    1644:	89 f0                	mov    %esi,%eax
+    1646:	e8 a5 fd ff ff       	call   13f0 <printint>
+        ap++;
+    164b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    164f:	e9 87 fe ff ff       	jmp    14db <printf+0x4b>
+        putc(fd, *ap);
+    1654:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    1657:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    1659:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    165b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1662:	00 
+    1663:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    1666:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    1669:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    166c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1670:	e8 dd fc ff ff       	call   1352 <write>
+        ap++;
+    1675:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    1679:	e9 5d fe ff ff       	jmp    14db <printf+0x4b>
+    167e:	66 90                	xchg   %ax,%ax
+
+00001680 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    1680:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1681:	a1 5c 1b 00 00       	mov    0x1b5c,%eax
+{
+    1686:	89 e5                	mov    %esp,%ebp
+    1688:	57                   	push   %edi
+    1689:	56                   	push   %esi
+    168a:	53                   	push   %ebx
+    168b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    168e:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    1690:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1693:	39 d0                	cmp    %edx,%eax
+    1695:	72 11                	jb     16a8 <free+0x28>
+    1697:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1698:	39 c8                	cmp    %ecx,%eax
+    169a:	72 04                	jb     16a0 <free+0x20>
+    169c:	39 ca                	cmp    %ecx,%edx
+    169e:	72 10                	jb     16b0 <free+0x30>
+    16a0:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16a2:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16a4:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16a6:	73 f0                	jae    1698 <free+0x18>
+    16a8:	39 ca                	cmp    %ecx,%edx
+    16aa:	72 04                	jb     16b0 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16ac:	39 c8                	cmp    %ecx,%eax
+    16ae:	72 f0                	jb     16a0 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    16b0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    16b3:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    16b6:	39 cf                	cmp    %ecx,%edi
+    16b8:	74 1e                	je     16d8 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    16ba:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    16bd:	8b 48 04             	mov    0x4(%eax),%ecx
+    16c0:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    16c3:	39 f2                	cmp    %esi,%edx
+    16c5:	74 28                	je     16ef <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    16c7:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    16c9:	a3 5c 1b 00 00       	mov    %eax,0x1b5c
+}
+    16ce:	5b                   	pop    %ebx
+    16cf:	5e                   	pop    %esi
+    16d0:	5f                   	pop    %edi
+    16d1:	5d                   	pop    %ebp
+    16d2:	c3                   	ret    
+    16d3:	90                   	nop
+    16d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    16d8:	03 71 04             	add    0x4(%ecx),%esi
+    16db:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    16de:	8b 08                	mov    (%eax),%ecx
+    16e0:	8b 09                	mov    (%ecx),%ecx
+    16e2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    16e5:	8b 48 04             	mov    0x4(%eax),%ecx
+    16e8:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    16eb:	39 f2                	cmp    %esi,%edx
+    16ed:	75 d8                	jne    16c7 <free+0x47>
+    p->s.size += bp->s.size;
+    16ef:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    16f2:	a3 5c 1b 00 00       	mov    %eax,0x1b5c
+    p->s.size += bp->s.size;
+    16f7:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    16fa:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    16fd:	89 10                	mov    %edx,(%eax)
+}
+    16ff:	5b                   	pop    %ebx
+    1700:	5e                   	pop    %esi
+    1701:	5f                   	pop    %edi
+    1702:	5d                   	pop    %ebp
+    1703:	c3                   	ret    
+    1704:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    170a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001710 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1710:	55                   	push   %ebp
+    1711:	89 e5                	mov    %esp,%ebp
+    1713:	57                   	push   %edi
+    1714:	56                   	push   %esi
+    1715:	53                   	push   %ebx
+    1716:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1719:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    171c:	8b 1d 5c 1b 00 00    	mov    0x1b5c,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1722:	8d 48 07             	lea    0x7(%eax),%ecx
+    1725:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1728:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    172a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    172d:	0f 84 9b 00 00 00    	je     17ce <malloc+0xbe>
+    1733:	8b 13                	mov    (%ebx),%edx
+    1735:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    1738:	39 fe                	cmp    %edi,%esi
+    173a:	76 64                	jbe    17a0 <malloc+0x90>
+    173c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    1743:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    1748:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    174b:	eb 0e                	jmp    175b <malloc+0x4b>
+    174d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1750:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    1752:	8b 78 04             	mov    0x4(%eax),%edi
+    1755:	39 fe                	cmp    %edi,%esi
+    1757:	76 4f                	jbe    17a8 <malloc+0x98>
+    1759:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    175b:	3b 15 5c 1b 00 00    	cmp    0x1b5c,%edx
+    1761:	75 ed                	jne    1750 <malloc+0x40>
+  if(nu < 4096)
+    1763:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1766:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    176c:	bf 00 10 00 00       	mov    $0x1000,%edi
+    1771:	0f 43 fe             	cmovae %esi,%edi
+    1774:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    1777:	89 04 24             	mov    %eax,(%esp)
+    177a:	e8 3b fc ff ff       	call   13ba <sbrk>
+  if(p == (char*)-1)
+    177f:	83 f8 ff             	cmp    $0xffffffff,%eax
+    1782:	74 18                	je     179c <malloc+0x8c>
+  hp->s.size = nu;
+    1784:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    1787:	83 c0 08             	add    $0x8,%eax
+    178a:	89 04 24             	mov    %eax,(%esp)
+    178d:	e8 ee fe ff ff       	call   1680 <free>
+  return freep;
+    1792:	8b 15 5c 1b 00 00    	mov    0x1b5c,%edx
+      if((p = morecore(nunits)) == 0)
+    1798:	85 d2                	test   %edx,%edx
+    179a:	75 b4                	jne    1750 <malloc+0x40>
+        return 0;
+    179c:	31 c0                	xor    %eax,%eax
+    179e:	eb 20                	jmp    17c0 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    17a0:	89 d0                	mov    %edx,%eax
+    17a2:	89 da                	mov    %ebx,%edx
+    17a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    17a8:	39 fe                	cmp    %edi,%esi
+    17aa:	74 1c                	je     17c8 <malloc+0xb8>
+        p->s.size -= nunits;
+    17ac:	29 f7                	sub    %esi,%edi
+    17ae:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    17b1:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    17b4:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    17b7:	89 15 5c 1b 00 00    	mov    %edx,0x1b5c
+      return (void*)(p + 1);
+    17bd:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    17c0:	83 c4 1c             	add    $0x1c,%esp
+    17c3:	5b                   	pop    %ebx
+    17c4:	5e                   	pop    %esi
+    17c5:	5f                   	pop    %edi
+    17c6:	5d                   	pop    %ebp
+    17c7:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    17c8:	8b 08                	mov    (%eax),%ecx
+    17ca:	89 0a                	mov    %ecx,(%edx)
+    17cc:	eb e9                	jmp    17b7 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    17ce:	c7 05 5c 1b 00 00 60 	movl   $0x1b60,0x1b5c
+    17d5:	1b 00 00 
+    base.s.size = 0;
+    17d8:	ba 60 1b 00 00       	mov    $0x1b60,%edx
+    base.s.ptr = freep = prevp = &base;
+    17dd:	c7 05 60 1b 00 00 60 	movl   $0x1b60,0x1b60
+    17e4:	1b 00 00 
+    base.s.size = 0;
+    17e7:	c7 05 64 1b 00 00 00 	movl   $0x0,0x1b64
+    17ee:	00 00 00 
+    17f1:	e9 46 ff ff ff       	jmp    173c <malloc+0x2c>
+    17f6:	66 90                	xchg   %ax,%ax
+    17f8:	66 90                	xchg   %ax,%ax
+    17fa:	66 90                	xchg   %ax,%ax
+    17fc:	66 90                	xchg   %ax,%ax
+    17fe:	66 90                	xchg   %ax,%ax
+
+00001800 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1800:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1801:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1806:	89 e5                	mov    %esp,%ebp
+    1808:	8b 55 08             	mov    0x8(%ebp),%edx
+    180b:	90                   	nop
+    180c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1810:	89 c8                	mov    %ecx,%eax
+    1812:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1815:	85 c0                	test   %eax,%eax
+    1817:	75 f7                	jne    1810 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1819:	0f ae f0             	mfence 
+}
+    181c:	5d                   	pop    %ebp
+    181d:	c3                   	ret    
+    181e:	66 90                	xchg   %ax,%ax
+
+00001820 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1820:	55                   	push   %ebp
+    1821:	89 e5                	mov    %esp,%ebp
+    1823:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1826:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1829:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    182f:	5d                   	pop    %ebp
+    1830:	c3                   	ret    
diff --git a/shm_cnt.c b/shm_cnt.c
new file mode 100644
index 0000000..1661d22
--- /dev/null
+++ b/shm_cnt.c
@@ -0,0 +1,48 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "uspinlock.h"
+
+struct shm_cnt {
+   struct uspinlock lock;
+   int cnt;
+};
+
+int main(int argc, char *argv[])
+{
+int pid;
+int i=0;
+struct shm_cnt *counter;
+  pid=fork();
+  sleep(1);
+
+//shm_open: first process will create the page, the second will just attach to the same page
+//we get the virtual address of the page returned into counter
+//which we can now use but will be shared between the two processes
+  
+shm_open(1,(char **)&counter);
+ 
+//  printf(1,"%s returned successfully from shm_open with counter %x\n", pid? "Child": "Parent", counter); 
+  for(i = 0; i < 10000; i++)
+    {
+     uacquire(&(counter->lock));
+     counter->cnt++;
+     urelease(&(counter->lock));
+
+//print something because we are curious and to give a chance to switch process
+     if(i%1000 == 0)
+       printf(1,"Counter in %s is %d at address %x\n",pid? "Parent" : "Child", counter->cnt, counter);
+}
+  
+  if(pid)
+     {
+       printf(1,"Counter in parent is %d\n",counter->cnt);
+    wait();
+    } else
+    printf(1,"Counter in child is %d\n\n",counter->cnt);
+
+//shm_close: first process will just detach, next one will free up the shm_table entry (but for now not the page)
+   shm_close(1);
+   exit();
+   return 0;
+}
diff --git a/shm_cnt.d b/shm_cnt.d
new file mode 100644
index 0000000..2c6a154
--- /dev/null
+++ b/shm_cnt.d
@@ -0,0 +1,2 @@
+shm_cnt.o: shm_cnt.c /usr/include/stdc-predef.h types.h stat.h user.h \
+ uspinlock.h
diff --git a/shm_cnt.o b/shm_cnt.o
new file mode 100644
index 0000000..2ce5c80
Binary files /dev/null and b/shm_cnt.o differ
diff --git a/shm_cnt.sym b/shm_cnt.sym
new file mode 100644
index 0000000..7a7eed8
--- /dev/null
+++ b/shm_cnt.sym
@@ -0,0 +1,62 @@
+00001000 .text
+00001834 .rodata
+000018b0 .eh_frame
+00001b5c .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 shm_cnt.c
+00000000 ulib.c
+00000000 printf.c
+000013f0 printint
+0000189f digits.1359
+00000000 umalloc.c
+00001b5c freep
+00001b60 base
+00000000 uspinlock.c
+00001110 strcpy
+00001490 printf
+00001300 memmove
+0000137a mknod
+000013d2 shm_open
+00001220 gets
+000013b2 getpid
+00001710 malloc
+000013c2 sleep
+00001342 pipe
+00001352 write
+0000138a fstat
+00001362 kill
+000013a2 chdir
+0000136a exec
+0000133a wait
+0000134a read
+00001382 unlink
+00001800 uacquire
+0000132a fork
+000013ba sbrk
+000013da shm_close
+000013ca uptime
+00001b5c __bss_start
+000011c0 memset
+00001000 main
+00001140 strcmp
+000013aa dup
+00001280 stat
+00001b5c _edata
+00001b68 _end
+00001392 link
+00001332 exit
+000012d0 atoi
+00001190 strlen
+00001372 open
+000011e0 strchr
+0000139a mkdir
+0000135a close
+00001820 urelease
+00001680 free
diff --git a/sleeplock.c b/sleeplock.c
index e0750ea..d0e4d91 100644
--- a/sleeplock.c
+++ b/sleeplock.c
@@ -47,7 +47,7 @@ holdingsleep(struct sleeplock *lk)
   int r;
   
   acquire(&lk->lk);
-  r = lk->locked && (lk->pid == myproc()->pid);
+  r = lk->locked;
   release(&lk->lk);
   return r;
 }
diff --git a/sleeplock.d b/sleeplock.d
new file mode 100644
index 0000000..e50551a
--- /dev/null
+++ b/sleeplock.d
@@ -0,0 +1,2 @@
+sleeplock.o: sleeplock.c /usr/include/stdc-predef.h types.h defs.h \
+ param.h x86.h memlayout.h mmu.h proc.h spinlock.h sleeplock.h
diff --git a/sleeplock.o b/sleeplock.o
new file mode 100644
index 0000000..5c98a16
Binary files /dev/null and b/sleeplock.o differ
diff --git a/spinlock.c b/spinlock.c
index 4020186..9120bf2 100644
--- a/spinlock.c
+++ b/spinlock.c
@@ -89,11 +89,7 @@ getcallerpcs(void *v, uint pcs[])
 int
 holding(struct spinlock *lock)
 {
-  int r;
-  pushcli();
-  r = lock->locked && lock->cpu == mycpu();
-  popcli();
-  return r;
+  return lock->locked && lock->cpu == mycpu();
 }
 
 
diff --git a/spinlock.d b/spinlock.d
new file mode 100644
index 0000000..9f70952
--- /dev/null
+++ b/spinlock.d
@@ -0,0 +1,2 @@
+spinlock.o: spinlock.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ x86.h memlayout.h mmu.h proc.h spinlock.h
diff --git a/spinlock.o b/spinlock.o
new file mode 100644
index 0000000..1ebcdd9
Binary files /dev/null and b/spinlock.o differ
diff --git a/stressfs.asm b/stressfs.asm
new file mode 100644
index 0000000..674ff86
--- /dev/null
+++ b/stressfs.asm
@@ -0,0 +1,1309 @@
+
+_stressfs:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+#include "fs.h"
+#include "fcntl.h"
+
+int
+main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+  int fd, i;
+  char path[] = "stressfs0";
+    1001:	b8 30 00 00 00       	mov    $0x30,%eax
+{
+    1006:	89 e5                	mov    %esp,%ebp
+    1008:	57                   	push   %edi
+    1009:	56                   	push   %esi
+    100a:	53                   	push   %ebx
+  char data[512];
+
+  printf(1, "stressfs starting\n");
+  memset(data, 'a', sizeof(data));
+
+  for(i = 0; i < 4; i++)
+    100b:	31 db                	xor    %ebx,%ebx
+{
+    100d:	83 e4 f0             	and    $0xfffffff0,%esp
+    1010:	81 ec 20 02 00 00    	sub    $0x220,%esp
+  printf(1, "stressfs starting\n");
+    1016:	c7 44 24 04 61 18 00 	movl   $0x1861,0x4(%esp)
+    101d:	00 
+  memset(data, 'a', sizeof(data));
+    101e:	8d 74 24 20          	lea    0x20(%esp),%esi
+  printf(1, "stressfs starting\n");
+    1022:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  char path[] = "stressfs0";
+    1029:	66 89 44 24 1e       	mov    %ax,0x1e(%esp)
+    102e:	c7 44 24 16 73 74 72 	movl   $0x65727473,0x16(%esp)
+    1035:	65 
+    1036:	c7 44 24 1a 73 73 66 	movl   $0x73667373,0x1a(%esp)
+    103d:	73 
+  printf(1, "stressfs starting\n");
+    103e:	e8 7d 04 00 00       	call   14c0 <printf>
+  memset(data, 'a', sizeof(data));
+    1043:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+    104a:	00 
+    104b:	c7 44 24 04 61 00 00 	movl   $0x61,0x4(%esp)
+    1052:	00 
+    1053:	89 34 24             	mov    %esi,(%esp)
+    1056:	e8 95 01 00 00       	call   11f0 <memset>
+    if(fork() > 0)
+    105b:	e8 fa 02 00 00       	call   135a <fork>
+    1060:	85 c0                	test   %eax,%eax
+    1062:	0f 8f c3 00 00 00    	jg     112b <main+0x12b>
+  for(i = 0; i < 4; i++)
+    1068:	83 c3 01             	add    $0x1,%ebx
+    106b:	83 fb 04             	cmp    $0x4,%ebx
+    106e:	75 eb                	jne    105b <main+0x5b>
+    1070:	bf 04 00 00 00       	mov    $0x4,%edi
+      break;
+
+  printf(1, "write %d\n", i);
+    1075:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+
+  path[8] += i;
+  fd = open(path, O_CREATE | O_RDWR);
+    1079:	bb 14 00 00 00       	mov    $0x14,%ebx
+  printf(1, "write %d\n", i);
+    107e:	c7 44 24 04 74 18 00 	movl   $0x1874,0x4(%esp)
+    1085:	00 
+    1086:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    108d:	e8 2e 04 00 00       	call   14c0 <printf>
+  path[8] += i;
+    1092:	89 f8                	mov    %edi,%eax
+    1094:	00 44 24 1e          	add    %al,0x1e(%esp)
+  fd = open(path, O_CREATE | O_RDWR);
+    1098:	8d 44 24 16          	lea    0x16(%esp),%eax
+    109c:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    10a3:	00 
+    10a4:	89 04 24             	mov    %eax,(%esp)
+    10a7:	e8 f6 02 00 00       	call   13a2 <open>
+    10ac:	89 c7                	mov    %eax,%edi
+    10ae:	66 90                	xchg   %ax,%ax
+  for(i = 0; i < 20; i++)
+//    printf(fd, "%d\n", i);
+    write(fd, data, sizeof(data));
+    10b0:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+    10b7:	00 
+    10b8:	89 74 24 04          	mov    %esi,0x4(%esp)
+    10bc:	89 3c 24             	mov    %edi,(%esp)
+    10bf:	e8 be 02 00 00       	call   1382 <write>
+  for(i = 0; i < 20; i++)
+    10c4:	83 eb 01             	sub    $0x1,%ebx
+    10c7:	75 e7                	jne    10b0 <main+0xb0>
+  close(fd);
+    10c9:	89 3c 24             	mov    %edi,(%esp)
+
+  printf(1, "read\n");
+
+  fd = open(path, O_RDONLY);
+    10cc:	bb 14 00 00 00       	mov    $0x14,%ebx
+  close(fd);
+    10d1:	e8 b4 02 00 00       	call   138a <close>
+  printf(1, "read\n");
+    10d6:	c7 44 24 04 7e 18 00 	movl   $0x187e,0x4(%esp)
+    10dd:	00 
+    10de:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    10e5:	e8 d6 03 00 00       	call   14c0 <printf>
+  fd = open(path, O_RDONLY);
+    10ea:	8d 44 24 16          	lea    0x16(%esp),%eax
+    10ee:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    10f5:	00 
+    10f6:	89 04 24             	mov    %eax,(%esp)
+    10f9:	e8 a4 02 00 00       	call   13a2 <open>
+    10fe:	89 c7                	mov    %eax,%edi
+  for (i = 0; i < 20; i++)
+    read(fd, data, sizeof(data));
+    1100:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+    1107:	00 
+    1108:	89 74 24 04          	mov    %esi,0x4(%esp)
+    110c:	89 3c 24             	mov    %edi,(%esp)
+    110f:	e8 66 02 00 00       	call   137a <read>
+  for (i = 0; i < 20; i++)
+    1114:	83 eb 01             	sub    $0x1,%ebx
+    1117:	75 e7                	jne    1100 <main+0x100>
+  close(fd);
+    1119:	89 3c 24             	mov    %edi,(%esp)
+    111c:	e8 69 02 00 00       	call   138a <close>
+
+  wait();
+    1121:	e8 44 02 00 00       	call   136a <wait>
+
+  exit();
+    1126:	e8 37 02 00 00       	call   1362 <exit>
+    112b:	89 df                	mov    %ebx,%edi
+    112d:	8d 76 00             	lea    0x0(%esi),%esi
+    1130:	e9 40 ff ff ff       	jmp    1075 <main+0x75>
+    1135:	66 90                	xchg   %ax,%ax
+    1137:	66 90                	xchg   %ax,%ax
+    1139:	66 90                	xchg   %ax,%ax
+    113b:	66 90                	xchg   %ax,%ax
+    113d:	66 90                	xchg   %ax,%ax
+    113f:	90                   	nop
+
+00001140 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1140:	55                   	push   %ebp
+    1141:	89 e5                	mov    %esp,%ebp
+    1143:	8b 45 08             	mov    0x8(%ebp),%eax
+    1146:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1149:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    114a:	89 c2                	mov    %eax,%edx
+    114c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1150:	83 c1 01             	add    $0x1,%ecx
+    1153:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1157:	83 c2 01             	add    $0x1,%edx
+    115a:	84 db                	test   %bl,%bl
+    115c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    115f:	75 ef                	jne    1150 <strcpy+0x10>
+    ;
+  return os;
+}
+    1161:	5b                   	pop    %ebx
+    1162:	5d                   	pop    %ebp
+    1163:	c3                   	ret    
+    1164:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    116a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001170 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1170:	55                   	push   %ebp
+    1171:	89 e5                	mov    %esp,%ebp
+    1173:	8b 55 08             	mov    0x8(%ebp),%edx
+    1176:	53                   	push   %ebx
+    1177:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    117a:	0f b6 02             	movzbl (%edx),%eax
+    117d:	84 c0                	test   %al,%al
+    117f:	74 2d                	je     11ae <strcmp+0x3e>
+    1181:	0f b6 19             	movzbl (%ecx),%ebx
+    1184:	38 d8                	cmp    %bl,%al
+    1186:	74 0e                	je     1196 <strcmp+0x26>
+    1188:	eb 2b                	jmp    11b5 <strcmp+0x45>
+    118a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1190:	38 c8                	cmp    %cl,%al
+    1192:	75 15                	jne    11a9 <strcmp+0x39>
+    p++, q++;
+    1194:	89 d9                	mov    %ebx,%ecx
+    1196:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    1199:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    119c:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    119f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    11a3:	84 c0                	test   %al,%al
+    11a5:	75 e9                	jne    1190 <strcmp+0x20>
+    11a7:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    11a9:	29 c8                	sub    %ecx,%eax
+}
+    11ab:	5b                   	pop    %ebx
+    11ac:	5d                   	pop    %ebp
+    11ad:	c3                   	ret    
+    11ae:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    11b1:	31 c0                	xor    %eax,%eax
+    11b3:	eb f4                	jmp    11a9 <strcmp+0x39>
+    11b5:	0f b6 cb             	movzbl %bl,%ecx
+    11b8:	eb ef                	jmp    11a9 <strcmp+0x39>
+    11ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000011c0 <strlen>:
+
+uint
+strlen(char *s)
+{
+    11c0:	55                   	push   %ebp
+    11c1:	89 e5                	mov    %esp,%ebp
+    11c3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    11c6:	80 39 00             	cmpb   $0x0,(%ecx)
+    11c9:	74 12                	je     11dd <strlen+0x1d>
+    11cb:	31 d2                	xor    %edx,%edx
+    11cd:	8d 76 00             	lea    0x0(%esi),%esi
+    11d0:	83 c2 01             	add    $0x1,%edx
+    11d3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    11d7:	89 d0                	mov    %edx,%eax
+    11d9:	75 f5                	jne    11d0 <strlen+0x10>
+    ;
+  return n;
+}
+    11db:	5d                   	pop    %ebp
+    11dc:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    11dd:	31 c0                	xor    %eax,%eax
+}
+    11df:	5d                   	pop    %ebp
+    11e0:	c3                   	ret    
+    11e1:	eb 0d                	jmp    11f0 <memset>
+    11e3:	90                   	nop
+    11e4:	90                   	nop
+    11e5:	90                   	nop
+    11e6:	90                   	nop
+    11e7:	90                   	nop
+    11e8:	90                   	nop
+    11e9:	90                   	nop
+    11ea:	90                   	nop
+    11eb:	90                   	nop
+    11ec:	90                   	nop
+    11ed:	90                   	nop
+    11ee:	90                   	nop
+    11ef:	90                   	nop
+
+000011f0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    11f0:	55                   	push   %ebp
+    11f1:	89 e5                	mov    %esp,%ebp
+    11f3:	8b 55 08             	mov    0x8(%ebp),%edx
+    11f6:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    11f7:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    11fa:	8b 45 0c             	mov    0xc(%ebp),%eax
+    11fd:	89 d7                	mov    %edx,%edi
+    11ff:	fc                   	cld    
+    1200:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    1202:	89 d0                	mov    %edx,%eax
+    1204:	5f                   	pop    %edi
+    1205:	5d                   	pop    %ebp
+    1206:	c3                   	ret    
+    1207:	89 f6                	mov    %esi,%esi
+    1209:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001210 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    1210:	55                   	push   %ebp
+    1211:	89 e5                	mov    %esp,%ebp
+    1213:	8b 45 08             	mov    0x8(%ebp),%eax
+    1216:	53                   	push   %ebx
+    1217:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    121a:	0f b6 18             	movzbl (%eax),%ebx
+    121d:	84 db                	test   %bl,%bl
+    121f:	74 1d                	je     123e <strchr+0x2e>
+    if(*s == c)
+    1221:	38 d3                	cmp    %dl,%bl
+    1223:	89 d1                	mov    %edx,%ecx
+    1225:	75 0d                	jne    1234 <strchr+0x24>
+    1227:	eb 17                	jmp    1240 <strchr+0x30>
+    1229:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1230:	38 ca                	cmp    %cl,%dl
+    1232:	74 0c                	je     1240 <strchr+0x30>
+  for(; *s; s++)
+    1234:	83 c0 01             	add    $0x1,%eax
+    1237:	0f b6 10             	movzbl (%eax),%edx
+    123a:	84 d2                	test   %dl,%dl
+    123c:	75 f2                	jne    1230 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    123e:	31 c0                	xor    %eax,%eax
+}
+    1240:	5b                   	pop    %ebx
+    1241:	5d                   	pop    %ebp
+    1242:	c3                   	ret    
+    1243:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1249:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001250 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1250:	55                   	push   %ebp
+    1251:	89 e5                	mov    %esp,%ebp
+    1253:	57                   	push   %edi
+    1254:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1255:	31 f6                	xor    %esi,%esi
+{
+    1257:	53                   	push   %ebx
+    1258:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    125b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    125e:	eb 31                	jmp    1291 <gets+0x41>
+    cc = read(0, &c, 1);
+    1260:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1267:	00 
+    1268:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    126c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1273:	e8 02 01 00 00       	call   137a <read>
+    if(cc < 1)
+    1278:	85 c0                	test   %eax,%eax
+    127a:	7e 1d                	jle    1299 <gets+0x49>
+      break;
+    buf[i++] = c;
+    127c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    1280:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    1282:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    1285:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    1287:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    128b:	74 0c                	je     1299 <gets+0x49>
+    128d:	3c 0a                	cmp    $0xa,%al
+    128f:	74 08                	je     1299 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    1291:	8d 5e 01             	lea    0x1(%esi),%ebx
+    1294:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    1297:	7c c7                	jl     1260 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    1299:	8b 45 08             	mov    0x8(%ebp),%eax
+    129c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    12a0:	83 c4 2c             	add    $0x2c,%esp
+    12a3:	5b                   	pop    %ebx
+    12a4:	5e                   	pop    %esi
+    12a5:	5f                   	pop    %edi
+    12a6:	5d                   	pop    %ebp
+    12a7:	c3                   	ret    
+    12a8:	90                   	nop
+    12a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000012b0 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    12b0:	55                   	push   %ebp
+    12b1:	89 e5                	mov    %esp,%ebp
+    12b3:	56                   	push   %esi
+    12b4:	53                   	push   %ebx
+    12b5:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    12b8:	8b 45 08             	mov    0x8(%ebp),%eax
+    12bb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    12c2:	00 
+    12c3:	89 04 24             	mov    %eax,(%esp)
+    12c6:	e8 d7 00 00 00       	call   13a2 <open>
+  if(fd < 0)
+    12cb:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    12cd:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    12cf:	78 27                	js     12f8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    12d1:	8b 45 0c             	mov    0xc(%ebp),%eax
+    12d4:	89 1c 24             	mov    %ebx,(%esp)
+    12d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    12db:	e8 da 00 00 00       	call   13ba <fstat>
+  close(fd);
+    12e0:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    12e3:	89 c6                	mov    %eax,%esi
+  close(fd);
+    12e5:	e8 a0 00 00 00       	call   138a <close>
+  return r;
+    12ea:	89 f0                	mov    %esi,%eax
+}
+    12ec:	83 c4 10             	add    $0x10,%esp
+    12ef:	5b                   	pop    %ebx
+    12f0:	5e                   	pop    %esi
+    12f1:	5d                   	pop    %ebp
+    12f2:	c3                   	ret    
+    12f3:	90                   	nop
+    12f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    12f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    12fd:	eb ed                	jmp    12ec <stat+0x3c>
+    12ff:	90                   	nop
+
+00001300 <atoi>:
+
+int
+atoi(const char *s)
+{
+    1300:	55                   	push   %ebp
+    1301:	89 e5                	mov    %esp,%ebp
+    1303:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    1306:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    1307:	0f be 11             	movsbl (%ecx),%edx
+    130a:	8d 42 d0             	lea    -0x30(%edx),%eax
+    130d:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    130f:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    1314:	77 17                	ja     132d <atoi+0x2d>
+    1316:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    1318:	83 c1 01             	add    $0x1,%ecx
+    131b:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    131e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1322:	0f be 11             	movsbl (%ecx),%edx
+    1325:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1328:	80 fb 09             	cmp    $0x9,%bl
+    132b:	76 eb                	jbe    1318 <atoi+0x18>
+  return n;
+}
+    132d:	5b                   	pop    %ebx
+    132e:	5d                   	pop    %ebp
+    132f:	c3                   	ret    
+
+00001330 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1330:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1331:	31 d2                	xor    %edx,%edx
+{
+    1333:	89 e5                	mov    %esp,%ebp
+    1335:	56                   	push   %esi
+    1336:	8b 45 08             	mov    0x8(%ebp),%eax
+    1339:	53                   	push   %ebx
+    133a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    133d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1340:	85 db                	test   %ebx,%ebx
+    1342:	7e 12                	jle    1356 <memmove+0x26>
+    1344:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1348:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    134c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    134f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1352:	39 da                	cmp    %ebx,%edx
+    1354:	75 f2                	jne    1348 <memmove+0x18>
+  return vdst;
+}
+    1356:	5b                   	pop    %ebx
+    1357:	5e                   	pop    %esi
+    1358:	5d                   	pop    %ebp
+    1359:	c3                   	ret    
+
+0000135a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    135a:	b8 01 00 00 00       	mov    $0x1,%eax
+    135f:	cd 40                	int    $0x40
+    1361:	c3                   	ret    
+
+00001362 <exit>:
+SYSCALL(exit)
+    1362:	b8 02 00 00 00       	mov    $0x2,%eax
+    1367:	cd 40                	int    $0x40
+    1369:	c3                   	ret    
+
+0000136a <wait>:
+SYSCALL(wait)
+    136a:	b8 03 00 00 00       	mov    $0x3,%eax
+    136f:	cd 40                	int    $0x40
+    1371:	c3                   	ret    
+
+00001372 <pipe>:
+SYSCALL(pipe)
+    1372:	b8 04 00 00 00       	mov    $0x4,%eax
+    1377:	cd 40                	int    $0x40
+    1379:	c3                   	ret    
+
+0000137a <read>:
+SYSCALL(read)
+    137a:	b8 05 00 00 00       	mov    $0x5,%eax
+    137f:	cd 40                	int    $0x40
+    1381:	c3                   	ret    
+
+00001382 <write>:
+SYSCALL(write)
+    1382:	b8 10 00 00 00       	mov    $0x10,%eax
+    1387:	cd 40                	int    $0x40
+    1389:	c3                   	ret    
+
+0000138a <close>:
+SYSCALL(close)
+    138a:	b8 15 00 00 00       	mov    $0x15,%eax
+    138f:	cd 40                	int    $0x40
+    1391:	c3                   	ret    
+
+00001392 <kill>:
+SYSCALL(kill)
+    1392:	b8 06 00 00 00       	mov    $0x6,%eax
+    1397:	cd 40                	int    $0x40
+    1399:	c3                   	ret    
+
+0000139a <exec>:
+SYSCALL(exec)
+    139a:	b8 07 00 00 00       	mov    $0x7,%eax
+    139f:	cd 40                	int    $0x40
+    13a1:	c3                   	ret    
+
+000013a2 <open>:
+SYSCALL(open)
+    13a2:	b8 0f 00 00 00       	mov    $0xf,%eax
+    13a7:	cd 40                	int    $0x40
+    13a9:	c3                   	ret    
+
+000013aa <mknod>:
+SYSCALL(mknod)
+    13aa:	b8 11 00 00 00       	mov    $0x11,%eax
+    13af:	cd 40                	int    $0x40
+    13b1:	c3                   	ret    
+
+000013b2 <unlink>:
+SYSCALL(unlink)
+    13b2:	b8 12 00 00 00       	mov    $0x12,%eax
+    13b7:	cd 40                	int    $0x40
+    13b9:	c3                   	ret    
+
+000013ba <fstat>:
+SYSCALL(fstat)
+    13ba:	b8 08 00 00 00       	mov    $0x8,%eax
+    13bf:	cd 40                	int    $0x40
+    13c1:	c3                   	ret    
+
+000013c2 <link>:
+SYSCALL(link)
+    13c2:	b8 13 00 00 00       	mov    $0x13,%eax
+    13c7:	cd 40                	int    $0x40
+    13c9:	c3                   	ret    
+
+000013ca <mkdir>:
+SYSCALL(mkdir)
+    13ca:	b8 14 00 00 00       	mov    $0x14,%eax
+    13cf:	cd 40                	int    $0x40
+    13d1:	c3                   	ret    
+
+000013d2 <chdir>:
+SYSCALL(chdir)
+    13d2:	b8 09 00 00 00       	mov    $0x9,%eax
+    13d7:	cd 40                	int    $0x40
+    13d9:	c3                   	ret    
+
+000013da <dup>:
+SYSCALL(dup)
+    13da:	b8 0a 00 00 00       	mov    $0xa,%eax
+    13df:	cd 40                	int    $0x40
+    13e1:	c3                   	ret    
+
+000013e2 <getpid>:
+SYSCALL(getpid)
+    13e2:	b8 0b 00 00 00       	mov    $0xb,%eax
+    13e7:	cd 40                	int    $0x40
+    13e9:	c3                   	ret    
+
+000013ea <sbrk>:
+SYSCALL(sbrk)
+    13ea:	b8 0c 00 00 00       	mov    $0xc,%eax
+    13ef:	cd 40                	int    $0x40
+    13f1:	c3                   	ret    
+
+000013f2 <sleep>:
+SYSCALL(sleep)
+    13f2:	b8 0d 00 00 00       	mov    $0xd,%eax
+    13f7:	cd 40                	int    $0x40
+    13f9:	c3                   	ret    
+
+000013fa <uptime>:
+SYSCALL(uptime)
+    13fa:	b8 0e 00 00 00       	mov    $0xe,%eax
+    13ff:	cd 40                	int    $0x40
+    1401:	c3                   	ret    
+
+00001402 <shm_open>:
+SYSCALL(shm_open)
+    1402:	b8 16 00 00 00       	mov    $0x16,%eax
+    1407:	cd 40                	int    $0x40
+    1409:	c3                   	ret    
+
+0000140a <shm_close>:
+SYSCALL(shm_close)	
+    140a:	b8 17 00 00 00       	mov    $0x17,%eax
+    140f:	cd 40                	int    $0x40
+    1411:	c3                   	ret    
+    1412:	66 90                	xchg   %ax,%ax
+    1414:	66 90                	xchg   %ax,%ax
+    1416:	66 90                	xchg   %ax,%ax
+    1418:	66 90                	xchg   %ax,%ax
+    141a:	66 90                	xchg   %ax,%ax
+    141c:	66 90                	xchg   %ax,%ax
+    141e:	66 90                	xchg   %ax,%ax
+
+00001420 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1420:	55                   	push   %ebp
+    1421:	89 e5                	mov    %esp,%ebp
+    1423:	57                   	push   %edi
+    1424:	56                   	push   %esi
+    1425:	89 c6                	mov    %eax,%esi
+    1427:	53                   	push   %ebx
+    1428:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    142b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    142e:	85 db                	test   %ebx,%ebx
+    1430:	74 09                	je     143b <printint+0x1b>
+    1432:	89 d0                	mov    %edx,%eax
+    1434:	c1 e8 1f             	shr    $0x1f,%eax
+    1437:	84 c0                	test   %al,%al
+    1439:	75 75                	jne    14b0 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    143b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    143d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1444:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1447:	31 ff                	xor    %edi,%edi
+    1449:	89 ce                	mov    %ecx,%esi
+    144b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    144e:	eb 02                	jmp    1452 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1450:	89 cf                	mov    %ecx,%edi
+    1452:	31 d2                	xor    %edx,%edx
+    1454:	f7 f6                	div    %esi
+    1456:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1459:	0f b6 92 8b 18 00 00 	movzbl 0x188b(%edx),%edx
+  }while((x /= base) != 0);
+    1460:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1462:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1465:	75 e9                	jne    1450 <printint+0x30>
+  if(neg)
+    1467:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    146a:	89 c8                	mov    %ecx,%eax
+    146c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    146f:	85 d2                	test   %edx,%edx
+    1471:	74 08                	je     147b <printint+0x5b>
+    buf[i++] = '-';
+    1473:	8d 4f 02             	lea    0x2(%edi),%ecx
+    1476:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    147b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    147e:	66 90                	xchg   %ax,%ax
+    1480:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    1485:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    1488:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    148f:	00 
+    1490:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1494:	89 34 24             	mov    %esi,(%esp)
+    1497:	88 45 d7             	mov    %al,-0x29(%ebp)
+    149a:	e8 e3 fe ff ff       	call   1382 <write>
+  while(--i >= 0)
+    149f:	83 ff ff             	cmp    $0xffffffff,%edi
+    14a2:	75 dc                	jne    1480 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    14a4:	83 c4 4c             	add    $0x4c,%esp
+    14a7:	5b                   	pop    %ebx
+    14a8:	5e                   	pop    %esi
+    14a9:	5f                   	pop    %edi
+    14aa:	5d                   	pop    %ebp
+    14ab:	c3                   	ret    
+    14ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    14b0:	89 d0                	mov    %edx,%eax
+    14b2:	f7 d8                	neg    %eax
+    neg = 1;
+    14b4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    14bb:	eb 87                	jmp    1444 <printint+0x24>
+    14bd:	8d 76 00             	lea    0x0(%esi),%esi
+
+000014c0 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    14c0:	55                   	push   %ebp
+    14c1:	89 e5                	mov    %esp,%ebp
+    14c3:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    14c4:	31 ff                	xor    %edi,%edi
+{
+    14c6:	56                   	push   %esi
+    14c7:	53                   	push   %ebx
+    14c8:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    14cb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    14ce:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    14d1:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    14d4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    14d7:	0f b6 13             	movzbl (%ebx),%edx
+    14da:	83 c3 01             	add    $0x1,%ebx
+    14dd:	84 d2                	test   %dl,%dl
+    14df:	75 39                	jne    151a <printf+0x5a>
+    14e1:	e9 c2 00 00 00       	jmp    15a8 <printf+0xe8>
+    14e6:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    14e8:	83 fa 25             	cmp    $0x25,%edx
+    14eb:	0f 84 bf 00 00 00    	je     15b0 <printf+0xf0>
+  write(fd, &c, 1);
+    14f1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    14f4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14fb:	00 
+    14fc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1500:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    1503:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    1506:	e8 77 fe ff ff       	call   1382 <write>
+    150b:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    150e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    1512:	84 d2                	test   %dl,%dl
+    1514:	0f 84 8e 00 00 00    	je     15a8 <printf+0xe8>
+    if(state == 0){
+    151a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    151c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    151f:	74 c7                	je     14e8 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1521:	83 ff 25             	cmp    $0x25,%edi
+    1524:	75 e5                	jne    150b <printf+0x4b>
+      if(c == 'd'){
+    1526:	83 fa 64             	cmp    $0x64,%edx
+    1529:	0f 84 31 01 00 00    	je     1660 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    152f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1534:	83 f8 70             	cmp    $0x70,%eax
+    1537:	0f 84 83 00 00 00    	je     15c0 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    153d:	83 fa 73             	cmp    $0x73,%edx
+    1540:	0f 84 a2 00 00 00    	je     15e8 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1546:	83 fa 63             	cmp    $0x63,%edx
+    1549:	0f 84 35 01 00 00    	je     1684 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    154f:	83 fa 25             	cmp    $0x25,%edx
+    1552:	0f 84 e0 00 00 00    	je     1638 <printf+0x178>
+  write(fd, &c, 1);
+    1558:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    155b:	83 c3 01             	add    $0x1,%ebx
+    155e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1565:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    1566:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    1568:	89 44 24 04          	mov    %eax,0x4(%esp)
+    156c:	89 34 24             	mov    %esi,(%esp)
+    156f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    1572:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    1576:	e8 07 fe ff ff       	call   1382 <write>
+        putc(fd, c);
+    157b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    157e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    1581:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1588:	00 
+    1589:	89 44 24 04          	mov    %eax,0x4(%esp)
+    158d:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    1590:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    1593:	e8 ea fd ff ff       	call   1382 <write>
+  for(i = 0; fmt[i]; i++){
+    1598:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    159c:	84 d2                	test   %dl,%dl
+    159e:	0f 85 76 ff ff ff    	jne    151a <printf+0x5a>
+    15a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    15a8:	83 c4 3c             	add    $0x3c,%esp
+    15ab:	5b                   	pop    %ebx
+    15ac:	5e                   	pop    %esi
+    15ad:	5f                   	pop    %edi
+    15ae:	5d                   	pop    %ebp
+    15af:	c3                   	ret    
+        state = '%';
+    15b0:	bf 25 00 00 00       	mov    $0x25,%edi
+    15b5:	e9 51 ff ff ff       	jmp    150b <printf+0x4b>
+    15ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    15c0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    15c3:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    15c8:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    15ca:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    15d1:	8b 10                	mov    (%eax),%edx
+    15d3:	89 f0                	mov    %esi,%eax
+    15d5:	e8 46 fe ff ff       	call   1420 <printint>
+        ap++;
+    15da:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    15de:	e9 28 ff ff ff       	jmp    150b <printf+0x4b>
+    15e3:	90                   	nop
+    15e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    15e8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    15eb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    15ef:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    15f1:	b8 84 18 00 00       	mov    $0x1884,%eax
+    15f6:	85 ff                	test   %edi,%edi
+    15f8:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    15fb:	0f b6 07             	movzbl (%edi),%eax
+    15fe:	84 c0                	test   %al,%al
+    1600:	74 2a                	je     162c <printf+0x16c>
+    1602:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1608:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    160b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    160e:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    1611:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1618:	00 
+    1619:	89 44 24 04          	mov    %eax,0x4(%esp)
+    161d:	89 34 24             	mov    %esi,(%esp)
+    1620:	e8 5d fd ff ff       	call   1382 <write>
+        while(*s != 0){
+    1625:	0f b6 07             	movzbl (%edi),%eax
+    1628:	84 c0                	test   %al,%al
+    162a:	75 dc                	jne    1608 <printf+0x148>
+      state = 0;
+    162c:	31 ff                	xor    %edi,%edi
+    162e:	e9 d8 fe ff ff       	jmp    150b <printf+0x4b>
+    1633:	90                   	nop
+    1634:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1638:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    163b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    163d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1644:	00 
+    1645:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1649:	89 34 24             	mov    %esi,(%esp)
+    164c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1650:	e8 2d fd ff ff       	call   1382 <write>
+    1655:	e9 b1 fe ff ff       	jmp    150b <printf+0x4b>
+    165a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    1660:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1663:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    1668:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    166b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1672:	8b 10                	mov    (%eax),%edx
+    1674:	89 f0                	mov    %esi,%eax
+    1676:	e8 a5 fd ff ff       	call   1420 <printint>
+        ap++;
+    167b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    167f:	e9 87 fe ff ff       	jmp    150b <printf+0x4b>
+        putc(fd, *ap);
+    1684:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    1687:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    1689:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    168b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1692:	00 
+    1693:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    1696:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    1699:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    169c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    16a0:	e8 dd fc ff ff       	call   1382 <write>
+        ap++;
+    16a5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    16a9:	e9 5d fe ff ff       	jmp    150b <printf+0x4b>
+    16ae:	66 90                	xchg   %ax,%ax
+
+000016b0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    16b0:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16b1:	a1 44 1b 00 00       	mov    0x1b44,%eax
+{
+    16b6:	89 e5                	mov    %esp,%ebp
+    16b8:	57                   	push   %edi
+    16b9:	56                   	push   %esi
+    16ba:	53                   	push   %ebx
+    16bb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16be:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    16c0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16c3:	39 d0                	cmp    %edx,%eax
+    16c5:	72 11                	jb     16d8 <free+0x28>
+    16c7:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16c8:	39 c8                	cmp    %ecx,%eax
+    16ca:	72 04                	jb     16d0 <free+0x20>
+    16cc:	39 ca                	cmp    %ecx,%edx
+    16ce:	72 10                	jb     16e0 <free+0x30>
+    16d0:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16d2:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16d4:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    16d6:	73 f0                	jae    16c8 <free+0x18>
+    16d8:	39 ca                	cmp    %ecx,%edx
+    16da:	72 04                	jb     16e0 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    16dc:	39 c8                	cmp    %ecx,%eax
+    16de:	72 f0                	jb     16d0 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    16e0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    16e3:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    16e6:	39 cf                	cmp    %ecx,%edi
+    16e8:	74 1e                	je     1708 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    16ea:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    16ed:	8b 48 04             	mov    0x4(%eax),%ecx
+    16f0:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    16f3:	39 f2                	cmp    %esi,%edx
+    16f5:	74 28                	je     171f <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    16f7:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    16f9:	a3 44 1b 00 00       	mov    %eax,0x1b44
+}
+    16fe:	5b                   	pop    %ebx
+    16ff:	5e                   	pop    %esi
+    1700:	5f                   	pop    %edi
+    1701:	5d                   	pop    %ebp
+    1702:	c3                   	ret    
+    1703:	90                   	nop
+    1704:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    1708:	03 71 04             	add    0x4(%ecx),%esi
+    170b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    170e:	8b 08                	mov    (%eax),%ecx
+    1710:	8b 09                	mov    (%ecx),%ecx
+    1712:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    1715:	8b 48 04             	mov    0x4(%eax),%ecx
+    1718:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    171b:	39 f2                	cmp    %esi,%edx
+    171d:	75 d8                	jne    16f7 <free+0x47>
+    p->s.size += bp->s.size;
+    171f:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    1722:	a3 44 1b 00 00       	mov    %eax,0x1b44
+    p->s.size += bp->s.size;
+    1727:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    172a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    172d:	89 10                	mov    %edx,(%eax)
+}
+    172f:	5b                   	pop    %ebx
+    1730:	5e                   	pop    %esi
+    1731:	5f                   	pop    %edi
+    1732:	5d                   	pop    %ebp
+    1733:	c3                   	ret    
+    1734:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    173a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001740 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1740:	55                   	push   %ebp
+    1741:	89 e5                	mov    %esp,%ebp
+    1743:	57                   	push   %edi
+    1744:	56                   	push   %esi
+    1745:	53                   	push   %ebx
+    1746:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1749:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    174c:	8b 1d 44 1b 00 00    	mov    0x1b44,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1752:	8d 48 07             	lea    0x7(%eax),%ecx
+    1755:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1758:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    175a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    175d:	0f 84 9b 00 00 00    	je     17fe <malloc+0xbe>
+    1763:	8b 13                	mov    (%ebx),%edx
+    1765:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    1768:	39 fe                	cmp    %edi,%esi
+    176a:	76 64                	jbe    17d0 <malloc+0x90>
+    176c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    1773:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    1778:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    177b:	eb 0e                	jmp    178b <malloc+0x4b>
+    177d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1780:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    1782:	8b 78 04             	mov    0x4(%eax),%edi
+    1785:	39 fe                	cmp    %edi,%esi
+    1787:	76 4f                	jbe    17d8 <malloc+0x98>
+    1789:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    178b:	3b 15 44 1b 00 00    	cmp    0x1b44,%edx
+    1791:	75 ed                	jne    1780 <malloc+0x40>
+  if(nu < 4096)
+    1793:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1796:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    179c:	bf 00 10 00 00       	mov    $0x1000,%edi
+    17a1:	0f 43 fe             	cmovae %esi,%edi
+    17a4:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    17a7:	89 04 24             	mov    %eax,(%esp)
+    17aa:	e8 3b fc ff ff       	call   13ea <sbrk>
+  if(p == (char*)-1)
+    17af:	83 f8 ff             	cmp    $0xffffffff,%eax
+    17b2:	74 18                	je     17cc <malloc+0x8c>
+  hp->s.size = nu;
+    17b4:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    17b7:	83 c0 08             	add    $0x8,%eax
+    17ba:	89 04 24             	mov    %eax,(%esp)
+    17bd:	e8 ee fe ff ff       	call   16b0 <free>
+  return freep;
+    17c2:	8b 15 44 1b 00 00    	mov    0x1b44,%edx
+      if((p = morecore(nunits)) == 0)
+    17c8:	85 d2                	test   %edx,%edx
+    17ca:	75 b4                	jne    1780 <malloc+0x40>
+        return 0;
+    17cc:	31 c0                	xor    %eax,%eax
+    17ce:	eb 20                	jmp    17f0 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    17d0:	89 d0                	mov    %edx,%eax
+    17d2:	89 da                	mov    %ebx,%edx
+    17d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    17d8:	39 fe                	cmp    %edi,%esi
+    17da:	74 1c                	je     17f8 <malloc+0xb8>
+        p->s.size -= nunits;
+    17dc:	29 f7                	sub    %esi,%edi
+    17de:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    17e1:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    17e4:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    17e7:	89 15 44 1b 00 00    	mov    %edx,0x1b44
+      return (void*)(p + 1);
+    17ed:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    17f0:	83 c4 1c             	add    $0x1c,%esp
+    17f3:	5b                   	pop    %ebx
+    17f4:	5e                   	pop    %esi
+    17f5:	5f                   	pop    %edi
+    17f6:	5d                   	pop    %ebp
+    17f7:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    17f8:	8b 08                	mov    (%eax),%ecx
+    17fa:	89 0a                	mov    %ecx,(%edx)
+    17fc:	eb e9                	jmp    17e7 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    17fe:	c7 05 44 1b 00 00 48 	movl   $0x1b48,0x1b44
+    1805:	1b 00 00 
+    base.s.size = 0;
+    1808:	ba 48 1b 00 00       	mov    $0x1b48,%edx
+    base.s.ptr = freep = prevp = &base;
+    180d:	c7 05 48 1b 00 00 48 	movl   $0x1b48,0x1b48
+    1814:	1b 00 00 
+    base.s.size = 0;
+    1817:	c7 05 4c 1b 00 00 00 	movl   $0x0,0x1b4c
+    181e:	00 00 00 
+    1821:	e9 46 ff ff ff       	jmp    176c <malloc+0x2c>
+    1826:	66 90                	xchg   %ax,%ax
+    1828:	66 90                	xchg   %ax,%ax
+    182a:	66 90                	xchg   %ax,%ax
+    182c:	66 90                	xchg   %ax,%ax
+    182e:	66 90                	xchg   %ax,%ax
+
+00001830 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1830:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1831:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1836:	89 e5                	mov    %esp,%ebp
+    1838:	8b 55 08             	mov    0x8(%ebp),%edx
+    183b:	90                   	nop
+    183c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1840:	89 c8                	mov    %ecx,%eax
+    1842:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1845:	85 c0                	test   %eax,%eax
+    1847:	75 f7                	jne    1840 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1849:	0f ae f0             	mfence 
+}
+    184c:	5d                   	pop    %ebp
+    184d:	c3                   	ret    
+    184e:	66 90                	xchg   %ax,%ax
+
+00001850 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1850:	55                   	push   %ebp
+    1851:	89 e5                	mov    %esp,%ebp
+    1853:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1856:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1859:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    185f:	5d                   	pop    %ebp
+    1860:	c3                   	ret    
diff --git a/stressfs.c b/stressfs.c
index 46e0e66..c0a4743 100644
--- a/stressfs.c
+++ b/stressfs.c
@@ -43,7 +43,7 @@ main(int argc, char *argv[])
     read(fd, data, sizeof(data));
   close(fd);
 
-  wait(NULL);
+  wait();
 
-  exit(0);
+  exit();
 }
diff --git a/stressfs.d b/stressfs.d
new file mode 100644
index 0000000..7d5de54
--- /dev/null
+++ b/stressfs.d
@@ -0,0 +1,2 @@
+stressfs.o: stressfs.c /usr/include/stdc-predef.h types.h stat.h user.h \
+ fs.h fcntl.h
diff --git a/stressfs.o b/stressfs.o
new file mode 100644
index 0000000..5abedf4
Binary files /dev/null and b/stressfs.o differ
diff --git a/stressfs.sym b/stressfs.sym
new file mode 100644
index 0000000..5f07929
--- /dev/null
+++ b/stressfs.sym
@@ -0,0 +1,62 @@
+00001000 .text
+00001861 .rodata
+0000189c .eh_frame
+00001b44 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 stressfs.c
+00000000 ulib.c
+00000000 printf.c
+00001420 printint
+0000188b digits.1359
+00000000 umalloc.c
+00001b44 freep
+00001b48 base
+00000000 uspinlock.c
+00001140 strcpy
+000014c0 printf
+00001330 memmove
+000013aa mknod
+00001402 shm_open
+00001250 gets
+000013e2 getpid
+00001740 malloc
+000013f2 sleep
+00001372 pipe
+00001382 write
+000013ba fstat
+00001392 kill
+000013d2 chdir
+0000139a exec
+0000136a wait
+0000137a read
+000013b2 unlink
+00001830 uacquire
+0000135a fork
+000013ea sbrk
+0000140a shm_close
+000013fa uptime
+00001b44 __bss_start
+000011f0 memset
+00001000 main
+00001170 strcmp
+000013da dup
+000012b0 stat
+00001b44 _edata
+00001b50 _end
+000013c2 link
+00001362 exit
+00001300 atoi
+000011c0 strlen
+000013a2 open
+00001210 strchr
+000013ca mkdir
+0000138a close
+00001850 urelease
+000016b0 free
diff --git a/string.d b/string.d
new file mode 100644
index 0000000..68931ed
--- /dev/null
+++ b/string.d
@@ -0,0 +1 @@
+string.o: string.c /usr/include/stdc-predef.h types.h x86.h
diff --git a/string.o b/string.o
new file mode 100644
index 0000000..81a791d
Binary files /dev/null and b/string.o differ
diff --git a/swtch.S b/swtch.S
index 63a7dcc..8751317 100644
--- a/swtch.S
+++ b/swtch.S
@@ -2,16 +2,15 @@
 #
 #   void swtch(struct context **old, struct context *new);
 # 
-# Save the current registers on the stack, creating
-# a struct context, and save its address in *old.
-# Switch stacks to new and pop previously-saved registers.
+# Save current register context in old
+# and then load register context from new.
 
 .globl swtch
 swtch:
   movl 4(%esp), %eax
   movl 8(%esp), %edx
 
-  # Save old callee-saved registers
+  # Save old callee-save registers
   pushl %ebp
   pushl %ebx
   pushl %esi
@@ -21,7 +20,7 @@ swtch:
   movl %esp, (%eax)
   movl %edx, %esp
 
-  # Load new callee-saved registers
+  # Load new callee-save registers
   popl %edi
   popl %esi
   popl %ebx
diff --git a/swtch.o b/swtch.o
new file mode 100644
index 0000000..ac947f0
Binary files /dev/null and b/swtch.o differ
diff --git a/symlink.patch b/symlink.patch
new file mode 100644
index 0000000..c7caf23
--- /dev/null
+++ b/symlink.patch
@@ -0,0 +1,151 @@
+diff -r f8a4e40ab1d6 fs.c
+--- a/fs.c	Thu Aug 30 14:32:06 2007 -0400
++++ b/fs.c	Thu Aug 30 14:29:02 2007 -0400
+@@ -577,12 +577,18 @@ skipelem(char *path, char *name)
+ // If parent != 0, return the inode for the parent and copy the final
+ // path element into name, which must have room for DIRSIZ bytes.
+ static struct inode*
+-_namei(char *path, int parent, char *name)
++_namei(struct inode *root, char *path, int parent, char *name, int depth)
+ {
+   struct inode *ip, *next;
++  char buf[100], tname[DIRSIZ];
++
++  if(depth > 5)
++    return 0;
+ 
+   if(*path == '/')
+     ip = iget(ROOTDEV, 1);
++  else if(root)
++    ip = idup(root);
+   else
+     ip = idup(cp->cwd);
+ 
+@@ -598,10 +604,24 @@ _namei(char *path, int parent, char *nam
+       return ip;
+     }
+     if((next = dirlookup(ip, name, 0)) == 0){
++      cprintf("did not find %s\n", name);
+       iunlockput(ip);
+       return 0;
+     }
+-    iunlockput(ip);
++    iunlock(ip);
++    ilock(next);
++    if(next->type == T_SYMLINK){
++      if(next->size >= sizeof(buf) || readi(next, buf, 0, next->size) != next->size){
++        iunlockput(next);
++        iput(ip);
++        return 0;
++      }
++      buf[next->size] = 0;
++      iunlockput(next);
++      next = _namei(ip, buf, 0, tname, depth+1);
++    }else
++      iunlock(next);
++    iput(ip);
+     ip = next;
+   }
+   if(parent){
+@@ -615,11 +635,11 @@ namei(char *path)
+ namei(char *path)
+ {
+   char name[DIRSIZ];
+-  return _namei(path, 0, name);
++  return _namei(0, path, 0, name, 0);
+ }
+ 
+ struct inode*
+ nameiparent(char *path, char *name)
+ {
+-  return _namei(path, 1, name);
+-}
++  return _namei(0, path, 1, name, 0);
++}
+diff -r f8a4e40ab1d6 fs.h
+--- a/fs.h	Thu Aug 30 14:32:06 2007 -0400
++++ b/fs.h	Thu Aug 30 13:05:43 2007 -0400
+@@ -33,6 +33,7 @@ struct dinode {
+ #define T_DIR  1   // Directory
+ #define T_FILE 2   // File
+ #define T_DEV  3   // Special device
++#define T_SYMLINK 4  // Symlink
+ 
+ // Inodes per block.
+ #define IPB           (BSIZE / sizeof(struct dinode))
+diff -r f8a4e40ab1d6 syscall.c
+--- a/syscall.c	Thu Aug 30 14:32:06 2007 -0400
++++ b/syscall.c	Thu Aug 30 13:05:29 2007 -0400
+@@ -96,6 +96,7 @@ extern int sys_unlink(void);
+ extern int sys_unlink(void);
+ extern int sys_wait(void);
+ extern int sys_write(void);
++extern int sys_symlink(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_chdir]   sys_chdir,
+@@ -118,6 +119,7 @@ static int (*syscalls[])(void) = {
+ [SYS_unlink]  sys_unlink,
+ [SYS_wait]    sys_wait,
+ [SYS_write]   sys_write,
++[SYS_symlink]	sys_symlink,
+ };
+ 
+ void
+diff -r f8a4e40ab1d6 syscall.h
+--- a/syscall.h	Thu Aug 30 14:32:06 2007 -0400
++++ b/syscall.h	Thu Aug 30 13:02:48 2007 -0400
+@@ -19,3 +19,4 @@
+ #define SYS_getpid 18
+ #define SYS_sbrk   19
+ #define SYS_sleep  20
++#define SYS_symlink 21
+diff -r f8a4e40ab1d6 sysfile.c
+--- a/sysfile.c	Thu Aug 30 14:32:06 2007 -0400
++++ b/sysfile.c	Thu Aug 30 13:10:31 2007 -0400
+@@ -257,6 +257,21 @@ create(char *path, int canexist, short t
+ }
+ 
+ int
++sys_symlink(void)
++{
++  char *old, *new;
++  struct inode *ip;
++  
++  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
++    return -1;
++  if((ip = create(new, 0, T_SYMLINK, 0, 0)) == 0)
++    return -1;
++  writei(ip, old, 0, strlen(old));
++  iunlockput(ip);
++  return 0;
++}
++
++int
+ sys_open(void)
+ {
+   char *path;
+@@ -393,3 +408,4 @@ sys_pipe(void)
+   fd[1] = fd1;
+   return 0;
+ }
++
+diff -r f8a4e40ab1d6 user.h
+--- a/user.h	Thu Aug 30 14:32:06 2007 -0400
++++ b/user.h	Thu Aug 30 13:02:34 2007 -0400
+@@ -21,6 +21,7 @@ int getpid();
+ int getpid();
+ char* sbrk(int);
+ int sleep(int);
++int symlink(int);
+ 
+ // ulib.c
+ int stat(char*, struct stat*);
+diff -r f8a4e40ab1d6 usys.S
+--- a/usys.S	Thu Aug 30 14:32:06 2007 -0400
++++ b/usys.S	Thu Aug 30 13:05:54 2007 -0400
+@@ -28,3 +28,4 @@ STUB(getpid)
+ STUB(getpid)
+ STUB(sbrk)
+ STUB(sleep)
++STUB(symlink)
diff --git a/syscall.c b/syscall.c
index 41a8c3c..94ef3c9 100644
--- a/syscall.c
+++ b/syscall.c
@@ -101,15 +101,16 @@ extern int sys_sbrk(void);
 extern int sys_sleep(void);
 extern int sys_unlink(void);
 extern int sys_wait(void);
-extern int sys_waitpid(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
 
+extern int sys_shm_open(void);
+extern int sys_shm_close(void);
+
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
 [SYS_exit]    sys_exit,
 [SYS_wait]    sys_wait,
-[SYS_waitpid] sys_waitpid,
 [SYS_pipe]    sys_pipe,
 [SYS_read]    sys_read,
 [SYS_kill]    sys_kill,
@@ -128,6 +129,8 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_shm_open] sys_shm_open,
+[SYS_shm_close] sys_shm_close
 };
 
 void
diff --git a/syscall.d b/syscall.d
new file mode 100644
index 0000000..4649283
--- /dev/null
+++ b/syscall.d
@@ -0,0 +1,2 @@
+syscall.o: syscall.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h proc.h x86.h syscall.h
diff --git a/syscall.h b/syscall.h
index 374ff05..00fbec5 100644
--- a/syscall.h
+++ b/syscall.h
@@ -1,23 +1,24 @@
 // System call numbers
-#define SYS_fork     1
-#define SYS_exit     2
-#define SYS_wait     3
-#define SYS_pipe     4
-#define SYS_read     5
-#define SYS_kill     6
-#define SYS_exec     7
-#define SYS_fstat    8
-#define SYS_chdir    9
-#define SYS_dup     10
-#define SYS_getpid  11
-#define SYS_sbrk    12
-#define SYS_sleep   13
-#define SYS_uptime  14
-#define SYS_open    15
-#define SYS_write   16
-#define SYS_mknod   17
-#define SYS_unlink  18
-#define SYS_link    19
-#define SYS_mkdir   20
-#define SYS_close   21
-#define SYS_waitpid 22
\ No newline at end of file
+#define SYS_fork    1
+#define SYS_exit    2
+#define SYS_wait    3
+#define SYS_pipe    4
+#define SYS_read    5
+#define SYS_kill    6
+#define SYS_exec    7
+#define SYS_fstat   8
+#define SYS_chdir   9
+#define SYS_dup    10
+#define SYS_getpid 11
+#define SYS_sbrk   12
+#define SYS_sleep  13
+#define SYS_uptime 14
+#define SYS_open   15
+#define SYS_write  16
+#define SYS_mknod  17
+#define SYS_unlink 18
+#define SYS_link   19
+#define SYS_mkdir  20
+#define SYS_close  21
+#define SYS_shm_open 22
+#define SYS_shm_close 23
diff --git a/syscall.o b/syscall.o
new file mode 100644
index 0000000..f47a50f
Binary files /dev/null and b/syscall.o differ
diff --git a/sysfile.c b/sysfile.c
index bfe61b7..87e508b 100644
--- a/sysfile.c
+++ b/sysfile.c
@@ -241,6 +241,7 @@ bad:
 static struct inode*
 create(char *path, short type, short major, short minor)
 {
+  uint off;
   struct inode *ip, *dp;
   char name[DIRSIZ];
 
@@ -248,7 +249,7 @@ create(char *path, short type, short major, short minor)
     return 0;
   ilock(dp);
 
-  if((ip = dirlookup(dp, name, 0)) != 0){
+  if((ip = dirlookup(dp, name, &off)) != 0){
     iunlockput(dp);
     ilock(ip);
     if(type == T_FILE && ip->type == T_FILE)
diff --git a/sysfile.d b/sysfile.d
new file mode 100644
index 0000000..74f1a20
--- /dev/null
+++ b/sysfile.d
@@ -0,0 +1,2 @@
+sysfile.o: sysfile.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ stat.h mmu.h proc.h fs.h spinlock.h sleeplock.h file.h fcntl.h
diff --git a/sysfile.o b/sysfile.o
new file mode 100644
index 0000000..8f519ac
Binary files /dev/null and b/sysfile.o differ
diff --git a/sysproc.c b/sysproc.c
index ebccf84..41dc493 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -7,6 +7,28 @@
 #include "mmu.h"
 #include "proc.h"
 
+int sys_shm_open(void) {
+  int id;
+  char **pointer;
+
+  if(argint(0, &id) < 0)
+    return -1;
+
+  if(argptr(1, (char **) (&pointer),4)<0)
+    return -1;
+  return shm_open(id, pointer);
+}
+
+int sys_shm_close(void) {
+  int id;
+
+  if(argint(0, &id) < 0)
+    return -1;
+
+  
+  return shm_close(id);
+}
+
 int
 sys_fork(void)
 {
@@ -14,22 +36,16 @@ sys_fork(void)
 }
 
 int
-sys_exit(int status)
+sys_exit(void)
 {
-  exit(status);
+  exit();
   return 0;  // not reached
 }
 
 int
-sys_wait(int* status)
-{
-  return wait(status);
-}
-
-int
-sys_waitpid(int pid, int* status, int options)
+sys_wait(void)
 {
-    return waitpid(pid, status, options);
+  return wait();
 }
 
 int
diff --git a/sysproc.d b/sysproc.d
new file mode 100644
index 0000000..2f26f0c
--- /dev/null
+++ b/sysproc.d
@@ -0,0 +1,2 @@
+sysproc.o: sysproc.c /usr/include/stdc-predef.h types.h x86.h defs.h \
+ date.h param.h memlayout.h mmu.h proc.h
diff --git a/sysproc.o b/sysproc.o
new file mode 100644
index 0000000..b43f4c0
Binary files /dev/null and b/sysproc.o differ
diff --git a/trap.c b/trap.c
index 432ea5b..41c66eb 100644
--- a/trap.c
+++ b/trap.c
@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
 {
   if(tf->trapno == T_SYSCALL){
     if(myproc()->killed)
-      exit(4);
+      exit();
     myproc()->tf = tf;
     syscall();
     if(myproc()->killed)
-      exit(3);
+      exit();
     return;
   }
 
@@ -98,7 +98,7 @@ trap(struct trapframe *tf)
   // (If it is still executing in the kernel, let it keep running
   // until it gets to the regular system call return.)
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
-    exit(2);
+    exit();
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
@@ -108,5 +108,5 @@ trap(struct trapframe *tf)
 
   // Check if the process has been killed since we yielded
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
-    exit(1);
+    exit();
 }
diff --git a/trap.d b/trap.d
new file mode 100644
index 0000000..c48ab89
--- /dev/null
+++ b/trap.d
@@ -0,0 +1,2 @@
+trap.o: trap.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h proc.h x86.h traps.h spinlock.h
diff --git a/trap.o b/trap.o
new file mode 100644
index 0000000..5780232
Binary files /dev/null and b/trap.o differ
diff --git a/trapasm.o b/trapasm.o
new file mode 100644
index 0000000..f94bc58
Binary files /dev/null and b/trapasm.o differ
diff --git a/uart.d b/uart.d
new file mode 100644
index 0000000..d156629
--- /dev/null
+++ b/uart.d
@@ -0,0 +1,2 @@
+uart.o: uart.c /usr/include/stdc-predef.h types.h defs.h param.h traps.h \
+ spinlock.h sleeplock.h fs.h file.h mmu.h proc.h x86.h
diff --git a/uart.o b/uart.o
new file mode 100644
index 0000000..9b1f94c
Binary files /dev/null and b/uart.o differ
diff --git a/ulib.c b/ulib.c
index 8e1e1a2..51a9e74 100644
--- a/ulib.c
+++ b/ulib.c
@@ -5,7 +5,7 @@
 #include "x86.h"
 
 char*
-strcpy(char *s, const char *t)
+strcpy(char *s, char *t)
 {
   char *os;
 
@@ -24,7 +24,7 @@ strcmp(const char *p, const char *q)
 }
 
 uint
-strlen(const char *s)
+strlen(char *s)
 {
   int n;
 
@@ -68,7 +68,7 @@ gets(char *buf, int max)
 }
 
 int
-stat(const char *n, struct stat *st)
+stat(char *n, struct stat *st)
 {
   int fd;
   int r;
@@ -93,10 +93,9 @@ atoi(const char *s)
 }
 
 void*
-memmove(void *vdst, const void *vsrc, int n)
+memmove(void *vdst, void *vsrc, int n)
 {
-  char *dst;
-  const char *src;
+  char *dst, *src;
 
   dst = vdst;
   src = vsrc;
diff --git a/ulib.d b/ulib.d
new file mode 100644
index 0000000..61f575e
--- /dev/null
+++ b/ulib.d
@@ -0,0 +1,2 @@
+ulib.o: ulib.c /usr/include/stdc-predef.h types.h stat.h fcntl.h user.h \
+ x86.h
diff --git a/ulib.o b/ulib.o
new file mode 100644
index 0000000..6902da7
Binary files /dev/null and b/ulib.o differ
diff --git a/umalloc.d b/umalloc.d
new file mode 100644
index 0000000..cc1d152
--- /dev/null
+++ b/umalloc.d
@@ -0,0 +1,2 @@
+umalloc.o: umalloc.c /usr/include/stdc-predef.h types.h stat.h user.h \
+ param.h
diff --git a/umalloc.o b/umalloc.o
new file mode 100644
index 0000000..1e49828
Binary files /dev/null and b/umalloc.o differ
diff --git a/user.h b/user.h
index 0931387..f920f49 100644
--- a/user.h
+++ b/user.h
@@ -1,41 +1,40 @@
-#include <stddef.h>
-
 struct stat;
 struct rtcdate;
 
 // system calls
 int fork(void);
-int exit(int status) __attribute__((noreturn));
-int wait(int* status);
-int waitpid(int pid, int* status, int options);
+int exit(void) __attribute__((noreturn));
+int wait(void);
 int pipe(int*);
-int write(int, const void*, int);
+int write(int, void*, int);
 int read(int, void*, int);
 int close(int);
 int kill(int);
 int exec(char*, char**);
-int open(const char*, int);
-int mknod(const char*, short, short);
-int unlink(const char*);
+int open(char*, int);
+int mknod(char*, short, short);
+int unlink(char*);
 int fstat(int fd, struct stat*);
-int link(const char*, const char*);
-int mkdir(const char*);
-int chdir(const char*);
+int link(char*, char*);
+int mkdir(char*);
+int chdir(char*);
 int dup(int);
 int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int shm_open(int, char **);
+int shm_close(int);
 
 // ulib.c
-int stat(const char*, struct stat*);
-char* strcpy(char*, const char*);
-void *memmove(void*, const void*, int);
+int stat(char*, struct stat*);
+char* strcpy(char*, char*);
+void *memmove(void*, void*, int);
 char* strchr(const char*, char c);
 int strcmp(const char*, const char*);
-void printf(int, const char*, ...);
+void printf(int, char*, ...);
 char* gets(char*, int max);
-uint strlen(const char*);
+uint strlen(char*);
 void* memset(void*, int, uint);
 void* malloc(uint);
 void free(void*);
diff --git a/usertests.asm b/usertests.asm
new file mode 100644
index 0000000..0313aa9
--- /dev/null
+++ b/usertests.asm
@@ -0,0 +1,6298 @@
+
+_usertests:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+  return randstate;
+}
+
+int
+main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	83 e4 f0             	and    $0xfffffff0,%esp
+    1006:	83 ec 10             	sub    $0x10,%esp
+  printf(1, "usertests starting\n");
+    1009:	c7 44 24 04 92 61 00 	movl   $0x6192,0x4(%esp)
+    1010:	00 
+    1011:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1018:	e8 e3 3d 00 00       	call   4e00 <printf>
+
+  if(open("usertests.ran", 0) >= 0){
+    101d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1024:	00 
+    1025:	c7 04 24 a6 61 00 00 	movl   $0x61a6,(%esp)
+    102c:	e8 b1 3c 00 00       	call   4ce2 <open>
+    1031:	85 c0                	test   %eax,%eax
+    1033:	78 19                	js     104e <main+0x4e>
+    printf(1, "already ran user tests -- rebuild fs.img\n");
+    1035:	c7 44 24 04 10 69 00 	movl   $0x6910,0x4(%esp)
+    103c:	00 
+    103d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1044:	e8 b7 3d 00 00       	call   4e00 <printf>
+    exit();
+    1049:	e8 54 3c 00 00       	call   4ca2 <exit>
+  }
+  close(open("usertests.ran", O_CREATE));
+    104e:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    1055:	00 
+    1056:	c7 04 24 a6 61 00 00 	movl   $0x61a6,(%esp)
+    105d:	e8 80 3c 00 00       	call   4ce2 <open>
+    1062:	89 04 24             	mov    %eax,(%esp)
+    1065:	e8 60 3c 00 00       	call   4cca <close>
+
+  argptest();
+    106a:	e8 71 39 00 00       	call   49e0 <argptest>
+  createdelete();
+    106f:	e8 9c 12 00 00       	call   2310 <createdelete>
+  linkunlink();
+    1074:	e8 27 1c 00 00       	call   2ca0 <linkunlink>
+  concreate();
+    1079:	e8 02 19 00 00       	call   2980 <concreate>
+    107e:	66 90                	xchg   %ax,%ax
+  fourfiles();
+    1080:	e8 7b 10 00 00       	call   2100 <fourfiles>
+  sharedfd();
+    1085:	e8 96 0e 00 00       	call   1f20 <sharedfd>
+
+  bigargtest();
+    108a:	e8 c1 35 00 00       	call   4650 <bigargtest>
+    108f:	90                   	nop
+  bigwrite();
+    1090:	e8 fb 25 00 00       	call   3690 <bigwrite>
+  bigargtest();
+    1095:	e8 b6 35 00 00       	call   4650 <bigargtest>
+  bsstest();
+    109a:	e8 31 35 00 00       	call   45d0 <bsstest>
+    109f:	90                   	nop
+  sbrktest();
+    10a0:	e8 0b 30 00 00       	call   40b0 <sbrktest>
+  validatetest();
+    10a5:	e8 76 34 00 00       	call   4520 <validatetest>
+
+  opentest();
+    10aa:	e8 61 03 00 00       	call   1410 <opentest>
+    10af:	90                   	nop
+  writetest();
+    10b0:	e8 fb 03 00 00       	call   14b0 <writetest>
+  writetest1();
+    10b5:	e8 06 06 00 00       	call   16c0 <writetest1>
+  createtest();
+    10ba:	e8 f1 07 00 00       	call   18b0 <createtest>
+    10bf:	90                   	nop
+
+  openiputtest();
+    10c0:	e8 3b 02 00 00       	call   1300 <openiputtest>
+  exitiputtest();
+    10c5:	e8 46 01 00 00       	call   1210 <exitiputtest>
+  iputtest();
+    10ca:	e8 61 00 00 00       	call   1130 <iputtest>
+    10cf:	90                   	nop
+
+  mem();
+    10d0:	e8 6b 0d 00 00       	call   1e40 <mem>
+  pipe1();
+    10d5:	e8 b6 09 00 00       	call   1a90 <pipe1>
+  preempt();
+    10da:	e8 71 0b 00 00       	call   1c50 <preempt>
+    10df:	90                   	nop
+  exitwait();
+    10e0:	e8 cb 0c 00 00       	call   1db0 <exitwait>
+
+  rmdot();
+    10e5:	e8 06 2a 00 00       	call   3af0 <rmdot>
+  fourteen();
+    10ea:	e8 a1 28 00 00       	call   3990 <fourteen>
+    10ef:	90                   	nop
+  bigfile();
+    10f0:	e8 9b 26 00 00       	call   3790 <bigfile>
+  subdir();
+    10f5:	e8 06 1e 00 00       	call   2f00 <subdir>
+  linktest();
+    10fa:	e8 21 16 00 00       	call   2720 <linktest>
+    10ff:	90                   	nop
+  unlinkread();
+    1100:	e8 4b 14 00 00       	call   2550 <unlinkread>
+  dirfile();
+    1105:	e8 76 2b 00 00       	call   3c80 <dirfile>
+  iref();
+    110a:	e8 b1 2d 00 00       	call   3ec0 <iref>
+    110f:	90                   	nop
+  forktest();
+    1110:	e8 cb 2e 00 00       	call   3fe0 <forktest>
+  bigdir(); // slow
+    1115:	e8 96 1c 00 00       	call   2db0 <bigdir>
+
+  uio();
+    111a:	e8 41 38 00 00       	call   4960 <uio>
+    111f:	90                   	nop
+
+  exectest();
+    1120:	e8 1b 09 00 00       	call   1a40 <exectest>
+
+  exit();
+    1125:	e8 78 3b 00 00       	call   4ca2 <exit>
+    112a:	66 90                	xchg   %ax,%ax
+    112c:	66 90                	xchg   %ax,%ax
+    112e:	66 90                	xchg   %ax,%ax
+
+00001130 <iputtest>:
+{
+    1130:	55                   	push   %ebp
+    1131:	89 e5                	mov    %esp,%ebp
+    1133:	83 ec 18             	sub    $0x18,%esp
+  printf(stdout, "iput test\n");
+    1136:	a1 60 72 00 00       	mov    0x7260,%eax
+    113b:	c7 44 24 04 38 52 00 	movl   $0x5238,0x4(%esp)
+    1142:	00 
+    1143:	89 04 24             	mov    %eax,(%esp)
+    1146:	e8 b5 3c 00 00       	call   4e00 <printf>
+  if(mkdir("iputdir") < 0){
+    114b:	c7 04 24 cb 51 00 00 	movl   $0x51cb,(%esp)
+    1152:	e8 b3 3b 00 00       	call   4d0a <mkdir>
+    1157:	85 c0                	test   %eax,%eax
+    1159:	78 4b                	js     11a6 <iputtest+0x76>
+  if(chdir("iputdir") < 0){
+    115b:	c7 04 24 cb 51 00 00 	movl   $0x51cb,(%esp)
+    1162:	e8 ab 3b 00 00       	call   4d12 <chdir>
+    1167:	85 c0                	test   %eax,%eax
+    1169:	0f 88 85 00 00 00    	js     11f4 <iputtest+0xc4>
+  if(unlink("../iputdir") < 0){
+    116f:	c7 04 24 c8 51 00 00 	movl   $0x51c8,(%esp)
+    1176:	e8 77 3b 00 00       	call   4cf2 <unlink>
+    117b:	85 c0                	test   %eax,%eax
+    117d:	78 5b                	js     11da <iputtest+0xaa>
+  if(chdir("/") < 0){
+    117f:	c7 04 24 ed 51 00 00 	movl   $0x51ed,(%esp)
+    1186:	e8 87 3b 00 00       	call   4d12 <chdir>
+    118b:	85 c0                	test   %eax,%eax
+    118d:	78 31                	js     11c0 <iputtest+0x90>
+  printf(stdout, "iput test ok\n");
+    118f:	a1 60 72 00 00       	mov    0x7260,%eax
+    1194:	c7 44 24 04 70 52 00 	movl   $0x5270,0x4(%esp)
+    119b:	00 
+    119c:	89 04 24             	mov    %eax,(%esp)
+    119f:	e8 5c 3c 00 00       	call   4e00 <printf>
+}
+    11a4:	c9                   	leave  
+    11a5:	c3                   	ret    
+    printf(stdout, "mkdir failed\n");
+    11a6:	a1 60 72 00 00       	mov    0x7260,%eax
+    11ab:	c7 44 24 04 a4 51 00 	movl   $0x51a4,0x4(%esp)
+    11b2:	00 
+    11b3:	89 04 24             	mov    %eax,(%esp)
+    11b6:	e8 45 3c 00 00       	call   4e00 <printf>
+    exit();
+    11bb:	e8 e2 3a 00 00       	call   4ca2 <exit>
+    printf(stdout, "chdir / failed\n");
+    11c0:	a1 60 72 00 00       	mov    0x7260,%eax
+    11c5:	c7 44 24 04 ef 51 00 	movl   $0x51ef,0x4(%esp)
+    11cc:	00 
+    11cd:	89 04 24             	mov    %eax,(%esp)
+    11d0:	e8 2b 3c 00 00       	call   4e00 <printf>
+    exit();
+    11d5:	e8 c8 3a 00 00       	call   4ca2 <exit>
+    printf(stdout, "unlink ../iputdir failed\n");
+    11da:	a1 60 72 00 00       	mov    0x7260,%eax
+    11df:	c7 44 24 04 d3 51 00 	movl   $0x51d3,0x4(%esp)
+    11e6:	00 
+    11e7:	89 04 24             	mov    %eax,(%esp)
+    11ea:	e8 11 3c 00 00       	call   4e00 <printf>
+    exit();
+    11ef:	e8 ae 3a 00 00       	call   4ca2 <exit>
+    printf(stdout, "chdir iputdir failed\n");
+    11f4:	a1 60 72 00 00       	mov    0x7260,%eax
+    11f9:	c7 44 24 04 b2 51 00 	movl   $0x51b2,0x4(%esp)
+    1200:	00 
+    1201:	89 04 24             	mov    %eax,(%esp)
+    1204:	e8 f7 3b 00 00       	call   4e00 <printf>
+    exit();
+    1209:	e8 94 3a 00 00       	call   4ca2 <exit>
+    120e:	66 90                	xchg   %ax,%ax
+
+00001210 <exitiputtest>:
+{
+    1210:	55                   	push   %ebp
+    1211:	89 e5                	mov    %esp,%ebp
+    1213:	83 ec 18             	sub    $0x18,%esp
+  printf(stdout, "exitiput test\n");
+    1216:	a1 60 72 00 00       	mov    0x7260,%eax
+    121b:	c7 44 24 04 ff 51 00 	movl   $0x51ff,0x4(%esp)
+    1222:	00 
+    1223:	89 04 24             	mov    %eax,(%esp)
+    1226:	e8 d5 3b 00 00       	call   4e00 <printf>
+  pid = fork();
+    122b:	e8 6a 3a 00 00       	call   4c9a <fork>
+  if(pid < 0){
+    1230:	85 c0                	test   %eax,%eax
+    1232:	78 76                	js     12aa <exitiputtest+0x9a>
+  if(pid == 0){
+    1234:	75 3a                	jne    1270 <exitiputtest+0x60>
+    if(mkdir("iputdir") < 0){
+    1236:	c7 04 24 cb 51 00 00 	movl   $0x51cb,(%esp)
+    123d:	e8 c8 3a 00 00       	call   4d0a <mkdir>
+    1242:	85 c0                	test   %eax,%eax
+    1244:	0f 88 94 00 00 00    	js     12de <exitiputtest+0xce>
+    if(chdir("iputdir") < 0){
+    124a:	c7 04 24 cb 51 00 00 	movl   $0x51cb,(%esp)
+    1251:	e8 bc 3a 00 00       	call   4d12 <chdir>
+    1256:	85 c0                	test   %eax,%eax
+    1258:	78 6a                	js     12c4 <exitiputtest+0xb4>
+    if(unlink("../iputdir") < 0){
+    125a:	c7 04 24 c8 51 00 00 	movl   $0x51c8,(%esp)
+    1261:	e8 8c 3a 00 00       	call   4cf2 <unlink>
+    1266:	85 c0                	test   %eax,%eax
+    1268:	78 26                	js     1290 <exitiputtest+0x80>
+    exit();
+    126a:	e8 33 3a 00 00       	call   4ca2 <exit>
+    126f:	90                   	nop
+  wait();
+    1270:	e8 35 3a 00 00       	call   4caa <wait>
+  printf(stdout, "exitiput test ok\n");
+    1275:	a1 60 72 00 00       	mov    0x7260,%eax
+    127a:	c7 44 24 04 22 52 00 	movl   $0x5222,0x4(%esp)
+    1281:	00 
+    1282:	89 04 24             	mov    %eax,(%esp)
+    1285:	e8 76 3b 00 00       	call   4e00 <printf>
+}
+    128a:	c9                   	leave  
+    128b:	c3                   	ret    
+    128c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      printf(stdout, "unlink ../iputdir failed\n");
+    1290:	a1 60 72 00 00       	mov    0x7260,%eax
+    1295:	c7 44 24 04 d3 51 00 	movl   $0x51d3,0x4(%esp)
+    129c:	00 
+    129d:	89 04 24             	mov    %eax,(%esp)
+    12a0:	e8 5b 3b 00 00       	call   4e00 <printf>
+      exit();
+    12a5:	e8 f8 39 00 00       	call   4ca2 <exit>
+    printf(stdout, "fork failed\n");
+    12aa:	a1 60 72 00 00       	mov    0x7260,%eax
+    12af:	c7 44 24 04 e5 60 00 	movl   $0x60e5,0x4(%esp)
+    12b6:	00 
+    12b7:	89 04 24             	mov    %eax,(%esp)
+    12ba:	e8 41 3b 00 00       	call   4e00 <printf>
+    exit();
+    12bf:	e8 de 39 00 00       	call   4ca2 <exit>
+      printf(stdout, "child chdir failed\n");
+    12c4:	a1 60 72 00 00       	mov    0x7260,%eax
+    12c9:	c7 44 24 04 0e 52 00 	movl   $0x520e,0x4(%esp)
+    12d0:	00 
+    12d1:	89 04 24             	mov    %eax,(%esp)
+    12d4:	e8 27 3b 00 00       	call   4e00 <printf>
+      exit();
+    12d9:	e8 c4 39 00 00       	call   4ca2 <exit>
+      printf(stdout, "mkdir failed\n");
+    12de:	a1 60 72 00 00       	mov    0x7260,%eax
+    12e3:	c7 44 24 04 a4 51 00 	movl   $0x51a4,0x4(%esp)
+    12ea:	00 
+    12eb:	89 04 24             	mov    %eax,(%esp)
+    12ee:	e8 0d 3b 00 00       	call   4e00 <printf>
+      exit();
+    12f3:	e8 aa 39 00 00       	call   4ca2 <exit>
+    12f8:	90                   	nop
+    12f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001300 <openiputtest>:
+{
+    1300:	55                   	push   %ebp
+    1301:	89 e5                	mov    %esp,%ebp
+    1303:	83 ec 18             	sub    $0x18,%esp
+  printf(stdout, "openiput test\n");
+    1306:	a1 60 72 00 00       	mov    0x7260,%eax
+    130b:	c7 44 24 04 34 52 00 	movl   $0x5234,0x4(%esp)
+    1312:	00 
+    1313:	89 04 24             	mov    %eax,(%esp)
+    1316:	e8 e5 3a 00 00       	call   4e00 <printf>
+  if(mkdir("oidir") < 0){
+    131b:	c7 04 24 43 52 00 00 	movl   $0x5243,(%esp)
+    1322:	e8 e3 39 00 00       	call   4d0a <mkdir>
+    1327:	85 c0                	test   %eax,%eax
+    1329:	0f 88 9e 00 00 00    	js     13cd <openiputtest+0xcd>
+  pid = fork();
+    132f:	e8 66 39 00 00       	call   4c9a <fork>
+  if(pid < 0){
+    1334:	85 c0                	test   %eax,%eax
+    1336:	0f 88 ab 00 00 00    	js     13e7 <openiputtest+0xe7>
+    133c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  if(pid == 0){
+    1340:	75 36                	jne    1378 <openiputtest+0x78>
+    int fd = open("oidir", O_RDWR);
+    1342:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+    1349:	00 
+    134a:	c7 04 24 43 52 00 00 	movl   $0x5243,(%esp)
+    1351:	e8 8c 39 00 00       	call   4ce2 <open>
+    if(fd >= 0){
+    1356:	85 c0                	test   %eax,%eax
+    1358:	78 6e                	js     13c8 <openiputtest+0xc8>
+      printf(stdout, "open directory for write succeeded\n");
+    135a:	a1 60 72 00 00       	mov    0x7260,%eax
+    135f:	c7 44 24 04 c8 61 00 	movl   $0x61c8,0x4(%esp)
+    1366:	00 
+    1367:	89 04 24             	mov    %eax,(%esp)
+    136a:	e8 91 3a 00 00       	call   4e00 <printf>
+      exit();
+    136f:	e8 2e 39 00 00       	call   4ca2 <exit>
+    1374:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  sleep(1);
+    1378:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    137f:	e8 ae 39 00 00       	call   4d32 <sleep>
+  if(unlink("oidir") != 0){
+    1384:	c7 04 24 43 52 00 00 	movl   $0x5243,(%esp)
+    138b:	e8 62 39 00 00       	call   4cf2 <unlink>
+    1390:	85 c0                	test   %eax,%eax
+    1392:	75 1c                	jne    13b0 <openiputtest+0xb0>
+  wait();
+    1394:	e8 11 39 00 00       	call   4caa <wait>
+  printf(stdout, "openiput test ok\n");
+    1399:	a1 60 72 00 00       	mov    0x7260,%eax
+    139e:	c7 44 24 04 6c 52 00 	movl   $0x526c,0x4(%esp)
+    13a5:	00 
+    13a6:	89 04 24             	mov    %eax,(%esp)
+    13a9:	e8 52 3a 00 00       	call   4e00 <printf>
+}
+    13ae:	c9                   	leave  
+    13af:	c3                   	ret    
+    printf(stdout, "unlink failed\n");
+    13b0:	a1 60 72 00 00       	mov    0x7260,%eax
+    13b5:	c7 44 24 04 5d 52 00 	movl   $0x525d,0x4(%esp)
+    13bc:	00 
+    13bd:	89 04 24             	mov    %eax,(%esp)
+    13c0:	e8 3b 3a 00 00       	call   4e00 <printf>
+    13c5:	8d 76 00             	lea    0x0(%esi),%esi
+    exit();
+    13c8:	e8 d5 38 00 00       	call   4ca2 <exit>
+    printf(stdout, "mkdir oidir failed\n");
+    13cd:	a1 60 72 00 00       	mov    0x7260,%eax
+    13d2:	c7 44 24 04 49 52 00 	movl   $0x5249,0x4(%esp)
+    13d9:	00 
+    13da:	89 04 24             	mov    %eax,(%esp)
+    13dd:	e8 1e 3a 00 00       	call   4e00 <printf>
+    exit();
+    13e2:	e8 bb 38 00 00       	call   4ca2 <exit>
+    printf(stdout, "fork failed\n");
+    13e7:	a1 60 72 00 00       	mov    0x7260,%eax
+    13ec:	c7 44 24 04 e5 60 00 	movl   $0x60e5,0x4(%esp)
+    13f3:	00 
+    13f4:	89 04 24             	mov    %eax,(%esp)
+    13f7:	e8 04 3a 00 00       	call   4e00 <printf>
+    exit();
+    13fc:	e8 a1 38 00 00       	call   4ca2 <exit>
+    1401:	eb 0d                	jmp    1410 <opentest>
+    1403:	90                   	nop
+    1404:	90                   	nop
+    1405:	90                   	nop
+    1406:	90                   	nop
+    1407:	90                   	nop
+    1408:	90                   	nop
+    1409:	90                   	nop
+    140a:	90                   	nop
+    140b:	90                   	nop
+    140c:	90                   	nop
+    140d:	90                   	nop
+    140e:	90                   	nop
+    140f:	90                   	nop
+
+00001410 <opentest>:
+{
+    1410:	55                   	push   %ebp
+    1411:	89 e5                	mov    %esp,%ebp
+    1413:	83 ec 18             	sub    $0x18,%esp
+  printf(stdout, "open test\n");
+    1416:	a1 60 72 00 00       	mov    0x7260,%eax
+    141b:	c7 44 24 04 7e 52 00 	movl   $0x527e,0x4(%esp)
+    1422:	00 
+    1423:	89 04 24             	mov    %eax,(%esp)
+    1426:	e8 d5 39 00 00       	call   4e00 <printf>
+  fd = open("echo", 0);
+    142b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1432:	00 
+    1433:	c7 04 24 89 52 00 00 	movl   $0x5289,(%esp)
+    143a:	e8 a3 38 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    143f:	85 c0                	test   %eax,%eax
+    1441:	78 37                	js     147a <opentest+0x6a>
+  close(fd);
+    1443:	89 04 24             	mov    %eax,(%esp)
+    1446:	e8 7f 38 00 00       	call   4cca <close>
+  fd = open("doesnotexist", 0);
+    144b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1452:	00 
+    1453:	c7 04 24 a1 52 00 00 	movl   $0x52a1,(%esp)
+    145a:	e8 83 38 00 00       	call   4ce2 <open>
+  if(fd >= 0){
+    145f:	85 c0                	test   %eax,%eax
+    1461:	79 31                	jns    1494 <opentest+0x84>
+  printf(stdout, "open test ok\n");
+    1463:	a1 60 72 00 00       	mov    0x7260,%eax
+    1468:	c7 44 24 04 cc 52 00 	movl   $0x52cc,0x4(%esp)
+    146f:	00 
+    1470:	89 04 24             	mov    %eax,(%esp)
+    1473:	e8 88 39 00 00       	call   4e00 <printf>
+}
+    1478:	c9                   	leave  
+    1479:	c3                   	ret    
+    printf(stdout, "open echo failed!\n");
+    147a:	a1 60 72 00 00       	mov    0x7260,%eax
+    147f:	c7 44 24 04 8e 52 00 	movl   $0x528e,0x4(%esp)
+    1486:	00 
+    1487:	89 04 24             	mov    %eax,(%esp)
+    148a:	e8 71 39 00 00       	call   4e00 <printf>
+    exit();
+    148f:	e8 0e 38 00 00       	call   4ca2 <exit>
+    printf(stdout, "open doesnotexist succeeded!\n");
+    1494:	a1 60 72 00 00       	mov    0x7260,%eax
+    1499:	c7 44 24 04 ae 52 00 	movl   $0x52ae,0x4(%esp)
+    14a0:	00 
+    14a1:	89 04 24             	mov    %eax,(%esp)
+    14a4:	e8 57 39 00 00       	call   4e00 <printf>
+    exit();
+    14a9:	e8 f4 37 00 00       	call   4ca2 <exit>
+    14ae:	66 90                	xchg   %ax,%ax
+
+000014b0 <writetest>:
+{
+    14b0:	55                   	push   %ebp
+    14b1:	89 e5                	mov    %esp,%ebp
+    14b3:	56                   	push   %esi
+    14b4:	53                   	push   %ebx
+    14b5:	83 ec 10             	sub    $0x10,%esp
+  printf(stdout, "small file test\n");
+    14b8:	a1 60 72 00 00       	mov    0x7260,%eax
+    14bd:	c7 44 24 04 da 52 00 	movl   $0x52da,0x4(%esp)
+    14c4:	00 
+    14c5:	89 04 24             	mov    %eax,(%esp)
+    14c8:	e8 33 39 00 00       	call   4e00 <printf>
+  fd = open("small", O_CREATE|O_RDWR);
+    14cd:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    14d4:	00 
+    14d5:	c7 04 24 eb 52 00 00 	movl   $0x52eb,(%esp)
+    14dc:	e8 01 38 00 00       	call   4ce2 <open>
+  if(fd >= 0){
+    14e1:	85 c0                	test   %eax,%eax
+  fd = open("small", O_CREATE|O_RDWR);
+    14e3:	89 c6                	mov    %eax,%esi
+  if(fd >= 0){
+    14e5:	0f 88 b1 01 00 00    	js     169c <writetest+0x1ec>
+    printf(stdout, "creat small succeeded; ok\n");
+    14eb:	a1 60 72 00 00       	mov    0x7260,%eax
+  for(i = 0; i < 100; i++){
+    14f0:	31 db                	xor    %ebx,%ebx
+    printf(stdout, "creat small succeeded; ok\n");
+    14f2:	c7 44 24 04 f1 52 00 	movl   $0x52f1,0x4(%esp)
+    14f9:	00 
+    14fa:	89 04 24             	mov    %eax,(%esp)
+    14fd:	e8 fe 38 00 00       	call   4e00 <printf>
+    1502:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(write(fd, "aaaaaaaaaa", 10) != 10){
+    1508:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+    150f:	00 
+    1510:	c7 44 24 04 28 53 00 	movl   $0x5328,0x4(%esp)
+    1517:	00 
+    1518:	89 34 24             	mov    %esi,(%esp)
+    151b:	e8 a2 37 00 00       	call   4cc2 <write>
+    1520:	83 f8 0a             	cmp    $0xa,%eax
+    1523:	0f 85 e9 00 00 00    	jne    1612 <writetest+0x162>
+    if(write(fd, "bbbbbbbbbb", 10) != 10){
+    1529:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+    1530:	00 
+    1531:	c7 44 24 04 33 53 00 	movl   $0x5333,0x4(%esp)
+    1538:	00 
+    1539:	89 34 24             	mov    %esi,(%esp)
+    153c:	e8 81 37 00 00       	call   4cc2 <write>
+    1541:	83 f8 0a             	cmp    $0xa,%eax
+    1544:	0f 85 e6 00 00 00    	jne    1630 <writetest+0x180>
+  for(i = 0; i < 100; i++){
+    154a:	83 c3 01             	add    $0x1,%ebx
+    154d:	83 fb 64             	cmp    $0x64,%ebx
+    1550:	75 b6                	jne    1508 <writetest+0x58>
+  printf(stdout, "writes ok\n");
+    1552:	a1 60 72 00 00       	mov    0x7260,%eax
+    1557:	c7 44 24 04 3e 53 00 	movl   $0x533e,0x4(%esp)
+    155e:	00 
+    155f:	89 04 24             	mov    %eax,(%esp)
+    1562:	e8 99 38 00 00       	call   4e00 <printf>
+  close(fd);
+    1567:	89 34 24             	mov    %esi,(%esp)
+    156a:	e8 5b 37 00 00       	call   4cca <close>
+  fd = open("small", O_RDONLY);
+    156f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1576:	00 
+    1577:	c7 04 24 eb 52 00 00 	movl   $0x52eb,(%esp)
+    157e:	e8 5f 37 00 00       	call   4ce2 <open>
+  if(fd >= 0){
+    1583:	85 c0                	test   %eax,%eax
+  fd = open("small", O_RDONLY);
+    1585:	89 c3                	mov    %eax,%ebx
+  if(fd >= 0){
+    1587:	0f 88 c1 00 00 00    	js     164e <writetest+0x19e>
+    printf(stdout, "open small succeeded ok\n");
+    158d:	a1 60 72 00 00       	mov    0x7260,%eax
+    1592:	c7 44 24 04 49 53 00 	movl   $0x5349,0x4(%esp)
+    1599:	00 
+    159a:	89 04 24             	mov    %eax,(%esp)
+    159d:	e8 5e 38 00 00       	call   4e00 <printf>
+  i = read(fd, buf, 2000);
+    15a2:	c7 44 24 08 d0 07 00 	movl   $0x7d0,0x8(%esp)
+    15a9:	00 
+    15aa:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    15b1:	00 
+    15b2:	89 1c 24             	mov    %ebx,(%esp)
+    15b5:	e8 00 37 00 00       	call   4cba <read>
+  if(i == 2000){
+    15ba:	3d d0 07 00 00       	cmp    $0x7d0,%eax
+    15bf:	0f 85 a3 00 00 00    	jne    1668 <writetest+0x1b8>
+    printf(stdout, "read succeeded ok\n");
+    15c5:	a1 60 72 00 00       	mov    0x7260,%eax
+    15ca:	c7 44 24 04 7d 53 00 	movl   $0x537d,0x4(%esp)
+    15d1:	00 
+    15d2:	89 04 24             	mov    %eax,(%esp)
+    15d5:	e8 26 38 00 00       	call   4e00 <printf>
+  close(fd);
+    15da:	89 1c 24             	mov    %ebx,(%esp)
+    15dd:	e8 e8 36 00 00       	call   4cca <close>
+  if(unlink("small") < 0){
+    15e2:	c7 04 24 eb 52 00 00 	movl   $0x52eb,(%esp)
+    15e9:	e8 04 37 00 00       	call   4cf2 <unlink>
+    15ee:	85 c0                	test   %eax,%eax
+    15f0:	0f 88 8c 00 00 00    	js     1682 <writetest+0x1d2>
+  printf(stdout, "small file test ok\n");
+    15f6:	a1 60 72 00 00       	mov    0x7260,%eax
+    15fb:	c7 44 24 04 a5 53 00 	movl   $0x53a5,0x4(%esp)
+    1602:	00 
+    1603:	89 04 24             	mov    %eax,(%esp)
+    1606:	e8 f5 37 00 00       	call   4e00 <printf>
+}
+    160b:	83 c4 10             	add    $0x10,%esp
+    160e:	5b                   	pop    %ebx
+    160f:	5e                   	pop    %esi
+    1610:	5d                   	pop    %ebp
+    1611:	c3                   	ret    
+      printf(stdout, "error: write aa %d new file failed\n", i);
+    1612:	a1 60 72 00 00       	mov    0x7260,%eax
+    1617:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    161b:	c7 44 24 04 ec 61 00 	movl   $0x61ec,0x4(%esp)
+    1622:	00 
+    1623:	89 04 24             	mov    %eax,(%esp)
+    1626:	e8 d5 37 00 00       	call   4e00 <printf>
+      exit();
+    162b:	e8 72 36 00 00       	call   4ca2 <exit>
+      printf(stdout, "error: write bb %d new file failed\n", i);
+    1630:	a1 60 72 00 00       	mov    0x7260,%eax
+    1635:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    1639:	c7 44 24 04 10 62 00 	movl   $0x6210,0x4(%esp)
+    1640:	00 
+    1641:	89 04 24             	mov    %eax,(%esp)
+    1644:	e8 b7 37 00 00       	call   4e00 <printf>
+      exit();
+    1649:	e8 54 36 00 00       	call   4ca2 <exit>
+    printf(stdout, "error: open small failed!\n");
+    164e:	a1 60 72 00 00       	mov    0x7260,%eax
+    1653:	c7 44 24 04 62 53 00 	movl   $0x5362,0x4(%esp)
+    165a:	00 
+    165b:	89 04 24             	mov    %eax,(%esp)
+    165e:	e8 9d 37 00 00       	call   4e00 <printf>
+    exit();
+    1663:	e8 3a 36 00 00       	call   4ca2 <exit>
+    printf(stdout, "read failed\n");
+    1668:	a1 60 72 00 00       	mov    0x7260,%eax
+    166d:	c7 44 24 04 a9 56 00 	movl   $0x56a9,0x4(%esp)
+    1674:	00 
+    1675:	89 04 24             	mov    %eax,(%esp)
+    1678:	e8 83 37 00 00       	call   4e00 <printf>
+    exit();
+    167d:	e8 20 36 00 00       	call   4ca2 <exit>
+    printf(stdout, "unlink small failed\n");
+    1682:	a1 60 72 00 00       	mov    0x7260,%eax
+    1687:	c7 44 24 04 90 53 00 	movl   $0x5390,0x4(%esp)
+    168e:	00 
+    168f:	89 04 24             	mov    %eax,(%esp)
+    1692:	e8 69 37 00 00       	call   4e00 <printf>
+    exit();
+    1697:	e8 06 36 00 00       	call   4ca2 <exit>
+    printf(stdout, "error: creat small failed!\n");
+    169c:	a1 60 72 00 00       	mov    0x7260,%eax
+    16a1:	c7 44 24 04 0c 53 00 	movl   $0x530c,0x4(%esp)
+    16a8:	00 
+    16a9:	89 04 24             	mov    %eax,(%esp)
+    16ac:	e8 4f 37 00 00       	call   4e00 <printf>
+    exit();
+    16b1:	e8 ec 35 00 00       	call   4ca2 <exit>
+    16b6:	8d 76 00             	lea    0x0(%esi),%esi
+    16b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+000016c0 <writetest1>:
+{
+    16c0:	55                   	push   %ebp
+    16c1:	89 e5                	mov    %esp,%ebp
+    16c3:	56                   	push   %esi
+    16c4:	53                   	push   %ebx
+    16c5:	83 ec 10             	sub    $0x10,%esp
+  printf(stdout, "big files test\n");
+    16c8:	a1 60 72 00 00       	mov    0x7260,%eax
+    16cd:	c7 44 24 04 b9 53 00 	movl   $0x53b9,0x4(%esp)
+    16d4:	00 
+    16d5:	89 04 24             	mov    %eax,(%esp)
+    16d8:	e8 23 37 00 00       	call   4e00 <printf>
+  fd = open("big", O_CREATE|O_RDWR);
+    16dd:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    16e4:	00 
+    16e5:	c7 04 24 33 54 00 00 	movl   $0x5433,(%esp)
+    16ec:	e8 f1 35 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    16f1:	85 c0                	test   %eax,%eax
+  fd = open("big", O_CREATE|O_RDWR);
+    16f3:	89 c6                	mov    %eax,%esi
+  if(fd < 0){
+    16f5:	0f 88 7a 01 00 00    	js     1875 <writetest1+0x1b5>
+    16fb:	31 db                	xor    %ebx,%ebx
+    16fd:	8d 76 00             	lea    0x0(%esi),%esi
+    if(write(fd, buf, 512) != 512){
+    1700:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+    1707:	00 
+    1708:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    170f:	00 
+    1710:	89 34 24             	mov    %esi,(%esp)
+    ((int*)buf)[0] = i;
+    1713:	89 1d 40 9a 00 00    	mov    %ebx,0x9a40
+    if(write(fd, buf, 512) != 512){
+    1719:	e8 a4 35 00 00       	call   4cc2 <write>
+    171e:	3d 00 02 00 00       	cmp    $0x200,%eax
+    1723:	0f 85 b2 00 00 00    	jne    17db <writetest1+0x11b>
+  for(i = 0; i < MAXFILE; i++){
+    1729:	83 c3 01             	add    $0x1,%ebx
+    172c:	81 fb 8c 00 00 00    	cmp    $0x8c,%ebx
+    1732:	75 cc                	jne    1700 <writetest1+0x40>
+  close(fd);
+    1734:	89 34 24             	mov    %esi,(%esp)
+    1737:	e8 8e 35 00 00       	call   4cca <close>
+  fd = open("big", O_RDONLY);
+    173c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1743:	00 
+    1744:	c7 04 24 33 54 00 00 	movl   $0x5433,(%esp)
+    174b:	e8 92 35 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    1750:	85 c0                	test   %eax,%eax
+  fd = open("big", O_RDONLY);
+    1752:	89 c6                	mov    %eax,%esi
+  if(fd < 0){
+    1754:	0f 88 01 01 00 00    	js     185b <writetest1+0x19b>
+    175a:	31 db                	xor    %ebx,%ebx
+    175c:	eb 1d                	jmp    177b <writetest1+0xbb>
+    175e:	66 90                	xchg   %ax,%ax
+    } else if(i != 512){
+    1760:	3d 00 02 00 00       	cmp    $0x200,%eax
+    1765:	0f 85 b0 00 00 00    	jne    181b <writetest1+0x15b>
+    if(((int*)buf)[0] != n){
+    176b:	a1 40 9a 00 00       	mov    0x9a40,%eax
+    1770:	39 d8                	cmp    %ebx,%eax
+    1772:	0f 85 81 00 00 00    	jne    17f9 <writetest1+0x139>
+    n++;
+    1778:	83 c3 01             	add    $0x1,%ebx
+    i = read(fd, buf, 512);
+    177b:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+    1782:	00 
+    1783:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    178a:	00 
+    178b:	89 34 24             	mov    %esi,(%esp)
+    178e:	e8 27 35 00 00       	call   4cba <read>
+    if(i == 0){
+    1793:	85 c0                	test   %eax,%eax
+    1795:	75 c9                	jne    1760 <writetest1+0xa0>
+      if(n == MAXFILE - 1){
+    1797:	81 fb 8b 00 00 00    	cmp    $0x8b,%ebx
+    179d:	0f 84 96 00 00 00    	je     1839 <writetest1+0x179>
+  close(fd);
+    17a3:	89 34 24             	mov    %esi,(%esp)
+    17a6:	e8 1f 35 00 00       	call   4cca <close>
+  if(unlink("big") < 0){
+    17ab:	c7 04 24 33 54 00 00 	movl   $0x5433,(%esp)
+    17b2:	e8 3b 35 00 00       	call   4cf2 <unlink>
+    17b7:	85 c0                	test   %eax,%eax
+    17b9:	0f 88 d0 00 00 00    	js     188f <writetest1+0x1cf>
+  printf(stdout, "big files ok\n");
+    17bf:	a1 60 72 00 00       	mov    0x7260,%eax
+    17c4:	c7 44 24 04 5a 54 00 	movl   $0x545a,0x4(%esp)
+    17cb:	00 
+    17cc:	89 04 24             	mov    %eax,(%esp)
+    17cf:	e8 2c 36 00 00       	call   4e00 <printf>
+}
+    17d4:	83 c4 10             	add    $0x10,%esp
+    17d7:	5b                   	pop    %ebx
+    17d8:	5e                   	pop    %esi
+    17d9:	5d                   	pop    %ebp
+    17da:	c3                   	ret    
+      printf(stdout, "error: write big file failed\n", i);
+    17db:	a1 60 72 00 00       	mov    0x7260,%eax
+    17e0:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    17e4:	c7 44 24 04 e3 53 00 	movl   $0x53e3,0x4(%esp)
+    17eb:	00 
+    17ec:	89 04 24             	mov    %eax,(%esp)
+    17ef:	e8 0c 36 00 00       	call   4e00 <printf>
+      exit();
+    17f4:	e8 a9 34 00 00       	call   4ca2 <exit>
+      printf(stdout, "read content of block %d is %d\n",
+    17f9:	89 44 24 0c          	mov    %eax,0xc(%esp)
+    17fd:	a1 60 72 00 00       	mov    0x7260,%eax
+    1802:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    1806:	c7 44 24 04 34 62 00 	movl   $0x6234,0x4(%esp)
+    180d:	00 
+    180e:	89 04 24             	mov    %eax,(%esp)
+    1811:	e8 ea 35 00 00       	call   4e00 <printf>
+      exit();
+    1816:	e8 87 34 00 00       	call   4ca2 <exit>
+      printf(stdout, "read failed %d\n", i);
+    181b:	89 44 24 08          	mov    %eax,0x8(%esp)
+    181f:	a1 60 72 00 00       	mov    0x7260,%eax
+    1824:	c7 44 24 04 37 54 00 	movl   $0x5437,0x4(%esp)
+    182b:	00 
+    182c:	89 04 24             	mov    %eax,(%esp)
+    182f:	e8 cc 35 00 00       	call   4e00 <printf>
+      exit();
+    1834:	e8 69 34 00 00       	call   4ca2 <exit>
+        printf(stdout, "read only %d blocks from big", n);
+    1839:	a1 60 72 00 00       	mov    0x7260,%eax
+    183e:	c7 44 24 08 8b 00 00 	movl   $0x8b,0x8(%esp)
+    1845:	00 
+    1846:	c7 44 24 04 1a 54 00 	movl   $0x541a,0x4(%esp)
+    184d:	00 
+    184e:	89 04 24             	mov    %eax,(%esp)
+    1851:	e8 aa 35 00 00       	call   4e00 <printf>
+        exit();
+    1856:	e8 47 34 00 00       	call   4ca2 <exit>
+    printf(stdout, "error: open big failed!\n");
+    185b:	a1 60 72 00 00       	mov    0x7260,%eax
+    1860:	c7 44 24 04 01 54 00 	movl   $0x5401,0x4(%esp)
+    1867:	00 
+    1868:	89 04 24             	mov    %eax,(%esp)
+    186b:	e8 90 35 00 00       	call   4e00 <printf>
+    exit();
+    1870:	e8 2d 34 00 00       	call   4ca2 <exit>
+    printf(stdout, "error: creat big failed!\n");
+    1875:	a1 60 72 00 00       	mov    0x7260,%eax
+    187a:	c7 44 24 04 c9 53 00 	movl   $0x53c9,0x4(%esp)
+    1881:	00 
+    1882:	89 04 24             	mov    %eax,(%esp)
+    1885:	e8 76 35 00 00       	call   4e00 <printf>
+    exit();
+    188a:	e8 13 34 00 00       	call   4ca2 <exit>
+    printf(stdout, "unlink big failed\n");
+    188f:	a1 60 72 00 00       	mov    0x7260,%eax
+    1894:	c7 44 24 04 47 54 00 	movl   $0x5447,0x4(%esp)
+    189b:	00 
+    189c:	89 04 24             	mov    %eax,(%esp)
+    189f:	e8 5c 35 00 00       	call   4e00 <printf>
+    exit();
+    18a4:	e8 f9 33 00 00       	call   4ca2 <exit>
+    18a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000018b0 <createtest>:
+{
+    18b0:	55                   	push   %ebp
+    18b1:	89 e5                	mov    %esp,%ebp
+    18b3:	53                   	push   %ebx
+  name[2] = '\0';
+    18b4:	bb 30 00 00 00       	mov    $0x30,%ebx
+{
+    18b9:	83 ec 14             	sub    $0x14,%esp
+  printf(stdout, "many creates, followed by unlink test\n");
+    18bc:	a1 60 72 00 00       	mov    0x7260,%eax
+    18c1:	c7 44 24 04 54 62 00 	movl   $0x6254,0x4(%esp)
+    18c8:	00 
+    18c9:	89 04 24             	mov    %eax,(%esp)
+    18cc:	e8 2f 35 00 00       	call   4e00 <printf>
+  name[0] = 'a';
+    18d1:	c6 05 40 ba 00 00 61 	movb   $0x61,0xba40
+  name[2] = '\0';
+    18d8:	c6 05 42 ba 00 00 00 	movb   $0x0,0xba42
+    18df:	90                   	nop
+    fd = open(name, O_CREATE|O_RDWR);
+    18e0:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    18e7:	00 
+    18e8:	c7 04 24 40 ba 00 00 	movl   $0xba40,(%esp)
+    name[1] = '0' + i;
+    18ef:	88 1d 41 ba 00 00    	mov    %bl,0xba41
+    18f5:	83 c3 01             	add    $0x1,%ebx
+    fd = open(name, O_CREATE|O_RDWR);
+    18f8:	e8 e5 33 00 00       	call   4ce2 <open>
+    close(fd);
+    18fd:	89 04 24             	mov    %eax,(%esp)
+    1900:	e8 c5 33 00 00       	call   4cca <close>
+  for(i = 0; i < 52; i++){
+    1905:	80 fb 64             	cmp    $0x64,%bl
+    1908:	75 d6                	jne    18e0 <createtest+0x30>
+  name[0] = 'a';
+    190a:	c6 05 40 ba 00 00 61 	movb   $0x61,0xba40
+  name[2] = '\0';
+    1911:	bb 30 00 00 00       	mov    $0x30,%ebx
+    1916:	c6 05 42 ba 00 00 00 	movb   $0x0,0xba42
+    191d:	8d 76 00             	lea    0x0(%esi),%esi
+    name[1] = '0' + i;
+    1920:	88 1d 41 ba 00 00    	mov    %bl,0xba41
+    1926:	83 c3 01             	add    $0x1,%ebx
+    unlink(name);
+    1929:	c7 04 24 40 ba 00 00 	movl   $0xba40,(%esp)
+    1930:	e8 bd 33 00 00       	call   4cf2 <unlink>
+  for(i = 0; i < 52; i++){
+    1935:	80 fb 64             	cmp    $0x64,%bl
+    1938:	75 e6                	jne    1920 <createtest+0x70>
+  printf(stdout, "many creates, followed by unlink; ok\n");
+    193a:	a1 60 72 00 00       	mov    0x7260,%eax
+    193f:	c7 44 24 04 7c 62 00 	movl   $0x627c,0x4(%esp)
+    1946:	00 
+    1947:	89 04 24             	mov    %eax,(%esp)
+    194a:	e8 b1 34 00 00       	call   4e00 <printf>
+}
+    194f:	83 c4 14             	add    $0x14,%esp
+    1952:	5b                   	pop    %ebx
+    1953:	5d                   	pop    %ebp
+    1954:	c3                   	ret    
+    1955:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1959:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001960 <dirtest>:
+{
+    1960:	55                   	push   %ebp
+    1961:	89 e5                	mov    %esp,%ebp
+    1963:	83 ec 18             	sub    $0x18,%esp
+  printf(stdout, "mkdir test\n");
+    1966:	a1 60 72 00 00       	mov    0x7260,%eax
+    196b:	c7 44 24 04 68 54 00 	movl   $0x5468,0x4(%esp)
+    1972:	00 
+    1973:	89 04 24             	mov    %eax,(%esp)
+    1976:	e8 85 34 00 00       	call   4e00 <printf>
+  if(mkdir("dir0") < 0){
+    197b:	c7 04 24 74 54 00 00 	movl   $0x5474,(%esp)
+    1982:	e8 83 33 00 00       	call   4d0a <mkdir>
+    1987:	85 c0                	test   %eax,%eax
+    1989:	78 4b                	js     19d6 <dirtest+0x76>
+  if(chdir("dir0") < 0){
+    198b:	c7 04 24 74 54 00 00 	movl   $0x5474,(%esp)
+    1992:	e8 7b 33 00 00       	call   4d12 <chdir>
+    1997:	85 c0                	test   %eax,%eax
+    1999:	0f 88 85 00 00 00    	js     1a24 <dirtest+0xc4>
+  if(chdir("..") < 0){
+    199f:	c7 04 24 19 5a 00 00 	movl   $0x5a19,(%esp)
+    19a6:	e8 67 33 00 00       	call   4d12 <chdir>
+    19ab:	85 c0                	test   %eax,%eax
+    19ad:	78 5b                	js     1a0a <dirtest+0xaa>
+  if(unlink("dir0") < 0){
+    19af:	c7 04 24 74 54 00 00 	movl   $0x5474,(%esp)
+    19b6:	e8 37 33 00 00       	call   4cf2 <unlink>
+    19bb:	85 c0                	test   %eax,%eax
+    19bd:	78 31                	js     19f0 <dirtest+0x90>
+  printf(stdout, "mkdir test ok\n");
+    19bf:	a1 60 72 00 00       	mov    0x7260,%eax
+    19c4:	c7 44 24 04 b1 54 00 	movl   $0x54b1,0x4(%esp)
+    19cb:	00 
+    19cc:	89 04 24             	mov    %eax,(%esp)
+    19cf:	e8 2c 34 00 00       	call   4e00 <printf>
+}
+    19d4:	c9                   	leave  
+    19d5:	c3                   	ret    
+    printf(stdout, "mkdir failed\n");
+    19d6:	a1 60 72 00 00       	mov    0x7260,%eax
+    19db:	c7 44 24 04 a4 51 00 	movl   $0x51a4,0x4(%esp)
+    19e2:	00 
+    19e3:	89 04 24             	mov    %eax,(%esp)
+    19e6:	e8 15 34 00 00       	call   4e00 <printf>
+    exit();
+    19eb:	e8 b2 32 00 00       	call   4ca2 <exit>
+    printf(stdout, "unlink dir0 failed\n");
+    19f0:	a1 60 72 00 00       	mov    0x7260,%eax
+    19f5:	c7 44 24 04 9d 54 00 	movl   $0x549d,0x4(%esp)
+    19fc:	00 
+    19fd:	89 04 24             	mov    %eax,(%esp)
+    1a00:	e8 fb 33 00 00       	call   4e00 <printf>
+    exit();
+    1a05:	e8 98 32 00 00       	call   4ca2 <exit>
+    printf(stdout, "chdir .. failed\n");
+    1a0a:	a1 60 72 00 00       	mov    0x7260,%eax
+    1a0f:	c7 44 24 04 8c 54 00 	movl   $0x548c,0x4(%esp)
+    1a16:	00 
+    1a17:	89 04 24             	mov    %eax,(%esp)
+    1a1a:	e8 e1 33 00 00       	call   4e00 <printf>
+    exit();
+    1a1f:	e8 7e 32 00 00       	call   4ca2 <exit>
+    printf(stdout, "chdir dir0 failed\n");
+    1a24:	a1 60 72 00 00       	mov    0x7260,%eax
+    1a29:	c7 44 24 04 79 54 00 	movl   $0x5479,0x4(%esp)
+    1a30:	00 
+    1a31:	89 04 24             	mov    %eax,(%esp)
+    1a34:	e8 c7 33 00 00       	call   4e00 <printf>
+    exit();
+    1a39:	e8 64 32 00 00       	call   4ca2 <exit>
+    1a3e:	66 90                	xchg   %ax,%ax
+
+00001a40 <exectest>:
+{
+    1a40:	55                   	push   %ebp
+    1a41:	89 e5                	mov    %esp,%ebp
+    1a43:	83 ec 18             	sub    $0x18,%esp
+  printf(stdout, "exec test\n");
+    1a46:	a1 60 72 00 00       	mov    0x7260,%eax
+    1a4b:	c7 44 24 04 c0 54 00 	movl   $0x54c0,0x4(%esp)
+    1a52:	00 
+    1a53:	89 04 24             	mov    %eax,(%esp)
+    1a56:	e8 a5 33 00 00       	call   4e00 <printf>
+  if(exec("echo", echoargv) < 0){
+    1a5b:	c7 44 24 04 64 72 00 	movl   $0x7264,0x4(%esp)
+    1a62:	00 
+    1a63:	c7 04 24 89 52 00 00 	movl   $0x5289,(%esp)
+    1a6a:	e8 6b 32 00 00       	call   4cda <exec>
+    1a6f:	85 c0                	test   %eax,%eax
+    1a71:	78 02                	js     1a75 <exectest+0x35>
+}
+    1a73:	c9                   	leave  
+    1a74:	c3                   	ret    
+    printf(stdout, "exec echo failed\n");
+    1a75:	a1 60 72 00 00       	mov    0x7260,%eax
+    1a7a:	c7 44 24 04 cb 54 00 	movl   $0x54cb,0x4(%esp)
+    1a81:	00 
+    1a82:	89 04 24             	mov    %eax,(%esp)
+    1a85:	e8 76 33 00 00       	call   4e00 <printf>
+    exit();
+    1a8a:	e8 13 32 00 00       	call   4ca2 <exit>
+    1a8f:	90                   	nop
+
+00001a90 <pipe1>:
+{
+    1a90:	55                   	push   %ebp
+    1a91:	89 e5                	mov    %esp,%ebp
+    1a93:	57                   	push   %edi
+    1a94:	56                   	push   %esi
+    1a95:	53                   	push   %ebx
+    1a96:	83 ec 2c             	sub    $0x2c,%esp
+  if(pipe(fds) != 0){
+    1a99:	8d 45 e0             	lea    -0x20(%ebp),%eax
+    1a9c:	89 04 24             	mov    %eax,(%esp)
+    1a9f:	e8 0e 32 00 00       	call   4cb2 <pipe>
+    1aa4:	85 c0                	test   %eax,%eax
+    1aa6:	0f 85 4e 01 00 00    	jne    1bfa <pipe1+0x16a>
+  pid = fork();
+    1aac:	e8 e9 31 00 00       	call   4c9a <fork>
+  if(pid == 0){
+    1ab1:	83 f8 00             	cmp    $0x0,%eax
+    1ab4:	0f 84 93 00 00 00    	je     1b4d <pipe1+0xbd>
+  } else if(pid > 0){
+    1aba:	0f 8e 53 01 00 00    	jle    1c13 <pipe1+0x183>
+    close(fds[1]);
+    1ac0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    cc = 1;
+    1ac3:	bf 01 00 00 00       	mov    $0x1,%edi
+  seq = 0;
+    1ac8:	31 db                	xor    %ebx,%ebx
+    close(fds[1]);
+    1aca:	89 04 24             	mov    %eax,(%esp)
+    1acd:	e8 f8 31 00 00       	call   4cca <close>
+    total = 0;
+    1ad2:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+    while((n = read(fds[0], buf, cc)) > 0){
+    1ad9:	8b 45 e0             	mov    -0x20(%ebp),%eax
+    1adc:	89 7c 24 08          	mov    %edi,0x8(%esp)
+    1ae0:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    1ae7:	00 
+    1ae8:	89 04 24             	mov    %eax,(%esp)
+    1aeb:	e8 ca 31 00 00       	call   4cba <read>
+    1af0:	85 c0                	test   %eax,%eax
+    1af2:	0f 8e b3 00 00 00    	jle    1bab <pipe1+0x11b>
+    1af8:	89 d9                	mov    %ebx,%ecx
+    1afa:	8d 34 03             	lea    (%ebx,%eax,1),%esi
+    1afd:	f7 d9                	neg    %ecx
+    1aff:	eb 09                	jmp    1b0a <pipe1+0x7a>
+    1b01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        if((buf[i] & 0xff) != (seq++ & 0xff)){
+    1b08:	89 d3                	mov    %edx,%ebx
+    1b0a:	38 9c 0b 40 9a 00 00 	cmp    %bl,0x9a40(%ebx,%ecx,1)
+    1b11:	8d 53 01             	lea    0x1(%ebx),%edx
+    1b14:	75 1b                	jne    1b31 <pipe1+0xa1>
+      for(i = 0; i < n; i++){
+    1b16:	39 f2                	cmp    %esi,%edx
+    1b18:	75 ee                	jne    1b08 <pipe1+0x78>
+      cc = cc * 2;
+    1b1a:	01 ff                	add    %edi,%edi
+        if((buf[i] & 0xff) != (seq++ & 0xff)){
+    1b1c:	89 f3                	mov    %esi,%ebx
+      total += n;
+    1b1e:	01 45 d4             	add    %eax,-0x2c(%ebp)
+        cc = sizeof(buf);
+    1b21:	81 ff 01 20 00 00    	cmp    $0x2001,%edi
+    1b27:	b8 00 20 00 00       	mov    $0x2000,%eax
+    1b2c:	0f 43 f8             	cmovae %eax,%edi
+    1b2f:	eb a8                	jmp    1ad9 <pipe1+0x49>
+          printf(1, "pipe1 oops 2\n");
+    1b31:	c7 44 24 04 fa 54 00 	movl   $0x54fa,0x4(%esp)
+    1b38:	00 
+    1b39:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1b40:	e8 bb 32 00 00       	call   4e00 <printf>
+}
+    1b45:	83 c4 2c             	add    $0x2c,%esp
+    1b48:	5b                   	pop    %ebx
+    1b49:	5e                   	pop    %esi
+    1b4a:	5f                   	pop    %edi
+    1b4b:	5d                   	pop    %ebp
+    1b4c:	c3                   	ret    
+    close(fds[0]);
+    1b4d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  seq = 0;
+    1b50:	31 f6                	xor    %esi,%esi
+    close(fds[0]);
+    1b52:	89 04 24             	mov    %eax,(%esp)
+    1b55:	e8 70 31 00 00       	call   4cca <close>
+    1b5a:	89 f0                	mov    %esi,%eax
+{
+    1b5c:	89 f3                	mov    %esi,%ebx
+    1b5e:	8d 96 09 04 00 00    	lea    0x409(%esi),%edx
+    1b64:	f7 d8                	neg    %eax
+    1b66:	66 90                	xchg   %ax,%ax
+        buf[i] = seq++;
+    1b68:	88 9c 18 40 9a 00 00 	mov    %bl,0x9a40(%eax,%ebx,1)
+    1b6f:	83 c3 01             	add    $0x1,%ebx
+      for(i = 0; i < 1033; i++)
+    1b72:	39 d3                	cmp    %edx,%ebx
+    1b74:	75 f2                	jne    1b68 <pipe1+0xd8>
+      if(write(fds[1], buf, 1033) != 1033){
+    1b76:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1b79:	89 de                	mov    %ebx,%esi
+    1b7b:	c7 44 24 08 09 04 00 	movl   $0x409,0x8(%esp)
+    1b82:	00 
+    1b83:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    1b8a:	00 
+    1b8b:	89 04 24             	mov    %eax,(%esp)
+    1b8e:	e8 2f 31 00 00       	call   4cc2 <write>
+    1b93:	3d 09 04 00 00       	cmp    $0x409,%eax
+    1b98:	0f 85 8e 00 00 00    	jne    1c2c <pipe1+0x19c>
+    for(n = 0; n < 5; n++){
+    1b9e:	81 fb 2d 14 00 00    	cmp    $0x142d,%ebx
+    1ba4:	75 b4                	jne    1b5a <pipe1+0xca>
+      exit();
+    1ba6:	e8 f7 30 00 00       	call   4ca2 <exit>
+    if(total != 5 * 1033){
+    1bab:	81 7d d4 2d 14 00 00 	cmpl   $0x142d,-0x2c(%ebp)
+    1bb2:	75 29                	jne    1bdd <pipe1+0x14d>
+    close(fds[0]);
+    1bb4:	8b 45 e0             	mov    -0x20(%ebp),%eax
+    1bb7:	89 04 24             	mov    %eax,(%esp)
+    1bba:	e8 0b 31 00 00       	call   4cca <close>
+    wait();
+    1bbf:	e8 e6 30 00 00       	call   4caa <wait>
+  printf(1, "pipe1 ok\n");
+    1bc4:	c7 44 24 04 1f 55 00 	movl   $0x551f,0x4(%esp)
+    1bcb:	00 
+    1bcc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1bd3:	e8 28 32 00 00       	call   4e00 <printf>
+    1bd8:	e9 68 ff ff ff       	jmp    1b45 <pipe1+0xb5>
+      printf(1, "pipe1 oops 3 total %d\n", total);
+    1bdd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1be0:	c7 44 24 04 08 55 00 	movl   $0x5508,0x4(%esp)
+    1be7:	00 
+    1be8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1bef:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1bf3:	e8 08 32 00 00       	call   4e00 <printf>
+    1bf8:	eb ac                	jmp    1ba6 <pipe1+0x116>
+    printf(1, "pipe() failed\n");
+    1bfa:	c7 44 24 04 dd 54 00 	movl   $0x54dd,0x4(%esp)
+    1c01:	00 
+    1c02:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1c09:	e8 f2 31 00 00       	call   4e00 <printf>
+    exit();
+    1c0e:	e8 8f 30 00 00       	call   4ca2 <exit>
+    printf(1, "fork() failed\n");
+    1c13:	c7 44 24 04 29 55 00 	movl   $0x5529,0x4(%esp)
+    1c1a:	00 
+    1c1b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1c22:	e8 d9 31 00 00       	call   4e00 <printf>
+    exit();
+    1c27:	e8 76 30 00 00       	call   4ca2 <exit>
+        printf(1, "pipe1 oops 1\n");
+    1c2c:	c7 44 24 04 ec 54 00 	movl   $0x54ec,0x4(%esp)
+    1c33:	00 
+    1c34:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1c3b:	e8 c0 31 00 00       	call   4e00 <printf>
+        exit();
+    1c40:	e8 5d 30 00 00       	call   4ca2 <exit>
+    1c45:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1c49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001c50 <preempt>:
+{
+    1c50:	55                   	push   %ebp
+    1c51:	89 e5                	mov    %esp,%ebp
+    1c53:	57                   	push   %edi
+    1c54:	56                   	push   %esi
+    1c55:	53                   	push   %ebx
+    1c56:	83 ec 2c             	sub    $0x2c,%esp
+  printf(1, "preempt: ");
+    1c59:	c7 44 24 04 38 55 00 	movl   $0x5538,0x4(%esp)
+    1c60:	00 
+    1c61:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1c68:	e8 93 31 00 00       	call   4e00 <printf>
+  pid1 = fork();
+    1c6d:	e8 28 30 00 00       	call   4c9a <fork>
+  if(pid1 == 0)
+    1c72:	85 c0                	test   %eax,%eax
+  pid1 = fork();
+    1c74:	89 c7                	mov    %eax,%edi
+  if(pid1 == 0)
+    1c76:	75 02                	jne    1c7a <preempt+0x2a>
+    1c78:	eb fe                	jmp    1c78 <preempt+0x28>
+    1c7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  pid2 = fork();
+    1c80:	e8 15 30 00 00       	call   4c9a <fork>
+  if(pid2 == 0)
+    1c85:	85 c0                	test   %eax,%eax
+  pid2 = fork();
+    1c87:	89 c6                	mov    %eax,%esi
+  if(pid2 == 0)
+    1c89:	75 02                	jne    1c8d <preempt+0x3d>
+    1c8b:	eb fe                	jmp    1c8b <preempt+0x3b>
+  pipe(pfds);
+    1c8d:	8d 45 e0             	lea    -0x20(%ebp),%eax
+    1c90:	89 04 24             	mov    %eax,(%esp)
+    1c93:	e8 1a 30 00 00       	call   4cb2 <pipe>
+  pid3 = fork();
+    1c98:	e8 fd 2f 00 00       	call   4c9a <fork>
+  if(pid3 == 0){
+    1c9d:	85 c0                	test   %eax,%eax
+  pid3 = fork();
+    1c9f:	89 c3                	mov    %eax,%ebx
+  if(pid3 == 0){
+    1ca1:	75 4c                	jne    1cef <preempt+0x9f>
+    close(pfds[0]);
+    1ca3:	8b 45 e0             	mov    -0x20(%ebp),%eax
+    1ca6:	89 04 24             	mov    %eax,(%esp)
+    1ca9:	e8 1c 30 00 00       	call   4cca <close>
+    if(write(pfds[1], "x", 1) != 1)
+    1cae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1cb1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1cb8:	00 
+    1cb9:	c7 44 24 04 fd 5a 00 	movl   $0x5afd,0x4(%esp)
+    1cc0:	00 
+    1cc1:	89 04 24             	mov    %eax,(%esp)
+    1cc4:	e8 f9 2f 00 00       	call   4cc2 <write>
+    1cc9:	83 f8 01             	cmp    $0x1,%eax
+    1ccc:	74 14                	je     1ce2 <preempt+0x92>
+      printf(1, "preempt write error");
+    1cce:	c7 44 24 04 42 55 00 	movl   $0x5542,0x4(%esp)
+    1cd5:	00 
+    1cd6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1cdd:	e8 1e 31 00 00       	call   4e00 <printf>
+    close(pfds[1]);
+    1ce2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1ce5:	89 04 24             	mov    %eax,(%esp)
+    1ce8:	e8 dd 2f 00 00       	call   4cca <close>
+    1ced:	eb fe                	jmp    1ced <preempt+0x9d>
+  close(pfds[1]);
+    1cef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1cf2:	89 04 24             	mov    %eax,(%esp)
+    1cf5:	e8 d0 2f 00 00       	call   4cca <close>
+  if(read(pfds[0], buf, sizeof(buf)) != 1){
+    1cfa:	8b 45 e0             	mov    -0x20(%ebp),%eax
+    1cfd:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
+    1d04:	00 
+    1d05:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    1d0c:	00 
+    1d0d:	89 04 24             	mov    %eax,(%esp)
+    1d10:	e8 a5 2f 00 00       	call   4cba <read>
+    1d15:	83 f8 01             	cmp    $0x1,%eax
+    1d18:	74 1c                	je     1d36 <preempt+0xe6>
+    printf(1, "preempt read error");
+    1d1a:	c7 44 24 04 56 55 00 	movl   $0x5556,0x4(%esp)
+    1d21:	00 
+    1d22:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1d29:	e8 d2 30 00 00       	call   4e00 <printf>
+}
+    1d2e:	83 c4 2c             	add    $0x2c,%esp
+    1d31:	5b                   	pop    %ebx
+    1d32:	5e                   	pop    %esi
+    1d33:	5f                   	pop    %edi
+    1d34:	5d                   	pop    %ebp
+    1d35:	c3                   	ret    
+  close(pfds[0]);
+    1d36:	8b 45 e0             	mov    -0x20(%ebp),%eax
+    1d39:	89 04 24             	mov    %eax,(%esp)
+    1d3c:	e8 89 2f 00 00       	call   4cca <close>
+  printf(1, "kill... ");
+    1d41:	c7 44 24 04 69 55 00 	movl   $0x5569,0x4(%esp)
+    1d48:	00 
+    1d49:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1d50:	e8 ab 30 00 00       	call   4e00 <printf>
+  kill(pid1);
+    1d55:	89 3c 24             	mov    %edi,(%esp)
+    1d58:	e8 75 2f 00 00       	call   4cd2 <kill>
+  kill(pid2);
+    1d5d:	89 34 24             	mov    %esi,(%esp)
+    1d60:	e8 6d 2f 00 00       	call   4cd2 <kill>
+  kill(pid3);
+    1d65:	89 1c 24             	mov    %ebx,(%esp)
+    1d68:	e8 65 2f 00 00       	call   4cd2 <kill>
+  printf(1, "wait... ");
+    1d6d:	c7 44 24 04 72 55 00 	movl   $0x5572,0x4(%esp)
+    1d74:	00 
+    1d75:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1d7c:	e8 7f 30 00 00       	call   4e00 <printf>
+  wait();
+    1d81:	e8 24 2f 00 00       	call   4caa <wait>
+  wait();
+    1d86:	e8 1f 2f 00 00       	call   4caa <wait>
+    1d8b:	90                   	nop
+    1d8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  wait();
+    1d90:	e8 15 2f 00 00       	call   4caa <wait>
+  printf(1, "preempt ok\n");
+    1d95:	c7 44 24 04 7b 55 00 	movl   $0x557b,0x4(%esp)
+    1d9c:	00 
+    1d9d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1da4:	e8 57 30 00 00       	call   4e00 <printf>
+    1da9:	eb 83                	jmp    1d2e <preempt+0xde>
+    1dab:	90                   	nop
+    1dac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00001db0 <exitwait>:
+{
+    1db0:	55                   	push   %ebp
+    1db1:	89 e5                	mov    %esp,%ebp
+    1db3:	56                   	push   %esi
+    1db4:	be 64 00 00 00       	mov    $0x64,%esi
+    1db9:	53                   	push   %ebx
+    1dba:	83 ec 10             	sub    $0x10,%esp
+    1dbd:	eb 13                	jmp    1dd2 <exitwait+0x22>
+    1dbf:	90                   	nop
+    if(pid){
+    1dc0:	74 71                	je     1e33 <exitwait+0x83>
+      if(wait() != pid){
+    1dc2:	e8 e3 2e 00 00       	call   4caa <wait>
+    1dc7:	39 d8                	cmp    %ebx,%eax
+    1dc9:	75 2d                	jne    1df8 <exitwait+0x48>
+  for(i = 0; i < 100; i++){
+    1dcb:	83 ee 01             	sub    $0x1,%esi
+    1dce:	66 90                	xchg   %ax,%ax
+    1dd0:	74 46                	je     1e18 <exitwait+0x68>
+    pid = fork();
+    1dd2:	e8 c3 2e 00 00       	call   4c9a <fork>
+    if(pid < 0){
+    1dd7:	85 c0                	test   %eax,%eax
+    pid = fork();
+    1dd9:	89 c3                	mov    %eax,%ebx
+    if(pid < 0){
+    1ddb:	79 e3                	jns    1dc0 <exitwait+0x10>
+      printf(1, "fork failed\n");
+    1ddd:	c7 44 24 04 e5 60 00 	movl   $0x60e5,0x4(%esp)
+    1de4:	00 
+    1de5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1dec:	e8 0f 30 00 00       	call   4e00 <printf>
+}
+    1df1:	83 c4 10             	add    $0x10,%esp
+    1df4:	5b                   	pop    %ebx
+    1df5:	5e                   	pop    %esi
+    1df6:	5d                   	pop    %ebp
+    1df7:	c3                   	ret    
+        printf(1, "wait wrong pid\n");
+    1df8:	c7 44 24 04 87 55 00 	movl   $0x5587,0x4(%esp)
+    1dff:	00 
+    1e00:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1e07:	e8 f4 2f 00 00       	call   4e00 <printf>
+}
+    1e0c:	83 c4 10             	add    $0x10,%esp
+    1e0f:	5b                   	pop    %ebx
+    1e10:	5e                   	pop    %esi
+    1e11:	5d                   	pop    %ebp
+    1e12:	c3                   	ret    
+    1e13:	90                   	nop
+    1e14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  printf(1, "exitwait ok\n");
+    1e18:	c7 44 24 04 97 55 00 	movl   $0x5597,0x4(%esp)
+    1e1f:	00 
+    1e20:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1e27:	e8 d4 2f 00 00       	call   4e00 <printf>
+}
+    1e2c:	83 c4 10             	add    $0x10,%esp
+    1e2f:	5b                   	pop    %ebx
+    1e30:	5e                   	pop    %esi
+    1e31:	5d                   	pop    %ebp
+    1e32:	c3                   	ret    
+      exit();
+    1e33:	e8 6a 2e 00 00       	call   4ca2 <exit>
+    1e38:	90                   	nop
+    1e39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001e40 <mem>:
+{
+    1e40:	55                   	push   %ebp
+    1e41:	89 e5                	mov    %esp,%ebp
+    1e43:	57                   	push   %edi
+    1e44:	56                   	push   %esi
+    1e45:	53                   	push   %ebx
+    1e46:	83 ec 1c             	sub    $0x1c,%esp
+  printf(1, "mem test\n");
+    1e49:	c7 44 24 04 a4 55 00 	movl   $0x55a4,0x4(%esp)
+    1e50:	00 
+    1e51:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1e58:	e8 a3 2f 00 00       	call   4e00 <printf>
+  ppid = getpid();
+    1e5d:	e8 c0 2e 00 00       	call   4d22 <getpid>
+    1e62:	89 c6                	mov    %eax,%esi
+  if((pid = fork()) == 0){
+    1e64:	e8 31 2e 00 00       	call   4c9a <fork>
+    1e69:	85 c0                	test   %eax,%eax
+    1e6b:	75 73                	jne    1ee0 <mem+0xa0>
+    1e6d:	31 db                	xor    %ebx,%ebx
+    1e6f:	90                   	nop
+    1e70:	eb 0a                	jmp    1e7c <mem+0x3c>
+    1e72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      *(char**)m2 = m1;
+    1e78:	89 18                	mov    %ebx,(%eax)
+    1e7a:	89 c3                	mov    %eax,%ebx
+    while((m2 = malloc(10001)) != 0){
+    1e7c:	c7 04 24 11 27 00 00 	movl   $0x2711,(%esp)
+    1e83:	e8 f8 31 00 00       	call   5080 <malloc>
+    1e88:	85 c0                	test   %eax,%eax
+    1e8a:	75 ec                	jne    1e78 <mem+0x38>
+    while(m1){
+    1e8c:	85 db                	test   %ebx,%ebx
+    1e8e:	75 0a                	jne    1e9a <mem+0x5a>
+    1e90:	eb 16                	jmp    1ea8 <mem+0x68>
+    1e92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      m1 = m2;
+    1e98:	89 fb                	mov    %edi,%ebx
+      m2 = *(char**)m1;
+    1e9a:	8b 3b                	mov    (%ebx),%edi
+      free(m1);
+    1e9c:	89 1c 24             	mov    %ebx,(%esp)
+    1e9f:	e8 4c 31 00 00       	call   4ff0 <free>
+    while(m1){
+    1ea4:	85 ff                	test   %edi,%edi
+    1ea6:	75 f0                	jne    1e98 <mem+0x58>
+    m1 = malloc(1024*20);
+    1ea8:	c7 04 24 00 50 00 00 	movl   $0x5000,(%esp)
+    1eaf:	e8 cc 31 00 00       	call   5080 <malloc>
+    if(m1 == 0){
+    1eb4:	85 c0                	test   %eax,%eax
+    1eb6:	74 38                	je     1ef0 <mem+0xb0>
+    free(m1);
+    1eb8:	89 04 24             	mov    %eax,(%esp)
+    1ebb:	e8 30 31 00 00       	call   4ff0 <free>
+    printf(1, "mem ok\n");
+    1ec0:	c7 44 24 04 c8 55 00 	movl   $0x55c8,0x4(%esp)
+    1ec7:	00 
+    1ec8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1ecf:	e8 2c 2f 00 00       	call   4e00 <printf>
+    exit();
+    1ed4:	e8 c9 2d 00 00       	call   4ca2 <exit>
+    1ed9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+}
+    1ee0:	83 c4 1c             	add    $0x1c,%esp
+    1ee3:	5b                   	pop    %ebx
+    1ee4:	5e                   	pop    %esi
+    1ee5:	5f                   	pop    %edi
+    1ee6:	5d                   	pop    %ebp
+    wait();
+    1ee7:	e9 be 2d 00 00       	jmp    4caa <wait>
+    1eec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      printf(1, "couldn't allocate mem?!!\n");
+    1ef0:	c7 44 24 04 ae 55 00 	movl   $0x55ae,0x4(%esp)
+    1ef7:	00 
+    1ef8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1eff:	e8 fc 2e 00 00       	call   4e00 <printf>
+      kill(ppid);
+    1f04:	89 34 24             	mov    %esi,(%esp)
+    1f07:	e8 c6 2d 00 00       	call   4cd2 <kill>
+      exit();
+    1f0c:	e8 91 2d 00 00       	call   4ca2 <exit>
+    1f11:	eb 0d                	jmp    1f20 <sharedfd>
+    1f13:	90                   	nop
+    1f14:	90                   	nop
+    1f15:	90                   	nop
+    1f16:	90                   	nop
+    1f17:	90                   	nop
+    1f18:	90                   	nop
+    1f19:	90                   	nop
+    1f1a:	90                   	nop
+    1f1b:	90                   	nop
+    1f1c:	90                   	nop
+    1f1d:	90                   	nop
+    1f1e:	90                   	nop
+    1f1f:	90                   	nop
+
+00001f20 <sharedfd>:
+{
+    1f20:	55                   	push   %ebp
+    1f21:	89 e5                	mov    %esp,%ebp
+    1f23:	57                   	push   %edi
+    1f24:	56                   	push   %esi
+    1f25:	53                   	push   %ebx
+    1f26:	83 ec 3c             	sub    $0x3c,%esp
+  printf(1, "sharedfd test\n");
+    1f29:	c7 44 24 04 d0 55 00 	movl   $0x55d0,0x4(%esp)
+    1f30:	00 
+    1f31:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1f38:	e8 c3 2e 00 00       	call   4e00 <printf>
+  unlink("sharedfd");
+    1f3d:	c7 04 24 df 55 00 00 	movl   $0x55df,(%esp)
+    1f44:	e8 a9 2d 00 00       	call   4cf2 <unlink>
+  fd = open("sharedfd", O_CREATE|O_RDWR);
+    1f49:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    1f50:	00 
+    1f51:	c7 04 24 df 55 00 00 	movl   $0x55df,(%esp)
+    1f58:	e8 85 2d 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    1f5d:	85 c0                	test   %eax,%eax
+  fd = open("sharedfd", O_CREATE|O_RDWR);
+    1f5f:	89 c7                	mov    %eax,%edi
+  if(fd < 0){
+    1f61:	0f 88 40 01 00 00    	js     20a7 <sharedfd+0x187>
+  pid = fork();
+    1f67:	e8 2e 2d 00 00       	call   4c9a <fork>
+  memset(buf, pid==0?'c':'p', sizeof(buf));
+    1f6c:	8d 75 de             	lea    -0x22(%ebp),%esi
+    1f6f:	bb e8 03 00 00       	mov    $0x3e8,%ebx
+    1f74:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+    1f7b:	00 
+    1f7c:	89 34 24             	mov    %esi,(%esp)
+    1f7f:	83 f8 01             	cmp    $0x1,%eax
+  pid = fork();
+    1f82:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  memset(buf, pid==0?'c':'p', sizeof(buf));
+    1f85:	19 c0                	sbb    %eax,%eax
+    1f87:	83 e0 f3             	and    $0xfffffff3,%eax
+    1f8a:	83 c0 70             	add    $0x70,%eax
+    1f8d:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1f91:	e8 9a 2b 00 00       	call   4b30 <memset>
+    1f96:	eb 05                	jmp    1f9d <sharedfd+0x7d>
+  for(i = 0; i < 1000; i++){
+    1f98:	83 eb 01             	sub    $0x1,%ebx
+    1f9b:	74 2d                	je     1fca <sharedfd+0xaa>
+    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+    1f9d:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+    1fa4:	00 
+    1fa5:	89 74 24 04          	mov    %esi,0x4(%esp)
+    1fa9:	89 3c 24             	mov    %edi,(%esp)
+    1fac:	e8 11 2d 00 00       	call   4cc2 <write>
+    1fb1:	83 f8 0a             	cmp    $0xa,%eax
+    1fb4:	74 e2                	je     1f98 <sharedfd+0x78>
+      printf(1, "fstests: write sharedfd failed\n");
+    1fb6:	c7 44 24 04 d0 62 00 	movl   $0x62d0,0x4(%esp)
+    1fbd:	00 
+    1fbe:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1fc5:	e8 36 2e 00 00       	call   4e00 <printf>
+  if(pid == 0)
+    1fca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1fcd:	85 c0                	test   %eax,%eax
+    1fcf:	0f 84 26 01 00 00    	je     20fb <sharedfd+0x1db>
+    wait();
+    1fd5:	e8 d0 2c 00 00       	call   4caa <wait>
+  close(fd);
+    1fda:	89 3c 24             	mov    %edi,(%esp)
+    1fdd:	e8 e8 2c 00 00       	call   4cca <close>
+  fd = open("sharedfd", 0);
+    1fe2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1fe9:	00 
+    1fea:	c7 04 24 df 55 00 00 	movl   $0x55df,(%esp)
+    1ff1:	e8 ec 2c 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    1ff6:	85 c0                	test   %eax,%eax
+  fd = open("sharedfd", 0);
+    1ff8:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  if(fd < 0){
+    1ffb:	0f 88 c2 00 00 00    	js     20c3 <sharedfd+0x1a3>
+    2001:	31 d2                	xor    %edx,%edx
+    2003:	31 db                	xor    %ebx,%ebx
+    2005:	8d 7d e8             	lea    -0x18(%ebp),%edi
+    2008:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    200b:	90                   	nop
+    200c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+    2010:	8b 45 d0             	mov    -0x30(%ebp),%eax
+    2013:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+    201a:	00 
+    201b:	89 74 24 04          	mov    %esi,0x4(%esp)
+    201f:	89 04 24             	mov    %eax,(%esp)
+    2022:	e8 93 2c 00 00       	call   4cba <read>
+    2027:	85 c0                	test   %eax,%eax
+    2029:	7e 36                	jle    2061 <sharedfd+0x141>
+    202b:	89 f0                	mov    %esi,%eax
+    202d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+    2030:	eb 18                	jmp    204a <sharedfd+0x12a>
+    2032:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        np++;
+    2038:	80 f9 70             	cmp    $0x70,%cl
+    203b:	0f 94 c1             	sete   %cl
+    203e:	83 c0 01             	add    $0x1,%eax
+    2041:	0f b6 c9             	movzbl %cl,%ecx
+    2044:	01 cb                	add    %ecx,%ebx
+    for(i = 0; i < sizeof(buf); i++){
+    2046:	39 f8                	cmp    %edi,%eax
+    2048:	74 12                	je     205c <sharedfd+0x13c>
+      if(buf[i] == 'c')
+    204a:	0f b6 08             	movzbl (%eax),%ecx
+    204d:	80 f9 63             	cmp    $0x63,%cl
+    2050:	75 e6                	jne    2038 <sharedfd+0x118>
+    2052:	83 c0 01             	add    $0x1,%eax
+        nc++;
+    2055:	83 c2 01             	add    $0x1,%edx
+    for(i = 0; i < sizeof(buf); i++){
+    2058:	39 f8                	cmp    %edi,%eax
+    205a:	75 ee                	jne    204a <sharedfd+0x12a>
+    205c:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    205f:	eb af                	jmp    2010 <sharedfd+0xf0>
+  close(fd);
+    2061:	8b 45 d0             	mov    -0x30(%ebp),%eax
+    2064:	89 04 24             	mov    %eax,(%esp)
+    2067:	e8 5e 2c 00 00       	call   4cca <close>
+  unlink("sharedfd");
+    206c:	c7 04 24 df 55 00 00 	movl   $0x55df,(%esp)
+    2073:	e8 7a 2c 00 00       	call   4cf2 <unlink>
+  if(nc == 10000 && np == 10000){
+    2078:	81 fb 10 27 00 00    	cmp    $0x2710,%ebx
+    207e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+    2081:	75 5c                	jne    20df <sharedfd+0x1bf>
+    2083:	81 fa 10 27 00 00    	cmp    $0x2710,%edx
+    2089:	75 54                	jne    20df <sharedfd+0x1bf>
+    printf(1, "sharedfd ok\n");
+    208b:	c7 44 24 04 e8 55 00 	movl   $0x55e8,0x4(%esp)
+    2092:	00 
+    2093:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    209a:	e8 61 2d 00 00       	call   4e00 <printf>
+}
+    209f:	83 c4 3c             	add    $0x3c,%esp
+    20a2:	5b                   	pop    %ebx
+    20a3:	5e                   	pop    %esi
+    20a4:	5f                   	pop    %edi
+    20a5:	5d                   	pop    %ebp
+    20a6:	c3                   	ret    
+    printf(1, "fstests: cannot open sharedfd for writing");
+    20a7:	c7 44 24 04 a4 62 00 	movl   $0x62a4,0x4(%esp)
+    20ae:	00 
+    20af:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    20b6:	e8 45 2d 00 00       	call   4e00 <printf>
+}
+    20bb:	83 c4 3c             	add    $0x3c,%esp
+    20be:	5b                   	pop    %ebx
+    20bf:	5e                   	pop    %esi
+    20c0:	5f                   	pop    %edi
+    20c1:	5d                   	pop    %ebp
+    20c2:	c3                   	ret    
+    printf(1, "fstests: cannot open sharedfd for reading\n");
+    20c3:	c7 44 24 04 f0 62 00 	movl   $0x62f0,0x4(%esp)
+    20ca:	00 
+    20cb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    20d2:	e8 29 2d 00 00       	call   4e00 <printf>
+}
+    20d7:	83 c4 3c             	add    $0x3c,%esp
+    20da:	5b                   	pop    %ebx
+    20db:	5e                   	pop    %esi
+    20dc:	5f                   	pop    %edi
+    20dd:	5d                   	pop    %ebp
+    20de:	c3                   	ret    
+    printf(1, "sharedfd oops %d %d\n", nc, np);
+    20df:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+    20e3:	89 54 24 08          	mov    %edx,0x8(%esp)
+    20e7:	c7 44 24 04 f5 55 00 	movl   $0x55f5,0x4(%esp)
+    20ee:	00 
+    20ef:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    20f6:	e8 05 2d 00 00       	call   4e00 <printf>
+    exit();
+    20fb:	e8 a2 2b 00 00       	call   4ca2 <exit>
+
+00002100 <fourfiles>:
+{
+    2100:	55                   	push   %ebp
+    2101:	89 e5                	mov    %esp,%ebp
+    2103:	57                   	push   %edi
+    2104:	56                   	push   %esi
+  printf(1, "fourfiles test\n");
+    2105:	be 0a 56 00 00       	mov    $0x560a,%esi
+{
+    210a:	53                   	push   %ebx
+  for(pi = 0; pi < 4; pi++){
+    210b:	31 db                	xor    %ebx,%ebx
+{
+    210d:	83 ec 2c             	sub    $0x2c,%esp
+  printf(1, "fourfiles test\n");
+    2110:	c7 44 24 04 10 56 00 	movl   $0x5610,0x4(%esp)
+    2117:	00 
+    2118:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  char *names[] = { "f0", "f1", "f2", "f3" };
+    211f:	c7 45 d8 0a 56 00 00 	movl   $0x560a,-0x28(%ebp)
+    2126:	c7 45 dc 53 57 00 00 	movl   $0x5753,-0x24(%ebp)
+    212d:	c7 45 e0 57 57 00 00 	movl   $0x5757,-0x20(%ebp)
+    2134:	c7 45 e4 0d 56 00 00 	movl   $0x560d,-0x1c(%ebp)
+  printf(1, "fourfiles test\n");
+    213b:	e8 c0 2c 00 00       	call   4e00 <printf>
+    unlink(fname);
+    2140:	89 34 24             	mov    %esi,(%esp)
+    2143:	e8 aa 2b 00 00       	call   4cf2 <unlink>
+    pid = fork();
+    2148:	e8 4d 2b 00 00       	call   4c9a <fork>
+    if(pid < 0){
+    214d:	85 c0                	test   %eax,%eax
+    214f:	0f 88 89 01 00 00    	js     22de <fourfiles+0x1de>
+    if(pid == 0){
+    2155:	0f 84 e4 00 00 00    	je     223f <fourfiles+0x13f>
+  for(pi = 0; pi < 4; pi++){
+    215b:	83 c3 01             	add    $0x1,%ebx
+    215e:	83 fb 04             	cmp    $0x4,%ebx
+    2161:	74 06                	je     2169 <fourfiles+0x69>
+    2163:	8b 74 9d d8          	mov    -0x28(%ebp,%ebx,4),%esi
+    2167:	eb d7                	jmp    2140 <fourfiles+0x40>
+    wait();
+    2169:	e8 3c 2b 00 00       	call   4caa <wait>
+    216e:	bf 30 00 00 00       	mov    $0x30,%edi
+    2173:	e8 32 2b 00 00       	call   4caa <wait>
+    2178:	e8 2d 2b 00 00       	call   4caa <wait>
+    217d:	e8 28 2b 00 00       	call   4caa <wait>
+    2182:	c7 45 d4 0a 56 00 00 	movl   $0x560a,-0x2c(%ebp)
+    fd = open(fname, 0);
+    2189:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    total = 0;
+    218c:	31 db                	xor    %ebx,%ebx
+    fd = open(fname, 0);
+    218e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    2195:	00 
+    2196:	89 04 24             	mov    %eax,(%esp)
+    2199:	e8 44 2b 00 00       	call   4ce2 <open>
+    219e:	89 c6                	mov    %eax,%esi
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+    21a0:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
+    21a7:	00 
+    21a8:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    21af:	00 
+    21b0:	89 34 24             	mov    %esi,(%esp)
+    21b3:	e8 02 2b 00 00       	call   4cba <read>
+    21b8:	85 c0                	test   %eax,%eax
+    21ba:	7e 1a                	jle    21d6 <fourfiles+0xd6>
+    21bc:	31 d2                	xor    %edx,%edx
+    21be:	66 90                	xchg   %ax,%ax
+        if(buf[j] != '0'+i){
+    21c0:	0f be 8a 40 9a 00 00 	movsbl 0x9a40(%edx),%ecx
+    21c7:	39 cf                	cmp    %ecx,%edi
+    21c9:	75 5b                	jne    2226 <fourfiles+0x126>
+      for(j = 0; j < n; j++){
+    21cb:	83 c2 01             	add    $0x1,%edx
+    21ce:	39 c2                	cmp    %eax,%edx
+    21d0:	75 ee                	jne    21c0 <fourfiles+0xc0>
+      total += n;
+    21d2:	01 d3                	add    %edx,%ebx
+    21d4:	eb ca                	jmp    21a0 <fourfiles+0xa0>
+    close(fd);
+    21d6:	89 34 24             	mov    %esi,(%esp)
+    21d9:	e8 ec 2a 00 00       	call   4cca <close>
+    if(total != 12*500){
+    21de:	81 fb 70 17 00 00    	cmp    $0x1770,%ebx
+    21e4:	0f 85 d7 00 00 00    	jne    22c1 <fourfiles+0x1c1>
+    unlink(fname);
+    21ea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    21ed:	89 04 24             	mov    %eax,(%esp)
+    21f0:	e8 fd 2a 00 00       	call   4cf2 <unlink>
+  for(i = 0; i < 2; i++){
+    21f5:	83 ff 31             	cmp    $0x31,%edi
+    21f8:	75 1c                	jne    2216 <fourfiles+0x116>
+  printf(1, "fourfiles ok\n");
+    21fa:	c7 44 24 04 4e 56 00 	movl   $0x564e,0x4(%esp)
+    2201:	00 
+    2202:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2209:	e8 f2 2b 00 00       	call   4e00 <printf>
+}
+    220e:	83 c4 2c             	add    $0x2c,%esp
+    2211:	5b                   	pop    %ebx
+    2212:	5e                   	pop    %esi
+    2213:	5f                   	pop    %edi
+    2214:	5d                   	pop    %ebp
+    2215:	c3                   	ret    
+    2216:	8b 45 dc             	mov    -0x24(%ebp),%eax
+    2219:	bf 31 00 00 00       	mov    $0x31,%edi
+    221e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    2221:	e9 63 ff ff ff       	jmp    2189 <fourfiles+0x89>
+          printf(1, "wrong char\n");
+    2226:	c7 44 24 04 31 56 00 	movl   $0x5631,0x4(%esp)
+    222d:	00 
+    222e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2235:	e8 c6 2b 00 00       	call   4e00 <printf>
+          exit();
+    223a:	e8 63 2a 00 00       	call   4ca2 <exit>
+      fd = open(fname, O_CREATE | O_RDWR);
+    223f:	89 34 24             	mov    %esi,(%esp)
+    2242:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    2249:	00 
+    224a:	e8 93 2a 00 00       	call   4ce2 <open>
+      if(fd < 0){
+    224f:	85 c0                	test   %eax,%eax
+      fd = open(fname, O_CREATE | O_RDWR);
+    2251:	89 c6                	mov    %eax,%esi
+      if(fd < 0){
+    2253:	0f 88 9e 00 00 00    	js     22f7 <fourfiles+0x1f7>
+      memset(buf, '0'+pi, 512);
+    2259:	83 c3 30             	add    $0x30,%ebx
+    225c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    2260:	bb 0c 00 00 00       	mov    $0xc,%ebx
+    2265:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+    226c:	00 
+    226d:	c7 04 24 40 9a 00 00 	movl   $0x9a40,(%esp)
+    2274:	e8 b7 28 00 00       	call   4b30 <memset>
+    2279:	eb 0a                	jmp    2285 <fourfiles+0x185>
+    227b:	90                   	nop
+    227c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      for(i = 0; i < 12; i++){
+    2280:	83 eb 01             	sub    $0x1,%ebx
+    2283:	74 b5                	je     223a <fourfiles+0x13a>
+        if((n = write(fd, buf, 500)) != 500){
+    2285:	c7 44 24 08 f4 01 00 	movl   $0x1f4,0x8(%esp)
+    228c:	00 
+    228d:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    2294:	00 
+    2295:	89 34 24             	mov    %esi,(%esp)
+    2298:	e8 25 2a 00 00       	call   4cc2 <write>
+    229d:	3d f4 01 00 00       	cmp    $0x1f4,%eax
+    22a2:	74 dc                	je     2280 <fourfiles+0x180>
+          printf(1, "write failed %d\n", n);
+    22a4:	89 44 24 08          	mov    %eax,0x8(%esp)
+    22a8:	c7 44 24 04 20 56 00 	movl   $0x5620,0x4(%esp)
+    22af:	00 
+    22b0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    22b7:	e8 44 2b 00 00       	call   4e00 <printf>
+          exit();
+    22bc:	e8 e1 29 00 00       	call   4ca2 <exit>
+      printf(1, "wrong length %d\n", total);
+    22c1:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    22c5:	c7 44 24 04 3d 56 00 	movl   $0x563d,0x4(%esp)
+    22cc:	00 
+    22cd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    22d4:	e8 27 2b 00 00       	call   4e00 <printf>
+      exit();
+    22d9:	e8 c4 29 00 00       	call   4ca2 <exit>
+      printf(1, "fork failed\n");
+    22de:	c7 44 24 04 e5 60 00 	movl   $0x60e5,0x4(%esp)
+    22e5:	00 
+    22e6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    22ed:	e8 0e 2b 00 00       	call   4e00 <printf>
+      exit();
+    22f2:	e8 ab 29 00 00       	call   4ca2 <exit>
+        printf(1, "create failed\n");
+    22f7:	c7 44 24 04 ab 58 00 	movl   $0x58ab,0x4(%esp)
+    22fe:	00 
+    22ff:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2306:	e8 f5 2a 00 00       	call   4e00 <printf>
+        exit();
+    230b:	e8 92 29 00 00       	call   4ca2 <exit>
+
+00002310 <createdelete>:
+{
+    2310:	55                   	push   %ebp
+    2311:	89 e5                	mov    %esp,%ebp
+    2313:	57                   	push   %edi
+    2314:	56                   	push   %esi
+    2315:	53                   	push   %ebx
+  for(pi = 0; pi < 4; pi++){
+    2316:	31 db                	xor    %ebx,%ebx
+{
+    2318:	83 ec 4c             	sub    $0x4c,%esp
+  printf(1, "createdelete test\n");
+    231b:	c7 44 24 04 5c 56 00 	movl   $0x565c,0x4(%esp)
+    2322:	00 
+    2323:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    232a:	e8 d1 2a 00 00       	call   4e00 <printf>
+    pid = fork();
+    232f:	e8 66 29 00 00       	call   4c9a <fork>
+    if(pid < 0){
+    2334:	85 c0                	test   %eax,%eax
+    2336:	0f 88 d2 01 00 00    	js     250e <createdelete+0x1fe>
+    233c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    if(pid == 0){
+    2340:	0f 84 14 01 00 00    	je     245a <createdelete+0x14a>
+  for(pi = 0; pi < 4; pi++){
+    2346:	83 c3 01             	add    $0x1,%ebx
+    2349:	83 fb 04             	cmp    $0x4,%ebx
+    234c:	75 e1                	jne    232f <createdelete+0x1f>
+    234e:	66 90                	xchg   %ax,%ax
+    wait();
+    2350:	e8 55 29 00 00       	call   4caa <wait>
+  for(i = 0; i < N; i++){
+    2355:	31 f6                	xor    %esi,%esi
+    wait();
+    2357:	e8 4e 29 00 00       	call   4caa <wait>
+    235c:	8d 7d c8             	lea    -0x38(%ebp),%edi
+    235f:	e8 46 29 00 00       	call   4caa <wait>
+    2364:	e8 41 29 00 00       	call   4caa <wait>
+  name[0] = name[1] = name[2] = 0;
+    2369:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
+    236d:	8d 76 00             	lea    0x0(%esi),%esi
+    2370:	85 f6                	test   %esi,%esi
+      name[2] = '\0';
+    2372:	bb 70 00 00 00       	mov    $0x70,%ebx
+    2377:	8d 46 30             	lea    0x30(%esi),%eax
+    237a:	0f 94 45 c7          	sete   -0x39(%ebp)
+    237e:	83 fe 09             	cmp    $0x9,%esi
+    2381:	88 45 c6             	mov    %al,-0x3a(%ebp)
+    2384:	0f 9f c0             	setg   %al
+    2387:	08 45 c7             	or     %al,-0x39(%ebp)
+    238a:	8d 46 ff             	lea    -0x1(%esi),%eax
+    238d:	89 45 c0             	mov    %eax,-0x40(%ebp)
+      name[1] = '0' + i;
+    2390:	0f b6 45 c6          	movzbl -0x3a(%ebp),%eax
+      fd = open(name, 0);
+    2394:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    239b:	00 
+    239c:	89 3c 24             	mov    %edi,(%esp)
+      name[0] = 'p' + pi;
+    239f:	88 5d c8             	mov    %bl,-0x38(%ebp)
+      name[1] = '0' + i;
+    23a2:	88 45 c9             	mov    %al,-0x37(%ebp)
+      fd = open(name, 0);
+    23a5:	e8 38 29 00 00       	call   4ce2 <open>
+      if((i == 0 || i >= N/2) && fd < 0){
+    23aa:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
+    23ae:	0f 84 84 00 00 00    	je     2438 <createdelete+0x128>
+    23b4:	85 c0                	test   %eax,%eax
+    23b6:	0f 88 1c 01 00 00    	js     24d8 <createdelete+0x1c8>
+      } else if((i >= 1 && i < N/2) && fd >= 0){
+    23bc:	83 7d c0 08          	cmpl   $0x8,-0x40(%ebp)
+    23c0:	0f 86 61 01 00 00    	jbe    2527 <createdelete+0x217>
+        close(fd);
+    23c6:	89 04 24             	mov    %eax,(%esp)
+    23c9:	83 c3 01             	add    $0x1,%ebx
+    23cc:	e8 f9 28 00 00       	call   4cca <close>
+    for(pi = 0; pi < 4; pi++){
+    23d1:	80 fb 74             	cmp    $0x74,%bl
+    23d4:	75 ba                	jne    2390 <createdelete+0x80>
+  for(i = 0; i < N; i++){
+    23d6:	83 c6 01             	add    $0x1,%esi
+    23d9:	83 fe 14             	cmp    $0x14,%esi
+    23dc:	75 92                	jne    2370 <createdelete+0x60>
+    23de:	be 70 00 00 00       	mov    $0x70,%esi
+    23e3:	90                   	nop
+    23e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    23e8:	8d 46 c0             	lea    -0x40(%esi),%eax
+    23eb:	bb 04 00 00 00       	mov    $0x4,%ebx
+    23f0:	88 45 c7             	mov    %al,-0x39(%ebp)
+      name[0] = 'p' + i;
+    23f3:	89 f0                	mov    %esi,%eax
+    23f5:	88 45 c8             	mov    %al,-0x38(%ebp)
+      name[1] = '0' + i;
+    23f8:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
+      unlink(name);
+    23fc:	89 3c 24             	mov    %edi,(%esp)
+      name[1] = '0' + i;
+    23ff:	88 45 c9             	mov    %al,-0x37(%ebp)
+      unlink(name);
+    2402:	e8 eb 28 00 00       	call   4cf2 <unlink>
+    for(pi = 0; pi < 4; pi++){
+    2407:	83 eb 01             	sub    $0x1,%ebx
+    240a:	75 e7                	jne    23f3 <createdelete+0xe3>
+    240c:	83 c6 01             	add    $0x1,%esi
+  for(i = 0; i < N; i++){
+    240f:	89 f0                	mov    %esi,%eax
+    2411:	3c 84                	cmp    $0x84,%al
+    2413:	75 d3                	jne    23e8 <createdelete+0xd8>
+  printf(1, "createdelete ok\n");
+    2415:	c7 44 24 04 6f 56 00 	movl   $0x566f,0x4(%esp)
+    241c:	00 
+    241d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2424:	e8 d7 29 00 00       	call   4e00 <printf>
+}
+    2429:	83 c4 4c             	add    $0x4c,%esp
+    242c:	5b                   	pop    %ebx
+    242d:	5e                   	pop    %esi
+    242e:	5f                   	pop    %edi
+    242f:	5d                   	pop    %ebp
+    2430:	c3                   	ret    
+    2431:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      } else if((i >= 1 && i < N/2) && fd >= 0){
+    2438:	85 c0                	test   %eax,%eax
+    243a:	0f 89 e7 00 00 00    	jns    2527 <createdelete+0x217>
+    2440:	83 c3 01             	add    $0x1,%ebx
+    for(pi = 0; pi < 4; pi++){
+    2443:	80 fb 74             	cmp    $0x74,%bl
+    2446:	0f 85 44 ff ff ff    	jne    2390 <createdelete+0x80>
+  for(i = 0; i < N; i++){
+    244c:	83 c6 01             	add    $0x1,%esi
+    244f:	83 fe 14             	cmp    $0x14,%esi
+    2452:	0f 85 18 ff ff ff    	jne    2370 <createdelete+0x60>
+    2458:	eb 84                	jmp    23de <createdelete+0xce>
+      name[0] = 'p' + pi;
+    245a:	83 c3 70             	add    $0x70,%ebx
+      name[2] = '\0';
+    245d:	be 01 00 00 00       	mov    $0x1,%esi
+      name[0] = 'p' + pi;
+    2462:	88 5d c8             	mov    %bl,-0x38(%ebp)
+    2465:	8d 7d c8             	lea    -0x38(%ebp),%edi
+      name[2] = '\0';
+    2468:	31 db                	xor    %ebx,%ebx
+    246a:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
+    246e:	eb 0b                	jmp    247b <createdelete+0x16b>
+      for(i = 0; i < N; i++){
+    2470:	83 fe 14             	cmp    $0x14,%esi
+    2473:	74 7b                	je     24f0 <createdelete+0x1e0>
+    2475:	83 c3 01             	add    $0x1,%ebx
+    2478:	83 c6 01             	add    $0x1,%esi
+    247b:	8d 43 30             	lea    0x30(%ebx),%eax
+        fd = open(name, O_CREATE | O_RDWR);
+    247e:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    2485:	00 
+    2486:	89 3c 24             	mov    %edi,(%esp)
+    2489:	88 45 c9             	mov    %al,-0x37(%ebp)
+    248c:	e8 51 28 00 00       	call   4ce2 <open>
+        if(fd < 0){
+    2491:	85 c0                	test   %eax,%eax
+    2493:	78 60                	js     24f5 <createdelete+0x1e5>
+        close(fd);
+    2495:	89 04 24             	mov    %eax,(%esp)
+    2498:	e8 2d 28 00 00       	call   4cca <close>
+        if(i > 0 && (i % 2 ) == 0){
+    249d:	85 db                	test   %ebx,%ebx
+    249f:	74 d4                	je     2475 <createdelete+0x165>
+    24a1:	f6 c3 01             	test   $0x1,%bl
+    24a4:	75 ca                	jne    2470 <createdelete+0x160>
+          name[1] = '0' + (i / 2);
+    24a6:	89 d8                	mov    %ebx,%eax
+    24a8:	d1 f8                	sar    %eax
+    24aa:	83 c0 30             	add    $0x30,%eax
+          if(unlink(name) < 0){
+    24ad:	89 3c 24             	mov    %edi,(%esp)
+          name[1] = '0' + (i / 2);
+    24b0:	88 45 c9             	mov    %al,-0x37(%ebp)
+          if(unlink(name) < 0){
+    24b3:	e8 3a 28 00 00       	call   4cf2 <unlink>
+    24b8:	85 c0                	test   %eax,%eax
+    24ba:	79 b4                	jns    2470 <createdelete+0x160>
+            printf(1, "unlink failed\n");
+    24bc:	c7 44 24 04 5d 52 00 	movl   $0x525d,0x4(%esp)
+    24c3:	00 
+    24c4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    24cb:	e8 30 29 00 00       	call   4e00 <printf>
+            exit();
+    24d0:	e8 cd 27 00 00       	call   4ca2 <exit>
+    24d5:	8d 76 00             	lea    0x0(%esi),%esi
+        printf(1, "oops createdelete %s didn't exist\n", name);
+    24d8:	89 7c 24 08          	mov    %edi,0x8(%esp)
+    24dc:	c7 44 24 04 1c 63 00 	movl   $0x631c,0x4(%esp)
+    24e3:	00 
+    24e4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    24eb:	e8 10 29 00 00       	call   4e00 <printf>
+        exit();
+    24f0:	e8 ad 27 00 00       	call   4ca2 <exit>
+          printf(1, "create failed\n");
+    24f5:	c7 44 24 04 ab 58 00 	movl   $0x58ab,0x4(%esp)
+    24fc:	00 
+    24fd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2504:	e8 f7 28 00 00       	call   4e00 <printf>
+          exit();
+    2509:	e8 94 27 00 00       	call   4ca2 <exit>
+      printf(1, "fork failed\n");
+    250e:	c7 44 24 04 e5 60 00 	movl   $0x60e5,0x4(%esp)
+    2515:	00 
+    2516:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    251d:	e8 de 28 00 00       	call   4e00 <printf>
+      exit();
+    2522:	e8 7b 27 00 00       	call   4ca2 <exit>
+        printf(1, "oops createdelete %s did exist\n", name);
+    2527:	89 7c 24 08          	mov    %edi,0x8(%esp)
+    252b:	c7 44 24 04 40 63 00 	movl   $0x6340,0x4(%esp)
+    2532:	00 
+    2533:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    253a:	e8 c1 28 00 00       	call   4e00 <printf>
+        exit();
+    253f:	e8 5e 27 00 00       	call   4ca2 <exit>
+    2544:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    254a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00002550 <unlinkread>:
+{
+    2550:	55                   	push   %ebp
+    2551:	89 e5                	mov    %esp,%ebp
+    2553:	56                   	push   %esi
+    2554:	53                   	push   %ebx
+    2555:	83 ec 10             	sub    $0x10,%esp
+  printf(1, "unlinkread test\n");
+    2558:	c7 44 24 04 80 56 00 	movl   $0x5680,0x4(%esp)
+    255f:	00 
+    2560:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2567:	e8 94 28 00 00       	call   4e00 <printf>
+  fd = open("unlinkread", O_CREATE | O_RDWR);
+    256c:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    2573:	00 
+    2574:	c7 04 24 91 56 00 00 	movl   $0x5691,(%esp)
+    257b:	e8 62 27 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    2580:	85 c0                	test   %eax,%eax
+  fd = open("unlinkread", O_CREATE | O_RDWR);
+    2582:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    2584:	0f 88 fe 00 00 00    	js     2688 <unlinkread+0x138>
+  write(fd, "hello", 5);
+    258a:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
+    2591:	00 
+    2592:	c7 44 24 04 b6 56 00 	movl   $0x56b6,0x4(%esp)
+    2599:	00 
+    259a:	89 04 24             	mov    %eax,(%esp)
+    259d:	e8 20 27 00 00       	call   4cc2 <write>
+  close(fd);
+    25a2:	89 1c 24             	mov    %ebx,(%esp)
+    25a5:	e8 20 27 00 00       	call   4cca <close>
+  fd = open("unlinkread", O_RDWR);
+    25aa:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+    25b1:	00 
+    25b2:	c7 04 24 91 56 00 00 	movl   $0x5691,(%esp)
+    25b9:	e8 24 27 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    25be:	85 c0                	test   %eax,%eax
+  fd = open("unlinkread", O_RDWR);
+    25c0:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    25c2:	0f 88 3d 01 00 00    	js     2705 <unlinkread+0x1b5>
+  if(unlink("unlinkread") != 0){
+    25c8:	c7 04 24 91 56 00 00 	movl   $0x5691,(%esp)
+    25cf:	e8 1e 27 00 00       	call   4cf2 <unlink>
+    25d4:	85 c0                	test   %eax,%eax
+    25d6:	0f 85 10 01 00 00    	jne    26ec <unlinkread+0x19c>
+  fd1 = open("unlinkread", O_CREATE | O_RDWR);
+    25dc:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    25e3:	00 
+    25e4:	c7 04 24 91 56 00 00 	movl   $0x5691,(%esp)
+    25eb:	e8 f2 26 00 00       	call   4ce2 <open>
+  write(fd1, "yyy", 3);
+    25f0:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
+    25f7:	00 
+    25f8:	c7 44 24 04 ee 56 00 	movl   $0x56ee,0x4(%esp)
+    25ff:	00 
+  fd1 = open("unlinkread", O_CREATE | O_RDWR);
+    2600:	89 c6                	mov    %eax,%esi
+  write(fd1, "yyy", 3);
+    2602:	89 04 24             	mov    %eax,(%esp)
+    2605:	e8 b8 26 00 00       	call   4cc2 <write>
+  close(fd1);
+    260a:	89 34 24             	mov    %esi,(%esp)
+    260d:	e8 b8 26 00 00       	call   4cca <close>
+  if(read(fd, buf, sizeof(buf)) != 5){
+    2612:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
+    2619:	00 
+    261a:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    2621:	00 
+    2622:	89 1c 24             	mov    %ebx,(%esp)
+    2625:	e8 90 26 00 00       	call   4cba <read>
+    262a:	83 f8 05             	cmp    $0x5,%eax
+    262d:	0f 85 a0 00 00 00    	jne    26d3 <unlinkread+0x183>
+  if(buf[0] != 'h'){
+    2633:	80 3d 40 9a 00 00 68 	cmpb   $0x68,0x9a40
+    263a:	75 7e                	jne    26ba <unlinkread+0x16a>
+  if(write(fd, buf, 10) != 10){
+    263c:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
+    2643:	00 
+    2644:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    264b:	00 
+    264c:	89 1c 24             	mov    %ebx,(%esp)
+    264f:	e8 6e 26 00 00       	call   4cc2 <write>
+    2654:	83 f8 0a             	cmp    $0xa,%eax
+    2657:	75 48                	jne    26a1 <unlinkread+0x151>
+  close(fd);
+    2659:	89 1c 24             	mov    %ebx,(%esp)
+    265c:	e8 69 26 00 00       	call   4cca <close>
+  unlink("unlinkread");
+    2661:	c7 04 24 91 56 00 00 	movl   $0x5691,(%esp)
+    2668:	e8 85 26 00 00       	call   4cf2 <unlink>
+  printf(1, "unlinkread ok\n");
+    266d:	c7 44 24 04 39 57 00 	movl   $0x5739,0x4(%esp)
+    2674:	00 
+    2675:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    267c:	e8 7f 27 00 00       	call   4e00 <printf>
+}
+    2681:	83 c4 10             	add    $0x10,%esp
+    2684:	5b                   	pop    %ebx
+    2685:	5e                   	pop    %esi
+    2686:	5d                   	pop    %ebp
+    2687:	c3                   	ret    
+    printf(1, "create unlinkread failed\n");
+    2688:	c7 44 24 04 9c 56 00 	movl   $0x569c,0x4(%esp)
+    268f:	00 
+    2690:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2697:	e8 64 27 00 00       	call   4e00 <printf>
+    exit();
+    269c:	e8 01 26 00 00       	call   4ca2 <exit>
+    printf(1, "unlinkread write failed\n");
+    26a1:	c7 44 24 04 20 57 00 	movl   $0x5720,0x4(%esp)
+    26a8:	00 
+    26a9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    26b0:	e8 4b 27 00 00       	call   4e00 <printf>
+    exit();
+    26b5:	e8 e8 25 00 00       	call   4ca2 <exit>
+    printf(1, "unlinkread wrong data\n");
+    26ba:	c7 44 24 04 09 57 00 	movl   $0x5709,0x4(%esp)
+    26c1:	00 
+    26c2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    26c9:	e8 32 27 00 00       	call   4e00 <printf>
+    exit();
+    26ce:	e8 cf 25 00 00       	call   4ca2 <exit>
+    printf(1, "unlinkread read failed");
+    26d3:	c7 44 24 04 f2 56 00 	movl   $0x56f2,0x4(%esp)
+    26da:	00 
+    26db:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    26e2:	e8 19 27 00 00       	call   4e00 <printf>
+    exit();
+    26e7:	e8 b6 25 00 00       	call   4ca2 <exit>
+    printf(1, "unlink unlinkread failed\n");
+    26ec:	c7 44 24 04 d4 56 00 	movl   $0x56d4,0x4(%esp)
+    26f3:	00 
+    26f4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    26fb:	e8 00 27 00 00       	call   4e00 <printf>
+    exit();
+    2700:	e8 9d 25 00 00       	call   4ca2 <exit>
+    printf(1, "open unlinkread failed\n");
+    2705:	c7 44 24 04 bc 56 00 	movl   $0x56bc,0x4(%esp)
+    270c:	00 
+    270d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2714:	e8 e7 26 00 00       	call   4e00 <printf>
+    exit();
+    2719:	e8 84 25 00 00       	call   4ca2 <exit>
+    271e:	66 90                	xchg   %ax,%ax
+
+00002720 <linktest>:
+{
+    2720:	55                   	push   %ebp
+    2721:	89 e5                	mov    %esp,%ebp
+    2723:	53                   	push   %ebx
+    2724:	83 ec 14             	sub    $0x14,%esp
+  printf(1, "linktest\n");
+    2727:	c7 44 24 04 48 57 00 	movl   $0x5748,0x4(%esp)
+    272e:	00 
+    272f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2736:	e8 c5 26 00 00       	call   4e00 <printf>
+  unlink("lf1");
+    273b:	c7 04 24 52 57 00 00 	movl   $0x5752,(%esp)
+    2742:	e8 ab 25 00 00       	call   4cf2 <unlink>
+  unlink("lf2");
+    2747:	c7 04 24 56 57 00 00 	movl   $0x5756,(%esp)
+    274e:	e8 9f 25 00 00       	call   4cf2 <unlink>
+  fd = open("lf1", O_CREATE|O_RDWR);
+    2753:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    275a:	00 
+    275b:	c7 04 24 52 57 00 00 	movl   $0x5752,(%esp)
+    2762:	e8 7b 25 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    2767:	85 c0                	test   %eax,%eax
+  fd = open("lf1", O_CREATE|O_RDWR);
+    2769:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    276b:	0f 88 26 01 00 00    	js     2897 <linktest+0x177>
+  if(write(fd, "hello", 5) != 5){
+    2771:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
+    2778:	00 
+    2779:	c7 44 24 04 b6 56 00 	movl   $0x56b6,0x4(%esp)
+    2780:	00 
+    2781:	89 04 24             	mov    %eax,(%esp)
+    2784:	e8 39 25 00 00       	call   4cc2 <write>
+    2789:	83 f8 05             	cmp    $0x5,%eax
+    278c:	0f 85 cd 01 00 00    	jne    295f <linktest+0x23f>
+  close(fd);
+    2792:	89 1c 24             	mov    %ebx,(%esp)
+    2795:	e8 30 25 00 00       	call   4cca <close>
+  if(link("lf1", "lf2") < 0){
+    279a:	c7 44 24 04 56 57 00 	movl   $0x5756,0x4(%esp)
+    27a1:	00 
+    27a2:	c7 04 24 52 57 00 00 	movl   $0x5752,(%esp)
+    27a9:	e8 54 25 00 00       	call   4d02 <link>
+    27ae:	85 c0                	test   %eax,%eax
+    27b0:	0f 88 90 01 00 00    	js     2946 <linktest+0x226>
+  unlink("lf1");
+    27b6:	c7 04 24 52 57 00 00 	movl   $0x5752,(%esp)
+    27bd:	e8 30 25 00 00       	call   4cf2 <unlink>
+  if(open("lf1", 0) >= 0){
+    27c2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    27c9:	00 
+    27ca:	c7 04 24 52 57 00 00 	movl   $0x5752,(%esp)
+    27d1:	e8 0c 25 00 00       	call   4ce2 <open>
+    27d6:	85 c0                	test   %eax,%eax
+    27d8:	0f 89 4f 01 00 00    	jns    292d <linktest+0x20d>
+  fd = open("lf2", 0);
+    27de:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    27e5:	00 
+    27e6:	c7 04 24 56 57 00 00 	movl   $0x5756,(%esp)
+    27ed:	e8 f0 24 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    27f2:	85 c0                	test   %eax,%eax
+  fd = open("lf2", 0);
+    27f4:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    27f6:	0f 88 18 01 00 00    	js     2914 <linktest+0x1f4>
+  if(read(fd, buf, sizeof(buf)) != 5){
+    27fc:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
+    2803:	00 
+    2804:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    280b:	00 
+    280c:	89 04 24             	mov    %eax,(%esp)
+    280f:	e8 a6 24 00 00       	call   4cba <read>
+    2814:	83 f8 05             	cmp    $0x5,%eax
+    2817:	0f 85 de 00 00 00    	jne    28fb <linktest+0x1db>
+  close(fd);
+    281d:	89 1c 24             	mov    %ebx,(%esp)
+    2820:	e8 a5 24 00 00       	call   4cca <close>
+  if(link("lf2", "lf2") >= 0){
+    2825:	c7 44 24 04 56 57 00 	movl   $0x5756,0x4(%esp)
+    282c:	00 
+    282d:	c7 04 24 56 57 00 00 	movl   $0x5756,(%esp)
+    2834:	e8 c9 24 00 00       	call   4d02 <link>
+    2839:	85 c0                	test   %eax,%eax
+    283b:	0f 89 a1 00 00 00    	jns    28e2 <linktest+0x1c2>
+  unlink("lf2");
+    2841:	c7 04 24 56 57 00 00 	movl   $0x5756,(%esp)
+    2848:	e8 a5 24 00 00       	call   4cf2 <unlink>
+  if(link("lf2", "lf1") >= 0){
+    284d:	c7 44 24 04 52 57 00 	movl   $0x5752,0x4(%esp)
+    2854:	00 
+    2855:	c7 04 24 56 57 00 00 	movl   $0x5756,(%esp)
+    285c:	e8 a1 24 00 00       	call   4d02 <link>
+    2861:	85 c0                	test   %eax,%eax
+    2863:	79 64                	jns    28c9 <linktest+0x1a9>
+  if(link(".", "lf1") >= 0){
+    2865:	c7 44 24 04 52 57 00 	movl   $0x5752,0x4(%esp)
+    286c:	00 
+    286d:	c7 04 24 1a 5a 00 00 	movl   $0x5a1a,(%esp)
+    2874:	e8 89 24 00 00       	call   4d02 <link>
+    2879:	85 c0                	test   %eax,%eax
+    287b:	79 33                	jns    28b0 <linktest+0x190>
+  printf(1, "linktest ok\n");
+    287d:	c7 44 24 04 f0 57 00 	movl   $0x57f0,0x4(%esp)
+    2884:	00 
+    2885:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    288c:	e8 6f 25 00 00       	call   4e00 <printf>
+}
+    2891:	83 c4 14             	add    $0x14,%esp
+    2894:	5b                   	pop    %ebx
+    2895:	5d                   	pop    %ebp
+    2896:	c3                   	ret    
+    printf(1, "create lf1 failed\n");
+    2897:	c7 44 24 04 5a 57 00 	movl   $0x575a,0x4(%esp)
+    289e:	00 
+    289f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    28a6:	e8 55 25 00 00       	call   4e00 <printf>
+    exit();
+    28ab:	e8 f2 23 00 00       	call   4ca2 <exit>
+    printf(1, "link . lf1 succeeded! oops\n");
+    28b0:	c7 44 24 04 d4 57 00 	movl   $0x57d4,0x4(%esp)
+    28b7:	00 
+    28b8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    28bf:	e8 3c 25 00 00       	call   4e00 <printf>
+    exit();
+    28c4:	e8 d9 23 00 00       	call   4ca2 <exit>
+    printf(1, "link non-existant succeeded! oops\n");
+    28c9:	c7 44 24 04 88 63 00 	movl   $0x6388,0x4(%esp)
+    28d0:	00 
+    28d1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    28d8:	e8 23 25 00 00       	call   4e00 <printf>
+    exit();
+    28dd:	e8 c0 23 00 00       	call   4ca2 <exit>
+    printf(1, "link lf2 lf2 succeeded! oops\n");
+    28e2:	c7 44 24 04 b6 57 00 	movl   $0x57b6,0x4(%esp)
+    28e9:	00 
+    28ea:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    28f1:	e8 0a 25 00 00       	call   4e00 <printf>
+    exit();
+    28f6:	e8 a7 23 00 00       	call   4ca2 <exit>
+    printf(1, "read lf2 failed\n");
+    28fb:	c7 44 24 04 a5 57 00 	movl   $0x57a5,0x4(%esp)
+    2902:	00 
+    2903:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    290a:	e8 f1 24 00 00       	call   4e00 <printf>
+    exit();
+    290f:	e8 8e 23 00 00       	call   4ca2 <exit>
+    printf(1, "open lf2 failed\n");
+    2914:	c7 44 24 04 94 57 00 	movl   $0x5794,0x4(%esp)
+    291b:	00 
+    291c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2923:	e8 d8 24 00 00       	call   4e00 <printf>
+    exit();
+    2928:	e8 75 23 00 00       	call   4ca2 <exit>
+    printf(1, "unlinked lf1 but it is still there!\n");
+    292d:	c7 44 24 04 60 63 00 	movl   $0x6360,0x4(%esp)
+    2934:	00 
+    2935:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    293c:	e8 bf 24 00 00       	call   4e00 <printf>
+    exit();
+    2941:	e8 5c 23 00 00       	call   4ca2 <exit>
+    printf(1, "link lf1 lf2 failed\n");
+    2946:	c7 44 24 04 7f 57 00 	movl   $0x577f,0x4(%esp)
+    294d:	00 
+    294e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2955:	e8 a6 24 00 00       	call   4e00 <printf>
+    exit();
+    295a:	e8 43 23 00 00       	call   4ca2 <exit>
+    printf(1, "write lf1 failed\n");
+    295f:	c7 44 24 04 6d 57 00 	movl   $0x576d,0x4(%esp)
+    2966:	00 
+    2967:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    296e:	e8 8d 24 00 00       	call   4e00 <printf>
+    exit();
+    2973:	e8 2a 23 00 00       	call   4ca2 <exit>
+    2978:	90                   	nop
+    2979:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00002980 <concreate>:
+{
+    2980:	55                   	push   %ebp
+    2981:	89 e5                	mov    %esp,%ebp
+    2983:	57                   	push   %edi
+    2984:	56                   	push   %esi
+  for(i = 0; i < 40; i++){
+    2985:	31 f6                	xor    %esi,%esi
+{
+    2987:	53                   	push   %ebx
+    2988:	83 ec 5c             	sub    $0x5c,%esp
+  printf(1, "concreate test\n");
+    298b:	c7 44 24 04 fd 57 00 	movl   $0x57fd,0x4(%esp)
+    2992:	00 
+    2993:	8d 5d ad             	lea    -0x53(%ebp),%ebx
+    2996:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    299d:	e8 5e 24 00 00       	call   4e00 <printf>
+  file[0] = 'C';
+    29a2:	c6 45 ad 43          	movb   $0x43,-0x53(%ebp)
+  file[2] = '\0';
+    29a6:	c6 45 af 00          	movb   $0x0,-0x51(%ebp)
+    29aa:	eb 4f                	jmp    29fb <concreate+0x7b>
+    29ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    if(pid && (i % 3) == 1){
+    29b0:	b8 56 55 55 55       	mov    $0x55555556,%eax
+    29b5:	89 f1                	mov    %esi,%ecx
+    29b7:	f7 ee                	imul   %esi
+    29b9:	89 f0                	mov    %esi,%eax
+    29bb:	c1 f8 1f             	sar    $0x1f,%eax
+    29be:	29 c2                	sub    %eax,%edx
+    29c0:	8d 04 52             	lea    (%edx,%edx,2),%eax
+    29c3:	29 c1                	sub    %eax,%ecx
+    29c5:	83 f9 01             	cmp    $0x1,%ecx
+    29c8:	74 7e                	je     2a48 <concreate+0xc8>
+      fd = open(file, O_CREATE | O_RDWR);
+    29ca:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    29d1:	00 
+    29d2:	89 1c 24             	mov    %ebx,(%esp)
+    29d5:	e8 08 23 00 00       	call   4ce2 <open>
+      if(fd < 0){
+    29da:	85 c0                	test   %eax,%eax
+    29dc:	0f 88 43 02 00 00    	js     2c25 <concreate+0x2a5>
+      close(fd);
+    29e2:	89 04 24             	mov    %eax,(%esp)
+    29e5:	e8 e0 22 00 00       	call   4cca <close>
+    if(pid == 0)
+    29ea:	85 ff                	test   %edi,%edi
+    29ec:	74 52                	je     2a40 <concreate+0xc0>
+  for(i = 0; i < 40; i++){
+    29ee:	83 c6 01             	add    $0x1,%esi
+      wait();
+    29f1:	e8 b4 22 00 00       	call   4caa <wait>
+  for(i = 0; i < 40; i++){
+    29f6:	83 fe 28             	cmp    $0x28,%esi
+    29f9:	74 6d                	je     2a68 <concreate+0xe8>
+    29fb:	8d 46 30             	lea    0x30(%esi),%eax
+    unlink(file);
+    29fe:	89 1c 24             	mov    %ebx,(%esp)
+    2a01:	88 45 ae             	mov    %al,-0x52(%ebp)
+    2a04:	e8 e9 22 00 00       	call   4cf2 <unlink>
+    pid = fork();
+    2a09:	e8 8c 22 00 00       	call   4c9a <fork>
+    if(pid && (i % 3) == 1){
+    2a0e:	85 c0                	test   %eax,%eax
+    pid = fork();
+    2a10:	89 c7                	mov    %eax,%edi
+    if(pid && (i % 3) == 1){
+    2a12:	75 9c                	jne    29b0 <concreate+0x30>
+    } else if(pid == 0 && (i % 5) == 1){
+    2a14:	b8 67 66 66 66       	mov    $0x66666667,%eax
+    2a19:	89 f1                	mov    %esi,%ecx
+    2a1b:	f7 ee                	imul   %esi
+    2a1d:	89 f0                	mov    %esi,%eax
+    2a1f:	c1 f8 1f             	sar    $0x1f,%eax
+    2a22:	d1 fa                	sar    %edx
+    2a24:	29 c2                	sub    %eax,%edx
+    2a26:	8d 04 92             	lea    (%edx,%edx,4),%eax
+    2a29:	29 c1                	sub    %eax,%ecx
+    2a2b:	83 f9 01             	cmp    $0x1,%ecx
+    2a2e:	75 9a                	jne    29ca <concreate+0x4a>
+      link("C0", file);
+    2a30:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    2a34:	c7 04 24 0d 58 00 00 	movl   $0x580d,(%esp)
+    2a3b:	e8 c2 22 00 00       	call   4d02 <link>
+        exit();
+    2a40:	e8 5d 22 00 00       	call   4ca2 <exit>
+    2a45:	8d 76 00             	lea    0x0(%esi),%esi
+      link("C0", file);
+    2a48:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+  for(i = 0; i < 40; i++){
+    2a4c:	83 c6 01             	add    $0x1,%esi
+      link("C0", file);
+    2a4f:	c7 04 24 0d 58 00 00 	movl   $0x580d,(%esp)
+    2a56:	e8 a7 22 00 00       	call   4d02 <link>
+      wait();
+    2a5b:	e8 4a 22 00 00       	call   4caa <wait>
+  for(i = 0; i < 40; i++){
+    2a60:	83 fe 28             	cmp    $0x28,%esi
+    2a63:	75 96                	jne    29fb <concreate+0x7b>
+    2a65:	8d 76 00             	lea    0x0(%esi),%esi
+  memset(fa, 0, sizeof(fa));
+    2a68:	8d 45 c0             	lea    -0x40(%ebp),%eax
+    2a6b:	c7 44 24 08 28 00 00 	movl   $0x28,0x8(%esp)
+    2a72:	00 
+    2a73:	8d 7d b0             	lea    -0x50(%ebp),%edi
+    2a76:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    2a7d:	00 
+    2a7e:	89 04 24             	mov    %eax,(%esp)
+    2a81:	e8 aa 20 00 00       	call   4b30 <memset>
+  fd = open(".", 0);
+    2a86:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    2a8d:	00 
+    2a8e:	c7 04 24 1a 5a 00 00 	movl   $0x5a1a,(%esp)
+    2a95:	e8 48 22 00 00       	call   4ce2 <open>
+  n = 0;
+    2a9a:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
+  fd = open(".", 0);
+    2aa1:	89 c6                	mov    %eax,%esi
+    2aa3:	90                   	nop
+    2aa4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  while(read(fd, &de, sizeof(de)) > 0){
+    2aa8:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+    2aaf:	00 
+    2ab0:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    2ab4:	89 34 24             	mov    %esi,(%esp)
+    2ab7:	e8 fe 21 00 00       	call   4cba <read>
+    2abc:	85 c0                	test   %eax,%eax
+    2abe:	7e 40                	jle    2b00 <concreate+0x180>
+    if(de.inum == 0)
+    2ac0:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
+    2ac5:	74 e1                	je     2aa8 <concreate+0x128>
+    if(de.name[0] == 'C' && de.name[2] == '\0'){
+    2ac7:	80 7d b2 43          	cmpb   $0x43,-0x4e(%ebp)
+    2acb:	75 db                	jne    2aa8 <concreate+0x128>
+    2acd:	80 7d b4 00          	cmpb   $0x0,-0x4c(%ebp)
+    2ad1:	75 d5                	jne    2aa8 <concreate+0x128>
+      i = de.name[1] - '0';
+    2ad3:	0f be 45 b3          	movsbl -0x4d(%ebp),%eax
+    2ad7:	83 e8 30             	sub    $0x30,%eax
+      if(i < 0 || i >= sizeof(fa)){
+    2ada:	83 f8 27             	cmp    $0x27,%eax
+    2add:	0f 87 5f 01 00 00    	ja     2c42 <concreate+0x2c2>
+      if(fa[i]){
+    2ae3:	80 7c 05 c0 00       	cmpb   $0x0,-0x40(%ebp,%eax,1)
+    2ae8:	0f 85 8d 01 00 00    	jne    2c7b <concreate+0x2fb>
+      fa[i] = 1;
+    2aee:	c6 44 05 c0 01       	movb   $0x1,-0x40(%ebp,%eax,1)
+      n++;
+    2af3:	83 45 a4 01          	addl   $0x1,-0x5c(%ebp)
+    2af7:	eb af                	jmp    2aa8 <concreate+0x128>
+    2af9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  close(fd);
+    2b00:	89 34 24             	mov    %esi,(%esp)
+    2b03:	e8 c2 21 00 00       	call   4cca <close>
+  if(n != 40){
+    2b08:	83 7d a4 28          	cmpl   $0x28,-0x5c(%ebp)
+    2b0c:	0f 85 50 01 00 00    	jne    2c62 <concreate+0x2e2>
+    2b12:	31 f6                	xor    %esi,%esi
+    2b14:	eb 7f                	jmp    2b95 <concreate+0x215>
+    2b16:	66 90                	xchg   %ax,%ax
+       ((i % 3) == 1 && pid != 0)){
+    2b18:	85 ff                	test   %edi,%edi
+    2b1a:	0f 84 ae 00 00 00    	je     2bce <concreate+0x24e>
+      close(open(file, 0));
+    2b20:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    2b27:	00 
+    2b28:	89 1c 24             	mov    %ebx,(%esp)
+    2b2b:	e8 b2 21 00 00       	call   4ce2 <open>
+    2b30:	89 04 24             	mov    %eax,(%esp)
+    2b33:	e8 92 21 00 00       	call   4cca <close>
+      close(open(file, 0));
+    2b38:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    2b3f:	00 
+    2b40:	89 1c 24             	mov    %ebx,(%esp)
+    2b43:	e8 9a 21 00 00       	call   4ce2 <open>
+    2b48:	89 04 24             	mov    %eax,(%esp)
+    2b4b:	e8 7a 21 00 00       	call   4cca <close>
+      close(open(file, 0));
+    2b50:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    2b57:	00 
+    2b58:	89 1c 24             	mov    %ebx,(%esp)
+    2b5b:	e8 82 21 00 00       	call   4ce2 <open>
+    2b60:	89 04 24             	mov    %eax,(%esp)
+    2b63:	e8 62 21 00 00       	call   4cca <close>
+      close(open(file, 0));
+    2b68:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    2b6f:	00 
+    2b70:	89 1c 24             	mov    %ebx,(%esp)
+    2b73:	e8 6a 21 00 00       	call   4ce2 <open>
+    2b78:	89 04 24             	mov    %eax,(%esp)
+    2b7b:	e8 4a 21 00 00       	call   4cca <close>
+    if(pid == 0)
+    2b80:	85 ff                	test   %edi,%edi
+    2b82:	0f 84 b8 fe ff ff    	je     2a40 <concreate+0xc0>
+  for(i = 0; i < 40; i++){
+    2b88:	83 c6 01             	add    $0x1,%esi
+      wait();
+    2b8b:	e8 1a 21 00 00       	call   4caa <wait>
+  for(i = 0; i < 40; i++){
+    2b90:	83 fe 28             	cmp    $0x28,%esi
+    2b93:	74 5b                	je     2bf0 <concreate+0x270>
+    2b95:	8d 46 30             	lea    0x30(%esi),%eax
+    2b98:	88 45 ae             	mov    %al,-0x52(%ebp)
+    pid = fork();
+    2b9b:	e8 fa 20 00 00       	call   4c9a <fork>
+    if(pid < 0){
+    2ba0:	85 c0                	test   %eax,%eax
+    pid = fork();
+    2ba2:	89 c7                	mov    %eax,%edi
+    if(pid < 0){
+    2ba4:	78 66                	js     2c0c <concreate+0x28c>
+    if(((i % 3) == 0 && pid == 0) ||
+    2ba6:	b8 56 55 55 55       	mov    $0x55555556,%eax
+    2bab:	f7 ee                	imul   %esi
+    2bad:	89 f0                	mov    %esi,%eax
+    2baf:	c1 f8 1f             	sar    $0x1f,%eax
+    2bb2:	29 c2                	sub    %eax,%edx
+    2bb4:	8d 04 52             	lea    (%edx,%edx,2),%eax
+    2bb7:	89 f2                	mov    %esi,%edx
+    2bb9:	29 c2                	sub    %eax,%edx
+    2bbb:	89 d0                	mov    %edx,%eax
+    2bbd:	09 f8                	or     %edi,%eax
+    2bbf:	0f 84 5b ff ff ff    	je     2b20 <concreate+0x1a0>
+    2bc5:	83 fa 01             	cmp    $0x1,%edx
+    2bc8:	0f 84 4a ff ff ff    	je     2b18 <concreate+0x198>
+      unlink(file);
+    2bce:	89 1c 24             	mov    %ebx,(%esp)
+    2bd1:	e8 1c 21 00 00       	call   4cf2 <unlink>
+      unlink(file);
+    2bd6:	89 1c 24             	mov    %ebx,(%esp)
+    2bd9:	e8 14 21 00 00       	call   4cf2 <unlink>
+      unlink(file);
+    2bde:	89 1c 24             	mov    %ebx,(%esp)
+    2be1:	e8 0c 21 00 00       	call   4cf2 <unlink>
+      unlink(file);
+    2be6:	89 1c 24             	mov    %ebx,(%esp)
+    2be9:	e8 04 21 00 00       	call   4cf2 <unlink>
+    2bee:	eb 90                	jmp    2b80 <concreate+0x200>
+  printf(1, "concreate ok\n");
+    2bf0:	c7 44 24 04 62 58 00 	movl   $0x5862,0x4(%esp)
+    2bf7:	00 
+    2bf8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2bff:	e8 fc 21 00 00       	call   4e00 <printf>
+}
+    2c04:	83 c4 5c             	add    $0x5c,%esp
+    2c07:	5b                   	pop    %ebx
+    2c08:	5e                   	pop    %esi
+    2c09:	5f                   	pop    %edi
+    2c0a:	5d                   	pop    %ebp
+    2c0b:	c3                   	ret    
+      printf(1, "fork failed\n");
+    2c0c:	c7 44 24 04 e5 60 00 	movl   $0x60e5,0x4(%esp)
+    2c13:	00 
+    2c14:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2c1b:	e8 e0 21 00 00       	call   4e00 <printf>
+      exit();
+    2c20:	e8 7d 20 00 00       	call   4ca2 <exit>
+        printf(1, "concreate create %s failed\n", file);
+    2c25:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    2c29:	c7 44 24 04 10 58 00 	movl   $0x5810,0x4(%esp)
+    2c30:	00 
+    2c31:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2c38:	e8 c3 21 00 00       	call   4e00 <printf>
+        exit();
+    2c3d:	e8 60 20 00 00       	call   4ca2 <exit>
+        printf(1, "concreate weird file %s\n", de.name);
+    2c42:	8d 45 b2             	lea    -0x4e(%ebp),%eax
+    2c45:	89 44 24 08          	mov    %eax,0x8(%esp)
+    2c49:	c7 44 24 04 2c 58 00 	movl   $0x582c,0x4(%esp)
+    2c50:	00 
+    2c51:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2c58:	e8 a3 21 00 00       	call   4e00 <printf>
+    2c5d:	e9 de fd ff ff       	jmp    2a40 <concreate+0xc0>
+    printf(1, "concreate not enough files in directory listing\n");
+    2c62:	c7 44 24 04 ac 63 00 	movl   $0x63ac,0x4(%esp)
+    2c69:	00 
+    2c6a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2c71:	e8 8a 21 00 00       	call   4e00 <printf>
+    exit();
+    2c76:	e8 27 20 00 00       	call   4ca2 <exit>
+        printf(1, "concreate duplicate file %s\n", de.name);
+    2c7b:	8d 45 b2             	lea    -0x4e(%ebp),%eax
+    2c7e:	89 44 24 08          	mov    %eax,0x8(%esp)
+    2c82:	c7 44 24 04 45 58 00 	movl   $0x5845,0x4(%esp)
+    2c89:	00 
+    2c8a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2c91:	e8 6a 21 00 00       	call   4e00 <printf>
+        exit();
+    2c96:	e8 07 20 00 00       	call   4ca2 <exit>
+    2c9b:	90                   	nop
+    2c9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00002ca0 <linkunlink>:
+{
+    2ca0:	55                   	push   %ebp
+    2ca1:	89 e5                	mov    %esp,%ebp
+    2ca3:	57                   	push   %edi
+    2ca4:	56                   	push   %esi
+    2ca5:	53                   	push   %ebx
+    2ca6:	83 ec 1c             	sub    $0x1c,%esp
+  printf(1, "linkunlink test\n");
+    2ca9:	c7 44 24 04 70 58 00 	movl   $0x5870,0x4(%esp)
+    2cb0:	00 
+    2cb1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2cb8:	e8 43 21 00 00       	call   4e00 <printf>
+  unlink("x");
+    2cbd:	c7 04 24 fd 5a 00 00 	movl   $0x5afd,(%esp)
+    2cc4:	e8 29 20 00 00       	call   4cf2 <unlink>
+  pid = fork();
+    2cc9:	e8 cc 1f 00 00       	call   4c9a <fork>
+  if(pid < 0){
+    2cce:	85 c0                	test   %eax,%eax
+  pid = fork();
+    2cd0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(pid < 0){
+    2cd3:	0f 88 b8 00 00 00    	js     2d91 <linkunlink+0xf1>
+  unsigned int x = (pid ? 1 : 97);
+    2cd9:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
+    2cdd:	bb 64 00 00 00       	mov    $0x64,%ebx
+    if((x % 3) == 0){
+    2ce2:	be ab aa aa aa       	mov    $0xaaaaaaab,%esi
+  unsigned int x = (pid ? 1 : 97);
+    2ce7:	19 ff                	sbb    %edi,%edi
+    2ce9:	83 e7 60             	and    $0x60,%edi
+    2cec:	83 c7 01             	add    $0x1,%edi
+    2cef:	eb 1d                	jmp    2d0e <linkunlink+0x6e>
+    2cf1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    } else if((x % 3) == 1){
+    2cf8:	83 fa 01             	cmp    $0x1,%edx
+    2cfb:	74 7b                	je     2d78 <linkunlink+0xd8>
+      unlink("x");
+    2cfd:	c7 04 24 fd 5a 00 00 	movl   $0x5afd,(%esp)
+    2d04:	e8 e9 1f 00 00       	call   4cf2 <unlink>
+  for(i = 0; i < 100; i++){
+    2d09:	83 eb 01             	sub    $0x1,%ebx
+    2d0c:	74 3c                	je     2d4a <linkunlink+0xaa>
+    x = x * 1103515245 + 12345;
+    2d0e:	69 cf 6d 4e c6 41    	imul   $0x41c64e6d,%edi,%ecx
+    2d14:	8d b9 39 30 00 00    	lea    0x3039(%ecx),%edi
+    if((x % 3) == 0){
+    2d1a:	89 f8                	mov    %edi,%eax
+    2d1c:	f7 e6                	mul    %esi
+    2d1e:	d1 ea                	shr    %edx
+    2d20:	8d 04 52             	lea    (%edx,%edx,2),%eax
+    2d23:	89 fa                	mov    %edi,%edx
+    2d25:	29 c2                	sub    %eax,%edx
+    2d27:	75 cf                	jne    2cf8 <linkunlink+0x58>
+      close(open("x", O_RDWR | O_CREATE));
+    2d29:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    2d30:	00 
+    2d31:	c7 04 24 fd 5a 00 00 	movl   $0x5afd,(%esp)
+    2d38:	e8 a5 1f 00 00       	call   4ce2 <open>
+    2d3d:	89 04 24             	mov    %eax,(%esp)
+    2d40:	e8 85 1f 00 00       	call   4cca <close>
+  for(i = 0; i < 100; i++){
+    2d45:	83 eb 01             	sub    $0x1,%ebx
+    2d48:	75 c4                	jne    2d0e <linkunlink+0x6e>
+  if(pid)
+    2d4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    2d4d:	85 c0                	test   %eax,%eax
+    2d4f:	74 59                	je     2daa <linkunlink+0x10a>
+    wait();
+    2d51:	e8 54 1f 00 00       	call   4caa <wait>
+  printf(1, "linkunlink ok\n");
+    2d56:	c7 44 24 04 85 58 00 	movl   $0x5885,0x4(%esp)
+    2d5d:	00 
+    2d5e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2d65:	e8 96 20 00 00       	call   4e00 <printf>
+}
+    2d6a:	83 c4 1c             	add    $0x1c,%esp
+    2d6d:	5b                   	pop    %ebx
+    2d6e:	5e                   	pop    %esi
+    2d6f:	5f                   	pop    %edi
+    2d70:	5d                   	pop    %ebp
+    2d71:	c3                   	ret    
+    2d72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      link("cat", "x");
+    2d78:	c7 44 24 04 fd 5a 00 	movl   $0x5afd,0x4(%esp)
+    2d7f:	00 
+    2d80:	c7 04 24 81 58 00 00 	movl   $0x5881,(%esp)
+    2d87:	e8 76 1f 00 00       	call   4d02 <link>
+    2d8c:	e9 78 ff ff ff       	jmp    2d09 <linkunlink+0x69>
+    printf(1, "fork failed\n");
+    2d91:	c7 44 24 04 e5 60 00 	movl   $0x60e5,0x4(%esp)
+    2d98:	00 
+    2d99:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2da0:	e8 5b 20 00 00       	call   4e00 <printf>
+    exit();
+    2da5:	e8 f8 1e 00 00       	call   4ca2 <exit>
+    exit();
+    2daa:	e8 f3 1e 00 00       	call   4ca2 <exit>
+    2daf:	90                   	nop
+
+00002db0 <bigdir>:
+{
+    2db0:	55                   	push   %ebp
+    2db1:	89 e5                	mov    %esp,%ebp
+    2db3:	56                   	push   %esi
+    2db4:	53                   	push   %ebx
+    2db5:	83 ec 20             	sub    $0x20,%esp
+  printf(1, "bigdir test\n");
+    2db8:	c7 44 24 04 94 58 00 	movl   $0x5894,0x4(%esp)
+    2dbf:	00 
+    2dc0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2dc7:	e8 34 20 00 00       	call   4e00 <printf>
+  unlink("bd");
+    2dcc:	c7 04 24 a1 58 00 00 	movl   $0x58a1,(%esp)
+    2dd3:	e8 1a 1f 00 00       	call   4cf2 <unlink>
+  fd = open("bd", O_CREATE);
+    2dd8:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    2ddf:	00 
+    2de0:	c7 04 24 a1 58 00 00 	movl   $0x58a1,(%esp)
+    2de7:	e8 f6 1e 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    2dec:	85 c0                	test   %eax,%eax
+    2dee:	0f 88 e6 00 00 00    	js     2eda <bigdir+0x12a>
+  close(fd);
+    2df4:	89 04 24             	mov    %eax,(%esp)
+  for(i = 0; i < 500; i++){
+    2df7:	31 db                	xor    %ebx,%ebx
+  close(fd);
+    2df9:	e8 cc 1e 00 00       	call   4cca <close>
+    2dfe:	8d 75 ee             	lea    -0x12(%ebp),%esi
+    2e01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    name[1] = '0' + (i / 64);
+    2e08:	89 d8                	mov    %ebx,%eax
+    2e0a:	c1 f8 06             	sar    $0x6,%eax
+    2e0d:	83 c0 30             	add    $0x30,%eax
+    2e10:	88 45 ef             	mov    %al,-0x11(%ebp)
+    name[2] = '0' + (i % 64);
+    2e13:	89 d8                	mov    %ebx,%eax
+    2e15:	83 e0 3f             	and    $0x3f,%eax
+    2e18:	83 c0 30             	add    $0x30,%eax
+    if(link("bd", name) != 0){
+    2e1b:	89 74 24 04          	mov    %esi,0x4(%esp)
+    2e1f:	c7 04 24 a1 58 00 00 	movl   $0x58a1,(%esp)
+    name[0] = 'x';
+    2e26:	c6 45 ee 78          	movb   $0x78,-0x12(%ebp)
+    name[2] = '0' + (i % 64);
+    2e2a:	88 45 f0             	mov    %al,-0x10(%ebp)
+    name[3] = '\0';
+    2e2d:	c6 45 f1 00          	movb   $0x0,-0xf(%ebp)
+    if(link("bd", name) != 0){
+    2e31:	e8 cc 1e 00 00       	call   4d02 <link>
+    2e36:	85 c0                	test   %eax,%eax
+    2e38:	75 6e                	jne    2ea8 <bigdir+0xf8>
+  for(i = 0; i < 500; i++){
+    2e3a:	83 c3 01             	add    $0x1,%ebx
+    2e3d:	81 fb f4 01 00 00    	cmp    $0x1f4,%ebx
+    2e43:	75 c3                	jne    2e08 <bigdir+0x58>
+  unlink("bd");
+    2e45:	c7 04 24 a1 58 00 00 	movl   $0x58a1,(%esp)
+  for(i = 0; i < 500; i++){
+    2e4c:	66 31 db             	xor    %bx,%bx
+  unlink("bd");
+    2e4f:	e8 9e 1e 00 00       	call   4cf2 <unlink>
+    2e54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    name[1] = '0' + (i / 64);
+    2e58:	89 d8                	mov    %ebx,%eax
+    2e5a:	c1 f8 06             	sar    $0x6,%eax
+    2e5d:	83 c0 30             	add    $0x30,%eax
+    2e60:	88 45 ef             	mov    %al,-0x11(%ebp)
+    name[2] = '0' + (i % 64);
+    2e63:	89 d8                	mov    %ebx,%eax
+    2e65:	83 e0 3f             	and    $0x3f,%eax
+    2e68:	83 c0 30             	add    $0x30,%eax
+    if(unlink(name) != 0){
+    2e6b:	89 34 24             	mov    %esi,(%esp)
+    name[0] = 'x';
+    2e6e:	c6 45 ee 78          	movb   $0x78,-0x12(%ebp)
+    name[2] = '0' + (i % 64);
+    2e72:	88 45 f0             	mov    %al,-0x10(%ebp)
+    name[3] = '\0';
+    2e75:	c6 45 f1 00          	movb   $0x0,-0xf(%ebp)
+    if(unlink(name) != 0){
+    2e79:	e8 74 1e 00 00       	call   4cf2 <unlink>
+    2e7e:	85 c0                	test   %eax,%eax
+    2e80:	75 3f                	jne    2ec1 <bigdir+0x111>
+  for(i = 0; i < 500; i++){
+    2e82:	83 c3 01             	add    $0x1,%ebx
+    2e85:	81 fb f4 01 00 00    	cmp    $0x1f4,%ebx
+    2e8b:	75 cb                	jne    2e58 <bigdir+0xa8>
+  printf(1, "bigdir ok\n");
+    2e8d:	c7 44 24 04 e3 58 00 	movl   $0x58e3,0x4(%esp)
+    2e94:	00 
+    2e95:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2e9c:	e8 5f 1f 00 00       	call   4e00 <printf>
+}
+    2ea1:	83 c4 20             	add    $0x20,%esp
+    2ea4:	5b                   	pop    %ebx
+    2ea5:	5e                   	pop    %esi
+    2ea6:	5d                   	pop    %ebp
+    2ea7:	c3                   	ret    
+      printf(1, "bigdir link failed\n");
+    2ea8:	c7 44 24 04 ba 58 00 	movl   $0x58ba,0x4(%esp)
+    2eaf:	00 
+    2eb0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2eb7:	e8 44 1f 00 00       	call   4e00 <printf>
+      exit();
+    2ebc:	e8 e1 1d 00 00       	call   4ca2 <exit>
+      printf(1, "bigdir unlink failed");
+    2ec1:	c7 44 24 04 ce 58 00 	movl   $0x58ce,0x4(%esp)
+    2ec8:	00 
+    2ec9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2ed0:	e8 2b 1f 00 00       	call   4e00 <printf>
+      exit();
+    2ed5:	e8 c8 1d 00 00       	call   4ca2 <exit>
+    printf(1, "bigdir create failed\n");
+    2eda:	c7 44 24 04 a4 58 00 	movl   $0x58a4,0x4(%esp)
+    2ee1:	00 
+    2ee2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2ee9:	e8 12 1f 00 00       	call   4e00 <printf>
+    exit();
+    2eee:	e8 af 1d 00 00       	call   4ca2 <exit>
+    2ef3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    2ef9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00002f00 <subdir>:
+{
+    2f00:	55                   	push   %ebp
+    2f01:	89 e5                	mov    %esp,%ebp
+    2f03:	53                   	push   %ebx
+    2f04:	83 ec 14             	sub    $0x14,%esp
+  printf(1, "subdir test\n");
+    2f07:	c7 44 24 04 ee 58 00 	movl   $0x58ee,0x4(%esp)
+    2f0e:	00 
+    2f0f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2f16:	e8 e5 1e 00 00       	call   4e00 <printf>
+  unlink("ff");
+    2f1b:	c7 04 24 77 59 00 00 	movl   $0x5977,(%esp)
+    2f22:	e8 cb 1d 00 00       	call   4cf2 <unlink>
+  if(mkdir("dd") != 0){
+    2f27:	c7 04 24 14 5a 00 00 	movl   $0x5a14,(%esp)
+    2f2e:	e8 d7 1d 00 00       	call   4d0a <mkdir>
+    2f33:	85 c0                	test   %eax,%eax
+    2f35:	0f 85 07 06 00 00    	jne    3542 <subdir+0x642>
+  fd = open("dd/ff", O_CREATE | O_RDWR);
+    2f3b:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    2f42:	00 
+    2f43:	c7 04 24 4d 59 00 00 	movl   $0x594d,(%esp)
+    2f4a:	e8 93 1d 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    2f4f:	85 c0                	test   %eax,%eax
+  fd = open("dd/ff", O_CREATE | O_RDWR);
+    2f51:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    2f53:	0f 88 d0 05 00 00    	js     3529 <subdir+0x629>
+  write(fd, "ff", 2);
+    2f59:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
+    2f60:	00 
+    2f61:	c7 44 24 04 77 59 00 	movl   $0x5977,0x4(%esp)
+    2f68:	00 
+    2f69:	89 04 24             	mov    %eax,(%esp)
+    2f6c:	e8 51 1d 00 00       	call   4cc2 <write>
+  close(fd);
+    2f71:	89 1c 24             	mov    %ebx,(%esp)
+    2f74:	e8 51 1d 00 00       	call   4cca <close>
+  if(unlink("dd") >= 0){
+    2f79:	c7 04 24 14 5a 00 00 	movl   $0x5a14,(%esp)
+    2f80:	e8 6d 1d 00 00       	call   4cf2 <unlink>
+    2f85:	85 c0                	test   %eax,%eax
+    2f87:	0f 89 83 05 00 00    	jns    3510 <subdir+0x610>
+  if(mkdir("/dd/dd") != 0){
+    2f8d:	c7 04 24 28 59 00 00 	movl   $0x5928,(%esp)
+    2f94:	e8 71 1d 00 00       	call   4d0a <mkdir>
+    2f99:	85 c0                	test   %eax,%eax
+    2f9b:	0f 85 56 05 00 00    	jne    34f7 <subdir+0x5f7>
+  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+    2fa1:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    2fa8:	00 
+    2fa9:	c7 04 24 4a 59 00 00 	movl   $0x594a,(%esp)
+    2fb0:	e8 2d 1d 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    2fb5:	85 c0                	test   %eax,%eax
+  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+    2fb7:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    2fb9:	0f 88 25 04 00 00    	js     33e4 <subdir+0x4e4>
+  write(fd, "FF", 2);
+    2fbf:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
+    2fc6:	00 
+    2fc7:	c7 44 24 04 6b 59 00 	movl   $0x596b,0x4(%esp)
+    2fce:	00 
+    2fcf:	89 04 24             	mov    %eax,(%esp)
+    2fd2:	e8 eb 1c 00 00       	call   4cc2 <write>
+  close(fd);
+    2fd7:	89 1c 24             	mov    %ebx,(%esp)
+    2fda:	e8 eb 1c 00 00       	call   4cca <close>
+  fd = open("dd/dd/../ff", 0);
+    2fdf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    2fe6:	00 
+    2fe7:	c7 04 24 6e 59 00 00 	movl   $0x596e,(%esp)
+    2fee:	e8 ef 1c 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    2ff3:	85 c0                	test   %eax,%eax
+  fd = open("dd/dd/../ff", 0);
+    2ff5:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    2ff7:	0f 88 ce 03 00 00    	js     33cb <subdir+0x4cb>
+  cc = read(fd, buf, sizeof(buf));
+    2ffd:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
+    3004:	00 
+    3005:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    300c:	00 
+    300d:	89 04 24             	mov    %eax,(%esp)
+    3010:	e8 a5 1c 00 00       	call   4cba <read>
+  if(cc != 2 || buf[0] != 'f'){
+    3015:	83 f8 02             	cmp    $0x2,%eax
+    3018:	0f 85 fe 02 00 00    	jne    331c <subdir+0x41c>
+    301e:	80 3d 40 9a 00 00 66 	cmpb   $0x66,0x9a40
+    3025:	0f 85 f1 02 00 00    	jne    331c <subdir+0x41c>
+  close(fd);
+    302b:	89 1c 24             	mov    %ebx,(%esp)
+    302e:	e8 97 1c 00 00       	call   4cca <close>
+  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+    3033:	c7 44 24 04 ae 59 00 	movl   $0x59ae,0x4(%esp)
+    303a:	00 
+    303b:	c7 04 24 4a 59 00 00 	movl   $0x594a,(%esp)
+    3042:	e8 bb 1c 00 00       	call   4d02 <link>
+    3047:	85 c0                	test   %eax,%eax
+    3049:	0f 85 c7 03 00 00    	jne    3416 <subdir+0x516>
+  if(unlink("dd/dd/ff") != 0){
+    304f:	c7 04 24 4a 59 00 00 	movl   $0x594a,(%esp)
+    3056:	e8 97 1c 00 00       	call   4cf2 <unlink>
+    305b:	85 c0                	test   %eax,%eax
+    305d:	0f 85 eb 02 00 00    	jne    334e <subdir+0x44e>
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    3063:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    306a:	00 
+    306b:	c7 04 24 4a 59 00 00 	movl   $0x594a,(%esp)
+    3072:	e8 6b 1c 00 00       	call   4ce2 <open>
+    3077:	85 c0                	test   %eax,%eax
+    3079:	0f 89 5f 04 00 00    	jns    34de <subdir+0x5de>
+  if(chdir("dd") != 0){
+    307f:	c7 04 24 14 5a 00 00 	movl   $0x5a14,(%esp)
+    3086:	e8 87 1c 00 00       	call   4d12 <chdir>
+    308b:	85 c0                	test   %eax,%eax
+    308d:	0f 85 32 04 00 00    	jne    34c5 <subdir+0x5c5>
+  if(chdir("dd/../../dd") != 0){
+    3093:	c7 04 24 e2 59 00 00 	movl   $0x59e2,(%esp)
+    309a:	e8 73 1c 00 00       	call   4d12 <chdir>
+    309f:	85 c0                	test   %eax,%eax
+    30a1:	0f 85 8e 02 00 00    	jne    3335 <subdir+0x435>
+  if(chdir("dd/../../../dd") != 0){
+    30a7:	c7 04 24 08 5a 00 00 	movl   $0x5a08,(%esp)
+    30ae:	e8 5f 1c 00 00       	call   4d12 <chdir>
+    30b3:	85 c0                	test   %eax,%eax
+    30b5:	0f 85 7a 02 00 00    	jne    3335 <subdir+0x435>
+  if(chdir("./..") != 0){
+    30bb:	c7 04 24 17 5a 00 00 	movl   $0x5a17,(%esp)
+    30c2:	e8 4b 1c 00 00       	call   4d12 <chdir>
+    30c7:	85 c0                	test   %eax,%eax
+    30c9:	0f 85 2e 03 00 00    	jne    33fd <subdir+0x4fd>
+  fd = open("dd/dd/ffff", 0);
+    30cf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    30d6:	00 
+    30d7:	c7 04 24 ae 59 00 00 	movl   $0x59ae,(%esp)
+    30de:	e8 ff 1b 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    30e3:	85 c0                	test   %eax,%eax
+  fd = open("dd/dd/ffff", 0);
+    30e5:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    30e7:	0f 88 81 05 00 00    	js     366e <subdir+0x76e>
+  if(read(fd, buf, sizeof(buf)) != 2){
+    30ed:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
+    30f4:	00 
+    30f5:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    30fc:	00 
+    30fd:	89 04 24             	mov    %eax,(%esp)
+    3100:	e8 b5 1b 00 00       	call   4cba <read>
+    3105:	83 f8 02             	cmp    $0x2,%eax
+    3108:	0f 85 47 05 00 00    	jne    3655 <subdir+0x755>
+  close(fd);
+    310e:	89 1c 24             	mov    %ebx,(%esp)
+    3111:	e8 b4 1b 00 00       	call   4cca <close>
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    3116:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    311d:	00 
+    311e:	c7 04 24 4a 59 00 00 	movl   $0x594a,(%esp)
+    3125:	e8 b8 1b 00 00       	call   4ce2 <open>
+    312a:	85 c0                	test   %eax,%eax
+    312c:	0f 89 4e 02 00 00    	jns    3380 <subdir+0x480>
+  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+    3132:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    3139:	00 
+    313a:	c7 04 24 62 5a 00 00 	movl   $0x5a62,(%esp)
+    3141:	e8 9c 1b 00 00       	call   4ce2 <open>
+    3146:	85 c0                	test   %eax,%eax
+    3148:	0f 89 19 02 00 00    	jns    3367 <subdir+0x467>
+  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+    314e:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    3155:	00 
+    3156:	c7 04 24 87 5a 00 00 	movl   $0x5a87,(%esp)
+    315d:	e8 80 1b 00 00       	call   4ce2 <open>
+    3162:	85 c0                	test   %eax,%eax
+    3164:	0f 89 42 03 00 00    	jns    34ac <subdir+0x5ac>
+  if(open("dd", O_CREATE) >= 0){
+    316a:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    3171:	00 
+    3172:	c7 04 24 14 5a 00 00 	movl   $0x5a14,(%esp)
+    3179:	e8 64 1b 00 00       	call   4ce2 <open>
+    317e:	85 c0                	test   %eax,%eax
+    3180:	0f 89 0d 03 00 00    	jns    3493 <subdir+0x593>
+  if(open("dd", O_RDWR) >= 0){
+    3186:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+    318d:	00 
+    318e:	c7 04 24 14 5a 00 00 	movl   $0x5a14,(%esp)
+    3195:	e8 48 1b 00 00       	call   4ce2 <open>
+    319a:	85 c0                	test   %eax,%eax
+    319c:	0f 89 d8 02 00 00    	jns    347a <subdir+0x57a>
+  if(open("dd", O_WRONLY) >= 0){
+    31a2:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+    31a9:	00 
+    31aa:	c7 04 24 14 5a 00 00 	movl   $0x5a14,(%esp)
+    31b1:	e8 2c 1b 00 00       	call   4ce2 <open>
+    31b6:	85 c0                	test   %eax,%eax
+    31b8:	0f 89 a3 02 00 00    	jns    3461 <subdir+0x561>
+  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+    31be:	c7 44 24 04 f6 5a 00 	movl   $0x5af6,0x4(%esp)
+    31c5:	00 
+    31c6:	c7 04 24 62 5a 00 00 	movl   $0x5a62,(%esp)
+    31cd:	e8 30 1b 00 00       	call   4d02 <link>
+    31d2:	85 c0                	test   %eax,%eax
+    31d4:	0f 84 6e 02 00 00    	je     3448 <subdir+0x548>
+  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+    31da:	c7 44 24 04 f6 5a 00 	movl   $0x5af6,0x4(%esp)
+    31e1:	00 
+    31e2:	c7 04 24 87 5a 00 00 	movl   $0x5a87,(%esp)
+    31e9:	e8 14 1b 00 00       	call   4d02 <link>
+    31ee:	85 c0                	test   %eax,%eax
+    31f0:	0f 84 39 02 00 00    	je     342f <subdir+0x52f>
+  if(link("dd/ff", "dd/dd/ffff") == 0){
+    31f6:	c7 44 24 04 ae 59 00 	movl   $0x59ae,0x4(%esp)
+    31fd:	00 
+    31fe:	c7 04 24 4d 59 00 00 	movl   $0x594d,(%esp)
+    3205:	e8 f8 1a 00 00       	call   4d02 <link>
+    320a:	85 c0                	test   %eax,%eax
+    320c:	0f 84 a0 01 00 00    	je     33b2 <subdir+0x4b2>
+  if(mkdir("dd/ff/ff") == 0){
+    3212:	c7 04 24 62 5a 00 00 	movl   $0x5a62,(%esp)
+    3219:	e8 ec 1a 00 00       	call   4d0a <mkdir>
+    321e:	85 c0                	test   %eax,%eax
+    3220:	0f 84 73 01 00 00    	je     3399 <subdir+0x499>
+  if(mkdir("dd/xx/ff") == 0){
+    3226:	c7 04 24 87 5a 00 00 	movl   $0x5a87,(%esp)
+    322d:	e8 d8 1a 00 00       	call   4d0a <mkdir>
+    3232:	85 c0                	test   %eax,%eax
+    3234:	0f 84 02 04 00 00    	je     363c <subdir+0x73c>
+  if(mkdir("dd/dd/ffff") == 0){
+    323a:	c7 04 24 ae 59 00 00 	movl   $0x59ae,(%esp)
+    3241:	e8 c4 1a 00 00       	call   4d0a <mkdir>
+    3246:	85 c0                	test   %eax,%eax
+    3248:	0f 84 d5 03 00 00    	je     3623 <subdir+0x723>
+  if(unlink("dd/xx/ff") == 0){
+    324e:	c7 04 24 87 5a 00 00 	movl   $0x5a87,(%esp)
+    3255:	e8 98 1a 00 00       	call   4cf2 <unlink>
+    325a:	85 c0                	test   %eax,%eax
+    325c:	0f 84 a8 03 00 00    	je     360a <subdir+0x70a>
+  if(unlink("dd/ff/ff") == 0){
+    3262:	c7 04 24 62 5a 00 00 	movl   $0x5a62,(%esp)
+    3269:	e8 84 1a 00 00       	call   4cf2 <unlink>
+    326e:	85 c0                	test   %eax,%eax
+    3270:	0f 84 7b 03 00 00    	je     35f1 <subdir+0x6f1>
+  if(chdir("dd/ff") == 0){
+    3276:	c7 04 24 4d 59 00 00 	movl   $0x594d,(%esp)
+    327d:	e8 90 1a 00 00       	call   4d12 <chdir>
+    3282:	85 c0                	test   %eax,%eax
+    3284:	0f 84 4e 03 00 00    	je     35d8 <subdir+0x6d8>
+  if(chdir("dd/xx") == 0){
+    328a:	c7 04 24 f9 5a 00 00 	movl   $0x5af9,(%esp)
+    3291:	e8 7c 1a 00 00       	call   4d12 <chdir>
+    3296:	85 c0                	test   %eax,%eax
+    3298:	0f 84 21 03 00 00    	je     35bf <subdir+0x6bf>
+  if(unlink("dd/dd/ffff") != 0){
+    329e:	c7 04 24 ae 59 00 00 	movl   $0x59ae,(%esp)
+    32a5:	e8 48 1a 00 00       	call   4cf2 <unlink>
+    32aa:	85 c0                	test   %eax,%eax
+    32ac:	0f 85 9c 00 00 00    	jne    334e <subdir+0x44e>
+  if(unlink("dd/ff") != 0){
+    32b2:	c7 04 24 4d 59 00 00 	movl   $0x594d,(%esp)
+    32b9:	e8 34 1a 00 00       	call   4cf2 <unlink>
+    32be:	85 c0                	test   %eax,%eax
+    32c0:	0f 85 e0 02 00 00    	jne    35a6 <subdir+0x6a6>
+  if(unlink("dd") == 0){
+    32c6:	c7 04 24 14 5a 00 00 	movl   $0x5a14,(%esp)
+    32cd:	e8 20 1a 00 00       	call   4cf2 <unlink>
+    32d2:	85 c0                	test   %eax,%eax
+    32d4:	0f 84 b3 02 00 00    	je     358d <subdir+0x68d>
+  if(unlink("dd/dd") < 0){
+    32da:	c7 04 24 29 59 00 00 	movl   $0x5929,(%esp)
+    32e1:	e8 0c 1a 00 00       	call   4cf2 <unlink>
+    32e6:	85 c0                	test   %eax,%eax
+    32e8:	0f 88 86 02 00 00    	js     3574 <subdir+0x674>
+  if(unlink("dd") < 0){
+    32ee:	c7 04 24 14 5a 00 00 	movl   $0x5a14,(%esp)
+    32f5:	e8 f8 19 00 00       	call   4cf2 <unlink>
+    32fa:	85 c0                	test   %eax,%eax
+    32fc:	0f 88 59 02 00 00    	js     355b <subdir+0x65b>
+  printf(1, "subdir ok\n");
+    3302:	c7 44 24 04 f6 5b 00 	movl   $0x5bf6,0x4(%esp)
+    3309:	00 
+    330a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3311:	e8 ea 1a 00 00       	call   4e00 <printf>
+}
+    3316:	83 c4 14             	add    $0x14,%esp
+    3319:	5b                   	pop    %ebx
+    331a:	5d                   	pop    %ebp
+    331b:	c3                   	ret    
+    printf(1, "dd/dd/../ff wrong content\n");
+    331c:	c7 44 24 04 93 59 00 	movl   $0x5993,0x4(%esp)
+    3323:	00 
+    3324:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    332b:	e8 d0 1a 00 00       	call   4e00 <printf>
+    exit();
+    3330:	e8 6d 19 00 00       	call   4ca2 <exit>
+    printf(1, "chdir dd/../../dd failed\n");
+    3335:	c7 44 24 04 ee 59 00 	movl   $0x59ee,0x4(%esp)
+    333c:	00 
+    333d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3344:	e8 b7 1a 00 00       	call   4e00 <printf>
+    exit();
+    3349:	e8 54 19 00 00       	call   4ca2 <exit>
+    printf(1, "unlink dd/dd/ff failed\n");
+    334e:	c7 44 24 04 b9 59 00 	movl   $0x59b9,0x4(%esp)
+    3355:	00 
+    3356:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    335d:	e8 9e 1a 00 00       	call   4e00 <printf>
+    exit();
+    3362:	e8 3b 19 00 00       	call   4ca2 <exit>
+    printf(1, "create dd/ff/ff succeeded!\n");
+    3367:	c7 44 24 04 6b 5a 00 	movl   $0x5a6b,0x4(%esp)
+    336e:	00 
+    336f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3376:	e8 85 1a 00 00       	call   4e00 <printf>
+    exit();
+    337b:	e8 22 19 00 00       	call   4ca2 <exit>
+    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+    3380:	c7 44 24 04 50 64 00 	movl   $0x6450,0x4(%esp)
+    3387:	00 
+    3388:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    338f:	e8 6c 1a 00 00       	call   4e00 <printf>
+    exit();
+    3394:	e8 09 19 00 00       	call   4ca2 <exit>
+    printf(1, "mkdir dd/ff/ff succeeded!\n");
+    3399:	c7 44 24 04 ff 5a 00 	movl   $0x5aff,0x4(%esp)
+    33a0:	00 
+    33a1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    33a8:	e8 53 1a 00 00       	call   4e00 <printf>
+    exit();
+    33ad:	e8 f0 18 00 00       	call   4ca2 <exit>
+    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+    33b2:	c7 44 24 04 c0 64 00 	movl   $0x64c0,0x4(%esp)
+    33b9:	00 
+    33ba:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    33c1:	e8 3a 1a 00 00       	call   4e00 <printf>
+    exit();
+    33c6:	e8 d7 18 00 00       	call   4ca2 <exit>
+    printf(1, "open dd/dd/../ff failed\n");
+    33cb:	c7 44 24 04 7a 59 00 	movl   $0x597a,0x4(%esp)
+    33d2:	00 
+    33d3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    33da:	e8 21 1a 00 00       	call   4e00 <printf>
+    exit();
+    33df:	e8 be 18 00 00       	call   4ca2 <exit>
+    printf(1, "create dd/dd/ff failed\n");
+    33e4:	c7 44 24 04 53 59 00 	movl   $0x5953,0x4(%esp)
+    33eb:	00 
+    33ec:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    33f3:	e8 08 1a 00 00       	call   4e00 <printf>
+    exit();
+    33f8:	e8 a5 18 00 00       	call   4ca2 <exit>
+    printf(1, "chdir ./.. failed\n");
+    33fd:	c7 44 24 04 1c 5a 00 	movl   $0x5a1c,0x4(%esp)
+    3404:	00 
+    3405:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    340c:	e8 ef 19 00 00       	call   4e00 <printf>
+    exit();
+    3411:	e8 8c 18 00 00       	call   4ca2 <exit>
+    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+    3416:	c7 44 24 04 08 64 00 	movl   $0x6408,0x4(%esp)
+    341d:	00 
+    341e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3425:	e8 d6 19 00 00       	call   4e00 <printf>
+    exit();
+    342a:	e8 73 18 00 00       	call   4ca2 <exit>
+    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+    342f:	c7 44 24 04 9c 64 00 	movl   $0x649c,0x4(%esp)
+    3436:	00 
+    3437:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    343e:	e8 bd 19 00 00       	call   4e00 <printf>
+    exit();
+    3443:	e8 5a 18 00 00       	call   4ca2 <exit>
+    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+    3448:	c7 44 24 04 78 64 00 	movl   $0x6478,0x4(%esp)
+    344f:	00 
+    3450:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3457:	e8 a4 19 00 00       	call   4e00 <printf>
+    exit();
+    345c:	e8 41 18 00 00       	call   4ca2 <exit>
+    printf(1, "open dd wronly succeeded!\n");
+    3461:	c7 44 24 04 db 5a 00 	movl   $0x5adb,0x4(%esp)
+    3468:	00 
+    3469:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3470:	e8 8b 19 00 00       	call   4e00 <printf>
+    exit();
+    3475:	e8 28 18 00 00       	call   4ca2 <exit>
+    printf(1, "open dd rdwr succeeded!\n");
+    347a:	c7 44 24 04 c2 5a 00 	movl   $0x5ac2,0x4(%esp)
+    3481:	00 
+    3482:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3489:	e8 72 19 00 00       	call   4e00 <printf>
+    exit();
+    348e:	e8 0f 18 00 00       	call   4ca2 <exit>
+    printf(1, "create dd succeeded!\n");
+    3493:	c7 44 24 04 ac 5a 00 	movl   $0x5aac,0x4(%esp)
+    349a:	00 
+    349b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    34a2:	e8 59 19 00 00       	call   4e00 <printf>
+    exit();
+    34a7:	e8 f6 17 00 00       	call   4ca2 <exit>
+    printf(1, "create dd/xx/ff succeeded!\n");
+    34ac:	c7 44 24 04 90 5a 00 	movl   $0x5a90,0x4(%esp)
+    34b3:	00 
+    34b4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    34bb:	e8 40 19 00 00       	call   4e00 <printf>
+    exit();
+    34c0:	e8 dd 17 00 00       	call   4ca2 <exit>
+    printf(1, "chdir dd failed\n");
+    34c5:	c7 44 24 04 d1 59 00 	movl   $0x59d1,0x4(%esp)
+    34cc:	00 
+    34cd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    34d4:	e8 27 19 00 00       	call   4e00 <printf>
+    exit();
+    34d9:	e8 c4 17 00 00       	call   4ca2 <exit>
+    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+    34de:	c7 44 24 04 2c 64 00 	movl   $0x642c,0x4(%esp)
+    34e5:	00 
+    34e6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    34ed:	e8 0e 19 00 00       	call   4e00 <printf>
+    exit();
+    34f2:	e8 ab 17 00 00       	call   4ca2 <exit>
+    printf(1, "subdir mkdir dd/dd failed\n");
+    34f7:	c7 44 24 04 2f 59 00 	movl   $0x592f,0x4(%esp)
+    34fe:	00 
+    34ff:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3506:	e8 f5 18 00 00       	call   4e00 <printf>
+    exit();
+    350b:	e8 92 17 00 00       	call   4ca2 <exit>
+    printf(1, "unlink dd (non-empty dir) succeeded!\n");
+    3510:	c7 44 24 04 e0 63 00 	movl   $0x63e0,0x4(%esp)
+    3517:	00 
+    3518:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    351f:	e8 dc 18 00 00       	call   4e00 <printf>
+    exit();
+    3524:	e8 79 17 00 00       	call   4ca2 <exit>
+    printf(1, "create dd/ff failed\n");
+    3529:	c7 44 24 04 13 59 00 	movl   $0x5913,0x4(%esp)
+    3530:	00 
+    3531:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3538:	e8 c3 18 00 00       	call   4e00 <printf>
+    exit();
+    353d:	e8 60 17 00 00       	call   4ca2 <exit>
+    printf(1, "subdir mkdir dd failed\n");
+    3542:	c7 44 24 04 fb 58 00 	movl   $0x58fb,0x4(%esp)
+    3549:	00 
+    354a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3551:	e8 aa 18 00 00       	call   4e00 <printf>
+    exit();
+    3556:	e8 47 17 00 00       	call   4ca2 <exit>
+    printf(1, "unlink dd failed\n");
+    355b:	c7 44 24 04 e4 5b 00 	movl   $0x5be4,0x4(%esp)
+    3562:	00 
+    3563:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    356a:	e8 91 18 00 00       	call   4e00 <printf>
+    exit();
+    356f:	e8 2e 17 00 00       	call   4ca2 <exit>
+    printf(1, "unlink dd/dd failed\n");
+    3574:	c7 44 24 04 cf 5b 00 	movl   $0x5bcf,0x4(%esp)
+    357b:	00 
+    357c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3583:	e8 78 18 00 00       	call   4e00 <printf>
+    exit();
+    3588:	e8 15 17 00 00       	call   4ca2 <exit>
+    printf(1, "unlink non-empty dd succeeded!\n");
+    358d:	c7 44 24 04 e4 64 00 	movl   $0x64e4,0x4(%esp)
+    3594:	00 
+    3595:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    359c:	e8 5f 18 00 00       	call   4e00 <printf>
+    exit();
+    35a1:	e8 fc 16 00 00       	call   4ca2 <exit>
+    printf(1, "unlink dd/ff failed\n");
+    35a6:	c7 44 24 04 ba 5b 00 	movl   $0x5bba,0x4(%esp)
+    35ad:	00 
+    35ae:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    35b5:	e8 46 18 00 00       	call   4e00 <printf>
+    exit();
+    35ba:	e8 e3 16 00 00       	call   4ca2 <exit>
+    printf(1, "chdir dd/xx succeeded!\n");
+    35bf:	c7 44 24 04 a2 5b 00 	movl   $0x5ba2,0x4(%esp)
+    35c6:	00 
+    35c7:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    35ce:	e8 2d 18 00 00       	call   4e00 <printf>
+    exit();
+    35d3:	e8 ca 16 00 00       	call   4ca2 <exit>
+    printf(1, "chdir dd/ff succeeded!\n");
+    35d8:	c7 44 24 04 8a 5b 00 	movl   $0x5b8a,0x4(%esp)
+    35df:	00 
+    35e0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    35e7:	e8 14 18 00 00       	call   4e00 <printf>
+    exit();
+    35ec:	e8 b1 16 00 00       	call   4ca2 <exit>
+    printf(1, "unlink dd/ff/ff succeeded!\n");
+    35f1:	c7 44 24 04 6e 5b 00 	movl   $0x5b6e,0x4(%esp)
+    35f8:	00 
+    35f9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3600:	e8 fb 17 00 00       	call   4e00 <printf>
+    exit();
+    3605:	e8 98 16 00 00       	call   4ca2 <exit>
+    printf(1, "unlink dd/xx/ff succeeded!\n");
+    360a:	c7 44 24 04 52 5b 00 	movl   $0x5b52,0x4(%esp)
+    3611:	00 
+    3612:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3619:	e8 e2 17 00 00       	call   4e00 <printf>
+    exit();
+    361e:	e8 7f 16 00 00       	call   4ca2 <exit>
+    printf(1, "mkdir dd/dd/ffff succeeded!\n");
+    3623:	c7 44 24 04 35 5b 00 	movl   $0x5b35,0x4(%esp)
+    362a:	00 
+    362b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3632:	e8 c9 17 00 00       	call   4e00 <printf>
+    exit();
+    3637:	e8 66 16 00 00       	call   4ca2 <exit>
+    printf(1, "mkdir dd/xx/ff succeeded!\n");
+    363c:	c7 44 24 04 1a 5b 00 	movl   $0x5b1a,0x4(%esp)
+    3643:	00 
+    3644:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    364b:	e8 b0 17 00 00       	call   4e00 <printf>
+    exit();
+    3650:	e8 4d 16 00 00       	call   4ca2 <exit>
+    printf(1, "read dd/dd/ffff wrong len\n");
+    3655:	c7 44 24 04 47 5a 00 	movl   $0x5a47,0x4(%esp)
+    365c:	00 
+    365d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3664:	e8 97 17 00 00       	call   4e00 <printf>
+    exit();
+    3669:	e8 34 16 00 00       	call   4ca2 <exit>
+    printf(1, "open dd/dd/ffff failed\n");
+    366e:	c7 44 24 04 2f 5a 00 	movl   $0x5a2f,0x4(%esp)
+    3675:	00 
+    3676:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    367d:	e8 7e 17 00 00       	call   4e00 <printf>
+    exit();
+    3682:	e8 1b 16 00 00       	call   4ca2 <exit>
+    3687:	89 f6                	mov    %esi,%esi
+    3689:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00003690 <bigwrite>:
+{
+    3690:	55                   	push   %ebp
+    3691:	89 e5                	mov    %esp,%ebp
+    3693:	56                   	push   %esi
+    3694:	53                   	push   %ebx
+  for(sz = 499; sz < 12*512; sz += 471){
+    3695:	bb f3 01 00 00       	mov    $0x1f3,%ebx
+{
+    369a:	83 ec 10             	sub    $0x10,%esp
+  printf(1, "bigwrite test\n");
+    369d:	c7 44 24 04 01 5c 00 	movl   $0x5c01,0x4(%esp)
+    36a4:	00 
+    36a5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    36ac:	e8 4f 17 00 00       	call   4e00 <printf>
+  unlink("bigwrite");
+    36b1:	c7 04 24 10 5c 00 00 	movl   $0x5c10,(%esp)
+    36b8:	e8 35 16 00 00       	call   4cf2 <unlink>
+    36bd:	8d 76 00             	lea    0x0(%esi),%esi
+    fd = open("bigwrite", O_CREATE | O_RDWR);
+    36c0:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    36c7:	00 
+    36c8:	c7 04 24 10 5c 00 00 	movl   $0x5c10,(%esp)
+    36cf:	e8 0e 16 00 00       	call   4ce2 <open>
+    if(fd < 0){
+    36d4:	85 c0                	test   %eax,%eax
+    fd = open("bigwrite", O_CREATE | O_RDWR);
+    36d6:	89 c6                	mov    %eax,%esi
+    if(fd < 0){
+    36d8:	0f 88 8e 00 00 00    	js     376c <bigwrite+0xdc>
+      int cc = write(fd, buf, sz);
+    36de:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    36e2:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    36e9:	00 
+    36ea:	89 04 24             	mov    %eax,(%esp)
+    36ed:	e8 d0 15 00 00       	call   4cc2 <write>
+      if(cc != sz){
+    36f2:	39 d8                	cmp    %ebx,%eax
+    36f4:	75 55                	jne    374b <bigwrite+0xbb>
+      int cc = write(fd, buf, sz);
+    36f6:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    36fa:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    3701:	00 
+    3702:	89 34 24             	mov    %esi,(%esp)
+    3705:	e8 b8 15 00 00       	call   4cc2 <write>
+      if(cc != sz){
+    370a:	39 c3                	cmp    %eax,%ebx
+    370c:	75 3d                	jne    374b <bigwrite+0xbb>
+    close(fd);
+    370e:	89 34 24             	mov    %esi,(%esp)
+  for(sz = 499; sz < 12*512; sz += 471){
+    3711:	81 c3 d7 01 00 00    	add    $0x1d7,%ebx
+    close(fd);
+    3717:	e8 ae 15 00 00       	call   4cca <close>
+    unlink("bigwrite");
+    371c:	c7 04 24 10 5c 00 00 	movl   $0x5c10,(%esp)
+    3723:	e8 ca 15 00 00       	call   4cf2 <unlink>
+  for(sz = 499; sz < 12*512; sz += 471){
+    3728:	81 fb 07 18 00 00    	cmp    $0x1807,%ebx
+    372e:	75 90                	jne    36c0 <bigwrite+0x30>
+  printf(1, "bigwrite ok\n");
+    3730:	c7 44 24 04 43 5c 00 	movl   $0x5c43,0x4(%esp)
+    3737:	00 
+    3738:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    373f:	e8 bc 16 00 00       	call   4e00 <printf>
+}
+    3744:	83 c4 10             	add    $0x10,%esp
+    3747:	5b                   	pop    %ebx
+    3748:	5e                   	pop    %esi
+    3749:	5d                   	pop    %ebp
+    374a:	c3                   	ret    
+        printf(1, "write(%d) ret %d\n", sz, cc);
+    374b:	89 44 24 0c          	mov    %eax,0xc(%esp)
+    374f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    3753:	c7 44 24 04 31 5c 00 	movl   $0x5c31,0x4(%esp)
+    375a:	00 
+    375b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3762:	e8 99 16 00 00       	call   4e00 <printf>
+        exit();
+    3767:	e8 36 15 00 00       	call   4ca2 <exit>
+      printf(1, "cannot create bigwrite\n");
+    376c:	c7 44 24 04 19 5c 00 	movl   $0x5c19,0x4(%esp)
+    3773:	00 
+    3774:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    377b:	e8 80 16 00 00       	call   4e00 <printf>
+      exit();
+    3780:	e8 1d 15 00 00       	call   4ca2 <exit>
+    3785:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    3789:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00003790 <bigfile>:
+{
+    3790:	55                   	push   %ebp
+    3791:	89 e5                	mov    %esp,%ebp
+    3793:	57                   	push   %edi
+    3794:	56                   	push   %esi
+    3795:	53                   	push   %ebx
+    3796:	83 ec 1c             	sub    $0x1c,%esp
+  printf(1, "bigfile test\n");
+    3799:	c7 44 24 04 50 5c 00 	movl   $0x5c50,0x4(%esp)
+    37a0:	00 
+    37a1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    37a8:	e8 53 16 00 00       	call   4e00 <printf>
+  unlink("bigfile");
+    37ad:	c7 04 24 6c 5c 00 00 	movl   $0x5c6c,(%esp)
+    37b4:	e8 39 15 00 00       	call   4cf2 <unlink>
+  fd = open("bigfile", O_CREATE | O_RDWR);
+    37b9:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    37c0:	00 
+    37c1:	c7 04 24 6c 5c 00 00 	movl   $0x5c6c,(%esp)
+    37c8:	e8 15 15 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    37cd:	85 c0                	test   %eax,%eax
+  fd = open("bigfile", O_CREATE | O_RDWR);
+    37cf:	89 c6                	mov    %eax,%esi
+  if(fd < 0){
+    37d1:	0f 88 7f 01 00 00    	js     3956 <bigfile+0x1c6>
+    37d7:	31 db                	xor    %ebx,%ebx
+    37d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    memset(buf, i, 600);
+    37e0:	c7 44 24 08 58 02 00 	movl   $0x258,0x8(%esp)
+    37e7:	00 
+    37e8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    37ec:	c7 04 24 40 9a 00 00 	movl   $0x9a40,(%esp)
+    37f3:	e8 38 13 00 00       	call   4b30 <memset>
+    if(write(fd, buf, 600) != 600){
+    37f8:	c7 44 24 08 58 02 00 	movl   $0x258,0x8(%esp)
+    37ff:	00 
+    3800:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    3807:	00 
+    3808:	89 34 24             	mov    %esi,(%esp)
+    380b:	e8 b2 14 00 00       	call   4cc2 <write>
+    3810:	3d 58 02 00 00       	cmp    $0x258,%eax
+    3815:	0f 85 09 01 00 00    	jne    3924 <bigfile+0x194>
+  for(i = 0; i < 20; i++){
+    381b:	83 c3 01             	add    $0x1,%ebx
+    381e:	83 fb 14             	cmp    $0x14,%ebx
+    3821:	75 bd                	jne    37e0 <bigfile+0x50>
+  close(fd);
+    3823:	89 34 24             	mov    %esi,(%esp)
+    3826:	e8 9f 14 00 00       	call   4cca <close>
+  fd = open("bigfile", 0);
+    382b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    3832:	00 
+    3833:	c7 04 24 6c 5c 00 00 	movl   $0x5c6c,(%esp)
+    383a:	e8 a3 14 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    383f:	85 c0                	test   %eax,%eax
+  fd = open("bigfile", 0);
+    3841:	89 c6                	mov    %eax,%esi
+  if(fd < 0){
+    3843:	0f 88 f4 00 00 00    	js     393d <bigfile+0x1ad>
+    3849:	31 db                	xor    %ebx,%ebx
+    384b:	31 ff                	xor    %edi,%edi
+    384d:	eb 2f                	jmp    387e <bigfile+0xee>
+    384f:	90                   	nop
+    if(cc != 300){
+    3850:	3d 2c 01 00 00       	cmp    $0x12c,%eax
+    3855:	0f 85 97 00 00 00    	jne    38f2 <bigfile+0x162>
+    if(buf[0] != i/2 || buf[299] != i/2){
+    385b:	0f be 05 40 9a 00 00 	movsbl 0x9a40,%eax
+    3862:	89 fa                	mov    %edi,%edx
+    3864:	d1 fa                	sar    %edx
+    3866:	39 d0                	cmp    %edx,%eax
+    3868:	75 6f                	jne    38d9 <bigfile+0x149>
+    386a:	0f be 15 6b 9b 00 00 	movsbl 0x9b6b,%edx
+    3871:	39 d0                	cmp    %edx,%eax
+    3873:	75 64                	jne    38d9 <bigfile+0x149>
+    total += cc;
+    3875:	81 c3 2c 01 00 00    	add    $0x12c,%ebx
+  for(i = 0; ; i++){
+    387b:	83 c7 01             	add    $0x1,%edi
+    cc = read(fd, buf, 300);
+    387e:	c7 44 24 08 2c 01 00 	movl   $0x12c,0x8(%esp)
+    3885:	00 
+    3886:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    388d:	00 
+    388e:	89 34 24             	mov    %esi,(%esp)
+    3891:	e8 24 14 00 00       	call   4cba <read>
+    if(cc < 0){
+    3896:	85 c0                	test   %eax,%eax
+    3898:	78 71                	js     390b <bigfile+0x17b>
+    if(cc == 0)
+    389a:	75 b4                	jne    3850 <bigfile+0xc0>
+  close(fd);
+    389c:	89 34 24             	mov    %esi,(%esp)
+    389f:	90                   	nop
+    38a0:	e8 25 14 00 00       	call   4cca <close>
+  if(total != 20*600){
+    38a5:	81 fb e0 2e 00 00    	cmp    $0x2ee0,%ebx
+    38ab:	0f 85 be 00 00 00    	jne    396f <bigfile+0x1df>
+  unlink("bigfile");
+    38b1:	c7 04 24 6c 5c 00 00 	movl   $0x5c6c,(%esp)
+    38b8:	e8 35 14 00 00       	call   4cf2 <unlink>
+  printf(1, "bigfile test ok\n");
+    38bd:	c7 44 24 04 fb 5c 00 	movl   $0x5cfb,0x4(%esp)
+    38c4:	00 
+    38c5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    38cc:	e8 2f 15 00 00       	call   4e00 <printf>
+}
+    38d1:	83 c4 1c             	add    $0x1c,%esp
+    38d4:	5b                   	pop    %ebx
+    38d5:	5e                   	pop    %esi
+    38d6:	5f                   	pop    %edi
+    38d7:	5d                   	pop    %ebp
+    38d8:	c3                   	ret    
+      printf(1, "read bigfile wrong data\n");
+    38d9:	c7 44 24 04 c8 5c 00 	movl   $0x5cc8,0x4(%esp)
+    38e0:	00 
+    38e1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    38e8:	e8 13 15 00 00       	call   4e00 <printf>
+      exit();
+    38ed:	e8 b0 13 00 00       	call   4ca2 <exit>
+      printf(1, "short read bigfile\n");
+    38f2:	c7 44 24 04 b4 5c 00 	movl   $0x5cb4,0x4(%esp)
+    38f9:	00 
+    38fa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3901:	e8 fa 14 00 00       	call   4e00 <printf>
+      exit();
+    3906:	e8 97 13 00 00       	call   4ca2 <exit>
+      printf(1, "read bigfile failed\n");
+    390b:	c7 44 24 04 9f 5c 00 	movl   $0x5c9f,0x4(%esp)
+    3912:	00 
+    3913:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    391a:	e8 e1 14 00 00       	call   4e00 <printf>
+      exit();
+    391f:	e8 7e 13 00 00       	call   4ca2 <exit>
+      printf(1, "write bigfile failed\n");
+    3924:	c7 44 24 04 74 5c 00 	movl   $0x5c74,0x4(%esp)
+    392b:	00 
+    392c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3933:	e8 c8 14 00 00       	call   4e00 <printf>
+      exit();
+    3938:	e8 65 13 00 00       	call   4ca2 <exit>
+    printf(1, "cannot open bigfile\n");
+    393d:	c7 44 24 04 8a 5c 00 	movl   $0x5c8a,0x4(%esp)
+    3944:	00 
+    3945:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    394c:	e8 af 14 00 00       	call   4e00 <printf>
+    exit();
+    3951:	e8 4c 13 00 00       	call   4ca2 <exit>
+    printf(1, "cannot create bigfile");
+    3956:	c7 44 24 04 5e 5c 00 	movl   $0x5c5e,0x4(%esp)
+    395d:	00 
+    395e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3965:	e8 96 14 00 00       	call   4e00 <printf>
+    exit();
+    396a:	e8 33 13 00 00       	call   4ca2 <exit>
+    printf(1, "read bigfile wrong total\n");
+    396f:	c7 44 24 04 e1 5c 00 	movl   $0x5ce1,0x4(%esp)
+    3976:	00 
+    3977:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    397e:	e8 7d 14 00 00       	call   4e00 <printf>
+    exit();
+    3983:	e8 1a 13 00 00       	call   4ca2 <exit>
+    3988:	90                   	nop
+    3989:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00003990 <fourteen>:
+{
+    3990:	55                   	push   %ebp
+    3991:	89 e5                	mov    %esp,%ebp
+    3993:	83 ec 18             	sub    $0x18,%esp
+  printf(1, "fourteen test\n");
+    3996:	c7 44 24 04 0c 5d 00 	movl   $0x5d0c,0x4(%esp)
+    399d:	00 
+    399e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    39a5:	e8 56 14 00 00       	call   4e00 <printf>
+  if(mkdir("12345678901234") != 0){
+    39aa:	c7 04 24 47 5d 00 00 	movl   $0x5d47,(%esp)
+    39b1:	e8 54 13 00 00       	call   4d0a <mkdir>
+    39b6:	85 c0                	test   %eax,%eax
+    39b8:	0f 85 92 00 00 00    	jne    3a50 <fourteen+0xc0>
+  if(mkdir("12345678901234/123456789012345") != 0){
+    39be:	c7 04 24 04 65 00 00 	movl   $0x6504,(%esp)
+    39c5:	e8 40 13 00 00       	call   4d0a <mkdir>
+    39ca:	85 c0                	test   %eax,%eax
+    39cc:	0f 85 fb 00 00 00    	jne    3acd <fourteen+0x13d>
+  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+    39d2:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    39d9:	00 
+    39da:	c7 04 24 54 65 00 00 	movl   $0x6554,(%esp)
+    39e1:	e8 fc 12 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    39e6:	85 c0                	test   %eax,%eax
+    39e8:	0f 88 c6 00 00 00    	js     3ab4 <fourteen+0x124>
+  close(fd);
+    39ee:	89 04 24             	mov    %eax,(%esp)
+    39f1:	e8 d4 12 00 00       	call   4cca <close>
+  fd = open("12345678901234/12345678901234/12345678901234", 0);
+    39f6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    39fd:	00 
+    39fe:	c7 04 24 c4 65 00 00 	movl   $0x65c4,(%esp)
+    3a05:	e8 d8 12 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    3a0a:	85 c0                	test   %eax,%eax
+    3a0c:	0f 88 89 00 00 00    	js     3a9b <fourteen+0x10b>
+  close(fd);
+    3a12:	89 04 24             	mov    %eax,(%esp)
+    3a15:	e8 b0 12 00 00       	call   4cca <close>
+  if(mkdir("12345678901234/12345678901234") == 0){
+    3a1a:	c7 04 24 38 5d 00 00 	movl   $0x5d38,(%esp)
+    3a21:	e8 e4 12 00 00       	call   4d0a <mkdir>
+    3a26:	85 c0                	test   %eax,%eax
+    3a28:	74 58                	je     3a82 <fourteen+0xf2>
+  if(mkdir("123456789012345/12345678901234") == 0){
+    3a2a:	c7 04 24 60 66 00 00 	movl   $0x6660,(%esp)
+    3a31:	e8 d4 12 00 00       	call   4d0a <mkdir>
+    3a36:	85 c0                	test   %eax,%eax
+    3a38:	74 2f                	je     3a69 <fourteen+0xd9>
+  printf(1, "fourteen ok\n");
+    3a3a:	c7 44 24 04 56 5d 00 	movl   $0x5d56,0x4(%esp)
+    3a41:	00 
+    3a42:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3a49:	e8 b2 13 00 00       	call   4e00 <printf>
+}
+    3a4e:	c9                   	leave  
+    3a4f:	c3                   	ret    
+    printf(1, "mkdir 12345678901234 failed\n");
+    3a50:	c7 44 24 04 1b 5d 00 	movl   $0x5d1b,0x4(%esp)
+    3a57:	00 
+    3a58:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3a5f:	e8 9c 13 00 00       	call   4e00 <printf>
+    exit();
+    3a64:	e8 39 12 00 00       	call   4ca2 <exit>
+    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+    3a69:	c7 44 24 04 80 66 00 	movl   $0x6680,0x4(%esp)
+    3a70:	00 
+    3a71:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3a78:	e8 83 13 00 00       	call   4e00 <printf>
+    exit();
+    3a7d:	e8 20 12 00 00       	call   4ca2 <exit>
+    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+    3a82:	c7 44 24 04 30 66 00 	movl   $0x6630,0x4(%esp)
+    3a89:	00 
+    3a8a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3a91:	e8 6a 13 00 00       	call   4e00 <printf>
+    exit();
+    3a96:	e8 07 12 00 00       	call   4ca2 <exit>
+    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+    3a9b:	c7 44 24 04 f4 65 00 	movl   $0x65f4,0x4(%esp)
+    3aa2:	00 
+    3aa3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3aaa:	e8 51 13 00 00       	call   4e00 <printf>
+    exit();
+    3aaf:	e8 ee 11 00 00       	call   4ca2 <exit>
+    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+    3ab4:	c7 44 24 04 84 65 00 	movl   $0x6584,0x4(%esp)
+    3abb:	00 
+    3abc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3ac3:	e8 38 13 00 00       	call   4e00 <printf>
+    exit();
+    3ac8:	e8 d5 11 00 00       	call   4ca2 <exit>
+    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+    3acd:	c7 44 24 04 24 65 00 	movl   $0x6524,0x4(%esp)
+    3ad4:	00 
+    3ad5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3adc:	e8 1f 13 00 00       	call   4e00 <printf>
+    exit();
+    3ae1:	e8 bc 11 00 00       	call   4ca2 <exit>
+    3ae6:	8d 76 00             	lea    0x0(%esi),%esi
+    3ae9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00003af0 <rmdot>:
+{
+    3af0:	55                   	push   %ebp
+    3af1:	89 e5                	mov    %esp,%ebp
+    3af3:	83 ec 18             	sub    $0x18,%esp
+  printf(1, "rmdot test\n");
+    3af6:	c7 44 24 04 63 5d 00 	movl   $0x5d63,0x4(%esp)
+    3afd:	00 
+    3afe:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3b05:	e8 f6 12 00 00       	call   4e00 <printf>
+  if(mkdir("dots") != 0){
+    3b0a:	c7 04 24 6f 5d 00 00 	movl   $0x5d6f,(%esp)
+    3b11:	e8 f4 11 00 00       	call   4d0a <mkdir>
+    3b16:	85 c0                	test   %eax,%eax
+    3b18:	0f 85 9a 00 00 00    	jne    3bb8 <rmdot+0xc8>
+  if(chdir("dots") != 0){
+    3b1e:	c7 04 24 6f 5d 00 00 	movl   $0x5d6f,(%esp)
+    3b25:	e8 e8 11 00 00       	call   4d12 <chdir>
+    3b2a:	85 c0                	test   %eax,%eax
+    3b2c:	0f 85 35 01 00 00    	jne    3c67 <rmdot+0x177>
+  if(unlink(".") == 0){
+    3b32:	c7 04 24 1a 5a 00 00 	movl   $0x5a1a,(%esp)
+    3b39:	e8 b4 11 00 00       	call   4cf2 <unlink>
+    3b3e:	85 c0                	test   %eax,%eax
+    3b40:	0f 84 08 01 00 00    	je     3c4e <rmdot+0x15e>
+  if(unlink("..") == 0){
+    3b46:	c7 04 24 19 5a 00 00 	movl   $0x5a19,(%esp)
+    3b4d:	e8 a0 11 00 00       	call   4cf2 <unlink>
+    3b52:	85 c0                	test   %eax,%eax
+    3b54:	0f 84 db 00 00 00    	je     3c35 <rmdot+0x145>
+  if(chdir("/") != 0){
+    3b5a:	c7 04 24 ed 51 00 00 	movl   $0x51ed,(%esp)
+    3b61:	e8 ac 11 00 00       	call   4d12 <chdir>
+    3b66:	85 c0                	test   %eax,%eax
+    3b68:	0f 85 ae 00 00 00    	jne    3c1c <rmdot+0x12c>
+  if(unlink("dots/.") == 0){
+    3b6e:	c7 04 24 b7 5d 00 00 	movl   $0x5db7,(%esp)
+    3b75:	e8 78 11 00 00       	call   4cf2 <unlink>
+    3b7a:	85 c0                	test   %eax,%eax
+    3b7c:	0f 84 81 00 00 00    	je     3c03 <rmdot+0x113>
+  if(unlink("dots/..") == 0){
+    3b82:	c7 04 24 d5 5d 00 00 	movl   $0x5dd5,(%esp)
+    3b89:	e8 64 11 00 00       	call   4cf2 <unlink>
+    3b8e:	85 c0                	test   %eax,%eax
+    3b90:	74 58                	je     3bea <rmdot+0xfa>
+  if(unlink("dots") != 0){
+    3b92:	c7 04 24 6f 5d 00 00 	movl   $0x5d6f,(%esp)
+    3b99:	e8 54 11 00 00       	call   4cf2 <unlink>
+    3b9e:	85 c0                	test   %eax,%eax
+    3ba0:	75 2f                	jne    3bd1 <rmdot+0xe1>
+  printf(1, "rmdot ok\n");
+    3ba2:	c7 44 24 04 0a 5e 00 	movl   $0x5e0a,0x4(%esp)
+    3ba9:	00 
+    3baa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3bb1:	e8 4a 12 00 00       	call   4e00 <printf>
+}
+    3bb6:	c9                   	leave  
+    3bb7:	c3                   	ret    
+    printf(1, "mkdir dots failed\n");
+    3bb8:	c7 44 24 04 74 5d 00 	movl   $0x5d74,0x4(%esp)
+    3bbf:	00 
+    3bc0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3bc7:	e8 34 12 00 00       	call   4e00 <printf>
+    exit();
+    3bcc:	e8 d1 10 00 00       	call   4ca2 <exit>
+    printf(1, "unlink dots failed!\n");
+    3bd1:	c7 44 24 04 f5 5d 00 	movl   $0x5df5,0x4(%esp)
+    3bd8:	00 
+    3bd9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3be0:	e8 1b 12 00 00       	call   4e00 <printf>
+    exit();
+    3be5:	e8 b8 10 00 00       	call   4ca2 <exit>
+    printf(1, "unlink dots/.. worked!\n");
+    3bea:	c7 44 24 04 dd 5d 00 	movl   $0x5ddd,0x4(%esp)
+    3bf1:	00 
+    3bf2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3bf9:	e8 02 12 00 00       	call   4e00 <printf>
+    exit();
+    3bfe:	e8 9f 10 00 00       	call   4ca2 <exit>
+    printf(1, "unlink dots/. worked!\n");
+    3c03:	c7 44 24 04 be 5d 00 	movl   $0x5dbe,0x4(%esp)
+    3c0a:	00 
+    3c0b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3c12:	e8 e9 11 00 00       	call   4e00 <printf>
+    exit();
+    3c17:	e8 86 10 00 00       	call   4ca2 <exit>
+    printf(1, "chdir / failed\n");
+    3c1c:	c7 44 24 04 ef 51 00 	movl   $0x51ef,0x4(%esp)
+    3c23:	00 
+    3c24:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3c2b:	e8 d0 11 00 00       	call   4e00 <printf>
+    exit();
+    3c30:	e8 6d 10 00 00       	call   4ca2 <exit>
+    printf(1, "rm .. worked!\n");
+    3c35:	c7 44 24 04 a8 5d 00 	movl   $0x5da8,0x4(%esp)
+    3c3c:	00 
+    3c3d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3c44:	e8 b7 11 00 00       	call   4e00 <printf>
+    exit();
+    3c49:	e8 54 10 00 00       	call   4ca2 <exit>
+    printf(1, "rm . worked!\n");
+    3c4e:	c7 44 24 04 9a 5d 00 	movl   $0x5d9a,0x4(%esp)
+    3c55:	00 
+    3c56:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3c5d:	e8 9e 11 00 00       	call   4e00 <printf>
+    exit();
+    3c62:	e8 3b 10 00 00       	call   4ca2 <exit>
+    printf(1, "chdir dots failed\n");
+    3c67:	c7 44 24 04 87 5d 00 	movl   $0x5d87,0x4(%esp)
+    3c6e:	00 
+    3c6f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3c76:	e8 85 11 00 00       	call   4e00 <printf>
+    exit();
+    3c7b:	e8 22 10 00 00       	call   4ca2 <exit>
+
+00003c80 <dirfile>:
+{
+    3c80:	55                   	push   %ebp
+    3c81:	89 e5                	mov    %esp,%ebp
+    3c83:	53                   	push   %ebx
+    3c84:	83 ec 14             	sub    $0x14,%esp
+  printf(1, "dir vs file\n");
+    3c87:	c7 44 24 04 14 5e 00 	movl   $0x5e14,0x4(%esp)
+    3c8e:	00 
+    3c8f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3c96:	e8 65 11 00 00       	call   4e00 <printf>
+  fd = open("dirfile", O_CREATE);
+    3c9b:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    3ca2:	00 
+    3ca3:	c7 04 24 21 5e 00 00 	movl   $0x5e21,(%esp)
+    3caa:	e8 33 10 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    3caf:	85 c0                	test   %eax,%eax
+    3cb1:	0f 88 4e 01 00 00    	js     3e05 <dirfile+0x185>
+  close(fd);
+    3cb7:	89 04 24             	mov    %eax,(%esp)
+    3cba:	e8 0b 10 00 00       	call   4cca <close>
+  if(chdir("dirfile") == 0){
+    3cbf:	c7 04 24 21 5e 00 00 	movl   $0x5e21,(%esp)
+    3cc6:	e8 47 10 00 00       	call   4d12 <chdir>
+    3ccb:	85 c0                	test   %eax,%eax
+    3ccd:	0f 84 19 01 00 00    	je     3dec <dirfile+0x16c>
+  fd = open("dirfile/xx", 0);
+    3cd3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    3cda:	00 
+    3cdb:	c7 04 24 5a 5e 00 00 	movl   $0x5e5a,(%esp)
+    3ce2:	e8 fb 0f 00 00       	call   4ce2 <open>
+  if(fd >= 0){
+    3ce7:	85 c0                	test   %eax,%eax
+    3ce9:	0f 89 e4 00 00 00    	jns    3dd3 <dirfile+0x153>
+  fd = open("dirfile/xx", O_CREATE);
+    3cef:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    3cf6:	00 
+    3cf7:	c7 04 24 5a 5e 00 00 	movl   $0x5e5a,(%esp)
+    3cfe:	e8 df 0f 00 00       	call   4ce2 <open>
+  if(fd >= 0){
+    3d03:	85 c0                	test   %eax,%eax
+    3d05:	0f 89 c8 00 00 00    	jns    3dd3 <dirfile+0x153>
+  if(mkdir("dirfile/xx") == 0){
+    3d0b:	c7 04 24 5a 5e 00 00 	movl   $0x5e5a,(%esp)
+    3d12:	e8 f3 0f 00 00       	call   4d0a <mkdir>
+    3d17:	85 c0                	test   %eax,%eax
+    3d19:	0f 84 7c 01 00 00    	je     3e9b <dirfile+0x21b>
+  if(unlink("dirfile/xx") == 0){
+    3d1f:	c7 04 24 5a 5e 00 00 	movl   $0x5e5a,(%esp)
+    3d26:	e8 c7 0f 00 00       	call   4cf2 <unlink>
+    3d2b:	85 c0                	test   %eax,%eax
+    3d2d:	0f 84 4f 01 00 00    	je     3e82 <dirfile+0x202>
+  if(link("README", "dirfile/xx") == 0){
+    3d33:	c7 44 24 04 5a 5e 00 	movl   $0x5e5a,0x4(%esp)
+    3d3a:	00 
+    3d3b:	c7 04 24 be 5e 00 00 	movl   $0x5ebe,(%esp)
+    3d42:	e8 bb 0f 00 00       	call   4d02 <link>
+    3d47:	85 c0                	test   %eax,%eax
+    3d49:	0f 84 1a 01 00 00    	je     3e69 <dirfile+0x1e9>
+  if(unlink("dirfile") != 0){
+    3d4f:	c7 04 24 21 5e 00 00 	movl   $0x5e21,(%esp)
+    3d56:	e8 97 0f 00 00       	call   4cf2 <unlink>
+    3d5b:	85 c0                	test   %eax,%eax
+    3d5d:	0f 85 ed 00 00 00    	jne    3e50 <dirfile+0x1d0>
+  fd = open(".", O_RDWR);
+    3d63:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+    3d6a:	00 
+    3d6b:	c7 04 24 1a 5a 00 00 	movl   $0x5a1a,(%esp)
+    3d72:	e8 6b 0f 00 00       	call   4ce2 <open>
+  if(fd >= 0){
+    3d77:	85 c0                	test   %eax,%eax
+    3d79:	0f 89 b8 00 00 00    	jns    3e37 <dirfile+0x1b7>
+  fd = open(".", 0);
+    3d7f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    3d86:	00 
+    3d87:	c7 04 24 1a 5a 00 00 	movl   $0x5a1a,(%esp)
+    3d8e:	e8 4f 0f 00 00       	call   4ce2 <open>
+  if(write(fd, "x", 1) > 0){
+    3d93:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    3d9a:	00 
+    3d9b:	c7 44 24 04 fd 5a 00 	movl   $0x5afd,0x4(%esp)
+    3da2:	00 
+    3da3:	89 04 24             	mov    %eax,(%esp)
+  fd = open(".", 0);
+    3da6:	89 c3                	mov    %eax,%ebx
+  if(write(fd, "x", 1) > 0){
+    3da8:	e8 15 0f 00 00       	call   4cc2 <write>
+    3dad:	85 c0                	test   %eax,%eax
+    3daf:	7f 6d                	jg     3e1e <dirfile+0x19e>
+  close(fd);
+    3db1:	89 1c 24             	mov    %ebx,(%esp)
+    3db4:	e8 11 0f 00 00       	call   4cca <close>
+  printf(1, "dir vs file OK\n");
+    3db9:	c7 44 24 04 f1 5e 00 	movl   $0x5ef1,0x4(%esp)
+    3dc0:	00 
+    3dc1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3dc8:	e8 33 10 00 00       	call   4e00 <printf>
+}
+    3dcd:	83 c4 14             	add    $0x14,%esp
+    3dd0:	5b                   	pop    %ebx
+    3dd1:	5d                   	pop    %ebp
+    3dd2:	c3                   	ret    
+    printf(1, "create dirfile/xx succeeded!\n");
+    3dd3:	c7 44 24 04 65 5e 00 	movl   $0x5e65,0x4(%esp)
+    3dda:	00 
+    3ddb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3de2:	e8 19 10 00 00       	call   4e00 <printf>
+    exit();
+    3de7:	e8 b6 0e 00 00       	call   4ca2 <exit>
+    printf(1, "chdir dirfile succeeded!\n");
+    3dec:	c7 44 24 04 40 5e 00 	movl   $0x5e40,0x4(%esp)
+    3df3:	00 
+    3df4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3dfb:	e8 00 10 00 00       	call   4e00 <printf>
+    exit();
+    3e00:	e8 9d 0e 00 00       	call   4ca2 <exit>
+    printf(1, "create dirfile failed\n");
+    3e05:	c7 44 24 04 29 5e 00 	movl   $0x5e29,0x4(%esp)
+    3e0c:	00 
+    3e0d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3e14:	e8 e7 0f 00 00       	call   4e00 <printf>
+    exit();
+    3e19:	e8 84 0e 00 00       	call   4ca2 <exit>
+    printf(1, "write . succeeded!\n");
+    3e1e:	c7 44 24 04 dd 5e 00 	movl   $0x5edd,0x4(%esp)
+    3e25:	00 
+    3e26:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3e2d:	e8 ce 0f 00 00       	call   4e00 <printf>
+    exit();
+    3e32:	e8 6b 0e 00 00       	call   4ca2 <exit>
+    printf(1, "open . for writing succeeded!\n");
+    3e37:	c7 44 24 04 d4 66 00 	movl   $0x66d4,0x4(%esp)
+    3e3e:	00 
+    3e3f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3e46:	e8 b5 0f 00 00       	call   4e00 <printf>
+    exit();
+    3e4b:	e8 52 0e 00 00       	call   4ca2 <exit>
+    printf(1, "unlink dirfile failed!\n");
+    3e50:	c7 44 24 04 c5 5e 00 	movl   $0x5ec5,0x4(%esp)
+    3e57:	00 
+    3e58:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3e5f:	e8 9c 0f 00 00       	call   4e00 <printf>
+    exit();
+    3e64:	e8 39 0e 00 00       	call   4ca2 <exit>
+    printf(1, "link to dirfile/xx succeeded!\n");
+    3e69:	c7 44 24 04 b4 66 00 	movl   $0x66b4,0x4(%esp)
+    3e70:	00 
+    3e71:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3e78:	e8 83 0f 00 00       	call   4e00 <printf>
+    exit();
+    3e7d:	e8 20 0e 00 00       	call   4ca2 <exit>
+    printf(1, "unlink dirfile/xx succeeded!\n");
+    3e82:	c7 44 24 04 a0 5e 00 	movl   $0x5ea0,0x4(%esp)
+    3e89:	00 
+    3e8a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3e91:	e8 6a 0f 00 00       	call   4e00 <printf>
+    exit();
+    3e96:	e8 07 0e 00 00       	call   4ca2 <exit>
+    printf(1, "mkdir dirfile/xx succeeded!\n");
+    3e9b:	c7 44 24 04 83 5e 00 	movl   $0x5e83,0x4(%esp)
+    3ea2:	00 
+    3ea3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3eaa:	e8 51 0f 00 00       	call   4e00 <printf>
+    exit();
+    3eaf:	e8 ee 0d 00 00       	call   4ca2 <exit>
+    3eb4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    3eba:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00003ec0 <iref>:
+{
+    3ec0:	55                   	push   %ebp
+    3ec1:	89 e5                	mov    %esp,%ebp
+    3ec3:	53                   	push   %ebx
+  printf(1, "empty file name\n");
+    3ec4:	bb 33 00 00 00       	mov    $0x33,%ebx
+{
+    3ec9:	83 ec 14             	sub    $0x14,%esp
+  printf(1, "empty file name\n");
+    3ecc:	c7 44 24 04 01 5f 00 	movl   $0x5f01,0x4(%esp)
+    3ed3:	00 
+    3ed4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3edb:	e8 20 0f 00 00       	call   4e00 <printf>
+    if(mkdir("irefd") != 0){
+    3ee0:	c7 04 24 12 5f 00 00 	movl   $0x5f12,(%esp)
+    3ee7:	e8 1e 0e 00 00       	call   4d0a <mkdir>
+    3eec:	85 c0                	test   %eax,%eax
+    3eee:	0f 85 af 00 00 00    	jne    3fa3 <iref+0xe3>
+    if(chdir("irefd") != 0){
+    3ef4:	c7 04 24 12 5f 00 00 	movl   $0x5f12,(%esp)
+    3efb:	e8 12 0e 00 00       	call   4d12 <chdir>
+    3f00:	85 c0                	test   %eax,%eax
+    3f02:	0f 85 b4 00 00 00    	jne    3fbc <iref+0xfc>
+    mkdir("");
+    3f08:	c7 04 24 c7 55 00 00 	movl   $0x55c7,(%esp)
+    3f0f:	e8 f6 0d 00 00       	call   4d0a <mkdir>
+    link("README", "");
+    3f14:	c7 44 24 04 c7 55 00 	movl   $0x55c7,0x4(%esp)
+    3f1b:	00 
+    3f1c:	c7 04 24 be 5e 00 00 	movl   $0x5ebe,(%esp)
+    3f23:	e8 da 0d 00 00       	call   4d02 <link>
+    fd = open("", O_CREATE);
+    3f28:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    3f2f:	00 
+    3f30:	c7 04 24 c7 55 00 00 	movl   $0x55c7,(%esp)
+    3f37:	e8 a6 0d 00 00       	call   4ce2 <open>
+    if(fd >= 0)
+    3f3c:	85 c0                	test   %eax,%eax
+    3f3e:	78 08                	js     3f48 <iref+0x88>
+      close(fd);
+    3f40:	89 04 24             	mov    %eax,(%esp)
+    3f43:	e8 82 0d 00 00       	call   4cca <close>
+    fd = open("xx", O_CREATE);
+    3f48:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    3f4f:	00 
+    3f50:	c7 04 24 fc 5a 00 00 	movl   $0x5afc,(%esp)
+    3f57:	e8 86 0d 00 00       	call   4ce2 <open>
+    if(fd >= 0)
+    3f5c:	85 c0                	test   %eax,%eax
+    3f5e:	78 08                	js     3f68 <iref+0xa8>
+      close(fd);
+    3f60:	89 04 24             	mov    %eax,(%esp)
+    3f63:	e8 62 0d 00 00       	call   4cca <close>
+    unlink("xx");
+    3f68:	c7 04 24 fc 5a 00 00 	movl   $0x5afc,(%esp)
+    3f6f:	e8 7e 0d 00 00       	call   4cf2 <unlink>
+  for(i = 0; i < 50 + 1; i++){
+    3f74:	83 eb 01             	sub    $0x1,%ebx
+    3f77:	0f 85 63 ff ff ff    	jne    3ee0 <iref+0x20>
+  chdir("/");
+    3f7d:	c7 04 24 ed 51 00 00 	movl   $0x51ed,(%esp)
+    3f84:	e8 89 0d 00 00       	call   4d12 <chdir>
+  printf(1, "empty file name OK\n");
+    3f89:	c7 44 24 04 40 5f 00 	movl   $0x5f40,0x4(%esp)
+    3f90:	00 
+    3f91:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3f98:	e8 63 0e 00 00       	call   4e00 <printf>
+}
+    3f9d:	83 c4 14             	add    $0x14,%esp
+    3fa0:	5b                   	pop    %ebx
+    3fa1:	5d                   	pop    %ebp
+    3fa2:	c3                   	ret    
+      printf(1, "mkdir irefd failed\n");
+    3fa3:	c7 44 24 04 18 5f 00 	movl   $0x5f18,0x4(%esp)
+    3faa:	00 
+    3fab:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3fb2:	e8 49 0e 00 00       	call   4e00 <printf>
+      exit();
+    3fb7:	e8 e6 0c 00 00       	call   4ca2 <exit>
+      printf(1, "chdir irefd failed\n");
+    3fbc:	c7 44 24 04 2c 5f 00 	movl   $0x5f2c,0x4(%esp)
+    3fc3:	00 
+    3fc4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3fcb:	e8 30 0e 00 00       	call   4e00 <printf>
+      exit();
+    3fd0:	e8 cd 0c 00 00       	call   4ca2 <exit>
+    3fd5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    3fd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00003fe0 <forktest>:
+{
+    3fe0:	55                   	push   %ebp
+    3fe1:	89 e5                	mov    %esp,%ebp
+    3fe3:	53                   	push   %ebx
+  for(n=0; n<1000; n++){
+    3fe4:	31 db                	xor    %ebx,%ebx
+{
+    3fe6:	83 ec 14             	sub    $0x14,%esp
+  printf(1, "fork test\n");
+    3fe9:	c7 44 24 04 54 5f 00 	movl   $0x5f54,0x4(%esp)
+    3ff0:	00 
+    3ff1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    3ff8:	e8 03 0e 00 00       	call   4e00 <printf>
+    3ffd:	eb 13                	jmp    4012 <forktest+0x32>
+    3fff:	90                   	nop
+    if(pid == 0)
+    4000:	0f 84 87 00 00 00    	je     408d <forktest+0xad>
+  for(n=0; n<1000; n++){
+    4006:	83 c3 01             	add    $0x1,%ebx
+    4009:	81 fb e8 03 00 00    	cmp    $0x3e8,%ebx
+    400f:	90                   	nop
+    4010:	74 4e                	je     4060 <forktest+0x80>
+    pid = fork();
+    4012:	e8 83 0c 00 00       	call   4c9a <fork>
+    if(pid < 0)
+    4017:	85 c0                	test   %eax,%eax
+    4019:	79 e5                	jns    4000 <forktest+0x20>
+  for(; n > 0; n--){
+    401b:	85 db                	test   %ebx,%ebx
+    401d:	8d 76 00             	lea    0x0(%esi),%esi
+    4020:	74 15                	je     4037 <forktest+0x57>
+    4022:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(wait() < 0){
+    4028:	e8 7d 0c 00 00       	call   4caa <wait>
+    402d:	85 c0                	test   %eax,%eax
+    402f:	90                   	nop
+    4030:	78 47                	js     4079 <forktest+0x99>
+  for(; n > 0; n--){
+    4032:	83 eb 01             	sub    $0x1,%ebx
+    4035:	75 f1                	jne    4028 <forktest+0x48>
+  if(wait() != -1){
+    4037:	e8 6e 0c 00 00       	call   4caa <wait>
+    403c:	83 f8 ff             	cmp    $0xffffffff,%eax
+    403f:	90                   	nop
+    4040:	75 50                	jne    4092 <forktest+0xb2>
+  printf(1, "fork test OK\n");
+    4042:	c7 44 24 04 86 5f 00 	movl   $0x5f86,0x4(%esp)
+    4049:	00 
+    404a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    4051:	e8 aa 0d 00 00       	call   4e00 <printf>
+}
+    4056:	83 c4 14             	add    $0x14,%esp
+    4059:	5b                   	pop    %ebx
+    405a:	5d                   	pop    %ebp
+    405b:	c3                   	ret    
+    405c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    printf(1, "fork claimed to work 1000 times!\n");
+    4060:	c7 44 24 04 f4 66 00 	movl   $0x66f4,0x4(%esp)
+    4067:	00 
+    4068:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    406f:	e8 8c 0d 00 00       	call   4e00 <printf>
+    exit();
+    4074:	e8 29 0c 00 00       	call   4ca2 <exit>
+      printf(1, "wait stopped early\n");
+    4079:	c7 44 24 04 5f 5f 00 	movl   $0x5f5f,0x4(%esp)
+    4080:	00 
+    4081:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    4088:	e8 73 0d 00 00       	call   4e00 <printf>
+      exit();
+    408d:	e8 10 0c 00 00       	call   4ca2 <exit>
+    printf(1, "wait got too many\n");
+    4092:	c7 44 24 04 73 5f 00 	movl   $0x5f73,0x4(%esp)
+    4099:	00 
+    409a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    40a1:	e8 5a 0d 00 00       	call   4e00 <printf>
+    exit();
+    40a6:	e8 f7 0b 00 00       	call   4ca2 <exit>
+    40ab:	90                   	nop
+    40ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000040b0 <sbrktest>:
+{
+    40b0:	55                   	push   %ebp
+    40b1:	89 e5                	mov    %esp,%ebp
+    40b3:	57                   	push   %edi
+    40b4:	56                   	push   %esi
+  for(i = 0; i < 5000; i++){
+    40b5:	31 f6                	xor    %esi,%esi
+{
+    40b7:	53                   	push   %ebx
+    40b8:	83 ec 6c             	sub    $0x6c,%esp
+  printf(stdout, "sbrk test\n");
+    40bb:	a1 60 72 00 00       	mov    0x7260,%eax
+    40c0:	c7 44 24 04 94 5f 00 	movl   $0x5f94,0x4(%esp)
+    40c7:	00 
+    40c8:	89 04 24             	mov    %eax,(%esp)
+    40cb:	e8 30 0d 00 00       	call   4e00 <printf>
+  oldbrk = sbrk(0);
+    40d0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    40d7:	e8 4e 0c 00 00       	call   4d2a <sbrk>
+  a = sbrk(0);
+    40dc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  oldbrk = sbrk(0);
+    40e3:	89 45 a4             	mov    %eax,-0x5c(%ebp)
+  a = sbrk(0);
+    40e6:	e8 3f 0c 00 00       	call   4d2a <sbrk>
+    40eb:	89 c3                	mov    %eax,%ebx
+    40ed:	8d 76 00             	lea    0x0(%esi),%esi
+    b = sbrk(1);
+    40f0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    40f7:	e8 2e 0c 00 00       	call   4d2a <sbrk>
+    if(b != a){
+    40fc:	39 d8                	cmp    %ebx,%eax
+    b = sbrk(1);
+    40fe:	89 c7                	mov    %eax,%edi
+    if(b != a){
+    4100:	0f 85 78 02 00 00    	jne    437e <sbrktest+0x2ce>
+  for(i = 0; i < 5000; i++){
+    4106:	83 c6 01             	add    $0x1,%esi
+    a = b + 1;
+    4109:	83 c3 01             	add    $0x1,%ebx
+    *b = 1;
+    410c:	c6 43 ff 01          	movb   $0x1,-0x1(%ebx)
+  for(i = 0; i < 5000; i++){
+    4110:	81 fe 88 13 00 00    	cmp    $0x1388,%esi
+    4116:	75 d8                	jne    40f0 <sbrktest+0x40>
+  pid = fork();
+    4118:	e8 7d 0b 00 00       	call   4c9a <fork>
+  if(pid < 0){
+    411d:	85 c0                	test   %eax,%eax
+  pid = fork();
+    411f:	89 c3                	mov    %eax,%ebx
+  if(pid < 0){
+    4121:	0f 88 c5 03 00 00    	js     44ec <sbrktest+0x43c>
+  c = sbrk(1);
+    4127:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    412e:	e8 f7 0b 00 00       	call   4d2a <sbrk>
+  c = sbrk(1);
+    4133:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    413a:	e8 eb 0b 00 00       	call   4d2a <sbrk>
+  if(c != a + 1){
+    413f:	8d 57 02             	lea    0x2(%edi),%edx
+    4142:	39 d0                	cmp    %edx,%eax
+    4144:	0f 85 88 03 00 00    	jne    44d2 <sbrktest+0x422>
+  if(pid == 0)
+    414a:	85 db                	test   %ebx,%ebx
+    414c:	0f 84 7b 03 00 00    	je     44cd <sbrktest+0x41d>
+  wait();
+    4152:	e8 53 0b 00 00       	call   4caa <wait>
+  a = sbrk(0);
+    4157:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    415e:	e8 c7 0b 00 00       	call   4d2a <sbrk>
+  amt = (BIG) - (uint)a;
+    4163:	ba 00 00 40 06       	mov    $0x6400000,%edx
+    4168:	29 c2                	sub    %eax,%edx
+  a = sbrk(0);
+    416a:	89 c3                	mov    %eax,%ebx
+  p = sbrk(amt);
+    416c:	89 14 24             	mov    %edx,(%esp)
+    416f:	e8 b6 0b 00 00       	call   4d2a <sbrk>
+  if (p != a) {
+    4174:	39 d8                	cmp    %ebx,%eax
+    4176:	0f 85 3c 03 00 00    	jne    44b8 <sbrktest+0x408>
+  *lastaddr = 99;
+    417c:	c6 05 ff ff 3f 06 63 	movb   $0x63,0x63fffff
+  a = sbrk(0);
+    4183:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    418a:	e8 9b 0b 00 00       	call   4d2a <sbrk>
+  c = sbrk(-4096);
+    418f:	c7 04 24 00 f0 ff ff 	movl   $0xfffff000,(%esp)
+  a = sbrk(0);
+    4196:	89 c3                	mov    %eax,%ebx
+  c = sbrk(-4096);
+    4198:	e8 8d 0b 00 00       	call   4d2a <sbrk>
+  if(c == (char*)0xffffffff){
+    419d:	83 f8 ff             	cmp    $0xffffffff,%eax
+    41a0:	0f 84 f8 02 00 00    	je     449e <sbrktest+0x3ee>
+  c = sbrk(0);
+    41a6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    41ad:	e8 78 0b 00 00       	call   4d2a <sbrk>
+  if(c != a - 4096){
+    41b2:	8d 93 00 f0 ff ff    	lea    -0x1000(%ebx),%edx
+    41b8:	39 d0                	cmp    %edx,%eax
+    41ba:	0f 85 bc 02 00 00    	jne    447c <sbrktest+0x3cc>
+  a = sbrk(0);
+    41c0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    41c7:	e8 5e 0b 00 00       	call   4d2a <sbrk>
+  c = sbrk(4096);
+    41cc:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
+  a = sbrk(0);
+    41d3:	89 c6                	mov    %eax,%esi
+  c = sbrk(4096);
+    41d5:	e8 50 0b 00 00       	call   4d2a <sbrk>
+  if(c != a || sbrk(0) != a + 4096){
+    41da:	39 f0                	cmp    %esi,%eax
+  c = sbrk(4096);
+    41dc:	89 c3                	mov    %eax,%ebx
+  if(c != a || sbrk(0) != a + 4096){
+    41de:	0f 85 76 02 00 00    	jne    445a <sbrktest+0x3aa>
+    41e4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    41eb:	e8 3a 0b 00 00       	call   4d2a <sbrk>
+    41f0:	8d 93 00 10 00 00    	lea    0x1000(%ebx),%edx
+    41f6:	39 d0                	cmp    %edx,%eax
+    41f8:	0f 85 5c 02 00 00    	jne    445a <sbrktest+0x3aa>
+  if(*lastaddr == 99){
+    41fe:	80 3d ff ff 3f 06 63 	cmpb   $0x63,0x63fffff
+    4205:	0f 84 35 02 00 00    	je     4440 <sbrktest+0x390>
+  a = sbrk(0);
+    420b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    4212:	e8 13 0b 00 00       	call   4d2a <sbrk>
+  c = sbrk(-(sbrk(0) - oldbrk));
+    4217:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  a = sbrk(0);
+    421e:	89 c3                	mov    %eax,%ebx
+  c = sbrk(-(sbrk(0) - oldbrk));
+    4220:	e8 05 0b 00 00       	call   4d2a <sbrk>
+    4225:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
+    4228:	29 c1                	sub    %eax,%ecx
+    422a:	89 0c 24             	mov    %ecx,(%esp)
+    422d:	e8 f8 0a 00 00       	call   4d2a <sbrk>
+  if(c != a){
+    4232:	39 d8                	cmp    %ebx,%eax
+    4234:	0f 85 e4 01 00 00    	jne    441e <sbrktest+0x36e>
+    423a:	bb 00 00 00 80       	mov    $0x80000000,%ebx
+    423f:	90                   	nop
+    ppid = getpid();
+    4240:	e8 dd 0a 00 00       	call   4d22 <getpid>
+    4245:	89 c6                	mov    %eax,%esi
+    pid = fork();
+    4247:	e8 4e 0a 00 00       	call   4c9a <fork>
+    if(pid < 0){
+    424c:	85 c0                	test   %eax,%eax
+    424e:	0f 88 b0 01 00 00    	js     4404 <sbrktest+0x354>
+    if(pid == 0){
+    4254:	0f 84 7d 01 00 00    	je     43d7 <sbrktest+0x327>
+  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+    425a:	81 c3 50 c3 00 00    	add    $0xc350,%ebx
+    wait();
+    4260:	e8 45 0a 00 00       	call   4caa <wait>
+  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+    4265:	81 fb 80 84 1e 80    	cmp    $0x801e8480,%ebx
+    426b:	75 d3                	jne    4240 <sbrktest+0x190>
+  if(pipe(fds) != 0){
+    426d:	8d 45 b8             	lea    -0x48(%ebp),%eax
+    4270:	89 04 24             	mov    %eax,(%esp)
+    4273:	e8 3a 0a 00 00       	call   4cb2 <pipe>
+    4278:	85 c0                	test   %eax,%eax
+    427a:	0f 85 3e 01 00 00    	jne    43be <sbrktest+0x30e>
+    4280:	8d 5d e8             	lea    -0x18(%ebp),%ebx
+    4283:	8d 75 c0             	lea    -0x40(%ebp),%esi
+      read(fds[0], &scratch, 1);
+    4286:	8d 7d b7             	lea    -0x49(%ebp),%edi
+    if((pids[i] = fork()) == 0){
+    4289:	e8 0c 0a 00 00       	call   4c9a <fork>
+    428e:	85 c0                	test   %eax,%eax
+    4290:	89 06                	mov    %eax,(%esi)
+    4292:	0f 84 9f 00 00 00    	je     4337 <sbrktest+0x287>
+    if(pids[i] != -1)
+    4298:	83 f8 ff             	cmp    $0xffffffff,%eax
+    429b:	74 17                	je     42b4 <sbrktest+0x204>
+      read(fds[0], &scratch, 1);
+    429d:	8b 45 b8             	mov    -0x48(%ebp),%eax
+    42a0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    42a7:	00 
+    42a8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    42ac:	89 04 24             	mov    %eax,(%esp)
+    42af:	e8 06 0a 00 00       	call   4cba <read>
+    42b4:	83 c6 04             	add    $0x4,%esi
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    42b7:	39 de                	cmp    %ebx,%esi
+    42b9:	75 ce                	jne    4289 <sbrktest+0x1d9>
+  c = sbrk(4096);
+    42bb:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
+    42c2:	8d 75 c0             	lea    -0x40(%ebp),%esi
+    42c5:	e8 60 0a 00 00       	call   4d2a <sbrk>
+    42ca:	89 c7                	mov    %eax,%edi
+    if(pids[i] == -1)
+    42cc:	8b 06                	mov    (%esi),%eax
+    42ce:	83 f8 ff             	cmp    $0xffffffff,%eax
+    42d1:	74 0d                	je     42e0 <sbrktest+0x230>
+    kill(pids[i]);
+    42d3:	89 04 24             	mov    %eax,(%esp)
+    42d6:	e8 f7 09 00 00       	call   4cd2 <kill>
+    wait();
+    42db:	e8 ca 09 00 00       	call   4caa <wait>
+    42e0:	83 c6 04             	add    $0x4,%esi
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    42e3:	39 f3                	cmp    %esi,%ebx
+    42e5:	75 e5                	jne    42cc <sbrktest+0x21c>
+  if(c == (char*)0xffffffff){
+    42e7:	83 ff ff             	cmp    $0xffffffff,%edi
+    42ea:	0f 84 b4 00 00 00    	je     43a4 <sbrktest+0x2f4>
+  if(sbrk(0) > oldbrk)
+    42f0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    42f7:	e8 2e 0a 00 00       	call   4d2a <sbrk>
+    42fc:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
+    42ff:	73 19                	jae    431a <sbrktest+0x26a>
+    sbrk(-(sbrk(0) - oldbrk));
+    4301:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    4308:	e8 1d 0a 00 00       	call   4d2a <sbrk>
+    430d:	8b 7d a4             	mov    -0x5c(%ebp),%edi
+    4310:	29 c7                	sub    %eax,%edi
+    4312:	89 3c 24             	mov    %edi,(%esp)
+    4315:	e8 10 0a 00 00       	call   4d2a <sbrk>
+  printf(stdout, "sbrk test OK\n");
+    431a:	a1 60 72 00 00       	mov    0x7260,%eax
+    431f:	c7 44 24 04 3c 60 00 	movl   $0x603c,0x4(%esp)
+    4326:	00 
+    4327:	89 04 24             	mov    %eax,(%esp)
+    432a:	e8 d1 0a 00 00       	call   4e00 <printf>
+}
+    432f:	83 c4 6c             	add    $0x6c,%esp
+    4332:	5b                   	pop    %ebx
+    4333:	5e                   	pop    %esi
+    4334:	5f                   	pop    %edi
+    4335:	5d                   	pop    %ebp
+    4336:	c3                   	ret    
+      sbrk(BIG - (uint)sbrk(0));
+    4337:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    433e:	e8 e7 09 00 00       	call   4d2a <sbrk>
+    4343:	ba 00 00 40 06       	mov    $0x6400000,%edx
+    4348:	29 c2                	sub    %eax,%edx
+    434a:	89 14 24             	mov    %edx,(%esp)
+    434d:	e8 d8 09 00 00       	call   4d2a <sbrk>
+      write(fds[1], "x", 1);
+    4352:	8b 45 bc             	mov    -0x44(%ebp),%eax
+    4355:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    435c:	00 
+    435d:	c7 44 24 04 fd 5a 00 	movl   $0x5afd,0x4(%esp)
+    4364:	00 
+    4365:	89 04 24             	mov    %eax,(%esp)
+    4368:	e8 55 09 00 00       	call   4cc2 <write>
+    436d:	8d 76 00             	lea    0x0(%esi),%esi
+      for(;;) sleep(1000);
+    4370:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
+    4377:	e8 b6 09 00 00       	call   4d32 <sleep>
+    437c:	eb f2                	jmp    4370 <sbrktest+0x2c0>
+      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+    437e:	89 44 24 10          	mov    %eax,0x10(%esp)
+    4382:	a1 60 72 00 00       	mov    0x7260,%eax
+    4387:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+    438b:	89 74 24 08          	mov    %esi,0x8(%esp)
+    438f:	c7 44 24 04 9f 5f 00 	movl   $0x5f9f,0x4(%esp)
+    4396:	00 
+    4397:	89 04 24             	mov    %eax,(%esp)
+    439a:	e8 61 0a 00 00       	call   4e00 <printf>
+      exit();
+    439f:	e8 fe 08 00 00       	call   4ca2 <exit>
+    printf(stdout, "failed sbrk leaked memory\n");
+    43a4:	a1 60 72 00 00       	mov    0x7260,%eax
+    43a9:	c7 44 24 04 21 60 00 	movl   $0x6021,0x4(%esp)
+    43b0:	00 
+    43b1:	89 04 24             	mov    %eax,(%esp)
+    43b4:	e8 47 0a 00 00       	call   4e00 <printf>
+    exit();
+    43b9:	e8 e4 08 00 00       	call   4ca2 <exit>
+    printf(1, "pipe() failed\n");
+    43be:	c7 44 24 04 dd 54 00 	movl   $0x54dd,0x4(%esp)
+    43c5:	00 
+    43c6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    43cd:	e8 2e 0a 00 00       	call   4e00 <printf>
+    exit();
+    43d2:	e8 cb 08 00 00       	call   4ca2 <exit>
+      printf(stdout, "oops could read %x = %x\n", a, *a);
+    43d7:	0f be 03             	movsbl (%ebx),%eax
+    43da:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    43de:	c7 44 24 04 08 60 00 	movl   $0x6008,0x4(%esp)
+    43e5:	00 
+    43e6:	89 44 24 0c          	mov    %eax,0xc(%esp)
+    43ea:	a1 60 72 00 00       	mov    0x7260,%eax
+    43ef:	89 04 24             	mov    %eax,(%esp)
+    43f2:	e8 09 0a 00 00       	call   4e00 <printf>
+      kill(ppid);
+    43f7:	89 34 24             	mov    %esi,(%esp)
+    43fa:	e8 d3 08 00 00       	call   4cd2 <kill>
+      exit();
+    43ff:	e8 9e 08 00 00       	call   4ca2 <exit>
+      printf(stdout, "fork failed\n");
+    4404:	a1 60 72 00 00       	mov    0x7260,%eax
+    4409:	c7 44 24 04 e5 60 00 	movl   $0x60e5,0x4(%esp)
+    4410:	00 
+    4411:	89 04 24             	mov    %eax,(%esp)
+    4414:	e8 e7 09 00 00       	call   4e00 <printf>
+      exit();
+    4419:	e8 84 08 00 00       	call   4ca2 <exit>
+    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+    441e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+    4422:	a1 60 72 00 00       	mov    0x7260,%eax
+    4427:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    442b:	c7 44 24 04 e8 67 00 	movl   $0x67e8,0x4(%esp)
+    4432:	00 
+    4433:	89 04 24             	mov    %eax,(%esp)
+    4436:	e8 c5 09 00 00       	call   4e00 <printf>
+    exit();
+    443b:	e8 62 08 00 00       	call   4ca2 <exit>
+    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+    4440:	a1 60 72 00 00       	mov    0x7260,%eax
+    4445:	c7 44 24 04 b8 67 00 	movl   $0x67b8,0x4(%esp)
+    444c:	00 
+    444d:	89 04 24             	mov    %eax,(%esp)
+    4450:	e8 ab 09 00 00       	call   4e00 <printf>
+    exit();
+    4455:	e8 48 08 00 00       	call   4ca2 <exit>
+    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+    445a:	a1 60 72 00 00       	mov    0x7260,%eax
+    445f:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+    4463:	89 74 24 08          	mov    %esi,0x8(%esp)
+    4467:	c7 44 24 04 90 67 00 	movl   $0x6790,0x4(%esp)
+    446e:	00 
+    446f:	89 04 24             	mov    %eax,(%esp)
+    4472:	e8 89 09 00 00       	call   4e00 <printf>
+    exit();
+    4477:	e8 26 08 00 00       	call   4ca2 <exit>
+    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+    447c:	89 44 24 0c          	mov    %eax,0xc(%esp)
+    4480:	a1 60 72 00 00       	mov    0x7260,%eax
+    4485:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    4489:	c7 44 24 04 58 67 00 	movl   $0x6758,0x4(%esp)
+    4490:	00 
+    4491:	89 04 24             	mov    %eax,(%esp)
+    4494:	e8 67 09 00 00       	call   4e00 <printf>
+    exit();
+    4499:	e8 04 08 00 00       	call   4ca2 <exit>
+    printf(stdout, "sbrk could not deallocate\n");
+    449e:	a1 60 72 00 00       	mov    0x7260,%eax
+    44a3:	c7 44 24 04 ed 5f 00 	movl   $0x5fed,0x4(%esp)
+    44aa:	00 
+    44ab:	89 04 24             	mov    %eax,(%esp)
+    44ae:	e8 4d 09 00 00       	call   4e00 <printf>
+    exit();
+    44b3:	e8 ea 07 00 00       	call   4ca2 <exit>
+    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+    44b8:	a1 60 72 00 00       	mov    0x7260,%eax
+    44bd:	c7 44 24 04 18 67 00 	movl   $0x6718,0x4(%esp)
+    44c4:	00 
+    44c5:	89 04 24             	mov    %eax,(%esp)
+    44c8:	e8 33 09 00 00       	call   4e00 <printf>
+    exit();
+    44cd:	e8 d0 07 00 00       	call   4ca2 <exit>
+    printf(stdout, "sbrk test failed post-fork\n");
+    44d2:	a1 60 72 00 00       	mov    0x7260,%eax
+    44d7:	c7 44 24 04 d1 5f 00 	movl   $0x5fd1,0x4(%esp)
+    44de:	00 
+    44df:	89 04 24             	mov    %eax,(%esp)
+    44e2:	e8 19 09 00 00       	call   4e00 <printf>
+    exit();
+    44e7:	e8 b6 07 00 00       	call   4ca2 <exit>
+    printf(stdout, "sbrk test fork failed\n");
+    44ec:	a1 60 72 00 00       	mov    0x7260,%eax
+    44f1:	c7 44 24 04 ba 5f 00 	movl   $0x5fba,0x4(%esp)
+    44f8:	00 
+    44f9:	89 04 24             	mov    %eax,(%esp)
+    44fc:	e8 ff 08 00 00       	call   4e00 <printf>
+    exit();
+    4501:	e8 9c 07 00 00       	call   4ca2 <exit>
+    4506:	8d 76 00             	lea    0x0(%esi),%esi
+    4509:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00004510 <validateint>:
+{
+    4510:	55                   	push   %ebp
+    4511:	89 e5                	mov    %esp,%ebp
+}
+    4513:	5d                   	pop    %ebp
+    4514:	c3                   	ret    
+    4515:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    4519:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00004520 <validatetest>:
+{
+    4520:	55                   	push   %ebp
+    4521:	89 e5                	mov    %esp,%ebp
+    4523:	56                   	push   %esi
+    4524:	53                   	push   %ebx
+  for(p = 0; p <= (uint)hi; p += 4096){
+    4525:	31 db                	xor    %ebx,%ebx
+{
+    4527:	83 ec 10             	sub    $0x10,%esp
+  printf(stdout, "validate test\n");
+    452a:	a1 60 72 00 00       	mov    0x7260,%eax
+    452f:	c7 44 24 04 4a 60 00 	movl   $0x604a,0x4(%esp)
+    4536:	00 
+    4537:	89 04 24             	mov    %eax,(%esp)
+    453a:	e8 c1 08 00 00       	call   4e00 <printf>
+    453f:	90                   	nop
+    if((pid = fork()) == 0){
+    4540:	e8 55 07 00 00       	call   4c9a <fork>
+    4545:	85 c0                	test   %eax,%eax
+    4547:	89 c6                	mov    %eax,%esi
+    4549:	74 79                	je     45c4 <validatetest+0xa4>
+    sleep(0);
+    454b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    4552:	e8 db 07 00 00       	call   4d32 <sleep>
+    sleep(0);
+    4557:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    455e:	e8 cf 07 00 00       	call   4d32 <sleep>
+    kill(pid);
+    4563:	89 34 24             	mov    %esi,(%esp)
+    4566:	e8 67 07 00 00       	call   4cd2 <kill>
+    wait();
+    456b:	e8 3a 07 00 00       	call   4caa <wait>
+    if(link("nosuchfile", (char*)p) != -1){
+    4570:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    4574:	c7 04 24 59 60 00 00 	movl   $0x6059,(%esp)
+    457b:	e8 82 07 00 00       	call   4d02 <link>
+    4580:	83 f8 ff             	cmp    $0xffffffff,%eax
+    4583:	75 2a                	jne    45af <validatetest+0x8f>
+  for(p = 0; p <= (uint)hi; p += 4096){
+    4585:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+    458b:	81 fb 00 40 11 00    	cmp    $0x114000,%ebx
+    4591:	75 ad                	jne    4540 <validatetest+0x20>
+  printf(stdout, "validate ok\n");
+    4593:	a1 60 72 00 00       	mov    0x7260,%eax
+    4598:	c7 44 24 04 7d 60 00 	movl   $0x607d,0x4(%esp)
+    459f:	00 
+    45a0:	89 04 24             	mov    %eax,(%esp)
+    45a3:	e8 58 08 00 00       	call   4e00 <printf>
+}
+    45a8:	83 c4 10             	add    $0x10,%esp
+    45ab:	5b                   	pop    %ebx
+    45ac:	5e                   	pop    %esi
+    45ad:	5d                   	pop    %ebp
+    45ae:	c3                   	ret    
+      printf(stdout, "link should not succeed\n");
+    45af:	a1 60 72 00 00       	mov    0x7260,%eax
+    45b4:	c7 44 24 04 64 60 00 	movl   $0x6064,0x4(%esp)
+    45bb:	00 
+    45bc:	89 04 24             	mov    %eax,(%esp)
+    45bf:	e8 3c 08 00 00       	call   4e00 <printf>
+      exit();
+    45c4:	e8 d9 06 00 00       	call   4ca2 <exit>
+    45c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000045d0 <bsstest>:
+{
+    45d0:	55                   	push   %ebp
+    45d1:	89 e5                	mov    %esp,%ebp
+    45d3:	83 ec 18             	sub    $0x18,%esp
+  printf(stdout, "bss test\n");
+    45d6:	a1 60 72 00 00       	mov    0x7260,%eax
+    45db:	c7 44 24 04 8a 60 00 	movl   $0x608a,0x4(%esp)
+    45e2:	00 
+    45e3:	89 04 24             	mov    %eax,(%esp)
+    45e6:	e8 15 08 00 00       	call   4e00 <printf>
+    if(uninit[i] != '\0'){
+    45eb:	80 3d 20 73 00 00 00 	cmpb   $0x0,0x7320
+    45f2:	75 36                	jne    462a <bsstest+0x5a>
+  for(i = 0; i < sizeof(uninit); i++){
+    45f4:	b8 01 00 00 00       	mov    $0x1,%eax
+    45f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    if(uninit[i] != '\0'){
+    4600:	80 b8 20 73 00 00 00 	cmpb   $0x0,0x7320(%eax)
+    4607:	75 21                	jne    462a <bsstest+0x5a>
+  for(i = 0; i < sizeof(uninit); i++){
+    4609:	83 c0 01             	add    $0x1,%eax
+    460c:	3d 10 27 00 00       	cmp    $0x2710,%eax
+    4611:	75 ed                	jne    4600 <bsstest+0x30>
+  printf(stdout, "bss test ok\n");
+    4613:	a1 60 72 00 00       	mov    0x7260,%eax
+    4618:	c7 44 24 04 a5 60 00 	movl   $0x60a5,0x4(%esp)
+    461f:	00 
+    4620:	89 04 24             	mov    %eax,(%esp)
+    4623:	e8 d8 07 00 00       	call   4e00 <printf>
+}
+    4628:	c9                   	leave  
+    4629:	c3                   	ret    
+      printf(stdout, "bss test failed\n");
+    462a:	a1 60 72 00 00       	mov    0x7260,%eax
+    462f:	c7 44 24 04 94 60 00 	movl   $0x6094,0x4(%esp)
+    4636:	00 
+    4637:	89 04 24             	mov    %eax,(%esp)
+    463a:	e8 c1 07 00 00       	call   4e00 <printf>
+      exit();
+    463f:	e8 5e 06 00 00       	call   4ca2 <exit>
+    4644:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    464a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00004650 <bigargtest>:
+{
+    4650:	55                   	push   %ebp
+    4651:	89 e5                	mov    %esp,%ebp
+    4653:	83 ec 18             	sub    $0x18,%esp
+  unlink("bigarg-ok");
+    4656:	c7 04 24 b2 60 00 00 	movl   $0x60b2,(%esp)
+    465d:	e8 90 06 00 00       	call   4cf2 <unlink>
+  pid = fork();
+    4662:	e8 33 06 00 00       	call   4c9a <fork>
+  if(pid == 0){
+    4667:	85 c0                	test   %eax,%eax
+    4669:	74 45                	je     46b0 <bigargtest+0x60>
+    466b:	90                   	nop
+    466c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  } else if(pid < 0){
+    4670:	0f 88 d0 00 00 00    	js     4746 <bigargtest+0xf6>
+  wait();
+    4676:	e8 2f 06 00 00       	call   4caa <wait>
+  fd = open("bigarg-ok", 0);
+    467b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    4682:	00 
+    4683:	c7 04 24 b2 60 00 00 	movl   $0x60b2,(%esp)
+    468a:	e8 53 06 00 00       	call   4ce2 <open>
+  if(fd < 0){
+    468f:	85 c0                	test   %eax,%eax
+    4691:	0f 88 95 00 00 00    	js     472c <bigargtest+0xdc>
+  close(fd);
+    4697:	89 04 24             	mov    %eax,(%esp)
+    469a:	e8 2b 06 00 00       	call   4cca <close>
+  unlink("bigarg-ok");
+    469f:	c7 04 24 b2 60 00 00 	movl   $0x60b2,(%esp)
+    46a6:	e8 47 06 00 00       	call   4cf2 <unlink>
+}
+    46ab:	c9                   	leave  
+    46ac:	c3                   	ret    
+    46ad:	8d 76 00             	lea    0x0(%esi),%esi
+      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
+    46b0:	c7 04 85 80 72 00 00 	movl   $0x680c,0x7280(,%eax,4)
+    46b7:	0c 68 00 00 
+    for(i = 0; i < MAXARG-1; i++)
+    46bb:	83 c0 01             	add    $0x1,%eax
+    46be:	83 f8 1f             	cmp    $0x1f,%eax
+    46c1:	75 ed                	jne    46b0 <bigargtest+0x60>
+    printf(stdout, "bigarg test\n");
+    46c3:	a1 60 72 00 00       	mov    0x7260,%eax
+    46c8:	c7 44 24 04 bc 60 00 	movl   $0x60bc,0x4(%esp)
+    46cf:	00 
+    args[MAXARG-1] = 0;
+    46d0:	c7 05 fc 72 00 00 00 	movl   $0x0,0x72fc
+    46d7:	00 00 00 
+    printf(stdout, "bigarg test\n");
+    46da:	89 04 24             	mov    %eax,(%esp)
+    46dd:	e8 1e 07 00 00       	call   4e00 <printf>
+    exec("echo", args);
+    46e2:	c7 44 24 04 80 72 00 	movl   $0x7280,0x4(%esp)
+    46e9:	00 
+    46ea:	c7 04 24 89 52 00 00 	movl   $0x5289,(%esp)
+    46f1:	e8 e4 05 00 00       	call   4cda <exec>
+    printf(stdout, "bigarg test ok\n");
+    46f6:	a1 60 72 00 00       	mov    0x7260,%eax
+    46fb:	c7 44 24 04 c9 60 00 	movl   $0x60c9,0x4(%esp)
+    4702:	00 
+    4703:	89 04 24             	mov    %eax,(%esp)
+    4706:	e8 f5 06 00 00       	call   4e00 <printf>
+    fd = open("bigarg-ok", O_CREATE);
+    470b:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+    4712:	00 
+    4713:	c7 04 24 b2 60 00 00 	movl   $0x60b2,(%esp)
+    471a:	e8 c3 05 00 00       	call   4ce2 <open>
+    close(fd);
+    471f:	89 04 24             	mov    %eax,(%esp)
+    4722:	e8 a3 05 00 00       	call   4cca <close>
+    exit();
+    4727:	e8 76 05 00 00       	call   4ca2 <exit>
+    printf(stdout, "bigarg test failed!\n");
+    472c:	a1 60 72 00 00       	mov    0x7260,%eax
+    4731:	c7 44 24 04 f2 60 00 	movl   $0x60f2,0x4(%esp)
+    4738:	00 
+    4739:	89 04 24             	mov    %eax,(%esp)
+    473c:	e8 bf 06 00 00       	call   4e00 <printf>
+    exit();
+    4741:	e8 5c 05 00 00       	call   4ca2 <exit>
+    printf(stdout, "bigargtest: fork failed\n");
+    4746:	a1 60 72 00 00       	mov    0x7260,%eax
+    474b:	c7 44 24 04 d9 60 00 	movl   $0x60d9,0x4(%esp)
+    4752:	00 
+    4753:	89 04 24             	mov    %eax,(%esp)
+    4756:	e8 a5 06 00 00       	call   4e00 <printf>
+    exit();
+    475b:	e8 42 05 00 00       	call   4ca2 <exit>
+
+00004760 <fsfull>:
+{
+    4760:	55                   	push   %ebp
+    4761:	89 e5                	mov    %esp,%ebp
+    4763:	57                   	push   %edi
+    4764:	56                   	push   %esi
+    4765:	53                   	push   %ebx
+  for(nfiles = 0; ; nfiles++){
+    4766:	31 db                	xor    %ebx,%ebx
+{
+    4768:	83 ec 5c             	sub    $0x5c,%esp
+  printf(1, "fsfull test\n");
+    476b:	c7 44 24 04 07 61 00 	movl   $0x6107,0x4(%esp)
+    4772:	00 
+    4773:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    477a:	e8 81 06 00 00       	call   4e00 <printf>
+    477f:	90                   	nop
+    name[1] = '0' + nfiles / 1000;
+    4780:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
+    4785:	89 d9                	mov    %ebx,%ecx
+    4787:	f7 eb                	imul   %ebx
+    name[2] = '0' + (nfiles % 1000) / 100;
+    4789:	89 de                	mov    %ebx,%esi
+    name[1] = '0' + nfiles / 1000;
+    478b:	c1 f9 1f             	sar    $0x1f,%ecx
+    name[3] = '0' + (nfiles % 100) / 10;
+    478e:	89 df                	mov    %ebx,%edi
+    printf(1, "writing %s\n", name);
+    4790:	c7 44 24 04 14 61 00 	movl   $0x6114,0x4(%esp)
+    4797:	00 
+    4798:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    name[1] = '0' + nfiles / 1000;
+    479f:	c1 fa 06             	sar    $0x6,%edx
+    47a2:	29 ca                	sub    %ecx,%edx
+    47a4:	8d 42 30             	lea    0x30(%edx),%eax
+    name[2] = '0' + (nfiles % 1000) / 100;
+    47a7:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
+    name[1] = '0' + nfiles / 1000;
+    47ad:	88 45 a9             	mov    %al,-0x57(%ebp)
+    name[2] = '0' + (nfiles % 1000) / 100;
+    47b0:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
+    name[0] = 'f';
+    47b5:	c6 45 a8 66          	movb   $0x66,-0x58(%ebp)
+    name[5] = '\0';
+    47b9:	c6 45 ad 00          	movb   $0x0,-0x53(%ebp)
+    name[2] = '0' + (nfiles % 1000) / 100;
+    47bd:	29 d6                	sub    %edx,%esi
+    47bf:	f7 ee                	imul   %esi
+    name[3] = '0' + (nfiles % 100) / 10;
+    47c1:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
+    name[2] = '0' + (nfiles % 1000) / 100;
+    47c6:	c1 fe 1f             	sar    $0x1f,%esi
+    47c9:	c1 fa 05             	sar    $0x5,%edx
+    47cc:	29 f2                	sub    %esi,%edx
+    name[3] = '0' + (nfiles % 100) / 10;
+    47ce:	be 67 66 66 66       	mov    $0x66666667,%esi
+    name[2] = '0' + (nfiles % 1000) / 100;
+    47d3:	83 c2 30             	add    $0x30,%edx
+    47d6:	88 55 aa             	mov    %dl,-0x56(%ebp)
+    name[3] = '0' + (nfiles % 100) / 10;
+    47d9:	f7 eb                	imul   %ebx
+    47db:	c1 fa 05             	sar    $0x5,%edx
+    47de:	29 ca                	sub    %ecx,%edx
+    47e0:	6b d2 64             	imul   $0x64,%edx,%edx
+    47e3:	29 d7                	sub    %edx,%edi
+    47e5:	89 f8                	mov    %edi,%eax
+    47e7:	f7 ee                	imul   %esi
+    name[4] = '0' + (nfiles % 10);
+    47e9:	89 d8                	mov    %ebx,%eax
+    name[3] = '0' + (nfiles % 100) / 10;
+    47eb:	c1 ff 1f             	sar    $0x1f,%edi
+    47ee:	c1 fa 02             	sar    $0x2,%edx
+    47f1:	29 fa                	sub    %edi,%edx
+    47f3:	83 c2 30             	add    $0x30,%edx
+    47f6:	88 55 ab             	mov    %dl,-0x55(%ebp)
+    name[4] = '0' + (nfiles % 10);
+    47f9:	f7 ee                	imul   %esi
+    47fb:	c1 fa 02             	sar    $0x2,%edx
+    47fe:	29 ca                	sub    %ecx,%edx
+    4800:	89 d9                	mov    %ebx,%ecx
+    4802:	8d 04 92             	lea    (%edx,%edx,4),%eax
+    4805:	01 c0                	add    %eax,%eax
+    4807:	29 c1                	sub    %eax,%ecx
+    4809:	89 c8                	mov    %ecx,%eax
+    480b:	83 c0 30             	add    $0x30,%eax
+    480e:	88 45 ac             	mov    %al,-0x54(%ebp)
+    printf(1, "writing %s\n", name);
+    4811:	8d 45 a8             	lea    -0x58(%ebp),%eax
+    4814:	89 44 24 08          	mov    %eax,0x8(%esp)
+    4818:	e8 e3 05 00 00       	call   4e00 <printf>
+    int fd = open(name, O_CREATE|O_RDWR);
+    481d:	8d 45 a8             	lea    -0x58(%ebp),%eax
+    4820:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+    4827:	00 
+    4828:	89 04 24             	mov    %eax,(%esp)
+    482b:	e8 b2 04 00 00       	call   4ce2 <open>
+    if(fd < 0){
+    4830:	85 c0                	test   %eax,%eax
+    int fd = open(name, O_CREATE|O_RDWR);
+    4832:	89 c7                	mov    %eax,%edi
+    if(fd < 0){
+    4834:	78 57                	js     488d <fsfull+0x12d>
+    4836:	31 f6                	xor    %esi,%esi
+    4838:	eb 08                	jmp    4842 <fsfull+0xe2>
+    483a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      total += cc;
+    4840:	01 c6                	add    %eax,%esi
+      int cc = write(fd, buf, 512);
+    4842:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+    4849:	00 
+    484a:	c7 44 24 04 40 9a 00 	movl   $0x9a40,0x4(%esp)
+    4851:	00 
+    4852:	89 3c 24             	mov    %edi,(%esp)
+    4855:	e8 68 04 00 00       	call   4cc2 <write>
+      if(cc < 512)
+    485a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
+    485f:	7f df                	jg     4840 <fsfull+0xe0>
+    printf(1, "wrote %d bytes\n", total);
+    4861:	89 74 24 08          	mov    %esi,0x8(%esp)
+    4865:	c7 44 24 04 30 61 00 	movl   $0x6130,0x4(%esp)
+    486c:	00 
+    486d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    4874:	e8 87 05 00 00       	call   4e00 <printf>
+    close(fd);
+    4879:	89 3c 24             	mov    %edi,(%esp)
+    487c:	e8 49 04 00 00       	call   4cca <close>
+    if(total == 0)
+    4881:	85 f6                	test   %esi,%esi
+    4883:	74 23                	je     48a8 <fsfull+0x148>
+  for(nfiles = 0; ; nfiles++){
+    4885:	83 c3 01             	add    $0x1,%ebx
+  }
+    4888:	e9 f3 fe ff ff       	jmp    4780 <fsfull+0x20>
+      printf(1, "open %s failed\n", name);
+    488d:	8d 45 a8             	lea    -0x58(%ebp),%eax
+    4890:	89 44 24 08          	mov    %eax,0x8(%esp)
+    4894:	c7 44 24 04 20 61 00 	movl   $0x6120,0x4(%esp)
+    489b:	00 
+    489c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    48a3:	e8 58 05 00 00       	call   4e00 <printf>
+    name[1] = '0' + nfiles / 1000;
+    48a8:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
+    48ad:	89 d9                	mov    %ebx,%ecx
+    48af:	f7 eb                	imul   %ebx
+    name[2] = '0' + (nfiles % 1000) / 100;
+    48b1:	89 de                	mov    %ebx,%esi
+    name[1] = '0' + nfiles / 1000;
+    48b3:	c1 f9 1f             	sar    $0x1f,%ecx
+    name[3] = '0' + (nfiles % 100) / 10;
+    48b6:	89 df                	mov    %ebx,%edi
+    name[0] = 'f';
+    48b8:	c6 45 a8 66          	movb   $0x66,-0x58(%ebp)
+    name[5] = '\0';
+    48bc:	c6 45 ad 00          	movb   $0x0,-0x53(%ebp)
+    name[1] = '0' + nfiles / 1000;
+    48c0:	c1 fa 06             	sar    $0x6,%edx
+    48c3:	29 ca                	sub    %ecx,%edx
+    48c5:	8d 42 30             	lea    0x30(%edx),%eax
+    name[2] = '0' + (nfiles % 1000) / 100;
+    48c8:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
+    name[1] = '0' + nfiles / 1000;
+    48ce:	88 45 a9             	mov    %al,-0x57(%ebp)
+    name[2] = '0' + (nfiles % 1000) / 100;
+    48d1:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
+    48d6:	29 d6                	sub    %edx,%esi
+    48d8:	f7 ee                	imul   %esi
+    name[3] = '0' + (nfiles % 100) / 10;
+    48da:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
+    name[2] = '0' + (nfiles % 1000) / 100;
+    48df:	c1 fe 1f             	sar    $0x1f,%esi
+    48e2:	c1 fa 05             	sar    $0x5,%edx
+    48e5:	29 f2                	sub    %esi,%edx
+    name[3] = '0' + (nfiles % 100) / 10;
+    48e7:	be 67 66 66 66       	mov    $0x66666667,%esi
+    name[2] = '0' + (nfiles % 1000) / 100;
+    48ec:	83 c2 30             	add    $0x30,%edx
+    48ef:	88 55 aa             	mov    %dl,-0x56(%ebp)
+    name[3] = '0' + (nfiles % 100) / 10;
+    48f2:	f7 eb                	imul   %ebx
+    48f4:	c1 fa 05             	sar    $0x5,%edx
+    48f7:	29 ca                	sub    %ecx,%edx
+    48f9:	6b d2 64             	imul   $0x64,%edx,%edx
+    48fc:	29 d7                	sub    %edx,%edi
+    48fe:	89 f8                	mov    %edi,%eax
+    4900:	f7 ee                	imul   %esi
+    name[4] = '0' + (nfiles % 10);
+    4902:	89 d8                	mov    %ebx,%eax
+    name[3] = '0' + (nfiles % 100) / 10;
+    4904:	c1 ff 1f             	sar    $0x1f,%edi
+    4907:	c1 fa 02             	sar    $0x2,%edx
+    490a:	29 fa                	sub    %edi,%edx
+    490c:	83 c2 30             	add    $0x30,%edx
+    490f:	88 55 ab             	mov    %dl,-0x55(%ebp)
+    name[4] = '0' + (nfiles % 10);
+    4912:	f7 ee                	imul   %esi
+    4914:	c1 fa 02             	sar    $0x2,%edx
+    4917:	29 ca                	sub    %ecx,%edx
+    4919:	89 d9                	mov    %ebx,%ecx
+    491b:	8d 04 92             	lea    (%edx,%edx,4),%eax
+    nfiles--;
+    491e:	83 eb 01             	sub    $0x1,%ebx
+    name[4] = '0' + (nfiles % 10);
+    4921:	01 c0                	add    %eax,%eax
+    4923:	29 c1                	sub    %eax,%ecx
+    4925:	89 c8                	mov    %ecx,%eax
+    4927:	83 c0 30             	add    $0x30,%eax
+    492a:	88 45 ac             	mov    %al,-0x54(%ebp)
+    unlink(name);
+    492d:	8d 45 a8             	lea    -0x58(%ebp),%eax
+    4930:	89 04 24             	mov    %eax,(%esp)
+    4933:	e8 ba 03 00 00       	call   4cf2 <unlink>
+  while(nfiles >= 0){
+    4938:	83 fb ff             	cmp    $0xffffffff,%ebx
+    493b:	0f 85 67 ff ff ff    	jne    48a8 <fsfull+0x148>
+  printf(1, "fsfull test finished\n");
+    4941:	c7 44 24 04 40 61 00 	movl   $0x6140,0x4(%esp)
+    4948:	00 
+    4949:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    4950:	e8 ab 04 00 00       	call   4e00 <printf>
+}
+    4955:	83 c4 5c             	add    $0x5c,%esp
+    4958:	5b                   	pop    %ebx
+    4959:	5e                   	pop    %esi
+    495a:	5f                   	pop    %edi
+    495b:	5d                   	pop    %ebp
+    495c:	c3                   	ret    
+    495d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00004960 <uio>:
+{
+    4960:	55                   	push   %ebp
+    4961:	89 e5                	mov    %esp,%ebp
+    4963:	83 ec 18             	sub    $0x18,%esp
+  printf(1, "uio test\n");
+    4966:	c7 44 24 04 56 61 00 	movl   $0x6156,0x4(%esp)
+    496d:	00 
+    496e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    4975:	e8 86 04 00 00       	call   4e00 <printf>
+  pid = fork();
+    497a:	e8 1b 03 00 00       	call   4c9a <fork>
+  if(pid == 0){
+    497f:	85 c0                	test   %eax,%eax
+    4981:	74 1d                	je     49a0 <uio+0x40>
+  } else if(pid < 0){
+    4983:	78 42                	js     49c7 <uio+0x67>
+  wait();
+    4985:	e8 20 03 00 00       	call   4caa <wait>
+  printf(1, "uio test done\n");
+    498a:	c7 44 24 04 60 61 00 	movl   $0x6160,0x4(%esp)
+    4991:	00 
+    4992:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    4999:	e8 62 04 00 00       	call   4e00 <printf>
+}
+    499e:	c9                   	leave  
+    499f:	c3                   	ret    
+    asm volatile("outb %0,%1"::"a"(val), "d" (port));
+    49a0:	ba 70 00 00 00       	mov    $0x70,%edx
+    49a5:	b8 09 00 00 00       	mov    $0x9,%eax
+    49aa:	ee                   	out    %al,(%dx)
+    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+    49ab:	b2 71                	mov    $0x71,%dl
+    49ad:	ec                   	in     (%dx),%al
+    printf(1, "uio: uio succeeded; test FAILED\n");
+    49ae:	c7 44 24 04 ec 68 00 	movl   $0x68ec,0x4(%esp)
+    49b5:	00 
+    49b6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    49bd:	e8 3e 04 00 00       	call   4e00 <printf>
+    exit();
+    49c2:	e8 db 02 00 00       	call   4ca2 <exit>
+    printf (1, "fork failed\n");
+    49c7:	c7 44 24 04 e5 60 00 	movl   $0x60e5,0x4(%esp)
+    49ce:	00 
+    49cf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    49d6:	e8 25 04 00 00       	call   4e00 <printf>
+    exit();
+    49db:	e8 c2 02 00 00       	call   4ca2 <exit>
+
+000049e0 <argptest>:
+{
+    49e0:	55                   	push   %ebp
+    49e1:	89 e5                	mov    %esp,%ebp
+    49e3:	53                   	push   %ebx
+    49e4:	83 ec 14             	sub    $0x14,%esp
+  fd = open("init", O_RDONLY);
+    49e7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    49ee:	00 
+    49ef:	c7 04 24 6f 61 00 00 	movl   $0x616f,(%esp)
+    49f6:	e8 e7 02 00 00       	call   4ce2 <open>
+  if (fd < 0) {
+    49fb:	85 c0                	test   %eax,%eax
+  fd = open("init", O_RDONLY);
+    49fd:	89 c3                	mov    %eax,%ebx
+  if (fd < 0) {
+    49ff:	78 45                	js     4a46 <argptest+0x66>
+  read(fd, sbrk(0) - 1, -1);
+    4a01:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    4a08:	e8 1d 03 00 00       	call   4d2a <sbrk>
+    4a0d:	89 1c 24             	mov    %ebx,(%esp)
+    4a10:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
+    4a17:	ff 
+    4a18:	83 e8 01             	sub    $0x1,%eax
+    4a1b:	89 44 24 04          	mov    %eax,0x4(%esp)
+    4a1f:	e8 96 02 00 00       	call   4cba <read>
+  close(fd);
+    4a24:	89 1c 24             	mov    %ebx,(%esp)
+    4a27:	e8 9e 02 00 00       	call   4cca <close>
+  printf(1, "arg test passed\n");
+    4a2c:	c7 44 24 04 81 61 00 	movl   $0x6181,0x4(%esp)
+    4a33:	00 
+    4a34:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    4a3b:	e8 c0 03 00 00       	call   4e00 <printf>
+}
+    4a40:	83 c4 14             	add    $0x14,%esp
+    4a43:	5b                   	pop    %ebx
+    4a44:	5d                   	pop    %ebp
+    4a45:	c3                   	ret    
+    printf(2, "open failed\n");
+    4a46:	c7 44 24 04 74 61 00 	movl   $0x6174,0x4(%esp)
+    4a4d:	00 
+    4a4e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+    4a55:	e8 a6 03 00 00       	call   4e00 <printf>
+    exit();
+    4a5a:	e8 43 02 00 00       	call   4ca2 <exit>
+    4a5f:	90                   	nop
+
+00004a60 <rand>:
+  randstate = randstate * 1664525 + 1013904223;
+    4a60:	69 05 5c 72 00 00 0d 	imul   $0x19660d,0x725c,%eax
+    4a67:	66 19 00 
+{
+    4a6a:	55                   	push   %ebp
+    4a6b:	89 e5                	mov    %esp,%ebp
+}
+    4a6d:	5d                   	pop    %ebp
+  randstate = randstate * 1664525 + 1013904223;
+    4a6e:	05 5f f3 6e 3c       	add    $0x3c6ef35f,%eax
+    4a73:	a3 5c 72 00 00       	mov    %eax,0x725c
+}
+    4a78:	c3                   	ret    
+    4a79:	66 90                	xchg   %ax,%ax
+    4a7b:	66 90                	xchg   %ax,%ax
+    4a7d:	66 90                	xchg   %ax,%ax
+    4a7f:	90                   	nop
+
+00004a80 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    4a80:	55                   	push   %ebp
+    4a81:	89 e5                	mov    %esp,%ebp
+    4a83:	8b 45 08             	mov    0x8(%ebp),%eax
+    4a86:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    4a89:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    4a8a:	89 c2                	mov    %eax,%edx
+    4a8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    4a90:	83 c1 01             	add    $0x1,%ecx
+    4a93:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    4a97:	83 c2 01             	add    $0x1,%edx
+    4a9a:	84 db                	test   %bl,%bl
+    4a9c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    4a9f:	75 ef                	jne    4a90 <strcpy+0x10>
+    ;
+  return os;
+}
+    4aa1:	5b                   	pop    %ebx
+    4aa2:	5d                   	pop    %ebp
+    4aa3:	c3                   	ret    
+    4aa4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    4aaa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00004ab0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    4ab0:	55                   	push   %ebp
+    4ab1:	89 e5                	mov    %esp,%ebp
+    4ab3:	8b 55 08             	mov    0x8(%ebp),%edx
+    4ab6:	53                   	push   %ebx
+    4ab7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    4aba:	0f b6 02             	movzbl (%edx),%eax
+    4abd:	84 c0                	test   %al,%al
+    4abf:	74 2d                	je     4aee <strcmp+0x3e>
+    4ac1:	0f b6 19             	movzbl (%ecx),%ebx
+    4ac4:	38 d8                	cmp    %bl,%al
+    4ac6:	74 0e                	je     4ad6 <strcmp+0x26>
+    4ac8:	eb 2b                	jmp    4af5 <strcmp+0x45>
+    4aca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    4ad0:	38 c8                	cmp    %cl,%al
+    4ad2:	75 15                	jne    4ae9 <strcmp+0x39>
+    p++, q++;
+    4ad4:	89 d9                	mov    %ebx,%ecx
+    4ad6:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    4ad9:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    4adc:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    4adf:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    4ae3:	84 c0                	test   %al,%al
+    4ae5:	75 e9                	jne    4ad0 <strcmp+0x20>
+    4ae7:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    4ae9:	29 c8                	sub    %ecx,%eax
+}
+    4aeb:	5b                   	pop    %ebx
+    4aec:	5d                   	pop    %ebp
+    4aed:	c3                   	ret    
+    4aee:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    4af1:	31 c0                	xor    %eax,%eax
+    4af3:	eb f4                	jmp    4ae9 <strcmp+0x39>
+    4af5:	0f b6 cb             	movzbl %bl,%ecx
+    4af8:	eb ef                	jmp    4ae9 <strcmp+0x39>
+    4afa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00004b00 <strlen>:
+
+uint
+strlen(char *s)
+{
+    4b00:	55                   	push   %ebp
+    4b01:	89 e5                	mov    %esp,%ebp
+    4b03:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    4b06:	80 39 00             	cmpb   $0x0,(%ecx)
+    4b09:	74 12                	je     4b1d <strlen+0x1d>
+    4b0b:	31 d2                	xor    %edx,%edx
+    4b0d:	8d 76 00             	lea    0x0(%esi),%esi
+    4b10:	83 c2 01             	add    $0x1,%edx
+    4b13:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    4b17:	89 d0                	mov    %edx,%eax
+    4b19:	75 f5                	jne    4b10 <strlen+0x10>
+    ;
+  return n;
+}
+    4b1b:	5d                   	pop    %ebp
+    4b1c:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    4b1d:	31 c0                	xor    %eax,%eax
+}
+    4b1f:	5d                   	pop    %ebp
+    4b20:	c3                   	ret    
+    4b21:	eb 0d                	jmp    4b30 <memset>
+    4b23:	90                   	nop
+    4b24:	90                   	nop
+    4b25:	90                   	nop
+    4b26:	90                   	nop
+    4b27:	90                   	nop
+    4b28:	90                   	nop
+    4b29:	90                   	nop
+    4b2a:	90                   	nop
+    4b2b:	90                   	nop
+    4b2c:	90                   	nop
+    4b2d:	90                   	nop
+    4b2e:	90                   	nop
+    4b2f:	90                   	nop
+
+00004b30 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    4b30:	55                   	push   %ebp
+    4b31:	89 e5                	mov    %esp,%ebp
+    4b33:	8b 55 08             	mov    0x8(%ebp),%edx
+    4b36:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    4b37:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    4b3a:	8b 45 0c             	mov    0xc(%ebp),%eax
+    4b3d:	89 d7                	mov    %edx,%edi
+    4b3f:	fc                   	cld    
+    4b40:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    4b42:	89 d0                	mov    %edx,%eax
+    4b44:	5f                   	pop    %edi
+    4b45:	5d                   	pop    %ebp
+    4b46:	c3                   	ret    
+    4b47:	89 f6                	mov    %esi,%esi
+    4b49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00004b50 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    4b50:	55                   	push   %ebp
+    4b51:	89 e5                	mov    %esp,%ebp
+    4b53:	8b 45 08             	mov    0x8(%ebp),%eax
+    4b56:	53                   	push   %ebx
+    4b57:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    4b5a:	0f b6 18             	movzbl (%eax),%ebx
+    4b5d:	84 db                	test   %bl,%bl
+    4b5f:	74 1d                	je     4b7e <strchr+0x2e>
+    if(*s == c)
+    4b61:	38 d3                	cmp    %dl,%bl
+    4b63:	89 d1                	mov    %edx,%ecx
+    4b65:	75 0d                	jne    4b74 <strchr+0x24>
+    4b67:	eb 17                	jmp    4b80 <strchr+0x30>
+    4b69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    4b70:	38 ca                	cmp    %cl,%dl
+    4b72:	74 0c                	je     4b80 <strchr+0x30>
+  for(; *s; s++)
+    4b74:	83 c0 01             	add    $0x1,%eax
+    4b77:	0f b6 10             	movzbl (%eax),%edx
+    4b7a:	84 d2                	test   %dl,%dl
+    4b7c:	75 f2                	jne    4b70 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    4b7e:	31 c0                	xor    %eax,%eax
+}
+    4b80:	5b                   	pop    %ebx
+    4b81:	5d                   	pop    %ebp
+    4b82:	c3                   	ret    
+    4b83:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    4b89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00004b90 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    4b90:	55                   	push   %ebp
+    4b91:	89 e5                	mov    %esp,%ebp
+    4b93:	57                   	push   %edi
+    4b94:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    4b95:	31 f6                	xor    %esi,%esi
+{
+    4b97:	53                   	push   %ebx
+    4b98:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    4b9b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    4b9e:	eb 31                	jmp    4bd1 <gets+0x41>
+    cc = read(0, &c, 1);
+    4ba0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    4ba7:	00 
+    4ba8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    4bac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    4bb3:	e8 02 01 00 00       	call   4cba <read>
+    if(cc < 1)
+    4bb8:	85 c0                	test   %eax,%eax
+    4bba:	7e 1d                	jle    4bd9 <gets+0x49>
+      break;
+    buf[i++] = c;
+    4bbc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    4bc0:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    4bc2:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    4bc5:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    4bc7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    4bcb:	74 0c                	je     4bd9 <gets+0x49>
+    4bcd:	3c 0a                	cmp    $0xa,%al
+    4bcf:	74 08                	je     4bd9 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    4bd1:	8d 5e 01             	lea    0x1(%esi),%ebx
+    4bd4:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    4bd7:	7c c7                	jl     4ba0 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    4bd9:	8b 45 08             	mov    0x8(%ebp),%eax
+    4bdc:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    4be0:	83 c4 2c             	add    $0x2c,%esp
+    4be3:	5b                   	pop    %ebx
+    4be4:	5e                   	pop    %esi
+    4be5:	5f                   	pop    %edi
+    4be6:	5d                   	pop    %ebp
+    4be7:	c3                   	ret    
+    4be8:	90                   	nop
+    4be9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00004bf0 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    4bf0:	55                   	push   %ebp
+    4bf1:	89 e5                	mov    %esp,%ebp
+    4bf3:	56                   	push   %esi
+    4bf4:	53                   	push   %ebx
+    4bf5:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    4bf8:	8b 45 08             	mov    0x8(%ebp),%eax
+    4bfb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    4c02:	00 
+    4c03:	89 04 24             	mov    %eax,(%esp)
+    4c06:	e8 d7 00 00 00       	call   4ce2 <open>
+  if(fd < 0)
+    4c0b:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    4c0d:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    4c0f:	78 27                	js     4c38 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    4c11:	8b 45 0c             	mov    0xc(%ebp),%eax
+    4c14:	89 1c 24             	mov    %ebx,(%esp)
+    4c17:	89 44 24 04          	mov    %eax,0x4(%esp)
+    4c1b:	e8 da 00 00 00       	call   4cfa <fstat>
+  close(fd);
+    4c20:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    4c23:	89 c6                	mov    %eax,%esi
+  close(fd);
+    4c25:	e8 a0 00 00 00       	call   4cca <close>
+  return r;
+    4c2a:	89 f0                	mov    %esi,%eax
+}
+    4c2c:	83 c4 10             	add    $0x10,%esp
+    4c2f:	5b                   	pop    %ebx
+    4c30:	5e                   	pop    %esi
+    4c31:	5d                   	pop    %ebp
+    4c32:	c3                   	ret    
+    4c33:	90                   	nop
+    4c34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    4c38:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    4c3d:	eb ed                	jmp    4c2c <stat+0x3c>
+    4c3f:	90                   	nop
+
+00004c40 <atoi>:
+
+int
+atoi(const char *s)
+{
+    4c40:	55                   	push   %ebp
+    4c41:	89 e5                	mov    %esp,%ebp
+    4c43:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    4c46:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    4c47:	0f be 11             	movsbl (%ecx),%edx
+    4c4a:	8d 42 d0             	lea    -0x30(%edx),%eax
+    4c4d:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    4c4f:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    4c54:	77 17                	ja     4c6d <atoi+0x2d>
+    4c56:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    4c58:	83 c1 01             	add    $0x1,%ecx
+    4c5b:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    4c5e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    4c62:	0f be 11             	movsbl (%ecx),%edx
+    4c65:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    4c68:	80 fb 09             	cmp    $0x9,%bl
+    4c6b:	76 eb                	jbe    4c58 <atoi+0x18>
+  return n;
+}
+    4c6d:	5b                   	pop    %ebx
+    4c6e:	5d                   	pop    %ebp
+    4c6f:	c3                   	ret    
+
+00004c70 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    4c70:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    4c71:	31 d2                	xor    %edx,%edx
+{
+    4c73:	89 e5                	mov    %esp,%ebp
+    4c75:	56                   	push   %esi
+    4c76:	8b 45 08             	mov    0x8(%ebp),%eax
+    4c79:	53                   	push   %ebx
+    4c7a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    4c7d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    4c80:	85 db                	test   %ebx,%ebx
+    4c82:	7e 12                	jle    4c96 <memmove+0x26>
+    4c84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    4c88:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    4c8c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    4c8f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    4c92:	39 da                	cmp    %ebx,%edx
+    4c94:	75 f2                	jne    4c88 <memmove+0x18>
+  return vdst;
+}
+    4c96:	5b                   	pop    %ebx
+    4c97:	5e                   	pop    %esi
+    4c98:	5d                   	pop    %ebp
+    4c99:	c3                   	ret    
+
+00004c9a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    4c9a:	b8 01 00 00 00       	mov    $0x1,%eax
+    4c9f:	cd 40                	int    $0x40
+    4ca1:	c3                   	ret    
+
+00004ca2 <exit>:
+SYSCALL(exit)
+    4ca2:	b8 02 00 00 00       	mov    $0x2,%eax
+    4ca7:	cd 40                	int    $0x40
+    4ca9:	c3                   	ret    
+
+00004caa <wait>:
+SYSCALL(wait)
+    4caa:	b8 03 00 00 00       	mov    $0x3,%eax
+    4caf:	cd 40                	int    $0x40
+    4cb1:	c3                   	ret    
+
+00004cb2 <pipe>:
+SYSCALL(pipe)
+    4cb2:	b8 04 00 00 00       	mov    $0x4,%eax
+    4cb7:	cd 40                	int    $0x40
+    4cb9:	c3                   	ret    
+
+00004cba <read>:
+SYSCALL(read)
+    4cba:	b8 05 00 00 00       	mov    $0x5,%eax
+    4cbf:	cd 40                	int    $0x40
+    4cc1:	c3                   	ret    
+
+00004cc2 <write>:
+SYSCALL(write)
+    4cc2:	b8 10 00 00 00       	mov    $0x10,%eax
+    4cc7:	cd 40                	int    $0x40
+    4cc9:	c3                   	ret    
+
+00004cca <close>:
+SYSCALL(close)
+    4cca:	b8 15 00 00 00       	mov    $0x15,%eax
+    4ccf:	cd 40                	int    $0x40
+    4cd1:	c3                   	ret    
+
+00004cd2 <kill>:
+SYSCALL(kill)
+    4cd2:	b8 06 00 00 00       	mov    $0x6,%eax
+    4cd7:	cd 40                	int    $0x40
+    4cd9:	c3                   	ret    
+
+00004cda <exec>:
+SYSCALL(exec)
+    4cda:	b8 07 00 00 00       	mov    $0x7,%eax
+    4cdf:	cd 40                	int    $0x40
+    4ce1:	c3                   	ret    
+
+00004ce2 <open>:
+SYSCALL(open)
+    4ce2:	b8 0f 00 00 00       	mov    $0xf,%eax
+    4ce7:	cd 40                	int    $0x40
+    4ce9:	c3                   	ret    
+
+00004cea <mknod>:
+SYSCALL(mknod)
+    4cea:	b8 11 00 00 00       	mov    $0x11,%eax
+    4cef:	cd 40                	int    $0x40
+    4cf1:	c3                   	ret    
+
+00004cf2 <unlink>:
+SYSCALL(unlink)
+    4cf2:	b8 12 00 00 00       	mov    $0x12,%eax
+    4cf7:	cd 40                	int    $0x40
+    4cf9:	c3                   	ret    
+
+00004cfa <fstat>:
+SYSCALL(fstat)
+    4cfa:	b8 08 00 00 00       	mov    $0x8,%eax
+    4cff:	cd 40                	int    $0x40
+    4d01:	c3                   	ret    
+
+00004d02 <link>:
+SYSCALL(link)
+    4d02:	b8 13 00 00 00       	mov    $0x13,%eax
+    4d07:	cd 40                	int    $0x40
+    4d09:	c3                   	ret    
+
+00004d0a <mkdir>:
+SYSCALL(mkdir)
+    4d0a:	b8 14 00 00 00       	mov    $0x14,%eax
+    4d0f:	cd 40                	int    $0x40
+    4d11:	c3                   	ret    
+
+00004d12 <chdir>:
+SYSCALL(chdir)
+    4d12:	b8 09 00 00 00       	mov    $0x9,%eax
+    4d17:	cd 40                	int    $0x40
+    4d19:	c3                   	ret    
+
+00004d1a <dup>:
+SYSCALL(dup)
+    4d1a:	b8 0a 00 00 00       	mov    $0xa,%eax
+    4d1f:	cd 40                	int    $0x40
+    4d21:	c3                   	ret    
+
+00004d22 <getpid>:
+SYSCALL(getpid)
+    4d22:	b8 0b 00 00 00       	mov    $0xb,%eax
+    4d27:	cd 40                	int    $0x40
+    4d29:	c3                   	ret    
+
+00004d2a <sbrk>:
+SYSCALL(sbrk)
+    4d2a:	b8 0c 00 00 00       	mov    $0xc,%eax
+    4d2f:	cd 40                	int    $0x40
+    4d31:	c3                   	ret    
+
+00004d32 <sleep>:
+SYSCALL(sleep)
+    4d32:	b8 0d 00 00 00       	mov    $0xd,%eax
+    4d37:	cd 40                	int    $0x40
+    4d39:	c3                   	ret    
+
+00004d3a <uptime>:
+SYSCALL(uptime)
+    4d3a:	b8 0e 00 00 00       	mov    $0xe,%eax
+    4d3f:	cd 40                	int    $0x40
+    4d41:	c3                   	ret    
+
+00004d42 <shm_open>:
+SYSCALL(shm_open)
+    4d42:	b8 16 00 00 00       	mov    $0x16,%eax
+    4d47:	cd 40                	int    $0x40
+    4d49:	c3                   	ret    
+
+00004d4a <shm_close>:
+SYSCALL(shm_close)	
+    4d4a:	b8 17 00 00 00       	mov    $0x17,%eax
+    4d4f:	cd 40                	int    $0x40
+    4d51:	c3                   	ret    
+    4d52:	66 90                	xchg   %ax,%ax
+    4d54:	66 90                	xchg   %ax,%ax
+    4d56:	66 90                	xchg   %ax,%ax
+    4d58:	66 90                	xchg   %ax,%ax
+    4d5a:	66 90                	xchg   %ax,%ax
+    4d5c:	66 90                	xchg   %ax,%ax
+    4d5e:	66 90                	xchg   %ax,%ax
+
+00004d60 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    4d60:	55                   	push   %ebp
+    4d61:	89 e5                	mov    %esp,%ebp
+    4d63:	57                   	push   %edi
+    4d64:	56                   	push   %esi
+    4d65:	89 c6                	mov    %eax,%esi
+    4d67:	53                   	push   %ebx
+    4d68:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    4d6b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    4d6e:	85 db                	test   %ebx,%ebx
+    4d70:	74 09                	je     4d7b <printint+0x1b>
+    4d72:	89 d0                	mov    %edx,%eax
+    4d74:	c1 e8 1f             	shr    $0x1f,%eax
+    4d77:	84 c0                	test   %al,%al
+    4d79:	75 75                	jne    4df0 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    4d7b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    4d7d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    4d84:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    4d87:	31 ff                	xor    %edi,%edi
+    4d89:	89 ce                	mov    %ecx,%esi
+    4d8b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    4d8e:	eb 02                	jmp    4d92 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    4d90:	89 cf                	mov    %ecx,%edi
+    4d92:	31 d2                	xor    %edx,%edx
+    4d94:	f7 f6                	div    %esi
+    4d96:	8d 4f 01             	lea    0x1(%edi),%ecx
+    4d99:	0f b6 92 43 69 00 00 	movzbl 0x6943(%edx),%edx
+  }while((x /= base) != 0);
+    4da0:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    4da2:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    4da5:	75 e9                	jne    4d90 <printint+0x30>
+  if(neg)
+    4da7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    4daa:	89 c8                	mov    %ecx,%eax
+    4dac:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    4daf:	85 d2                	test   %edx,%edx
+    4db1:	74 08                	je     4dbb <printint+0x5b>
+    buf[i++] = '-';
+    4db3:	8d 4f 02             	lea    0x2(%edi),%ecx
+    4db6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    4dbb:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    4dbe:	66 90                	xchg   %ax,%ax
+    4dc0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    4dc5:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    4dc8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    4dcf:	00 
+    4dd0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    4dd4:	89 34 24             	mov    %esi,(%esp)
+    4dd7:	88 45 d7             	mov    %al,-0x29(%ebp)
+    4dda:	e8 e3 fe ff ff       	call   4cc2 <write>
+  while(--i >= 0)
+    4ddf:	83 ff ff             	cmp    $0xffffffff,%edi
+    4de2:	75 dc                	jne    4dc0 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    4de4:	83 c4 4c             	add    $0x4c,%esp
+    4de7:	5b                   	pop    %ebx
+    4de8:	5e                   	pop    %esi
+    4de9:	5f                   	pop    %edi
+    4dea:	5d                   	pop    %ebp
+    4deb:	c3                   	ret    
+    4dec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    4df0:	89 d0                	mov    %edx,%eax
+    4df2:	f7 d8                	neg    %eax
+    neg = 1;
+    4df4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    4dfb:	eb 87                	jmp    4d84 <printint+0x24>
+    4dfd:	8d 76 00             	lea    0x0(%esi),%esi
+
+00004e00 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    4e00:	55                   	push   %ebp
+    4e01:	89 e5                	mov    %esp,%ebp
+    4e03:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    4e04:	31 ff                	xor    %edi,%edi
+{
+    4e06:	56                   	push   %esi
+    4e07:	53                   	push   %ebx
+    4e08:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    4e0b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    4e0e:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    4e11:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    4e14:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    4e17:	0f b6 13             	movzbl (%ebx),%edx
+    4e1a:	83 c3 01             	add    $0x1,%ebx
+    4e1d:	84 d2                	test   %dl,%dl
+    4e1f:	75 39                	jne    4e5a <printf+0x5a>
+    4e21:	e9 c2 00 00 00       	jmp    4ee8 <printf+0xe8>
+    4e26:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    4e28:	83 fa 25             	cmp    $0x25,%edx
+    4e2b:	0f 84 bf 00 00 00    	je     4ef0 <printf+0xf0>
+  write(fd, &c, 1);
+    4e31:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    4e34:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    4e3b:	00 
+    4e3c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    4e40:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    4e43:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    4e46:	e8 77 fe ff ff       	call   4cc2 <write>
+    4e4b:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    4e4e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    4e52:	84 d2                	test   %dl,%dl
+    4e54:	0f 84 8e 00 00 00    	je     4ee8 <printf+0xe8>
+    if(state == 0){
+    4e5a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    4e5c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    4e5f:	74 c7                	je     4e28 <printf+0x28>
+      }
+    } else if(state == '%'){
+    4e61:	83 ff 25             	cmp    $0x25,%edi
+    4e64:	75 e5                	jne    4e4b <printf+0x4b>
+      if(c == 'd'){
+    4e66:	83 fa 64             	cmp    $0x64,%edx
+    4e69:	0f 84 31 01 00 00    	je     4fa0 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    4e6f:	25 f7 00 00 00       	and    $0xf7,%eax
+    4e74:	83 f8 70             	cmp    $0x70,%eax
+    4e77:	0f 84 83 00 00 00    	je     4f00 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    4e7d:	83 fa 73             	cmp    $0x73,%edx
+    4e80:	0f 84 a2 00 00 00    	je     4f28 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    4e86:	83 fa 63             	cmp    $0x63,%edx
+    4e89:	0f 84 35 01 00 00    	je     4fc4 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    4e8f:	83 fa 25             	cmp    $0x25,%edx
+    4e92:	0f 84 e0 00 00 00    	je     4f78 <printf+0x178>
+  write(fd, &c, 1);
+    4e98:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    4e9b:	83 c3 01             	add    $0x1,%ebx
+    4e9e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    4ea5:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    4ea6:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    4ea8:	89 44 24 04          	mov    %eax,0x4(%esp)
+    4eac:	89 34 24             	mov    %esi,(%esp)
+    4eaf:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    4eb2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    4eb6:	e8 07 fe ff ff       	call   4cc2 <write>
+        putc(fd, c);
+    4ebb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    4ebe:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    4ec1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    4ec8:	00 
+    4ec9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    4ecd:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    4ed0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    4ed3:	e8 ea fd ff ff       	call   4cc2 <write>
+  for(i = 0; fmt[i]; i++){
+    4ed8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    4edc:	84 d2                	test   %dl,%dl
+    4ede:	0f 85 76 ff ff ff    	jne    4e5a <printf+0x5a>
+    4ee4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    4ee8:	83 c4 3c             	add    $0x3c,%esp
+    4eeb:	5b                   	pop    %ebx
+    4eec:	5e                   	pop    %esi
+    4eed:	5f                   	pop    %edi
+    4eee:	5d                   	pop    %ebp
+    4eef:	c3                   	ret    
+        state = '%';
+    4ef0:	bf 25 00 00 00       	mov    $0x25,%edi
+    4ef5:	e9 51 ff ff ff       	jmp    4e4b <printf+0x4b>
+    4efa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    4f00:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    4f03:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    4f08:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    4f0a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    4f11:	8b 10                	mov    (%eax),%edx
+    4f13:	89 f0                	mov    %esi,%eax
+    4f15:	e8 46 fe ff ff       	call   4d60 <printint>
+        ap++;
+    4f1a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    4f1e:	e9 28 ff ff ff       	jmp    4e4b <printf+0x4b>
+    4f23:	90                   	nop
+    4f24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    4f28:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    4f2b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    4f2f:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    4f31:	b8 3c 69 00 00       	mov    $0x693c,%eax
+    4f36:	85 ff                	test   %edi,%edi
+    4f38:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    4f3b:	0f b6 07             	movzbl (%edi),%eax
+    4f3e:	84 c0                	test   %al,%al
+    4f40:	74 2a                	je     4f6c <printf+0x16c>
+    4f42:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    4f48:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    4f4b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    4f4e:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    4f51:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    4f58:	00 
+    4f59:	89 44 24 04          	mov    %eax,0x4(%esp)
+    4f5d:	89 34 24             	mov    %esi,(%esp)
+    4f60:	e8 5d fd ff ff       	call   4cc2 <write>
+        while(*s != 0){
+    4f65:	0f b6 07             	movzbl (%edi),%eax
+    4f68:	84 c0                	test   %al,%al
+    4f6a:	75 dc                	jne    4f48 <printf+0x148>
+      state = 0;
+    4f6c:	31 ff                	xor    %edi,%edi
+    4f6e:	e9 d8 fe ff ff       	jmp    4e4b <printf+0x4b>
+    4f73:	90                   	nop
+    4f74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    4f78:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    4f7b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    4f7d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    4f84:	00 
+    4f85:	89 44 24 04          	mov    %eax,0x4(%esp)
+    4f89:	89 34 24             	mov    %esi,(%esp)
+    4f8c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    4f90:	e8 2d fd ff ff       	call   4cc2 <write>
+    4f95:	e9 b1 fe ff ff       	jmp    4e4b <printf+0x4b>
+    4f9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    4fa0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    4fa3:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    4fa8:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    4fab:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    4fb2:	8b 10                	mov    (%eax),%edx
+    4fb4:	89 f0                	mov    %esi,%eax
+    4fb6:	e8 a5 fd ff ff       	call   4d60 <printint>
+        ap++;
+    4fbb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    4fbf:	e9 87 fe ff ff       	jmp    4e4b <printf+0x4b>
+        putc(fd, *ap);
+    4fc4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    4fc7:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    4fc9:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    4fcb:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    4fd2:	00 
+    4fd3:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    4fd6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    4fd9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    4fdc:	89 44 24 04          	mov    %eax,0x4(%esp)
+    4fe0:	e8 dd fc ff ff       	call   4cc2 <write>
+        ap++;
+    4fe5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    4fe9:	e9 5d fe ff ff       	jmp    4e4b <printf+0x4b>
+    4fee:	66 90                	xchg   %ax,%ax
+
+00004ff0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    4ff0:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    4ff1:	a1 00 73 00 00       	mov    0x7300,%eax
+{
+    4ff6:	89 e5                	mov    %esp,%ebp
+    4ff8:	57                   	push   %edi
+    4ff9:	56                   	push   %esi
+    4ffa:	53                   	push   %ebx
+    4ffb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    4ffe:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    5000:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    5003:	39 d0                	cmp    %edx,%eax
+    5005:	72 11                	jb     5018 <free+0x28>
+    5007:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    5008:	39 c8                	cmp    %ecx,%eax
+    500a:	72 04                	jb     5010 <free+0x20>
+    500c:	39 ca                	cmp    %ecx,%edx
+    500e:	72 10                	jb     5020 <free+0x30>
+    5010:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    5012:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    5014:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    5016:	73 f0                	jae    5008 <free+0x18>
+    5018:	39 ca                	cmp    %ecx,%edx
+    501a:	72 04                	jb     5020 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    501c:	39 c8                	cmp    %ecx,%eax
+    501e:	72 f0                	jb     5010 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    5020:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    5023:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    5026:	39 cf                	cmp    %ecx,%edi
+    5028:	74 1e                	je     5048 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    502a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    502d:	8b 48 04             	mov    0x4(%eax),%ecx
+    5030:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    5033:	39 f2                	cmp    %esi,%edx
+    5035:	74 28                	je     505f <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    5037:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    5039:	a3 00 73 00 00       	mov    %eax,0x7300
+}
+    503e:	5b                   	pop    %ebx
+    503f:	5e                   	pop    %esi
+    5040:	5f                   	pop    %edi
+    5041:	5d                   	pop    %ebp
+    5042:	c3                   	ret    
+    5043:	90                   	nop
+    5044:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    5048:	03 71 04             	add    0x4(%ecx),%esi
+    504b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    504e:	8b 08                	mov    (%eax),%ecx
+    5050:	8b 09                	mov    (%ecx),%ecx
+    5052:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    5055:	8b 48 04             	mov    0x4(%eax),%ecx
+    5058:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    505b:	39 f2                	cmp    %esi,%edx
+    505d:	75 d8                	jne    5037 <free+0x47>
+    p->s.size += bp->s.size;
+    505f:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    5062:	a3 00 73 00 00       	mov    %eax,0x7300
+    p->s.size += bp->s.size;
+    5067:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    506a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    506d:	89 10                	mov    %edx,(%eax)
+}
+    506f:	5b                   	pop    %ebx
+    5070:	5e                   	pop    %esi
+    5071:	5f                   	pop    %edi
+    5072:	5d                   	pop    %ebp
+    5073:	c3                   	ret    
+    5074:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    507a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00005080 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    5080:	55                   	push   %ebp
+    5081:	89 e5                	mov    %esp,%ebp
+    5083:	57                   	push   %edi
+    5084:	56                   	push   %esi
+    5085:	53                   	push   %ebx
+    5086:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    5089:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    508c:	8b 1d 00 73 00 00    	mov    0x7300,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    5092:	8d 48 07             	lea    0x7(%eax),%ecx
+    5095:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    5098:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    509a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    509d:	0f 84 9b 00 00 00    	je     513e <malloc+0xbe>
+    50a3:	8b 13                	mov    (%ebx),%edx
+    50a5:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    50a8:	39 fe                	cmp    %edi,%esi
+    50aa:	76 64                	jbe    5110 <malloc+0x90>
+    50ac:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    50b3:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    50b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    50bb:	eb 0e                	jmp    50cb <malloc+0x4b>
+    50bd:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    50c0:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    50c2:	8b 78 04             	mov    0x4(%eax),%edi
+    50c5:	39 fe                	cmp    %edi,%esi
+    50c7:	76 4f                	jbe    5118 <malloc+0x98>
+    50c9:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    50cb:	3b 15 00 73 00 00    	cmp    0x7300,%edx
+    50d1:	75 ed                	jne    50c0 <malloc+0x40>
+  if(nu < 4096)
+    50d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    50d6:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    50dc:	bf 00 10 00 00       	mov    $0x1000,%edi
+    50e1:	0f 43 fe             	cmovae %esi,%edi
+    50e4:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    50e7:	89 04 24             	mov    %eax,(%esp)
+    50ea:	e8 3b fc ff ff       	call   4d2a <sbrk>
+  if(p == (char*)-1)
+    50ef:	83 f8 ff             	cmp    $0xffffffff,%eax
+    50f2:	74 18                	je     510c <malloc+0x8c>
+  hp->s.size = nu;
+    50f4:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    50f7:	83 c0 08             	add    $0x8,%eax
+    50fa:	89 04 24             	mov    %eax,(%esp)
+    50fd:	e8 ee fe ff ff       	call   4ff0 <free>
+  return freep;
+    5102:	8b 15 00 73 00 00    	mov    0x7300,%edx
+      if((p = morecore(nunits)) == 0)
+    5108:	85 d2                	test   %edx,%edx
+    510a:	75 b4                	jne    50c0 <malloc+0x40>
+        return 0;
+    510c:	31 c0                	xor    %eax,%eax
+    510e:	eb 20                	jmp    5130 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    5110:	89 d0                	mov    %edx,%eax
+    5112:	89 da                	mov    %ebx,%edx
+    5114:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    5118:	39 fe                	cmp    %edi,%esi
+    511a:	74 1c                	je     5138 <malloc+0xb8>
+        p->s.size -= nunits;
+    511c:	29 f7                	sub    %esi,%edi
+    511e:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    5121:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    5124:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    5127:	89 15 00 73 00 00    	mov    %edx,0x7300
+      return (void*)(p + 1);
+    512d:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    5130:	83 c4 1c             	add    $0x1c,%esp
+    5133:	5b                   	pop    %ebx
+    5134:	5e                   	pop    %esi
+    5135:	5f                   	pop    %edi
+    5136:	5d                   	pop    %ebp
+    5137:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    5138:	8b 08                	mov    (%eax),%ecx
+    513a:	89 0a                	mov    %ecx,(%edx)
+    513c:	eb e9                	jmp    5127 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    513e:	c7 05 00 73 00 00 04 	movl   $0x7304,0x7300
+    5145:	73 00 00 
+    base.s.size = 0;
+    5148:	ba 04 73 00 00       	mov    $0x7304,%edx
+    base.s.ptr = freep = prevp = &base;
+    514d:	c7 05 04 73 00 00 04 	movl   $0x7304,0x7304
+    5154:	73 00 00 
+    base.s.size = 0;
+    5157:	c7 05 08 73 00 00 00 	movl   $0x0,0x7308
+    515e:	00 00 00 
+    5161:	e9 46 ff ff ff       	jmp    50ac <malloc+0x2c>
+    5166:	66 90                	xchg   %ax,%ax
+    5168:	66 90                	xchg   %ax,%ax
+    516a:	66 90                	xchg   %ax,%ax
+    516c:	66 90                	xchg   %ax,%ax
+    516e:	66 90                	xchg   %ax,%ax
+
+00005170 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    5170:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    5171:	b9 01 00 00 00       	mov    $0x1,%ecx
+    5176:	89 e5                	mov    %esp,%ebp
+    5178:	8b 55 08             	mov    0x8(%ebp),%edx
+    517b:	90                   	nop
+    517c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    5180:	89 c8                	mov    %ecx,%eax
+    5182:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    5185:	85 c0                	test   %eax,%eax
+    5187:	75 f7                	jne    5180 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    5189:	0f ae f0             	mfence 
+}
+    518c:	5d                   	pop    %ebp
+    518d:	c3                   	ret    
+    518e:	66 90                	xchg   %ax,%ax
+
+00005190 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    5190:	55                   	push   %ebp
+    5191:	89 e5                	mov    %esp,%ebp
+    5193:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    5196:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    5199:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    519f:	5d                   	pop    %ebp
+    51a0:	c3                   	ret    
diff --git a/usertests.c b/usertests.c
index 2c2c128..a1e97e7 100644
--- a/usertests.c
+++ b/usertests.c
@@ -21,19 +21,19 @@ iputtest(void)
 
   if(mkdir("iputdir") < 0){
     printf(stdout, "mkdir failed\n");
-    exit(184);
+    exit();
   }
   if(chdir("iputdir") < 0){
     printf(stdout, "chdir iputdir failed\n");
-    exit(183);
+    exit();
   }
   if(unlink("../iputdir") < 0){
     printf(stdout, "unlink ../iputdir failed\n");
-    exit(182);
+    exit();
   }
   if(chdir("/") < 0){
     printf(stdout, "chdir / failed\n");
-    exit(181);
+    exit();
   }
   printf(stdout, "iput test ok\n");
 }
@@ -49,24 +49,24 @@ exitiputtest(void)
   pid = fork();
   if(pid < 0){
     printf(stdout, "fork failed\n");
-    exit(180);
+    exit();
   }
   if(pid == 0){
     if(mkdir("iputdir") < 0){
       printf(stdout, "mkdir failed\n");
-      exit(179);
+      exit();
     }
     if(chdir("iputdir") < 0){
       printf(stdout, "child chdir failed\n");
-      exit(178);
+      exit();
     }
     if(unlink("../iputdir") < 0){
       printf(stdout, "unlink ../iputdir failed\n");
-      exit(177);
+      exit();
     }
-    exit(176);
+    exit();
   }
-  wait(NULL);
+  wait();
   printf(stdout, "exitiput test ok\n");
 }
 
@@ -89,27 +89,27 @@ openiputtest(void)
   printf(stdout, "openiput test\n");
   if(mkdir("oidir") < 0){
     printf(stdout, "mkdir oidir failed\n");
-    exit(175);
+    exit();
   }
   pid = fork();
   if(pid < 0){
     printf(stdout, "fork failed\n");
-    exit(174);
+    exit();
   }
   if(pid == 0){
     int fd = open("oidir", O_RDWR);
     if(fd >= 0){
       printf(stdout, "open directory for write succeeded\n");
-      exit(0);
+      exit();
     }
-    exit(172);
+    exit();
   }
   sleep(1);
   if(unlink("oidir") != 0){
     printf(stdout, "unlink failed\n");
-    exit(171);
+    exit();
   }
-  wait(NULL);
+  wait();
   printf(stdout, "openiput test ok\n");
 }
 
@@ -124,13 +124,13 @@ opentest(void)
   fd = open("echo", 0);
   if(fd < 0){
     printf(stdout, "open echo failed!\n");
-    exit(170);
+    exit();
   }
   close(fd);
   fd = open("doesnotexist", 0);
   if(fd >= 0){
     printf(stdout, "open doesnotexist succeeded!\n");
-    exit(0);
+    exit();
   }
   printf(stdout, "open test ok\n");
 }
@@ -147,16 +147,16 @@ writetest(void)
     printf(stdout, "creat small succeeded; ok\n");
   } else {
     printf(stdout, "error: creat small failed!\n");
-    exit(168);
+    exit();
   }
   for(i = 0; i < 100; i++){
     if(write(fd, "aaaaaaaaaa", 10) != 10){
       printf(stdout, "error: write aa %d new file failed\n", i);
-      exit(167);
+      exit();
     }
     if(write(fd, "bbbbbbbbbb", 10) != 10){
       printf(stdout, "error: write bb %d new file failed\n", i);
-      exit(166);
+      exit();
     }
   }
   printf(stdout, "writes ok\n");
@@ -166,20 +166,20 @@ writetest(void)
     printf(stdout, "open small succeeded ok\n");
   } else {
     printf(stdout, "error: open small failed!\n");
-    exit(165);
+    exit();
   }
   i = read(fd, buf, 2000);
   if(i == 2000){
     printf(stdout, "read succeeded ok\n");
   } else {
     printf(stdout, "read failed\n");
-    exit(164);
+    exit();
   }
   close(fd);
 
   if(unlink("small") < 0){
     printf(stdout, "unlink small failed\n");
-    exit(163);
+    exit();
   }
   printf(stdout, "small file test ok\n");
 }
@@ -194,14 +194,14 @@ writetest1(void)
   fd = open("big", O_CREATE|O_RDWR);
   if(fd < 0){
     printf(stdout, "error: creat big failed!\n");
-    exit(162);
+    exit();
   }
 
   for(i = 0; i < MAXFILE; i++){
     ((int*)buf)[0] = i;
     if(write(fd, buf, 512) != 512){
       printf(stdout, "error: write big file failed\n", i);
-      exit(161);
+      exit();
     }
   }
 
@@ -210,7 +210,7 @@ writetest1(void)
   fd = open("big", O_RDONLY);
   if(fd < 0){
     printf(stdout, "error: open big failed!\n");
-    exit(160);
+    exit();
   }
 
   n = 0;
@@ -219,24 +219,24 @@ writetest1(void)
     if(i == 0){
       if(n == MAXFILE - 1){
         printf(stdout, "read only %d blocks from big", n);
-        exit(159);
+        exit();
       }
       break;
     } else if(i != 512){
       printf(stdout, "read failed %d\n", i);
-      exit(158);
+      exit();
     }
     if(((int*)buf)[0] != n){
       printf(stdout, "read content of block %d is %d\n",
              n, ((int*)buf)[0]);
-      exit(157);
+      exit();
     }
     n++;
   }
   close(fd);
   if(unlink("big") < 0){
     printf(stdout, "unlink big failed\n");
-    exit(156);
+    exit();
   }
   printf(stdout, "big files ok\n");
 }
@@ -270,22 +270,22 @@ void dirtest(void)
 
   if(mkdir("dir0") < 0){
     printf(stdout, "mkdir failed\n");
-    exit(155);
+    exit();
   }
 
   if(chdir("dir0") < 0){
     printf(stdout, "chdir dir0 failed\n");
-    exit(154);
+    exit();
   }
 
   if(chdir("..") < 0){
     printf(stdout, "chdir .. failed\n");
-    exit(153);
+    exit();
   }
 
   if(unlink("dir0") < 0){
     printf(stdout, "unlink dir0 failed\n");
-    exit(152);
+    exit();
   }
   printf(stdout, "mkdir test ok\n");
 }
@@ -296,7 +296,7 @@ exectest(void)
   printf(stdout, "exec test\n");
   if(exec("echo", echoargv) < 0){
     printf(stdout, "exec echo failed\n");
-    exit(151);
+    exit();
   }
 }
 
@@ -310,7 +310,7 @@ pipe1(void)
 
   if(pipe(fds) != 0){
     printf(1, "pipe() failed\n");
-    exit(150);
+    exit();
   }
   pid = fork();
   seq = 0;
@@ -321,10 +321,10 @@ pipe1(void)
         buf[i] = seq++;
       if(write(fds[1], buf, 1033) != 1033){
         printf(1, "pipe1 oops 1\n");
-        exit(149);
+        exit();
       }
     }
-    exit(148);
+    exit();
   } else if(pid > 0){
     close(fds[1]);
     total = 0;
@@ -343,13 +343,13 @@ pipe1(void)
     }
     if(total != 5 * 1033){
       printf(1, "pipe1 oops 3 total %d\n", total);
-      exit(147);
+      exit();
     }
     close(fds[0]);
-    wait(NULL);
+    wait();
   } else {
     printf(1, "fork() failed\n");
-    exit(146);
+    exit();
   }
   printf(1, "pipe1 ok\n");
 }
@@ -394,9 +394,9 @@ preempt(void)
   kill(pid2);
   kill(pid3);
   printf(1, "wait... ");
-  wait(NULL);
-  wait(NULL);
-  wait(NULL);
+  wait();
+  wait();
+  wait();
   printf(1, "preempt ok\n");
 }
 
@@ -413,12 +413,12 @@ exitwait(void)
       return;
     }
     if(pid){
-      if(wait(NULL) != pid){
+      if(wait() != pid){
         printf(1, "wait wrong pid\n");
         return;
       }
     } else {
-      exit(145);
+      exit();
     }
   }
   printf(1, "exitwait ok\n");
@@ -447,13 +447,13 @@ mem(void)
     if(m1 == 0){
       printf(1, "couldn't allocate mem?!!\n");
       kill(ppid);
-      exit(144);
+      exit();
     }
     free(m1);
     printf(1, "mem ok\n");
-    exit(0);
+    exit();
   } else {
-    wait(NULL);
+    wait();
   }
 }
 
@@ -484,9 +484,9 @@ sharedfd(void)
     }
   }
   if(pid == 0)
-    exit(142);
+    exit();
   else
-    wait(NULL);
+    wait();
   close(fd);
   fd = open("sharedfd", 0);
   if(fd < 0){
@@ -508,7 +508,7 @@ sharedfd(void)
     printf(1, "sharedfd ok\n");
   } else {
     printf(1, "sharedfd oops %d %d\n", nc, np);
-    exit(141);
+    exit();
   }
 }
 
@@ -530,29 +530,29 @@ fourfiles(void)
     pid = fork();
     if(pid < 0){
       printf(1, "fork failed\n");
-      exit(140);
+      exit();
     }
 
     if(pid == 0){
       fd = open(fname, O_CREATE | O_RDWR);
       if(fd < 0){
         printf(1, "create failed\n");
-        exit(139);
+        exit();
       }
 
       memset(buf, '0'+pi, 512);
       for(i = 0; i < 12; i++){
         if((n = write(fd, buf, 500)) != 500){
           printf(1, "write failed %d\n", n);
-          exit(138);
+          exit();
         }
       }
-      exit(137);
+      exit();
     }
   }
 
   for(pi = 0; pi < 4; pi++){
-    wait(NULL);
+    wait();
   }
 
   for(i = 0; i < 2; i++){
@@ -563,7 +563,7 @@ fourfiles(void)
       for(j = 0; j < n; j++){
         if(buf[j] != '0'+i){
           printf(1, "wrong char\n");
-          exit(136);
+          exit();
         }
       }
       total += n;
@@ -571,7 +571,7 @@ fourfiles(void)
     close(fd);
     if(total != 12*500){
       printf(1, "wrong length %d\n", total);
-      exit(135);
+      exit();
     }
     unlink(fname);
   }
@@ -593,7 +593,7 @@ createdelete(void)
     pid = fork();
     if(pid < 0){
       printf(1, "fork failed\n");
-      exit(134);
+      exit();
     }
 
     if(pid == 0){
@@ -604,23 +604,23 @@ createdelete(void)
         fd = open(name, O_CREATE | O_RDWR);
         if(fd < 0){
           printf(1, "create failed\n");
-          exit(133);
+          exit();
         }
         close(fd);
         if(i > 0 && (i % 2 ) == 0){
           name[1] = '0' + (i / 2);
           if(unlink(name) < 0){
             printf(1, "unlink failed\n");
-            exit(132);
+            exit();
           }
         }
       }
-      exit(131);
+      exit();
     }
   }
 
   for(pi = 0; pi < 4; pi++){
-    wait(NULL);
+    wait();
   }
 
   name[0] = name[1] = name[2] = 0;
@@ -631,10 +631,10 @@ createdelete(void)
       fd = open(name, 0);
       if((i == 0 || i >= N/2) && fd < 0){
         printf(1, "oops createdelete %s didn't exist\n", name);
-        exit(130);
+        exit();
       } else if((i >= 1 && i < N/2) && fd >= 0){
         printf(1, "oops createdelete %s did exist\n", name);
-        exit(129);
+        exit();
       }
       if(fd >= 0)
         close(fd);
@@ -662,7 +662,7 @@ unlinkread(void)
   fd = open("unlinkread", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "create unlinkread failed\n");
-    exit(128);
+    exit();
   }
   write(fd, "hello", 5);
   close(fd);
@@ -670,11 +670,11 @@ unlinkread(void)
   fd = open("unlinkread", O_RDWR);
   if(fd < 0){
     printf(1, "open unlinkread failed\n");
-    exit(127);
+    exit();
   }
   if(unlink("unlinkread") != 0){
     printf(1, "unlink unlinkread failed\n");
-    exit(126);
+    exit();
   }
 
   fd1 = open("unlinkread", O_CREATE | O_RDWR);
@@ -683,15 +683,15 @@ unlinkread(void)
 
   if(read(fd, buf, sizeof(buf)) != 5){
     printf(1, "unlinkread read failed");
-    exit(125);
+    exit();
   }
   if(buf[0] != 'h'){
     printf(1, "unlinkread wrong data\n");
-    exit(124);
+    exit();
   }
   if(write(fd, buf, 10) != 10){
     printf(1, "unlinkread write failed\n");
-    exit(123);
+    exit();
   }
   close(fd);
   unlink("unlinkread");
@@ -711,50 +711,50 @@ linktest(void)
   fd = open("lf1", O_CREATE|O_RDWR);
   if(fd < 0){
     printf(1, "create lf1 failed\n");
-    exit(122);
+    exit();
   }
   if(write(fd, "hello", 5) != 5){
     printf(1, "write lf1 failed\n");
-    exit(121);
+    exit();
   }
   close(fd);
 
   if(link("lf1", "lf2") < 0){
     printf(1, "link lf1 lf2 failed\n");
-    exit(120);
+    exit();
   }
   unlink("lf1");
 
   if(open("lf1", 0) >= 0){
     printf(1, "unlinked lf1 but it is still there!\n");
-    exit(119);
+    exit();
   }
 
   fd = open("lf2", 0);
   if(fd < 0){
     printf(1, "open lf2 failed\n");
-    exit(118);
+    exit();
   }
   if(read(fd, buf, sizeof(buf)) != 5){
     printf(1, "read lf2 failed\n");
-    exit(117);
+    exit();
   }
   close(fd);
 
   if(link("lf2", "lf2") >= 0){
     printf(1, "link lf2 lf2 succeeded! oops\n");
-    exit(116);
+    exit();
   }
 
   unlink("lf2");
   if(link("lf2", "lf1") >= 0){
     printf(1, "link non-existant succeeded! oops\n");
-    exit(115);
+    exit();
   }
 
   if(link(".", "lf1") >= 0){
     printf(1, "link . lf1 succeeded! oops\n");
-    exit(114);
+    exit();
   }
 
   printf(1, "linktest ok\n");
@@ -787,14 +787,14 @@ concreate(void)
       fd = open(file, O_CREATE | O_RDWR);
       if(fd < 0){
         printf(1, "concreate create %s failed\n", file);
-        exit(113);
+        exit();
       }
       close(fd);
     }
     if(pid == 0)
-      exit(112);
+      exit();
     else
-      wait(NULL);
+      wait();
   }
 
   memset(fa, 0, sizeof(fa));
@@ -807,11 +807,11 @@ concreate(void)
       i = de.name[1] - '0';
       if(i < 0 || i >= sizeof(fa)){
         printf(1, "concreate weird file %s\n", de.name);
-        exit(111);
+        exit();
       }
       if(fa[i]){
         printf(1, "concreate duplicate file %s\n", de.name);
-        exit(110);
+        exit();
       }
       fa[i] = 1;
       n++;
@@ -821,7 +821,7 @@ concreate(void)
 
   if(n != 40){
     printf(1, "concreate not enough files in directory listing\n");
-    exit(109);
+    exit();
   }
 
   for(i = 0; i < 40; i++){
@@ -829,7 +829,7 @@ concreate(void)
     pid = fork();
     if(pid < 0){
       printf(1, "fork failed\n");
-      exit(108);
+      exit();
     }
     if(((i % 3) == 0 && pid == 0) ||
        ((i % 3) == 1 && pid != 0)){
@@ -844,9 +844,9 @@ concreate(void)
       unlink(file);
     }
     if(pid == 0)
-      exit(107);
+      exit();
     else
-      wait(NULL);
+      wait();
   }
 
   printf(1, "concreate ok\n");
@@ -865,7 +865,7 @@ linkunlink()
   pid = fork();
   if(pid < 0){
     printf(1, "fork failed\n");
-    exit(106);
+    exit();
   }
 
   unsigned int x = (pid ? 1 : 97);
@@ -881,9 +881,9 @@ linkunlink()
   }
 
   if(pid)
-    wait(NULL);
+    wait();
   else
-    exit(105);
+    exit();
 
   printf(1, "linkunlink ok\n");
 }
@@ -901,7 +901,7 @@ bigdir(void)
   fd = open("bd", O_CREATE);
   if(fd < 0){
     printf(1, "bigdir create failed\n");
-    exit(104);
+    exit();
   }
   close(fd);
 
@@ -912,7 +912,7 @@ bigdir(void)
     name[3] = '\0';
     if(link("bd", name) != 0){
       printf(1, "bigdir link failed\n");
-      exit(103);
+      exit();
     }
   }
 
@@ -924,7 +924,7 @@ bigdir(void)
     name[3] = '\0';
     if(unlink(name) != 0){
       printf(1, "bigdir unlink failed");
-      exit(102);
+      exit();
     }
   }
 
@@ -941,31 +941,31 @@ subdir(void)
   unlink("ff");
   if(mkdir("dd") != 0){
     printf(1, "subdir mkdir dd failed\n");
-    exit(101);
+    exit();
   }
 
   fd = open("dd/ff", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "create dd/ff failed\n");
-    exit(100);
+    exit();
   }
   write(fd, "ff", 2);
   close(fd);
 
   if(unlink("dd") >= 0){
     printf(1, "unlink dd (non-empty dir) succeeded!\n");
-    exit(99);
+    exit();
   }
 
   if(mkdir("/dd/dd") != 0){
     printf(1, "subdir mkdir dd/dd failed\n");
-    exit(98);
+    exit();
   }
 
   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "create dd/dd/ff failed\n");
-    exit(97);
+    exit();
   }
   write(fd, "FF", 2);
   close(fd);
@@ -973,142 +973,142 @@ subdir(void)
   fd = open("dd/dd/../ff", 0);
   if(fd < 0){
     printf(1, "open dd/dd/../ff failed\n");
-    exit(96);
+    exit();
   }
   cc = read(fd, buf, sizeof(buf));
   if(cc != 2 || buf[0] != 'f'){
     printf(1, "dd/dd/../ff wrong content\n");
-    exit(95);
+    exit();
   }
   close(fd);
 
   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
-    exit(94);
+    exit();
   }
 
   if(unlink("dd/dd/ff") != 0){
     printf(1, "unlink dd/dd/ff failed\n");
-    exit(93);
+    exit();
   }
   if(open("dd/dd/ff", O_RDONLY) >= 0){
     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
-    exit(92);
+    exit();
   }
 
   if(chdir("dd") != 0){
     printf(1, "chdir dd failed\n");
-    exit(91);
+    exit();
   }
   if(chdir("dd/../../dd") != 0){
     printf(1, "chdir dd/../../dd failed\n");
-    exit(90);
+    exit();
   }
   if(chdir("dd/../../../dd") != 0){
     printf(1, "chdir dd/../../dd failed\n");
-    exit(89);
+    exit();
   }
   if(chdir("./..") != 0){
     printf(1, "chdir ./.. failed\n");
-    exit(88);
+    exit();
   }
 
   fd = open("dd/dd/ffff", 0);
   if(fd < 0){
     printf(1, "open dd/dd/ffff failed\n");
-    exit(87);
+    exit();
   }
   if(read(fd, buf, sizeof(buf)) != 2){
     printf(1, "read dd/dd/ffff wrong len\n");
-    exit(86);
+    exit();
   }
   close(fd);
 
   if(open("dd/dd/ff", O_RDONLY) >= 0){
     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
-    exit(0);
+    exit();
   }
 
   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
     printf(1, "create dd/ff/ff succeeded!\n");
-    exit(0);
+    exit();
   }
   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
     printf(1, "create dd/xx/ff succeeded!\n");
-    exit(0);
+    exit();
   }
   if(open("dd", O_CREATE) >= 0){
     printf(1, "create dd succeeded!\n");
-    exit(0);
+    exit();
   }
   if(open("dd", O_RDWR) >= 0){
     printf(1, "open dd rdwr succeeded!\n");
-    exit(0);
+    exit();
   }
   if(open("dd", O_WRONLY) >= 0){
     printf(1, "open dd wronly succeeded!\n");
-    exit(0);
+    exit();
   }
   if(link("dd/ff/ff", "dd/dd/xx") == 0){
     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
-    exit(0);
+    exit();
   }
   if(link("dd/xx/ff", "dd/dd/xx") == 0){
     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
-    exit(0);
+    exit();
   }
   if(link("dd/ff", "dd/dd/ffff") == 0){
     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
-    exit(0);
+    exit();
   }
   if(mkdir("dd/ff/ff") == 0){
     printf(1, "mkdir dd/ff/ff succeeded!\n");
-    exit(0);
+    exit();
   }
   if(mkdir("dd/xx/ff") == 0){
     printf(1, "mkdir dd/xx/ff succeeded!\n");
-    exit(0);
+    exit();
   }
   if(mkdir("dd/dd/ffff") == 0){
     printf(1, "mkdir dd/dd/ffff succeeded!\n");
-    exit(0);
+    exit();
   }
   if(unlink("dd/xx/ff") == 0){
     printf(1, "unlink dd/xx/ff succeeded!\n");
-    exit(0);
+    exit();
   }
   if(unlink("dd/ff/ff") == 0){
     printf(1, "unlink dd/ff/ff succeeded!\n");
-    exit(0);
+    exit();
   }
   if(chdir("dd/ff") == 0){
     printf(1, "chdir dd/ff succeeded!\n");
-    exit(0);
+    exit();
   }
   if(chdir("dd/xx") == 0){
     printf(1, "chdir dd/xx succeeded!\n");
-    exit(0);
+    exit();
   }
 
   if(unlink("dd/dd/ffff") != 0){
     printf(1, "unlink dd/dd/ff failed\n");
-    exit(68);
+    exit();
   }
   if(unlink("dd/ff") != 0){
     printf(1, "unlink dd/ff failed\n");
-    exit(67);
+    exit();
   }
   if(unlink("dd") == 0){
     printf(1, "unlink non-empty dd succeeded!\n");
-    exit(0);
+    exit();
   }
   if(unlink("dd/dd") < 0){
     printf(1, "unlink dd/dd failed\n");
-    exit(65);
+    exit();
   }
   if(unlink("dd") < 0){
     printf(1, "unlink dd failed\n");
-    exit(64);
+    exit();
   }
 
   printf(1, "subdir ok\n");
@@ -1127,14 +1127,14 @@ bigwrite(void)
     fd = open("bigwrite", O_CREATE | O_RDWR);
     if(fd < 0){
       printf(1, "cannot create bigwrite\n");
-      exit(63);
+      exit();
     }
     int i;
     for(i = 0; i < 2; i++){
       int cc = write(fd, buf, sz);
       if(cc != sz){
         printf(1, "write(%d) ret %d\n", sz, cc);
-        exit(62);
+        exit();
       }
     }
     close(fd);
@@ -1155,13 +1155,13 @@ bigfile(void)
   fd = open("bigfile", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "cannot create bigfile");
-    exit(61);
+    exit();
   }
   for(i = 0; i < 20; i++){
     memset(buf, i, 600);
     if(write(fd, buf, 600) != 600){
       printf(1, "write bigfile failed\n");
-      exit(60);
+      exit();
     }
   }
   close(fd);
@@ -1169,31 +1169,31 @@ bigfile(void)
   fd = open("bigfile", 0);
   if(fd < 0){
     printf(1, "cannot open bigfile\n");
-    exit(59);
+    exit();
   }
   total = 0;
   for(i = 0; ; i++){
     cc = read(fd, buf, 300);
     if(cc < 0){
       printf(1, "read bigfile failed\n");
-      exit(58);
+      exit();
     }
     if(cc == 0)
       break;
     if(cc != 300){
       printf(1, "short read bigfile\n");
-      exit(57);
+      exit();
     }
     if(buf[0] != i/2 || buf[299] != i/2){
       printf(1, "read bigfile wrong data\n");
-      exit(56);
+      exit();
     }
     total += cc;
   }
   close(fd);
   if(total != 20*600){
     printf(1, "read bigfile wrong total\n");
-    exit(55);
+    exit();
   }
   unlink("bigfile");
 
@@ -1210,32 +1210,32 @@ fourteen(void)
 
   if(mkdir("12345678901234") != 0){
     printf(1, "mkdir 12345678901234 failed\n");
-    exit(54);
+    exit();
   }
   if(mkdir("12345678901234/123456789012345") != 0){
     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
-    exit(53);
+    exit();
   }
   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
   if(fd < 0){
     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
-    exit(52);
+    exit();
   }
   close(fd);
   fd = open("12345678901234/12345678901234/12345678901234", 0);
   if(fd < 0){
     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
-    exit(51);
+    exit();
   }
   close(fd);
 
   if(mkdir("12345678901234/12345678901234") == 0){
     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
-    exit(0);
+    exit();
   }
   if(mkdir("123456789012345/12345678901234") == 0){
     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
-    exit(0);
+    exit();
   }
 
   printf(1, "fourteen ok\n");
@@ -1247,35 +1247,35 @@ rmdot(void)
   printf(1, "rmdot test\n");
   if(mkdir("dots") != 0){
     printf(1, "mkdir dots failed\n");
-    exit(48);
+    exit();
   }
   if(chdir("dots") != 0){
     printf(1, "chdir dots failed\n");
-    exit(47);
+    exit();
   }
   if(unlink(".") == 0){
     printf(1, "rm . worked!\n");
-    exit(0);
+    exit();
   }
   if(unlink("..") == 0){
     printf(1, "rm .. worked!\n");
-    exit(0);
+    exit();
   }
   if(chdir("/") != 0){
     printf(1, "chdir / failed\n");
-    exit(44);
+    exit();
   }
   if(unlink("dots/.") == 0){
     printf(1, "unlink dots/. worked!\n");
-    exit(0);
+    exit();
   }
   if(unlink("dots/..") == 0){
     printf(1, "unlink dots/.. worked!\n");
-    exit(0);
+    exit();
   }
   if(unlink("dots") != 0){
     printf(1, "unlink dots failed!\n");
-    exit(41);
+    exit();
   }
   printf(1, "rmdot ok\n");
 }
@@ -1290,49 +1290,49 @@ dirfile(void)
   fd = open("dirfile", O_CREATE);
   if(fd < 0){
     printf(1, "create dirfile failed\n");
-    exit(40);
+    exit();
   }
   close(fd);
   if(chdir("dirfile") == 0){
     printf(1, "chdir dirfile succeeded!\n");
-    exit(0);
+    exit();
   }
   fd = open("dirfile/xx", 0);
   if(fd >= 0){
     printf(1, "create dirfile/xx succeeded!\n");
-    exit(0);
+    exit();
   }
   fd = open("dirfile/xx", O_CREATE);
   if(fd >= 0){
     printf(1, "create dirfile/xx succeeded!\n");
-    exit(0);
+    exit();
   }
   if(mkdir("dirfile/xx") == 0){
     printf(1, "mkdir dirfile/xx succeeded!\n");
-    exit(0);
+    exit();
   }
   if(unlink("dirfile/xx") == 0){
     printf(1, "unlink dirfile/xx succeeded!\n");
-    exit(0);
+    exit();
   }
   if(link("README", "dirfile/xx") == 0){
     printf(1, "link to dirfile/xx succeeded!\n");
-    exit(0);
+    exit();
   }
   if(unlink("dirfile") != 0){
     printf(1, "unlink dirfile failed!\n");
-    exit(33);
+    exit();
   }
 
   fd = open(".", O_RDWR);
   if(fd >= 0){
     printf(1, "open . for writing succeeded!\n");
-    exit(0);
+    exit();
   }
   fd = open(".", 0);
   if(write(fd, "x", 1) > 0){
     printf(1, "write . succeeded!\n");
-    exit(0);
+    exit();
   }
   close(fd);
 
@@ -1351,11 +1351,11 @@ iref(void)
   for(i = 0; i < 50 + 1; i++){
     if(mkdir("irefd") != 0){
       printf(1, "mkdir irefd failed\n");
-      exit(30);
+      exit();
     }
     if(chdir("irefd") != 0){
       printf(1, "chdir irefd failed\n");
-      exit(29);
+      exit();
     }
 
     mkdir("");
@@ -1388,24 +1388,24 @@ forktest(void)
     if(pid < 0)
       break;
     if(pid == 0)
-      exit(28);
+      exit();
   }
 
   if(n == 1000){
     printf(1, "fork claimed to work 1000 times!\n");
-    exit(27);
+    exit();
   }
 
   for(; n > 0; n--){
-    if(wait(NULL) < 0){
+    if(wait() < 0){
       printf(1, "wait stopped early\n");
-      exit(26);
+      exit();
     }
   }
 
-  if(wait(NULL) != -1){
+  if(wait() != -1){
     printf(1, "wait got too many\n");
-    exit(25);
+    exit();
   }
 
   printf(1, "fork test OK\n");
@@ -1428,7 +1428,7 @@ sbrktest(void)
     b = sbrk(1);
     if(b != a){
       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
-      exit(24);
+      exit();
     }
     *b = 1;
     a = b + 1;
@@ -1436,17 +1436,17 @@ sbrktest(void)
   pid = fork();
   if(pid < 0){
     printf(stdout, "sbrk test fork failed\n");
-    exit(23);
+    exit();
   }
   c = sbrk(1);
   c = sbrk(1);
   if(c != a + 1){
     printf(stdout, "sbrk test failed post-fork\n");
-    exit(22);
+    exit();
   }
   if(pid == 0)
-    exit(21);
-  wait(NULL);
+    exit();
+  wait();
 
   // can one grow address space to something big?
 #define BIG (100*1024*1024)
@@ -1455,7 +1455,7 @@ sbrktest(void)
   p = sbrk(amt);
   if (p != a) {
     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
-    exit(20);
+    exit();
   }
   lastaddr = (char*) (BIG-1);
   *lastaddr = 99;
@@ -1465,12 +1465,12 @@ sbrktest(void)
   c = sbrk(-4096);
   if(c == (char*)0xffffffff){
     printf(stdout, "sbrk could not deallocate\n");
-    exit(19);
+    exit();
   }
   c = sbrk(0);
   if(c != a - 4096){
     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
-    exit(18);
+    exit();
   }
 
   // can one re-allocate that page?
@@ -1478,19 +1478,19 @@ sbrktest(void)
   c = sbrk(4096);
   if(c != a || sbrk(0) != a + 4096){
     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
-    exit(17);
+    exit();
   }
   if(*lastaddr == 99){
     // should be zero
     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
-    exit(16);
+    exit();
   }
 
   a = sbrk(0);
   c = sbrk(-(sbrk(0) - oldbrk));
   if(c != a){
     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
-    exit(15);
+    exit();
   }
 
   // can we read the kernel's memory?
@@ -1499,21 +1499,21 @@ sbrktest(void)
     pid = fork();
     if(pid < 0){
       printf(stdout, "fork failed\n");
-      exit(14);
+      exit();
     }
     if(pid == 0){
       printf(stdout, "oops could read %x = %x\n", a, *a);
       kill(ppid);
-      exit(13);
+      exit();
     }
-    wait(NULL);
+    wait();
   }
 
   // if we run the system out of memory, does it clean up the last
   // failed allocation?
   if(pipe(fds) != 0){
     printf(1, "pipe() failed\n");
-    exit(12);
+    exit();
   }
   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
     if((pids[i] = fork()) == 0){
@@ -1533,11 +1533,11 @@ sbrktest(void)
     if(pids[i] == -1)
       continue;
     kill(pids[i]);
-    wait(NULL);
+    wait();
   }
   if(c == (char*)0xffffffff){
     printf(stdout, "failed sbrk leaked memory\n");
-    exit(10);
+    exit();
   }
 
   if(sbrk(0) > oldbrk)
@@ -1572,17 +1572,17 @@ validatetest(void)
     if((pid = fork()) == 0){
       // try to crash the kernel by passing in a badly placed integer
       validateint((int*)p);
-      exit(9);
+      exit();
     }
     sleep(0);
     sleep(0);
     kill(pid);
-    wait(NULL);
+    wait();
 
     // try to crash the kernel by passing in a bad string pointer
     if(link("nosuchfile", (char*)p) != -1){
       printf(stdout, "link should not succeed\n");
-      exit(8);
+      exit();
     }
   }
 
@@ -1600,7 +1600,7 @@ bsstest(void)
   for(i = 0; i < sizeof(uninit); i++){
     if(uninit[i] != '\0'){
       printf(stdout, "bss test failed\n");
-      exit(7);
+      exit();
     }
   }
   printf(stdout, "bss test ok\n");
@@ -1627,16 +1627,16 @@ bigargtest(void)
     printf(stdout, "bigarg test ok\n");
     fd = open("bigarg-ok", O_CREATE);
     close(fd);
-    exit(6);
+    exit();
   } else if(pid < 0){
     printf(stdout, "bigargtest: fork failed\n");
-    exit(5);
+    exit();
   }
-  wait(NULL);
+  wait();
   fd = open("bigarg-ok", 0);
   if(fd < 0){
     printf(stdout, "bigarg test failed!\n");
-    exit(4);
+    exit();
   }
   close(fd);
   unlink("bigarg-ok");
@@ -1715,12 +1715,12 @@ uio()
     port = RTC_DATA;
     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
     printf(1, "uio: uio succeeded; test FAILED\n");
-    exit(3);
+    exit();
   } else if(pid < 0){
     printf (1, "fork failed\n");
-    exit(2);
+    exit();
   }
-  wait(NULL);
+  wait();
   printf(1, "uio test done\n");
 }
 
@@ -1730,7 +1730,7 @@ void argptest()
   fd = open("init", O_RDONLY);
   if (fd < 0) {
     printf(2, "open failed\n");
-    exit(1);
+    exit();
   }
   read(fd, sbrk(0) - 1, -1);
   close(fd);
@@ -1752,7 +1752,7 @@ main(int argc, char *argv[])
 
   if(open("usertests.ran", 0) >= 0){
     printf(1, "already ran user tests -- rebuild fs.img\n");
-    exit(1);
+    exit();
   }
   close(open("usertests.ran", O_CREATE));
 
@@ -1799,5 +1799,5 @@ main(int argc, char *argv[])
 
   exectest();
 
-  exit(0);
+  exit();
 }
diff --git a/usertests.d b/usertests.d
new file mode 100644
index 0000000..a4933d3
--- /dev/null
+++ b/usertests.d
@@ -0,0 +1,2 @@
+usertests.o: usertests.c /usr/include/stdc-predef.h param.h types.h \
+ stat.h user.h fs.h fcntl.h syscall.h traps.h memlayout.h
diff --git a/usertests.o b/usertests.o
new file mode 100644
index 0000000..bafd193
Binary files /dev/null and b/usertests.o differ
diff --git a/usertests.sym b/usertests.sym
new file mode 100644
index 0000000..0154404
--- /dev/null
+++ b/usertests.sym
@@ -0,0 +1,108 @@
+00001000 .text
+000051a4 .rodata
+00006954 .eh_frame
+0000725c .data
+00007280 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 usertests.c
+00007280 args.1723
+00000000 ulib.c
+00000000 printf.c
+00004d60 printint
+00006943 digits.1359
+00000000 umalloc.c
+00007300 freep
+00007304 base
+00000000 uspinlock.c
+00004a80 strcpy
+00001db0 exitwait
+00004e00 printf
+00007260 stdout
+00004650 bigargtest
+00004c70 memmove
+00001300 openiputtest
+00004cea mknod
+00004d42 shm_open
+00004b90 gets
+00004d22 getpid
+00001a90 pipe1
+00003ec0 iref
+00005080 malloc
+00004d32 sleep
+00001210 exitiputtest
+00004760 fsfull
+00002db0 bigdir
+00003fe0 forktest
+000016c0 writetest1
+00003690 bigwrite
+00001f20 sharedfd
+0000725c randstate
+00004cb2 pipe
+00007320 uninit
+00003c80 dirfile
+00004cc2 write
+000045d0 bsstest
+00007264 echoargv
+00004cfa fstat
+00004cd2 kill
+00004520 validatetest
+00003af0 rmdot
+00004d12 chdir
+00001a40 exectest
+00004cda exec
+00004caa wait
+00004a60 rand
+00004cba read
+00001c50 preempt
+00004cf2 unlink
+000049e0 argptest
+00005170 uacquire
+00001e40 mem
+00004c9a fork
+00004d2a sbrk
+00004d4a shm_close
+00004d3a uptime
+00007278 __bss_start
+00004b30 memset
+000018b0 createtest
+00001000 main
+00002310 createdelete
+00004ab0 strcmp
+000014b0 writetest
+00004d1a dup
+000040b0 sbrktest
+00001410 opentest
+00002f00 subdir
+00004960 uio
+00002720 linktest
+00009a40 buf
+00001960 dirtest
+00001130 iputtest
+00004bf0 stat
+00003790 bigfile
+00007278 _edata
+0000ba44 _end
+00002550 unlinkread
+00004d02 link
+00004ca2 exit
+00004c40 atoi
+00002ca0 linkunlink
+0000ba40 name
+00004b00 strlen
+00004ce2 open
+00004b50 strchr
+00002980 concreate
+00003990 fourteen
+00004510 validateint
+00002100 fourfiles
+00004d0a mkdir
+00004cca close
+00005190 urelease
+00004ff0 free
diff --git a/uspinlock.c b/uspinlock.c
new file mode 100644
index 0000000..17c609b
--- /dev/null
+++ b/uspinlock.c
@@ -0,0 +1,25 @@
+#include "types.h"
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+}
+
+void urelease (struct uspinlock *lk) {
+  __sync_synchronize();
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+}
diff --git a/uspinlock.d b/uspinlock.d
new file mode 100644
index 0000000..23a956c
--- /dev/null
+++ b/uspinlock.d
@@ -0,0 +1,2 @@
+uspinlock.o: uspinlock.c /usr/include/stdc-predef.h types.h uspinlock.h \
+ x86.h
diff --git a/uspinlock.h b/uspinlock.h
new file mode 100644
index 0000000..06e195c
--- /dev/null
+++ b/uspinlock.h
@@ -0,0 +1,9 @@
+
+
+struct uspinlock {
+uint locked;
+};
+
+void uacquire(struct uspinlock *lock);
+void urelease(struct uspinlock *lock);
+
diff --git a/uspinlock.o b/uspinlock.o
new file mode 100644
index 0000000..0a28709
Binary files /dev/null and b/uspinlock.o differ
diff --git a/usys.S b/usys.S
index 1687ed0..7d6d0a0 100644
--- a/usys.S
+++ b/usys.S
@@ -11,7 +11,6 @@
 SYSCALL(fork)
 SYSCALL(exit)
 SYSCALL(wait)
-SYSCALL(waitpid)
 SYSCALL(pipe)
 SYSCALL(read)
 SYSCALL(write)
@@ -30,3 +29,5 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(shm_open)
+SYSCALL(shm_close)	
diff --git a/usys.o b/usys.o
new file mode 100644
index 0000000..5fe23a5
Binary files /dev/null and b/usys.o differ
diff --git a/vectors.S b/vectors.S
new file mode 100644
index 0000000..9e4041a
--- /dev/null
+++ b/vectors.S
@@ -0,0 +1,1537 @@
+# generated by vectors.pl - do not edit
+# handlers
+.globl alltraps
+.globl vector0
+vector0:
+  pushl $0
+  pushl $0
+  jmp alltraps
+.globl vector1
+vector1:
+  pushl $0
+  pushl $1
+  jmp alltraps
+.globl vector2
+vector2:
+  pushl $0
+  pushl $2
+  jmp alltraps
+.globl vector3
+vector3:
+  pushl $0
+  pushl $3
+  jmp alltraps
+.globl vector4
+vector4:
+  pushl $0
+  pushl $4
+  jmp alltraps
+.globl vector5
+vector5:
+  pushl $0
+  pushl $5
+  jmp alltraps
+.globl vector6
+vector6:
+  pushl $0
+  pushl $6
+  jmp alltraps
+.globl vector7
+vector7:
+  pushl $0
+  pushl $7
+  jmp alltraps
+.globl vector8
+vector8:
+  pushl $8
+  jmp alltraps
+.globl vector9
+vector9:
+  pushl $0
+  pushl $9
+  jmp alltraps
+.globl vector10
+vector10:
+  pushl $10
+  jmp alltraps
+.globl vector11
+vector11:
+  pushl $11
+  jmp alltraps
+.globl vector12
+vector12:
+  pushl $12
+  jmp alltraps
+.globl vector13
+vector13:
+  pushl $13
+  jmp alltraps
+.globl vector14
+vector14:
+  pushl $14
+  jmp alltraps
+.globl vector15
+vector15:
+  pushl $0
+  pushl $15
+  jmp alltraps
+.globl vector16
+vector16:
+  pushl $0
+  pushl $16
+  jmp alltraps
+.globl vector17
+vector17:
+  pushl $17
+  jmp alltraps
+.globl vector18
+vector18:
+  pushl $0
+  pushl $18
+  jmp alltraps
+.globl vector19
+vector19:
+  pushl $0
+  pushl $19
+  jmp alltraps
+.globl vector20
+vector20:
+  pushl $0
+  pushl $20
+  jmp alltraps
+.globl vector21
+vector21:
+  pushl $0
+  pushl $21
+  jmp alltraps
+.globl vector22
+vector22:
+  pushl $0
+  pushl $22
+  jmp alltraps
+.globl vector23
+vector23:
+  pushl $0
+  pushl $23
+  jmp alltraps
+.globl vector24
+vector24:
+  pushl $0
+  pushl $24
+  jmp alltraps
+.globl vector25
+vector25:
+  pushl $0
+  pushl $25
+  jmp alltraps
+.globl vector26
+vector26:
+  pushl $0
+  pushl $26
+  jmp alltraps
+.globl vector27
+vector27:
+  pushl $0
+  pushl $27
+  jmp alltraps
+.globl vector28
+vector28:
+  pushl $0
+  pushl $28
+  jmp alltraps
+.globl vector29
+vector29:
+  pushl $0
+  pushl $29
+  jmp alltraps
+.globl vector30
+vector30:
+  pushl $0
+  pushl $30
+  jmp alltraps
+.globl vector31
+vector31:
+  pushl $0
+  pushl $31
+  jmp alltraps
+.globl vector32
+vector32:
+  pushl $0
+  pushl $32
+  jmp alltraps
+.globl vector33
+vector33:
+  pushl $0
+  pushl $33
+  jmp alltraps
+.globl vector34
+vector34:
+  pushl $0
+  pushl $34
+  jmp alltraps
+.globl vector35
+vector35:
+  pushl $0
+  pushl $35
+  jmp alltraps
+.globl vector36
+vector36:
+  pushl $0
+  pushl $36
+  jmp alltraps
+.globl vector37
+vector37:
+  pushl $0
+  pushl $37
+  jmp alltraps
+.globl vector38
+vector38:
+  pushl $0
+  pushl $38
+  jmp alltraps
+.globl vector39
+vector39:
+  pushl $0
+  pushl $39
+  jmp alltraps
+.globl vector40
+vector40:
+  pushl $0
+  pushl $40
+  jmp alltraps
+.globl vector41
+vector41:
+  pushl $0
+  pushl $41
+  jmp alltraps
+.globl vector42
+vector42:
+  pushl $0
+  pushl $42
+  jmp alltraps
+.globl vector43
+vector43:
+  pushl $0
+  pushl $43
+  jmp alltraps
+.globl vector44
+vector44:
+  pushl $0
+  pushl $44
+  jmp alltraps
+.globl vector45
+vector45:
+  pushl $0
+  pushl $45
+  jmp alltraps
+.globl vector46
+vector46:
+  pushl $0
+  pushl $46
+  jmp alltraps
+.globl vector47
+vector47:
+  pushl $0
+  pushl $47
+  jmp alltraps
+.globl vector48
+vector48:
+  pushl $0
+  pushl $48
+  jmp alltraps
+.globl vector49
+vector49:
+  pushl $0
+  pushl $49
+  jmp alltraps
+.globl vector50
+vector50:
+  pushl $0
+  pushl $50
+  jmp alltraps
+.globl vector51
+vector51:
+  pushl $0
+  pushl $51
+  jmp alltraps
+.globl vector52
+vector52:
+  pushl $0
+  pushl $52
+  jmp alltraps
+.globl vector53
+vector53:
+  pushl $0
+  pushl $53
+  jmp alltraps
+.globl vector54
+vector54:
+  pushl $0
+  pushl $54
+  jmp alltraps
+.globl vector55
+vector55:
+  pushl $0
+  pushl $55
+  jmp alltraps
+.globl vector56
+vector56:
+  pushl $0
+  pushl $56
+  jmp alltraps
+.globl vector57
+vector57:
+  pushl $0
+  pushl $57
+  jmp alltraps
+.globl vector58
+vector58:
+  pushl $0
+  pushl $58
+  jmp alltraps
+.globl vector59
+vector59:
+  pushl $0
+  pushl $59
+  jmp alltraps
+.globl vector60
+vector60:
+  pushl $0
+  pushl $60
+  jmp alltraps
+.globl vector61
+vector61:
+  pushl $0
+  pushl $61
+  jmp alltraps
+.globl vector62
+vector62:
+  pushl $0
+  pushl $62
+  jmp alltraps
+.globl vector63
+vector63:
+  pushl $0
+  pushl $63
+  jmp alltraps
+.globl vector64
+vector64:
+  pushl $0
+  pushl $64
+  jmp alltraps
+.globl vector65
+vector65:
+  pushl $0
+  pushl $65
+  jmp alltraps
+.globl vector66
+vector66:
+  pushl $0
+  pushl $66
+  jmp alltraps
+.globl vector67
+vector67:
+  pushl $0
+  pushl $67
+  jmp alltraps
+.globl vector68
+vector68:
+  pushl $0
+  pushl $68
+  jmp alltraps
+.globl vector69
+vector69:
+  pushl $0
+  pushl $69
+  jmp alltraps
+.globl vector70
+vector70:
+  pushl $0
+  pushl $70
+  jmp alltraps
+.globl vector71
+vector71:
+  pushl $0
+  pushl $71
+  jmp alltraps
+.globl vector72
+vector72:
+  pushl $0
+  pushl $72
+  jmp alltraps
+.globl vector73
+vector73:
+  pushl $0
+  pushl $73
+  jmp alltraps
+.globl vector74
+vector74:
+  pushl $0
+  pushl $74
+  jmp alltraps
+.globl vector75
+vector75:
+  pushl $0
+  pushl $75
+  jmp alltraps
+.globl vector76
+vector76:
+  pushl $0
+  pushl $76
+  jmp alltraps
+.globl vector77
+vector77:
+  pushl $0
+  pushl $77
+  jmp alltraps
+.globl vector78
+vector78:
+  pushl $0
+  pushl $78
+  jmp alltraps
+.globl vector79
+vector79:
+  pushl $0
+  pushl $79
+  jmp alltraps
+.globl vector80
+vector80:
+  pushl $0
+  pushl $80
+  jmp alltraps
+.globl vector81
+vector81:
+  pushl $0
+  pushl $81
+  jmp alltraps
+.globl vector82
+vector82:
+  pushl $0
+  pushl $82
+  jmp alltraps
+.globl vector83
+vector83:
+  pushl $0
+  pushl $83
+  jmp alltraps
+.globl vector84
+vector84:
+  pushl $0
+  pushl $84
+  jmp alltraps
+.globl vector85
+vector85:
+  pushl $0
+  pushl $85
+  jmp alltraps
+.globl vector86
+vector86:
+  pushl $0
+  pushl $86
+  jmp alltraps
+.globl vector87
+vector87:
+  pushl $0
+  pushl $87
+  jmp alltraps
+.globl vector88
+vector88:
+  pushl $0
+  pushl $88
+  jmp alltraps
+.globl vector89
+vector89:
+  pushl $0
+  pushl $89
+  jmp alltraps
+.globl vector90
+vector90:
+  pushl $0
+  pushl $90
+  jmp alltraps
+.globl vector91
+vector91:
+  pushl $0
+  pushl $91
+  jmp alltraps
+.globl vector92
+vector92:
+  pushl $0
+  pushl $92
+  jmp alltraps
+.globl vector93
+vector93:
+  pushl $0
+  pushl $93
+  jmp alltraps
+.globl vector94
+vector94:
+  pushl $0
+  pushl $94
+  jmp alltraps
+.globl vector95
+vector95:
+  pushl $0
+  pushl $95
+  jmp alltraps
+.globl vector96
+vector96:
+  pushl $0
+  pushl $96
+  jmp alltraps
+.globl vector97
+vector97:
+  pushl $0
+  pushl $97
+  jmp alltraps
+.globl vector98
+vector98:
+  pushl $0
+  pushl $98
+  jmp alltraps
+.globl vector99
+vector99:
+  pushl $0
+  pushl $99
+  jmp alltraps
+.globl vector100
+vector100:
+  pushl $0
+  pushl $100
+  jmp alltraps
+.globl vector101
+vector101:
+  pushl $0
+  pushl $101
+  jmp alltraps
+.globl vector102
+vector102:
+  pushl $0
+  pushl $102
+  jmp alltraps
+.globl vector103
+vector103:
+  pushl $0
+  pushl $103
+  jmp alltraps
+.globl vector104
+vector104:
+  pushl $0
+  pushl $104
+  jmp alltraps
+.globl vector105
+vector105:
+  pushl $0
+  pushl $105
+  jmp alltraps
+.globl vector106
+vector106:
+  pushl $0
+  pushl $106
+  jmp alltraps
+.globl vector107
+vector107:
+  pushl $0
+  pushl $107
+  jmp alltraps
+.globl vector108
+vector108:
+  pushl $0
+  pushl $108
+  jmp alltraps
+.globl vector109
+vector109:
+  pushl $0
+  pushl $109
+  jmp alltraps
+.globl vector110
+vector110:
+  pushl $0
+  pushl $110
+  jmp alltraps
+.globl vector111
+vector111:
+  pushl $0
+  pushl $111
+  jmp alltraps
+.globl vector112
+vector112:
+  pushl $0
+  pushl $112
+  jmp alltraps
+.globl vector113
+vector113:
+  pushl $0
+  pushl $113
+  jmp alltraps
+.globl vector114
+vector114:
+  pushl $0
+  pushl $114
+  jmp alltraps
+.globl vector115
+vector115:
+  pushl $0
+  pushl $115
+  jmp alltraps
+.globl vector116
+vector116:
+  pushl $0
+  pushl $116
+  jmp alltraps
+.globl vector117
+vector117:
+  pushl $0
+  pushl $117
+  jmp alltraps
+.globl vector118
+vector118:
+  pushl $0
+  pushl $118
+  jmp alltraps
+.globl vector119
+vector119:
+  pushl $0
+  pushl $119
+  jmp alltraps
+.globl vector120
+vector120:
+  pushl $0
+  pushl $120
+  jmp alltraps
+.globl vector121
+vector121:
+  pushl $0
+  pushl $121
+  jmp alltraps
+.globl vector122
+vector122:
+  pushl $0
+  pushl $122
+  jmp alltraps
+.globl vector123
+vector123:
+  pushl $0
+  pushl $123
+  jmp alltraps
+.globl vector124
+vector124:
+  pushl $0
+  pushl $124
+  jmp alltraps
+.globl vector125
+vector125:
+  pushl $0
+  pushl $125
+  jmp alltraps
+.globl vector126
+vector126:
+  pushl $0
+  pushl $126
+  jmp alltraps
+.globl vector127
+vector127:
+  pushl $0
+  pushl $127
+  jmp alltraps
+.globl vector128
+vector128:
+  pushl $0
+  pushl $128
+  jmp alltraps
+.globl vector129
+vector129:
+  pushl $0
+  pushl $129
+  jmp alltraps
+.globl vector130
+vector130:
+  pushl $0
+  pushl $130
+  jmp alltraps
+.globl vector131
+vector131:
+  pushl $0
+  pushl $131
+  jmp alltraps
+.globl vector132
+vector132:
+  pushl $0
+  pushl $132
+  jmp alltraps
+.globl vector133
+vector133:
+  pushl $0
+  pushl $133
+  jmp alltraps
+.globl vector134
+vector134:
+  pushl $0
+  pushl $134
+  jmp alltraps
+.globl vector135
+vector135:
+  pushl $0
+  pushl $135
+  jmp alltraps
+.globl vector136
+vector136:
+  pushl $0
+  pushl $136
+  jmp alltraps
+.globl vector137
+vector137:
+  pushl $0
+  pushl $137
+  jmp alltraps
+.globl vector138
+vector138:
+  pushl $0
+  pushl $138
+  jmp alltraps
+.globl vector139
+vector139:
+  pushl $0
+  pushl $139
+  jmp alltraps
+.globl vector140
+vector140:
+  pushl $0
+  pushl $140
+  jmp alltraps
+.globl vector141
+vector141:
+  pushl $0
+  pushl $141
+  jmp alltraps
+.globl vector142
+vector142:
+  pushl $0
+  pushl $142
+  jmp alltraps
+.globl vector143
+vector143:
+  pushl $0
+  pushl $143
+  jmp alltraps
+.globl vector144
+vector144:
+  pushl $0
+  pushl $144
+  jmp alltraps
+.globl vector145
+vector145:
+  pushl $0
+  pushl $145
+  jmp alltraps
+.globl vector146
+vector146:
+  pushl $0
+  pushl $146
+  jmp alltraps
+.globl vector147
+vector147:
+  pushl $0
+  pushl $147
+  jmp alltraps
+.globl vector148
+vector148:
+  pushl $0
+  pushl $148
+  jmp alltraps
+.globl vector149
+vector149:
+  pushl $0
+  pushl $149
+  jmp alltraps
+.globl vector150
+vector150:
+  pushl $0
+  pushl $150
+  jmp alltraps
+.globl vector151
+vector151:
+  pushl $0
+  pushl $151
+  jmp alltraps
+.globl vector152
+vector152:
+  pushl $0
+  pushl $152
+  jmp alltraps
+.globl vector153
+vector153:
+  pushl $0
+  pushl $153
+  jmp alltraps
+.globl vector154
+vector154:
+  pushl $0
+  pushl $154
+  jmp alltraps
+.globl vector155
+vector155:
+  pushl $0
+  pushl $155
+  jmp alltraps
+.globl vector156
+vector156:
+  pushl $0
+  pushl $156
+  jmp alltraps
+.globl vector157
+vector157:
+  pushl $0
+  pushl $157
+  jmp alltraps
+.globl vector158
+vector158:
+  pushl $0
+  pushl $158
+  jmp alltraps
+.globl vector159
+vector159:
+  pushl $0
+  pushl $159
+  jmp alltraps
+.globl vector160
+vector160:
+  pushl $0
+  pushl $160
+  jmp alltraps
+.globl vector161
+vector161:
+  pushl $0
+  pushl $161
+  jmp alltraps
+.globl vector162
+vector162:
+  pushl $0
+  pushl $162
+  jmp alltraps
+.globl vector163
+vector163:
+  pushl $0
+  pushl $163
+  jmp alltraps
+.globl vector164
+vector164:
+  pushl $0
+  pushl $164
+  jmp alltraps
+.globl vector165
+vector165:
+  pushl $0
+  pushl $165
+  jmp alltraps
+.globl vector166
+vector166:
+  pushl $0
+  pushl $166
+  jmp alltraps
+.globl vector167
+vector167:
+  pushl $0
+  pushl $167
+  jmp alltraps
+.globl vector168
+vector168:
+  pushl $0
+  pushl $168
+  jmp alltraps
+.globl vector169
+vector169:
+  pushl $0
+  pushl $169
+  jmp alltraps
+.globl vector170
+vector170:
+  pushl $0
+  pushl $170
+  jmp alltraps
+.globl vector171
+vector171:
+  pushl $0
+  pushl $171
+  jmp alltraps
+.globl vector172
+vector172:
+  pushl $0
+  pushl $172
+  jmp alltraps
+.globl vector173
+vector173:
+  pushl $0
+  pushl $173
+  jmp alltraps
+.globl vector174
+vector174:
+  pushl $0
+  pushl $174
+  jmp alltraps
+.globl vector175
+vector175:
+  pushl $0
+  pushl $175
+  jmp alltraps
+.globl vector176
+vector176:
+  pushl $0
+  pushl $176
+  jmp alltraps
+.globl vector177
+vector177:
+  pushl $0
+  pushl $177
+  jmp alltraps
+.globl vector178
+vector178:
+  pushl $0
+  pushl $178
+  jmp alltraps
+.globl vector179
+vector179:
+  pushl $0
+  pushl $179
+  jmp alltraps
+.globl vector180
+vector180:
+  pushl $0
+  pushl $180
+  jmp alltraps
+.globl vector181
+vector181:
+  pushl $0
+  pushl $181
+  jmp alltraps
+.globl vector182
+vector182:
+  pushl $0
+  pushl $182
+  jmp alltraps
+.globl vector183
+vector183:
+  pushl $0
+  pushl $183
+  jmp alltraps
+.globl vector184
+vector184:
+  pushl $0
+  pushl $184
+  jmp alltraps
+.globl vector185
+vector185:
+  pushl $0
+  pushl $185
+  jmp alltraps
+.globl vector186
+vector186:
+  pushl $0
+  pushl $186
+  jmp alltraps
+.globl vector187
+vector187:
+  pushl $0
+  pushl $187
+  jmp alltraps
+.globl vector188
+vector188:
+  pushl $0
+  pushl $188
+  jmp alltraps
+.globl vector189
+vector189:
+  pushl $0
+  pushl $189
+  jmp alltraps
+.globl vector190
+vector190:
+  pushl $0
+  pushl $190
+  jmp alltraps
+.globl vector191
+vector191:
+  pushl $0
+  pushl $191
+  jmp alltraps
+.globl vector192
+vector192:
+  pushl $0
+  pushl $192
+  jmp alltraps
+.globl vector193
+vector193:
+  pushl $0
+  pushl $193
+  jmp alltraps
+.globl vector194
+vector194:
+  pushl $0
+  pushl $194
+  jmp alltraps
+.globl vector195
+vector195:
+  pushl $0
+  pushl $195
+  jmp alltraps
+.globl vector196
+vector196:
+  pushl $0
+  pushl $196
+  jmp alltraps
+.globl vector197
+vector197:
+  pushl $0
+  pushl $197
+  jmp alltraps
+.globl vector198
+vector198:
+  pushl $0
+  pushl $198
+  jmp alltraps
+.globl vector199
+vector199:
+  pushl $0
+  pushl $199
+  jmp alltraps
+.globl vector200
+vector200:
+  pushl $0
+  pushl $200
+  jmp alltraps
+.globl vector201
+vector201:
+  pushl $0
+  pushl $201
+  jmp alltraps
+.globl vector202
+vector202:
+  pushl $0
+  pushl $202
+  jmp alltraps
+.globl vector203
+vector203:
+  pushl $0
+  pushl $203
+  jmp alltraps
+.globl vector204
+vector204:
+  pushl $0
+  pushl $204
+  jmp alltraps
+.globl vector205
+vector205:
+  pushl $0
+  pushl $205
+  jmp alltraps
+.globl vector206
+vector206:
+  pushl $0
+  pushl $206
+  jmp alltraps
+.globl vector207
+vector207:
+  pushl $0
+  pushl $207
+  jmp alltraps
+.globl vector208
+vector208:
+  pushl $0
+  pushl $208
+  jmp alltraps
+.globl vector209
+vector209:
+  pushl $0
+  pushl $209
+  jmp alltraps
+.globl vector210
+vector210:
+  pushl $0
+  pushl $210
+  jmp alltraps
+.globl vector211
+vector211:
+  pushl $0
+  pushl $211
+  jmp alltraps
+.globl vector212
+vector212:
+  pushl $0
+  pushl $212
+  jmp alltraps
+.globl vector213
+vector213:
+  pushl $0
+  pushl $213
+  jmp alltraps
+.globl vector214
+vector214:
+  pushl $0
+  pushl $214
+  jmp alltraps
+.globl vector215
+vector215:
+  pushl $0
+  pushl $215
+  jmp alltraps
+.globl vector216
+vector216:
+  pushl $0
+  pushl $216
+  jmp alltraps
+.globl vector217
+vector217:
+  pushl $0
+  pushl $217
+  jmp alltraps
+.globl vector218
+vector218:
+  pushl $0
+  pushl $218
+  jmp alltraps
+.globl vector219
+vector219:
+  pushl $0
+  pushl $219
+  jmp alltraps
+.globl vector220
+vector220:
+  pushl $0
+  pushl $220
+  jmp alltraps
+.globl vector221
+vector221:
+  pushl $0
+  pushl $221
+  jmp alltraps
+.globl vector222
+vector222:
+  pushl $0
+  pushl $222
+  jmp alltraps
+.globl vector223
+vector223:
+  pushl $0
+  pushl $223
+  jmp alltraps
+.globl vector224
+vector224:
+  pushl $0
+  pushl $224
+  jmp alltraps
+.globl vector225
+vector225:
+  pushl $0
+  pushl $225
+  jmp alltraps
+.globl vector226
+vector226:
+  pushl $0
+  pushl $226
+  jmp alltraps
+.globl vector227
+vector227:
+  pushl $0
+  pushl $227
+  jmp alltraps
+.globl vector228
+vector228:
+  pushl $0
+  pushl $228
+  jmp alltraps
+.globl vector229
+vector229:
+  pushl $0
+  pushl $229
+  jmp alltraps
+.globl vector230
+vector230:
+  pushl $0
+  pushl $230
+  jmp alltraps
+.globl vector231
+vector231:
+  pushl $0
+  pushl $231
+  jmp alltraps
+.globl vector232
+vector232:
+  pushl $0
+  pushl $232
+  jmp alltraps
+.globl vector233
+vector233:
+  pushl $0
+  pushl $233
+  jmp alltraps
+.globl vector234
+vector234:
+  pushl $0
+  pushl $234
+  jmp alltraps
+.globl vector235
+vector235:
+  pushl $0
+  pushl $235
+  jmp alltraps
+.globl vector236
+vector236:
+  pushl $0
+  pushl $236
+  jmp alltraps
+.globl vector237
+vector237:
+  pushl $0
+  pushl $237
+  jmp alltraps
+.globl vector238
+vector238:
+  pushl $0
+  pushl $238
+  jmp alltraps
+.globl vector239
+vector239:
+  pushl $0
+  pushl $239
+  jmp alltraps
+.globl vector240
+vector240:
+  pushl $0
+  pushl $240
+  jmp alltraps
+.globl vector241
+vector241:
+  pushl $0
+  pushl $241
+  jmp alltraps
+.globl vector242
+vector242:
+  pushl $0
+  pushl $242
+  jmp alltraps
+.globl vector243
+vector243:
+  pushl $0
+  pushl $243
+  jmp alltraps
+.globl vector244
+vector244:
+  pushl $0
+  pushl $244
+  jmp alltraps
+.globl vector245
+vector245:
+  pushl $0
+  pushl $245
+  jmp alltraps
+.globl vector246
+vector246:
+  pushl $0
+  pushl $246
+  jmp alltraps
+.globl vector247
+vector247:
+  pushl $0
+  pushl $247
+  jmp alltraps
+.globl vector248
+vector248:
+  pushl $0
+  pushl $248
+  jmp alltraps
+.globl vector249
+vector249:
+  pushl $0
+  pushl $249
+  jmp alltraps
+.globl vector250
+vector250:
+  pushl $0
+  pushl $250
+  jmp alltraps
+.globl vector251
+vector251:
+  pushl $0
+  pushl $251
+  jmp alltraps
+.globl vector252
+vector252:
+  pushl $0
+  pushl $252
+  jmp alltraps
+.globl vector253
+vector253:
+  pushl $0
+  pushl $253
+  jmp alltraps
+.globl vector254
+vector254:
+  pushl $0
+  pushl $254
+  jmp alltraps
+.globl vector255
+vector255:
+  pushl $0
+  pushl $255
+  jmp alltraps
+
+# vector table
+.data
+.globl vectors
+vectors:
+  .long vector0
+  .long vector1
+  .long vector2
+  .long vector3
+  .long vector4
+  .long vector5
+  .long vector6
+  .long vector7
+  .long vector8
+  .long vector9
+  .long vector10
+  .long vector11
+  .long vector12
+  .long vector13
+  .long vector14
+  .long vector15
+  .long vector16
+  .long vector17
+  .long vector18
+  .long vector19
+  .long vector20
+  .long vector21
+  .long vector22
+  .long vector23
+  .long vector24
+  .long vector25
+  .long vector26
+  .long vector27
+  .long vector28
+  .long vector29
+  .long vector30
+  .long vector31
+  .long vector32
+  .long vector33
+  .long vector34
+  .long vector35
+  .long vector36
+  .long vector37
+  .long vector38
+  .long vector39
+  .long vector40
+  .long vector41
+  .long vector42
+  .long vector43
+  .long vector44
+  .long vector45
+  .long vector46
+  .long vector47
+  .long vector48
+  .long vector49
+  .long vector50
+  .long vector51
+  .long vector52
+  .long vector53
+  .long vector54
+  .long vector55
+  .long vector56
+  .long vector57
+  .long vector58
+  .long vector59
+  .long vector60
+  .long vector61
+  .long vector62
+  .long vector63
+  .long vector64
+  .long vector65
+  .long vector66
+  .long vector67
+  .long vector68
+  .long vector69
+  .long vector70
+  .long vector71
+  .long vector72
+  .long vector73
+  .long vector74
+  .long vector75
+  .long vector76
+  .long vector77
+  .long vector78
+  .long vector79
+  .long vector80
+  .long vector81
+  .long vector82
+  .long vector83
+  .long vector84
+  .long vector85
+  .long vector86
+  .long vector87
+  .long vector88
+  .long vector89
+  .long vector90
+  .long vector91
+  .long vector92
+  .long vector93
+  .long vector94
+  .long vector95
+  .long vector96
+  .long vector97
+  .long vector98
+  .long vector99
+  .long vector100
+  .long vector101
+  .long vector102
+  .long vector103
+  .long vector104
+  .long vector105
+  .long vector106
+  .long vector107
+  .long vector108
+  .long vector109
+  .long vector110
+  .long vector111
+  .long vector112
+  .long vector113
+  .long vector114
+  .long vector115
+  .long vector116
+  .long vector117
+  .long vector118
+  .long vector119
+  .long vector120
+  .long vector121
+  .long vector122
+  .long vector123
+  .long vector124
+  .long vector125
+  .long vector126
+  .long vector127
+  .long vector128
+  .long vector129
+  .long vector130
+  .long vector131
+  .long vector132
+  .long vector133
+  .long vector134
+  .long vector135
+  .long vector136
+  .long vector137
+  .long vector138
+  .long vector139
+  .long vector140
+  .long vector141
+  .long vector142
+  .long vector143
+  .long vector144
+  .long vector145
+  .long vector146
+  .long vector147
+  .long vector148
+  .long vector149
+  .long vector150
+  .long vector151
+  .long vector152
+  .long vector153
+  .long vector154
+  .long vector155
+  .long vector156
+  .long vector157
+  .long vector158
+  .long vector159
+  .long vector160
+  .long vector161
+  .long vector162
+  .long vector163
+  .long vector164
+  .long vector165
+  .long vector166
+  .long vector167
+  .long vector168
+  .long vector169
+  .long vector170
+  .long vector171
+  .long vector172
+  .long vector173
+  .long vector174
+  .long vector175
+  .long vector176
+  .long vector177
+  .long vector178
+  .long vector179
+  .long vector180
+  .long vector181
+  .long vector182
+  .long vector183
+  .long vector184
+  .long vector185
+  .long vector186
+  .long vector187
+  .long vector188
+  .long vector189
+  .long vector190
+  .long vector191
+  .long vector192
+  .long vector193
+  .long vector194
+  .long vector195
+  .long vector196
+  .long vector197
+  .long vector198
+  .long vector199
+  .long vector200
+  .long vector201
+  .long vector202
+  .long vector203
+  .long vector204
+  .long vector205
+  .long vector206
+  .long vector207
+  .long vector208
+  .long vector209
+  .long vector210
+  .long vector211
+  .long vector212
+  .long vector213
+  .long vector214
+  .long vector215
+  .long vector216
+  .long vector217
+  .long vector218
+  .long vector219
+  .long vector220
+  .long vector221
+  .long vector222
+  .long vector223
+  .long vector224
+  .long vector225
+  .long vector226
+  .long vector227
+  .long vector228
+  .long vector229
+  .long vector230
+  .long vector231
+  .long vector232
+  .long vector233
+  .long vector234
+  .long vector235
+  .long vector236
+  .long vector237
+  .long vector238
+  .long vector239
+  .long vector240
+  .long vector241
+  .long vector242
+  .long vector243
+  .long vector244
+  .long vector245
+  .long vector246
+  .long vector247
+  .long vector248
+  .long vector249
+  .long vector250
+  .long vector251
+  .long vector252
+  .long vector253
+  .long vector254
+  .long vector255
diff --git a/vectors.o b/vectors.o
new file mode 100644
index 0000000..1108491
Binary files /dev/null and b/vectors.o differ
diff --git a/vm.c b/vm.c
index 7134cff..f623aa3 100644
--- a/vm.c
+++ b/vm.c
@@ -57,7 +57,7 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
 // Create PTEs for virtual addresses starting at va that refer to
 // physical addresses starting at pa. va and size might not
 // be page-aligned.
-static int
+int
 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
 {
   char *a, *last;
@@ -332,10 +332,8 @@ copyuvm(pde_t *pgdir, uint sz)
     if((mem = kalloc()) == 0)
       goto bad;
     memmove(mem, (char*)P2V(pa), PGSIZE);
-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
-      kfree(mem);
+    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0)
       goto bad;
-    }
   }
   return d;
 
diff --git a/vm.d b/vm.d
new file mode 100644
index 0000000..51631b1
--- /dev/null
+++ b/vm.d
@@ -0,0 +1,2 @@
+vm.o: vm.c /usr/include/stdc-predef.h param.h types.h defs.h x86.h \
+ memlayout.h mmu.h proc.h elf.h
diff --git a/vm.o b/vm.o
new file mode 100644
index 0000000..21de52d
Binary files /dev/null and b/vm.o differ
diff --git a/wc.asm b/wc.asm
new file mode 100644
index 0000000..34b877e
--- /dev/null
+++ b/wc.asm
@@ -0,0 +1,1356 @@
+
+_wc:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+  printf(1, "%d %d %d %s\n", l, w, c, name);
+}
+
+int
+main(int argc, char *argv[])
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	57                   	push   %edi
+    1004:	56                   	push   %esi
+  int fd, i;
+
+  if(argc <= 1){
+    1005:	be 01 00 00 00       	mov    $0x1,%esi
+{
+    100a:	53                   	push   %ebx
+    100b:	83 e4 f0             	and    $0xfffffff0,%esp
+    100e:	83 ec 10             	sub    $0x10,%esp
+    1011:	8b 45 0c             	mov    0xc(%ebp),%eax
+  if(argc <= 1){
+    1014:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+    1018:	8d 58 04             	lea    0x4(%eax),%ebx
+    101b:	7e 60                	jle    107d <main+0x7d>
+    101d:	8d 76 00             	lea    0x0(%esi),%esi
+    wc(0, "");
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+    if((fd = open(argv[i], 0)) < 0){
+    1020:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1027:	00 
+    1028:	8b 03                	mov    (%ebx),%eax
+    102a:	89 04 24             	mov    %eax,(%esp)
+    102d:	e8 c0 03 00 00       	call   13f2 <open>
+    1032:	85 c0                	test   %eax,%eax
+    1034:	89 c7                	mov    %eax,%edi
+    1036:	78 26                	js     105e <main+0x5e>
+      printf(1, "wc: cannot open %s\n", argv[i]);
+      exit();
+    }
+    wc(fd, argv[i]);
+    1038:	8b 13                	mov    (%ebx),%edx
+  for(i = 1; i < argc; i++){
+    103a:	83 c6 01             	add    $0x1,%esi
+    103d:	83 c3 04             	add    $0x4,%ebx
+    wc(fd, argv[i]);
+    1040:	89 04 24             	mov    %eax,(%esp)
+    1043:	89 54 24 04          	mov    %edx,0x4(%esp)
+    1047:	e8 54 00 00 00       	call   10a0 <wc>
+    close(fd);
+    104c:	89 3c 24             	mov    %edi,(%esp)
+    104f:	e8 86 03 00 00       	call   13da <close>
+  for(i = 1; i < argc; i++){
+    1054:	3b 75 08             	cmp    0x8(%ebp),%esi
+    1057:	75 c7                	jne    1020 <main+0x20>
+  }
+  exit();
+    1059:	e8 54 03 00 00       	call   13b2 <exit>
+      printf(1, "wc: cannot open %s\n", argv[i]);
+    105e:	8b 03                	mov    (%ebx),%eax
+    1060:	c7 44 24 04 d4 18 00 	movl   $0x18d4,0x4(%esp)
+    1067:	00 
+    1068:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    106f:	89 44 24 08          	mov    %eax,0x8(%esp)
+    1073:	e8 98 04 00 00       	call   1510 <printf>
+      exit();
+    1078:	e8 35 03 00 00       	call   13b2 <exit>
+    wc(0, "");
+    107d:	c7 44 24 04 c6 18 00 	movl   $0x18c6,0x4(%esp)
+    1084:	00 
+    1085:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    108c:	e8 0f 00 00 00       	call   10a0 <wc>
+    exit();
+    1091:	e8 1c 03 00 00       	call   13b2 <exit>
+    1096:	66 90                	xchg   %ax,%ax
+    1098:	66 90                	xchg   %ax,%ax
+    109a:	66 90                	xchg   %ax,%ax
+    109c:	66 90                	xchg   %ax,%ax
+    109e:	66 90                	xchg   %ax,%ax
+
+000010a0 <wc>:
+{
+    10a0:	55                   	push   %ebp
+    10a1:	89 e5                	mov    %esp,%ebp
+    10a3:	57                   	push   %edi
+    10a4:	56                   	push   %esi
+  inword = 0;
+    10a5:	31 f6                	xor    %esi,%esi
+{
+    10a7:	53                   	push   %ebx
+  l = w = c = 0;
+    10a8:	31 db                	xor    %ebx,%ebx
+{
+    10aa:	83 ec 3c             	sub    $0x3c,%esp
+  l = w = c = 0;
+    10ad:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+    10b4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+    10bb:	90                   	nop
+    10bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+    10c0:	8b 45 08             	mov    0x8(%ebp),%eax
+    10c3:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
+    10ca:	00 
+    10cb:	c7 44 24 04 00 1c 00 	movl   $0x1c00,0x4(%esp)
+    10d2:	00 
+    10d3:	89 04 24             	mov    %eax,(%esp)
+    10d6:	e8 ef 02 00 00       	call   13ca <read>
+    10db:	83 f8 00             	cmp    $0x0,%eax
+    10de:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    10e1:	7e 54                	jle    1137 <wc+0x97>
+    10e3:	31 ff                	xor    %edi,%edi
+    10e5:	eb 0b                	jmp    10f2 <wc+0x52>
+    10e7:	90                   	nop
+        inword = 0;
+    10e8:	31 f6                	xor    %esi,%esi
+    for(i=0; i<n; i++){
+    10ea:	83 c7 01             	add    $0x1,%edi
+    10ed:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
+    10f0:	74 38                	je     112a <wc+0x8a>
+      if(buf[i] == '\n')
+    10f2:	0f be 87 00 1c 00 00 	movsbl 0x1c00(%edi),%eax
+        l++;
+    10f9:	31 c9                	xor    %ecx,%ecx
+      if(strchr(" \r\t\n\v", buf[i]))
+    10fb:	c7 04 24 b1 18 00 00 	movl   $0x18b1,(%esp)
+        l++;
+    1102:	3c 0a                	cmp    $0xa,%al
+    1104:	0f 94 c1             	sete   %cl
+      if(strchr(" \r\t\n\v", buf[i]))
+    1107:	89 44 24 04          	mov    %eax,0x4(%esp)
+        l++;
+    110b:	01 cb                	add    %ecx,%ebx
+      if(strchr(" \r\t\n\v", buf[i]))
+    110d:	e8 4e 01 00 00       	call   1260 <strchr>
+    1112:	85 c0                	test   %eax,%eax
+    1114:	75 d2                	jne    10e8 <wc+0x48>
+      else if(!inword){
+    1116:	85 f6                	test   %esi,%esi
+    1118:	75 16                	jne    1130 <wc+0x90>
+        w++;
+    111a:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+    for(i=0; i<n; i++){
+    111e:	83 c7 01             	add    $0x1,%edi
+    1121:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
+        inword = 1;
+    1124:	66 be 01 00          	mov    $0x1,%si
+    for(i=0; i<n; i++){
+    1128:	75 c8                	jne    10f2 <wc+0x52>
+    112a:	01 7d dc             	add    %edi,-0x24(%ebp)
+    112d:	eb 91                	jmp    10c0 <wc+0x20>
+    112f:	90                   	nop
+    1130:	be 01 00 00 00       	mov    $0x1,%esi
+    1135:	eb b3                	jmp    10ea <wc+0x4a>
+  if(n < 0){
+    1137:	75 35                	jne    116e <wc+0xce>
+  printf(1, "%d %d %d %s\n", l, w, c, name);
+    1139:	8b 45 0c             	mov    0xc(%ebp),%eax
+    113c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+    1140:	c7 44 24 04 c7 18 00 	movl   $0x18c7,0x4(%esp)
+    1147:	00 
+    1148:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    114f:	89 44 24 14          	mov    %eax,0x14(%esp)
+    1153:	8b 45 dc             	mov    -0x24(%ebp),%eax
+    1156:	89 44 24 10          	mov    %eax,0x10(%esp)
+    115a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+    115d:	89 44 24 0c          	mov    %eax,0xc(%esp)
+    1161:	e8 aa 03 00 00       	call   1510 <printf>
+}
+    1166:	83 c4 3c             	add    $0x3c,%esp
+    1169:	5b                   	pop    %ebx
+    116a:	5e                   	pop    %esi
+    116b:	5f                   	pop    %edi
+    116c:	5d                   	pop    %ebp
+    116d:	c3                   	ret    
+    printf(1, "wc: read error\n");
+    116e:	c7 44 24 04 b7 18 00 	movl   $0x18b7,0x4(%esp)
+    1175:	00 
+    1176:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    117d:	e8 8e 03 00 00       	call   1510 <printf>
+    exit();
+    1182:	e8 2b 02 00 00       	call   13b2 <exit>
+    1187:	66 90                	xchg   %ax,%ax
+    1189:	66 90                	xchg   %ax,%ax
+    118b:	66 90                	xchg   %ax,%ax
+    118d:	66 90                	xchg   %ax,%ax
+    118f:	90                   	nop
+
+00001190 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1190:	55                   	push   %ebp
+    1191:	89 e5                	mov    %esp,%ebp
+    1193:	8b 45 08             	mov    0x8(%ebp),%eax
+    1196:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1199:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    119a:	89 c2                	mov    %eax,%edx
+    119c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    11a0:	83 c1 01             	add    $0x1,%ecx
+    11a3:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    11a7:	83 c2 01             	add    $0x1,%edx
+    11aa:	84 db                	test   %bl,%bl
+    11ac:	88 5a ff             	mov    %bl,-0x1(%edx)
+    11af:	75 ef                	jne    11a0 <strcpy+0x10>
+    ;
+  return os;
+}
+    11b1:	5b                   	pop    %ebx
+    11b2:	5d                   	pop    %ebp
+    11b3:	c3                   	ret    
+    11b4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    11ba:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+000011c0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    11c0:	55                   	push   %ebp
+    11c1:	89 e5                	mov    %esp,%ebp
+    11c3:	8b 55 08             	mov    0x8(%ebp),%edx
+    11c6:	53                   	push   %ebx
+    11c7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    11ca:	0f b6 02             	movzbl (%edx),%eax
+    11cd:	84 c0                	test   %al,%al
+    11cf:	74 2d                	je     11fe <strcmp+0x3e>
+    11d1:	0f b6 19             	movzbl (%ecx),%ebx
+    11d4:	38 d8                	cmp    %bl,%al
+    11d6:	74 0e                	je     11e6 <strcmp+0x26>
+    11d8:	eb 2b                	jmp    1205 <strcmp+0x45>
+    11da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    11e0:	38 c8                	cmp    %cl,%al
+    11e2:	75 15                	jne    11f9 <strcmp+0x39>
+    p++, q++;
+    11e4:	89 d9                	mov    %ebx,%ecx
+    11e6:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    11e9:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    11ec:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    11ef:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    11f3:	84 c0                	test   %al,%al
+    11f5:	75 e9                	jne    11e0 <strcmp+0x20>
+    11f7:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    11f9:	29 c8                	sub    %ecx,%eax
+}
+    11fb:	5b                   	pop    %ebx
+    11fc:	5d                   	pop    %ebp
+    11fd:	c3                   	ret    
+    11fe:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    1201:	31 c0                	xor    %eax,%eax
+    1203:	eb f4                	jmp    11f9 <strcmp+0x39>
+    1205:	0f b6 cb             	movzbl %bl,%ecx
+    1208:	eb ef                	jmp    11f9 <strcmp+0x39>
+    120a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001210 <strlen>:
+
+uint
+strlen(char *s)
+{
+    1210:	55                   	push   %ebp
+    1211:	89 e5                	mov    %esp,%ebp
+    1213:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    1216:	80 39 00             	cmpb   $0x0,(%ecx)
+    1219:	74 12                	je     122d <strlen+0x1d>
+    121b:	31 d2                	xor    %edx,%edx
+    121d:	8d 76 00             	lea    0x0(%esi),%esi
+    1220:	83 c2 01             	add    $0x1,%edx
+    1223:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    1227:	89 d0                	mov    %edx,%eax
+    1229:	75 f5                	jne    1220 <strlen+0x10>
+    ;
+  return n;
+}
+    122b:	5d                   	pop    %ebp
+    122c:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    122d:	31 c0                	xor    %eax,%eax
+}
+    122f:	5d                   	pop    %ebp
+    1230:	c3                   	ret    
+    1231:	eb 0d                	jmp    1240 <memset>
+    1233:	90                   	nop
+    1234:	90                   	nop
+    1235:	90                   	nop
+    1236:	90                   	nop
+    1237:	90                   	nop
+    1238:	90                   	nop
+    1239:	90                   	nop
+    123a:	90                   	nop
+    123b:	90                   	nop
+    123c:	90                   	nop
+    123d:	90                   	nop
+    123e:	90                   	nop
+    123f:	90                   	nop
+
+00001240 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    1240:	55                   	push   %ebp
+    1241:	89 e5                	mov    %esp,%ebp
+    1243:	8b 55 08             	mov    0x8(%ebp),%edx
+    1246:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    1247:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    124a:	8b 45 0c             	mov    0xc(%ebp),%eax
+    124d:	89 d7                	mov    %edx,%edi
+    124f:	fc                   	cld    
+    1250:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    1252:	89 d0                	mov    %edx,%eax
+    1254:	5f                   	pop    %edi
+    1255:	5d                   	pop    %ebp
+    1256:	c3                   	ret    
+    1257:	89 f6                	mov    %esi,%esi
+    1259:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001260 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    1260:	55                   	push   %ebp
+    1261:	89 e5                	mov    %esp,%ebp
+    1263:	8b 45 08             	mov    0x8(%ebp),%eax
+    1266:	53                   	push   %ebx
+    1267:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    126a:	0f b6 18             	movzbl (%eax),%ebx
+    126d:	84 db                	test   %bl,%bl
+    126f:	74 1d                	je     128e <strchr+0x2e>
+    if(*s == c)
+    1271:	38 d3                	cmp    %dl,%bl
+    1273:	89 d1                	mov    %edx,%ecx
+    1275:	75 0d                	jne    1284 <strchr+0x24>
+    1277:	eb 17                	jmp    1290 <strchr+0x30>
+    1279:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1280:	38 ca                	cmp    %cl,%dl
+    1282:	74 0c                	je     1290 <strchr+0x30>
+  for(; *s; s++)
+    1284:	83 c0 01             	add    $0x1,%eax
+    1287:	0f b6 10             	movzbl (%eax),%edx
+    128a:	84 d2                	test   %dl,%dl
+    128c:	75 f2                	jne    1280 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    128e:	31 c0                	xor    %eax,%eax
+}
+    1290:	5b                   	pop    %ebx
+    1291:	5d                   	pop    %ebp
+    1292:	c3                   	ret    
+    1293:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+000012a0 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    12a0:	55                   	push   %ebp
+    12a1:	89 e5                	mov    %esp,%ebp
+    12a3:	57                   	push   %edi
+    12a4:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    12a5:	31 f6                	xor    %esi,%esi
+{
+    12a7:	53                   	push   %ebx
+    12a8:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    12ab:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    12ae:	eb 31                	jmp    12e1 <gets+0x41>
+    cc = read(0, &c, 1);
+    12b0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    12b7:	00 
+    12b8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    12bc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    12c3:	e8 02 01 00 00       	call   13ca <read>
+    if(cc < 1)
+    12c8:	85 c0                	test   %eax,%eax
+    12ca:	7e 1d                	jle    12e9 <gets+0x49>
+      break;
+    buf[i++] = c;
+    12cc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    12d0:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    12d2:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    12d5:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    12d7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    12db:	74 0c                	je     12e9 <gets+0x49>
+    12dd:	3c 0a                	cmp    $0xa,%al
+    12df:	74 08                	je     12e9 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    12e1:	8d 5e 01             	lea    0x1(%esi),%ebx
+    12e4:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    12e7:	7c c7                	jl     12b0 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    12e9:	8b 45 08             	mov    0x8(%ebp),%eax
+    12ec:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    12f0:	83 c4 2c             	add    $0x2c,%esp
+    12f3:	5b                   	pop    %ebx
+    12f4:	5e                   	pop    %esi
+    12f5:	5f                   	pop    %edi
+    12f6:	5d                   	pop    %ebp
+    12f7:	c3                   	ret    
+    12f8:	90                   	nop
+    12f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001300 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    1300:	55                   	push   %ebp
+    1301:	89 e5                	mov    %esp,%ebp
+    1303:	56                   	push   %esi
+    1304:	53                   	push   %ebx
+    1305:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    1308:	8b 45 08             	mov    0x8(%ebp),%eax
+    130b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    1312:	00 
+    1313:	89 04 24             	mov    %eax,(%esp)
+    1316:	e8 d7 00 00 00       	call   13f2 <open>
+  if(fd < 0)
+    131b:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    131d:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    131f:	78 27                	js     1348 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    1321:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1324:	89 1c 24             	mov    %ebx,(%esp)
+    1327:	89 44 24 04          	mov    %eax,0x4(%esp)
+    132b:	e8 da 00 00 00       	call   140a <fstat>
+  close(fd);
+    1330:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    1333:	89 c6                	mov    %eax,%esi
+  close(fd);
+    1335:	e8 a0 00 00 00       	call   13da <close>
+  return r;
+    133a:	89 f0                	mov    %esi,%eax
+}
+    133c:	83 c4 10             	add    $0x10,%esp
+    133f:	5b                   	pop    %ebx
+    1340:	5e                   	pop    %esi
+    1341:	5d                   	pop    %ebp
+    1342:	c3                   	ret    
+    1343:	90                   	nop
+    1344:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    1348:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    134d:	eb ed                	jmp    133c <stat+0x3c>
+    134f:	90                   	nop
+
+00001350 <atoi>:
+
+int
+atoi(const char *s)
+{
+    1350:	55                   	push   %ebp
+    1351:	89 e5                	mov    %esp,%ebp
+    1353:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    1356:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    1357:	0f be 11             	movsbl (%ecx),%edx
+    135a:	8d 42 d0             	lea    -0x30(%edx),%eax
+    135d:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    135f:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    1364:	77 17                	ja     137d <atoi+0x2d>
+    1366:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    1368:	83 c1 01             	add    $0x1,%ecx
+    136b:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    136e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1372:	0f be 11             	movsbl (%ecx),%edx
+    1375:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1378:	80 fb 09             	cmp    $0x9,%bl
+    137b:	76 eb                	jbe    1368 <atoi+0x18>
+  return n;
+}
+    137d:	5b                   	pop    %ebx
+    137e:	5d                   	pop    %ebp
+    137f:	c3                   	ret    
+
+00001380 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1380:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1381:	31 d2                	xor    %edx,%edx
+{
+    1383:	89 e5                	mov    %esp,%ebp
+    1385:	56                   	push   %esi
+    1386:	8b 45 08             	mov    0x8(%ebp),%eax
+    1389:	53                   	push   %ebx
+    138a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    138d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1390:	85 db                	test   %ebx,%ebx
+    1392:	7e 12                	jle    13a6 <memmove+0x26>
+    1394:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1398:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    139c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    139f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    13a2:	39 da                	cmp    %ebx,%edx
+    13a4:	75 f2                	jne    1398 <memmove+0x18>
+  return vdst;
+}
+    13a6:	5b                   	pop    %ebx
+    13a7:	5e                   	pop    %esi
+    13a8:	5d                   	pop    %ebp
+    13a9:	c3                   	ret    
+
+000013aa <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    13aa:	b8 01 00 00 00       	mov    $0x1,%eax
+    13af:	cd 40                	int    $0x40
+    13b1:	c3                   	ret    
+
+000013b2 <exit>:
+SYSCALL(exit)
+    13b2:	b8 02 00 00 00       	mov    $0x2,%eax
+    13b7:	cd 40                	int    $0x40
+    13b9:	c3                   	ret    
+
+000013ba <wait>:
+SYSCALL(wait)
+    13ba:	b8 03 00 00 00       	mov    $0x3,%eax
+    13bf:	cd 40                	int    $0x40
+    13c1:	c3                   	ret    
+
+000013c2 <pipe>:
+SYSCALL(pipe)
+    13c2:	b8 04 00 00 00       	mov    $0x4,%eax
+    13c7:	cd 40                	int    $0x40
+    13c9:	c3                   	ret    
+
+000013ca <read>:
+SYSCALL(read)
+    13ca:	b8 05 00 00 00       	mov    $0x5,%eax
+    13cf:	cd 40                	int    $0x40
+    13d1:	c3                   	ret    
+
+000013d2 <write>:
+SYSCALL(write)
+    13d2:	b8 10 00 00 00       	mov    $0x10,%eax
+    13d7:	cd 40                	int    $0x40
+    13d9:	c3                   	ret    
+
+000013da <close>:
+SYSCALL(close)
+    13da:	b8 15 00 00 00       	mov    $0x15,%eax
+    13df:	cd 40                	int    $0x40
+    13e1:	c3                   	ret    
+
+000013e2 <kill>:
+SYSCALL(kill)
+    13e2:	b8 06 00 00 00       	mov    $0x6,%eax
+    13e7:	cd 40                	int    $0x40
+    13e9:	c3                   	ret    
+
+000013ea <exec>:
+SYSCALL(exec)
+    13ea:	b8 07 00 00 00       	mov    $0x7,%eax
+    13ef:	cd 40                	int    $0x40
+    13f1:	c3                   	ret    
+
+000013f2 <open>:
+SYSCALL(open)
+    13f2:	b8 0f 00 00 00       	mov    $0xf,%eax
+    13f7:	cd 40                	int    $0x40
+    13f9:	c3                   	ret    
+
+000013fa <mknod>:
+SYSCALL(mknod)
+    13fa:	b8 11 00 00 00       	mov    $0x11,%eax
+    13ff:	cd 40                	int    $0x40
+    1401:	c3                   	ret    
+
+00001402 <unlink>:
+SYSCALL(unlink)
+    1402:	b8 12 00 00 00       	mov    $0x12,%eax
+    1407:	cd 40                	int    $0x40
+    1409:	c3                   	ret    
+
+0000140a <fstat>:
+SYSCALL(fstat)
+    140a:	b8 08 00 00 00       	mov    $0x8,%eax
+    140f:	cd 40                	int    $0x40
+    1411:	c3                   	ret    
+
+00001412 <link>:
+SYSCALL(link)
+    1412:	b8 13 00 00 00       	mov    $0x13,%eax
+    1417:	cd 40                	int    $0x40
+    1419:	c3                   	ret    
+
+0000141a <mkdir>:
+SYSCALL(mkdir)
+    141a:	b8 14 00 00 00       	mov    $0x14,%eax
+    141f:	cd 40                	int    $0x40
+    1421:	c3                   	ret    
+
+00001422 <chdir>:
+SYSCALL(chdir)
+    1422:	b8 09 00 00 00       	mov    $0x9,%eax
+    1427:	cd 40                	int    $0x40
+    1429:	c3                   	ret    
+
+0000142a <dup>:
+SYSCALL(dup)
+    142a:	b8 0a 00 00 00       	mov    $0xa,%eax
+    142f:	cd 40                	int    $0x40
+    1431:	c3                   	ret    
+
+00001432 <getpid>:
+SYSCALL(getpid)
+    1432:	b8 0b 00 00 00       	mov    $0xb,%eax
+    1437:	cd 40                	int    $0x40
+    1439:	c3                   	ret    
+
+0000143a <sbrk>:
+SYSCALL(sbrk)
+    143a:	b8 0c 00 00 00       	mov    $0xc,%eax
+    143f:	cd 40                	int    $0x40
+    1441:	c3                   	ret    
+
+00001442 <sleep>:
+SYSCALL(sleep)
+    1442:	b8 0d 00 00 00       	mov    $0xd,%eax
+    1447:	cd 40                	int    $0x40
+    1449:	c3                   	ret    
+
+0000144a <uptime>:
+SYSCALL(uptime)
+    144a:	b8 0e 00 00 00       	mov    $0xe,%eax
+    144f:	cd 40                	int    $0x40
+    1451:	c3                   	ret    
+
+00001452 <shm_open>:
+SYSCALL(shm_open)
+    1452:	b8 16 00 00 00       	mov    $0x16,%eax
+    1457:	cd 40                	int    $0x40
+    1459:	c3                   	ret    
+
+0000145a <shm_close>:
+SYSCALL(shm_close)	
+    145a:	b8 17 00 00 00       	mov    $0x17,%eax
+    145f:	cd 40                	int    $0x40
+    1461:	c3                   	ret    
+    1462:	66 90                	xchg   %ax,%ax
+    1464:	66 90                	xchg   %ax,%ax
+    1466:	66 90                	xchg   %ax,%ax
+    1468:	66 90                	xchg   %ax,%ax
+    146a:	66 90                	xchg   %ax,%ax
+    146c:	66 90                	xchg   %ax,%ax
+    146e:	66 90                	xchg   %ax,%ax
+
+00001470 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1470:	55                   	push   %ebp
+    1471:	89 e5                	mov    %esp,%ebp
+    1473:	57                   	push   %edi
+    1474:	56                   	push   %esi
+    1475:	89 c6                	mov    %eax,%esi
+    1477:	53                   	push   %ebx
+    1478:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    147b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    147e:	85 db                	test   %ebx,%ebx
+    1480:	74 09                	je     148b <printint+0x1b>
+    1482:	89 d0                	mov    %edx,%eax
+    1484:	c1 e8 1f             	shr    $0x1f,%eax
+    1487:	84 c0                	test   %al,%al
+    1489:	75 75                	jne    1500 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    148b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    148d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1494:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1497:	31 ff                	xor    %edi,%edi
+    1499:	89 ce                	mov    %ecx,%esi
+    149b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    149e:	eb 02                	jmp    14a2 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    14a0:	89 cf                	mov    %ecx,%edi
+    14a2:	31 d2                	xor    %edx,%edx
+    14a4:	f7 f6                	div    %esi
+    14a6:	8d 4f 01             	lea    0x1(%edi),%ecx
+    14a9:	0f b6 92 ef 18 00 00 	movzbl 0x18ef(%edx),%edx
+  }while((x /= base) != 0);
+    14b0:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    14b2:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    14b5:	75 e9                	jne    14a0 <printint+0x30>
+  if(neg)
+    14b7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    14ba:	89 c8                	mov    %ecx,%eax
+    14bc:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    14bf:	85 d2                	test   %edx,%edx
+    14c1:	74 08                	je     14cb <printint+0x5b>
+    buf[i++] = '-';
+    14c3:	8d 4f 02             	lea    0x2(%edi),%ecx
+    14c6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    14cb:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    14ce:	66 90                	xchg   %ax,%ax
+    14d0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    14d5:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    14d8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    14df:	00 
+    14e0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    14e4:	89 34 24             	mov    %esi,(%esp)
+    14e7:	88 45 d7             	mov    %al,-0x29(%ebp)
+    14ea:	e8 e3 fe ff ff       	call   13d2 <write>
+  while(--i >= 0)
+    14ef:	83 ff ff             	cmp    $0xffffffff,%edi
+    14f2:	75 dc                	jne    14d0 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    14f4:	83 c4 4c             	add    $0x4c,%esp
+    14f7:	5b                   	pop    %ebx
+    14f8:	5e                   	pop    %esi
+    14f9:	5f                   	pop    %edi
+    14fa:	5d                   	pop    %ebp
+    14fb:	c3                   	ret    
+    14fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    1500:	89 d0                	mov    %edx,%eax
+    1502:	f7 d8                	neg    %eax
+    neg = 1;
+    1504:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    150b:	eb 87                	jmp    1494 <printint+0x24>
+    150d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00001510 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    1510:	55                   	push   %ebp
+    1511:	89 e5                	mov    %esp,%ebp
+    1513:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    1514:	31 ff                	xor    %edi,%edi
+{
+    1516:	56                   	push   %esi
+    1517:	53                   	push   %ebx
+    1518:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    151b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    151e:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    1521:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    1524:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    1527:	0f b6 13             	movzbl (%ebx),%edx
+    152a:	83 c3 01             	add    $0x1,%ebx
+    152d:	84 d2                	test   %dl,%dl
+    152f:	75 39                	jne    156a <printf+0x5a>
+    1531:	e9 c2 00 00 00       	jmp    15f8 <printf+0xe8>
+    1536:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    1538:	83 fa 25             	cmp    $0x25,%edx
+    153b:	0f 84 bf 00 00 00    	je     1600 <printf+0xf0>
+  write(fd, &c, 1);
+    1541:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    1544:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    154b:	00 
+    154c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1550:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    1553:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    1556:	e8 77 fe ff ff       	call   13d2 <write>
+    155b:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    155e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    1562:	84 d2                	test   %dl,%dl
+    1564:	0f 84 8e 00 00 00    	je     15f8 <printf+0xe8>
+    if(state == 0){
+    156a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    156c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    156f:	74 c7                	je     1538 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1571:	83 ff 25             	cmp    $0x25,%edi
+    1574:	75 e5                	jne    155b <printf+0x4b>
+      if(c == 'd'){
+    1576:	83 fa 64             	cmp    $0x64,%edx
+    1579:	0f 84 31 01 00 00    	je     16b0 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    157f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1584:	83 f8 70             	cmp    $0x70,%eax
+    1587:	0f 84 83 00 00 00    	je     1610 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    158d:	83 fa 73             	cmp    $0x73,%edx
+    1590:	0f 84 a2 00 00 00    	je     1638 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1596:	83 fa 63             	cmp    $0x63,%edx
+    1599:	0f 84 35 01 00 00    	je     16d4 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    159f:	83 fa 25             	cmp    $0x25,%edx
+    15a2:	0f 84 e0 00 00 00    	je     1688 <printf+0x178>
+  write(fd, &c, 1);
+    15a8:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    15ab:	83 c3 01             	add    $0x1,%ebx
+    15ae:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    15b5:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    15b6:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    15b8:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15bc:	89 34 24             	mov    %esi,(%esp)
+    15bf:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    15c2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    15c6:	e8 07 fe ff ff       	call   13d2 <write>
+        putc(fd, c);
+    15cb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    15ce:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    15d1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    15d8:	00 
+    15d9:	89 44 24 04          	mov    %eax,0x4(%esp)
+    15dd:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    15e0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    15e3:	e8 ea fd ff ff       	call   13d2 <write>
+  for(i = 0; fmt[i]; i++){
+    15e8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    15ec:	84 d2                	test   %dl,%dl
+    15ee:	0f 85 76 ff ff ff    	jne    156a <printf+0x5a>
+    15f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    15f8:	83 c4 3c             	add    $0x3c,%esp
+    15fb:	5b                   	pop    %ebx
+    15fc:	5e                   	pop    %esi
+    15fd:	5f                   	pop    %edi
+    15fe:	5d                   	pop    %ebp
+    15ff:	c3                   	ret    
+        state = '%';
+    1600:	bf 25 00 00 00       	mov    $0x25,%edi
+    1605:	e9 51 ff ff ff       	jmp    155b <printf+0x4b>
+    160a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    1610:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1613:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    1618:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    161a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1621:	8b 10                	mov    (%eax),%edx
+    1623:	89 f0                	mov    %esi,%eax
+    1625:	e8 46 fe ff ff       	call   1470 <printint>
+        ap++;
+    162a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    162e:	e9 28 ff ff ff       	jmp    155b <printf+0x4b>
+    1633:	90                   	nop
+    1634:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    1638:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    163b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    163f:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    1641:	b8 e8 18 00 00       	mov    $0x18e8,%eax
+    1646:	85 ff                	test   %edi,%edi
+    1648:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    164b:	0f b6 07             	movzbl (%edi),%eax
+    164e:	84 c0                	test   %al,%al
+    1650:	74 2a                	je     167c <printf+0x16c>
+    1652:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1658:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    165b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    165e:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    1661:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1668:	00 
+    1669:	89 44 24 04          	mov    %eax,0x4(%esp)
+    166d:	89 34 24             	mov    %esi,(%esp)
+    1670:	e8 5d fd ff ff       	call   13d2 <write>
+        while(*s != 0){
+    1675:	0f b6 07             	movzbl (%edi),%eax
+    1678:	84 c0                	test   %al,%al
+    167a:	75 dc                	jne    1658 <printf+0x148>
+      state = 0;
+    167c:	31 ff                	xor    %edi,%edi
+    167e:	e9 d8 fe ff ff       	jmp    155b <printf+0x4b>
+    1683:	90                   	nop
+    1684:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1688:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    168b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    168d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1694:	00 
+    1695:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1699:	89 34 24             	mov    %esi,(%esp)
+    169c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    16a0:	e8 2d fd ff ff       	call   13d2 <write>
+    16a5:	e9 b1 fe ff ff       	jmp    155b <printf+0x4b>
+    16aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    16b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    16b3:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    16b8:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    16bb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    16c2:	8b 10                	mov    (%eax),%edx
+    16c4:	89 f0                	mov    %esi,%eax
+    16c6:	e8 a5 fd ff ff       	call   1470 <printint>
+        ap++;
+    16cb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    16cf:	e9 87 fe ff ff       	jmp    155b <printf+0x4b>
+        putc(fd, *ap);
+    16d4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    16d7:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    16d9:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    16db:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    16e2:	00 
+    16e3:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    16e6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    16e9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    16ec:	89 44 24 04          	mov    %eax,0x4(%esp)
+    16f0:	e8 dd fc ff ff       	call   13d2 <write>
+        ap++;
+    16f5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    16f9:	e9 5d fe ff ff       	jmp    155b <printf+0x4b>
+    16fe:	66 90                	xchg   %ax,%ax
+
+00001700 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    1700:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1701:	a1 e0 1b 00 00       	mov    0x1be0,%eax
+{
+    1706:	89 e5                	mov    %esp,%ebp
+    1708:	57                   	push   %edi
+    1709:	56                   	push   %esi
+    170a:	53                   	push   %ebx
+    170b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    170e:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    1710:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1713:	39 d0                	cmp    %edx,%eax
+    1715:	72 11                	jb     1728 <free+0x28>
+    1717:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1718:	39 c8                	cmp    %ecx,%eax
+    171a:	72 04                	jb     1720 <free+0x20>
+    171c:	39 ca                	cmp    %ecx,%edx
+    171e:	72 10                	jb     1730 <free+0x30>
+    1720:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1722:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1724:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1726:	73 f0                	jae    1718 <free+0x18>
+    1728:	39 ca                	cmp    %ecx,%edx
+    172a:	72 04                	jb     1730 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    172c:	39 c8                	cmp    %ecx,%eax
+    172e:	72 f0                	jb     1720 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    1730:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    1733:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    1736:	39 cf                	cmp    %ecx,%edi
+    1738:	74 1e                	je     1758 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    173a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    173d:	8b 48 04             	mov    0x4(%eax),%ecx
+    1740:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    1743:	39 f2                	cmp    %esi,%edx
+    1745:	74 28                	je     176f <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    1747:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    1749:	a3 e0 1b 00 00       	mov    %eax,0x1be0
+}
+    174e:	5b                   	pop    %ebx
+    174f:	5e                   	pop    %esi
+    1750:	5f                   	pop    %edi
+    1751:	5d                   	pop    %ebp
+    1752:	c3                   	ret    
+    1753:	90                   	nop
+    1754:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    1758:	03 71 04             	add    0x4(%ecx),%esi
+    175b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    175e:	8b 08                	mov    (%eax),%ecx
+    1760:	8b 09                	mov    (%ecx),%ecx
+    1762:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    1765:	8b 48 04             	mov    0x4(%eax),%ecx
+    1768:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    176b:	39 f2                	cmp    %esi,%edx
+    176d:	75 d8                	jne    1747 <free+0x47>
+    p->s.size += bp->s.size;
+    176f:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    1772:	a3 e0 1b 00 00       	mov    %eax,0x1be0
+    p->s.size += bp->s.size;
+    1777:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    177a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    177d:	89 10                	mov    %edx,(%eax)
+}
+    177f:	5b                   	pop    %ebx
+    1780:	5e                   	pop    %esi
+    1781:	5f                   	pop    %edi
+    1782:	5d                   	pop    %ebp
+    1783:	c3                   	ret    
+    1784:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    178a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001790 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1790:	55                   	push   %ebp
+    1791:	89 e5                	mov    %esp,%ebp
+    1793:	57                   	push   %edi
+    1794:	56                   	push   %esi
+    1795:	53                   	push   %ebx
+    1796:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1799:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    179c:	8b 1d e0 1b 00 00    	mov    0x1be0,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    17a2:	8d 48 07             	lea    0x7(%eax),%ecx
+    17a5:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    17a8:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    17aa:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    17ad:	0f 84 9b 00 00 00    	je     184e <malloc+0xbe>
+    17b3:	8b 13                	mov    (%ebx),%edx
+    17b5:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    17b8:	39 fe                	cmp    %edi,%esi
+    17ba:	76 64                	jbe    1820 <malloc+0x90>
+    17bc:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    17c3:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    17c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    17cb:	eb 0e                	jmp    17db <malloc+0x4b>
+    17cd:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    17d0:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    17d2:	8b 78 04             	mov    0x4(%eax),%edi
+    17d5:	39 fe                	cmp    %edi,%esi
+    17d7:	76 4f                	jbe    1828 <malloc+0x98>
+    17d9:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    17db:	3b 15 e0 1b 00 00    	cmp    0x1be0,%edx
+    17e1:	75 ed                	jne    17d0 <malloc+0x40>
+  if(nu < 4096)
+    17e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    17e6:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    17ec:	bf 00 10 00 00       	mov    $0x1000,%edi
+    17f1:	0f 43 fe             	cmovae %esi,%edi
+    17f4:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    17f7:	89 04 24             	mov    %eax,(%esp)
+    17fa:	e8 3b fc ff ff       	call   143a <sbrk>
+  if(p == (char*)-1)
+    17ff:	83 f8 ff             	cmp    $0xffffffff,%eax
+    1802:	74 18                	je     181c <malloc+0x8c>
+  hp->s.size = nu;
+    1804:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    1807:	83 c0 08             	add    $0x8,%eax
+    180a:	89 04 24             	mov    %eax,(%esp)
+    180d:	e8 ee fe ff ff       	call   1700 <free>
+  return freep;
+    1812:	8b 15 e0 1b 00 00    	mov    0x1be0,%edx
+      if((p = morecore(nunits)) == 0)
+    1818:	85 d2                	test   %edx,%edx
+    181a:	75 b4                	jne    17d0 <malloc+0x40>
+        return 0;
+    181c:	31 c0                	xor    %eax,%eax
+    181e:	eb 20                	jmp    1840 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    1820:	89 d0                	mov    %edx,%eax
+    1822:	89 da                	mov    %ebx,%edx
+    1824:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    1828:	39 fe                	cmp    %edi,%esi
+    182a:	74 1c                	je     1848 <malloc+0xb8>
+        p->s.size -= nunits;
+    182c:	29 f7                	sub    %esi,%edi
+    182e:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    1831:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    1834:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    1837:	89 15 e0 1b 00 00    	mov    %edx,0x1be0
+      return (void*)(p + 1);
+    183d:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    1840:	83 c4 1c             	add    $0x1c,%esp
+    1843:	5b                   	pop    %ebx
+    1844:	5e                   	pop    %esi
+    1845:	5f                   	pop    %edi
+    1846:	5d                   	pop    %ebp
+    1847:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    1848:	8b 08                	mov    (%eax),%ecx
+    184a:	89 0a                	mov    %ecx,(%edx)
+    184c:	eb e9                	jmp    1837 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    184e:	c7 05 e0 1b 00 00 e4 	movl   $0x1be4,0x1be0
+    1855:	1b 00 00 
+    base.s.size = 0;
+    1858:	ba e4 1b 00 00       	mov    $0x1be4,%edx
+    base.s.ptr = freep = prevp = &base;
+    185d:	c7 05 e4 1b 00 00 e4 	movl   $0x1be4,0x1be4
+    1864:	1b 00 00 
+    base.s.size = 0;
+    1867:	c7 05 e8 1b 00 00 00 	movl   $0x0,0x1be8
+    186e:	00 00 00 
+    1871:	e9 46 ff ff ff       	jmp    17bc <malloc+0x2c>
+    1876:	66 90                	xchg   %ax,%ax
+    1878:	66 90                	xchg   %ax,%ax
+    187a:	66 90                	xchg   %ax,%ax
+    187c:	66 90                	xchg   %ax,%ax
+    187e:	66 90                	xchg   %ax,%ax
+
+00001880 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1880:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1881:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1886:	89 e5                	mov    %esp,%ebp
+    1888:	8b 55 08             	mov    0x8(%ebp),%edx
+    188b:	90                   	nop
+    188c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1890:	89 c8                	mov    %ecx,%eax
+    1892:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1895:	85 c0                	test   %eax,%eax
+    1897:	75 f7                	jne    1890 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1899:	0f ae f0             	mfence 
+}
+    189c:	5d                   	pop    %ebp
+    189d:	c3                   	ret    
+    189e:	66 90                	xchg   %ax,%ax
+
+000018a0 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    18a0:	55                   	push   %ebp
+    18a1:	89 e5                	mov    %esp,%ebp
+    18a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    18a6:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    18a9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    18af:	5d                   	pop    %ebp
+    18b0:	c3                   	ret    
diff --git a/wc.c b/wc.c
index 08b93b6..d6a54df 100644
--- a/wc.c
+++ b/wc.c
@@ -27,7 +27,7 @@ wc(int fd, char *name)
   }
   if(n < 0){
     printf(1, "wc: read error\n");
-    exit(3);
+    exit();
   }
   printf(1, "%d %d %d %s\n", l, w, c, name);
 }
@@ -39,16 +39,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     wc(0, "");
-    exit(2);
+    exit();
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "wc: cannot open %s\n", argv[i]);
-      exit(1);
+      exit();
     }
     wc(fd, argv[i]);
     close(fd);
   }
-  exit(0);
+  exit();
 }
diff --git a/wc.d b/wc.d
new file mode 100644
index 0000000..6adc498
--- /dev/null
+++ b/wc.d
@@ -0,0 +1 @@
+wc.o: wc.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/wc.o b/wc.o
new file mode 100644
index 0000000..2d83b08
Binary files /dev/null and b/wc.o differ
diff --git a/wc.sym b/wc.sym
new file mode 100644
index 0000000..00eca90
--- /dev/null
+++ b/wc.sym
@@ -0,0 +1,64 @@
+00001000 .text
+000018b1 .rodata
+00001900 .eh_frame
+00001be0 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 wc.c
+00000000 ulib.c
+00000000 printf.c
+00001470 printint
+000018ef digits.1359
+00000000 umalloc.c
+00001be0 freep
+00001be4 base
+00000000 uspinlock.c
+00001190 strcpy
+00001510 printf
+00001380 memmove
+000013fa mknod
+00001452 shm_open
+000012a0 gets
+00001432 getpid
+00001790 malloc
+00001442 sleep
+000013c2 pipe
+000013d2 write
+0000140a fstat
+000013e2 kill
+00001422 chdir
+000013ea exec
+000013ba wait
+000013ca read
+00001402 unlink
+000010a0 wc
+00001880 uacquire
+000013aa fork
+0000143a sbrk
+0000145a shm_close
+0000144a uptime
+00001bdc __bss_start
+00001240 memset
+00001000 main
+000011c0 strcmp
+0000142a dup
+00001c00 buf
+00001300 stat
+00001bdc _edata
+00001e00 _end
+00001412 link
+000013b2 exit
+00001350 atoi
+00001210 strlen
+000013f2 open
+00001260 strchr
+0000141a mkdir
+000013da close
+000018a0 urelease
+00001700 free
diff --git a/xv6.img b/xv6.img
new file mode 100644
index 0000000..44c554a
Binary files /dev/null and b/xv6.img differ
diff --git a/zombie.asm b/zombie.asm
new file mode 100644
index 0000000..0da4de6
--- /dev/null
+++ b/zombie.asm
@@ -0,0 +1,1195 @@
+
+_zombie:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00001000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(void)
+{
+    1000:	55                   	push   %ebp
+    1001:	89 e5                	mov    %esp,%ebp
+    1003:	83 e4 f0             	and    $0xfffffff0,%esp
+    1006:	83 ec 10             	sub    $0x10,%esp
+  if(fork() > 0)
+    1009:	e8 3c 02 00 00       	call   124a <fork>
+    100e:	85 c0                	test   %eax,%eax
+    1010:	7e 0c                	jle    101e <main+0x1e>
+    sleep(5);  // Let child exit before parent.
+    1012:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
+    1019:	e8 c4 02 00 00       	call   12e2 <sleep>
+  exit();
+    101e:	e8 2f 02 00 00       	call   1252 <exit>
+    1023:	66 90                	xchg   %ax,%ax
+    1025:	66 90                	xchg   %ax,%ax
+    1027:	66 90                	xchg   %ax,%ax
+    1029:	66 90                	xchg   %ax,%ax
+    102b:	66 90                	xchg   %ax,%ax
+    102d:	66 90                	xchg   %ax,%ax
+    102f:	90                   	nop
+
+00001030 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, char *t)
+{
+    1030:	55                   	push   %ebp
+    1031:	89 e5                	mov    %esp,%ebp
+    1033:	8b 45 08             	mov    0x8(%ebp),%eax
+    1036:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+    1039:	53                   	push   %ebx
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    103a:	89 c2                	mov    %eax,%edx
+    103c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1040:	83 c1 01             	add    $0x1,%ecx
+    1043:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+    1047:	83 c2 01             	add    $0x1,%edx
+    104a:	84 db                	test   %bl,%bl
+    104c:	88 5a ff             	mov    %bl,-0x1(%edx)
+    104f:	75 ef                	jne    1040 <strcpy+0x10>
+    ;
+  return os;
+}
+    1051:	5b                   	pop    %ebx
+    1052:	5d                   	pop    %ebp
+    1053:	c3                   	ret    
+    1054:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    105a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001060 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    1060:	55                   	push   %ebp
+    1061:	89 e5                	mov    %esp,%ebp
+    1063:	8b 55 08             	mov    0x8(%ebp),%edx
+    1066:	53                   	push   %ebx
+    1067:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  while(*p && *p == *q)
+    106a:	0f b6 02             	movzbl (%edx),%eax
+    106d:	84 c0                	test   %al,%al
+    106f:	74 2d                	je     109e <strcmp+0x3e>
+    1071:	0f b6 19             	movzbl (%ecx),%ebx
+    1074:	38 d8                	cmp    %bl,%al
+    1076:	74 0e                	je     1086 <strcmp+0x26>
+    1078:	eb 2b                	jmp    10a5 <strcmp+0x45>
+    107a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1080:	38 c8                	cmp    %cl,%al
+    1082:	75 15                	jne    1099 <strcmp+0x39>
+    p++, q++;
+    1084:	89 d9                	mov    %ebx,%ecx
+    1086:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    1089:	0f b6 02             	movzbl (%edx),%eax
+    p++, q++;
+    108c:	8d 59 01             	lea    0x1(%ecx),%ebx
+  while(*p && *p == *q)
+    108f:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
+    1093:	84 c0                	test   %al,%al
+    1095:	75 e9                	jne    1080 <strcmp+0x20>
+    1097:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    1099:	29 c8                	sub    %ecx,%eax
+}
+    109b:	5b                   	pop    %ebx
+    109c:	5d                   	pop    %ebp
+    109d:	c3                   	ret    
+    109e:	0f b6 09             	movzbl (%ecx),%ecx
+  while(*p && *p == *q)
+    10a1:	31 c0                	xor    %eax,%eax
+    10a3:	eb f4                	jmp    1099 <strcmp+0x39>
+    10a5:	0f b6 cb             	movzbl %bl,%ecx
+    10a8:	eb ef                	jmp    1099 <strcmp+0x39>
+    10aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000010b0 <strlen>:
+
+uint
+strlen(char *s)
+{
+    10b0:	55                   	push   %ebp
+    10b1:	89 e5                	mov    %esp,%ebp
+    10b3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    10b6:	80 39 00             	cmpb   $0x0,(%ecx)
+    10b9:	74 12                	je     10cd <strlen+0x1d>
+    10bb:	31 d2                	xor    %edx,%edx
+    10bd:	8d 76 00             	lea    0x0(%esi),%esi
+    10c0:	83 c2 01             	add    $0x1,%edx
+    10c3:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
+    10c7:	89 d0                	mov    %edx,%eax
+    10c9:	75 f5                	jne    10c0 <strlen+0x10>
+    ;
+  return n;
+}
+    10cb:	5d                   	pop    %ebp
+    10cc:	c3                   	ret    
+  for(n = 0; s[n]; n++)
+    10cd:	31 c0                	xor    %eax,%eax
+}
+    10cf:	5d                   	pop    %ebp
+    10d0:	c3                   	ret    
+    10d1:	eb 0d                	jmp    10e0 <memset>
+    10d3:	90                   	nop
+    10d4:	90                   	nop
+    10d5:	90                   	nop
+    10d6:	90                   	nop
+    10d7:	90                   	nop
+    10d8:	90                   	nop
+    10d9:	90                   	nop
+    10da:	90                   	nop
+    10db:	90                   	nop
+    10dc:	90                   	nop
+    10dd:	90                   	nop
+    10de:	90                   	nop
+    10df:	90                   	nop
+
+000010e0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    10e0:	55                   	push   %ebp
+    10e1:	89 e5                	mov    %esp,%ebp
+    10e3:	8b 55 08             	mov    0x8(%ebp),%edx
+    10e6:	57                   	push   %edi
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    10e7:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    10ea:	8b 45 0c             	mov    0xc(%ebp),%eax
+    10ed:	89 d7                	mov    %edx,%edi
+    10ef:	fc                   	cld    
+    10f0:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    10f2:	89 d0                	mov    %edx,%eax
+    10f4:	5f                   	pop    %edi
+    10f5:	5d                   	pop    %ebp
+    10f6:	c3                   	ret    
+    10f7:	89 f6                	mov    %esi,%esi
+    10f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001100 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    1100:	55                   	push   %ebp
+    1101:	89 e5                	mov    %esp,%ebp
+    1103:	8b 45 08             	mov    0x8(%ebp),%eax
+    1106:	53                   	push   %ebx
+    1107:	8b 55 0c             	mov    0xc(%ebp),%edx
+  for(; *s; s++)
+    110a:	0f b6 18             	movzbl (%eax),%ebx
+    110d:	84 db                	test   %bl,%bl
+    110f:	74 1d                	je     112e <strchr+0x2e>
+    if(*s == c)
+    1111:	38 d3                	cmp    %dl,%bl
+    1113:	89 d1                	mov    %edx,%ecx
+    1115:	75 0d                	jne    1124 <strchr+0x24>
+    1117:	eb 17                	jmp    1130 <strchr+0x30>
+    1119:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1120:	38 ca                	cmp    %cl,%dl
+    1122:	74 0c                	je     1130 <strchr+0x30>
+  for(; *s; s++)
+    1124:	83 c0 01             	add    $0x1,%eax
+    1127:	0f b6 10             	movzbl (%eax),%edx
+    112a:	84 d2                	test   %dl,%dl
+    112c:	75 f2                	jne    1120 <strchr+0x20>
+      return (char*)s;
+  return 0;
+    112e:	31 c0                	xor    %eax,%eax
+}
+    1130:	5b                   	pop    %ebx
+    1131:	5d                   	pop    %ebp
+    1132:	c3                   	ret    
+    1133:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    1139:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
+
+00001140 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    1140:	55                   	push   %ebp
+    1141:	89 e5                	mov    %esp,%ebp
+    1143:	57                   	push   %edi
+    1144:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    1145:	31 f6                	xor    %esi,%esi
+{
+    1147:	53                   	push   %ebx
+    1148:	83 ec 2c             	sub    $0x2c,%esp
+    cc = read(0, &c, 1);
+    114b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    114e:	eb 31                	jmp    1181 <gets+0x41>
+    cc = read(0, &c, 1);
+    1150:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1157:	00 
+    1158:	89 7c 24 04          	mov    %edi,0x4(%esp)
+    115c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    1163:	e8 02 01 00 00       	call   126a <read>
+    if(cc < 1)
+    1168:	85 c0                	test   %eax,%eax
+    116a:	7e 1d                	jle    1189 <gets+0x49>
+      break;
+    buf[i++] = c;
+    116c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  for(i=0; i+1 < max; ){
+    1170:	89 de                	mov    %ebx,%esi
+    buf[i++] = c;
+    1172:	8b 55 08             	mov    0x8(%ebp),%edx
+    if(c == '\n' || c == '\r')
+    1175:	3c 0d                	cmp    $0xd,%al
+    buf[i++] = c;
+    1177:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+    if(c == '\n' || c == '\r')
+    117b:	74 0c                	je     1189 <gets+0x49>
+    117d:	3c 0a                	cmp    $0xa,%al
+    117f:	74 08                	je     1189 <gets+0x49>
+  for(i=0; i+1 < max; ){
+    1181:	8d 5e 01             	lea    0x1(%esi),%ebx
+    1184:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    1187:	7c c7                	jl     1150 <gets+0x10>
+      break;
+  }
+  buf[i] = '\0';
+    1189:	8b 45 08             	mov    0x8(%ebp),%eax
+    118c:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
+  return buf;
+}
+    1190:	83 c4 2c             	add    $0x2c,%esp
+    1193:	5b                   	pop    %ebx
+    1194:	5e                   	pop    %esi
+    1195:	5f                   	pop    %edi
+    1196:	5d                   	pop    %ebp
+    1197:	c3                   	ret    
+    1198:	90                   	nop
+    1199:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000011a0 <stat>:
+
+int
+stat(char *n, struct stat *st)
+{
+    11a0:	55                   	push   %ebp
+    11a1:	89 e5                	mov    %esp,%ebp
+    11a3:	56                   	push   %esi
+    11a4:	53                   	push   %ebx
+    11a5:	83 ec 10             	sub    $0x10,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    11a8:	8b 45 08             	mov    0x8(%ebp),%eax
+    11ab:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+    11b2:	00 
+    11b3:	89 04 24             	mov    %eax,(%esp)
+    11b6:	e8 d7 00 00 00       	call   1292 <open>
+  if(fd < 0)
+    11bb:	85 c0                	test   %eax,%eax
+  fd = open(n, O_RDONLY);
+    11bd:	89 c3                	mov    %eax,%ebx
+  if(fd < 0)
+    11bf:	78 27                	js     11e8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    11c1:	8b 45 0c             	mov    0xc(%ebp),%eax
+    11c4:	89 1c 24             	mov    %ebx,(%esp)
+    11c7:	89 44 24 04          	mov    %eax,0x4(%esp)
+    11cb:	e8 da 00 00 00       	call   12aa <fstat>
+  close(fd);
+    11d0:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    11d3:	89 c6                	mov    %eax,%esi
+  close(fd);
+    11d5:	e8 a0 00 00 00       	call   127a <close>
+  return r;
+    11da:	89 f0                	mov    %esi,%eax
+}
+    11dc:	83 c4 10             	add    $0x10,%esp
+    11df:	5b                   	pop    %ebx
+    11e0:	5e                   	pop    %esi
+    11e1:	5d                   	pop    %ebp
+    11e2:	c3                   	ret    
+    11e3:	90                   	nop
+    11e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    11e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    11ed:	eb ed                	jmp    11dc <stat+0x3c>
+    11ef:	90                   	nop
+
+000011f0 <atoi>:
+
+int
+atoi(const char *s)
+{
+    11f0:	55                   	push   %ebp
+    11f1:	89 e5                	mov    %esp,%ebp
+    11f3:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    11f6:	53                   	push   %ebx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    11f7:	0f be 11             	movsbl (%ecx),%edx
+    11fa:	8d 42 d0             	lea    -0x30(%edx),%eax
+    11fd:	3c 09                	cmp    $0x9,%al
+  n = 0;
+    11ff:	b8 00 00 00 00       	mov    $0x0,%eax
+  while('0' <= *s && *s <= '9')
+    1204:	77 17                	ja     121d <atoi+0x2d>
+    1206:	66 90                	xchg   %ax,%ax
+    n = n*10 + *s++ - '0';
+    1208:	83 c1 01             	add    $0x1,%ecx
+    120b:	8d 04 80             	lea    (%eax,%eax,4),%eax
+    120e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+  while('0' <= *s && *s <= '9')
+    1212:	0f be 11             	movsbl (%ecx),%edx
+    1215:	8d 5a d0             	lea    -0x30(%edx),%ebx
+    1218:	80 fb 09             	cmp    $0x9,%bl
+    121b:	76 eb                	jbe    1208 <atoi+0x18>
+  return n;
+}
+    121d:	5b                   	pop    %ebx
+    121e:	5d                   	pop    %ebp
+    121f:	c3                   	ret    
+
+00001220 <memmove>:
+
+void*
+memmove(void *vdst, void *vsrc, int n)
+{
+    1220:	55                   	push   %ebp
+  char *dst, *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    1221:	31 d2                	xor    %edx,%edx
+{
+    1223:	89 e5                	mov    %esp,%ebp
+    1225:	56                   	push   %esi
+    1226:	8b 45 08             	mov    0x8(%ebp),%eax
+    1229:	53                   	push   %ebx
+    122a:	8b 5d 10             	mov    0x10(%ebp),%ebx
+    122d:	8b 75 0c             	mov    0xc(%ebp),%esi
+  while(n-- > 0)
+    1230:	85 db                	test   %ebx,%ebx
+    1232:	7e 12                	jle    1246 <memmove+0x26>
+    1234:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    *dst++ = *src++;
+    1238:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
+    123c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
+    123f:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0)
+    1242:	39 da                	cmp    %ebx,%edx
+    1244:	75 f2                	jne    1238 <memmove+0x18>
+  return vdst;
+}
+    1246:	5b                   	pop    %ebx
+    1247:	5e                   	pop    %esi
+    1248:	5d                   	pop    %ebp
+    1249:	c3                   	ret    
+
+0000124a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    124a:	b8 01 00 00 00       	mov    $0x1,%eax
+    124f:	cd 40                	int    $0x40
+    1251:	c3                   	ret    
+
+00001252 <exit>:
+SYSCALL(exit)
+    1252:	b8 02 00 00 00       	mov    $0x2,%eax
+    1257:	cd 40                	int    $0x40
+    1259:	c3                   	ret    
+
+0000125a <wait>:
+SYSCALL(wait)
+    125a:	b8 03 00 00 00       	mov    $0x3,%eax
+    125f:	cd 40                	int    $0x40
+    1261:	c3                   	ret    
+
+00001262 <pipe>:
+SYSCALL(pipe)
+    1262:	b8 04 00 00 00       	mov    $0x4,%eax
+    1267:	cd 40                	int    $0x40
+    1269:	c3                   	ret    
+
+0000126a <read>:
+SYSCALL(read)
+    126a:	b8 05 00 00 00       	mov    $0x5,%eax
+    126f:	cd 40                	int    $0x40
+    1271:	c3                   	ret    
+
+00001272 <write>:
+SYSCALL(write)
+    1272:	b8 10 00 00 00       	mov    $0x10,%eax
+    1277:	cd 40                	int    $0x40
+    1279:	c3                   	ret    
+
+0000127a <close>:
+SYSCALL(close)
+    127a:	b8 15 00 00 00       	mov    $0x15,%eax
+    127f:	cd 40                	int    $0x40
+    1281:	c3                   	ret    
+
+00001282 <kill>:
+SYSCALL(kill)
+    1282:	b8 06 00 00 00       	mov    $0x6,%eax
+    1287:	cd 40                	int    $0x40
+    1289:	c3                   	ret    
+
+0000128a <exec>:
+SYSCALL(exec)
+    128a:	b8 07 00 00 00       	mov    $0x7,%eax
+    128f:	cd 40                	int    $0x40
+    1291:	c3                   	ret    
+
+00001292 <open>:
+SYSCALL(open)
+    1292:	b8 0f 00 00 00       	mov    $0xf,%eax
+    1297:	cd 40                	int    $0x40
+    1299:	c3                   	ret    
+
+0000129a <mknod>:
+SYSCALL(mknod)
+    129a:	b8 11 00 00 00       	mov    $0x11,%eax
+    129f:	cd 40                	int    $0x40
+    12a1:	c3                   	ret    
+
+000012a2 <unlink>:
+SYSCALL(unlink)
+    12a2:	b8 12 00 00 00       	mov    $0x12,%eax
+    12a7:	cd 40                	int    $0x40
+    12a9:	c3                   	ret    
+
+000012aa <fstat>:
+SYSCALL(fstat)
+    12aa:	b8 08 00 00 00       	mov    $0x8,%eax
+    12af:	cd 40                	int    $0x40
+    12b1:	c3                   	ret    
+
+000012b2 <link>:
+SYSCALL(link)
+    12b2:	b8 13 00 00 00       	mov    $0x13,%eax
+    12b7:	cd 40                	int    $0x40
+    12b9:	c3                   	ret    
+
+000012ba <mkdir>:
+SYSCALL(mkdir)
+    12ba:	b8 14 00 00 00       	mov    $0x14,%eax
+    12bf:	cd 40                	int    $0x40
+    12c1:	c3                   	ret    
+
+000012c2 <chdir>:
+SYSCALL(chdir)
+    12c2:	b8 09 00 00 00       	mov    $0x9,%eax
+    12c7:	cd 40                	int    $0x40
+    12c9:	c3                   	ret    
+
+000012ca <dup>:
+SYSCALL(dup)
+    12ca:	b8 0a 00 00 00       	mov    $0xa,%eax
+    12cf:	cd 40                	int    $0x40
+    12d1:	c3                   	ret    
+
+000012d2 <getpid>:
+SYSCALL(getpid)
+    12d2:	b8 0b 00 00 00       	mov    $0xb,%eax
+    12d7:	cd 40                	int    $0x40
+    12d9:	c3                   	ret    
+
+000012da <sbrk>:
+SYSCALL(sbrk)
+    12da:	b8 0c 00 00 00       	mov    $0xc,%eax
+    12df:	cd 40                	int    $0x40
+    12e1:	c3                   	ret    
+
+000012e2 <sleep>:
+SYSCALL(sleep)
+    12e2:	b8 0d 00 00 00       	mov    $0xd,%eax
+    12e7:	cd 40                	int    $0x40
+    12e9:	c3                   	ret    
+
+000012ea <uptime>:
+SYSCALL(uptime)
+    12ea:	b8 0e 00 00 00       	mov    $0xe,%eax
+    12ef:	cd 40                	int    $0x40
+    12f1:	c3                   	ret    
+
+000012f2 <shm_open>:
+SYSCALL(shm_open)
+    12f2:	b8 16 00 00 00       	mov    $0x16,%eax
+    12f7:	cd 40                	int    $0x40
+    12f9:	c3                   	ret    
+
+000012fa <shm_close>:
+SYSCALL(shm_close)	
+    12fa:	b8 17 00 00 00       	mov    $0x17,%eax
+    12ff:	cd 40                	int    $0x40
+    1301:	c3                   	ret    
+    1302:	66 90                	xchg   %ax,%ax
+    1304:	66 90                	xchg   %ax,%ax
+    1306:	66 90                	xchg   %ax,%ax
+    1308:	66 90                	xchg   %ax,%ax
+    130a:	66 90                	xchg   %ax,%ax
+    130c:	66 90                	xchg   %ax,%ax
+    130e:	66 90                	xchg   %ax,%ax
+
+00001310 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1310:	55                   	push   %ebp
+    1311:	89 e5                	mov    %esp,%ebp
+    1313:	57                   	push   %edi
+    1314:	56                   	push   %esi
+    1315:	89 c6                	mov    %eax,%esi
+    1317:	53                   	push   %ebx
+    1318:	83 ec 4c             	sub    $0x4c,%esp
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    131b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    131e:	85 db                	test   %ebx,%ebx
+    1320:	74 09                	je     132b <printint+0x1b>
+    1322:	89 d0                	mov    %edx,%eax
+    1324:	c1 e8 1f             	shr    $0x1f,%eax
+    1327:	84 c0                	test   %al,%al
+    1329:	75 75                	jne    13a0 <printint+0x90>
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+    132b:	89 d0                	mov    %edx,%eax
+  neg = 0;
+    132d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+    1334:	89 75 c0             	mov    %esi,-0x40(%ebp)
+  }
+
+  i = 0;
+    1337:	31 ff                	xor    %edi,%edi
+    1339:	89 ce                	mov    %ecx,%esi
+    133b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+    133e:	eb 02                	jmp    1342 <printint+0x32>
+  do{
+    buf[i++] = digits[x % base];
+    1340:	89 cf                	mov    %ecx,%edi
+    1342:	31 d2                	xor    %edx,%edx
+    1344:	f7 f6                	div    %esi
+    1346:	8d 4f 01             	lea    0x1(%edi),%ecx
+    1349:	0f b6 92 58 17 00 00 	movzbl 0x1758(%edx),%edx
+  }while((x /= base) != 0);
+    1350:	85 c0                	test   %eax,%eax
+    buf[i++] = digits[x % base];
+    1352:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
+  }while((x /= base) != 0);
+    1355:	75 e9                	jne    1340 <printint+0x30>
+  if(neg)
+    1357:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+    buf[i++] = digits[x % base];
+    135a:	89 c8                	mov    %ecx,%eax
+    135c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+  if(neg)
+    135f:	85 d2                	test   %edx,%edx
+    1361:	74 08                	je     136b <printint+0x5b>
+    buf[i++] = '-';
+    1363:	8d 4f 02             	lea    0x2(%edi),%ecx
+    1366:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+
+  while(--i >= 0)
+    136b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+    136e:	66 90                	xchg   %ax,%ax
+    1370:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+    1375:	83 ef 01             	sub    $0x1,%edi
+  write(fd, &c, 1);
+    1378:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    137f:	00 
+    1380:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+    1384:	89 34 24             	mov    %esi,(%esp)
+    1387:	88 45 d7             	mov    %al,-0x29(%ebp)
+    138a:	e8 e3 fe ff ff       	call   1272 <write>
+  while(--i >= 0)
+    138f:	83 ff ff             	cmp    $0xffffffff,%edi
+    1392:	75 dc                	jne    1370 <printint+0x60>
+    putc(fd, buf[i]);
+}
+    1394:	83 c4 4c             	add    $0x4c,%esp
+    1397:	5b                   	pop    %ebx
+    1398:	5e                   	pop    %esi
+    1399:	5f                   	pop    %edi
+    139a:	5d                   	pop    %ebp
+    139b:	c3                   	ret    
+    139c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    x = -xx;
+    13a0:	89 d0                	mov    %edx,%eax
+    13a2:	f7 d8                	neg    %eax
+    neg = 1;
+    13a4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+    13ab:	eb 87                	jmp    1334 <printint+0x24>
+    13ad:	8d 76 00             	lea    0x0(%esi),%esi
+
+000013b0 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, char *fmt, ...)
+{
+    13b0:	55                   	push   %ebp
+    13b1:	89 e5                	mov    %esp,%ebp
+    13b3:	57                   	push   %edi
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    13b4:	31 ff                	xor    %edi,%edi
+{
+    13b6:	56                   	push   %esi
+    13b7:	53                   	push   %ebx
+    13b8:	83 ec 3c             	sub    $0x3c,%esp
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    13bb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  ap = (uint*)(void*)&fmt + 1;
+    13be:	8d 45 10             	lea    0x10(%ebp),%eax
+{
+    13c1:	8b 75 08             	mov    0x8(%ebp),%esi
+  ap = (uint*)(void*)&fmt + 1;
+    13c4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  for(i = 0; fmt[i]; i++){
+    13c7:	0f b6 13             	movzbl (%ebx),%edx
+    13ca:	83 c3 01             	add    $0x1,%ebx
+    13cd:	84 d2                	test   %dl,%dl
+    13cf:	75 39                	jne    140a <printf+0x5a>
+    13d1:	e9 c2 00 00 00       	jmp    1498 <printf+0xe8>
+    13d6:	66 90                	xchg   %ax,%ax
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+    13d8:	83 fa 25             	cmp    $0x25,%edx
+    13db:	0f 84 bf 00 00 00    	je     14a0 <printf+0xf0>
+  write(fd, &c, 1);
+    13e1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+    13e4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    13eb:	00 
+    13ec:	89 44 24 04          	mov    %eax,0x4(%esp)
+    13f0:	89 34 24             	mov    %esi,(%esp)
+        state = '%';
+      } else {
+        putc(fd, c);
+    13f3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+  write(fd, &c, 1);
+    13f6:	e8 77 fe ff ff       	call   1272 <write>
+    13fb:	83 c3 01             	add    $0x1,%ebx
+  for(i = 0; fmt[i]; i++){
+    13fe:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    1402:	84 d2                	test   %dl,%dl
+    1404:	0f 84 8e 00 00 00    	je     1498 <printf+0xe8>
+    if(state == 0){
+    140a:	85 ff                	test   %edi,%edi
+    c = fmt[i] & 0xff;
+    140c:	0f be c2             	movsbl %dl,%eax
+    if(state == 0){
+    140f:	74 c7                	je     13d8 <printf+0x28>
+      }
+    } else if(state == '%'){
+    1411:	83 ff 25             	cmp    $0x25,%edi
+    1414:	75 e5                	jne    13fb <printf+0x4b>
+      if(c == 'd'){
+    1416:	83 fa 64             	cmp    $0x64,%edx
+    1419:	0f 84 31 01 00 00    	je     1550 <printf+0x1a0>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    141f:	25 f7 00 00 00       	and    $0xf7,%eax
+    1424:	83 f8 70             	cmp    $0x70,%eax
+    1427:	0f 84 83 00 00 00    	je     14b0 <printf+0x100>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    142d:	83 fa 73             	cmp    $0x73,%edx
+    1430:	0f 84 a2 00 00 00    	je     14d8 <printf+0x128>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    1436:	83 fa 63             	cmp    $0x63,%edx
+    1439:	0f 84 35 01 00 00    	je     1574 <printf+0x1c4>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    143f:	83 fa 25             	cmp    $0x25,%edx
+    1442:	0f 84 e0 00 00 00    	je     1528 <printf+0x178>
+  write(fd, &c, 1);
+    1448:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    144b:	83 c3 01             	add    $0x1,%ebx
+    144e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1455:	00 
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    1456:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    1458:	89 44 24 04          	mov    %eax,0x4(%esp)
+    145c:	89 34 24             	mov    %esi,(%esp)
+    145f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+    1462:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+    1466:	e8 07 fe ff ff       	call   1272 <write>
+        putc(fd, c);
+    146b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  write(fd, &c, 1);
+    146e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    1471:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1478:	00 
+    1479:	89 44 24 04          	mov    %eax,0x4(%esp)
+    147d:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, c);
+    1480:	88 55 e7             	mov    %dl,-0x19(%ebp)
+  write(fd, &c, 1);
+    1483:	e8 ea fd ff ff       	call   1272 <write>
+  for(i = 0; fmt[i]; i++){
+    1488:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+    148c:	84 d2                	test   %dl,%dl
+    148e:	0f 85 76 ff ff ff    	jne    140a <printf+0x5a>
+    1494:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+}
+    1498:	83 c4 3c             	add    $0x3c,%esp
+    149b:	5b                   	pop    %ebx
+    149c:	5e                   	pop    %esi
+    149d:	5f                   	pop    %edi
+    149e:	5d                   	pop    %ebp
+    149f:	c3                   	ret    
+        state = '%';
+    14a0:	bf 25 00 00 00       	mov    $0x25,%edi
+    14a5:	e9 51 ff ff ff       	jmp    13fb <printf+0x4b>
+    14aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 16, 0);
+    14b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    14b3:	b9 10 00 00 00       	mov    $0x10,%ecx
+      state = 0;
+    14b8:	31 ff                	xor    %edi,%edi
+        printint(fd, *ap, 16, 0);
+    14ba:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    14c1:	8b 10                	mov    (%eax),%edx
+    14c3:	89 f0                	mov    %esi,%eax
+    14c5:	e8 46 fe ff ff       	call   1310 <printint>
+        ap++;
+    14ca:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    14ce:	e9 28 ff ff ff       	jmp    13fb <printf+0x4b>
+    14d3:	90                   	nop
+    14d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        s = (char*)*ap;
+    14d8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+        ap++;
+    14db:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+        s = (char*)*ap;
+    14df:	8b 38                	mov    (%eax),%edi
+          s = "(null)";
+    14e1:	b8 51 17 00 00       	mov    $0x1751,%eax
+    14e6:	85 ff                	test   %edi,%edi
+    14e8:	0f 44 f8             	cmove  %eax,%edi
+        while(*s != 0){
+    14eb:	0f b6 07             	movzbl (%edi),%eax
+    14ee:	84 c0                	test   %al,%al
+    14f0:	74 2a                	je     151c <printf+0x16c>
+    14f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    14f8:	88 45 e3             	mov    %al,-0x1d(%ebp)
+  write(fd, &c, 1);
+    14fb:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+          s++;
+    14fe:	83 c7 01             	add    $0x1,%edi
+  write(fd, &c, 1);
+    1501:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1508:	00 
+    1509:	89 44 24 04          	mov    %eax,0x4(%esp)
+    150d:	89 34 24             	mov    %esi,(%esp)
+    1510:	e8 5d fd ff ff       	call   1272 <write>
+        while(*s != 0){
+    1515:	0f b6 07             	movzbl (%edi),%eax
+    1518:	84 c0                	test   %al,%al
+    151a:	75 dc                	jne    14f8 <printf+0x148>
+      state = 0;
+    151c:	31 ff                	xor    %edi,%edi
+    151e:	e9 d8 fe ff ff       	jmp    13fb <printf+0x4b>
+    1523:	90                   	nop
+    1524:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  write(fd, &c, 1);
+    1528:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+      state = 0;
+    152b:	31 ff                	xor    %edi,%edi
+  write(fd, &c, 1);
+    152d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1534:	00 
+    1535:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1539:	89 34 24             	mov    %esi,(%esp)
+    153c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+    1540:	e8 2d fd ff ff       	call   1272 <write>
+    1545:	e9 b1 fe ff ff       	jmp    13fb <printf+0x4b>
+    154a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        printint(fd, *ap, 10, 1);
+    1550:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+    1553:	b9 0a 00 00 00       	mov    $0xa,%ecx
+      state = 0;
+    1558:	66 31 ff             	xor    %di,%di
+        printint(fd, *ap, 10, 1);
+    155b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    1562:	8b 10                	mov    (%eax),%edx
+    1564:	89 f0                	mov    %esi,%eax
+    1566:	e8 a5 fd ff ff       	call   1310 <printint>
+        ap++;
+    156b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    156f:	e9 87 fe ff ff       	jmp    13fb <printf+0x4b>
+        putc(fd, *ap);
+    1574:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+      state = 0;
+    1577:	31 ff                	xor    %edi,%edi
+        putc(fd, *ap);
+    1579:	8b 00                	mov    (%eax),%eax
+  write(fd, &c, 1);
+    157b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+    1582:	00 
+    1583:	89 34 24             	mov    %esi,(%esp)
+        putc(fd, *ap);
+    1586:	88 45 e4             	mov    %al,-0x1c(%ebp)
+  write(fd, &c, 1);
+    1589:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+    158c:	89 44 24 04          	mov    %eax,0x4(%esp)
+    1590:	e8 dd fc ff ff       	call   1272 <write>
+        ap++;
+    1595:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+    1599:	e9 5d fe ff ff       	jmp    13fb <printf+0x4b>
+    159e:	66 90                	xchg   %ax,%ax
+
+000015a0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    15a0:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15a1:	a1 10 1a 00 00       	mov    0x1a10,%eax
+{
+    15a6:	89 e5                	mov    %esp,%ebp
+    15a8:	57                   	push   %edi
+    15a9:	56                   	push   %esi
+    15aa:	53                   	push   %ebx
+    15ab:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15ae:	8b 08                	mov    (%eax),%ecx
+  bp = (Header*)ap - 1;
+    15b0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15b3:	39 d0                	cmp    %edx,%eax
+    15b5:	72 11                	jb     15c8 <free+0x28>
+    15b7:	90                   	nop
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15b8:	39 c8                	cmp    %ecx,%eax
+    15ba:	72 04                	jb     15c0 <free+0x20>
+    15bc:	39 ca                	cmp    %ecx,%edx
+    15be:	72 10                	jb     15d0 <free+0x30>
+    15c0:	89 c8                	mov    %ecx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15c2:	39 d0                	cmp    %edx,%eax
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15c4:	8b 08                	mov    (%eax),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    15c6:	73 f0                	jae    15b8 <free+0x18>
+    15c8:	39 ca                	cmp    %ecx,%edx
+    15ca:	72 04                	jb     15d0 <free+0x30>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    15cc:	39 c8                	cmp    %ecx,%eax
+    15ce:	72 f0                	jb     15c0 <free+0x20>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    15d0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    15d3:	8d 3c f2             	lea    (%edx,%esi,8),%edi
+    15d6:	39 cf                	cmp    %ecx,%edi
+    15d8:	74 1e                	je     15f8 <free+0x58>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    15da:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    15dd:	8b 48 04             	mov    0x4(%eax),%ecx
+    15e0:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    15e3:	39 f2                	cmp    %esi,%edx
+    15e5:	74 28                	je     160f <free+0x6f>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    15e7:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    15e9:	a3 10 1a 00 00       	mov    %eax,0x1a10
+}
+    15ee:	5b                   	pop    %ebx
+    15ef:	5e                   	pop    %esi
+    15f0:	5f                   	pop    %edi
+    15f1:	5d                   	pop    %ebp
+    15f2:	c3                   	ret    
+    15f3:	90                   	nop
+    15f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp->s.size += p->s.ptr->s.size;
+    15f8:	03 71 04             	add    0x4(%ecx),%esi
+    15fb:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    15fe:	8b 08                	mov    (%eax),%ecx
+    1600:	8b 09                	mov    (%ecx),%ecx
+    1602:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    1605:	8b 48 04             	mov    0x4(%eax),%ecx
+    1608:	8d 34 c8             	lea    (%eax,%ecx,8),%esi
+    160b:	39 f2                	cmp    %esi,%edx
+    160d:	75 d8                	jne    15e7 <free+0x47>
+    p->s.size += bp->s.size;
+    160f:	03 4b fc             	add    -0x4(%ebx),%ecx
+  freep = p;
+    1612:	a3 10 1a 00 00       	mov    %eax,0x1a10
+    p->s.size += bp->s.size;
+    1617:	89 48 04             	mov    %ecx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    161a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    161d:	89 10                	mov    %edx,(%eax)
+}
+    161f:	5b                   	pop    %ebx
+    1620:	5e                   	pop    %esi
+    1621:	5f                   	pop    %edi
+    1622:	5d                   	pop    %ebp
+    1623:	c3                   	ret    
+    1624:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    162a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
+
+00001630 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1630:	55                   	push   %ebp
+    1631:	89 e5                	mov    %esp,%ebp
+    1633:	57                   	push   %edi
+    1634:	56                   	push   %esi
+    1635:	53                   	push   %ebx
+    1636:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1639:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    163c:	8b 1d 10 1a 00 00    	mov    0x1a10,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1642:	8d 48 07             	lea    0x7(%eax),%ecx
+    1645:	c1 e9 03             	shr    $0x3,%ecx
+  if((prevp = freep) == 0){
+    1648:	85 db                	test   %ebx,%ebx
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    164a:	8d 71 01             	lea    0x1(%ecx),%esi
+  if((prevp = freep) == 0){
+    164d:	0f 84 9b 00 00 00    	je     16ee <malloc+0xbe>
+    1653:	8b 13                	mov    (%ebx),%edx
+    1655:	8b 7a 04             	mov    0x4(%edx),%edi
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+    1658:	39 fe                	cmp    %edi,%esi
+    165a:	76 64                	jbe    16c0 <malloc+0x90>
+    165c:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
+  if(nu < 4096)
+    1663:	bb 00 80 00 00       	mov    $0x8000,%ebx
+    1668:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    166b:	eb 0e                	jmp    167b <malloc+0x4b>
+    166d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1670:	8b 02                	mov    (%edx),%eax
+    if(p->s.size >= nunits){
+    1672:	8b 78 04             	mov    0x4(%eax),%edi
+    1675:	39 fe                	cmp    %edi,%esi
+    1677:	76 4f                	jbe    16c8 <malloc+0x98>
+    1679:	89 c2                	mov    %eax,%edx
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    167b:	3b 15 10 1a 00 00    	cmp    0x1a10,%edx
+    1681:	75 ed                	jne    1670 <malloc+0x40>
+  if(nu < 4096)
+    1683:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1686:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    168c:	bf 00 10 00 00       	mov    $0x1000,%edi
+    1691:	0f 43 fe             	cmovae %esi,%edi
+    1694:	0f 42 c3             	cmovb  %ebx,%eax
+  p = sbrk(nu * sizeof(Header));
+    1697:	89 04 24             	mov    %eax,(%esp)
+    169a:	e8 3b fc ff ff       	call   12da <sbrk>
+  if(p == (char*)-1)
+    169f:	83 f8 ff             	cmp    $0xffffffff,%eax
+    16a2:	74 18                	je     16bc <malloc+0x8c>
+  hp->s.size = nu;
+    16a4:	89 78 04             	mov    %edi,0x4(%eax)
+  free((void*)(hp + 1));
+    16a7:	83 c0 08             	add    $0x8,%eax
+    16aa:	89 04 24             	mov    %eax,(%esp)
+    16ad:	e8 ee fe ff ff       	call   15a0 <free>
+  return freep;
+    16b2:	8b 15 10 1a 00 00    	mov    0x1a10,%edx
+      if((p = morecore(nunits)) == 0)
+    16b8:	85 d2                	test   %edx,%edx
+    16ba:	75 b4                	jne    1670 <malloc+0x40>
+        return 0;
+    16bc:	31 c0                	xor    %eax,%eax
+    16be:	eb 20                	jmp    16e0 <malloc+0xb0>
+    if(p->s.size >= nunits){
+    16c0:	89 d0                	mov    %edx,%eax
+    16c2:	89 da                	mov    %ebx,%edx
+    16c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    16c8:	39 fe                	cmp    %edi,%esi
+    16ca:	74 1c                	je     16e8 <malloc+0xb8>
+        p->s.size -= nunits;
+    16cc:	29 f7                	sub    %esi,%edi
+    16ce:	89 78 04             	mov    %edi,0x4(%eax)
+        p += p->s.size;
+    16d1:	8d 04 f8             	lea    (%eax,%edi,8),%eax
+        p->s.size = nunits;
+    16d4:	89 70 04             	mov    %esi,0x4(%eax)
+      freep = prevp;
+    16d7:	89 15 10 1a 00 00    	mov    %edx,0x1a10
+      return (void*)(p + 1);
+    16dd:	83 c0 08             	add    $0x8,%eax
+  }
+}
+    16e0:	83 c4 1c             	add    $0x1c,%esp
+    16e3:	5b                   	pop    %ebx
+    16e4:	5e                   	pop    %esi
+    16e5:	5f                   	pop    %edi
+    16e6:	5d                   	pop    %ebp
+    16e7:	c3                   	ret    
+        prevp->s.ptr = p->s.ptr;
+    16e8:	8b 08                	mov    (%eax),%ecx
+    16ea:	89 0a                	mov    %ecx,(%edx)
+    16ec:	eb e9                	jmp    16d7 <malloc+0xa7>
+    base.s.ptr = freep = prevp = &base;
+    16ee:	c7 05 10 1a 00 00 14 	movl   $0x1a14,0x1a10
+    16f5:	1a 00 00 
+    base.s.size = 0;
+    16f8:	ba 14 1a 00 00       	mov    $0x1a14,%edx
+    base.s.ptr = freep = prevp = &base;
+    16fd:	c7 05 14 1a 00 00 14 	movl   $0x1a14,0x1a14
+    1704:	1a 00 00 
+    base.s.size = 0;
+    1707:	c7 05 18 1a 00 00 00 	movl   $0x0,0x1a18
+    170e:	00 00 00 
+    1711:	e9 46 ff ff ff       	jmp    165c <malloc+0x2c>
+    1716:	66 90                	xchg   %ax,%ax
+    1718:	66 90                	xchg   %ax,%ax
+    171a:	66 90                	xchg   %ax,%ax
+    171c:	66 90                	xchg   %ax,%ax
+    171e:	66 90                	xchg   %ax,%ax
+
+00001720 <uacquire>:
+#include "uspinlock.h"
+#include "x86.h"
+
+void
+uacquire(struct uspinlock *lk)
+{
+    1720:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+    1721:	b9 01 00 00 00       	mov    $0x1,%ecx
+    1726:	89 e5                	mov    %esp,%ebp
+    1728:	8b 55 08             	mov    0x8(%ebp),%edx
+    172b:	90                   	nop
+    172c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1730:	89 c8                	mov    %ecx,%eax
+    1732:	f0 87 02             	lock xchg %eax,(%edx)
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    1735:	85 c0                	test   %eax,%eax
+    1737:	75 f7                	jne    1730 <uacquire+0x10>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+    1739:	0f ae f0             	mfence 
+}
+    173c:	5d                   	pop    %ebp
+    173d:	c3                   	ret    
+    173e:	66 90                	xchg   %ax,%ax
+
+00001740 <urelease>:
+
+void urelease (struct uspinlock *lk) {
+    1740:	55                   	push   %ebp
+    1741:	89 e5                	mov    %esp,%ebp
+    1743:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+    1746:	0f ae f0             	mfence 
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+    1749:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+    174f:	5d                   	pop    %ebp
+    1750:	c3                   	ret    
diff --git a/zombie.c b/zombie.c
index c96b92d..ee817da 100644
--- a/zombie.c
+++ b/zombie.c
@@ -10,5 +10,5 @@ main(void)
 {
   if(fork() > 0)
     sleep(5);  // Let child exit before parent.
-  exit(0);
+  exit();
 }
diff --git a/zombie.d b/zombie.d
new file mode 100644
index 0000000..c3e36f5
--- /dev/null
+++ b/zombie.d
@@ -0,0 +1 @@
+zombie.o: zombie.c /usr/include/stdc-predef.h types.h stat.h user.h
diff --git a/zombie.o b/zombie.o
new file mode 100644
index 0000000..1370c12
Binary files /dev/null and b/zombie.o differ
diff --git a/zombie.sym b/zombie.sym
new file mode 100644
index 0000000..527ba72
--- /dev/null
+++ b/zombie.sym
@@ -0,0 +1,62 @@
+00001000 .text
+00001751 .rodata
+0000176c .eh_frame
+00001a10 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 zombie.c
+00000000 ulib.c
+00000000 printf.c
+00001310 printint
+00001758 digits.1359
+00000000 umalloc.c
+00001a10 freep
+00001a14 base
+00000000 uspinlock.c
+00001030 strcpy
+000013b0 printf
+00001220 memmove
+0000129a mknod
+000012f2 shm_open
+00001140 gets
+000012d2 getpid
+00001630 malloc
+000012e2 sleep
+00001262 pipe
+00001272 write
+000012aa fstat
+00001282 kill
+000012c2 chdir
+0000128a exec
+0000125a wait
+0000126a read
+000012a2 unlink
+00001720 uacquire
+0000124a fork
+000012da sbrk
+000012fa shm_close
+000012ea uptime
+00001a10 __bss_start
+000010e0 memset
+00001000 main
+00001060 strcmp
+000012ca dup
+000011a0 stat
+00001a10 _edata
+00001a1c _end
+000012b2 link
+00001252 exit
+000011f0 atoi
+000010b0 strlen
+00001292 open
+00001100 strchr
+000012ba mkdir
+0000127a close
+00001740 urelease
+000015a0 free
